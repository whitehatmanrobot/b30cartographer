NULL;
    DWORD cAttrs = 0;

    CWaitCursor Wait;

    HRESULT hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        return hr;
    }

    dspAssert(cAttrs);
    if (cAttrs != 1)
    {
        return E_FAIL;
    }
    dspAssert(pAttrs);

    PUCHAR saCount = GetSidSubAuthorityCount(pAttrs->pADsValues->OctetString.lpValue);
    DWORD dwGroupRID = *GetSidSubAuthority(pAttrs->pADsValues->OctetString.lpValue, (ULONG)*saCount - 1);
    dspDebugOut((DEB_ITRACE, "Group RID = %d\n", dwGroupRID));

    // This is the highest special account RID or alias in ntseapi.h
    if ( dwGroupRID <= DOMAIN_ALIAS_RID_RAS_SERVERS )
        fIsSpecialAccount = true;

    FreeADsMem(pAttrs);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnApply(void)
{
    TRACE(CDsGroupGenObjPage,OnApply);
    HRESULT hr = S_OK;
    ADSVALUE ADsValueType = {ADSTYPE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoDesc = m_rgpAttrMap[DESCR_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoSAMn = m_rgpAttrMap[SAMNAME_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoMail = m_rgpAttrMap[EMAIL_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoComm = m_rgpAttrMap[COMMENT_IDX]->AttrInfo;
    ADS_ATTR_INFO AttrInfoType = {g_wzGroupType, ADS_ATTR_UPDATE,
                                  ADSTYPE_INTEGER, &ADsValueType, 1};

    ADS_ATTR_INFO rgAttrs[5];
    DWORD cAttrs = 0;

    ADSVALUE ADsValueDesc = {m_rgpAttrMap[DESCR_IDX]->AttrInfo.dwADsType, NULL};
    ADSVALUE ADsValueSAMname = {m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.dwADsType, NULL};
    ADSVALUE ADsValueComm = {m_rgpAttrMap[COMMENT_IDX]->AttrInfo.dwADsType, NULL};
    ADSVALUE ADsValueMail = {m_rgpAttrMap[EMAIL_IDX]->AttrInfo.dwADsType, NULL};

    //
    // Description.
    //
    AttrInfoDesc.pADsValues = &ADsValueDesc;
    AttrInfoDesc.dwNumValues = 1;
    LPTSTR ptsz;

    if (m_fDescrDirty)
    {
        dspAssert(m_fDescrWritable);

        ptsz = new TCHAR[m_rgpAttrMap[DESCR_IDX]->nSizeLimit + 1];
        CHECK_NULL(ptsz, return -1);

        if (GetDlgItemText(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID,
                           ptsz, m_rgpAttrMap[DESCR_IDX]->nSizeLimit + 1) == 0)
        {
            // An empty control means remove the attribute value from the
            // object.
            //
            AttrInfoDesc.dwNumValues = 0;
            AttrInfoDesc.pADsValues = NULL;
            AttrInfoDesc.dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            if (!TcharToUnicode(ptsz, &ADsValueDesc.CaseIgnoreString))
            {
                delete[] ptsz;
                return -1;
            }
        }
        delete[] ptsz;
        rgAttrs[cAttrs++] = AttrInfoDesc;
    }

    //
    // SAM name.
    //
    AttrInfoSAMn.pADsValues = &ADsValueSAMname;
    AttrInfoSAMn.dwNumValues = 1;

    if (m_fSamNameDirty)
    {
      dspAssert(m_fSamNameWritable);

      ptsz = new TCHAR[m_rgpAttrMap[SAMNAME_IDX]->nSizeLimit + 1];
      if (ptsz == NULL)
      {
        DO_DEL(ADsValueDesc.CaseExactString)
        return -1;
      }

      if (GetDlgItemText(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID,
                         ptsz, m_rgpAttrMap[SAMNAME_IDX]->nSizeLimit + 1) == 0)
      {
        ErrMsg (IDS_ERR_DNLEVELNAME_MISSING, m_hPage);
        delete[] ptsz;
        hr = E_FAIL;
        goto Cleanup;
      }
      else
      {
        CStr csSAMName = ptsz;

        //
        // Now check for illegal characters
        //
        bool bSAMNameChanged = false;
        int iFind = csSAMName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
        if (iFind != -1 && !csSAMName.IsEmpty())
        {
          PVOID apv[1] = {(LPWSTR)(LPCWSTR)csSAMName};
          if (IDYES == SuperMsgBox(m_hPage,
                                   IDS_GROUP_SAMNAME_ILLEGAL, 
                                   0, 
                                   MB_YESNO | MB_ICONWARNING,
                                   S_OK, 
                                   apv, 
                                   1,
                                   FALSE, 
                                   __FILE__, 
                                   __LINE__))
          {
            while (iFind != -1)
            {
              csSAMName.SetAt(iFind, L'_');
              iFind = csSAMName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
              bSAMNameChanged = true;
            }
          }
          else
          {
            //
            // Set the focus to the edit box and select the text
            //
            SetFocus(GetDlgItem(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID));
            SendDlgItemMessage(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, EM_SETSEL, 0, -1);

            delete[] ptsz;
            hr = E_FAIL;
            goto Cleanup;
          }
        }

        if (bSAMNameChanged)
        {
            //
            // Write the change back to the control
            //
            SetDlgItemText(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, const_cast<PWSTR>((LPCWSTR)csSAMName));
        }

        if (!AllocWStr((PWSTR)(PCWSTR)csSAMName, &ADsValueSAMname.CaseIgnoreString))
        {
          delete[] ptsz;
          DO_DEL(ADsValueDesc.CaseExactString)
          return -1;
        }

      }
      delete[] ptsz;
      rgAttrs[cAttrs++] = AttrInfoSAMn;
    }

    //
    // Email Address.
    //
    AttrInfoMail.pADsValues = &ADsValueMail;
    AttrInfoMail.dwNumValues = 1;

    if (m_fEmailWritable)
    {
      if (!m_fEmailDirty)
      {
          SendMessage(GetParent(GetHWnd()), PSM_QUERYSIBLINGS,
                      (WPARAM)m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName,
                      (LPARAM)GetHWnd());
      }

      // SendMessage is syncronous. If the sibling page has an updated email
      // attribute value, it will get written to this page's edit control
      // and the dirty state member will be set. So, check it now rather than
      // use a 'else' clause after the above 'if' clause.
      //
      if (m_fEmailDirty)
      {
        ptsz = new TCHAR[m_rgpAttrMap[EMAIL_IDX]->nSizeLimit + 1];
        if (ptsz == NULL)
        {
          DO_DEL(ADsValueDesc.CaseExactString)
          DO_DEL(ADsValueSAMname.CaseIgnoreString);
          return -1;
        }

        if (GetDlgItemText(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                           ptsz, m_rgpAttrMap[EMAIL_IDX]->nSizeLimit + 1) == 0)
        {
          AttrInfoMail.dwNumValues = 0;
          AttrInfoMail.pADsValues = NULL;
          AttrInfoMail.dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
          if (!TcharToUnicode(ptsz, &ADsValueMail.CaseIgnoreString))
          {
            delete[] ptsz;
            hr = E_OUTOFMEMORY;
            goto Cleanup;
          }
          if (!FValidSMTPAddress(ADsValueMail.CaseIgnoreString))
          {
            ErrMsg(IDS_INVALID_MAIL_ADDR, GetHWnd());
            delete [] ptsz;
            hr = E_FAIL;
            goto Cleanup;
          }
        }
        delete[] ptsz;
        rgAttrs[cAttrs++] = AttrInfoMail;
      }
    }

    //
    // Comment.
    //
    AttrInfoComm.pADsValues = &ADsValueComm;
    AttrInfoComm.dwNumValues = 1;

    if (m_fCommentDirty)
    {
      dspAssert(m_fCommentWritable);

      ptsz = new TCHAR[m_rgpAttrMap[COMMENT_IDX]->nSizeLimit + 1];
      if (ptsz == NULL)
      {
        DO_DEL(ADsValueDesc.CaseExactString)
        DO_DEL(ADsValueSAMname.CaseIgnoreString);
        DO_DEL(ADsValueMail.CaseExactString)
        return -1;
      }

      if (GetDlgItemText(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID,
                         ptsz, m_rgpAttrMap[COMMENT_IDX]->nSizeLimit + 1) == 0)
      {
        AttrInfoComm.dwNumValues = 0;
        AttrInfoComm.pADsValues = NULL;
        AttrInfoComm.dwControlCode = ADS_ATTR_CLEAR;
      }
      else
      {
        if (!TcharToUnicode(ptsz, &ADsValueComm.CaseIgnoreString))
        {
          delete[] ptsz;
          DO_DEL(ADsValueDesc.CaseExactString)
          DO_DEL(ADsValueSAMname.CaseIgnoreString);
          DO_DEL(ADsValueMail.CaseExactString)
          return -1;
        }
      }
      delete[] ptsz;
      rgAttrs[cAttrs++] = AttrInfoComm;
    }

    //
    // set the group type flags
    //
    if (m_fTypeDirty)
    {
        dspAssert(m_fTypeWritable);

        BOOL Account = (IsDlgButtonChecked (m_hPage,IDC_RADIO_ACCOUNT)
                        == BST_CHECKED);
        BOOL Resource = (IsDlgButtonChecked (m_hPage,IDC_RADIO_RESOURCE)
                         == BST_CHECKED);
        BOOL Security = (IsDlgButtonChecked (m_hPage, IDC_RADIO_SEC_ENABLED)
                         == BST_CHECKED);
        if (Security)
        {
            ADsValueType.Integer = GROUP_TYPE_SECURITY_ENABLED;
        }
        else
        {
            if (m_dwType & GROUP_TYPE_SECURITY_ENABLED) 
            {
              TCHAR szTitle[80], szMessage[512];
              if (!LoadStringReport(IDS_MSG_TITLE, szTitle, 80, m_hPage))
                  {
                      hr = E_OUTOFMEMORY;
                      goto Cleanup;
                  }
              if (!LoadStringReport(IDS_MSG_DISABLING_SECURITY, szMessage, 512, m_hPage))
                  {
                      hr = E_OUTOFMEMORY;
                      goto Cleanup;
                  }
              
              LONG iRet = MessageBox(m_hPage, szMessage, szTitle, MB_YESNO |
                                     MB_ICONWARNING);
              
              if (iRet == IDNO)
                  {
                    //
                    // The user declined, so go back to prop sheet.
                    //
                    hr = S_FALSE;
                    goto Cleanup;
                  }
            }
            ADsValueType.Integer = 0;
        }

        if (Resource)
        {
            ADsValueType.Integer |= GROUP_TYPE_RESOURCE_GROUP;
        }
        else
        {
            if (Account)
            {
                ADsValueType.Integer |= GROUP_TYPE_ACCOUNT_GROUP;
            }
            else
            {
                ADsValueType.Integer |= GROUP_TYPE_UNIVERSAL_GROUP;
            }
        }
        rgAttrs[cAttrs++] = AttrInfoType;
    }

    //
    // Write the description, and group type.
    //
    DWORD cModified;

    hr = m_pDsObj->SetObjectAttributes(rgAttrs, cAttrs, &cModified);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        goto Cleanup;
    }

    m_fTypeDirty = m_fDescrDirty = m_fSamNameDirty = m_fEmailDirty = 
        m_fCommentDirty = FALSE;

Cleanup:
    DO_DEL(ADsValueDesc.CaseExactString)
    DO_DEL(ADsValueSAMname.CaseIgnoreString);
    DO_DEL(ADsValueMail.CaseExactString)
    DO_DEL(ADsValueComm.CaseExactString)
    
    if (hr == S_FALSE)
        return PSNRET_INVALID_NOCHANGEPAGE;
    else
        return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (codeNotify)
    {
    case BN_CLICKED:
        if ((id == IDC_RADIO_UNIVERSAL) ||
            (id == IDC_RADIO_RESOURCE) ||
            (id == IDC_RADIO_ACCOUNT))
        {
            int iCheck1, iCheck2;
            switch (id)
            {
            case IDC_RADIO_UNIVERSAL:
                iCheck1 = IDC_RADIO_RESOURCE;
                iCheck2 = IDC_RADIO_ACCOUNT;
                break;
            case IDC_RADIO_RESOURCE:
                iCheck1 = IDC_RADIO_UNIVERSAL;
                iCheck2 = IDC_RADIO_ACCOUNT;
                break;
            case IDC_RADIO_ACCOUNT:
                iCheck1 = IDC_RADIO_UNIVERSAL;
                iCheck2 = IDC_RADIO_RESOURCE;
                break;
            default:
                dspAssert(FALSE);
                iCheck1 = IDC_RADIO_RESOURCE;
                iCheck2 = IDC_RADIO_ACCOUNT;
                break;
            }
            CheckDlgButton(m_hPage, iCheck1, BST_UNCHECKED);
            CheckDlgButton(m_hPage, iCheck2, BST_UNCHECKED);
            m_fTypeDirty = TRUE;
            SetDirty();
        }
        if ((id == IDC_RADIO_SEC_ENABLED) ||
            (id == IDC_RADIO_SEC_DISABLED))
        {
            CheckDlgButton(m_hPage,
                           (id == IDC_RADIO_SEC_ENABLED) ?
                             IDC_RADIO_SEC_DISABLED : IDC_RADIO_SEC_ENABLED,
                           BST_UNCHECKED);
            m_fTypeDirty = TRUE;
            SetDirty();
        }
        break;

    case EN_CHANGE:
        switch (id)
        {
        case IDC_EMAIL_EDIT:
            m_fEmailDirty = TRUE;
            break;

        case IDC_DESCRIPTION_EDIT:
            m_fDescrDirty = TRUE;
            break;

        case IDC_SAM_NAME_EDIT:
            m_fSamNameDirty = TRUE;
            break;

        case IDC_EDIT_COMMENT:
            m_fCommentDirty = TRUE;
            break;
        }
        break;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnNotify
//
//  Synopsis:   Handles list notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }
    if (((LPNMHDR)lParam)->code == PSN_SETACTIVE)
    {
        dspDebugOut((DEB_ITRACE,
                    "(HWND: %08x) got PSN_SETACTIVE, sending PSM_QUERYSIBLINGS.\n",
                    GetHWnd()));
        SendMessage(GetParent(GetHWnd()), PSM_QUERYSIBLINGS,
                    (WPARAM)m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName,
                    (LPARAM)GetHWnd());
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnQuerySiblings
//
//  Synopsis:   Inter-page communications for shared attributes.
//
//  lParam == the HWND of the sending window.
//  wParam == the name of the attribute whose status is sought.
//
//-----------------------------------------------------------------------------
void
CDsGroupGenObjPage::OnQuerySiblings(WPARAM wParam, LPARAM lParam)
{
    PWSTR pwz = NULL;
    int cch;

#if DBG == 1
    char szBuf[100];
    strcpy(szBuf, "(HWND: %08x) got PSM_QUERYSIBLINGS for '%ws'");
#endif

    if ((HWND)lParam != GetHWnd())
    {
        if (m_fEmailDirty && wParam &&
            _wcsicmp((PWSTR)wParam,
                     m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName) == 0)
        {
#if DBG == 1
            strcat(szBuf, " sending DSPROP_ATTRCHANGED_MSG");
#endif
            ADS_ATTR_INFO Attr;
            ADSVALUE ADsValue;

            cch = (int)SendDlgItemMessage(GetHWnd(),
                                          m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                                          WM_GETTEXTLENGTH, 0, 0);
            pwz = new WCHAR[++cch];
            CHECK_NULL_REPORT(pwz, GetHWnd(), return);

            Attr.dwNumValues = 1;
            Attr.pszAttrName = m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName;
            Attr.pADsValues = &ADsValue;
            Attr.pADsValues->dwType = m_rgpAttrMap[EMAIL_IDX]->AttrInfo.dwADsType;
            Attr.pADsValues->CaseIgnoreString = pwz;

            GetDlgItemText(GetHWnd(), m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                           Attr.pADsValues->CaseIgnoreString, cch);

            SendMessage((HWND)lParam, g_uChangeMsg, (WPARAM)&Attr, 0);

            delete pwz;
        }
    }
#if DBG == 1
    else
    {
        strcat(szBuf, " (it was sent by this page!)");
    }
    strcat(szBuf, "\n");
    dspDebugOut((DEB_ITRACE, szBuf, GetHWnd(), wParam));
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnAttrChanged
//
//  Synopsis:   Inter-page communications for shared attributes.
//
//  wParam == the PADS_ATTR_INFO struct for the changed attribute.
//
//-----------------------------------------------------------------------------
void
CDsGroupGenObjPage::OnAttrChanged(WPARAM wParam)
{
    PADS_ATTR_INFO pAttrInfo = (PADS_ATTR_INFO)wParam;

    dspAssert(pAttrInfo && pAttrInfo->pszAttrName && pAttrInfo->pADsValues &&
              pAttrInfo->pADsValues->CaseIgnoreString);
    dspDebugOut((DEB_ITRACE,
                 "(HWND: %08x) got DSPROP_ATTRCHANGED_MSG for '%ws'.\n",
                 GetHWnd(), pAttrInfo->pszAttrName));
    if (_wcsicmp(pAttrInfo->pszAttrName, m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName) == 0)
    {
        SetDlgItemText(GetHWnd(), m_rgpAttrMap[EMAIL_IDX]->nCtrlID,
                       pAttrInfo->pADsValues->CaseIgnoreString);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::OnDestroy(void)
{
    ATTR_DATA ad = {0, (LPARAM)m_pCIcon};

    GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fOnDestroy);

    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

#endif // DSADMIN

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::CDsGrpMembersPage
//
//-----------------------------------------------------------------------------
CDsGrpMembersPage::CDsGrpMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags) :
    m_pList(NULL),
    m_fMixed(TRUE),
    m_dwType(0),
    m_fMemberWritable(FALSE),
    m_dwGroupRID(0),
    m_fShowIcons(FALSE),
    m_pszSecurityGroupExtraClasses(NULL),
    m_dwSecurityGroupExtraClassesCount(0),
    m_pszNonSecurityGroupExtraClasses(NULL),
    m_dwNonSecurityGroupExtraClassesCount(0),
    m_hwndObjPicker(NULL),
    m_pInitInfo(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsGrpMembersPage,CDsGrpMembersPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsGrpMembersPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::~CDsGrpMembersPage
//
//-----------------------------------------------------------------------------
CDsGrpMembersPage::~CDsGrpMembersPage()
{
  TRACE(CDsGrpMembersPage,~CDsGrpMembersPage);
  DO_DEL(m_pList);

  if (m_pszSecurityGroupExtraClasses != NULL)
  {
    for (DWORD idx = 0; idx < m_dwSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszSecurityGroupExtraClasses[idx] != NULL)
      {
        delete[] m_pszSecurityGroupExtraClasses[idx];
        m_pszSecurityGroupExtraClasses[idx] = NULL;
      }
    }
    delete[] m_pszSecurityGroupExtraClasses;
  }
  if (m_pszNonSecurityGroupExtraClasses != NULL)
  {
    for (DWORD idx = 0; idx < m_dwNonSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszNonSecurityGroupExtraClasses[idx] != NULL)
      {
        delete[] m_pszNonSecurityGroupExtraClasses[idx];
        m_pszNonSecurityGroupExtraClasses[idx] = NULL;
      }
    }
    delete[] m_pszNonSecurityGroupExtraClasses;
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsGrpMembersPage::QueryInterface(REFIID riid, void ** ppvObject)
{
  TRACE2(CDsGrpMembersPage,QueryInterface);
  if (IID_ICustomizeDsBrowser == riid)
  {
    *ppvObject = (ICustomizeDsBrowser*)this;
  }
  else
  {
    return CDsPropPageBase::QueryInterface(riid, ppvObject);
  }
  AddRef();
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsGrpMembersPage::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsGrpMembersPage::AddRef refcount going in %d\n", m_uRefs));
    return CDsPropPageBase::AddRef();
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpMembersPage::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsGrpMembersPage::Release(void)
{
  dspDebugOut((DEB_USER2, "CDsGrpMembersPage::Release ref count going in %d\n", m_uRefs));
  return CDsPropPageBase::Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::Initialize
//
//  Synopsis:   Initializes the ICustomizeDsBrowser interface
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::Initialize(HWND         hwnd,
                                      PCDSOP_INIT_INFO pInitInfo,
                                      IBindHelper *pBindHelper)
{
  HRESULT hr = S_OK;

  dspAssert(IsWindow(hwnd));
  dspAssert(pBindHelper);

  m_hwndObjPicker = hwnd;
  m_pInitInfo = pInitInfo;
  m_pBinder = pBindHelper;

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::BuildQueryString
//
//  Synopsis:   Used to build the query string from the securityGroupExtraClasses
//              and nonSecurityGroupExtraClasses in the DisplaySpecifiers
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::BuildQueryString(PWSTR* ppszFilterString)
{
  CStrW szFilterString = L"(|";

  BOOL bSecurityGroup = (m_dwType & GROUP_TYPE_SECURITY_ENABLED) ? TRUE : FALSE;
  if (bSecurityGroup)
  {
    if (m_dwSecurityGroupExtraClassesCount == 0)
    {
      return S_FALSE;
    }

    for (DWORD idx = 0; idx < m_dwSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszSecurityGroupExtraClasses[idx] != NULL)
      {
        szFilterString += L"(objectClass=";
        szFilterString += m_pszSecurityGroupExtraClasses[idx];
        szFilterString += L")";
      }
    }
  }
  else
  {
    if (m_dwNonSecurityGroupExtraClassesCount == 0)
    {
      return S_FALSE;
    }

    for (DWORD idx = 0; idx < m_dwNonSecurityGroupExtraClassesCount; idx++)
    {
      if (m_pszNonSecurityGroupExtraClasses[idx] != NULL)
      {
        szFilterString += L"(objectClass=";
        szFilterString += m_pszNonSecurityGroupExtraClasses[idx];
        szFilterString += L")";
      }
    }
  }

  szFilterString += L")";

  *ppszFilterString = new WCHAR[szFilterString.GetLength() + 1];
  CHECK_NULL_REPORT(*ppszFilterString, GetHWnd(), return E_OUTOFMEMORY);

  wcscpy(*ppszFilterString, szFilterString);
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsSelectionListWrapper::CreateSelectionList
//
//  Synopsis:   Used to convert a CDsSelectionListWrapper to a PDS_SELECTION_LIST
//
//-----------------------------------------------------------------------------
PDS_SELECTION_LIST CDsSelectionListWrapper::CreateSelectionList(CDsSelectionListWrapper* pHead)
{
  if (pHead == NULL)
  {
    return NULL;
  }

  PDS_SELECTION_LIST pSelectionList = NULL;

  UINT nCount = CDsSelectionListWrapper::GetCount(pHead);
  if (nCount > 0)
  {
    pSelectionList = (PDS_SELECTION_LIST)malloc(sizeof(DS_SELECTION_LIST) + 
                                                (sizeof(DS_SELECTION) * (nCount - 1)));
    if (pSelectionList != NULL)
    {
      memset(pSelectionList, 0, sizeof(DS_SELECTION_LIST) + (sizeof(DS_SELECTION) * (nCount - 1)));

      pSelectionList->cItems = nCount;
      pSelectionList->cFetchedAttributes = 0;

      //
      // Now fill in the selection list by walking the wrapper list
      //
      UINT idx = 0;
      CDsSelectionListWrapper* pCurrentItem = pHead;
      while (pCurrentItem != NULL)
      {
        memcpy(&(pSelectionList->aDsSelection[idx]), pCurrentItem->m_pSelection, sizeof(DS_SELECTION));
        pCurrentItem = pCurrentItem->m_pNext;
        idx++;
      }
    }
  }
  return pSelectionList;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsSelectionListWrapper::CreateSelectionList
//
//  Synopsis:   Counts the number of items in the CDsSelectionListWrapper
//
//-----------------------------------------------------------------------------
UINT CDsSelectionListWrapper::GetCount(CDsSelectionListWrapper* pHead)
{
  CDsSelectionListWrapper* pCurrentItem = pHead;
  UINT nCount = 0;
  
  while (pCurrentItem != NULL)
  {
    nCount++;
    pCurrentItem = pCurrentItem->m_pNext;
  }
  return nCount;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsSelectionListWrapper::DetachItemsAndDeleteList
//
//  Synopsis:   Counts the number of items in the CDsSelectionListWrapper
//
//-----------------------------------------------------------------------------
void CDsSelectionListWrapper::DetachItemsAndDeleteList(CDsSelectionListWrapper* pHead)
{
  CDsSelectionListWrapper* pNextItem = pHead;
  
  CDsSelectionListWrapper* pDeleteItem = NULL;

  while (pNextItem != NULL)
  {
    pDeleteItem = pNextItem;
    pNextItem = pNextItem->m_pNext;
    delete pDeleteItem->m_pSelection;
    delete pDeleteItem;
  }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::CollectDsObjects
//
//  Synopsis:   Used by AddObjects and PrefixSearch to retrieve the dataobject
//              of the additional objects
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::CollectDsObjects(PWSTR pszFilter,
                                            IDsObjectPickerScope *pDsScope,
                                            CDsPropDataObj *pdo)
{
  HRESULT hr = S_OK;

  dspAssert(pdo != NULL);
  if (pdo == NULL)
  {
    return E_POINTER;
  }

  //
  // Prepare the search object
  //
  PWSTR pszScopePath = NULL;
  hr = pDsScope->GetADsPath(&pszScopePath);
  CHECK_HRESULT(hr, return hr;);

  CDSSearch searchObj;
  hr = searchObj.Init(pszScopePath);
  CHECK_HRESULT(hr, return hr;);

  PWSTR pszAttributes[] = { g_wzADsPath };
  hr = searchObj.SetAttributeList(pszAttributes, 1);
  CHECK_HRESULT(hr, return hr);

  dspAssert(pszFilter != NULL);
  if (pszFilter == NULL)
  {
    return E_INVALIDARG;
  }

  hr = searchObj.SetFilterString(pszFilter);
  CHECK_HRESULT(hr, return hr);


  hr = searchObj.SetSearchScope(ADS_SCOPE_SUBTREE);
  CHECK_HRESULT(hr, return hr);

  //
  // Prepare the linked list for temporary storage of DS_SELECTION items
  //
  CDsSelectionListWrapper* pListHead = NULL;
  CDsSelectionListWrapper* pCurrentListItem = NULL;

  //
  // Get the path cracker
  //
  CComPtr<IADsPathname> spPathCracker;
  hr = GetADsPathname(spPathCracker);
  CHECK_HRESULT(hr, return hr);

  //
  // Execute the query
  //
  hr = searchObj.DoQuery();
  while (SUCCEEDED(hr))
  {
    hr = searchObj.GetNextRow();
		if (S_ADS_NOMORE_ROWS == hr)
		{
      hr = S_OK;
      break;
    }

    if (SUCCEEDED(hr))
    {
		  ADS_SEARCH_COLUMN PathColumn, ClassColumn;
		  ::ZeroMemory( &PathColumn, sizeof(PathColumn) );
      ::ZeroMemory(&ClassColumn, sizeof(ClassColumn));

      //
      // Get the ADsPath
      //
		  hr = searchObj.GetColumn(pszAttributes[0], &PathColumn);
      CHECK_HRESULT(hr, continue);
      dspAssert(PathColumn.pADsValues->dwType == ADSTYPE_CASE_IGNORE_STRING);

      //
      // Get the objectClass
      //
      CComPtr<IDirectoryObject> spDirObject;
      hr = ADsOpenObject(PathColumn.pADsValues->CaseIgnoreString,
                         NULL,
                         NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IDirectoryObject,
                         (PVOID*)&spDirObject);
      CHECK_HRESULT(hr, continue);
      
      //
      // Get the object info
      //
      ADS_OBJECT_INFO* pADsObjectInfo = NULL;
      hr = spDirObject->GetObjectInformation(&pADsObjectInfo);
      CHECK_HRESULT(hr, continue);
      dspAssert(pADsObjectInfo != NULL);

      PDS_SELECTION pSelection = new DS_SELECTION;
      CHECK_NULL(pSelection, return E_OUTOFMEMORY);

      ::ZeroMemory(pSelection, sizeof(DS_SELECTION));

      if (!AllocWStr(PathColumn.pADsValues->CaseIgnoreString, &(pSelection->pwzADsPath)))
      {
        CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
      }

      //
      // Assume that the class we are interested in is the first in the multivalued attribute
      //
      if (!AllocWStr(pADsObjectInfo->pszClassName, &(pSelection->pwzClass)))
      {
        CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
      }

      hr = spPathCracker->Set(PathColumn.pADsValues->CaseIgnoreString, ADS_SETTYPE_FULL);
      CHECK_HRESULT(hr, continue);

      hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      CHECK_HRESULT(hr, continue);

      // CODEWORK 122531 Should we be turning off escaped mode here?

      CComBSTR bstrName;
      hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrName);
      CHECK_HRESULT(hr, continue);

      //
      // Return the display to full
      //
      hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
      dspAssert(SUCCEEDED(hr));

      if (!AllocWStr(bstrName, &(pSelection->pwzName)))
      {
        CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
      }

      CDsSelectionListWrapper* pNewItem = new CDsSelectionListWrapper;
      CHECK_NULL(pNewItem, return E_OUTOFMEMORY);

      pNewItem->m_pSelection = pSelection;

      //
      // Add selection item to list
      //
      if (pListHead == NULL)
      {
        pListHead = pNewItem;
        pCurrentListItem = pNewItem;
      }
      else
      {
        pCurrentListItem->m_pNext = pNewItem;
        pCurrentListItem = pNewItem;
      }

      searchObj.FreeColumn(&PathColumn);
      searchObj.FreeColumn(&ClassColumn);
    }
  }

  if (pListHead != NULL)
  {
    PDS_SELECTION_LIST pSelectionList = CDsSelectionListWrapper::CreateSelectionList(pListHead);
    if (pSelectionList != NULL)
    {
      hr = pdo->Init(pSelectionList);
      CHECK_HRESULT(hr, return hr);
    }
    CDsSelectionListWrapper::DetachItemsAndDeleteList(pListHead);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::AddObjects
//
//  Synopsis:   Called by the Object Picker UI to add additional objects to the UI
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::AddObjects(IDsObjectPickerScope *pDsScope,
                                      IDataObject **ppdo)
{
  HRESULT hr = S_OK;

  //
  // Prepare the data object
  //
  CDsPropDataObj* pDataObj = new CDsPropDataObj(GetHWnd(), m_fReadOnly);
  CHECK_NULL(pDataObj, return E_OUTOFMEMORY);

  *ppdo = pDataObj;

  PWSTR pszFilter = NULL;
  hr = BuildQueryString(&pszFilter);
  if (FAILED(hr) ||
      !pszFilter ||
      hr == S_FALSE)
  {
    delete pDataObj;
    pDataObj = NULL;
    *ppdo = NULL;
    hr = S_FALSE;
  }
  else
  {
    hr = CollectDsObjects(pszFilter, pDsScope, pDataObj);
  }

  if (pszFilter != NULL)
  {
    delete[] pszFilter;
    pszFilter = NULL;
  }

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::GetQueryInfoByScope
//
//  Synopsis:   Called by the Object Picker UI 
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::GetQueryInfoByScope(IDsObjectPickerScope*,
                                               PDSQUERYINFO *ppdsqi) 
{ 
  return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::PrefixSearch
//
//  Synopsis:   Called by the Object Picker UI to get additional objects starting
//              with a specific string
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::PrefixSearch(IDsObjectPickerScope *pDsScope,
                                        PCWSTR pwzSearchFor,
                                        IDataObject **ppdo)
{
  HRESULT hr = S_OK;

  //
  // Prepare the data object
  //
  CDsPropDataObj* pDataObj = new CDsPropDataObj(GetHWnd(), m_fReadOnly);
  CHECK_NULL(pDataObj, return E_OUTOFMEMORY);

  *ppdo = pDataObj;

  CStrW szFilter;
  PWSTR pszFilter = NULL;
  hr = BuildQueryString(&pszFilter);
  if (FAILED(hr) || 
      hr == S_FALSE ||
      pszFilter == NULL)
  {
    delete pDataObj;
    pDataObj = NULL;
    *ppdo = NULL;

    if (pszFilter)
    {
      delete[] pszFilter;
      pszFilter = NULL;
    }

    hr = S_FALSE;
  }
  else
  {
    szFilter = pszFilter;
  
    CStrW szPrefix;
    szPrefix = L"(&(name=";
    szPrefix += pwzSearchFor;
    szPrefix += L"*)";

    szFilter = szPrefix + szFilter + L")";
    hr = CollectDsObjects(szFilter.GetBuffer(szFilter.GetLength() + 1), pDsScope, pDataObj);
  }

  return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   CreateGroupMembersPage
//
//  Synopsis:   Creates an instance of the group membership page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateGroupMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                       PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                       DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                       HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGroupMembersPage);

    CDsGrpMembersPage * pPageObj = new CDsGrpMembersPage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT
CDsGrpMembersPage::OnInitDialog(LPARAM lParam)
{
    return OnInitDialog(lParam, TRUE);
}

HRESULT CDsGrpMembersPage::OnInitDialog(LPARAM, BOOL fShowIcons)
{
    TRACE(CDsGrpMembersPage,OnInitDialog);
    HRESULT hr;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    m_fShowIcons = (0 != g_ulMemberFilterCount) ? fShowIcons : FALSE;

    CWaitCursor Wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    PTSTR ptzRDN;
    if (!UnicodeToTchar(m_pwszRDName, &ptzRDN))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return S_OK;
    }

    SetDlgItemText(m_hPage, IDC_CN, ptzRDN);
    delete ptzRDN;

    GetDomainMode(this, &m_fMixed);

    //
    // Get the group RID.
    //
    PWSTR rgpwzAttrNames[] = {L"primaryGroupToken"};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        return S_OK;
    }

    dspAssert(cAttrs);

    if (cAttrs == 1)
    {
        dspAssert(pAttrs);

        m_dwGroupRID = pAttrs->pADsValues->Integer;

        FreeADsMem(pAttrs);
    }

    GetGroupType(this, &m_dwType);
    dspDebugOut((DEB_ITRACE, "Group Type = 0x%x\n", m_dwType));

    //
    // Get the membership list and fill the listview control.
    //
    m_pList = new CDsMembershipList(m_hPage, IDC_MEMBER_LIST);

    CHECK_NULL_REPORT(m_pList, m_hPage, return S_OK);

    hr = m_pList->Init(m_fShowIcons);

    CHECK_HRESULT(hr, return S_OK);

    hr = FillGroupList();

    CHECK_HRESULT(hr, return S_OK);

    m_fMemberWritable = CheckIfWritable(g_wzMemberAttr);

    if (!m_fMemberWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BTN), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), FALSE);
    }

    //Set the focus on first item in the list
    ListView_SetItemState(GetDlgItem(m_hPage, IDC_MEMBER_LIST), 0,
                          LVIS_SELECTED, LVIS_SELECTED);

    BOOL bSecurityGroup = (m_dwType & GROUP_TYPE_SECURITY_ENABLED) ? TRUE : FALSE;
    hr = LoadGroupExtraClasses(bSecurityGroup);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnApply(void)
{
    TRACE(CDsGrpMembersPage,OnApply);
    HRESULT hr = S_OK;
    ADS_ATTR_INFO AttrInfo;
    PADS_ATTR_INFO pAttrs = &AttrInfo;

    AttrInfo.pszAttrName = g_wzMemberAttr;
    AttrInfo.dwADsType = ADSTYPE_DN_STRING;

    //
    // Read the list of members and do additions.
    //
    DWORD cModified;
    int i, cMembers = m_pList->GetCount();

    if (cMembers > 0)
    {
        AttrInfo.dwControlCode = ADS_ATTR_APPEND;
        PADSVALUE rgADsValues;

        rgADsValues = new ADSVALUE[cMembers];

        CHECK_NULL(rgADsValues, return PSNRET_INVALID_NOCHANGEPAGE);

        memset(rgADsValues, 0, cMembers * sizeof(ADSVALUE));

        pAttrs->pADsValues = rgADsValues;
        pAttrs->dwNumValues = 0;

        CMemberListItem * pItem;

        for (i = 0; i < cMembers; i++)
        {
            if (FAILED(m_pList->GetItem(i, &pItem)))
            {
                dspAssert(FALSE && "List Error");
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
            if (!pItem)
            {
                dspAssert(pItem);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (pItem->m_fIsAlreadyMember)
            {
                continue;
            }

            dspAssert(pItem->m_pwzDN);

            rgADsValues[pAttrs->dwNumValues].DNString = pItem->m_pwzDN;
            rgADsValues[pAttrs->dwNumValues].dwType = ADSTYPE_DN_STRING;

            pItem->m_fIsAlreadyMember = TRUE;
            pAttrs->dwNumValues++;
        }

        if (pAttrs->dwNumValues)
        {
            hr = m_pDsObj->SetObjectAttributes(pAttrs, 1, &cModified);

            if (!CheckGroupUpdate(hr, m_hPage))
            {
                delete rgADsValues;
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
        }
        delete rgADsValues;
    }

    //
    // Do removals.
    //
    DWORD cDelItems = m_DelList.GetItemCount();

    if (cDelItems)
    {
        AttrInfo.dwControlCode = ADS_ATTR_DELETE;
        PADSVALUE rgADsValues;

        rgADsValues = new ADSVALUE[cDelItems];

        CHECK_NULL(rgADsValues, return PSNRET_INVALID_NOCHANGEPAGE);

        memset(rgADsValues, 0, cDelItems * sizeof(ADSVALUE));

        pAttrs->pADsValues = rgADsValues;
        pAttrs->dwNumValues = 0;

        CMemberListItem * pDelItem = m_DelList.RemoveFirstItem();

        while (pDelItem)
        {
            if (pDelItem->m_fIsExternal)
            {
                hr = GetRealDN(pDelItem);

                CHECK_HRESULT_REPORT(hr, m_hPage, continue);
            }

            dspAssert(pDelItem->m_pwzDN);

            rgADsValues[pAttrs->dwNumValues].DNString = pDelItem->m_pwzDN;
            rgADsValues[pAttrs->dwNumValues].dwType = ADSTYPE_DN_STRING;

            pAttrs->dwNumValues++;

            pDelItem = m_DelList.RemoveFirstItem();
        }

        if (pAttrs->dwNumValues)
        {
            hr = m_pDsObj->SetObjectAttributes(pAttrs, 1, &cModified);

            if (!CheckGroupUpdate(hr, m_hPage, FALSE))
            {
                delete rgADsValues;
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
        }
        delete rgADsValues;
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (codeNotify)
    {
    case BN_CLICKED:
        TRACE(CDsGrpMembersPage,OnCommand);
        if (id == IDC_ADD_BTN)
        {
            InvokeUserQuery();
        }
        if (id == IDC_REMOVE_BTN)
        {
            RemoveMember();
        }
        break;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnNotify
//
//  Synopsis:   Handles list notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        if (m_fMemberWritable)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), TRUE);
        }
        break;

    case NM_DBLCLK:
        //
        // Display properties for the selected item. First, find out
        // which item is selected.
        //
        CMemberListItem * pItem;

        if (!m_pList->GetCurListItem(NULL, NULL, &pItem))
        {
            break;
        }

        dspAssert(pItem);

        if (pItem->m_fIsExternal)
        {
            HRESULT hr = GetRealDN(pItem);

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND))
            {
                MsgBox(IDS_CANT_VIEW_EXTERNAL, m_hPage);
                break;
            }
            CHECK_HRESULT_REPORT(hr, m_hPage, break);
        }

        if (pItem->m_ulScopeType & DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN)
        {
          //
          // We cannot show the properties for downlevel users
          //
          // Put a useful message up
          PTSTR ptzTitle, ptzMsg;
          if (!LoadStringToTchar(IDS_MSG_NO_DOWNLEVEL_PROPERTIES, &ptzMsg))
          {
            break;
          }
          if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
          {
            break;
          }
          MessageBox(m_hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
          delete[] ptzTitle;
          delete[] ptzMsg;

          break;
        }
        PostPropSheet(pItem->m_pwzDN, this);
        break;
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::InvokeUserQuery
//
//  Synopsis:   Bring up the query dialog to search for users and groups.
//
//-----------------------------------------------------------------------------
void
CDsGrpMembersPage::InvokeUserQuery(void)
{
    TRACE(CDsGrpMembersPage,InvokeUserQuery);
    HRESULT hr;
    UINT i;
    CWaitCursor WaitCursor;
    CSmartWStr cstrCleanDN;
    IDsObjectPicker * pObjSel;
    BOOL fIsObjSelInited, fNativeModeUSG = FALSE;
    CStr strExternMemberList;

    hr = GetObjSel(&pObjSel, &fIsObjSelInited);

    CHECK_HRESULT(hr, return);

    if (!fIsObjSelInited)
    {
        CStrW cstrDC;
        hr = GetLdapServerName(m_pDsObj, cstrDC);

        CHECK_HRESULT_REPORT(hr, m_hPage, return);
        dspDebugOut((DEB_ITRACE, "ObjSel targetted to %ws\n", (LPCWSTR)cstrDC));

        DSOP_SCOPE_INIT_INFO rgScopes[5];
        DSOP_INIT_INFO InitInfo;

        ZeroMemory(rgScopes, sizeof(rgScopes));
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        // The first scope is the local domain. All group types can contain
        // users, computers, and contacts from the local domain.
        //
        rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;
        rgScopes[0].pwzDcName = cstrDC;
        rgScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_USERS | DSOP_FILTER_CONTACTS | DSOP_FILTER_COMPUTERS;

        // The second scope is the local forest.
        //
        rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        rgScopes[1].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

        // The third scope is the GC.
        //
        rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[2].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        rgScopes[2].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

        // The fourth scope is uplevel external trusted domains.
        //
        rgScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
        rgScopes[3].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

        // The fifth scope is downlevel external trusted domains.
        //
        rgScopes[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[4].flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
        rgScopes[4].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

        if (m_dwType & GROUP_TYPE_ACCOUNT_GROUP) // Global group
        {
            if (!(m_fMixed && (m_dwType & GROUP_TYPE_SECURITY_ENABLED)))
            {
                // if it is not mixed-mode, security-enabled, add global.
                //
                rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_GLOBAL_GROUPS_DL |
                    DSOP_FILTER_GLOBAL_GROUPS_SE;
            }
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_CONTACTS;

            InitInfo.cDsScopeInfos = 3; // Enterprise scope.
        }
        else if (m_dwType & GROUP_TYPE_RESOURCE_GROUP) // Local group.
        {
            rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;
            if (!(m_fMixed && (m_dwType & GROUP_TYPE_SECURITY_ENABLED)) &&
                !(m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP))
            {
                // If this is not a mixed-mode security-enabled local group
                // or a builtin group, then add local groups.
                //
                rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                    DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
            }
            
            //bug  37724
            if( m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP )
                    rgScopes[0].FilterFlags.Uplevel.flBothModes |=
                    DSOP_FILTER_WELL_KNOWN_PRINCIPALS;


            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_USERS | DSOP_FILTER_CONTACTS |
                DSOP_FILTER_COMPUTERS |
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;
            //
            // Uplevel external domains:
            //
            rgScopes[3].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS |
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;
            //
            // Downlevel external domains:
            //
            rgScopes[4].FilterFlags.flDownlevel =
                DSOP_DOWNLEVEL_FILTER_USERS |
                DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

            InitInfo.cDsScopeInfos = 5; // Any trusted domain.
        }
        else if (m_dwType & GROUP_TYPE_UNIVERSAL_GROUP)
        {
            rgScopes[0].FilterFlags.Uplevel.flBothModes =
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_USERS | DSOP_FILTER_CONTACTS |
                DSOP_FILTER_COMPUTERS |
                DSOP_FILTER_UNIVERSAL_GROUPS_DL |
                DSOP_FILTER_UNIVERSAL_GROUPS_SE |
                DSOP_FILTER_GLOBAL_GROUPS_DL |
                DSOP_FILTER_GLOBAL_GROUPS_SE;

            InitInfo.cDsScopeInfos = 3; // Enterprise scope.
        }

        InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
        InitInfo.aDsScopeInfos = rgScopes;
        InitInfo.pwzTargetComputer = cstrDC;
        InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
        InitInfo.cAttributesToFetch = 2;
        LPCWSTR rgAttrNames[] = {g_wzObjectSID,
                                 g_wzUserAccountControl};
        InitInfo.apwzAttributeNames = rgAttrNames;

        hr = pObjSel->Initialize(&InitInfo);

        CHECK_HRESULT_REPORT(hr, m_hPage, return);

        ObjSelInited();
    }

    IDataObject * pdoSelections = NULL;

    CComPtr<IDsObjectPickerEx> spObjPickerEx;
    hr = pObjSel->QueryInterface(IID_IDsObjectPickerEx, (void**)&spObjPickerEx);
    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    hr = spObjPickerEx->InvokeDialogEx(m_hPage, this, &pdoSelections);

//    hr = pObjSel->InvokeDialog(m_hPage, &pdoSelections);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    if (hr == S_FALSE || !pdoSelections)
    {
        return;
    }

    // Security enabled universal groups shouldn't contain members
    // from mixed-mode domains BUT, we have to allow it for Exchange's
    // non-standard public folder security model.
    //
    if (!m_fMixed && (m_dwType & GROUP_TYPE_UNIVERSAL_GROUP) &&
        (m_dwType & GROUP_TYPE_SECURITY_ENABLED))
    {
        fNativeModeUSG = TRUE;
    }

    m_MixedModeMembers.Init(this);

    CSmartWStr cstrCleanGroup;
    FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

    hr = pdoSelections->GetData(&fmte, &medium);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

    if (!pSelList)
    {
        goto ExitCleanup;
    }

    WaitCursor.SetWait();

    // Clean the group name so it can be compared with those returned by the
    // user's selection.
    //
    hr = SkipPrefix(m_pwszObjPathName, &cstrCleanGroup);

    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

    //
    // Insert the returned items into the group.
    //
    for (i = 0; i < pSelList->cItems; i++)
    {
        CMemberListItem * pItemInDelList = NULL;
        PSID pSid = NULL;

        if (!pSelList->aDsSelection[i].pwzADsPath) continue;

        // Check for an object from an external trusted domain. These objects
        // have a path of the form "LDAP://<SID=01050xxxx>". SAM will create
        // an FSPO for this member and will then store that DN rather than the
        // above path. We won't know this DN until after the member is added,
        // so use its object-SID to identify it.
        //
        if ((pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN) ||
            (pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN))
        {
            dspAssert(pSelList->aDsSelection[i].pvarFetchedAttributes);
            if (pSelList->aDsSelection[i].pvarFetchedAttributes[0].vt != (VT_ARRAY | VT_UI1))
            {
                REPORT_ERROR(ERROR_DATATYPE_MISMATCH, m_hPage);
                continue;
            }
            pSid = pSelList->aDsSelection[i].pvarFetchedAttributes[0].parray->pvData;
            dspAssert(IsValidSid(pSid));
            //
            // Check if the item is in the delete list, if so remove it.
            //
            pItemInDelList = m_DelList.FindItemRemove(pSid);
        }
        else
        {
            hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &cstrCleanDN);

            CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

            // See if the user is trying to add the group to itself.
            //
            if (_wcsicmp(cstrCleanDN, cstrCleanGroup) == 0)
            {
                if (pSelList->cItems == 1)
                {
                    ErrMsg(IDS_ERROR_GRP_SELF, m_hPage);
                    goto ExitCleanup;
                }
                continue;
            }

            // Check if the item is in the delete list, if so remove it.
            //
            pItemInDelList = m_DelList.FindItemRemove(cstrCleanDN);
        }

        if (pItemInDelList)
        {
            hr = m_pList->InsertIntoList(pItemInDelList);
        }
        else
        {
            if (pSid)
            {
                CComPtr<IADsPathname> spPathCracker;

                hr = GetADsPathname(spPathCracker);

                CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                hr = spPathCracker->Set(pSelList->aDsSelection[i].pwzADsPath,
                                       ADS_SETTYPE_FULL);

                CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);
                PWSTR pwzName;
                BSTR bstr;

                hr = spPathCracker->Retrieve(ADS_FORMAT_PROVIDER, &bstr);

                CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                if (_wcsicmp(bstr, L"LDAP") == 0)
                {
                    SysFreeString(bstr);

                    hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &cstrCleanDN);

                    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                    hr = CrackName(cstrCleanDN, &pwzName, GET_OBJ_CAN_NAME_EX, m_hPage);

                    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                    hr = m_pList->InsertIntoList(pSid, pwzName);

                    LocalFreeStringW(&pwzName);
                }
                else
                {
                    SysFreeString(bstr);

                    hr = spPathCracker->Retrieve(ADS_FORMAT_WINDOWS_DN, &bstr);

                    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

                    hr = m_pList->InsertIntoList(pSid, bstr);

                    SysFreeString(bstr);
                }
            }
            else
            {
                int iIcon = -1;
                if (m_fShowIcons)
                {
                    BOOL fDisabled = FALSE;
                    if (pSelList->aDsSelection[i].pvarFetchedAttributes[1].vt == VT_I4)
                    {
                        fDisabled = pSelList->aDsSelection[i].pvarFetchedAttributes[1].lVal & UF_ACCOUNTDISABLE;
                    }
                    iIcon = g_ClassIconCache.GetClassIconIndex(pSelList->aDsSelection[i].pwzClass,
                                                               fDisabled);
                    if (iIcon == -1)
                    {
                      iIcon = g_ClassIconCache.AddClassIcon(pSelList->aDsSelection[i].pwzClass, 
                                                            fDisabled);
                    }
                }

                if (fNativeModeUSG &&
                    ((DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN == pSelList->aDsSelection[i].flScopeType) ||
                     (DSOP_SCOPE_TYPE_GLOBAL_CATALOG == pSelList->aDsSelection[i].flScopeType)))
                {
                    // member from domain in forest is DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                    // member from the same domain is DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                    //
                    m_MixedModeMembers.CheckMember(cstrCleanDN);
                }

                dspDebugOut((DEB_ITRACE, "New member scope is 0x%x\n", pSelList->aDsSelection[i].flScopeType));

                hr = m_pList->InsertIntoList(cstrCleanDN, iIcon);
            }
        }

        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
        {
            continue;
        }
        CHECK_HRESULT(hr, goto ExitCleanup);
    }

    m_MixedModeMembers.ListExternalMembers(strExternMemberList);

    if (!strExternMemberList.IsEmpty())
    {
        CStr strMessage, strFormat;

        strFormat.LoadString(g_hInstance, IDS_USG_MIXED_WARNING);

        strMessage.Format(strFormat, strExternMemberList);

        ReportErrorWorker(m_hPage, (LPTSTR)(LPCTSTR)strMessage);
    }

    SetDirty();
ExitCleanup:
    GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    pdoSelections->Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::FillGroupList
//
//  Synopsis:   Fill the list box with the names of the group members.
//
//-----------------------------------------------------------------------------
HRESULT
CDsGrpMembersPage::FillGroupList(void)
{
    TRACE(CDsGrpMembersPage,FillGroupList);
    return ::FillGroupList(this, m_pList, m_dwGroupRID);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::RemoveMember
//
//  Synopsis:   Removes the selected users.
//
//-----------------------------------------------------------------------------
void
CDsGrpMembersPage::RemoveMember(void)
{
    TRACE(CDsGrpMembersPage,RemoveMember);
    if (!m_pList)
    {
        return;
    }
    int* pIndex = NULL;
    CMemberListItem ** ppItem;
    int nNumSelected = 0;

    //
    // Compose the confirmation message and post it.
    //
    TCHAR szMsg[160];
    if (!LoadStringReport(IDS_RM_MBR_MSG, szMsg, 160, m_hPage))
    {
        return;
    }

    TCHAR szTitle[80];
    if (!LoadStringReport(IDS_MSG_TITLE, szTitle, 80, m_hPage))
    {
        return;
    }

    LONG iRet = MessageBox(m_hPage, szMsg, szTitle, MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);

    if (iRet == IDNO)
    {
        // The user declined, so go home.
        //
        return;
    }

    CWaitCursor cWait;

    if (!m_pList->GetCurListItems(&pIndex, NULL, &ppItem, &nNumSelected))
    {
        return;
    }

    for (int idx = 0; idx < nNumSelected; idx++)
    {
      if (!ppItem[idx])
      {
        if (pIndex != NULL)
        {
          delete[] pIndex;
          pIndex = 0;
        }
        delete[] ppItem;
        return;
      }

      if (ppItem[idx]->m_fIsPrimary)
      {
          ErrMsg(IDS_RM_USR_PRI_GRP, m_hPage);
          continue;
      }


      //
      // Put the item into the delete list and remove it from the list box.
      //
      if (!m_DelList.AddItem(ppItem[idx]))
      {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);

        if (pIndex != NULL)
        {
          delete[] pIndex;
          pIndex = 0;
        }
        delete[] ppItem;
        return;
      }

      m_pList->RemoveListItem(pIndex[idx]);

      for (int idx2 = idx; idx2 < nNumSelected; idx2++)
      {
        if (pIndex[idx2] > pIndex[idx])
        {
          pIndex[idx2]--;
        }
      }

      SetDirty();
    }
    //
    // Disable the Remove button, since nothing in the list box should have
    // the selection at this point.
    //
    //Since Remove Button has focus now, set focus to add button
    //before disabling

    SetFocus(GetDlgItem(m_hPage,IDC_ADD_BTN));
    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), FALSE);

    if (pIndex != NULL)
    {
      delete[] pIndex;
      pIndex = 0;
    }
    delete[] ppItem;

    return;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::GetRealDN
//
//  Synopsis:   If a member from an external domain that was added to the
//              group during this instance of the page, we won't yet have the
//              path to the FPO as the DN. So, search for the FPO using the
//              object-SID.
//
//-----------------------------------------------------------------------------
HRESULT
CDsGrpMembersPage::GetRealDN(CMemberListItem * pItem)
{
    return ::GetRealDN(this, pItem);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpMembersPage::OnDestroy(void)
{
    if (m_pList)
    {
        m_pList->ClearList();
    }

    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

HRESULT HrVariantToStringArray(const CComVariant& refvar, PWSTR** pppszStringArray, DWORD* pdwCount)
{
  HRESULT hr = S_OK;
  long start, end, current;
  *pdwCount = 0;
  *pppszStringArray = NULL;

	if (V_VT(&refvar) == VT_BSTR)
	{
		CComBSTR bstrVal = V_BSTR(&refvar);
    *pppszStringArray = new PWSTR[1];
    if (*pppszStringArray != NULL)
    {
      size_t length = wcslen(bstrVal);
      PWSTR pszVal = new WCHAR[length + 1];
      if (pszVal != NULL)
      {
        wcscpy(pszVal, bstrVal);
        (*pppszStringArray)[0] = pszVal;
      }
      else
      {
        delete[] *pppszStringArray;
        *pppszStringArray = NULL;
        *pdwCount = 0;
        return E_OUTOFMEMORY;
      }
    }
    *pdwCount = 1;
		return S_OK;
	}

  //
  // Check the VARIANT to make sure we have
  // an array of variants.
  //

  if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
  {
    dspAssert(FALSE);
    return E_UNEXPECTED;
  }
  SAFEARRAY *saAttributes = V_ARRAY( &refvar );

  //
  // Figure out the dimensions of the array.
  //

  hr = SafeArrayGetLBound( saAttributes, 1, &start );
  if( FAILED(hr) )
    return hr;

  hr = SafeArrayGetUBound( saAttributes, 1, &end );
  if( FAILED(hr) )
    return hr;

  CComVariant SingleResult;

  //
  // Process the array elements.
  //

  *pppszStringArray = new PWSTR[(end - start) + 1];
  if (*pppszStringArray != NULL)
  {
    for ( current = start; current <= end; current++) 
    {
      hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );
      if( FAILED(hr) )
        return hr;
      if ( V_VT(&SingleResult) != VT_BSTR )
        return E_UNEXPECTED;

      CComBSTR bstrVal = V_BSTR(&SingleResult);
      size_t length = wcslen(bstrVal);
      PWSTR pszVal = new WCHAR[length + 1];
      if (pszVal != NULL)
      {
        wcscpy(pszVal, bstrVal);

        long lCount = static_cast<long>(*pdwCount);
        if (lCount < (end - start) + 1)
        {
          (*pppszStringArray)[(*pdwCount)++] = pszVal;
        }
      }
      else
      {
        return E_OUTOFMEMORY;
      }
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
    *pdwCount = 0;
  }

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpMembersPage::LoadGroupExtraClasses
//
//  Synopsis:   Read the extra classes that need to be displayed from the
//              DisplaySpecifiers
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpMembersPage::LoadGroupExtraClasses(BOOL bSecurity)
{
  HRESULT hr = S_OK;
    
  dspAssert(m_pDsObj != NULL);
  if (m_pDsObj == NULL)
  {
    return E_INVALIDARG;
  }

  static LPCWSTR lpszSettingsObjectClass = L"dsUISettings";
  static LPCWSTR lpszSettingsObject = L"cn=DS-UI-Default-Settings";
  static LPCWSTR lpszSecurityGroupProperty = L"msDS-Security-Group-Extra-Classes";
  static LPCWSTR lpszNonSecurityGroupProperty = L"msDS-Non-Security-Group-Extra-Classes";

  //
  // Not AddRef'd so don't use a smart pointer
  //
  IDsDisplaySpecifier* pDispSpec;
  hr = GetIDispSpec(&pDispSpec);
  CHECK_HRESULT_REPORT(hr, GetHWnd(), return hr);

  //
  // get the display specifiers locale container (e.g. 409)
  //
  CComPtr<IADsContainer> spLocaleContainer;
  hr = pDispSpec->GetDisplaySpecifier(NULL, IID_IADsContainer, (void**)&spLocaleContainer);
  if (FAILED(hr))
  {
    return hr;
  }

  //
  // bind to the settings object
  //
  CComPtr<IDispatch> spIDispatchObject;
  hr = spLocaleContainer->GetObject((LPWSTR)lpszSettingsObjectClass, 
                                    (LPWSTR)lpszSettingsObject, 
                                    &spIDispatchObject);
  if (FAILED(hr))
  {
    return hr;
  }

  CComPtr<IADs> spSettingsObject;
  hr = spIDispatchObject->QueryInterface(IID_IADs, (void**)&spSettingsObject);
  if (FAILED(hr))
  {
    return hr;
  }

  if (bSecurity)
  {
    //
    // get the security group extra classes as a CStringList
    //
    CComVariant var;
    hr = spSettingsObject->Get((LPWSTR)lpszSecurityGroupProperty, &var);
    if (SUCCEEDED(hr))
    {
      hr = HrVariantToStringArray(var, &m_pszSecurityGroupExtraClasses, &m_dwSecurityGroupExtraClassesCount);
    }
  }
  else
  {
    //
    // get the non-security group extra classes as a CStringList
    //
    CComVariant var;
    hr = spSettingsObject->Get((LPWSTR)lpszNonSecurityGroupProperty, &var);
    if (SUCCEEDED(hr))
    {
      hr = HrVariantToStringArray(var, &m_pszNonSecurityGroupExtraClasses, &m_dwNonSecurityGroupExtraClassesCount);
    }
  }
  return hr;
}
//+----------------------------------------------------------------------------
//
//  Function:   GetDomainMode
//
//  Synopsis:   Is the domain to which the indicated object belongs in mixed
//              or native mode?
//
//-----------------------------------------------------------------------------
HRESULT
GetDomainMode(CDsPropPageBase * pObj, PBOOL pfMixed)
{
    HRESULT hr;
    CComBSTR cbstrDomain;

    hr = GetDomainScope(pObj, &cbstrDomain);

    CHECK_HRESULT_REPORT(hr, pObj->GetHWnd(), return hr);

    return GetDomainMode(cbstrDomain, pObj->GetHWnd(), pfMixed);
}

HRESULT
GetDomainMode(PWSTR pwzDomain, HWND hWnd, PBOOL pfMixed)
{
    HRESULT hr;
    WCHAR wzMixedAttr[] = L"nTMixedDomain";
    PWSTR rgpwzAttrNames[] = {wzMixedAttr};
    CComPtr <IDirectoryObject> pDomObj;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    dspDebugOut((DEB_ITRACE, "GetDomainMode targetted to %ws\n", pwzDomain));

    hr = ADsOpenObject(pwzDomain, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (void **)&pDomObj);

    CHECK_HRESULT_REPORT(hr, hWnd, return hr);

    hr = pDomObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    CHECK_HRESULT_REPORT(hr, hWnd, return hr);

    if (cAttrs && pAttrs && (_wcsicmp(pAttrs->pszAttrName, wzMixedAttr) == 0))
    {
        *pfMixed = (BOOL)pAttrs->pADsValues->Integer;

        FreeADsMem(pAttrs);
    }
    else
    {
        *pfMixed = 0;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetGroupType
//
//-----------------------------------------------------------------------------
HRESULT
GetGroupType(CDsPropPageBase * pObj, DWORD * pdwType)
{
    HRESULT hr;
    PWSTR rgpwzAttrNames[] = {g_wzGroupType};
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    hr = pObj->m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    CHECK_HRESULT_REPORT(hr, pObj->GetHWnd(), return hr);

    if (cAttrs && pAttrs && (_wcsicmp(pAttrs->pszAttrName, g_wzGroupType) == 0))
    {
        *pdwType = pAttrs->pADsValues->Integer;

        FreeADsMem(pAttrs);
    }
    else
    {
        *pdwType = 0;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   FillGroupList
//
//  Synopsis:   Fill the list box with the names of the group members.
//
//-----------------------------------------------------------------------------
HRESULT
FillGroupList(CDsPropPageBase * pPage, CDsMembershipList * pList,
              DWORD dwGroupRID)
{
    TRACE_FUNCTION(FillGroupList);
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD i, cAttrs = 0;
    WCHAR wzMemberAttr[MAX_PATH] = L"member;range=0-*";
    const WCHAR wcSep = L'-';
    const WCHAR wcEnd = L'*';
    const WCHAR wzFormat[] = L"member;range=%ld-*";
    PWSTR pwzAttrName[] = {wzMemberAttr}, pwzPath;
    BOOL fMoreRemain = FALSE, fNameNotMapped = FALSE;
    CComPtr <IDirectorySearch> spDsSearch;

    //
    // Read the membership list from the object using range (incremental)
    // retrieval.
    //
    do
    {
        hr = pPage->m_pDsObj->GetObjectAttributes(pwzAttrName, 1, &spAttrs, &cAttrs);

        if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, pPage->GetHWnd()))
        {
            return hr;
        }

        if (cAttrs > 0 && spAttrs != NULL)
        {
            for (i = 0; i < spAttrs->dwNumValues; i++)
            {
                hr = pList->InsertIntoNewList(spAttrs->pADsValues[i].CaseIgnoreString);

                if (DS_NAME_ERROR_NO_MAPPING == HRESULT_CODE(hr))
                {
                    fNameNotMapped = TRUE;
                    hr = S_OK;
                }
                else
                {
                    CHECK_HRESULT(hr, return hr);
                }
            }
            //
            // Check to see if there is more data. If the last char of the
            // attribute name string is an asterisk, then we have everything.
            //
            size_t cchEnd = wcslen(spAttrs->pszAttrName);

            fMoreRemain = spAttrs->pszAttrName[cchEnd - 1] != wcEnd;

            if (fMoreRemain)
            {
                PWSTR pwz = wcsrchr(spAttrs->pszAttrName, wcSep);
                if (!pwz)
                {
                    dspAssert(FALSE && spAttrs->pszAttrName);
                    fMoreRemain = FALSE;
                }
                else
                {
                    pwz++; // move past the hyphen to the range end value.
                    dspAssert(*pwz);
                    long lEnd = _wtol(pwz);
                    lEnd++; // start with the next value.
                    wsprintfW(wzMemberAttr, wzFormat, lEnd);
                    dspDebugOut((DEB_ITRACE,
                                 "Range returned is %ws, now asking for %ws\n",
                                 spAttrs->pszAttrName, wzMemberAttr));
                }
            }
        }
    } while (fMoreRemain);

    //
    // Query for all users/computers who have this as their primary group.
    //
    // Filter out interdomain-trust accounts (0x30000002).
    // This value is defined in ds\src\dsamain\include\mappings.h
    //
    WCHAR wzSearchFormat[] = L"(&(primaryGroupID=%u)(sAMAccountType<=805306369))";

    CStrW strSearchFilter;
    strSearchFilter.Format(wzSearchFormat, dwGroupRID);

    BSTR bstrDomain;

    hr = GetDomainScope(pPage, &bstrDomain);

    CHECK_HRESULT(hr, return hr);

    pwzAttrName[0] = g_wzADsPath;

    CDSSearch Search;
    hr = Search.Init((LPCWSTR)bstrDomain);

    SysFreeString(bstrDomain);
    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    Search.SetFilterString(const_cast<LPWSTR>((LPCWSTR)strSearchFilter));

    Search.SetAttributeList(pwzAttrName, 1);
    Search.SetSearchScope(ADS_SCOPE_SUBTREE);

    hr = Search.DoQuery();

    while (SUCCEEDED(hr))
    {
        hr = Search.GetNextRow();

        if (hr == S_ADS_NOMORE_ROWS)
        {
            hr = S_OK;
            break;
        }

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        ADS_SEARCH_COLUMN Column = {0};

        hr = Search.GetColumn(g_wzADsPath, &Column);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        hr = pPage->SkipPrefix(Column.pADsValues->CaseIgnoreString, &pwzPath);

        Search.FreeColumn(&Column);
        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        hr = pList->InsertIntoNewList(pwzPath, TRUE);

        delete pwzPath;
        CHECK_HRESULT(hr, return hr);
    }

    if (pList->GetCount() < 1)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_REMOVE_BTN), FALSE);
    }
    else if (((CDsGrpMembersPage *)pPage)->m_fShowIcons)
    {
        // Get class and userAccountControl for the group members and use
        // those values to select icons.
        //
        pList->SetMemberIcons(pPage);
    }

    if (fNameNotMapped)
    {
        MsgBox(IDS_GRP_NO_NAME_MAPPING, pPage->GetHWnd());
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRealDN
//
//  Synopsis:   If a member from an external domain that was added to the
//              group during this instance of the page, we won't yet have the
//              path to the FPO as the DN. So, search for the FPO using the
//              object-SID.
//
//-----------------------------------------------------------------------------
HRESULT
GetRealDN(CDsPropPageBase * pPage, CMemberListItem * pItem)
{
    HRESULT hr = S_OK;

    if (!pItem->GetSid())
    {
        return E_FAIL;
    }

    CComBSTR cbstrDomain;

    hr = GetDomainScope(pPage, &cbstrDomain);

    CHECK_HRESULT(hr, return hr);

    CStrW strDN;

    hr = FindFPO(pItem->GetSid(), cbstrDomain, strDN);
    //Don't show this eror here
    if(FAILED(hr))
        return hr;

    PWSTR pwzOldDN = pItem->m_pwzDN;

    if (!AllocWStr(const_cast<PWSTR>((LPCWSTR)strDN), &pItem->m_pwzDN))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    DO_DEL(pwzOldDN);

    pItem->m_fIsExternal = FALSE;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpShlGenPage::CDsGrpShlGenPage
//
//-----------------------------------------------------------------------------
CDsGrpShlGenPage::CDsGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags) :
    m_pCIcon(NULL),
    m_fDescrWritable(FALSE),
    m_fDescrDirty(FALSE),
    CDsGrpMembersPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsGrpShlGenPage,CDsGrpShlGenPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsGrpShlGenPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGrpShlGenPage::~CDsGrpShlGenPage
//
//-----------------------------------------------------------------------------
CDsGrpShlGenPage::~CDsGrpShlGenPage()
{
    TRACE(CDsGrpShlGenPage,~CDsGrpShlGenPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateGrpShlGenPage
//
//  Synopsis:   Creates an instance of the group shell general page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                    PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                    DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                    HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGroupMembersPage);

    CDsGrpShlGenPage * pPageObj = new CDsGrpShlGenPage(pDsPage, pDataObj,
                                                       hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsGrpShlGenPage::OnInitDialog(LPARAM lParam)
{
    TRACE(CDsGrpShlGenPage,OnInitDialog);
    HRESULT hr;
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD cAttrs = 0;

    CWaitCursor Wait;

    //
    // Get the icon from the DS and put it on the page.
    //
    ATTR_DATA ad = {0, 0};

    hr = GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fInit);

    CHECK_HRESULT_REPORT(hr, m_hPage, return S_OK);

    m_pCIcon = (CDsIconCtrl *)ad.pVoid;

    //
    // Get the name.
    //
    LPTSTR ptz;
    if (!UnicodeToTchar(m_pwszRDName, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return S_OK;
    }

    SetDlgItemText(m_hPage, IDC_CN, ptz);
    delete [] ptz;

    m_fDescrWritable = CheckIfWritable(g_wzDescription);

    //
    // Get the description
    //
    PWSTR rgpwzAttrNames[] = {g_wzDescription};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
    {
        return S_OK;
    }

    if (1 == cAttrs)
    {
        dspAssert(spAttrs);
        if (!UnicodeToTchar(spAttrs->pADsValues->CaseIgnoreString, &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return S_OK;
        }
        SetDlgItemText(m_hPage, IDC_DESCRIPTION_EDIT, ptz);
        delete [] ptz;
    }

    if (m_fDescrWritable)
    {
        SendDlgItemMessage(m_hPage, IDC_DESCRIPTION_EDIT, EM_LIMITTEXT, DSPROP_DESCRIPTION_RANGE_UPPER, 0);
    }
    else
    {
        SendDlgItemMessage(m_hPage, IDC_DESCRIPTION_EDIT, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }

    HRESULT hRes = CDsGrpMembersPage::OnInitDialog(lParam, FALSE);

#if !defined(DSADMIN)
    // in the Win95 shell, we do not want to have the buttons
    // because we do not have object picker
    MakeNotWritable();
    EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BTN), FALSE);
#endif
    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BTN), FALSE);

    return  hRes;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpShlGenPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }
    if (EN_CHANGE == codeNotify && IDC_DESCRIPTION_EDIT == id)
    {
        m_fDescrDirty = TRUE;
    }
    TRACE(CDsGrpShlGenPage,OnCommand);
    return CDsGrpMembersPage::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnApply
//
//  Synopsis:   Write changes
//
//-----------------------------------------------------------------------------
LRESULT CDsGrpShlGenPage::OnApply(void)
{
    TRACE(CDsGrpShlGenPage,OnApply);

    ADS_ATTR_INFO AttrInfoDesc = {g_wzDescription, ADS_ATTR_UPDATE,
                                  ADSTYPE_CASE_IGNORE_STRING, NULL, 0};
    ADSVALUE ADsValueDesc = {ADSTYPE_CASE_IGNORE_STRING, NULL};

    AttrInfoDesc.pADsValues = &ADsValueDesc;
    AttrInfoDesc.dwNumValues = 1;
    LPTSTR ptsz;

    if (m_fDescrDirty)
    {
        dspAssert(m_fDescrWritable);

        ptsz = new TCHAR[DSPROP_DESCRIPTION_RANGE_UPPER + 1];
        CHECK_NULL_REPORT(ptsz, m_hPage, return -1);

        if (GetDlgItemText(m_hPage, IDC_DESCRIPTION_EDIT, ptsz, DSPROP_DESCRIPTION_RANGE_UPPER + 1) == 0)
        {
            // An empty control means remove the attribute value from the
            // object.
            //
            AttrInfoDesc.dwNumValues = 0;
            AttrInfoDesc.pADsValues = NULL;
            AttrInfoDesc.dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            if (!TcharToUnicode(ptsz, &ADsValueDesc.CaseIgnoreString))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                delete ptsz;
                return -1;
            }
        }
        delete ptsz;
        DWORD cModified;

        HRESULT hr = m_pDsObj->SetObjectAttributes(&AttrInfoDesc, 1, &cModified);

        if (!CHECK_ADS_HR(&hr, m_hPage))
        {
            goto Cleanup;
        }

        m_fDescrDirty = FALSE;
    }

Cleanup:
    DO_DEL(ADsValueDesc.CaseExactString);

    return CDsGrpMembersPage::OnApply();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGrpShlGenPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsGrpShlGenPage::OnDestroy(void)
{
    ATTR_DATA ad = {0, (LPARAM)m_pCIcon};

    GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fOnDestroy);

    CDsGrpMembersPage::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckGroupUpdate
//
//  Synopsis:   Checks the result code to see if a group-specific error has
//              occured.
//
//-----------------------------------------------------------------------------
BOOL
CheckGroupUpdate(HRESULT hr, HWND hPage, BOOL fAdd, PWSTR pwzDN)
{
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    if (hPage == NULL)
    {
        hPage = GetDesktopWindow();
    }
    DWORD dwErr = 0;
    WCHAR wszErrBuf[MAX_PATH+1];
    WCHAR wszNameBuf[MAX_PATH+1];
    ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);
    //
    // ERROR_DS_CONSTRAINT_VIOLATION is the error returned for
    // duplicate name.
    //
    if ((LDAP_RETCODE)dwErr == LDAP_CONSTRAINT_VIOLATION ||
        hr == HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION))
    {
        PTSTR ptzTitle, ptzMsg;

        if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
        {
            goto FatalError;
        }
        if (!LoadStringToTchar((fAdd) ? IDS_ERRMSG_GROUP_CONSTRAINT :
                                        IDS_ERRMSG_GROUP_DELETE, &ptzMsg))
        {
            delete ptzTitle;
            goto FatalError;
        }
        MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
        delete [] ptzTitle;
        delete [] ptzMsg;
    }
    else if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT && fAdd)
    {
      // Put a useful message up
      PTSTR ptzTitle = 0, ptzMsg = 0;
      if (!LoadStringToTchar(IDS_MSG_USER_NOT_PRESENT, &ptzMsg))
      {
        goto FatalError;
      }
      if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
      {
        goto FatalError;
      }
      MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
      delete[] ptzTitle;
      delete[] ptzMsg;
    }
    else if (HRESULT_CODE(dwErr) == ERROR_DS_NO_ATTRIBUTE_OR_VALUE && !fAdd)
    {
      // No message needed
      return FALSE;
    }
    else if (HRESULT_CODE(dwErr) == ERROR_MEMBER_NOT_IN_ALIAS && !fAdd)
    {
      // Put a useful message up
      bool bShowGenericMessage = true;
      if (pwzDN)
      {
        //
        // Crack the DN into the name
        //
        CComPtr<IADsPathname> spPathcracker;
        hr = CoCreateInstance(CLSID_Pathname, 
                              NULL, 
                              CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, 
                              (PVOID *)&spPathcracker);
        if (SUCCEEDED(hr))
        {
          hr = spPathcracker->Set(pwzDN, ADS_SETTYPE_DN);
          if (SUCCEEDED(hr))
          {
            hr = spPathcracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            if (SUCCEEDED(hr))
            {
              CComBSTR sbstrName;
              hr = spPathcracker->Retrieve(ADS_FORMAT_LEAF, &sbstrName);
              if (SUCCEEDED(hr))
              {
                ErrMsgParam(IDS_MSG_MEMBER_ALREADY_GONE, (LPARAM)(PWSTR)sbstrName, hPage);
                bShowGenericMessage = false;
              }
            }
          }
        }
      }

      if (bShowGenericMessage)
      {
        PTSTR ptzTitle = 0, ptzMsg = 0;
        if (!LoadStringToTchar(IDS_MSG_MEMBER_ALREADY_GONE2, &ptzMsg))
        {
          goto FatalError;
        }
        if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
        {
          goto FatalError;
        }
        MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
        delete[] ptzTitle;
        delete[] ptzMsg;
      }
    }
    else
    {
        if (dwErr)
        {
            dspDebugOut((DEB_ERROR, 
                         "Extended Error 0x%x: %ws %ws.\n", dwErr,
                         wszErrBuf, wszNameBuf));
            ReportError(dwErr, IDS_ADS_ERROR_FORMAT, hPage);
        }
        else
        {
            dspDebugOut((DEB_ERROR, "Error %08lx\n", hr));
            ReportError(hr, IDS_ADS_ERROR_FORMAT, hPage);
        }
    }
    return FALSE;

FatalError:
    MessageBoxA(hPage, "A Fatal Error has occured!", "Active Directory Service",
                MB_OK | MB_ICONEXCLAMATION);

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   FindFPO
//
//  Synopsis:   Given a SID, look for a corresponding FPO.
//
//-----------------------------------------------------------------------------
HRESULT
FindFPO(PSID pSid, PWSTR pwzDomain, CStrW & strFPODN)
{
    HRESULT hr;
    CDSSearch Srch;

    hr = Srch.Init(pwzDomain);

    CHECK_HRESULT(hr, return hr);

    PWSTR rgpwzAttrNames[] = {g_wzDN};

    hr = Srch.SetAttributeList(rgpwzAttrNames, 1);

    CHECK_HRESULT(hr, return hr);

    Srch.SetSearchScope(ADS_SCOPE_SUBTREE);

    WCHAR wzSearchFormat[] = L"(&(objectCategory=foreignSecurityPrincipal)(objectSid=%s))";
    PWSTR pwzSID;
    CStrW strSearchFilter;

    hr = ADsEncodeBinaryData((PBYTE)pSid,
                             GetLengthSid(pSid),
                             &pwzSID);

    CHECK_HRESULT(hr, return hr);

    strSearchFilter.Format(wzSearchFormat, pwzSID);

    FreeADsMem(pwzSID);

    Srch.SetFilterString(const_cast<LPWSTR>((LPCWSTR)strSearchFilter));

    hr = Srch.DoQuery();

    CHECK_HRESULT(hr, return hr);

    hr = Srch.GetNextRow();

    if (hr == S_ADS_NOMORE_ROWS)
    {
        // No object has a matching SID, the FPO must have been deleted.
        //
        return HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND);
    }
    CHECK_HRESULT(hr, return hr);
    ADS_SEARCH_COLUMN Column;

    hr = Srch.GetColumn(g_wzDN, &Column);

    CHECK_HRESULT(hr, return hr);

    strFPODN = Column.pADsValues->CaseIgnoreString;

    if (strFPODN.IsEmpty())
    {
        Srch.FreeColumn(&Column);
        return E_OUTOFMEMORY;
    }

    Srch.FreeColumn(&Column);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:      CMemberDomainMode
//
//  Purpose:    Maintains a list of all domains in the enterprise from which
//              members have been added along with those domains' mode. Keeps
//              a second list of members who have been added from mixed-mode
//              domains.
//
//-----------------------------------------------------------------------------

void
CMemberDomainMode::Init(CDsPropPageBase * pPage)
{
    m_pPage = pPage;

    m_MemberList.Clear();
}

HRESULT
CMemberDomainMode::CheckMember(PWSTR pwzMemberDN)
{
    HRESULT hr;
    CComBSTR cbstrDomain;
    BOOL fMixed = FALSE;

    hr = GetObjectsDomain(m_pPage, pwzMemberDN, &cbstrDomain);

    if (SUCCEEDED(hr) && cbstrDomain)
    {
      if (!m_DomainList.Find(cbstrDomain, &fMixed))
      {
          // The member's domain is not already in the list. Read the domain
          // mode and then add it.
          //
          hr = GetDomainMode(cbstrDomain, m_pPage->GetHWnd(), &fMixed);

          CHECK_HRESULT(hr, return hr);

          hr = m_DomainList.Insert(cbstrDomain, fMixed);

          CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);
      }
    }

    if (fMixed)
    {
        PWSTR pwzCanEx;
        PTSTR ptzCanEx;
        CStr strName;

        hr = CrackName(pwzMemberDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_pPage->GetHWnd());

        CHECK_HRESULT(hr, return hr);

        if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
        {
            LocalFreeStringW(&pwzCanEx);
            REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        LocalFreeStringW(&pwzCanEx);

        CStr cstrFolder;

        GetNameParts(ptzCanEx, cstrFolder, strName);

        DO_DEL(ptzCanEx);

        hr = m_MemberList.Insert(strName);

        CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);
    }

    return S_OK;
}

HRESULT
CMemberDomainMode::ListExternalMembers(CStr & strList)
{
    m_MemberList.GetList(strList);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  CMemberDomainMode helper classes
//
//-----------------------------------------------------------------------------

HRESULT
CMMMemberList::Insert(LPCTSTR ptzName)
{
    CMMMemberListItem * pItem = new CMMMemberListItem;

    if (!pItem)
    {
        return E_OUTOFMEMORY;
    }

    pItem->m_strName = ptzName;

    if (m_pListHead == NULL)
    {
        m_pListHead = pItem;
    }
    else
    {
        pItem->LinkAfter(m_pListHead);
    }
    return S_OK;
}

#define MAX_MMMLISTING  25

void
CMMMemberList::GetList(CStr & strList)
{
    int nCount = 0;

    strList.Empty();

    CMMMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        strList += pItem->m_strName;

        nCount++;

        pItem = pItem->Next();
        if (pItem)
        {
            if (nCount > MAX_MMMLISTING)
            {
                strList += TEXT("...");
                return;
            }
            else
            {
                strList += TEXT(", ");
            }
        }
    }
}

void
CMMMemberList::Clear(void)
{
    CMMMemberListItem * pItem = m_pListHead, * pNext;

    while (pItem)
    {
        pNext = pItem->Next();
        delete pItem;
        pItem = pNext;
    }

    m_pListHead = NULL;
}

CDomainModeList::~CDomainModeList(void)
{
    CDomainModeListItem * pItem = m_pListHead, * pNext;

    while (pItem)
    {
        pNext = pItem->Next();
        delete pItem;
        pItem = pNext;
    }
}

HRESULT
CDomainModeList::Insert(PWSTR pwzDomain, BOOL fMixed)
{
    CDomainModeListItem * pItem = new CDomainModeListItem;

    if (!pItem)
    {
        return E_OUTOFMEMORY;
    }

    pItem->m_strName = pwzDomain;
    pItem->m_fMixed = fMixed;

    if (m_pListHead == NULL)
    {
        m_pListHead = pItem;
    }
    else
    {
        pItem->LinkAfter(m_pListHead);
    }
    return S_OK;
}

BOOL
CDomainModeList::Find(LPCWSTR pwzDomain, PBOOL pfMixed)
{
    CDomainModeListItem * pItem = m_pListHead;

    while (pItem)
    {
        if (_wcsicmp(pwzDomain, pItem->m_strName) == 0)
        {
            *pfMixed = pItem->m_fMixed;
            return TRUE;
        }
        pItem = pItem->Next();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       debug.h
//
//  Contents:   Debug routines and miscelaneous stuff.
//
//  Classes:    None.
//
//  History:    24-Mar-97   EricB   Created
//
//  Notes on Error Handling: The general rule is that errors will be reported
//  to the user as close to the detection of the error as possible. There are
//  two exceptions to this rule. First, utility routines that don't take an
//  HWND parameter (or a page object pointer) don't report errors because we
//  want a window handle so that the error dialogs will be modal. Second,
//  there are some circumstances where the error needs to be interpreted at a
//  higher level. These exceptions should be noted where they occur.
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_HXX__
#define __DEBUG_HXX__

// macros

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

//+----------------------------------------------------------------------------
// Macro: LOAD_STRING
// Purpose: attempts to load a string, takes "action" if fails
//-----------------------------------------------------------------------------
#define LOAD_STRING(ids, wcs, len, action) \
    if (!LoadString(g_hInstance, ids, wcs, len - 1)) \
    { \
        DWORD dwErr = GetLastError(); \
        dspDebugOut((DEB_ERROR, "LoadString of " #ids " failed with error %lu\n", dwErr)); \
        action; \
    }

//+----------------------------------------------------------------------------
// Function: LoadStringReport
// Purpose: attempts to load a string, returns FALSE and gives error message
//          if a failure occurs.
//-----------------------------------------------------------------------------
BOOL LoadStringReport(int ids, PTSTR ptsz, int len, HWND hwnd);

//
// debugging support
//

#if DBG == 1

#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

#ifdef __cplusplus
extern "C" {
#define EXTRNC "C"
#else
#define EXTRNC
#endif

// smprintf should only be called from xxDebugOut()

   void APINOT
   smprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   void          APINOT
   SmAssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   int APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   void APINOT
   CheckInit(char * pInfoLevelString, unsigned long * InfoLevel);

#define DSP_DEBUG_BUF_SIZE (512)

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
 #define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif


#define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char* comp##InfoLevelString = #comp;


#ifdef __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel); \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

#else  // ! __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel);
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

#endif // ! __cplusplus

DECLARE_DEBUG(DsProp)

#define dspDebugOut(x) DsPropInlineDebugOut x
#define dspAssert(x) (void)((x) || (SmAssertEx(__FILE__, __LINE__, #x),0))

#include "dscmn.h"

#define ERR_OUT(msg, hr) \
    if (SUCCEEDED(hr)) { \
        dspDebugOut((DEB_ERROR, #msg "\n")); \
    } else { \
        dspDebugOut((DEB_ERROR, #msg " failed with error 0x%x\n", hr)); \
        ReportError(hr, 0, 0); \
    }

#define REPORT_ERROR(hr, hwnd) \
    dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                 __FILE__, __LINE__, hr)); \
    ReportError(hr, 0, hwnd);

#define REPORT_ERROR_FORMAT(hr, ids, hwnd) \
    dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                 __FILE__, __LINE__, hr)); \
    ReportError(hr, ids, hwnd);

#define ERR_MSG(id, hwnd) \
    dspDebugOut((DEB_ERROR, "**** ERROR <%s @line %d> msg string ID: %d\n", \
                 __FILE__, __LINE__, id)); \
    ErrMsg(id, hwnd);

#define CHECK_HRESULT(hr, action) \
    if (FAILED(hr)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                     __FILE__, __LINE__, hr)); \
        action; \
    }

#define CHECK_HRESULT_REPORT(hr, hwnd, action) \
    if (FAILED(hr)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                     __FILE__, __LINE__, hr)); \
        ReportError(hr, 0, hwnd); \
        action; \
    }

#define CHECK_NULL(ptr, action) \
    if (ptr == NULL) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> NULL ptr\n", \
                     __FILE__, __LINE__)); \
        action; \
    }

#define CHECK_NULL_REPORT(ptr, hwnd, action) \
    if (ptr == NULL) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> NULL ptr\n", \
                     __FILE__, __LINE__)); \
        ReportError(E_OUTOFMEMORY, 0, hwnd); \
        action; \
    }

#define CHECK_WIN32(err, action) \
    if (err != ERROR_SUCCESS) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %d\n", \
                     __FILE__, __LINE__, err)); \
        action; \
    }

#define CHECK_WIN32_REPORT(err, hwnd, action) \
    if (err != ERROR_SUCCESS) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> %d\n", \
                     __FILE__, __LINE__, err)); \
        ReportError(err, 0, hwnd); \
        action; \
    }

#define CHECK_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        action; \
    }

#define CHECK_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        ReportError(RtlNtStatusToDosError(err), 0, hwnd); \
        action; \
    }

#define CHECK_LSA_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        action; \
    }

#define CHECK_LSA_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        dspDebugOut((DEB_ERROR, "**** ERROR RETURN <%s @line %d> -> 0x%08x\n", \
                     __FILE__, __LINE__, err)); \
        ReportError(LsaNtStatusToWinError(err), 0, hwnd); \
        action; \
    }

#define TRACER(ClassName,MethodName) \
    dspDebugOut((DEB_TRACE, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE(ClassName,MethodName) \
    dspDebugOut((DEB_USER1, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE2(ClassName,MethodName) \
    dspDebugOut((DEB_USER2, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE3(ClassName,MethodName) \
    dspDebugOut((DEB_USER3, #ClassName"::"#MethodName"(0x%p)\n", this)); \
    if (DsPropInfoLevel & DEB_USER5) HeapValidate(GetProcessHeap(), 0, NULL);

#define TRACE_FUNCTION(FunctionName) \
    dspDebugOut((DEB_USER1, #FunctionName"\n"));

#define TRACE_FUNCTION3(FunctionName) \
    dspDebugOut((DEB_USER3, #FunctionName"\n"));

#define DBG_OUT(String) \
    dspDebugOut((DEB_ITRACE, String "\n"));

#define DBG_OUT3(String) \
    dspDebugOut((DEB_USER3, String "\n"));

#else // DBG != 1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#define dspDebugOut(x)

#define dspAssert(x) 

#include "dscmn.h"

#define ERR_OUT(msg, hr) \
        ReportError(hr, 0, 0);

#define REPORT_ERROR(hr, hwnd) ReportError(hr, 0, hwnd);

#define REPORT_ERROR_FORMAT(hr, ids, hwnd) ReportError(hr, ids, hwnd);

#define ERR_MSG(id, hwnd) \
    ErrMsg(id, hwnd);

#define CHECK_HRESULT(hr, action) \
    if (FAILED(hr)) { \
        action; \
    }

#define CHECK_HRESULT_H(hr, hwnd, action) \
    if (FAILED(hr)) { \
        action; \
    }

#define CHECK_HRESULT_REPORT(hr, hwnd, action) \
    if (FAILED(hr)) { \
        ReportError(hr, 0, hwnd); \
        action; \
    }

#define CHECK_NULL(ptr, action) \
    if (ptr == NULL) { \
        action; \
    }

#define CHECK_NULL_REPORT(ptr, hwnd, action) \
    if (ptr == NULL) { \
        ReportError(E_OUTOFMEMORY, 0, hwnd); \
        action; \
    }

#define CHECK_WIN32(err, action) \
    if (err != ERROR_SUCCESS) { \
        ReportError(err, 0); \
        action; \
    }

#define CHECK_WIN32_REPORT(err, hwnd, action) \
    if (err != ERROR_SUCCESS) { \
        ReportError(err, 0, hwnd); \
        action; \
    }

#define CHECK_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        action; \
    }

#define CHECK_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        ReportError(err, 0, hwnd); \
        action; \
    }

#define CHECK_LSA_STATUS(err, action) \
    if (!NT_SUCCESS(err)) { \
        action; \
    }

#define CHECK_LSA_STATUS_REPORT(err, hwnd, action) \
    if (!NT_SUCCESS(err)) { \
        ReportError(LsaNtStatusToWinError(err), 0, hwnd); \
        action; \
    }

#define TRACER(ClassName,MethodName)
#define TRACE(ClassName,MethodName)
#define TRACE2(ClassName,MethodName)
#define TRACE3(ClassName,MethodName)
#define TRACE_FUNCTION(FunctionName)
#define TRACE_FUNCTION3(FunctionName)
#define DBG_OUT(String)
#define DBG_OUT3(String)

#endif // DBG == 1

#endif // __DEBUG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\group.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       group.h
//
//  Contents:   DS object property pages class header
//
//  Classes:    CDsPropPagesHost, CDsPropPagesHostCF, CDsTableDrivenPage
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _GROUP_H_
#define _GROUP_H_

#include "proppage.h"
#include "pages.h"
#include "objlist.h"
#include <initguid.h>
#include "objselp.h"

HRESULT
CreateGroupMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                       PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                       DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                       HPROPSHEETPAGE * phPage);

HRESULT
CreateGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                      HPROPSHEETPAGE * phPage);

HRESULT
CreateGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                    PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                    DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                    HPROPSHEETPAGE * phPage);

HRESULT GetDomainMode(CDsPropPageBase * pObj, PBOOL pfMixed);
HRESULT GetDomainMode(PWSTR pwzDomain, HWND hWnd, PBOOL pfMixed);
HRESULT GetGroupType(CDsPropPageBase * pObj, DWORD * pdwType);

//+----------------------------------------------------------------------------
//
//  Class:      CDsGroupGenObjPage
//
//  Purpose:    property page object class for the general page of the
//              group object.
//
//-----------------------------------------------------------------------------
class CDsGroupGenObjPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                       DWORD dwFlags);
    ~CDsGroupGenObjPage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    void    OnQuerySiblings(WPARAM wParam, LPARAM lParam);
    void    OnAttrChanged(WPARAM wParam);
    LRESULT OnDestroy(void);
	HRESULT IsSpecialAccount(bool& fIsSpecialAccount);

    CDsIconCtrl       * m_pCIcon;
    BOOL                m_fMixed; // Domain is in mixed mode
    DWORD               m_dwType;
    BOOL                m_fTypeWritable;
    BOOL                m_fDescrWritable;
    BOOL                m_fSamNameWritable;
    BOOL                m_fEmailWritable;
    BOOL                m_fCommentWritable;
    BOOL                m_fTypeDirty;
    BOOL                m_fDescrDirty;
    BOOL                m_fSamNameDirty;
    BOOL                m_fEmailDirty;
    BOOL                m_fCommentDirty;
};

HRESULT FillGroupList(CDsPropPageBase * pPage, CDsMembershipList * pList,
                      DWORD dwGroupRID);
HRESULT GetRealDN(CDsPropPageBase * pPage, CMemberListItem * pItem);
HRESULT FindFPO(PSID pSid, PWSTR pwzDomain, CStrW & strFPODN);

//+----------------------------------------------------------------------------
//
//  CMemberDomainMode helper classes
//
//-----------------------------------------------------------------------------
class CMMMemberListItem : public CDLink
{
public:
    CMMMemberListItem(void) {};
    ~CMMMemberListItem(void) {};

    // CDLink method overrides:
    CMMMemberListItem * Next(void) {return (CMMMemberListItem *)CDLink::Next();};

    CStr    m_strName;
};

class CMMMemberList
{
public:
    CMMMemberList(void) : m_pListHead(NULL) {};
    ~CMMMemberList(void) {Clear();};

    HRESULT Insert(LPCTSTR ptzName);
    void    GetList(CStr & strList);
    void    Clear(void);

private:
    CMMMemberListItem * m_pListHead;
};

class CDomainModeListItem : public CDLink
{
public:
    CDomainModeListItem(void) : m_fMixed(FALSE) {};
    ~CDomainModeListItem(void) {};

    // CDLink method overrides:
    CDomainModeListItem * Next(void) {return (CDomainModeListItem *)CDLink::Next();};

    CStrW   m_strName;
    BOOL    m_fMixed;
};

class CDomainModeList
{
public:
    CDomainModeList(void) : m_pListHead(NULL) {};
    ~CDomainModeList(void);

    HRESULT Insert(PWSTR pwzName, BOOL fMixed);
    BOOL    Find(LPCWSTR pwzDomain, PBOOL pfMixed);

private:
    CDomainModeListItem * m_pListHead;
};

//+----------------------------------------------------------------------------
//
//  Class:      CMemberDomainMode
//
//  Purpose:    Maintains a list of all domains in the enterprise from which
//              members have been added along with those domains' mode. Keeps
//              a second list of members who have been added from mixed-mode
//              domains.
//
//-----------------------------------------------------------------------------
class CMemberDomainMode
{
public:
    CMemberDomainMode(void) {};
    ~CMemberDomainMode(void) {};

    void    Init(CDsPropPageBase * pPage);
    HRESULT CheckMember(PWSTR pwzMemberDN);
    HRESULT ListExternalMembers(CStr & strList);

private:

    CDomainModeList     m_DomainList;
    CMMMemberList       m_MemberList;
    CDsPropPageBase   * m_pPage;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsSelectionListWrapper
//
//  Purpose:    A wrapper class for the DS_SELECTION_LIST that maintains a 
//              linked list of DS_SELECTION items and can make a DS_SELECTION_LIST
//              from that list
//
//-----------------------------------------------------------------------------
class CDsSelectionListWrapper
{
public:
  CDsSelectionListWrapper() : m_pNext(NULL), m_pSelection(NULL) {}
  ~CDsSelectionListWrapper() {}

  CDsSelectionListWrapper*  m_pNext;
  PDS_SELECTION             m_pSelection;

  static PDS_SELECTION_LIST CreateSelectionList(CDsSelectionListWrapper* pHead);
  static UINT GetCount(CDsSelectionListWrapper* pHead);
  static void DetachItemsAndDeleteList(CDsSelectionListWrapper* pHead);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsGrpMembersPage
//
//  Purpose:    Property page object class for the group object's membership
//              page.
//
//-----------------------------------------------------------------------------
class CDsGrpMembersPage : public CDsPropPageBase,
                          public ICustomizeDsBrowser
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsGrpMembersPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
    ~CDsGrpMembersPage(void);

    //
    // IUknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // ICustomizeDsBrowser methods 
    //
    STDMETHOD(Initialize)(THIS_
                          HWND         hwnd,
                          PCDSOP_INIT_INFO pInitInfo,
                          IBindHelper *pBindHelper);

    STDMETHOD(GetQueryInfoByScope)(THIS_
                IDsObjectPickerScope *pDsScope,
                PDSQUERYINFO *ppdsqi);

    STDMETHOD(AddObjects)(THIS_
                IDsObjectPickerScope *pDsScope,
                IDataObject **ppdo);

    STDMETHOD(ApproveObjects)(THIS_
                IDsObjectPickerScope*,
                IDataObject*,
                PBOOL) { return S_OK; }  // Approve everything

    STDMETHOD(PrefixSearch)(THIS_
                IDsObjectPickerScope *pDsScope,
                PCWSTR pwzSearchFor,
                IDataObject **pdo);

    STDMETHOD_(PSID, LookupDownlevelName)(THIS_
                                          PCWSTR) { return NULL; }

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    m_fShowIcons;

protected:
    HRESULT OnInitDialog(LPARAM lParam);
    HRESULT OnInitDialog(LPARAM lParam, BOOL fShowIcons);
    LRESULT OnApply(void);
    virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);

private:
    void    InvokeUserQuery(void);
    void    RemoveMember(void);
    HRESULT FillGroupList(void);
    HRESULT GetRealDN(CMemberListItem * pDelItem);

    HRESULT LoadGroupExtraClasses(BOOL bSecurity);
    HRESULT BuildQueryString(PWSTR* ppszFilterString);
    HRESULT CollectDsObjects(PWSTR pszFilter,
                             IDsObjectPickerScope *pDsScope,
                             CDsPropDataObj *pdo);


    PWSTR*              m_pszSecurityGroupExtraClasses;
    DWORD               m_dwSecurityGroupExtraClassesCount;
    PWSTR*              m_pszNonSecurityGroupExtraClasses;
    DWORD               m_dwNonSecurityGroupExtraClassesCount;

    HWND                m_hwndObjPicker;
    PCDSOP_INIT_INFO    m_pInitInfo;
    CComPtr<IBindHelper> m_pBinder;

protected:
    CDsMembershipList * m_pList;
    CMemberLinkList     m_DelList;
    DWORD               m_dwGroupRID;
    BOOL                m_fMixed; // Domain is in mixed mode
    DWORD               m_dwType;
    BOOL                m_fMemberWritable;
    CMemberDomainMode   m_MixedModeMembers;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsGrpShlGenPage
//
//  Purpose:    Property page object class for the group object's shell general
//              page which includes membership manipulation which is gained by
//              subclassing CDsGrpMembersPage.
//
//-----------------------------------------------------------------------------
class CDsGrpShlGenPage : public CDsGrpMembersPage
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsGrpShlGenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                     DWORD dwFlags);
    ~CDsGrpShlGenPage(void);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnApply(void);
    LRESULT OnDestroy(void);

#if !defined(DSADMIN)
    void MakeNotWritable() { m_fMemberWritable = FALSE; m_fDescrWritable = FALSE;}
#endif

    CDsIconCtrl       * m_pCIcon;
    BOOL                m_fDescrWritable;
    BOOL                m_fDescrDirty;
};

#endif // _GROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\cstr.h ===
// This is copied from the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This has been modified from the original MFC version to provide
// two classes: CStrW manipulates and stores only wide char strings,
// and CStr uses TCHARs.
// 

#ifndef __STR_H__
#define __STR_H__

#include <wchar.h>
#include <tchar.h>

#define STRAPI __stdcall
struct _STR_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength);
BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength);

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite=TRUE);

int  STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf); 
int  STRAPI StrLoadStringW(HINSTANCE hInst, UINT nID, LPWSTR lpszBuf); 

class CStr
{
public:

// Constructors
        CStr();
        CStr(const CStr& stringSrc);
        CStr(TCHAR ch, int nRepeat = 1);
        CStr(LPCSTR lpsz);
        CStr(LPCWSTR lpsz);
        CStr(LPCTSTR lpch, int nLength);
        CStr(const unsigned char* psz);

// Attributes & Operations
        // as an array of characters
        int GetLength() const;
        BOOL IsEmpty() const;
        void Empty();                       // free up the data

        TCHAR GetAt(int nIndex) const;      // 0 based
        TCHAR operator[](int nIndex) const; // same as GetAt
        void SetAt(int nIndex, TCHAR ch);
        operator LPCTSTR() const;           // as a C string

        // overloaded assignment
        const CStr& operator=(const CStr& stringSrc);
        const CStr& operator=(TCHAR ch);
#ifdef UNICODE
        const CStr& operator=(char ch);
#endif
        const CStr& operator=(LPCSTR lpsz);
        const CStr& operator=(LPCWSTR lpsz);
        const CStr& operator=(const unsigned char* psz);

        // string concatenation
        const CStr& operator+=(const CStr& string);
        const CStr& operator+=(TCHAR ch);
#ifdef UNICODE
        const CStr& operator+=(char ch);
#endif
        const CStr& operator+=(LPCTSTR lpsz);

        friend CStr STRAPI operator+(const CStr& string1,
                        const CStr& string2);
        friend CStr STRAPI operator+(const CStr& string, TCHAR ch);
        friend CStr STRAPI operator+(TCHAR ch, const CStr& string);
#ifdef UNICODE
        friend CStr STRAPI operator+(const CStr& string, char ch);
        friend CStr STRAPI operator+(char ch, const CStr& string);
#endif
        friend CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz);
        friend CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string);

        // string comparison
        int Compare(LPCTSTR lpsz) const;         // straight character
        int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
        int Collate(LPCTSTR lpsz) const;         // NLS aware

        // simple sub-string extraction
        CStr Mid(int nFirst, int nCount) const;
        CStr Mid(int nFirst) const;
        CStr Left(int nCount) const;
        CStr Right(int nCount) const;

        CStr SpanIncluding(LPCTSTR lpszCharSet) const;
        CStr SpanExcluding(LPCTSTR lpszCharSet) const;

        // upper/lower/reverse conversion
        void MakeUpper();
        void MakeLower();
        void MakeReverse();

        // trimming whitespace (either side)
        void TrimRight();
        void TrimLeft();

        // searching (return starting index, or -1 if not found)
        // look for a single character match
        int Find(TCHAR ch) const;               // like "C" strchr
        int ReverseFind(TCHAR ch) const;
        int FindOneOf(LPCTSTR lpszCharSet) const;

        // look for a specific sub-string
        int Find(LPCTSTR lpszSub) const;        // like "C" strstr

        // simple formatting
        void Format(LPCTSTR lpszFormat, ...);

        // Windows support
        BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
                                                                                // 255 chars max
#ifndef UNICODE
        // ANSI <-> OEM support (convert string in place)
        void AnsiToOem();
        void OemToAnsi();
#endif
        BSTR AllocSysString();
        BSTR SetSysString(BSTR* pbstr);

        // Access to string implementation buffer as "C" character array
        LPTSTR GetBuffer(int nMinBufLength);
        void ReleaseBuffer(int nNewLength = -1);
        LPTSTR GetBufferSetLength(int nNewLength);
        void FreeExtra();

// Implementation
public:
        ~CStr();
        int GetAllocLength() const;

protected:
        // lengths/sizes in characters
        //  (note: an extra character is always allocated)
        LPTSTR m_pchData;           // actual string (zero terminated)
        int m_nDataLength;          // does not include terminating 0
        int m_nAllocLength;         // does not include terminating 0

        // implementation helpers
        void Init();
        void AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
        BOOL AllocBuffer(int nLen);
        void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
        void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
        void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
        static void SafeDelete(LPTSTR& lpch);
        static int SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool STRAPI operator==(const CStr& s1, const CStr& s2);
bool STRAPI operator==(const CStr& s1, LPCTSTR s2);
bool STRAPI operator==(LPCTSTR s1, const CStr& s2);
bool STRAPI operator!=(const CStr& s1, const CStr& s2);
bool STRAPI operator!=(const CStr& s1, LPCTSTR s2);
bool STRAPI operator!=(LPCTSTR s1, const CStr& s2);
bool STRAPI operator<(const CStr& s1, const CStr& s2);
bool STRAPI operator<(const CStr& s1, LPCTSTR s2);
bool STRAPI operator<(LPCTSTR s1, const CStr& s2);
bool STRAPI operator>(const CStr& s1, const CStr& s2);
bool STRAPI operator>(const CStr& s1, LPCTSTR s2);
bool STRAPI operator>(LPCTSTR s1, const CStr& s2);
bool STRAPI operator<=(const CStr& s1, const CStr& s2);
bool STRAPI operator<=(const CStr& s1, LPCTSTR s2);
bool STRAPI operator<=(LPCTSTR s1, const CStr& s2);
bool STRAPI operator>=(const CStr& s1, const CStr& s2);
bool STRAPI operator>=(const CStr& s1, LPCTSTR s2);
bool STRAPI operator>=(LPCTSTR s1, const CStr& s2);

// conversion helpers
int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStr strEmptyStringT;
extern TCHAR strChNilT;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline int CStr::SafeStrlen(LPCTSTR lpsz)
        { return (int)((lpsz == NULL) ? NULL : _tcslen(lpsz)); }
inline CStr::CStr(const unsigned char* lpsz)
        { Init(); *this = (LPCSTR)lpsz; }
inline const CStr& CStr::operator=(const unsigned char* lpsz)
        { *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStr& CStr::operator+=(char ch)
        { *this += (TCHAR)ch; return *this; }
inline const CStr& CStr::operator=(char ch)
        { *this = (TCHAR)ch; return *this; }
inline CStr STRAPI operator+(const CStr& string, char ch)
        { return string + (TCHAR)ch; }
inline CStr STRAPI operator+(char ch, const CStr& string)
        { return (TCHAR)ch + string; }
#endif

inline int CStr::GetLength() const
        { return m_nDataLength; }
inline int CStr::GetAllocLength() const
        { return m_nAllocLength; }
inline BOOL CStr::IsEmpty() const
        { return m_nDataLength == 0; }
inline CStr::operator LPCTSTR() const
        { return (LPCTSTR)m_pchData; }

// String support (windows specific)
inline int CStr::Compare(LPCTSTR lpsz) const
        { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CStr::CompareNoCase(LPCTSTR lpsz) const
        { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStr::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStr::Collate(LPCTSTR lpsz) const
        { return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline void CStr::MakeUpper()
        { ::CharUpper(m_pchData); }
inline void CStr::MakeLower()
        { ::CharLower(m_pchData); }

inline void CStr::MakeReverse()
        { _tcsrev(m_pchData); }
inline TCHAR CStr::GetAt(int nIndex) const
        {
                dspAssert(nIndex >= 0);
                dspAssert(nIndex < m_nDataLength);

                return m_pchData[nIndex];
        }
inline TCHAR CStr::operator[](int nIndex) const
        {
                // same as GetAt

                dspAssert(nIndex >= 0);
                dspAssert(nIndex < m_nDataLength);

                return m_pchData[nIndex];
        }
inline void CStr::SetAt(int nIndex, TCHAR ch)
        {
                dspAssert(nIndex >= 0);
                dspAssert(nIndex < m_nDataLength);
                dspAssert(ch != 0);

                m_pchData[nIndex] = ch;
        }
inline bool STRAPI operator==(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) == 0; }
inline bool STRAPI operator!=(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) != 0; }
inline bool STRAPI operator<(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) > 0; }
inline bool STRAPI operator>(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) < 0; }
inline bool STRAPI operator<=(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) >= 0; }
inline bool STRAPI operator>=(const CStr& s1, const CStr& s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(const CStr& s1, LPCTSTR s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(LPCTSTR s1, const CStr& s2)
        { return s2.Compare(s1) <= 0; }

#ifndef UNICODE
inline void CStr::AnsiToOem()
        { ::AnsiToOem(m_pchData, m_pchData); }
inline void CStr::OemToAnsi()
        { ::OemToAnsi(m_pchData, m_pchData); }

#endif // UNICODE

// General Exception for memory
class MemoryException
{
public:
        MemoryException(){}
        void DisplayMessage()
        {
        ::MessageBox(NULL, _T("Memory Exception"), _T("System Out of Memory"), MB_OK|MB_ICONSTOP);
        }
};

// General Exception for memory
class ResourceException
{
public:
        ResourceException()
        {
        ::MessageBox(NULL, _T("Resource Exception"), _T("Unable to Load Resource"), MB_OK|MB_ICONSTOP);
        }
};

class CStrW
{
public:

// Constructors
        CStrW();
        CStrW(const CStrW& stringSrc);
        CStrW(WCHAR ch, int nRepeat = 1);
        CStrW(LPCSTR lpsz);
        CStrW(LPCWSTR lpsz);
        CStrW(LPCWSTR lpch, int nLength);
        CStrW(const unsigned char* psz);

// Attributes & Operations
        // as an array of characters
        int GetLength() const;
        BOOL IsEmpty() const;
        void Empty();                       // free up the data

        WCHAR GetAt(int nIndex) const;      // 0 based
        WCHAR operator[](int nIndex) const; // same as GetAt
        void SetAt(int nIndex, WCHAR ch);
        operator LPCWSTR() const;           // as a C string
        operator PWSTR();                   // as a C string

        // overloaded assignment
        const CStrW& operator=(const CStrW& stringSrc);
        const CStrW& operator=(WCHAR ch);
#ifdef UNICODE
        const CStrW& operator=(char ch);
#endif
        const CStrW& operator=(LPCSTR lpsz);
        const CStrW& operator=(LPCWSTR lpsz);
        const CStrW& operator=(const unsigned char* psz);
   const CStrW& operator=(UNICODE_STRING unistr);
   const CStrW& operator=(UNICODE_STRING * punistr);

        // string concatenation
        const CStrW& operator+=(const CStrW& string);
        const CStrW& operator+=(WCHAR ch);
#ifdef UNICODE
        const CStrW& operator+=(char ch);
#endif
        const CStrW& operator+=(LPCWSTR lpsz);

        friend CStrW STRAPI operator+(const CStrW& string1,
                        const CStrW& string2);
        friend CStrW STRAPI operator+(const CStrW& string, WCHAR ch);
        friend CStrW STRAPI operator+(WCHAR ch, const CStrW& string);
#ifdef UNICODE
        friend CStrW STRAPI operator+(const CStrW& string, char ch);
        friend CStrW STRAPI operator+(char ch, const CStrW& string);
#endif
        friend CStrW STRAPI operator+(const CStrW& string, LPCWSTR lpsz);
        friend CStrW STRAPI operator+(LPCWSTR lpsz, const CStrW& string);

        // string comparison
        int Compare(LPCWSTR lpsz) const;         // straight character
        int CompareNoCase(LPCWSTR lpsz) const;   // ignore case
        int Collate(LPCWSTR lpsz) const;         // NLS aware

        // simple sub-string extraction
        CStrW Mid(int nFirst, int nCount) const;
        CStrW Mid(int nFirst) const;
        CStrW Left(int nCount) const;
        CStrW Right(int nCount) const;

        CStrW SpanIncluding(LPCWSTR lpszCharSet) const;
        CStrW SpanExcluding(LPCWSTR lpszCharSet) const;

        // upper/lower/reverse conversion
        void MakeUpper();
        void MakeLower();
        void MakeReverse();

        // trimming whitespace (either side)
        void TrimRight();
        void TrimLeft();

        // searching (return starting index, or -1 if not found)
        // look for a single character match
        int Find(WCHAR ch) const;               // like "C" strchr
        int ReverseFind(WCHAR ch) const;
        int FindOneOf(LPCWSTR lpszCharSet) const;

        // look for a specific sub-string
        int Find(LPCWSTR lpszSub) const;        // like "C" strstr

        // simple formatting
        void Format(LPCWSTR lpszFormat, ...);

   // formatting for localization (uses FormatMessage API)

   // format using FormatMessage API on passed string
   void FormatMessage(PCWSTR pwzFormat, ...);
   // format using FormatMessage API on referenced string resource
   void FormatMessage(HINSTANCE hInst, UINT nFormatID, ...);

        // Windows support
        BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
                                                                                // 255 chars max
        BSTR AllocSysString();
        BSTR SetSysString(BSTR* pbstr);

        // Access to string implementation buffer as "C" character array
        PWSTR GetBuffer(int nMinBufLength);
        void ReleaseBuffer(int nNewLength = -1);
        PWSTR GetBufferSetLength(int nNewLength);
        void FreeExtra();

// Implementation
public:
        ~CStrW();
        int GetAllocLength() const;

protected:
        // lengths/sizes in characters
        //  (note: an extra character is always allocated)
        PWSTR m_pchData;           // actual string (zero terminated)
        int m_nDataLength;          // does not include terminating 0
        int m_nAllocLength;         // does not include terminating 0

        // implementation helpers
        void Init();
        void AllocCopy(CStrW& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
        BOOL AllocBuffer(int nLen);
        void AssignCopy(int nSrcLen, LPCWSTR lpszSrcData);
        void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data);
        void ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData);
        static void SafeDelete(PWSTR& lpch);
        static int SafeStrlen(LPCWSTR lpsz);
};

// Compare helpers
bool STRAPI operator==(const CStrW& s1, const CStrW& s2);
bool STRAPI operator==(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator==(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator!=(const CStrW& s1, const CStrW& s2);
bool STRAPI operator!=(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator!=(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator<(const CStrW& s1, const CStrW& s2);
bool STRAPI operator<(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator<(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator>(const CStrW& s1, const CStrW& s2);
bool STRAPI operator>(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator>(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator<=(const CStrW& s1, const CStrW& s2);
bool STRAPI operator<=(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator<=(LPCWSTR s1, const CStrW& s2);
bool STRAPI operator>=(const CStrW& s1, const CStrW& s2);
bool STRAPI operator>=(const CStrW& s1, LPCWSTR s2);
bool STRAPI operator>=(LPCWSTR s1, const CStrW& s2);

// conversion helpers
int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStrW strEmptyStringW;
extern WCHAR strChNilW;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline int CStrW::SafeStrlen(LPCWSTR lpsz)
        { return (int)((lpsz == NULL) ? NULL : wcslen(lpsz)); }
inline CStrW::CStrW(const unsigned char* lpsz)
        { Init(); *this = (LPCSTR)lpsz; }
inline const CStrW& CStrW::operator=(const unsigned char* lpsz)
        { *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStrW& CStrW::operator+=(char ch)
        { *this += (WCHAR)ch; return *this; }
inline const CStrW& CStrW::operator=(char ch)
        { *this = (WCHAR)ch; return *this; }
inline CStrW STRAPI operator+(const CStrW& string, char ch)
        { return string + (WCHAR)ch; }
inline CStrW STRAPI operator+(char ch, const CStrW& string)
        { return (WCHAR)ch + string; }
#endif

inline int CStrW::GetLength() const
        { return m_nDataLength; }
inline int CStrW::GetAllocLength() const
        { return m_nAllocLength; }
inline BOOL CStrW::IsEmpty() const
        { return m_nDataLength == 0; }
inline CStrW::operator LPCWSTR() const
        { return (LPCWSTR)m_pchData; }
inline CStrW::operator PWSTR()
        { return m_pchData; }

// String support (windows specific)
inline int CStrW::Compare(LPCWSTR lpsz) const
        { return wcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CStrW::CompareNoCase(LPCWSTR lpsz) const
        { return _wcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStrW::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStrW::Collate(LPCWSTR lpsz) const
        { return wcscoll(m_pchData, lpsz); }   // locale sensitive
inline void CStrW::MakeUpper()
        { ::CharUpperW(m_pchData); }
inline void CStrW::MakeLower()
        { ::CharLowerW(m_pchData); }

inline void CStrW::MakeReverse()
        { wcsrev(m_pchData); }
inline WCHAR CStrW::GetAt(int nIndex) const
        {
                dspAssert(nIndex >= 0);
                dspAssert(nIndex < m_nDataLength);

                return m_pchData[nIndex];
        }
inline WCHAR CStrW::operator[](int nIndex) const
        {
                // same as GetAt

                dspAssert(nIndex >= 0);
                dspAssert(nIndex < m_nDataLength);

                return m_pchData[nIndex];
        }
inline void CStrW::SetAt(int nIndex, WCHAR ch)
        {
                dspAssert(nIndex >= 0);
                dspAssert(nIndex < m_nDataLength);
                dspAssert(ch != 0);

                m_pchData[nIndex] = ch;
        }
inline bool STRAPI operator==(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) == 0; }
inline bool STRAPI operator==(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) == 0; }
inline bool STRAPI operator!=(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) != 0; }
inline bool STRAPI operator!=(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) != 0; }
inline bool STRAPI operator<(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) < 0; }
inline bool STRAPI operator<(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) > 0; }
inline bool STRAPI operator>(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) > 0; }
inline bool STRAPI operator>(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) < 0; }
inline bool STRAPI operator<=(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) <= 0; }
inline bool STRAPI operator<=(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) >= 0; }
inline bool STRAPI operator>=(const CStrW& s1, const CStrW& s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(const CStrW& s1, LPCWSTR s2)
        { return s1.Compare(s2) >= 0; }
inline bool STRAPI operator>=(LPCWSTR s1, const CStrW& s2)
        { return s2.Compare(s1) <= 0; }

//
// Added by JonN 4/16/98
//
class CStrListItem
{
public:
    CStr str;
    CStrListItem* pnext;
};
void FreeCStrList( IN OUT CStrListItem** ppList );
void CStrListAdd( IN OUT CStrListItem** ppList, IN LPCTSTR lpsz );
bool CStrListContains( IN CStrListItem** ppList, IN LPCTSTR lpsz );
int CountCStrList( IN CStrListItem** ppList );

#endif // __STR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\misc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       misc.cxx, this file is #include'd into the two dllmisc.cxx files.
//
//  Contents:   DS property pages class objects handler DLL fcns. Also, error
//              reporting, message, and miscelaneous functions.
//
//  History:    10-May-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#if defined(DSPROP_ADMIN)
#   include "chklist.h"
#   include "fpnw.h"
#endif
#include <time.h>

DECLARE_INFOLEVEL(DsProp);

HINSTANCE g_hInstance = NULL;
ULONG CDll::s_cObjs  = 0;
ULONG CDll::s_cLocks = 0;
UINT g_uChangeMsg = 0;
int g_iInstance = 0;

#ifndef DSPROP_ADMIN
CRITICAL_SECTION g_csNotifyCreate;
#endif

ULONG g_ulMemberFilterCount = DSPROP_MEMBER_FILTER_COUNT_DEFAULT;
ULONG g_ulMemberQueryLimit = DSPROP_MEMBER_QUERY_LIMIT_DEFAULT;

#define DIRECTORY_UI_KEY TEXT("Software\\Policies\\Microsoft\\Windows\\Directory UI")
#define MEMBER_QUERY_VALUE TEXT("GroupMemberFilterCount")
#define MEMBER_LIMIT_VALUE TEXT("GroupMemberQueryLimit")

#if defined(DSPROP_ADMIN)
Cache g_FPNWCache;
#endif

HRESULT GlobalInit(void);
void GlobalUnInit(void);
void ReportErrorFallback(HWND hWndMsg, HRESULT hr = ERROR_SUCCESS)
    { ReportError( hr, 0, hWndMsg ); }

//+----------------------------------------------------------------------------
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define SMDEBUGKEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug"

#ifndef DSPROP_ADMIN
//+----------------------------------------------------------------------------
//
//  Class:      CNotifyCreateCriticalSection
//
//  Purpose:    Prevents creation race conditions. Without this protection,
//              a second call to CNotifyObj::Create that comes in before the
//              first has created the hidden window will get NULL back from
//              FindSheetNoSetFocus and then go on to create a second hidden
//              window.
//
//-----------------------------------------------------------------------------
CNotifyCreateCriticalSection::CNotifyCreateCriticalSection()
{
    TRACE(CNotifyCreateCriticalSection, CNotifyCreateCriticalSection);
    EnterCriticalSection(&g_csNotifyCreate);
};

CNotifyCreateCriticalSection::~CNotifyCreateCriticalSection()
{
    TRACE(CNotifyCreateCriticalSection, ~CNotifyCreateCriticalSection);
    LeaveCriticalSection(&g_csNotifyCreate);
};

#endif



#define MAX_STRING 1024

//+----------------------------------------------------------------------------
//
//  Function:   LoadStringToTchar
//
//  Synopsis:   Loads the given string into an allocated buffer that must be
//              caller freed using delete.
//
//-----------------------------------------------------------------------------
BOOL LoadStringToTchar(int ids, PTSTR * pptstr)
{
    TCHAR szBuf[MAX_STRING];

    if (!LoadString(g_hInstance, ids, szBuf, MAX_STRING - 1))
    {
        return FALSE;
    }

    *pptstr = new TCHAR[_tcslen(szBuf) + 1];

    CHECK_NULL(*pptstr, return FALSE);

    _tcscpy(*pptstr, szBuf);

    return TRUE;
}

//+----------------------------------------------------------------------------
// Function: LoadStringReport
// Purpose: attempts to load a string, returns FALSE and gives error message
//          if a failure occurs.
//-----------------------------------------------------------------------------
BOOL LoadStringReport(int ids, PTSTR ptz, int len, HWND hwnd)
{
    if (!LoadString(g_hInstance, ids, ptz, len - 1))
    {
        DWORD dwErr = GetLastError();
        dspDebugOut((DEB_ERROR, "LoadString of %d failed with error %lu\n",
                     ids, dwErr));
        ReportError(dwErr, 0, hwnd);
        return FALSE;
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadErrorMessage
//
//  Synopsis:   Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
void LoadErrorMessage(HRESULT hr, int nStr, PTSTR* pptsz) // free with delete[]
{
    dspAssert( NULL != pptsz && NULL == *pptsz );
    PTSTR ptzFormat = NULL, ptzSysMsg;
    int cch;

    if (nStr)
    {
        LoadStringToTchar(nStr, &ptzFormat);
    }

    cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)&ptzSysMsg, 0, NULL);
    if (!cch)
    {
        // Try ADSI errors.
        //
        cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                            | FORMAT_MESSAGE_FROM_HMODULE,
                            GetModuleHandle(TEXT("activeds.dll")), hr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (PTSTR)&ptzSysMsg, 0, NULL);
    }

    if (!cch)
    {
        PTSTR ptzMsgTemplate = NULL;
        BOOL fDelMsgTemplate = TRUE;
        LoadStringToTchar(IDS_DEFAULT_ERROR_MSG, &ptzMsgTemplate);
        if (NULL == ptzMsgTemplate)
        {
            ptzMsgTemplate = TEXT("The operation failed with error code %d (0x%08x)");
            fDelMsgTemplate = FALSE;
        }
        *pptsz = new TCHAR[ lstrlen(ptzMsgTemplate)+10 ];
        dspAssert( NULL != *pptsz );
        if (NULL != *pptsz)
        {
            wsprintf(*pptsz, ptzMsgTemplate, hr, hr);
        }
        if (fDelMsgTemplate)
        {
            delete ptzMsgTemplate;
        }
    }
    else
    {
        PTSTR ptzMsg;
        BOOL fDelMsg = FALSE;

        if (ptzFormat)
        {
            ptzMsg = new TCHAR[lstrlen(ptzFormat) + lstrlen(ptzSysMsg) + 1];
            if (ptzMsg)
            {
                wsprintf(ptzMsg, ptzFormat, ptzSysMsg);
                fDelMsg = TRUE;
            }
            else
            {
                ptzMsg = ptzSysMsg;
            }
        }
        else
        {
            ptzMsg = ptzSysMsg;
        }

        *pptsz = new TCHAR[ lstrlen(ptzMsg)+1 ];
        if (NULL != *pptsz)
        {
            lstrcpy( *pptsz, ptzMsg );
        }
        dspAssert( NULL != *pptsz );

        LocalFree(ptzSysMsg);
        if (fDelMsg)
        {
            delete[] ptzMsg;
        }
        if (ptzFormat)
        {
            delete ptzFormat;
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckADsError
//
//  Synopsis:   Checks the result code from an ADSI call.
//
//  Returns:    TRUE if no error.
//
//-----------------------------------------------------------------------------
BOOL CheckADsError(HRESULT * phr, BOOL fIgnoreAttrNotFound, PSTR file,
                   int line, HWND hWnd)
{
    if (SUCCEEDED(*phr))
    {
        return TRUE;
    }

    if (((E_ADS_PROPERTY_NOT_FOUND == *phr) ||
         (HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) == *phr)) &&
        fIgnoreAttrNotFound)
    {
        *phr = S_OK;
        return TRUE;
    }

    HWND hWndMsg = hWnd;

    if (!hWndMsg)
    {
        hWndMsg = GetDesktopWindow();
    }

    DWORD dwErr;
    WCHAR wszErrBuf[MAX_PATH+1];
    WCHAR wszNameBuf[MAX_PATH+1];
    ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);
    if ((LDAP_RETCODE)dwErr == LDAP_NO_SUCH_ATTRIBUTE && fIgnoreAttrNotFound)
    {
        *phr = S_OK;
        return TRUE;
    }
    if (dwErr)
    {
        dspDebugOut((DEB_ERROR,
                     "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                     wszErrBuf, wszNameBuf, file, line));
        ReportError(dwErr, IDS_ADS_ERROR_FORMAT, hWndMsg);
    }
    else
    {
        dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", *phr, file, line));
        ReportError(*phr, IDS_ADS_ERROR_FORMAT, hWndMsg);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportError
//
//  Synopsis:   Displays an error using a user-friendly error message from the
//              system.
//
//-----------------------------------------------------------------------------
void ReportErrorWorker(HWND hWnd, PTSTR ptzMsg)
{
    HWND hWndMsg = hWnd;
    if (!hWndMsg)
    {
        hWndMsg = GetDesktopWindow();
    }

    PTSTR ptzTitle = NULL;
    if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
    {
        MessageBox(hWndMsg, ptzMsg, TEXT("Active Directory"), MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    MessageBox(hWndMsg, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);

    delete ptzTitle;
}

void ReportError(HRESULT hr, int nStr, HWND hWnd)
{
    PTSTR ptzMsg = NULL;
    LoadErrorMessage(hr, nStr, &ptzMsg);
    if (NULL == ptzMsg)
    {
        TCHAR tzBuf[80];
        wsprintf(tzBuf, TEXT("Active Directory failure with code '0x%08x'!"), hr);
        ReportErrorWorker( hWnd, tzBuf );
        return;
    }

    ReportErrorWorker( hWnd, ptzMsg );

    delete ptzMsg;
}

#if defined(DSADMIN)
//+----------------------------------------------------------------------------
//
//  Function:   SuperMsgBox
//
//  Synopsis:   Displays a message obtained from a string resource with
//              the parameters expanded. The error param, dwErr, if
//              non-zero, is converted to a string and becomes the first
//              replaceable param.
//
//  Note: this function is UNICODE-only.
//
//-----------------------------------------------------------------------------
int SuperMsgBox(
    HWND hWnd,          // owning window.
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    int nTitleId,       // string resource ID of the title. If zero, uses IDS_MSG_TITLE.
    UINT ufStyle,       // MessageBox flags.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PSTR szFile,        // use the __FILE__ macro. ignored in retail build.
    int nLine           // use the __LINE__ macro. ignored in retail build.
    )
{
    CStrW strTitle;
    PWSTR pwzMsg = NULL;

    strTitle.LoadString(g_hInstance, (nTitleId) ? nTitleId : IDS_MSG_TITLE);

    if (0 == strTitle.GetLength())
    {
        ReportErrorFallback(hWnd, dwErr);
        return 0;
    }

    DspFormatMessage(nMessageId, dwErr, rgpvArgs, nArguments,
                     fTryADSiErrors, &pwzMsg, hWnd);
    if (!pwzMsg)
    {
       return 0;
    }

    if (dwErr)
    {
        dspDebugOut((DEB_ERROR,
                     "*+*+*+*+* Error <%s @line %d> -> 0x%08x, with message:\n\t%ws\n",
                     szFile, nLine, dwErr, pwzMsg));
    }
    else
    {
        dspDebugOut((DEB_ERROR,
                     "*+*+*+*+* Message <%s @line %d>:\n\t%ws\n",
                     szFile, nLine, pwzMsg));
    }

    int retval = MessageBox(hWnd, pwzMsg, strTitle, ufStyle);

    LocalFree(pwzMsg);
    return retval;
}

//+----------------------------------------------------------------------------
//
//  Function:   DspFormatMessage
//
//  Synopsis:   Loads a string resource with replaceable parameters and uses
//              FormatMessage to populate the replaceable params from the
//              argument array. If dwErr is non-zero, will load the system
//              description for that error and include it in the argument array.
//
//-----------------------------------------------------------------------------
void
DspFormatMessage(
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PWSTR * ppwzMsg,    // The returned error string, free with LocalFree.
    HWND hWnd           // owning window, defaults to NULL.
    )
{
    int cch;
    PWSTR pwzSysErr = NULL;

    if (dwErr)
    {
        if (fTryADSiErrors)
        {
            DWORD dwStatus;
            WCHAR Buf1[256], Buf2[256];

            ADsGetLastError(&dwStatus, Buf1, 256, Buf2, 256);

            dspDebugOut((DEB_ERROR,
                         "ADsGetLastError returned status of %lx, error: %s, name %s\n",
                          dwStatus, Buf1, Buf2));

            if ((ERROR_INVALID_DATA != dwStatus) && (0 != dwStatus))
            {
                dwErr = dwStatus;
            }
        }

        cch = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwErr,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                             (PWSTR)&pwzSysErr, 0, NULL);
        if (!cch)
        {
            ReportErrorFallback(hWnd, dwErr);
            return;
        }
    }

    PWSTR * rgpvArguments = new PWSTR[nArguments + 1];

    if (!rgpvArguments)
    {
        ReportErrorFallback(hWnd, dwErr);
        return;
    }

    int nOffset = 0;

    if (dwErr)
    {
        rgpvArguments[0] = pwzSysErr;
        nOffset = 1;
    }

    if (0 != nArguments)
    {
        CopyMemory(rgpvArguments + nOffset, rgpvArgs, nArguments * sizeof(PVOID));
    }

    CStrW strFormat;

    strFormat.LoadString(g_hInstance, nMessageId);

    if (0 == strFormat.GetLength())
    {
        ReportErrorFallback(hWnd, dwErr);
        return;
    }

    cch = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY, strFormat, 0, 0,
                         (PWSTR)ppwzMsg, 0, (va_list *)rgpvArguments);

    if (pwzSysErr) LocalFree(pwzSysErr);

    if (!cch)
    {
        ReportErrorFallback(hWnd, dwErr);
    }

    delete[] rgpvArguments;
    return;
}

#endif // defined(DSADMIN)

//+----------------------------------------------------------------------------
//
//  Function:   ErrMsg
//
//  Synopsis:   Displays an error message obtained from a string resource.
//
//-----------------------------------------------------------------------------
void ErrMsg(UINT MsgID, HWND hWndParam)
{
    PTSTR ptz = TEXT("");

    ErrMsgParam(MsgID, (LPARAM)ptz, hWndParam);
}

//+----------------------------------------------------------------------------
//
//  Function:   ErrMsgParam
//
//  Synopsis:   Displays an error message obtained from a string resource with
//              an insertion parameter.
//
//  Note: fixed-size stack buffers are used for the strings because trying to
//        report an allocation failure using dynamically allocated string
//        buffers is not a good idea.
//-----------------------------------------------------------------------------
void ErrMsgParam(UINT MsgID, LPARAM param, HWND hWndParam)
{
    HWND hWnd;
    if (hWndParam == NULL)
    {
        hWnd = GetDesktopWindow();
    }
    else
    {
        hWnd = hWndParam;
    }
    TCHAR szTitle[MAX_TITLE+1];
    TCHAR szFormat[MAX_ERRORMSG+1];
    TCHAR szMsg[MAX_ERRORMSG+1];
    LOAD_STRING(IDS_MSG_TITLE, szTitle, MAX_TITLE, MessageBeep(MB_ICONEXCLAMATION); return);
    LOAD_STRING(MsgID, szFormat, MAX_ERRORMSG, MessageBeep(MB_ICONEXCLAMATION); return);
    wsprintf(szMsg, szFormat, param);
    MessageBox(hWnd, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

//+----------------------------------------------------------------------------
//
//  Function:   MsgBox
//
//  Synopsis:   Displays a message obtained from a string resource.
//
//-----------------------------------------------------------------------------
void MsgBox(UINT MsgID, HWND hWnd)
{
    MsgBox2(MsgID, 0, hWnd);
}

//+----------------------------------------------------------------------------
//
//  Function:   MsgBox2
//
//  Synopsis:   Displays a message obtained from a string resource which is
//              assumed to have a replacable parameter where the InsertID
//              string is inserted.
//
//-----------------------------------------------------------------------------
void MsgBox2(UINT MsgID, UINT InsertID, HWND hWnd)
{
    CStr strMsg, strFormat, strInsert, strTitle;

    if (!strTitle.LoadString(g_hInstance, IDS_MSG_TITLE))
    {
        REPORT_ERROR(GetLastError(), hWnd);
        return;
    }
    if (!strFormat.LoadString(g_hInstance, MsgID))
    {
        REPORT_ERROR(GetLastError(), hWnd);
        return;
    }
    if (InsertID)
    {
        if (!strInsert.LoadString(g_hInstance, InsertID))
        {
            REPORT_ERROR(GetLastError(), hWnd);
            return;
        }

        strMsg.Format(strFormat, strInsert);
    }
    else
    {
        strMsg = strFormat;
    }

    MessageBox(hWnd, strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
}

//+----------------------------------------------------------------------------
//
//      DLL functions
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//  History:    24-May-95 EricB created.
//
//-----------------------------------------------------------------------------
extern "C" BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            dspDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_ATTACH\n"));

            //
            // Get instance handle
            //

            g_hInstance = hInstance;

            //
            // Disable thread notification from OS
            //

            //DisableThreadLibraryCalls(hInstance);

            HRESULT hr;

            //
            // Initialize the global values.
            //

            hr = GlobalInit();
            if (FAILED(hr))
            {
                ERR_OUT("GlobalInit", hr);
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            dspDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_DETACH\n"));
            GlobalUnInit();
            break;
    }
    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Creates a class factory for the requested object.
//
//  Arguments:  [cid]    - the requested class object
//              [iid]    - the requested interface
//              [ppvObj] - returned pointer to class object
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(REFCLSID cid, REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = NULL;
    HRESULT hr = S_OK;

    for (int i = 0; i < g_DsPPClasses.cClasses; i++)
    {
        if (cid == *g_DsPPClasses.rgpClass[i]->pcid)
        {
            pUnk = CDsPropPagesHostCF::Create(g_DsPPClasses.rgpClass[i]);
            if (pUnk != NULL)
            {
                hr = pUnk->QueryInterface(iid, ppvObj);
                pUnk->Release();
            }
            else
            {
                return E_OUTOFMEMORY;
            }
            return hr;
        }
    }
    return E_NOINTERFACE;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates whether the DLL can be removed if there are no
//              objects in existence.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
    dspDebugOut((DEB_ITRACE, "DllCanUnloadNow: CDll::CanUnloadNow()? %s\n",
                 (CDll::CanUnloadNow() == S_OK) ? "TRUE" : "FALSE"));
    return CDll::CanUnloadNow();
}

TCHAR const c_szServerType[] = TEXT("InProcServer32");
TCHAR const c_szThreadModel[] = TEXT("ThreadingModel");
TCHAR const c_szThreadModelValue[] = TEXT("Apartment");

//+----------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Adds entries to the system registry.
//
//  Returns:    S_OK or error code.
//
//  Notes:      The keys look like this:
//
//      HKC\CLSID\clsid <No Name> REG_SZ name.progid
//                     \InPropServer32 <No Name> : REG_SZ : adprop.dll/dsprop.dll
//                                     ThreadingModel : REG_SZ : Apartment
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HKEY hKeyCLSID, hKeyDsPPClass, hKeySvr;

    long lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0,
                             KEY_WRITE, &hKeyCLSID);
    if (lRet != ERROR_SUCCESS)
    {
        dspDebugOut((DEB_ITRACE, "RegOpenKeyEx failed: %d", lRet));
        return (HRESULT_FROM_WIN32(lRet));
    }

    LPOLESTR pszCLSID;
    PTSTR ptzCLSID;
    DWORD dwDisposition;

    for (int i = 0; i < g_DsPPClasses.cClasses; i++)
    {
        hr = StringFromCLSID(*g_DsPPClasses.rgpClass[i]->pcid, &pszCLSID);

        if (FAILED(hr))
        {
            DBG_OUT("StringFromCLSID failed");
            continue;
        }

        if (!UnicodeToTchar(pszCLSID, &ptzCLSID))
        {
            DBG_OUT("Memory Allocation failure!");
            CoTaskMemFree(pszCLSID);
            hr = E_OUTOFMEMORY;
            continue;
        }

        CoTaskMemFree(pszCLSID);

        lRet = RegCreateKeyEx(hKeyCLSID, ptzCLSID, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKeyDsPPClass, &dwDisposition);

        delete ptzCLSID;

        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegCreateKeyEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
            continue;
        }

        TCHAR szProgID[MAX_PATH];
        _tcscpy(szProgID, c_szDsProppagesProgID);
        _tcscat(szProgID, g_DsPPClasses.rgpClass[i]->szProgID);

        lRet = RegSetValueEx(hKeyDsPPClass, NULL, 0, REG_SZ,
                             (CONST BYTE *)szProgID,
                             sizeof(TCHAR) * (static_cast<DWORD>(_tcslen(szProgID) + 1)));
        if (lRet != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyDsPPClass);
            dspDebugOut((DEB_ITRACE, "RegSetValueEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
            continue;
        }

        lRet = RegCreateKeyEx(hKeyDsPPClass, c_szServerType, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKeySvr, &dwDisposition);

        RegCloseKey(hKeyDsPPClass);

        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegCreateKeyEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
            continue;
        }

        lRet = RegSetValueEx(hKeySvr, NULL, 0, REG_SZ,
                             (CONST BYTE *)c_szDsProppagesDllName,
                         sizeof(TCHAR) * (static_cast<DWORD>(_tcslen(c_szDsProppagesDllName) + 1)));
        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegSetValueEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
        }

        lRet = RegSetValueEx(hKeySvr, c_szThreadModel, 0, REG_SZ,
                             (CONST BYTE *)c_szThreadModelValue,
                         sizeof(TCHAR) * (static_cast<DWORD>(_tcslen(c_szThreadModelValue) + 1)));
        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "RegSetValueEx failed: %d", lRet));
            hr = HRESULT_FROM_WIN32(lRet);
        }

        RegCloseKey(hKeySvr);
    }
    RegCloseKey(hKeyCLSID);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Removes the entries from the system registry.
//
//  Returns:    S_OK or S_FALSE
//
//  Notes:      The keys look like this:
//
//      HKC\CLSID\clsid <No Name> REG_SZ name.progid
//                     \InPropServer32 <No Name> : REG_SZ : dsprop.dll
//                                     ThreadingModel : REG_SZ : Apartment
//-----------------------------------------------------------------------------
STDAPI
DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    HKEY hKeyCLSID, hKeyClass;

    long lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0,
                             KEY_ALL_ACCESS, &hKeyCLSID);
    if (lRet != ERROR_SUCCESS)
    {
        dspDebugOut((DEB_ITRACE, "RegOpenKeyEx failed: %d", lRet));
        return (HRESULT_FROM_WIN32(lRet));
    }

    LPOLESTR pszCLSID;
    PTSTR ptzCLSID;

    for (int i = 0; i < g_DsPPClasses.cClasses; i++)
    {
        hr = StringFromCLSID(*g_DsPPClasses.rgpClass[i]->pcid, &pszCLSID);

        if (FAILED(hr))
        {
            DBG_OUT("StringFromCLSID failed");
            continue;
        }

        if (!UnicodeToTchar(pszCLSID, &ptzCLSID))
        {
            DBG_OUT("CLSID string memory allocation failure!");
            CoTaskMemFree(pszCLSID);
            hr = E_OUTOFMEMORY;
            continue;
        }

        CoTaskMemFree(pszCLSID);

        lRet = RegOpenKeyEx(hKeyCLSID, ptzCLSID, 0, KEY_ALL_ACCESS, &hKeyClass);

        if (lRet != ERROR_SUCCESS)
        {
            dspDebugOut((DEB_ITRACE, "Failed to open key %S\n", ptzCLSID));
            lRet = ERROR_SUCCESS;
            hr = S_FALSE;
        }
        else
        {
            lRet = RegDeleteKey(hKeyClass, c_szServerType);

            RegCloseKey(hKeyClass);

            dspDebugOut((DEB_ITRACE, "Delete of key %S returned code %d\n",
                         c_szServerType, lRet));

            if (lRet != ERROR_SUCCESS)
            {
                lRet = ERROR_SUCCESS;
                hr = S_FALSE;
            }
        }

        lRet = RegDeleteKey(hKeyCLSID, ptzCLSID);

        dspDebugOut((DEB_ITRACE, "Delete of key %S returned code %d\n",
                     ptzCLSID, lRet));

        delete ptzCLSID;

        if (lRet != ERROR_SUCCESS)
        {
            lRet = ERROR_SUCCESS;
            hr = S_FALSE;
        }
    }
    RegCloseKey(hKeyCLSID);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GlobalInit
//
//  Synopsis:   Sets up the global environment.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
inline HRESULT
GlobalInit(void)
{
    //
    // Initialize common controls
    //
    InitCommonControls();

    INITCOMMONCONTROLSEX icce;

    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_DATE_CLASSES;
    InitCommonControlsEx(&icce);

#if defined(DSPROP_ADMIN)
    //
    // Register the "CHECKLIST" control
    //
    RegisterCheckListWndClass();
#endif

#ifndef DSPROP_ADMIN
    //
    // Register the window class for the notification window.
    //
    RegisterNotifyClass();
#endif

    //
    // Register the attribute-changed message.
    //
    g_uChangeMsg = RegisterWindowMessage(DSPROP_ATTRCHANGED_MSG);

    CHECK_NULL(g_uChangeMsg, ;);

    //
    // Major cheesy hack to allow locating windows that are unique to this
    // instance (since hInstance is invariant).
    //
    srand((unsigned)time(NULL));
    g_iInstance = rand();

#ifndef DSPROP_ADMIN
    ExceptionPropagatingInitializeCriticalSection(&g_csNotifyCreate);
#endif

    HRESULT hr = CheckRegisterClipFormats();
    dspAssert( SUCCEEDED(hr) );

    // If found, read the value of the Member class query clause count and
    // number-of-members limit.
    //
    HKEY hKey;
    LONG lRet;
    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, DIRECTORY_UI_KEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(ULONG);
        RegQueryValueEx(hKey, MEMBER_QUERY_VALUE, NULL, NULL,
                        (LPBYTE)&g_ulMemberFilterCount, &dwSize);

        RegQueryValueEx(hKey, MEMBER_LIMIT_VALUE, NULL, NULL,
                        (LPBYTE)&g_ulMemberQueryLimit, &dwSize);
        RegCloseKey(hKey);
    }

    dspDebugOut((DEB_ITRACE | DEB_USER14, "GroupMemberFilterCount set to %d\n", g_ulMemberFilterCount));
    dspDebugOut((DEB_ITRACE | DEB_USER14, "GroupMemberQueryLimit set to %d\n", g_ulMemberQueryLimit));
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GlobalUnInit
//
//  Synopsis:   Do resource freeing.
//
//-----------------------------------------------------------------------------
inline void
GlobalUnInit(void)
{
#if defined(DSPROP_ADMIN)
  if (!g_FPNWCache.empty()) 
  {
    for (Cache::iterator i = g_FPNWCache.begin(); i != g_FPNWCache.end(); i++) 
    {
      if ((*i).second)
        LocalFree((*i).second);
    }
    g_FPNWCache.clear();
  }
#endif
  g_ClassIconCache.ClearAll();

#ifndef DSPROP_ADMIN
  DeleteCriticalSection(&g_csNotifyCreate);
#endif
}

//+----------------------------------------------------------------------------
//
//  Debugging routines.
//
//-----------------------------------------------------------------------------
#if DBG == 1

//////////////////////////////////////////////////////////////////////////////

unsigned long SmAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL fInfoLevelInit = FALSE;

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...);
static int _cdecl w4smprintf(const char *format, va_list arglist);

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...)
{
   int ret;

   va_list va;
   va_start(va, format);
   ret = w4smprintf(format, va);
   va_end(va);

   return ret;
}


static int _cdecl w4smprintf(const char *format, va_list arglist)
{
   int ret;
   char szMessageBuf[DSP_DEBUG_BUF_SIZE];

   ret = wvnsprintfA(szMessageBuf, DSP_DEBUG_BUF_SIZE - 1, format, arglist);
   OutputDebugStringA(szMessageBuf);
   return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   SmAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void APINOT
SmAssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (SmAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (SmAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (SmAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    wsprintfA(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
              pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
                     | MB_DEFAULT_DESKTOP_ONLY
                     | MB_TASKMODAL
                     | MB_ICONEXCLAMATION
                     | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //
#ifdef DSPROP_ADMIN
    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
                             | MB_SERVICE_NOTIFICATION
                             | MB_TASKMODAL
                             | MB_ICONEXCLAMATION
                             | MB_OKCANCEL);
        }
    }
#endif
    return id;
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT
smprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        (ulCompMask | DEF_INFOLEVEL))
    {
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((DEF_INFOLEVEL & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%x.%03x> %s: ", pid, tid, pszComp);
            }

            SYSTEMTIME st;
            GetLocalTime(&st);
            w4dprintf("%02d:%02d:%02d ", st.wHour, st.wMinute, st.wSecond);

            w4smprintf(ppszfmt, pargs);
        }
    }
}

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void APINOT
CheckInit(char * pInfoLevelString, unsigned long * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;
    if (fInfoLevelInit) return;
    fInfoLevelInit = TRUE;
    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SMDEBUGKEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(unsigned long);
        lRet = RegQueryValueExA(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);
        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;
        }
        RegCloseKey(hKey);
    }
}

#endif // DBG == 1

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      ::InitializeCriticalSection(critsec);
   }

   //
   // propagate the exception to our caller.  
   //
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\notify.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       notify.h
//
//  Contents:   Change notification ref-counting object.
//
//  Classes:    CNotifyObj
//
//  History:    20-Jan-98 EricB
//
//-----------------------------------------------------------------------------

/*+----------------------------------------------------------------------------
Property page startup and communication architecture

Caller creates a data object with the DSOBJECTNAMES clip format which names
the DS object. Caller then creates the CLSID_DsPropertyPages object and passes
in the data object pointer with the call to IShellExtInit::Initialize. The
object that implements this class is known as the tab collector. It is in
dsuiext.dll

The caller then calls IShellPropSheetExt::AddPages. The tab collector's
AddPages code reads the Display Specifier for the DS object's class. The
Display Specifier lists the CLSIDs for the COM objects that implement the
pages. AddPages then does a create on each CLSID, and for each calling the
Initialize and AddPages methods.

This iteration of the AddPages method is implemented by the CDsPropPagesHost
class. The host class reads a table to determine the pages to create for this
CLSID. Each page is created (via CreatePropertySheetPage) in the AddPages
method and the page handle is passed back to the original caller via the
AddPages callback parameter. The original caller builds an array of pages
handles and creates the sheet once its call of AddPages returns.

A mechanism is needed for operations that span all the pages of a sheet. These
operations include
a) binding to the DS object and retrieving the set of attributes that are
   needed by all pages,
b) handling errors due to the inability to bind to or fetch attributes from an
   object,
c) firing a single change notification back to the caller when an Apply is
   made,
d) responding to queries for sheet exclusivity,
e) sending a notification back to the caller when the sheet is closed.
The number and order of pages in a sheet is determined by the set of CLSIDs in
the display specifier. The display specifier is user modifiable. Because of
this, a hard-coded scheme that makes assumptions about the order and number of
pages cannot be used for the page-spanning operations enumerated above. Thus a
separate object, called the notification object, is created at sheet creation
time. The pages communicate with the notification object using window messages.
The notification object has a hidden window, a window proceedure, and a message
pump running on its own thread.

One then must ask: when does the notification window get created and when is it
destroyed? The creation will be in CDsPropPagesHost's implementation of
Initialize. The destruction will be signalled by a send message from the pages'
callback function.

The notify creation function will do a FindWindow looking for the notification
window. If not found, it will create it. During the notify object's creation it
will bind to the DS object and request the cn and allowedAttributesEffective
properties. The window's handle will then be returned to the Initialize
function so that the resultant pages can communicate with it. If the
notification object/window cannot be created, then an error will be returned
to the Initialize method which will in turn return the error to the original
caller. The caller should then abort the property display and should report a
catastrophic failure to the user. If the notification object is successfully
created, but the initial attributes cannot be fetched from the DS object, then
an internal error variable will be set in the notify object although it's
creation function will return a success code.

As the individual pages initialize, they will send a message asking for the
ADSI object pointer, the CN, and the effective-attributes list. An error code
will be returned instead if the bind/fetch failed. The page init code will
report this error to the user by substituting an error page for the property
page. This is done at page object initialization time (CDsPropPageBase::Init).
This is before the CreatePropertySheetPage call is made allowing the
substitution of an error page.

typedef struct {
    DWORD              dwSize;          // Set this to the size of the struct.
    DWORD              dwFlags;         // Reserved for future use.
    HRESULT            hr;              // If this is non-zero, then the others
    IDirectoryObject * pDsObj;          // should be ignored.
    LPCWSTR            pwzCN;
    PADS_ATTR_INFO     pWritableAttrs;
} ADSPROPINITPARAMS, * PADSPROPINITPARAMS;

#define WM_ADSPROP_NOTIFY_PAGEINIT
// where LPARAM is the PADSPROPINITPARAMS pointer.

Each page checks its list of attributes against those in the
allowedAttributesEffective array. If an attribute is found in the allowed
list, then it is marked as writable and its corresponding control will be
enabled. If an attribute is set to be un-readable but writable for that user
(an unusual but legal situation), the LDAP read will silently fail so that no
value will be placed in the dialog control, but the control will be left
enabled. Thus the user could unwittingly overwrite an existing value.
Consequently it is not a good idea to grant a user write permission but revoke
read permission on an attribute unless the above behavior is explicitly
intended. Here is the struct that will be used to mark attributes as
writable:

typedef struct {
    BOOL    fWritable;
    PVOID   pAttrData;
} ATTR_DATA, * PATTR_DATA;

An array of these structures will be allocated for each page with one element
per attribute. The ordering will be the same as the table of attributes for the
page.
Methods to check writability:

HRESULT CDsPropPageBase::CheckIfWritable(PATTR_DATA rgAttrData,
                                         PATTR_MAP * rgAttrMap,
                                         DWORD cAttrs,
                                         PADS_ATTR_INFO pWritableAttrs);

BOOL CDsPropPageBase::CheckIfWritable(const PWSTR & wzAttr);

Another private message will be used to pass the page's window handle to the
notify object. The notify object needs to know the property sheet's window
handle, which it can get by calling GetParent on the passed page handle. This
message is sent by each page's WM_DLGINIT function. The notify object's page
count will be incremented at this time.

#define WM_ADSPROP_NOTIFY_PAGEHWND
// where WPARAM => page's HWND

-----------------------------------------------------------------------------*/

#ifndef _NOTIFY_H_
#define _NOTIFY_H_

#include <propcfg.h> // DS Admin definition of PPROPSHEETCFG
#include <adsprop.h>

const TCHAR tzNotifyWndClass[] = TEXT("DsPropNotifyWindow");

#define DSPROP_TITLE_LEN 16

extern "C" BOOL IsSheetAlreadyUp(LPDATAOBJECT);
extern "C" BOOL BringSheetToForeground(PWSTR, BOOL);

VOID __cdecl NotifyThreadFcn(PVOID);
BOOL FindSheet(PWSTR);
HWND FindSheetNoSetFocus(PWSTR);
VOID RegisterNotifyClass(void);

#ifndef DSPROP_ADMIN

//+----------------------------------------------------------------------------
//
//  Class:      CNotifyCreateCriticalSection
//
//  Purpose:    Prevents creation race conditions. Without this protection,
//              a second call to CNotifyObj::Create that comes in before the
//              first has created the hidden window will get NULL back from
//              FindSheetNoSetFocus and then go on to create a second hidden
//              window.
//
//-----------------------------------------------------------------------------
class CNotifyCreateCriticalSection
{
public:
    CNotifyCreateCriticalSection();
    ~CNotifyCreateCriticalSection();
};

#endif // DSPROP_ADMIN

#endif // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\objlist.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       objlist.cxx
//
//  Contents:   Link-lists of objects and list-view controls displaying objects.
//
//  History:    20-Nov-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"

CClassIconCache g_ClassIconCache;

//+----------------------------------------------------------------------------
//
//  Class:      CMemberLinkList
//
//  Purpose:    Linked list of membership class objects.
//
//-----------------------------------------------------------------------------
CMemberLinkList::~CMemberLinkList(void)
{
    CMemberListItem * pItem = m_pListHead, * pNext;

    while (pItem)
    {
        pNext = pItem->Next();
        delete pItem;
        pItem = pNext;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::FindItemRemove
//
//  Synopsis:   Search for an element with a matching DN and, if found, remove
//              it from the list and return its pointer. Returns NULL if not
//              found.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberLinkList::FindItemRemove(PWSTR pwzDN)
{
    CMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        dspAssert(pItem->m_pwzDN);

        if (_wcsicmp(pItem->m_pwzDN, pwzDN) == 0)
        {
            if (pItem->Prev() == NULL)
            {
                // this item is the list head.
                //
                m_pListHead = pItem->Next();
            }
            pItem->UnLink();
            return pItem;
        }
        pItem = pItem->Next();
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::FindItemRemove
//
//  Synopsis:   Search for an element with a matching SID and, if found, remove
//              it from the list and return its pointer. Returns NULL if not
//              found.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberLinkList::FindItemRemove(PSID pSid)
{
    CMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        dspAssert(pItem->m_pwzDN);

        if (pItem->m_pSid && EqualSid(pItem->m_pSid, pSid))
        {
            if (pItem->Prev() == NULL)
            {
                // this item is the list head.
                //
                m_pListHead = pItem->Next();
            }
            pItem->UnLink();
            return pItem;
        }
        pItem = pItem->Next();
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::RemoveFirstItem
//
//  Synopsis:   Remove the first item from the list.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberLinkList::RemoveFirstItem(void)
{
    CMemberListItem * pItem = m_pListHead;

    if (pItem)
    {
        m_pListHead = pItem->Next();
        pItem->UnLink();
        return pItem;
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::AddItem
//
//  Synopsis:   Insert an item into the list.
//
//-----------------------------------------------------------------------------
BOOL
CMemberLinkList::AddItem(CMemberListItem * pItem, BOOL fMember)
{
    if (!pItem->m_fIsAlreadyMember)
    {
        return TRUE;
    }
    CMemberListItem * pItemCopy;

    if (m_pListHead == NULL)
    {
        pItemCopy = pItem->Copy();

        CHECK_NULL(pItemCopy, return FALSE);

        pItemCopy->m_fIsAlreadyMember = fMember;

        m_pListHead = pItemCopy;
    }
    else
    {
        CMemberListItem * pCur = m_pListHead;
        //
        // Make sure the item isn't already in the list.
        //
        while (pCur)
        {
            dspAssert(pCur->m_pwzDN);

            if (_wcsicmp(pCur->m_pwzDN, pItem->m_pwzDN) == 0)
            {
                return TRUE;
            }
            pCur = pCur->Next();
        }

        pItemCopy = pItem->Copy();

        CHECK_NULL(pItemCopy, return FALSE);

        pItemCopy->m_fIsAlreadyMember = fMember;

        pItemCopy->LinkAfter(m_pListHead);
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberLinkList::GetItemCount
//
//  Synopsis:   Return the count of elements in the list.
//
//-----------------------------------------------------------------------------
int
CMemberLinkList::GetItemCount(void)
{
    int cItem = 0;
    CMemberListItem * pItem = m_pListHead;

    while (pItem)
    {
        cItem++;
        pItem = pItem->Next();
    }
    return cItem;
}

//+----------------------------------------------------------------------------
//
//  Class:      CDsObjList
//
//  Purpose:    Base class for DS object lists that employ a two column
//              list view to show object Name and Folder.
//
//-----------------------------------------------------------------------------
CDsObjList::CDsObjList(HWND hPage, int idList) :
    m_hPage(hPage),
    m_idList(idList),
    m_nCurItem(0),
    m_fShowIcons(FALSE),
    m_fLimitExceeded(FALSE)
{
}

CDsObjList::~CDsObjList(void)
{
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::Init
//
//  Synopsis:   Initialize the list view, add its columns.
//
//-----------------------------------------------------------------------------
HRESULT
CDsObjList::Init(BOOL fShowIcons)
{
    m_fShowIcons = fShowIcons;

    m_hList = GetDlgItem(m_hPage, m_idList);

    if (m_hList == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ListView_SetExtendedListViewStyle(m_hList, LVS_EX_FULLROWSELECT);
    //
    // Set the column headings.
    //
    PTSTR ptsz;
    RECT rect;
    GetClientRect(m_hList, &rect);

    if (!LoadStringToTchar(IDS_COL_TITLE_OBJNAME, &ptsz))
    {
        ReportError(GetLastError(), 0, m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = OBJ_LIST_NAME_COL_WIDTH;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_NAME_COL;

    ListView_InsertColumn(m_hList, IDX_NAME_COL, &lvc);

    delete ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_OBJFOLDER, &ptsz))
    {
        ReportError(GetLastError(), 0, m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lvc.cx = rect.right - OBJ_LIST_NAME_COL_WIDTH;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_FOLDER_COL;

    ListView_InsertColumn(m_hList, IDX_FOLDER_COL, &lvc);

    delete ptsz;

    if (m_fShowIcons)
    {
        // Assign the imagelist to the listview
        //
        ListView_SetImageList(m_hList,
                              g_ClassIconCache.GetImageList(),
                              LVSIL_SMALL);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     GetNameParts
//
//  Synopsis:   The folder path and object name should be separated by a
//              newline character. Return a pointer to the name and allocate
//              a buffer for the folder part. Return NULL for the folder part
//              if a newline is not found. No folder is returned if the input
//              pointer pcstrFolder is NULL.
//
//-----------------------------------------------------------------------------
void
GetNameParts(const CStr& cstrCanonicalNameEx, CStr& cstrFolder, CStr & cstrName)
{
    int nCR = cstrCanonicalNameEx.Find(TEXT('\n'));

    if (-1 != nCR)
    {
        cstrFolder = cstrCanonicalNameEx.Left(nCR);

        cstrName = cstrCanonicalNameEx.Right(cstrCanonicalNameEx.GetLength() - nCR - 1);

        // Remove any escaping from the name
        //
        int nBackSlash;

        while ((nBackSlash = cstrName.Find(TEXT('\\'))) != -1)
        {
            CStr cstrTemp = cstrName.Left(nBackSlash);
            int count = cstrName.GetLength() - nBackSlash - 1;
            if (count > 0)
            {
               cstrTemp += cstrName.Right(cstrName.GetLength() - nBackSlash - 1);
            }
            cstrName = cstrTemp;
        }
    }
    else
    {
        cstrName = cstrCanonicalNameEx;
        cstrFolder.Empty();
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control.
//
//-----------------------------------------------------------------------------
HRESULT
CDsObjList::InsertIntoList(PTSTR ptzDisplayName, PVOID pData, int iIcon)
{
    HRESULT hr = S_OK;

    //
    // The name and folder should be separated by a new line character.
    //
    CStr cstrFolder, cstrName;
    CStr cstrDisplayName = ptzDisplayName;

    GetNameParts(cstrDisplayName, cstrFolder, cstrName);

    CHECK_HRESULT(hr, return hr);

    LV_ITEM lvi = {0};
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iSubItem = IDX_NAME_COL;

    lvi.pszText = const_cast<PTSTR>((LPCTSTR)cstrName);
    lvi.lParam = (LPARAM)pData;
    lvi.iItem = m_nCurItem;

    if (-1 != iIcon)
    {
        lvi.mask |= LVIF_IMAGE;
        // if the limit is exceeded use the default icon.
        lvi.iImage = (m_fLimitExceeded) ? 0 : iIcon;
    }

    int NewIndex = ListView_InsertItem(m_hList, &lvi);

    dspAssert(NewIndex != -1);

    if (!cstrFolder.IsEmpty())
    {
        ListView_SetItemText(m_hList, NewIndex, IDX_FOLDER_COL,
                             const_cast<PTSTR>((LPCTSTR)cstrFolder));

        //delete ptzFolder;
    }

    m_nCurItem++;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::GetItem
//
//  Synopsis:   Returns the name and item data for the indicated item. Any of
//              the input pointers can be NULL to skip that parameter.
//
//-----------------------------------------------------------------------------
HRESULT
CDsObjList::GetItem(int index, PTSTR * pptzName, PVOID * ppData)
{
    TCHAR tzBuf[256];
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = index;
    lvi.iSubItem = IDX_NAME_COL;
    lvi.pszText = tzBuf;
    lvi.cchTextMax = 256;

    if (!ListView_GetItem(m_hList, &lvi))
    {
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }

    if (pptzName)
    {
        if (lvi.pszText)
        {
            *pptzName = new TCHAR[_tcslen(lvi.pszText) + 1];

            CHECK_NULL_REPORT(*pptzName, m_hPage, return FALSE);

            _tcscpy(*pptzName, lvi.pszText);
        }
        else
        {
            *pptzName = NULL;
        }
    }
    if (ppData)
    {
        *ppData = (PVOID)lvi.lParam;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::GetCurListItem
//
//  Synopsis:   Returns the index, name (in an allocated buffer), and pointer
//              to the item data. Any of the input pointers can be NULL to skip
//              that parameter.
//
//-----------------------------------------------------------------------------
BOOL
CDsObjList::GetCurListItem(int * pIndex, PTSTR * pptzName, PVOID * ppData)
{
  int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);

  if (i < 0)
  {
    dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
    return FALSE;
  }

  HRESULT hr = GetItem(i, pptzName, ppData);

  if (FAILED(hr))
  {
    dspAssert(FALSE);
    return FALSE;
  }

  if (pIndex)
  {
    *pIndex = i;
  }

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::GetCurListItems
//
//  Synopsis:   Returns an array of indexes, names (in an allocated buffers), and pointers
//              to the items data. Any of the input pointers can be NULL to skip
//              that parameter.
//
//-----------------------------------------------------------------------------
BOOL
CDsObjList::GetCurListItems(int ** ppIndex, PTSTR ** ppptzName, PVOID ** pppData, int* pNumSelected)
{
  int iStartPoint = -1;
  int i = -1;
  UINT nSelected = ListView_GetSelectedCount(m_hList);

  if (ppIndex)
  {
    *ppIndex = new int[nSelected];
  }
  if (ppptzName)
  {
    *ppptzName = new PTSTR[nSelected];
  }
  if (pppData)
  {
    *pppData = new PVOID[nSelected];
  }

  for (UINT idx = 0; idx < nSelected; idx++)
  {
    i = ListView_GetNextItem(m_hList, iStartPoint, LVNI_SELECTED);

    if (i < 0)
    {
      dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
      if (ppIndex)
      {
        delete[] ppIndex;
        *ppIndex = 0;
      }
      if (ppptzName)
      {
        delete[] ppptzName;
        *ppptzName = 0;
      }
      if (pppData)
      {
        delete[] pppData;
        *pppData = 0;
      }
      return FALSE;
    }

    HRESULT hr;
    if (ppptzName == NULL && pppData == NULL)
    {
      hr = GetItem(i, NULL, NULL);
    }
    else if (pppData == NULL)
    {
      hr = GetItem(i, &((*ppptzName)[idx]), NULL);
    }
    else if (ppptzName == NULL)
    {
      hr = GetItem(i, NULL, &((*pppData)[idx]));
    }
    else
    {
      hr = GetItem(i, &((*ppptzName)[idx]), &((*pppData)[idx]));
    }

    if (FAILED(hr))
    {
      dspAssert(FALSE);
      if (ppIndex != NULL)
      {
        delete[] ppIndex;
        *ppIndex = 0;
      }
      if (ppptzName != NULL)
      {
        delete[] ppptzName;
        *ppptzName = 0;
      }
      if (pppData != NULL)
      {
        delete[] pppData;
        *pppData = 0;
      }
      return FALSE;
    }

    iStartPoint = i;
    (*ppIndex)[idx] = i;
  }
  *pNumSelected = nSelected;
  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control.
//
//  Arguments:  [pwzPath]        - object DN.
//              [iIcon]          - object icon, -1 means ignore.
//              [fAlreadyMember] - already member of group, not a new member in an add/apply-pending state.
//              [fPrimary]       - member by virtue of primaryGroupID attribute.
//              [fIgnoreDups]    - don't report error if already in list; used for merging in reverse membership.
//              [fDontChkDups]   - don't check for duplicates; used for initial listing of direct membership.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::InsertIntoList(PWSTR pwzPath, int iIcon, BOOL fAlreadyMember,
                                  BOOL fPrimary, BOOL fIgnoreDups,
                                  BOOL fDontChkDups, ULONG ulScopeType)
{
    HRESULT hr = S_OK, hrRet = S_OK;
    PWSTR pwzPathCopy = NULL, pwzCanEx = NULL;
    PTSTR ptzCanEx = NULL;
    CMemberListItem * pListItem = NULL;
    BOOL fCanBePrimary = FALSE;

    //
    // Convert the distinguished name to a more friendly variant for display
    // in the list.
    //
    if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == ulScopeType)
    {
        if (!UnicodeToTchar(pwzPath, &ptzCanEx))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            hr = E_OUTOFMEMORY;
            goto ErrorCleanup;
        }
        PTSTR ptzSlash = _tcspbrk(ptzCanEx, TEXT("\\/"));
        if (ptzSlash)
        {
            *ptzSlash = TEXT('\n');
        }
    }
    else
    {
        hr = CrackName(pwzPath, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_hPage);

        if (DS_NAME_ERROR_NO_MAPPING == HRESULT_CODE(hr))
        {
            hrRet = MAKE_HRESULT(SEVERITY_ERROR, 0, DS_NAME_ERROR_NO_MAPPING);
            hr = S_OK;
        }
        CHECK_HRESULT(hr, goto ErrorCleanup);

        if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
        {
            LocalFreeStringW(&pwzCanEx);
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            hr = E_OUTOFMEMORY;
            goto ErrorCleanup;
        }
        LocalFreeStringW(&pwzCanEx);
    }

    if (!fDontChkDups)
    {
        //
        // Check to see if the item is already in the list.
        //
        LV_ITEM lvi;
        lvi.mask = LVIF_PARAM;
        lvi.iItem = 0;
        lvi.iSubItem = IDX_NAME_COL;

        while (ListView_GetItem(m_hList, &lvi))
        {
            pListItem = (CMemberListItem *)lvi.lParam;
            dspAssert(pListItem);

            if (_wcsicmp(pListItem->m_pwzDN, pwzPath) == 0)
            {
                if (fIgnoreDups)
                {
                    DO_DEL(ptzCanEx);
                    return S_OK;
                }

                CStr cstrName;
                CStr cstrCanEx = ptzCanEx;
                CStr cstrFolder;

                GetNameParts(cstrCanEx, cstrFolder, cstrName);

                ErrMsgParam(IDS_GRP_ALREADY_MEMBER,
                  reinterpret_cast<LPARAM>((LPCTSTR)cstrName), m_hPage);

                DO_DEL(ptzCanEx);
                return HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
            }
            lvi.iItem++;
        }
    }

    //
    // Put the item into the list.
    //
    pListItem = new CMemberListItem;

    CHECK_NULL_REPORT(pListItem, m_hPage, goto ErrorCleanup);

    if (!AllocWStr(pwzPath, &pwzPathCopy))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        hr = E_OUTOFMEMORY;
        goto ErrorCleanup;
    }

    pListItem->m_ptzName = ptzCanEx;
    pListItem->m_pwzDN = pwzPathCopy;
    pListItem->m_fIsAlreadyMember = fAlreadyMember;
    pListItem->m_fCanBePrimary = fCanBePrimary;
    pListItem->m_fIsPrimary = fPrimary;
    pListItem->m_ulScopeType = ulScopeType;

    hr = CDsObjList::InsertIntoList(ptzCanEx, pListItem, iIcon);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    return hrRet;

ErrorCleanup:

    DO_DEL(pwzPathCopy);
    DO_DEL(ptzCanEx);
    DO_DEL(pListItem);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control. This method uses
//              the object-SID to identify the new group member which in this
//              case is from an external domain.
//
//  Arguments:  [pSid]    - a binary SID.
//              [pwzPath] - an object name in WINNT format (domain\name or
//                          domain/name).
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::InsertIntoList(PSID pSid, PWSTR pwzPath)
{
    HRESULT hr;
    PTSTR ptzCanEx, ptzSlash;
    CMemberListItem * pListItem = NULL;

    if (!UnicodeToTchar(pwzPath, &ptzCanEx))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return E_OUTOFMEMORY;
    }

    ptzSlash = _tcspbrk(ptzCanEx, TEXT("\n"));

    if (!ptzSlash)
    {
        ptzSlash = _tcspbrk(ptzCanEx, TEXT("/\\"));

        dspAssert(ptzSlash);

        if (ptzSlash)
        {
            *ptzSlash = TEXT('\n');
        }
    }

    //
    // Check to see if the item is already in the list. Use the display name
    // (canonical name) rather than the DN since the DN of an existing external
    // domain group member will be different from the initial path name (the
    // <SID=01050xxx> name).
    //
    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = IDX_NAME_COL;

    while (ListView_GetItem(m_hList, &lvi))
    {
        pListItem = (CMemberListItem *)lvi.lParam;
        dspAssert(pListItem);

        if (_tcsicmp(pListItem->m_ptzName, ptzCanEx) == 0)
        {
            CStr cstrName;
            CStr cstrCanEx = ptzCanEx;
            CStr cstrFolder;

            GetNameParts(cstrCanEx, cstrFolder, cstrName);

            ErrMsgParam(IDS_GRP_ALREADY_MEMBER,
                        reinterpret_cast<LPARAM>((LPCTSTR)cstrName), m_hPage);

            DO_DEL(ptzCanEx);
            return HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
        }
        lvi.iItem++;
    }

    //
    // Put the item into the list.
    //
    pListItem = new CMemberListItem;

    CHECK_NULL_REPORT(pListItem, m_hPage, return E_OUTOFMEMORY);

    PWSTR pwzSidPath;
    CStrW strSIDname;

    ConvertSidToPath(pSid, strSIDname);

    if (!AllocWStr(const_cast<PWSTR>((LPCWSTR)strSIDname), &pwzSidPath))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        hr = E_OUTOFMEMORY;
        goto ErrorCleanup;
    }

    pListItem->m_ptzName = ptzCanEx;
    pListItem->m_pwzDN = pwzSidPath;
    pListItem->m_fIsExternal = TRUE;
    pListItem->SetSid(pSid);

    hr = CDsObjList::InsertIntoList(ptzCanEx, pListItem);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    return S_OK;

ErrorCleanup:

    DO_DEL(pwzSidPath);
    DO_DEL(ptzCanEx);
    DO_DEL(pListItem);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::InsertIntoList
//
//  Synopsis:   Insert the item into the listview control.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::InsertIntoList(CMemberListItem * pItem)
{
    HRESULT hr = S_OK;
    PWSTR pwzCanEx = NULL;
    PTSTR ptzCanEx = NULL;

    //
    // Convert the 1779 name to a more friendly variant for display
    // in the list.
    //
    hr = CrackName(pItem->m_pwzDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_hPage);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
    {
        LocalFreeStringW(&pwzCanEx);
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        hr = E_OUTOFMEMORY;
        goto ErrorCleanup;
    }
    LocalFreeStringW(&pwzCanEx);

    hr = CDsObjList::InsertIntoList(ptzCanEx, pItem);

    CHECK_HRESULT(hr, goto ErrorCleanup);

    return S_OK;

ErrorCleanup:

    DO_DEL(ptzCanEx);
    DO_DEL(pItem);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsObjList::RemoveListItem
//
//  Synopsis:   Removes the indicated list item.
//
//-----------------------------------------------------------------------------
BOOL
CDsObjList::RemoveListItem(int Index)
{
    if (!ListView_DeleteItem(m_hList, Index))
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return FALSE;
    }

    m_nCurItem--;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::RemoveListItem
//
//  Synopsis:   Removes the indicated list item, deleting the item data obj.
//
//-----------------------------------------------------------------------------
BOOL
CDsMembershipList::RemoveListItem(int Index)
{
    CMemberListItem * pItem;
    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = Index;
    lvi.iSubItem = IDX_NAME_COL;

    if (!ListView_GetItem(m_hList, &lvi))
    {
        dspAssert(FALSE);
        return FALSE;
    }

    pItem = (CMemberListItem *)lvi.lParam;
    if (pItem)
    {
        delete pItem;
    }

    if (!ListView_DeleteItem(m_hList, Index))
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return FALSE;
    }

    m_nCurItem--;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::ClearList
//
//  Synopsis:   Remove all list items, freeing memory.
//
//-----------------------------------------------------------------------------
void
CDsMembershipList::ClearList(void)
{
    CMemberListItem * pItem;
    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = IDX_NAME_COL;

    while (ListView_GetItem(m_hList, &lvi))
    {
        pItem = (CMemberListItem *)lvi.lParam;
        if (pItem)
        {
            delete pItem;
        }
        lvi.iItem++;
    }

    ListView_DeleteAllItems(m_hList);

    m_nCurItem = 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::GetIndex
//
//  Synopsis:   Find the list entry whose DN matches and return the index.
//
//  Arguments:  [pwzDN]   - DN to match, matches only first instance.
//              [ulStart] - Index on which to start search.
//              [ulEnd]   - Search end index. If zero or less than ulStart,
//                          search to the end of the list.
//
//-----------------------------------------------------------------------------
int
CDsMembershipList::GetIndex(LPCWSTR pwzDN, ULONG ulStart, ULONG ulEnd)
{
    int i = ulStart;
    CMemberListItem * pItem;

    while (TRUE)
    {
        if (FAILED(GetItem(i, &pItem)))
        {
            return -1;
        }
        if (_wcsicmp(pwzDN, pItem->m_pwzDN) == 0)
        {
            return i;
        }
        if (ulEnd && (ULONG)i >= ulEnd)
        {
            return -1;
        }
        i++;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipList::SetMemberIcons
//
//  Synopsis:   Query the DS for the class and userAccountControl of the list's
//              members. Use the returned info to select an icon for each item.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipList::SetMemberIcons(CDsPropPageBase *pPage)
{
    HRESULT hr = S_OK;

    //
    // Just put this here so /W4 doesn't complain when compiling for Win9x
    //
    pPage;

    if (0 == g_ulMemberFilterCount)
    {
        return S_OK;
    }

    if ((ULONG)GetCount() > g_ulMemberQueryLimit)
    {
        m_fLimitExceeded = TRUE;
        return S_OK;
    }

#if defined (DSADMIN)

    CComPtr <IDirectorySearch> spDsSearch;
    CSmartWStr cswzCleanObj;
    PWSTR pwzDnsDom;

    hr = pPage->SkipPrefix(pPage->GetObjPathName(), &cswzCleanObj);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);
    //
    // To bind to a GC, you need to supply the domain name rather than the
    // server path because the current DC may not be hosting a GC.
    //
    hr = CrackName(cswzCleanObj, &pwzDnsDom, GET_DNS_DOMAIN_NAME, pPage->GetHWnd());

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = DSPROP_GetGCSearchOnDomain(pwzDnsDom,
                                    IID_IDirectorySearch,
                                    (PVOID*)&spDsSearch);
    LocalFreeStringW(&pwzDnsDom);

    if (S_OK != hr)
    {
        if (S_FALSE == hr ||
            HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) == hr)
        {
            ErrMsg(IDS_WARN_NO_GC_FOUND, pPage->GetHWnd());
        }
        else if (HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE) == hr)
        {
            ErrMsg(IDS_WARN_ACCESS_TO_GC_DENIED, pPage->GetHWnd());
        }
        else
        {
            CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(),;);
        }
        return hr;
    }

    CStrW csFilter = L"(|", csClass, csClause;
    CMemberListItem * pItem;
    ULONG i, ulStart = 0, ulEnd;
    ADS_SEARCHPREF_INFO SearchPref;
    WCHAR wzSearchFormat[] = L"(%s=%s)";
    PWSTR pwzAttrNames[] = {g_wzDN, g_wzObjectClass, g_wzUserAccountControl};

    SearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref.vValue.Integer = ADS_SCOPE_SUBTREE;
    SearchPref.vValue.dwType = ADSTYPE_INTEGER;

    hr = spDsSearch->SetSearchPreference(&SearchPref, 1);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    while (TRUE)
    {
        ulEnd = ulStart + g_ulMemberFilterCount;

        for (i = ulStart; i < ulEnd; i++)
        {
            if (GetItem(i, &pItem) == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            {
                // End Of List, reset end counter.
                //
                ulEnd = i;
                break;
            }
    
            csClause.Format(wzSearchFormat, g_wzDN, pItem->m_pwzDN);

            csFilter += csClause;
        }

        csFilter += L")";

        ADS_SEARCH_HANDLE hSrch = NULL;
        dspDebugOut((DEB_USER14 | DEB_ITRACE, "About to do the member search.\n"));

        hr = spDsSearch->ExecuteSearch((PWSTR)(LPCWSTR)csFilter,
                                       pwzAttrNames, ARRAYLENGTH(pwzAttrNames),
                                       &hSrch);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);
        dspDebugOut((DEB_USER14 | DEB_ITRACE, "Member search returned.\n"));

        hr = spDsSearch->GetNextRow(hSrch);

        for (i = ulStart; (i < ulEnd) && (S_OK == hr); i++)
        {
            ADS_SEARCH_COLUMN Column;
            BOOL fDisabled = FALSE;
            CStrW csDN;
            int iIndex;

            //
            // Get the object dn.
            //
            hr = spDsSearch->GetColumn(hSrch, g_wzDN, &Column);

            CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), break);

            csDN = Column.pADsValues->CaseIgnoreString;

            spDsSearch->FreeColumn(&Column);

            //
            // Get the object class.
            //
            hr = spDsSearch->GetColumn(hSrch, g_wzObjectClass, &Column);

            CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), break);

            // Krishna sez the most derived class is *always* the last array element...
            csClass = Column.pADsValues[Column.dwNumValues - 1].CaseIgnoreString;

            spDsSearch->FreeColumn(&Column);

            //
            // Get the object userAccountControl.
            //
            hr = spDsSearch->GetColumn(hSrch, g_wzUserAccountControl, &Column);

            if (S_OK == hr)
            {
                fDisabled = (Column.pADsValues->Integer & UF_ACCOUNTDISABLE) != 0;
                spDsSearch->FreeColumn(&Column);
            }

            if ((iIndex = GetIndex(csDN, ulStart, ulEnd)) == -1)
            {
                dspAssert(FALSE && "list entry not found!");
                return E_FAIL;
            }

            LV_ITEM lvi = {0};
            lvi.mask = LVIF_IMAGE;
            lvi.iSubItem = IDX_NAME_COL;
            lvi.iItem = iIndex;
            lvi.iImage = g_ClassIconCache.GetClassIconIndex(csClass, fDisabled);
            if (lvi.iImage == -1)
            {
              lvi.iImage = g_ClassIconCache.AddClassIcon(csClass, fDisabled);
            }
            ListView_SetItem(m_hList, &lvi);

            hr = spDsSearch->GetNextRow(hSrch);
        }

        dspDebugOut((DEB_USER14 | DEB_ITRACE, "Members updated with icons.\n"));

        spDsSearch->CloseSearchHandle(hSrch);

        if (ulEnd != (ulStart + g_ulMemberFilterCount))
        {
            // EOL, stop processing.
            //
            break;
        }
        ulStart = ulEnd;
        csFilter = L"(|";
    }

#endif // defined (DSADMIN)

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Class:      CMemberListItem
//
//  Purpose:    Item data for the reverse membership list.
//
//-----------------------------------------------------------------------------
//+----------------------------------------------------------------------------
//
//  Method:     CMemberListItem::Copy
//
//  Synopsis:   Return a copy of the original element.
//
//-----------------------------------------------------------------------------
CMemberListItem *
CMemberListItem::Copy(void)
{
    CMemberListItem * pItem = new CMemberListItem;

    CHECK_NULL(pItem, return NULL);

    if (this->m_pwzDN)
    {
        if (!AllocWStr(this->m_pwzDN, &pItem->m_pwzDN))
        {
            delete pItem;
            return NULL;
        }
    }
    if (this->m_ptzName)
    {
        if (!AllocTStr(this->m_ptzName, &pItem->m_ptzName))
        {
            delete pItem;
            return NULL;
        }
    }
    if (this->m_pSid)
    {
        if (!pItem->SetSid(this->m_pSid))
        {
            delete pItem;
            return NULL;
        }
    }
    pItem->m_fIsPrimary = this->m_fIsPrimary;
    pItem->m_ulScopeType = this->m_ulScopeType;
    pItem->m_fSidSet = this->m_fSidSet;
    pItem->m_fCanBePrimarySet = this->m_fCanBePrimarySet;
    pItem->m_fCanBePrimary = this->m_fCanBePrimary;
    pItem->m_fIsAlreadyMember = this->m_fIsAlreadyMember;
    pItem->m_fIsExternal = this->m_fIsExternal;

    return pItem;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMemberListItem::SetSid
//
//  Synopsis:   Copy and store the passed in SID.
//
//-----------------------------------------------------------------------------
BOOL
CMemberListItem::SetSid(PSID pSid)
{
    int cb = GetLengthSid(pSid);
    dspAssert(cb);
    this->m_pSid = new BYTE[cb];
    CHECK_NULL(this->m_pSid, return FALSE);
    memcpy(this->m_pSid, pSid, cb);
    m_fSidSet = TRUE;
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   ConvertSidToPath
//
//  Synopsis:   Converts the binary SID to a string LDAP path.
//
//-----------------------------------------------------------------------------
void
ConvertSidToPath(PSID pObjSID, CStrW &strSIDname)
{
    strSIDname = g_wzSidPathPrefix;
    //
    // Convert the bytes of the sid to hex chars.
    //
    PBYTE  pbSid = (PBYTE)pObjSID;
    ULONG  i;
    PUCHAR  pcSubAuth = NULL;

    pcSubAuth = GetSidSubAuthorityCount(pObjSID);

    dspAssert(pcSubAuth);

    ULONG cbSid = GetSidLengthRequired(*pcSubAuth);

    dspAssert(cbSid);
    dspAssert(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

    for (i = 0; i < cbSid; i++)
    {
        WCHAR wzCur[3];

        wsprintfW(wzCur, L"%02x", *pbSid);
        pbSid++;

        strSIDname += wzCur;
    }

    strSIDname += g_wzSidPathSuffix;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::CClassIconCache
//
//-----------------------------------------------------------------------------
CClassIconCache::CClassIconCache(void) :
    m_fInitialized(FALSE),
    m_prgcce(NULL),
    m_hImageList(NULL)
{
    TRACE(CClassIconCache,CClassIconCache);
    m_nImageCount = 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::~CClassIconCache
//
//-----------------------------------------------------------------------------
CClassIconCache::~CClassIconCache(void)
{
  TRACE(CClassIconCache,~CClassIconCache);

  ClearAll();
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::ClearAll
//
//-----------------------------------------------------------------------------
void CClassIconCache::ClearAll(void)
{
  if (m_hImageList != NULL)
  {
    ImageList_RemoveAll(m_hImageList);
    ImageList_Destroy(m_hImageList);
    m_hImageList = NULL;
  }

  if (m_prgcce != NULL)
  {
    delete[] m_prgcce;
    m_prgcce = NULL;
    m_nImageCount = 0;
  }
  m_fInitialized = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::GetClassIconIndex
//
//-----------------------------------------------------------------------------
int CClassIconCache::GetClassIconIndex(PCWSTR pwzClass, BOOL fDisabled)
{
  int iIcon = -1;

  dspAssert(pwzClass);

  Initialize();

  if (m_prgcce != NULL && m_nImageCount > 0)
  {
    for (UINT i = 0; i < m_nImageCount; i++)
    {
      if (_wcsicmp(pwzClass, m_prgcce[i].wzClass) == 0)
      {
        iIcon = (fDisabled) ? m_prgcce[i].iDisabledIcon : m_prgcce[i].iIcon;
        break;
      }
    }
  }

  dspDebugOut((DEB_USER14, "CClassIconCache::GetClassIconIndex returning %d\n", iIcon));
  
  return iIcon;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::AddClassIcon
//
//-----------------------------------------------------------------------------
int CClassIconCache::AddClassIcon(PCWSTR pwzClass, BOOL fDisabled)
{
  //
  // Retrieves the icon for the class from the DisplaySpecifiers and puts it
  // in the image list
  //
  HICON hIcon = NULL;
  HICON hDisabledIcon = NULL;

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, const_cast<PWSTR>(pwzClass), 16, 16);

  if (!hIcon)
  {
    DBG_OUT("CClassIconCache::AddClassIcon failed in DsGetIcon for normal icon");
    return E_OUTOFMEMORY;
  }

  hDisabledIcon = DsGetIcon(DSGIF_ISDISABLED | DSGIF_GETDEFAULTICON, const_cast<PWSTR>(pwzClass), 16, 16);

  if (!hDisabledIcon)
  {
    DBG_OUT("CClassIconCache::AddClassIcon failed in DsGetIcon for disabled icon");
    hDisabledIcon = hIcon;
  }

  if (m_prgcce != NULL)
  {
    CLASS_CACHE_ENTRY* pNewList = new CLASS_CACHE_ENTRY[m_nImageCount + 1];
    if (pNewList == NULL)
    {
      return -1;
    }

    memcpy(pNewList, m_prgcce, sizeof(CLASS_CACHE_ENTRY) * m_nImageCount);
    delete[] m_prgcce;
    m_prgcce = pNewList;
  
    m_prgcce[m_nImageCount].iIcon = ImageList_AddIcon(m_hImageList, hIcon);
    
    if (hDisabledIcon == hIcon)
    {
      m_prgcce[m_nImageCount].iDisabledIcon = m_prgcce[m_nImageCount].iIcon;
    }
    else
    {
      m_prgcce[m_nImageCount].iDisabledIcon = ImageList_AddIcon(m_hImageList, hDisabledIcon);
    }
    m_nImageCount++;
  }

  DestroyIcon(hIcon);
  if (hDisabledIcon != hIcon)
  {
    DestroyIcon(hDisabledIcon);
  }
  return (fDisabled) ? m_prgcce[m_nImageCount - 1].iDisabledIcon : m_prgcce[m_nImageCount - 1].iIcon;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::Initialize
//
//-----------------------------------------------------------------------------
HRESULT CClassIconCache::Initialize(void)
{
  if (m_fInitialized)
  {
    return S_OK;
  }

  if (m_prgcce != NULL)
  {
    delete[] m_prgcce;
    m_prgcce = NULL;
    m_nImageCount = 0;
  }
  m_nImageCount = ICON_CACHE_NUM_CLASSES;
  m_prgcce = new CLASS_CACHE_ENTRY[m_nImageCount];
  if (m_prgcce == NULL)
  {
    m_nImageCount = 0;
    return -1;
  }
  memset(m_prgcce, 0, sizeof(CLASS_CACHE_ENTRY) * m_nImageCount);

  dspAssert(m_prgcce != NULL);

  TRACE(CClassIconCache,Initialize);
  
  m_hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);

  if (NULL == m_hImageList)
  {
      DBG_OUT("ImageList_Create failed");
      return E_OUTOFMEMORY;
  }

  HICON hIcon;

  //
  // Default
  //
  hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MEMBER));

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for member icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[0].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  wcscpy(m_prgcce[0].wzClass, L"default");

  m_prgcce[0].iDisabledIcon = m_prgcce[0].iIcon;

  //
  // User
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzUser, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for user icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[1].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  hIcon = DsGetIcon(DSGIF_ISDISABLED | DSGIF_GETDEFAULTICON, g_wzUser, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for user disable icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[1].iDisabledIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  wcscpy(m_prgcce[1].wzClass, g_wzUser);

  //
  // Computer
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzComputer, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for computer icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[2].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  hIcon = DsGetIcon(DSGIF_ISDISABLED | DSGIF_GETDEFAULTICON, g_wzComputer, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for computer disable icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[2].iDisabledIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  wcscpy(m_prgcce[2].wzClass, g_wzComputer);

  //
  // Contact
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzContact, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for contact icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[3].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  m_prgcce[3].iDisabledIcon = -1;

  wcscpy(m_prgcce[3].wzClass, g_wzContact);

  //
  // Group
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzGroup, 16, 16);

  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for group icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[4].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  m_prgcce[4].iDisabledIcon = -1;

  wcscpy(m_prgcce[4].wzClass, g_wzGroup);

  //
  // FPO
  //

  hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, g_wzFPO, 16, 16);
  if (!hIcon)
  {
      DBG_OUT("DsGetIcon failed for fpo icon");
      return E_OUTOFMEMORY;
  }

  m_prgcce[5].iIcon = ImageList_AddIcon(m_hImageList, hIcon);

  DestroyIcon(hIcon);

  m_prgcce[5].iDisabledIcon = -1;

  wcscpy(m_prgcce[5].wzClass, g_wzFPO);

  m_fInitialized = TRUE;

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CClassIconCache::GetImageList
//
//-----------------------------------------------------------------------------
HIMAGELIST CClassIconCache::GetImageList(void)
{
  if (FAILED(Initialize()))
  {
    return NULL;
  }

  return m_hImageList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\pages.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       pages.h
//
//  Contents:   Resource identifiers.
//
//  Notes:      You can view the resources in VC, but DO NOT save from VC! The
//              help IDs do not map 1 to 1 with the control IDs and VC will
//              overwrite them.
//
//-----------------------------------------------------------------------------
#define IDD_SHELL_ADDRESS               101
#define IDC_OTHER_PHONE_BTN             101
#define IDD_SHELL_NAME                  102
#define IDD_SHELL_VOLUME_GEN            103
#define IDC_OTHER_URL_BTN               103
#define IDD_SHELL_COMPUTER_GEN          104
#define IDD_SHELL_GROUP_GENERAL         105
#define IDD_SHELL_GROUP_GEN             106
#define IDD_SHELL_DOMAIN_GEN            107
#define IDD_SHELL_OU_GEN                108
#define IDD_SHELL_BUSINESS              109
#define IDD_SHELL_MEMBERSHIP            110
#define IDD_SHELL_USER_GEN              111
#define IDD_OBJECT                      130
#define IDD_USER                        131
#define IDD_ADDRESS                     134
#define IDD_USER_ORG                    135
#define IDD_ACCOUNT                     136
#define IDD_MEMBER                      139
#define IDD_GROUP                       146
#define IDD_SITE_GENERAL                147
#define IDC_SUBNET_LIST                 148
#define IDD_DS_SERVER_GENERAL           149
#define IDC_ADD_BTN                     149
#define IDC_REMOVE_BTN                  150
#define IDC_LOCAL_PATH_RADIO            151
#define IDC_CONNECT_TO_RADIO            152
#define IDC_DRIVES_COMBO                153
#define IDC_LOCAL_PATH_EDIT             154
#define IDD_GROUP_GEN                   156
#define IDD_NTDSDSA_CONN                157
#define IDC_ACCT_LOCKOUT_CHK            158
#define IDC_ACCT_NEVER_EXPIRES_RADIO    161
#define IDC_ACCT_EXPIRES_ON_RADIO       162
#define IDC_ACCT_EXPIRES                163
#define IDC_PROFILE_PATH_EDIT           164
#define IDC_LOGON_SCRIPT_EDIT           165
#define IDC_LOGON_HOURS_BTN             166
#define IDC_LOGON_TO_BTN                167
#define IDC_CONNECT_TO_PATH_EDIT        168
#define IDC_COUNTRY_COMBO               169
#define IDC_NTDSDSA_GLOBAL_CATALOG      170
#define IDC_HOMEPHONE_EDIT              170
#define IDC_NTDSDSA_REPLICATE_FROM      171
#define IDC_NTDSDSA_REPLICATE_TO        172
#define IDS_TITLE_BUSINESS              172
#define IDC_OTHER_PAGER_BTN             172
#define IDS_CANT_VIEW_EXTERNAL          173
#define IDS_NATIVE_MODE                 174
#define IDC_OTHER_MOBLE_BTN             174
#define IDC_CHECK_LIST                  175
#define IDS_MSG_DISABLING_SECURITY      175
#define IDS_CONFIRM_DOM_RAISE           176
#define IDC_OTHER_FAX_BTN               176
#define IDC_COMMENT_EDIT                177
#define IDS_ERR_LOOKUP_FAILED           177
#define IDS_CHANGED_REBOOT              178
#define IDS_MODE_CHANGED                178
#define IDS_NO_GC_FOR_MEMBERSHIP        179
#define IDC_VIEW_BTN                    180
#define IDS_TRUST_TRANSITIVE            180
#define IDS_TRUSTED_SUCCEEDED           181
#define IDS_DES_KEY_ONLY                182
#define IDS_ERR_COUNTRY_DATA_BAD        183
#define IDS_BUILTIN_GROUP               184
#define IDS_DONT_REQ_PREAUTH            185
#define IDS_ERRMSG_NO_VOLUME_PATH       186
#define IDC_CLOSE                       187
#define IDS_GRP_NO_NAME_MAPPING         187
#define IDS_UACCT_NO_DOMAIN             188
#define IDS_NO_VALUE                    189
#define IDC_CLASS_STATIC                190
#define IDC_CREATED_TIME_STATIC         191
#define IDC_MODIFIED_TIME_STATIC        192
#define IDC_USN_CREATED_STATIC          193
#define IDC_USN_MODIFIED_STATIC         194
#define IDS_MUST_CHANGE_PW              197
#define IDS_MULTISEL_LIMIT              199
#define IDC_DS_SITE_IN_SUBNET           200
#define IDC_UNC_NAME_EDIT               200
#define IDS_REL_TREE_ROOT               200
#define IDC_BROWSE_BTN                  201
#define IDS_TRUST_RESET_NO_DC           201
#define IDC_LAST_INDEXED_STATIC         202
#define IDS_CANCEL_CANT_VERIFY          202
#define IDC_INDEX_CHECK                 203
#define IDS_MEMBERSHIP_OBJ_NOT_IN_GC    203
#define IDS_FPO_NO_NAME_MAPPING         204
#define IDC_CHECK_COLOR                 205
#define IDC_CHECK_STAPLE                206
#define IDC_EDIT_RESOLUTION             207
#define IDC_EDIT_SPEED                  208
#define IDC_BUTTON_BROWSE               211
#define IDC_LOCATION_EDIT               213
#define IDC_MODEL_EDIT                  214
#define IDC_MANAGER_EDIT                215
#define IDC_DESC_EDIT                   215
#define IDC_MGR_CHANGE_BTN              216
#define IDC_TITLE_EDIT                  217
#define IDD_PHONE                       218
#define IDC_DEPT_EDIT                   218
#define IDC_COMPANY_EDIT                219
#define IDC_PRI_GRP_BTN                 220
#define IDC_MEMBER_LIST                 221
#define IDC_PATH_FIELD                  223
#define IDC_PRI_GRP_STATIC              224
#define IDC_RM_GRP_BTN                  225
#define IDC_COMBO_PAPER_SIZE            226
#define IDD_OU                          226
#define IDD_OU_GEN                      226
#define IDD_DS_CONNECTION_GENERAL       227
#define IDC_MGR_CLEAR_BTN               227
#define IDC_REPORTS_LIST                228
#define IDD_SUBNET_GENERAL              229
#define IDC_MANAGEDBY_EDIT              229
#define IDD_DOMAIN                      230
#define IDC_STREET_EDIT                 230
#define IDD_DOMAINPOLICY                231
#define IDD_VOLUME                      232
#define IDD_GENERAL_PRINTQ              233
#define IDD_MANAGEDBY                   234
#define IDD_DOMAIN_TRUST                237
#define IDD_LOCALPOLICY_GEN             238
#define IDI_LOCAL_POLICY                238
#define IDC_NTDSDSA_QUERY_POLICY        239
#define IDD_COMPUTER                    239
#define IDI_SITEREPL                    239
#define IDD_FOREST_ROUTING              241
#define IDC_SUFFIXES_LIST               242
#define IDD_TRUSTED_DOM_GEN             246
#define IDD_NTDSDSA_GENERAL             249
#define IDD_FRS_CONNECTION_GENERAL      250
#define IDC_TRUSTED_STATIC              273
#define IDC_ADD_TRUST_BTN               274
#define IDC_REMOVE_TRUSTED_BTN          275
#define IDC_VIEW_TRUSTED_BTN            276
#define IDC_TRUSTING_STATIC             277
#define IDC_REMOVE_TRUSTING_BTN         278
#define IDC_VIEW_TRUSTING_BTN           279
#define IDC_SHOW_ROUTING_CHK            280
#define IDC_TRUSTED_LIST                281
#define IDC_TRUSTING_LIST               282
#define IDC_NET_ADDR_EDIT               285
#define IDC_ROLE_EDIT                   286
#define IDC_OS_EDIT                     287
#define IDC_OS_VER_EDIT                 288
#define IDC_DOMAIN_EDIT                 289
#define IDC_PW1_EDIT                    290
#define IDC_PW2_EDIT                    291
#define IDC_SUBNET_ADDRESS              292
#define IDC_SUBNET_MASK                 293
#define IDC_SITESETTINGS_CACHE_MEMB     294
#define IDC_SITESETTINGS_PREFERRED_SITE 295
#define IDS_EMPTY_SAM_NAME              311
#define IDS_CANT_CHANGE_PW              312
#define IDS_ERR_PARENT_CANCELED         314
#define IDD_USR_PROFILE                 315
#define IDS_NO_ACCESS_GC_FOR_MEMBERSHIP 315
#define IDD_MULTI_VALUE                 316
#define IDS_BUILTIN_NO_NEST             316
#define IDD_USER_CERTIFICATES           317
#define IDS_TRUST_NON_TRANSITIVE        317
#define IDS_TRUST_BAD_DOMAIN            318
#define IDS_VERIFY_TRUST_NOGOOD         319
#define IDS_NO_SAMNAME_FOR_PROFILE      320
#define IDC_CRED_PROMPT                 321
#define IDS_VERIFY_DOWNLEVEL_TRUST_NOGOOD 322
#define IDB_CERTIFICATE                 323
#define IDD_COMPUTER_OS                 324
#define IDD_RPC_GEN                     325
#define IDC_TYPE                        329
#define IDI_DS_WARNING                  329
#define IDC_ROLE                        329
#define IDC_TITLE                       330
#define IDC_COMPANY                     331
#define IDC_DEPARTMENT                  332
#define IDC_DIVISION                    333
#define IDC_OFFICE                      334
#define IDC_KEYWORDS_LIST               335
#define IDC_MEMBERS_LIST                336
#define IDC_DOMAIN_CHANGE_BUTTON        337
#define IDC_DOMAIN_NAME_EDIT            340
#define IDC_PEER_NAME_EDIT              341
#define IDC_TRUST_TYPE_EDIT             342
#define IDC_MAKE_PARENT_CHK             343
#define IDC_TRANSITIVE_CHK              345
#define IDC_SCHEDULE_BTN                346
#define IDC_PHONE_EDIT                  346
#define IDC_EMAIL_EDIT                  347
#define IDC_HOME_PAGE_EDIT              348
#define IDC_PAGER_EDIT                  350
#define IDC_MOBILE_EDIT                 351
#define IDC_OTHER_HOME_BTN              352
#define IDC_URL_EDIT                    353
#define IDC_DS_ICON                     354
#define IDC_NT5_NAME_EDIT               355
#ifdef CUSTOM_SCHEDULE
#define IDC_SCHEDULE_CHECKBOX           356
#endif
#define IDC_NT4_DOMAIN                  357
#define IDC_NT4_NAME_EDIT               358
#define IDC_EDIT                        361
#define IDC_LIST                        363
#define IDC_CERT_LIST                   364
#define IDC_VIEW_CERT                   365
#define IDC_COPY_TO_FILE                366
#define IDC_ADD_FROM_STORE              367
#define IDC_ADD_FROM_FILE               368
#define IDC_REMOVE                      369
#define IDC_PRI_GRP_LABEL               370
#define IDC_DIVIDING_LINE               371
#define IDC_PICTURE_BMP                 372
#define IDC_EDIT_COMMENT                374
#define IDC_FOREST_VERSION_STATIC       375
#define IDD_INTERSITE_GENERAL           403
#define IDD_DEFAULT_GENERAL             404
#define IDD_CONTAINER_GENERAL           405
#define IDD_NT_GROUP                    406
#define IDC_FRS_ROOT_PATH               411
#define IDC_FRS_STAGING_PATH            412
#define IDD_DS_SITE_SETTINGS_GENERAL    413
#define IDD_DS_SITE_LICENSE_SETTINGS_GENERAL 414
#define IDD_NTFRS_REPLICA_SET_GENERAL   421
#define IDD_NTFRS_MEMBER_GENERAL        422
#define IDD_NTFRS_SUBSCRIBER_GENERAL    424
#define IDD_SITELINK_GENERAL            430
#define IDD_SITELINKBRIDGE_GENERAL      431
#define IDD_LOGON_WKSTA                 432
#define IDD_ERROR_PAGE                  433
#define IDD_FPO_GENERAL                 434
#define IDD_FPNW_PROPERTIES             440
#define IDC_ADVANCED_BUTTON             441
#define IDC_SCRIPT_BUTTON               442
#define IDC_NETWARE_ENABLE              443
#define IDC_NWPWEXPIRED                 444
#define IDC_UNLIMITED_GRACELOGINS       445
#define IDC_LIMIT_GRACELOGINS           446
#define IDC_CONCURRENT_CONNECTIONS      447
#define IDC_UNLIMITED_CONNECTIONS       448
#define IDC_LIMIT_CONNECTIONS           449
#define IDC_GRACE_SPIN                  450
#define IDC_GRACE_LIMIT                 451
#define IDC_GRACE_REMAINING_SPIN        452
#define IDC_GRACE_REMAINING             453
#define IDC_GRACE_REMAINING_TEXT        454
#define IDC_CONNECTION_SPIN             455
#define IDC_CONNECTION_LIMIT            456
#define IDC_OBJECT_ID                   457
#define IDC_GRACE_LOGINS                458
#define IDC_OBJECTID_TEXT               459
#define IDC_NWHMDIR_RELPATH_TEXT        460
#define IDC_NWHMDIR_RELPATH             461
#define IDD_FPNW_PASSWORD               462
#define IDC_FPNWPASSWORD_USERNAME       463
#define IDC_FPNWPASSWORD_EDIT1          464
#define IDC_FPNWPASSWORD_EDIT2          465
#define IDD_FPNW_LOGON                  466
#define IDC_FPNWLOGON_USERNAME          467
#define IDC_FPNWLOGON_ALL               468
#define IDC_FPNWLOGON_SELECTED          469
#define IDC_FPNWLOGON_ADDRESS           470
#define IDC_FPNWLOGON_ADD               471
#define IDC_FPNWLOGON_REMOVE            472
#define IDD_FPNW_LOGON_ADDDLG           473
#define IDC_FPNWLOGONADD_NETWORKADDR    474
#define IDC_FPNWLOGONADD_NODEADDR       475
#define IDD_FPNW_LOGIN_SCRIPT           476
#define IDC_FPNWLOGINSCRIPT_EDIT        477
#define IDD_SPN_SUFFIX                  477
#define IDC_SPIN                        478
#define IDC_SPIN2                       479
#define IDD_DEFAULT_MULTI_GENERAL       500
#define IDC_OBJECT_TOTAL_STATIC         501
#define IDC_OU_COUNT_STATIC             502
#define IDC_USER_COUNT_STATIC           503
#define IDC_GROUP_COUNT_STATIC          504
#define IDC_COMPUTER_COUNT_STATIC       505
#define IDC_CONTACT_COUNT_STATIC        506
#define IDC_OTHER_COUNT_STATIC          507
#define IDC_ALWAYS_APPLY                525
#define IDD_MULTI_ACCOUNT               550
#define IDC_APPLY_UPN_CHK               551
#define IDC_APPLY_HOURS_CHK             552
#define IDC_APPLY_COMPUTERS_CHK         553
#define IDC_APPLY_EXPIRES_CHK           554
#define IDD_MULTI_USER_GENERAL          555
#define IDC_APPLY_DESC_CHK              556
#define IDC_APPLY_OFFICE_CHK            557
#define IDC_APPLY_PHONE_CHK             558
#define IDC_APPLY_EMAIL_CHK             559
#define IDC_APPLY_WEB_CHK               560
#define IDC_APPLY_FAX_CHK               561
#define IDC_DESC_STATIC                 562
#define IDC_OFFICE_STATIC               563
#define IDC_PHONE_STATIC                564
#define IDC_EMAIL_STATIC                565
#define IDC_WEB_STATIC                  566
#define IDC_FAX_STATIC                  567
#define IDC_SUMMARY_STATIC              568
#define IDD_MULTI_USER_ORG              570
#define IDC_APPLY_TITLE_CHK             571
#define IDC_APPLY_DEPT_CHK              572
#define IDC_APPLY_COMPANY_CHK           573
#define IDC_APPLY_MANAGER_CHK           574
#define IDC_NAME_STATIC                 575
#define IDD_MULTI_USER_PROFILE          578
#define IDC_APPLY_PROFILE_CHK           579
#define IDC_APPLY_SCRIPT_CHK            580
#define IDC_APPLY_HOMEDIR_CHK           581
#define IDC_TO_STATIC                   582
#define IDC_PROPERTIES_BUTTON           583
#define IDD_MULTISELECT_ERROR_DIALOG    585
#define IDC_ERROR_LIST                  586
#define IDC_COPY_BUTTON                 587
#define IDC_SUCCESS_LISTBOX             588
#define IDC_NOT_ATTEMPTED_LISTBOX       589
#define IDD_MULTI_USER_ADDRESS          590
#define IDC_APPLY_STREET_CHK            591
#define IDC_APPLY_POBOX_CHK             592
#define IDC_APPLY_CITY_CHK              593
#define IDC_APPLY_STATE_CHK             594
#define IDC_APPLY_ZIP_CHK               595
#define IDC_APPLY_COUNTRY_CHK           596
#define IDC_ERROR_STATIC                597
#define IDC_OU_LABEL_COUNT_STATIC       598
#define IDC_USER_LABEL_COUNT_STATIC     600
#define IDC_GROUP_LABEL_COUNT_STATIC    601
#define IDC_COMPUTER_LABEL_COUNT_STATIC 602
#define IDC_CONTACT_LABEL_COUNT_STATIC  603
#define IDC_OTHER_LABEL_COUNT_STATIC    604
#define IDC_SUMMARY_LABEL_STATIC        605
#define IDS_TRUST_FOREST_TRANSITIVE     606
#define IDD_RAISE_DOMAIN_VERSION        607
#define IDC_VER_NAME_STATIC             608
#define IDC_CUR_VER_STATIC              609
#define IDC_VER_COMBO                   610
#define IDS_DOM_VER_W2K_MIXED           611
#define IDS_DOM_VER_W2K_NATIVE          612
#define IDS_DOM_VER_XP_BETA_MIXED       613
#define IDS_DOM_VER_XP_BETA_NATIVE      614
#define IDS_DOM_VER_XP                  615
#define IDS_FOR_VER_W2K                 616
#define IDS_FOR_VER_XP_BETA             617
#define IDS_FOR_VER_XP                  618
#define IDD_HIGHEST_DOMAIN_VERSION      619
#define IDS_ERR_NO_DC                   620
#define IDC_CANT_RAISE_STATIC           621
#define IDS_CANT_RAISE_ACCESS           622
#define IDS_CANT_RAISE_PDC              623
#define IDS_CANT_RAISE_FSMO_HOLDER      624
#define IDS_CANT_RAISE_FOREST_ACCESS    625
#define IDD_CANT_RAISE_DOMAIN           626
#define IDC_SAVE_LOG                    627
#define IDS_DOM_VER_LOG_PREFIX          628
#define IDS_DOM_VER_LOG_HDR             629
#define IDS_DOM_VER_LOG_CREATE_FAILED   630
#define IDS_VERSION_ERROR_FORMAT        631
#define IDS_RAISE_DOM_VER_TITLE         632
#define IDD_RAISE_FOREST_VERSION        633
#define IDD_HIGHEST_FOREST_VERSION      634
#define IDD_CANT_RAISE_FOREST           635
#define IDS_RAISE_FOR_VER_TITLE         636
#define IDS_CONFIRM_FOR_RAISE           637
#define IDS_FOREST_CANT_RAISE_ACCESS    638
#define IDS_FOREST_CANT_RAISE_FSMO      639
#define IDS_FOR_VER_LOG_PREFIX          640
#define IDS_FOR_VER_LOG_HDR             641
#define IDS_FOR_VER_LOG_MODE_HDR        642
#define IDS_FOR_ERR_NO_DC               643
#define IDC_FOR_CANT_RAISE_STATIC       644
#define IDS_FOR_CANT_RAISE_STATIC       644
#define IDS_TWERR_REALM_ALREADY_EXISTS  645
#define IDS_TWERR_REALM_CANT_CHANGE     646
#define IDC_CONFIRM_NEXT_HINT           647
#define IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE 648
#define IDS_ERR_FOREST_TRUST_MISMATCH   649
#define IDD_CRED_ENTRY                  650
#define IDS_TW_VERIFY_OUTBOUND_TITLE    651
#define IDS_ERR_CHANGE_TRANSITIVITY     652
#define IDD_VERIFY_INBOUND              653
#define IDD_TRUST_RESET                 654
#define IDC_VERIFY_FAILURES             655
#define IDS_VERIFY_INBOUND              656
#define IDS_VERIFY_OUTBOUND             657
#define IDS_VERIFY_BAD_CREDS            658
#define IDS_OUTBOUND_TRUST_VERIFY_DONE  659
#define IDD_TRUSTWIZ_ALREADY_EXISTS_PAGE 660

#define IDC_COUNTRY_LABEL               998
#define IDS_COUNTRY_LABEL_NO_ACCEL      999
#define IDC_EDIT1                       1001
#define IDC_EDIT2                       1002
#define IDC_EDIT3                       1003
#define IDC_EDIT4                       1004
#define IDC_EDIT5                       1005
#define IDC_MANAGER                     1006
#define IDC_SVC_PACK_EDIT               1007
#define IDC_FAX_EDIT                    1008
#define IDC_CHECK1                      1010
#define IDC_CHECK2                      1011
#define IDC_CHECK_DOUBLE_SIDED          1012
#define IDC_RADIO_SEC_ENABLED           1012
#define IDC_ANY_WKSTA_RADIO             1012
#define IDC_RADIO_SEC_DISABLED          1013
#define IDC_SPECIFIC_WKSTAS_RADIO       1013
#define IDC_COMBO1                      1016
#define IDC_CHANGE_BTN                  1017
#define IDC_DWNLVL_TRANS_CHK            1021
#define IDC_LIST1                       1022
#define IDC_CLEAR_BTN                   1024
#define IDC_CN                          1025
#define IDC_SAM_NAME                    1028
#define IDS_SMARTCARD_REQ               1028
#define IDC_FIRST_NAME_EDIT             1029
#define IDS_DELEGATION_OK               1029
#define IDC_LAST_NAME_EDIT              1030
#define IDS_NOT_DELEGATED               1030
#define IDC_SH_FIRST_NAME_EDIT          1030
#define IDS_PASSWORD_MUTEX              1031
#define IDC_SH_LAST_NAME_EDIT           1031
#define IDC_INITIALS_EDIT               1031
#define IDC_DESCRIPTION_EDIT            1032
#define IDS_TRUST_SUCCEEDED             1032
#define IDS_TRUSTING_SUCCEEDED          1032
#define IDC_OFFICE_EDIT                 1033
#define IDC_SAM_NAME_EDIT               1033
#define IDS_CANT_WRITE                  1033
#define IDS_ERRMSG_NO_GROUP_ACCESS      1034
#define IDS_ERR_BOTH_PW_BTNS            1035
#define IDS_TRUSTDOM_LABEL_FORMAT       1036
#define IDS_ERR_BAD_TRUST               1037
#define IDC_ADDRESS_EDIT                1038
#define IDS_ADVANCED                    1038
#define IDC_CITY_EDIT                   1039
#define IDS_NO_PW_EXPIRE                1039
#define IDC_STATE_EDIT                  1040
#define IDS_ACCT_DISABLED               1040
#define IDC_ZIP_EDIT                    1041
#define IDS_ERR_UPN_NONUNIQUE           1041
#define IDC_COUNTRY_EDIT                1042
#define IDS_WARN_UPN_NO_GC_FOUND        1042
#define IDC_POBOX_EDIT                  1043
#define IDS_TRUST_RESET_QUERY           1043
#define IDS_PROFILE_USER_TOKEN          1043
#define IDS_TRUST_RESET_DONE            1044
#define IDC_DELETE_BTN                  1045
#define IDS_ERROR_TRUST_RESET           1045
#define IDS_ERR_TRUST_RESET_NOACCESS    1046
#define IDC_BUTTON1                     1047
#define IDC_BUS_ADDR_BTN                1047
#define IDS_ERR_CANT_DELEGATE           1047
#define IDS_TRUST_VERIFY_DONE           1048
#define IDS_HOME_DIR_CREATE_NO_ACCESS   1049
#define IDC_PROPPAGE_BTN                1050
#define IDS_FPNW_HOME_DIR_CREATE_NO_PARENT 1051
#define IDS_FPNW_HOME_DIR_CREATE_NO_ACCESS 1052
#define IDS_FPNW_HOME_DIR_CREATE_OTHER  1053
#define IDC_COMPUTER_BTN                1055
#define IDS_ERR_BOTH_MUST_EXPIRES       1056
#define IDC_DIALIN_PERMISSION           1072
#define IDC_NO_CALLBACK                 1073
#define IDC_SET_BY_CALLER               1074
#define IDC_PRESET_TO                   1075
#define IDC_PRESET_EDIT                 1076
#define IDD_TLN_EDIT                    1078
#define IDD_TLN_EXCLUDE                 1079
#define IDC_EXCLUDE_LABEL               1080
#define IDC_EXCLUDE_LABEL_LARGE         1081
#define IDC_EXCLUDE_LIST                1082
#define IDC_ADD_EXCLUSION_BTN           1083
#define IDC_REMOVE_EXCLUSION_BTN        1084
#define IDC_SUFFIXES_LABEL              1085
#define IDC_SUFFIX_LABEL_LARGE          1086
#define IDC_EXCLUSION_EDIT              1087
#define IDS_RNSPAGE_ACCESS              1088


#define IDS_ERR_CANT_VERIFY_CREDS       1091
#define IDS_ERR_CANT_SAVE_CREDS         1092
#define IDS_ERR_CANT_SAVE               1093
#define IDS_FTFILE_SUFFIX               1094
#define IDS_FTFILE_CSV_EXT              1095
#define IDS_LOG_TYPE                    1096
#define IDS_LOG_NOTES                   1097
#define IDS_LOG_FOR                     1098
#define IDS_LOG_WITH                    1099
#define IDS_FTFILE_FILTER               1100
#define IDS_VIEW                        1101
#define IDS_NETDOM_NO_FTINFOS           1102
#define IDS_NETDOM_CONFLICT_NAME        1103
#define IDS_NETDOM_CONFLICT             1104
#define IDS_NETDOM_TLNEX                1105
#define IDS_NETDOM_RANGE_ERROR          1106
#define IDS_NETDOM_NOT_FOREST           1107
#define IDS_NETDOM_NO_TRUST             1108
#define IDS_ERR_NOT_FORESTTRUST         1109
#define IDS_LOG_UNKNOWN                 1110
#define IDS_NETDOM_SID_CONFLICT_NAME    1111
#define IDS_NETDOM_SID_CONFLICT         1112
#define IDS_NETDOM_WRITE_FTINFO_FAILED  1113
#define IDS_NETDOM_ENABLE_DOMAIN        1114
#define IDS_NETDOM_DISABLE_DOMAIN       1115
#define IDS_NETDOM_EXCLUDED             1116
#define IDS_LOG_MATCHING_EXCLUSION      1117
#define IDS_NETDOM_MATCHING_TLNEX       1118
#define IDS_TWERR_CREATED_NO_NAMES      1119
#define IDS_TWERR_LOGIC                 1120
#define IDC_COMBO2                      1501
#define IDC_PATH                        1504
#define IDC_DS_INTERSITE_IN_CONNECTION  1505
#define IDC_RADIO_RESOURCE              1506
#define IDC_RADIO_ACCOUNT               1507
#define IDC_RADIO_UNIVERSAL             1508
#define IDC_UPDATE_LIST_CHECK           1509
#define IDC_IP_EDIT                     1511
#define IDC_OTHER_IP_BTN                1512
#define IDC_KEYWORDS_BTN                1514
#define IDC_EDIT_BTN                    1515
#define IDC_DELEGATION_CHK              1516
#define IDC_DOWNLEVEL_EDIT              1517
#define IDC_SERVER_EDIT                 1518
#define IDC_SITE_EDIT                   1519
#define IDC_SERVER_BTN                  1520
#define IDC_COMPAT_CHK                  1521
#define IDC_DOM_WARNING_STATIC          1523
#define IDC_WARNING_ICON                1524
#define IDC_DOMAIN_VERSION_STATIC       1525
#define IDC_UPN_SUFFIX_COMBO            1526
#define IDC_COMPUTER_EDIT               1527
#define IDC_MODE_GROUP                  1528
#define IDC_ERROR_MSG                   1529
#define IDC_DOWNLEVEL_NAME              1530
#define IDC_ACCOUNT_EDIT                1531
#define IDC_PW_EDIT                     1532
#define IDC_MSG                         1533
#define IDC_DISPLAYNAME_EDIT            1534
#define IDC_SHARED_FOLDER_EDIT          1535
#define IDC_PEER_LABEL                  1536
#define IDC_TRUST_DIR_EDIT              1537
#define IDC_GROUP_NOTE_STATIC           1538
#define IDC_TRUST_RESET_BTN             1539
#define IDC_SH_POB                      1540
#define IDC_SH_STATE                    1541
#define IDC_SH_STREET                   1542
#define IDC_SH_CITY                     1543
#define IDC_SH_ZIP                      1544
#define IDC_SH_COUNTRY                  1545
#define IDC_SH_DISPLAY_NAME_EDIT        1546
#define IDC_TRUST_TRANS_EDIT            1547
#define IDC_VERIFY_FRAME                1548
#define IDC_VERIFY_STATIC               1549
#define IDC_DUELLING_LB_OUT             1600
#define IDC_DUELLING_RB_ADD             1601
#define IDC_DUELLING_RB_REMOVE          1602
#define IDC_DUELLING_LB_IN              1603
#define IDC_PRI_GROUP_WARN_STATIC       1604
#define IDS_TITLE_GENERAL               2000
#define IDS_USER_TITLE_ORG              2001
#define IDS_USER_TITLE_ACCT             2002
#define IDS_USER_TITLE_MBR_OF           2003
#define IDS_TRUST_PARENTCHILD           2004
#define IDS_TITLE_ADDRESS               2005
#define IDS_TITLE_GROUP                 2006
#define IDS_TITLE_SITE                  2007
#define IDS_CLEAR_TEXT_PW               2008
#define IDS_TITLE_DS_SERVER             2009
#define IDS_TITLE_DS_CONNECTION         2010
#define IDS_RM_MBR_TITLE                2011
#define IDS_INVALID_MAIL_ADDR           2011
#define IDS_RM_MBR_MSG                  2012
#define IDS_REL_MIT                     2013
#define IDS_ERR_BAD_TRUST_PW            2014
#define IDS_TITLE_SUBNET                2015
#define IDS_PHONE_NOTES                 2016
#define IDS_OBJECT                      2017
#define IDS_INVALID_NAME_FORMAT         2018
#define IDS_MSG_TITLE                   2019
#define IDS_ERRMSG_NO_LONGER_EXISTS     2020
#define IDS_MANAGED_BY_TITLE            2021
#define IDS_REL_DCE                     2022
#define IDS_TRUST_DIR_INBOUND           2023
#define IDS_TRUST_DIR_OUTBOUND          2024
#define IDS_TRUST_DIR_BIDI              2025
#define IDS_TRUST_DISABLED              2026
#define IDS_ERRMSG_GROUP_DELETE         2027
#define IDS_ERR_CREATE_DIR              2028
#define IDS_ERR_DOMAIN_NOT_FOUND        2029
#define IDS_ERRMSG_INVALID_VOLUME_PATH  2030
#define IDS_ERRMSG_GROUP_CONSTRAINT     2033
#define IDS_TITLE_NTDSDSA_CONN          2034
#define IDS_TITLE_TRUST                 2040
#define IDS_COL_TITLE_DOMAIN            2041
#define IDS_COL_TITLE_RELATION          2042
#define IDS_COL_TITLE_TRANSITIVE        2043
#define IDS_COL_TITLE_ROUTING           2044
#define IDS_REL_PARENT                  2045
#define IDS_REL_CROSSLINK               2046
#define IDS_REL_EXTERNAL                2047
#define IDS_REL_CHILD                   2049
#define IDS_REL_INDIRECT                2050
#define IDS_ERRMSG_PW_MATCH             2051
#define IDS_ERRMSG_NO_DOMAIN            2052
#define IDS_ERRMSG_NO_ACCESS            2053
#define IDS_ERRMSG_INVALID_PATH         2054
#define IDS_MSG_REMOVE_CONFIRM          2061
#define IDS_REL_UNKNOWN                 2074
#define IDS_ERRMSG_NO_DC_RESPONSE       2076
#define IDS_RM_USR_FROM_GRP             2081
#define IDS_RM_USR_TITLE                2082
#define IDS_ROLE_WKS                    2083
#define IDS_ROLE_SVR                    2084
#define IDS_ERRMSG_INVALID_UNC_PATH     2090
#define IDS_ADS_ERROR_FORMAT            2091
#define IDS_MSG_FORCE_REMOVE_CONFIRM    2092
#define IDS_COL_TITLE_OBJNAME           2093
#define IDS_COL_TITLE_OBJFOLDER         2094
#define IDS_GRP_ALREADY_MEMBER          2095
#define IDS_RM_PRI_GRP                  2096
#define IDS_NT_GRP_TITLE                2097
#define IDS_NOTIFYTIMEOUT               2098
#define IDS_TITLE_DS_SITE_SETTINGS      2099
#define IDS_TITLE_DS_SITE_LICENSE_SETTINGS 2100
#define IDS_TITLE_OS                    2101
#define IDS_ERROR_NOSAMNAME             2102
#define IDS_MIXED_MODE                  2103
#define IDS_ERROR_GRP_SELF              2104
#define IDS_ERR_BAD_ADMIN_PW            2105
#define IDS_TRUST_LOGON_MSG             2106
#define IDS_ERR_NO_TRUST_CHECK          2107
#define IDS_ERR_TRUST_EXISTS            2108
#define IDS_ERR_TRUST_NOT_CREATED       2109
#define IDS_INVALID_SID                 2110
#define IDS_TITLE_NTFRS_REPLICA_SET     2111
#define IDS_TITLE_NTFRS_MEMBER          2112
#define IDS_ADMIN_NOCHANGE              2113
#define IDS_TITLE_NTFRS_SUBSCRIBER      2114
#define IDS_TITLE_FRS_CONNECTION        2115
#define IDS_LOGON_WKSTA                 2116
#define IDS_SHAREDNC_NONE               2117
#define IDS_SHAREDNC_NO_FROM_SERVER     2118
#define IDS_SHAREDNC_BOTH_GCS           2119
#define IDS_COL_TITLE_ERRORMSG          2200
#define IDS_COL_TITLE_PAGE              2201
#define IDS_STATUS_EXCEPTIONS           2202
#define IDS_STATUS_CONFLICT_GONE        2203
#define IDS_STATUS_NEW                  2204
#define IDS_ERR_EXCLUSION_EXISTS        2205
#define IDS_ERR_EXCLUSION_NOT_CHILD     2206
#define IDS_ERR_WRITE_FTI_TO_TDO        2207
#define IDS_ERR_EXCLUSION_CHILD         2208
#define IDC_HELP_BTN                    2209

#define IDS_RM_USR_PRI_GRP              2911
#define IDS_CONNECTION_KCC_GENERATED    3028
#define IDS_YES                         3029
#define IDS_NO                          3030
#define IDS_LOGON_HOURS                 3032
#define IDS_s_LOGON_HOURS_FOR           3033
#define IDS_SCHEDULE                    3034
#define IDS_s_SCHEDULE_FOR              3035
#define IDS_USER_TITLE_PROFILE          3036
#define IDS_CERTCOL_ISSUED_TO           3037
#define IDS_CERTCOL_ISSUED_BY           3038
#define IDS_CERTCOL_PURPOSES            3039
#define IDS_CERTCOL_EXP_DATE            3040
#define IDS_NOT_AVAILABLE               3041
#define IDS_ANY                         3042
#define IDS_CONFIRM_DELETE_CERT         3043
#define IDS_REMOVE_CERT                 3044
#define IDS_CERT_SAVE_FILTER            3045
#define IDS_OPEN_FILE_DLG_TITLE         3046
#define IDS_SAVE_FILE_DLG_TITLE         3047
#define IDS_COPY_TO_FILE                3048
#define IDS_COMMIT_CERT_STORE_CHANGES   3049
#define IDS_UNKNOWN_CERT_FILE_TYPE      3050
#define IDS_USER_TITLE_PUBLISHED_CERTS  3051
#define IDS_DUPLICATE_CERT              3052
#define IDS_ADD_FROM_STORE              3053
#define IDS_NOTIFYFAILURE               3054
#define IDS_CANT_OPEN_STORE             3055
#define IDS_CANT_SAVE_STORE             3056
#define IDS_SITELINK_NEEDS_TWO_SITES    3057
#define IDS_SITELINKBRIDGE_NEEDS_TWO_SITELINKS 3058
#define IDS_CONFIRM_DELETE_CERTS        3059
#define IDS_ERR_DNLEVELNAME_MISSING     3060
#define IDS_CANT_OPEN_STORE_OPEN_READ_ONLY 3061
#define IDS_FPNWPAGE_TITLE              3070
#define IDS_FPNWLOGON_NETWORKADDR       3071
#define IDS_FPNWLOGON_NODEADDR          3072
#define IDS_ALL_NODES                   3073
#define IDS_ERRMSG_NETWORKADDR_REQUIRED 3074
#define IDS_FAILED_TO_LOADFPNWCLNTDLL   3075
#define IDS_FAILED_TO_GETNWUSERINFO     3076
#define IDS_FAILED_TO_GETNWLOGINSCRIPTFILE 3077
#define IDS_FAILED_TO_GETUSERPARMS      3078
#define IDS_FAILED_TO_ENABLE_NWUSER     3079
#define IDS_FAILED_TO_UPDATE_NWPARMS    3080
#define IDS_FAILED_TO_WRITE_NWPARMS     3081
#define IDS_FAILED_TO_UPDATE_LOGINSCRIPTS 3082
#define IDS_INVALID_RELPATH             3083
#define IDS_RPC                         3084
#define IDS_INVALID                     3085
#define IDS_MULTIVALUED                 3086
#define IDS_COMPUTER_DELEGATE           3088
#define IDS_ERROR_VIEW_PERMISSIONS      3089
#define IDS_MSG_USER_NOT_PRESENT        3090
#define IDS_FIRST_COUNTRY_CODE          3091
#define IDS_LAST_COUNTRY_CODE           3092
#define IDS_TRUST_DIR_INBOUND_SHORTCUT  3093
#define IDS_TRUST_DIR_OUTBOUND_SHORTCUT 3094
#define IDS_DEFAULT_ERROR_TEXT          3095
#define IDS_LOCAL_GROUP_ONLY            3096
#define IDS_VIEW_SCHEDULE               3097
#define IDS_CONNECTION_WARNING_MARK     3098
#define IDS_CONNECTION_WARNING_CANNOT_MARK 3099
#define IDS_HOME_DIR_EXISTS             3100
#define IDS_CANT_READ_HOME_DIR_SID      3101
#define IDS_TRUST_BROKEN                3102
#define IDS_SC_RESET_FAILED             3103
#define IDS_HOME_DIR_CREATE_FAILED      3104
#define IDS_SC_QUERY_FAILED             3105
#define IDS_ERR_FINDING_UPN             3106
#define IDI_MEMBER                      3108
#define IDS_USG_MIXED_WARNING           3109
#define IDS_OUT_OF_RANGE                3207
#define IDS_DEFAULT_ERROR_MSG           3208
#define IDS_ERR_CANT_TRUST_SELF         3209
#define IDS_TDO_NOT_FOUND               3210
#define IDC_TRANS_GROUPBOX              3211
#define IDC_TRANS_YES_RADIO             3212
#define IDC_TRANS_NO_RADIO              3213
#define IDC_TRANS_STATIC                3214
#define IDS_MULTI_FAILURE_CAPTION       3215
#define IDS_WARN_NO_GC_FOUND            3216
#define IDS_ALL_USERS_GIVEN_FULL_CONTROL 3227
#define IDS_USER_GIVEN_FULL_CONTROL     3228
#define IDS_FIRST_USER_OWNER_ALL_FULL_CONTROL 3229
#define IDS_WARN_UPN_GC_FOUND_ERROR     3230
#define IDD_TRUSTWIZ_INTRO_PAGE         3231
#define IDD_TRUSTWIZ_NAME_PAGE          3232
#define IDD_TRUSTWIZ_CREDS_PAGE         3233
#define IDD_TRUSTWIZ_PW_MATCH_PAGE      3234
#define IDD_TRUSTWIZ_WIN_OR_MIT_PAGE    3235
#define IDD_TRUSTWIZ_DIRECTION_PAGE     3236
#define IDD_TRUSTWIZ_BIDI_PAGE          3237
#define IDD_TRUSTWIZ_EXTERN_OR_FOREST_PAGE 3238
#define IDC_ENABLE_BTN                  3239
#define IDD_TRUSTWIZ_STATUS_PAGE        3240
#define IDD_TRUSTWIZ_SUMMARY_PAGE       3241
#define IDD_TRUSTWIZ_VERIFY_OUTBOUND_PAGE 3242
#define IDD_TRUSTWIZ_VERIFY_STATUS_PAGE 3243
#define IDD_TRUSTWIZ_SUFFIX_PAGE        3244
#define IDD_TRUSTWIZ_COMPLETE_OK_PAGE   3245
#define IDD_TRUSTWIZ_DONE_NO_OP_PAGE    3246
#define IDD_TRUSTWIZ_DONE_ERRORS_PAGE   3247
#define IDD_TRUSTWIZ_CONFLICTS_POPUP    3248
#define IDS_TW_NAME_TITLE               3249
#define IDS_TW_NAME_SUBTITLE            3250
#define IDB_TW_BANNER16                 3251
#define IDB_TW_BANNER256                3252
#define IDB_TW_WATER16                  3253
#define IDB_TW_WATER256                 3254
#define IDC_COMPLETE_SUBMSG             3255
#define IDC_TW_INTRO_RICHEDIT           3256
#define IDC_STATIC                      3257
#define IDC_BIG_TITLE                   3258
#define IDS_TW_TITLE                    3259
#define IDC_BIG_COMPLETING              3260
#define IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE 3261
#define IDC_MIT_TRUST_RADIO             3262
#define IDC_WIN_TRUST_RADIO             3263
#define IDS_TW_TRANS_TITLE              3264
#define IDS_TW_TRANS_SUBTITLE           3265
#define IDS_TW_PWMATCH_TITLE            3266
#define IDS_TW_PWMATCH_SUBTITLE         3267
#define IDS_TW_CREDS_TITLE              3268
#define IDS_TW_CREDS_SUBTITLE_OTHER     3269
#define IDS_TW_WIN_RADIO_LABEL          3270
#define IDS_TW_WINORMIT_SUBTITLE        3271
#define IDC_TW_CREDS_PROMPT             3272
#define IDS_ROUTING_PAGE_TITLE          3273
#define IDS_TW_TYPE_TITLE               3274
#define IDC_TW_BIDI_RADIO               3275
#define IDC_TW_OUTBOUND_RADIO           3276
#define IDC_TW_INBOUND_RADIO            3277
#define IDS_TW_DIRECTION_TITLE          3278
#define IDS_TW_DIRECTION_SUBTITLE       3279
#define IDC_YES_RADIO                   3280
#define IDC_NO_RADIO                    3281
#define IDS_TW_BIDI_SUBTITLE            3282
#define IDS_TW_BIDI_TITLE               3283
#define IDS_TW_BIDI_SUBTITLE_FOREST     3284
#define IDD_TRUSTWIZ_FAILURE_PAGE       3285
#define IDC_BIG_CANNOT_CONTINUE         3286
#define IDC_FAILPAGE_EDIT1              3287
#define IDC_FAILPAGE_EDIT2              3288
#define IDS_FMT_STRING_ERROR_MSG        3289
//#define         3290
//#define           3291
#define IDI_BULLET                      3292
#define IDS_TW_BIDI_SUBTITLE_REALM      3293
#define IDD_TRUSTWIZ_SELECTIONS         3294
#define IDS_TW_SELECTION_EXISTS         3295
#define IDC_PROGRESS                    3296
#define IDS_TW_SELECTIONS_TITLE         3297
#define IDS_TW_SELECTIONS_SUBTITLE      3298
#define IDS_TW_THIS_DOMAIN              3299
#define IDS_TW_SPECIFIED_DOMAIN         3300
#define IDS_TW_TRUST_TYPE_PREFIX        3301
#define IDS_TW_DIRECTION_PREFIX         3302
#define IDS_WZERR_TYPE_MIT              3303
#define IDS_WZERR_TYPE_UNEXPECTED       3304
#define IDS_WZERR_TYPE_DELETE           3305
#define IDC_WZ_PROGRESS_MSG             3306
#define IDS_WZ_PROGRESS_MSG             3307
#define IDC_CREDMAN                     3308
#define IDS_TW_CREDS_SUBTITLE_LOCAL     3309
#define IDC_CRED_DOMAIN                 3310
#define IDS_CRED_LOCAL_DOMAIN           3311
#define IDS_CRED_OTHER_DOMAIN           3312
#define IDS_CRED_ADMIN_OTHER_PROMPT     3313
#define IDS_CRED_ADMIN_LOCAL_PROMPT     3314
#define IDS_CRED_USER_OTHER_PROMPT      3315
#define IDS_TW_CREDS_SUBTITLE_OTHER_NONADMIN 3316
#define IDC_EXTERNAL_RADIO              3316
#define IDC_FOREST_RADIO                3317
#define IDW_TW_TYPE_TITLE               3318
#define IDW_TW_EXORFOR_SUBTITLE         3319
#define IDD_TRUSTWIZ_TRANSITIVITY_PAGE  3320
#define IDS_ERR_DOMAIN_NOT_FOUND1       3321
#define IDS_ERR_DOMAIN_NOT_FOUND2       3322
#define IDS_WZERR_TYPE_NOT_FOUND        3323
#define IDS_WZERR_TYPE_WIN              3324
#define IDS_TWERR_ALREADY_EXISTS        3325
#define IDS_TWERR_NO_CHANGES            3326
#define IDS_TWERR_NOT_TO_SELF1          3327
#define IDS_TWERR_NOT_TO_SELF2          3328
#define IDS_TWERR_CANT_CHANGE           3329
#define IDS_TW_VERIFY_INBOUND_TITLE     3330
#define IDS_TW_VERIFY_SUBTITLE          3331
#define IDS_VERIFY_TCV_FAILED           3332
#define IDS_VERIFY_TCV_LOGSRV           3333
#define IDS_VERIFY_DOING_RESET          3334
#define IDS_VERIFY_TCV_NSUPP            3335
#define IDS_VERIFY_RESET_FAILED         3336
#define IDS_TW_CREATED_OK               3337
#define IDS_TW_VERIFIED_OK              3338
#define IDS_TW_VERIFIED_BAD             3339
#define IDS_TW_VERIFY_ERR_INBOUND       3340
#define IDS_TRUST_VERIFY_OUTBOUND       3341
#define IDS_TRUST_VERIFY_INBOUND        3342
#define IDS_TW_VERIFY_ERR_OUTBOUND      3343
#define IDS_LOG_EXCLUSION               3344
#define IDS_TW_SEL_ACTION               3345
#define IDS_TW_ATTR_XFOREST             3346
#define IDS_REL_FOREST                  3347
#define IDC_WARN_CREATE_STATIC          3348
#define IDS_TW_STATUS_TITLE             3349
#define IDS_TW_STATUS_SUBTITLE          3350
#define IDS_TW_SUFFIX_TITLE             3351
#define IDS_TW_SUFFIX_SUBTITLE          3352
#define IDC_TW_SUFFIX_LABEL             3353
#define IDS_COLLISIONS_MSG              3354
#define IDS_DNT_MSG_TITLE               3355
#define IDS_LOGFILE_CREATE_FAILED       3356
#define IDS_FT_NAMES_PREFIX             3357
#define IDS_WZ_TRANS_YES                3358
#define IDS_WZ_TRANS_NO                 3359
#define IDC_DISABLE_BTN                 3360
#define IDC_SUFFIXES_STATIC             3361
#define IDS_COL_TITLE_SUFFIX            3362
#define IDS_COL_TITLE_STATUS            3363
#define IDC_SAVE_FOREST_NAMES_STATIC    3364
#define IDC_SAVE_FOREST_NAMES_BTN       3365
#define IDS_ROUTING_ERR_NO_DC           3366
#define IDC_SUFFIXES_STATIC_BIG         3367
#define IDS_ROUTING_ENABLED             3368
#define IDS_ROUTING_DISABLED            3369
#define IDS_ROUTING_CONFLICT            3370
#define IDS_ERR_FT_CONTACT_DOMAIN       3371
#define IDS_ERR_FT_TRUST_MISSING        3372
#define IDS_NO_FTINFO                   3373
#define IDS_LOG_ADMIN_DISABLED          3374
#define IDS_LOG_NEW_DISABLED            3375
#define IDS_LOG_NAME_SUFFIX             3376
#define IDS_LOG_DOM_DNS_NAME            3377
#define IDS_LOG_DOM_FLAT_NAME           3378
#define IDS_LOG_STATUS                  3379
#define IDS_LOG_PREFIX                  3380
#define IDS_LOG_ENABLED                 3381
#define IDS_LOG_CONFLICT                3382
#define IDS_LOG_HAS_EXCLUSION           3383
#define IDS_LOG_SID                     3384
#define IDS_ERR_READ_FTINFO             3385
#define IDS_TLNEDIT_NAME_COL            3386
#define IDS_TLNEDIT_STATUS_COL          3387
#define IDS_ROUTING_EXCEPT_ENABLE       3388
#define IDS_ROUTING_EXCEPT_DISABLE      3389

#define IDS_MSG_NO_DOWNLEVEL_PROPERTIES 3400
#define IDS_MSG_MEMBER_ALREADY_GONE     3401
#define IDS_MSG_MEMBER_ALREADY_GONE2    3402
#define IDS_WARN_ACCESS_TO_GC_DENIED    3403
#define IDS_SAMNAME_ILLEGAL             3404
#define IDS_LOGINNAME_ILLEGAL           3405
#define IDS_GROUP_SAMNAME_ILLEGAL       3406
#define IDC_WARNING_STATIC              3407
#define IDD_COMPUTER_DELEGATION         3420
#define IDC_NO_TRUST_RADIO              3421
#define IDC_ANY_SERVICE_RADIO           3422
#define IDC_SPECIFIED_SERVICES_RADIO    3423
#define IDC_KERBEROS_ONLY_RADIO         3424
#define IDC_ANY_RADIO                   3425
#define IDC_SERVICES_LIST               3426
#define IDC_ADD_BUTTON                  3427
#define IDC_REMOVE_BUTTON               3428
#define IDS_TITLE_DELEGATION            3429
#define IDC_LIST_STATIC                 3430
#define IDD_SELECT_SERVICES_DIALOG      3440
#define IDC_USERS_COMPUTERS_BUTTON      3441
#define IDC_SELECT_ALL_BUTTON           3443
#define IDS_SERVICE_TYPE_COLUMN         3450
#define IDS_USER_OR_COMPUTER_COLUMN     3451
#define IDS_PORT_COLUMN                 3452
#define IDS_SERVICE_NAME_COLUMN         3453
#define IDS_DOMAIN_COLUMN               3454
#define IDS_NO_TRUST_USER_RADIO         3455
#define IDS_ANY_SERVICE_USER_RADIO      3456
#define IDS_SPECIFIED_SERVICES_USER_RADIO 3457
#define IDS_ERROR_MUST_HAVE_SPN         3458
#define IDC_NO_OBJECT_WITH_SPN          3459


// NOTE: strings in the range 3999 to 4400 are reserved for the
// ISO-3166 country code strings.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\proppage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proppage.cxx
//
//  Contents:   CDsPropPagesHost, the class that exposes IShellExtInit and
//              IShellPropSheetExt
//
//  History:    24-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include <propcfg.h>
#include <pcrack.h>

CLIPFORMAT g_cfDsObjectNames = 0;
CLIPFORMAT g_cfDsDispSpecOptions = 0;
CLIPFORMAT g_cfShellIDListArray = 0;
CLIPFORMAT g_cfMMCGetNodeType = 0;
CLIPFORMAT g_cfDsPropCfg = 0;
CLIPFORMAT g_cfDsSelList = 0;
CLIPFORMAT g_cfDsMultiSelectProppages = 0;
//CLIPFORMAT g_cfMMCGetCoClass = 0;

static void ToggleMVDefaultBtn(HWND hDlg, BOOL fOK);

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::CDsPropPagesHost
//
//-----------------------------------------------------------------------------
CDsPropPagesHost::CDsPropPagesHost(PDSCLASSPAGES pDsPP) :
    m_pDsPPages(pDsPP),
    m_pDataObj(NULL),
    m_hNotifyObj(NULL),
    m_uRefs(1)
{
    TRACE2(CDsPropPagesHost,CDsPropPagesHost);
#ifdef _DEBUG
    strcpy(szClass, "CDsPropPagesHost");
#endif
    m_ObjMedium.tymed = TYMED_NULL;
    m_ObjMedium.hGlobal = NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::~CDsPropPagesHost
//
//-----------------------------------------------------------------------------
CDsPropPagesHost::~CDsPropPagesHost()
{
    TRACE(CDsPropPagesHost,~CDsPropPagesHost);
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }
    if (m_ObjMedium.tymed != TYMED_NULL)
    {
        ReleaseStgMedium(&m_ObjMedium);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IShellExtInit::Initialize
//
//  Synopsis:   
//
//  Arguments:  
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::Initialize(LPCITEMIDLIST, LPDATAOBJECT pDataObj,
                             HKEY)
{
    TRACE2(CDsPropPagesHost,Initialize);

    if (IsBadReadPtr(pDataObj, sizeof(LPDATAOBJECT)))
    {
        DBG_OUT("Failed because we don't have a data object");
        return E_INVALIDARG;
    }

    if (m_pDataObj)
    {
        m_pDataObj->Release();
        m_pDataObj = NULL;
    }

    // Hang onto the IDataObject we are being passed.

    m_pDataObj = pDataObj;
    if (m_pDataObj)
    {
        m_pDataObj->AddRef();
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IShellExtInit::AddPages
//
//  Synopsis:   
//
//  Arguments:  
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    TRACE(CDsPropPagesHost,AddPages);

    CWaitCursor cWait;

    HRESULT hr = S_OK;
    HPROPSHEETPAGE hPage;
    PWSTR pwzObjADsPath, pwzClass;
    DWORD i;
    BOOL fPageCreated = FALSE;

    //
    // Get the unique identifier for the notify object from the data object
    //
    FORMATETC mfmte = {g_cfDsMultiSelectProppages, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM objMedium;
    LPWSTR lpszUniqueID = NULL;
    LPWSTR lpszTempUniqueID = NULL;

    hr = m_pDataObj->GetData(&mfmte, &objMedium);
    if (SUCCEEDED(hr))
    {
      lpszTempUniqueID = (LPWSTR)objMedium.hGlobal;
      if (lpszTempUniqueID == NULL)
      {
        DBG_OUT("Unique identifier not available for property pages.");
        ReleaseStgMedium(&objMedium);
        return ERROR_INVALID_DATA;
      }

      size_t iLength = wcslen(lpszTempUniqueID);
      lpszUniqueID = new WCHAR[iLength + 1];
      wcscpy(lpszUniqueID, lpszTempUniqueID);

      GlobalFree(objMedium.hGlobal);
    }
    //
    // Retrieve the DS object names
    //
    FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    LPDSOBJECTNAMES pDsObjectNames;
    //
    // Get the path to the DS object from the data object.
    // Note: This call runs on the caller's main thread. The pages' window
    // procs run on a different thread, so don't reference the data object
    // from a winproc unless it is first marshalled on this thread.
    //
    hr = m_pDataObj->GetData(&fmte, &m_ObjMedium);
    CHECK_HRESULT(hr, return hr);

    pDsObjectNames = (LPDSOBJECTNAMES)m_ObjMedium.hGlobal;

    if (pDsObjectNames->cItems < 1)
    {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      return ERROR_INVALID_DATA;
    }

    pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                      pDsObjectNames->aObjects[0].offsetName);
    pwzClass = (PWSTR)ByteOffset(pDsObjectNames,
                                 pDsObjectNames->aObjects[0].offsetClass);
    dspDebugOut((DEB_ITRACE, "Object name: %ws, Class: %ws\n", pwzObjADsPath,
                 pwzClass));

    // Crack the name to get the server name and use that to create a
    // CDSBasePathsInfo that can be used by the pages

    CDSBasePathsInfo* pBasePathsInfo = 0;
    CPathCracker pathCracker;
    hr = pathCracker.Set(pwzObjADsPath, ADS_SETTYPE_FULL);
    if (SUCCEEDED(hr))
    {
       CComBSTR sbstrServer;
       pBasePathsInfo = new CDSBasePathsInfo();
       if (pBasePathsInfo)
       {
          hr = pathCracker.Retrieve(ADS_FORMAT_SERVER, &sbstrServer);
          if (SUCCEEDED(hr))
          {
             hr = pBasePathsInfo->InitFromName(sbstrServer);
          }
          else
          {
             // The shell calls the prop-page without a server in the path.
             //
             hr = pBasePathsInfo->InitFromName(NULL);
          }
       }
    }

    if (FAILED(hr) || !pBasePathsInfo)
    {
       DBG_OUT("Failed to create/initialize the base paths info for the pages");
       return ERROR_INVALID_DATA;
    }

    //
    // Loop to see if any pages will be created.
    //
    for (i = 0; i < m_pDsPPages->cPages; i++)
    {
        PDSPAGE pDsPage = m_pDsPPages->rgpDsPages[i];

        if ((pDsPage->dwFlags & DSPROVIDER_ADVANCED) &&
            !(pDsObjectNames->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED))
        {
            // The page should only be displayed if in advanced mode.
            //
            continue;
        }

        if (pDsPage->nCLSIDs)
        {
            // Only show the page if there is a match on the snapin (namespace)
            // CLSID.
            //
            BOOL fFound = FALSE;
            for (DWORD j = 0; j < pDsPage->nCLSIDs; j++)
            {
                if (IsEqualCLSID(pDsPage->rgCLSID[j],
                                 pDsObjectNames->clsidNamespace))
                {
                    fFound = TRUE;
                }
            }
            if (!fFound)
            {
                continue;
            }
        }

        fPageCreated = TRUE;
    }

    if (fPageCreated)
    {
      //
      // At least one page will be created, so contact the notification
      // object. If it doesn't already exist, it will be created.
      //
      if (lpszUniqueID == NULL)
      {
        //
        // Copy the path to be used as the unique ID for the page
        // This should only be done if the DataObject does not support g_cfDsMultiSelectProppages
        //
        size_t iLength = wcslen(pwzObjADsPath);
        lpszUniqueID = new WCHAR[iLength + 1];
        wcscpy(lpszUniqueID, pwzObjADsPath);
      }
      hr = ADsPropCreateNotifyObj(m_pDataObj, lpszUniqueID, &m_hNotifyObj);
      delete[] lpszUniqueID;
      CHECK_HRESULT(hr, return hr);
    }

    //
    // Create each page.
    //
    for (i = 0; i < m_pDsPPages->cPages; i++)
    {
        PDSPAGE pDsPage = m_pDsPPages->rgpDsPages[i];

        if ((pDsPage->dwFlags & DSPROVIDER_ADVANCED) &&
            !(pDsObjectNames->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED))
        {
            // The page should only be displayed if in advanced mode.
            //
            continue;
        }

        if (pDsPage->nCLSIDs)
        {
            // Only show the page if there is a match on the snapin (namespace)
            // CLSID.
            //
            BOOL fFound = FALSE;
            for (DWORD j = 0; j < pDsPage->nCLSIDs; j++)
            {
                if (IsEqualCLSID(pDsPage->rgCLSID[j],
                                 pDsObjectNames->clsidNamespace))
                {
                    fFound = TRUE;
                }
            }
            if (!fFound)
            {
                continue;
            }
        }

        // Call the page's creation function.
        //
        hr = (*pDsPage->pCreateFcn)(pDsPage, m_pDataObj, pwzObjADsPath,
                                    pwzClass, m_hNotifyObj,
                                    pDsObjectNames->aObjects[0].dwFlags,
                                    pBasePathsInfo,
                                    &hPage);
        if (hr == S_FALSE)
        {
            // If the page doesn't want to be shown, it should return S_FALSE.
            //
            continue;
        }
        if (hr == HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP))
        {
            break;
        }
        CHECK_HRESULT(hr, continue);

        // Pass the page handle back to the app wanting to post the prop sheet.
        //
        if (!(*pAddPageProc)(hPage, lParam))
        {
            CHECK_HRESULT(E_FAIL, return E_FAIL);
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IShellExtInit::ReplacePage
//
//  Synopsis:   Unused.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::ReplacePage(UINT,
                              LPFNADDPROPSHEETPAGE,
                              LPARAM)
{
    TRACE(CDsPropPagesHost,ReplacePage);
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Multi-valued attribute editing.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttrDlg
//
//  Purpose:    Read, edit, and write a multi-valued, string property. This is
//              the dialog that contains the CMultiStringAttr class controls.
//
//-----------------------------------------------------------------------------
CMultiStringAttrDlg::CMultiStringAttrDlg(CDsPropPageBase * pPage) :
    m_pPage(pPage),
    m_MSA(pPage)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr name.
//              [pAttrInfo]  - place to store the values.
//              [nLimit]     - the max number of values (zero means no limit).
//              [fCommaList] - if TRUE, pAttrInfo is a single-valued, comma
//                             delimited list.
//-----------------------------------------------------------------------------
HRESULT
CMultiStringAttrDlg::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                          BOOL fWritable, int nLimit, BOOL fCommaList, BOOL fMultiselectPage)
{
    return m_MSA.Init(pAttrMap, pAttrInfo, fWritable, nLimit, fCommaList, fMultiselectPage);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT CMultiStringAttrDlg::Write(PADS_ATTR_INFO pAttrInfo)
{
    return m_MSA.Write(pAttrInfo);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::Edit
//
//  Synopsis:   Post the edit dialog.
//
//-----------------------------------------------------------------------------
INT_PTR CMultiStringAttrDlg::Edit(void)
{
  INT_PTR nRet;

  nRet = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_MULTI_VALUE),
                        m_pPage->GetHWnd(), (DLGPROC)StaticDlgProc, (LPARAM)this);
  if (IDOK == nRet)
  {
    EnableWindow(GetDlgItem(GetParent(m_pPage->GetHWnd()), IDOK), TRUE);

    m_pPage->SetDirty();
  }

  return nRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::StaticDlgProc
//
//  Synopsis:   The static dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CMultiStringAttrDlg::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                   LPARAM lParam)
{
    CMultiStringAttrDlg * pMSAD = (CMultiStringAttrDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pMSAD = (CMultiStringAttrDlg *)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMSAD);
    }

    if (pMSAD)
    {
        return pMSAD->MultiValDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttrDlg::MultiValDlgProc
//
//  Synopsis:   The instancce dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
BOOL CALLBACK
CMultiStringAttrDlg::MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam)
{
    CMultiStringAttrDlg * pMSAD = (CMultiStringAttrDlg *)GetWindowLongPtr(hDlg, DWLP_USER);
    CMultiStringAttr * pMSA = &pMSAD->m_MSA;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoDlgInit(hDlg);

    case WM_COMMAND:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoCommand(hDlg,
                               GET_WM_COMMAND_ID(wParam, lParam),
                               GET_WM_COMMAND_CMD(wParam, lParam));

    case WM_NOTIFY:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoNotify(hDlg, (NMHDR *)lParam);

    case WM_HELP:
        LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
        dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                     pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
        if (pHelpInfo->iCtrlId < 1)
        {
            return 0;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttr
//
//  Purpose:    Read, edit, and write a multi-valued, string property.
//
//-----------------------------------------------------------------------------
CMultiStringAttr::CMultiStringAttr(CDsPropPageBase * pPage) :
    m_pPage(pPage),
    m_pAttrLDAPname(NULL),
    m_nMaxLen(0),
    m_nCurDefCtrl(IDC_CLOSE),
    m_fListHasSel(FALSE),
    m_nLimit(0),
    m_cValues(0),
    m_fWritable(TRUE),
    m_fCommaList(FALSE),
    m_fDirty(FALSE),
    m_fAppend(FALSE)
{
    m_AttrInfo.pADsValues = NULL;
    m_AttrInfo.dwNumValues = 0;
    m_AttrInfo.pszAttrName = NULL;
}

CMultiStringAttr::~CMultiStringAttr()
{
    ClearAttrInfo();
    DO_DEL(m_pAttrLDAPname);
}

void CMultiStringAttr::ClearAttrInfo(void)
{
    for (DWORD i = 0; i < m_AttrInfo.dwNumValues; i++)
    {
        delete [] m_AttrInfo.pADsValues[i].CaseIgnoreString;
    }
    if (m_AttrInfo.pADsValues)
    {
        delete [] m_AttrInfo.pADsValues;
    }
    m_AttrInfo.pADsValues = NULL;
    m_AttrInfo.dwNumValues = 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr name.
//              [pAttrInfo]  - place to store the values.
//              [nLimit]     - the max number of values (zero means no limit).
//              [fCommaList] - if TRUE, pAttrInfo is a single-valued, comma
//                             delimited list.
//-----------------------------------------------------------------------------
HRESULT
CMultiStringAttr::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                       BOOL fWritable, int nLimit, BOOL fCommaList, BOOL fAppend)
{
    if (!AllocWStr(pAttrMap->AttrInfo.pszAttrName, &m_pAttrLDAPname))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    m_nLimit = nLimit;
    m_fCommaList = fCommaList;
    m_fWritable = fWritable;
    m_fAppend = fAppend;

    m_nMaxLen = pAttrMap->nSizeLimit;

    m_AttrInfo.dwADsType = pAttrMap->AttrInfo.dwADsType;

    if (NULL == pAttrInfo)
    {
        return S_OK;
    }

    DWORD cItems = 0;
    PWSTR pwzComma, pwzCur;

    if (fCommaList)
    {
        pwzCur = pAttrInfo->pADsValues->CaseIgnoreString;
        //
        // Count the number of elements. This count includes empty elements,
        // e.g. leading, trailing, or adjacent commas.
        //
        while (*pwzCur)
        {
            cItems++;
            pwzComma = wcschr(pwzCur, L',');
            if (pwzComma)
            {
                pwzCur = pwzComma + 1;
            }
            else
            {
                break;
            }
        }
    }
    else
    {
        cItems = pAttrInfo->dwNumValues;
    }

    m_AttrInfo.pADsValues = new ADSVALUE[cItems];

    CHECK_NULL_REPORT(m_AttrInfo.pADsValues, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

    for (DWORD i = 0, j = 0; i < cItems; i++)
    {
        if (fCommaList)
        {
            if (i == 0)
            {
                pwzCur = wcstok(pAttrInfo->pADsValues->CaseIgnoreString, L",\0");
            }
            else
            {
                pwzCur = wcstok(NULL, L",\0");
            }
            if (!pwzCur)
            {
                break;
            }
            if (!*pwzCur)
            {
                // Skip empty elements.
                //
                continue;
            }
            if (!AllocWStr(pwzCur, &m_AttrInfo.pADsValues[j].CaseIgnoreString))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            dspAssert(i == j);

            if (!AllocWStr(pAttrInfo->pADsValues[j].CaseIgnoreString,
                           &m_AttrInfo.pADsValues[j].CaseIgnoreString))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
        }
        m_AttrInfo.pADsValues[j].dwType = m_AttrInfo.dwADsType;
        m_AttrInfo.dwNumValues++;
        j++;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT CMultiStringAttr::Write(PADS_ATTR_INFO pAttrInfo)
{
    pAttrInfo->dwADsType = m_AttrInfo.dwADsType;
    pAttrInfo->dwNumValues = 0;

    if (!m_fWritable)
    {
        return ADM_S_SKIP;
    }

    if (m_AttrInfo.dwNumValues)
    {
        PADSVALUE pADsValues;

        int nValues = (m_fCommaList) ? 1 : m_AttrInfo.dwNumValues;

        pADsValues = new ADSVALUE[nValues];

        CHECK_NULL_REPORT(pADsValues, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

        if (m_fAppend)
        {
          pAttrInfo->dwControlCode = ADS_ATTR_APPEND;
        }
        else
        {
          pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        pAttrInfo->pADsValues = pADsValues;

        if (m_fCommaList)
        {
            // For simplicity, just go ahead and allocate the max. That is,
            // there are m_AttrInfo.dwNumValues values each which can be a max
            // length of m_nMaxLen. The comma separator is included in the
            // count.
            //
            pADsValues->CaseIgnoreString = new WCHAR[(m_AttrInfo.dwNumValues * (m_nMaxLen + 1)) + 1];
            CHECK_NULL_REPORT(pADsValues->CaseIgnoreString, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

            wcscpy(pADsValues->CaseIgnoreString,
                   m_AttrInfo.pADsValues[0].CaseIgnoreString);

            for (DWORD i = 1; i < m_AttrInfo.dwNumValues; i++)
            {
                wcscat(pADsValues->CaseIgnoreString, L",");
                wcscat(pADsValues->CaseIgnoreString,
                       m_AttrInfo.pADsValues[i].CaseIgnoreString);
            }
            pADsValues->dwType = m_AttrInfo.dwADsType;
            pAttrInfo->dwNumValues = 1;
        }
        else
        {
            for (DWORD i = 0; i < m_AttrInfo.dwNumValues; i++)
            {
                PWSTR pwz;
                if (!AllocWStr(m_AttrInfo.pADsValues[i].CaseIgnoreString, &pwz))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
                    return E_OUTOFMEMORY;
                }
                pADsValues[i].dwType = m_AttrInfo.dwADsType;
                pADsValues[i].CaseIgnoreString = pwz;
                pAttrInfo->dwNumValues++;
            }
        }
    }
    else
    {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::SetDirty
//
//  Synopsis:   Marks the page dirty and enables the OK button
//
//-----------------------------------------------------------------------------
void CMultiStringAttr::SetDirty(HWND hDlg)
{
  m_fDirty = TRUE;
  EnableWindow(GetDlgItem(hDlg, IDC_CLOSE), m_fDirty);
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::EnableControls
//
//  Synopsis:   Enable or disable all of the controls.
//
//-----------------------------------------------------------------------------
void
CMultiStringAttr::EnableControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_LIST), fEnable);
    if (!fEnable)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
        m_fListHasSel = FALSE;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_CLOSE), IsDirty());
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::DoDlgInit
//
//  Synopsis:   WM_INITDIALOG code.
//
//-----------------------------------------------------------------------------
BOOL
CMultiStringAttr::DoDlgInit(HWND hDlg)
{
    LPTSTR ptz;
    HRESULT hr = S_OK;
    LONG i;
    HWND hList;
    LV_ITEM lvi;
    /*
    //
    // Create the dialog caption: "<obj-name> - <attribute-name>"
    //
    TCHAR szCaption[MAX_PATH];
    if (!UnicodeToTchar(m_pPage->GetObjRDName(), &ptz))
    {
        CHECK_WIN32_REPORT(ERROR_NOT_ENOUGH_MEMORY, hDlg, return FALSE);
    }
    _tcscpy(szCaption, ptz);
    delete ptz;
    _tcscat(szCaption, TEXT(" - "));
    int len = _tcslen(szCaption);
    */

    // Get the attribute "friendly" name.
    //
    WCHAR wzBuf[MAX_PATH + 1];
    IDsDisplaySpecifier * pDispSpec;

    hr = m_pPage->GetIDispSpec(&pDispSpec);

    CHECK_HRESULT_REPORT(hr, hDlg, return 0);

    //
    // If this is multi-select it must be a homogenous selection so if 
    // m_pPage->GetObjClass() returns NULL then get the class from the data object
    //
    LPCWSTR lpszClassName = m_pPage->GetObjClass();
    if (lpszClassName == NULL)
    {
      //
      // For the retrieval of the DS Object names
      //
      FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
      STGMEDIUM objMedium;
      hr = m_pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
      CHECK_HRESULT(hr, return FALSE);

      LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

      //
      // Get the objects class 
      //
      lpszClassName = (PWSTR)ByteOffset(pDsObjectNames,
                                        pDsObjectNames->aObjects[0].offsetClass);

    }
    hr = pDispSpec->GetFriendlyAttributeName(lpszClassName,
                                             m_pAttrLDAPname, wzBuf, MAX_PATH);
    CHECK_HRESULT_REPORT(hr, hDlg, return 0);

    if (!UnicodeToTchar(wzBuf, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, hDlg);
        return 0;
    }
    //_tcscat(szCaption, ptz);
    SetWindowText(hDlg, ptz);
    delete ptz;

    // Limit the entry length of the edit control.
    //
    SendDlgItemMessage(hDlg, IDC_EDIT, EM_LIMITTEXT, m_nMaxLen, 0);

    // Initialize the list view.
    //
    RECT rect;
    LV_COLUMN lvc;
    hList = GetDlgItem(hDlg, IDC_LIST);
    ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);
    if (!m_fWritable)
    {
        LONG_PTR lStyle = GetWindowLongPtr(hList, GWL_STYLE);
        lStyle &= ~(LVS_EDITLABELS);
        SetWindowLongPtr(hList, GWL_STYLE, lStyle);
    }

    GetClientRect(hList, &rect);
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right;
    lvc.iSubItem = 0;

    ListView_InsertColumn(hList, 0, &lvc);

    // Load the list view.
    //
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 0;

    for (i = 0; (DWORD)i < m_AttrInfo.dwNumValues; i++)
    {
        if (!UnicodeToTchar(m_AttrInfo.pADsValues[i].CaseIgnoreString,
                            &ptz))
        {
            ReportError(E_OUTOFMEMORY, 0, hDlg);
            return 0;
        }
        lvi.pszText = ptz;
        lvi.iItem = i;
        ListView_InsertItem(hList, &lvi);
        m_cValues++;
    }

    //
    // Disable the Add, Change, and Remove buttons.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_CLOSE), FALSE);

    if (!m_fWritable)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT), FALSE);
    }
    //
    // Make the CLOSE button the default.
    //
    int style;

    style = (int)GetWindowLongPtr(GetDlgItem(hDlg, IDC_CLOSE), GWL_STYLE);

    style |= BS_DEFPUSHBUTTON;

    SendDlgItemMessage(hDlg, IDC_CLOSE, BM_SETSTYLE,
                       (WPARAM)LOWORD(style), MAKELPARAM(TRUE, 0));
    m_nCurDefCtrl = IDC_CLOSE;
    return 1;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::DoCommand
//
//  Synopsis:   WM_COMMAND code.
//
//-----------------------------------------------------------------------------
int
CMultiStringAttr::DoCommand(HWND hDlg, int id, int code)
{
    LPTSTR ptz;
    LONG i;
    HWND hList;
    LV_ITEM lvi;
    switch (code)
    {
    case BN_CLICKED:
        if (id == IDOK)
        {
            // Hitting Return causes IDOK to be sent. Replace that with the
            // ID of the control that is currently the default.
            //
            id = m_nCurDefCtrl;
        }
        switch (id)
        {
        case IDC_ADD_BTN:
            if (m_nLimit && (m_cValues >= m_nLimit))
            {
                ErrMsgParam(IDS_MULTISEL_LIMIT, (LPARAM)m_nLimit, hDlg);
                return 1;
            }
            ptz = new TCHAR[m_nMaxLen + 1];

            CHECK_NULL_REPORT(ptz, hDlg, return -1);

            if (GetWindowText(GetDlgItem(hDlg, IDC_EDIT), ptz,
                              m_nMaxLen))
            {
                hList = GetDlgItem(hDlg, IDC_LIST);
                //
                // See if the string already exists
                //
                LVFINDINFO lvSearchInfo = {0};
                lvSearchInfo.flags = LVFI_STRING;
                lvSearchInfo.psz = ptz;
                i = ListView_FindItem(hList, -1, &lvSearchInfo);
                if (i == -1)
                {
                  i = ListView_GetItemCount(hList);
                  lvi.mask = LVIF_TEXT;
                  lvi.iSubItem = 0;
                  lvi.pszText = ptz;
                  lvi.iItem = i;
                  ListView_InsertItem(hList, &lvi);
                  //Make this item selected and make it  visible
                  ListView_SetItemState( hList, 
                                         i, 
                                         LVIS_SELECTED|LVIS_FOCUSED , 
                                         LVIS_SELECTED|LVIS_FOCUSED );
                }
                ListView_EnsureVisible(hList, i, FALSE);


                m_cValues++;

                SetWindowText(GetDlgItem(hDlg, IDC_EDIT), TEXT(""));
                //
                // Disable the Save button and make the OK button the
                // default.
                //
                ToggleMVDefaultBtn(hDlg, TRUE);

                m_nCurDefCtrl = IDC_CLOSE;
                SetDirty(hDlg);
            }

            delete ptz;

            return 1;

        case IDC_DELETE_BTN:
        case IDC_EDIT_BTN:
            hList = GetDlgItem(hDlg, IDC_LIST);

            i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);
            dspDebugOut((DEB_ITRACE, "List element %d selected\n", i));

            if (i >= 0)
            {
                if (id == IDC_DELETE_BTN)
                {
                    ListView_DeleteItem(hList, i);
                    m_cValues--;

                    //Get the count of list view items
                    LONG itemCount = ListView_GetItemCount(hList);
                    if(itemCount)
                    {
                        ListView_SetItemState( hList, 
                                               (itemCount > i) ? i : i-1,
                                               LVIS_SELECTED|LVIS_FOCUSED , 
                                               LVIS_SELECTED|LVIS_FOCUSED );
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT));
                        m_fListHasSel = FALSE;
                    }
                }
                else
                {
                    SetFocus(GetDlgItem(hDlg, IDC_LIST));
                    ListView_EditLabel(hList, i);
                }
                SetDirty(hDlg);
            }


            return 1;

        case IDC_CLOSE:
            {
                // Copy the list box back to the attr info list.
                //
                int nItems;
                ClearAttrInfo();
                m_fListHasSel = FALSE;

                hList = GetDlgItem(hDlg, IDC_LIST);
                nItems = ListView_GetItemCount(hList);

                if (nItems == 0)
                {
                    EndDialog(hDlg, IDOK);
                    return 1;
                }

                m_AttrInfo.pADsValues = new ADSVALUE[nItems];

                CHECK_NULL_REPORT(m_AttrInfo.pADsValues, hDlg, return -1);

                ptz = new TCHAR[m_nMaxLen + 1];

                CHECK_NULL_REPORT(ptz, hDlg, return -1);

                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 0;
                lvi.pszText = ptz;
                lvi.cchTextMax = m_nMaxLen + 1;

                for (i = 0; i < nItems; i++)
                {
                    lvi.iItem = i;
                    if (!ListView_GetItem(hList, &lvi))
                    {
                        REPORT_ERROR(GetLastError(), hDlg);
                        delete ptz;
                        EndDialog(hDlg, IDCANCEL);
                        return -1;
                    }
                    if (!TcharToUnicode(ptz,
                                        &m_AttrInfo.pADsValues[i].CaseIgnoreString))
                    {
                        REPORT_ERROR(E_OUTOFMEMORY, hDlg);
                        return E_OUTOFMEMORY;
                    }
                    m_AttrInfo.pADsValues[i].dwType = m_AttrInfo.dwADsType;
                    m_AttrInfo.dwNumValues++;
                }
                delete ptz;
                EndDialog(hDlg, IDOK);
            }
            return IDOK;

        case IDCANCEL:
            m_fListHasSel = FALSE;
            EndDialog(hDlg, IDCANCEL);
            return IDCANCEL;
        }
        break;

    case EN_CHANGE:
        if (id == IDC_EDIT)
        {
            BOOL fEnableAdd = FALSE;
            LRESULT lTextLen = SendDlgItemMessage(hDlg, IDC_EDIT,
                                                  WM_GETTEXTLENGTH,
                                                  0, 0);

            PTSTR pszText = new TCHAR[lTextLen + 1];
            if (pszText != NULL)
            {
              if (!GetDlgItemText(hDlg, IDC_EDIT, pszText, static_cast<int>(lTextLen + 1)))
              {
                fEnableAdd = lTextLen > 0;
              }
              else
              {
                CStr strText;
                strText = pszText;
                strText.TrimLeft();
                strText.TrimRight();

                if (strText.IsEmpty())
                {
                  fEnableAdd = FALSE;
                }
                else
                {
                  fEnableAdd = TRUE;
                }
              }
            }
            else
            {
              fEnableAdd = lTextLen > 0;
            }

            if (fEnableAdd && (m_nCurDefCtrl == IDC_ADD_BTN))
            {
                return 1;
            }

            m_nCurDefCtrl = (fEnableAdd) ? IDC_ADD_BTN : IDC_CLOSE;

            EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), fEnableAdd);

            ToggleMVDefaultBtn(hDlg, !fEnableAdd);

            return 1;
        }
        break;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CMultiStringAttr::DoNotify
//
//  Synopsis:   WM_NOTIFY code.
//
//-----------------------------------------------------------------------------
BOOL
CMultiStringAttr::DoNotify(HWND hDlg, NMHDR * pNmHdr)
{
    if (pNmHdr->idFrom != IDC_LIST)
    {
        return TRUE;
    }

    LV_DISPINFO * pldi = (LV_DISPINFO *)pNmHdr;

    switch (pNmHdr->code)
    {
    case LVN_ENDLABELEDIT:
        if (pldi->item.pszText)
        {
            dspDebugOut((DEB_ITRACE, "Editing item %d, new value %S\n",
                         pldi->item.iItem, pldi->item.pszText));
            ListView_SetItemText(pldi->hdr.hwndFrom, pldi->item.iItem, 0,
                                 pldi->item.pszText);
        }
        break;

    case NM_SETFOCUS:
        dspDebugOut((DEB_ITRACE, "NM_SETFOCUS received\n"));
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            //
            // If the list control gets the focus by tabbing and no item
            // is selected, then set the selection to the first item.
            //
            if (!m_fListHasSel && ListView_GetItemCount(GetDlgItem(hDlg, IDC_LIST)))
            {
                dspDebugOut((DEB_ITRACE, "setting the list selection\n"));
                m_fListHasSel = TRUE;
                ListView_SetItemState(GetDlgItem(hDlg, IDC_LIST), 0, 
                                      LVIS_FOCUSED | LVIS_SELECTED,
                                      LVIS_FOCUSED | LVIS_SELECTED);
                if (m_fWritable)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
                }
            }
        }
        return 1;

    case LVN_ITEMCHANGED:
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            if(ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_LIST)))
            {
                m_fListHasSel = TRUE;
                if (m_fWritable)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
                }
            }
            else
            {
                m_fListHasSel = FALSE;
                if (m_fWritable)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
                }
            }
        }
        return 1;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   OtherValuesBtn
//
//  Synopsis:   "Others..." button that brings up a dialog (similar to the
//              multi-valued attribute dialog) to modify the otherXXXX
//              attribute. Usage: if a multi-valued property needs to
//              have one value designated at the primary value, then this
//              must be expressed as two separate attributes since multi-
//              valued attributes are un-ordered. For example, consider tele-
//              phone numbers; Telephone-Number, which is single-valued is the
//              primary value and Phone-Office-Other, which is multi-valued,
//              is used to store the "other" numbers.
//
//-----------------------------------------------------------------------------
HRESULT
OtherValuesBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    CMultiStringAttrDlg * pMultiS = NULL;

    switch (DlgOp)
    {
    case fInit:
      {
        pMultiS = new CMultiStringAttrDlg(pPage);

        CHECK_NULL_REPORT(pMultiS, pPage->GetHWnd(), return E_OUTOFMEMORY);

        BOOL fMultiselectPage = pPage->IsMultiselectPage();
        hr = pMultiS->Init(pAttrMap, pAttrInfo, PATTR_DATA_IS_WRITABLE(pAttrData), 0, FALSE, fMultiselectPage);

        CHECK_HRESULT(hr, return hr);

        pAttrData->pVoid = reinterpret_cast<LPARAM>(pMultiS);  // save the object pointer.
      }
      break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
            pMultiS = (CMultiStringAttrDlg *)pAttrData->pVoid;

            if (IDOK == pMultiS->Edit())
            {
                PATTR_DATA_SET_DIRTY(pAttrData);
            }
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }
        CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
        pMultiS = (CMultiStringAttrDlg *)pAttrData->pVoid;

        return pMultiS->Write(pAttrInfo);

    case fOnDestroy:
        if (pAttrData->pVoid)
        {
            delete (CMultiStringAttrDlg *)pAttrData->pVoid;
        }
        break;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function    ToggleMVDefaultBtn
//
//  Synopsis:   Toggle the default pushbutton of the multi-valued dialog.
//
//-----------------------------------------------------------------------------
void
ToggleMVDefaultBtn(HWND hDlg, BOOL fOK)
{
    LONG style, newstyle;
    int nDefault = IDC_CLOSE, nNotDefault = IDC_ADD_BTN;

    if (!fOK)
    {
        nDefault = IDC_ADD_BTN;
        nNotDefault = IDC_CLOSE;
    }

    //
    // Clear the default bit on this one.
    //
    style = (LONG)GetWindowLongPtr(GetDlgItem(hDlg, nNotDefault), GWL_STYLE);

    newstyle = style & ~(BS_DEFPUSHBUTTON);

    SendDlgItemMessage(hDlg, nNotDefault, BM_SETSTYLE, (WPARAM)LOWORD(newstyle),
                       MAKELPARAM(TRUE, 0));

    //
    // Make this one the default.
    //
    style = (LONG)GetWindowLongPtr(GetDlgItem(hDlg, nDefault), GWL_STYLE);

    newstyle = style | BS_DEFPUSHBUTTON;

    SendDlgItemMessage(hDlg, nDefault, BM_SETSTYLE, (WPARAM)LOWORD(newstyle),
                       MAKELPARAM(TRUE, 0));
    if (fOK)
    {
        SetFocus(GetDlgItem(hDlg, IDC_EDIT));
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   GetObjectClass
//
//  Synopsis:   Object page attribute function for object class.
//
//-----------------------------------------------------------------------------
HRESULT
GetObjectClass(CDsPropPageBase * pPage, PATTR_MAP,
               PADS_ATTR_INFO, LPARAM, PATTR_DATA,
               DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        WCHAR wszBuf[120];
        PTSTR ptz;
        HRESULT hr;
        IDsDisplaySpecifier * pDispSpec;

        hr = pPage->GetIDispSpec(&pDispSpec);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);
        //
        // Look up the localized class name on the object display
        // specification cache.
        //
        hr = pDispSpec->GetFriendlyClassName(pPage->GetObjClass(), wszBuf, 120);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        if (!UnicodeToTchar(wszBuf, &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }

        SetDlgItemText(pPage->GetHWnd(), IDC_CLASS_STATIC, ptz);

        delete ptz;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetObjectTimestamp
//
//  Synopsis:   Object page attribute function for object timestamps.
//
//-----------------------------------------------------------------------------
HRESULT
GetObjectTimestamp(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                   PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
                   DLG_OP DlgOp)
{
    DWORD dwErr;

    if ((DlgOp == fInit) && pPage)
    {
        TCHAR tszBuf[MAX_MSG_LEN];

        if (pAttrInfo && pAttrInfo->dwNumValues && pAttrInfo->pADsValues &&
            pAttrInfo->pADsValues->dwType == ADSTYPE_UTC_TIME)
        {
            SYSTEMTIME st = {0};

            if (!SystemTimeToTzSpecificLocalTime(NULL, &pAttrInfo->pADsValues->UTCTime, &st))
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return dwErr);
            }

            int cch = GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL,
                                    tszBuf, MAX_MSG_LEN);
            if (cch == 0)
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return dwErr);
            }

            _tcscat(tszBuf, TEXT(" "));
            cch = static_cast<int>(_tcslen(tszBuf));

            GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, tszBuf + cch,
                          MAX_MSG_LEN - cch);
        }
        else
        {
            if (!LoadString(g_hInstance, IDS_NO_VALUE, tszBuf, MAX_MSG_LEN - 1))
            {
              _tcscpy(tszBuf, TEXT(" "));
            }
        }

        int nCtrl = 0;

        switch (pAttrMap->nCtrlID)
        {
        case IDC_CREATED_TIME_STATIC:
            DBG_OUT("Getting creation timestamp.");
            nCtrl = IDC_CREATED_TIME_STATIC;
            break;

        case IDC_MODIFIED_TIME_STATIC:
            DBG_OUT("Getting last modification timestamp.");
            nCtrl = IDC_MODIFIED_TIME_STATIC;
            break;

        default:
            REPORT_ERROR(E_INVALIDARG, pPage->GetHWnd());
        }

        SetDlgItemText(pPage->GetHWnd(), nCtrl, tszBuf);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ObjectPathField
//
//  Synopsis:   Handles the Object page path field.
//
//-----------------------------------------------------------------------------
HRESULT
ObjectPathField(CDsPropPageBase * pPage, PATTR_MAP,
                PADS_ATTR_INFO, LPARAM, PATTR_DATA,
                DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        PWSTR pwzPath, pwzDNSname;

        HRESULT hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwzPath);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        hr = CrackName(pwzPath, &pwzDNSname, GET_OBJ_CAN_NAME, pPage->GetHWnd());

        delete pwzPath;

        CHECK_HRESULT(hr, return hr);

        PTSTR ptszPath;

        if (!UnicodeToTchar(pwzDNSname, &ptszPath))
        {
            LocalFreeStringW(&pwzDNSname);
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }

        LocalFreeStringW(&pwzDNSname);

        SetDlgItemText(pPage->GetHWnd(), IDC_PATH_FIELD, ptszPath);

        delete ptszPath;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\objlist.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       objlist.h
//
//  Contents:   DS object list object header
//
//  Classes:    
//
//  History:    20-Nov-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _OBJLIST_H_
#define _OBJLIST_H_

//#include <cdlink.hxx>

//+----------------------------------------------------------------------------
//
//  Class:      CMemberListItem
//
//  Purpose:    membership list data item.
//
//-----------------------------------------------------------------------------
class CMemberListItem : public CDLink
{
public:
    CMemberListItem(void) : m_pwzDN(NULL), m_ptzName(NULL), m_pSid(NULL),
                            m_fSidSet(FALSE), m_fCanBePrimarySet(FALSE),
                            m_fCanBePrimary(FALSE), m_fIsPrimary(FALSE),
                            m_fIsAlreadyMember(FALSE), m_fIsExternal(FALSE),
                            m_ulScopeType(0) {};
    ~CMemberListItem(void) {DO_DEL(m_pwzDN);
                            DO_DEL(m_ptzName);
                            DO_DEL(m_pSid);};
    // CDLink method overrides:
    CMemberListItem   * Next(void) {return (CMemberListItem *)CDLink::Next();};

    CMemberListItem   * Copy(void);
    BOOL                IsSidSet(void) {return m_fSidSet;};
    BOOL                IsCanBePrimarySet(void) {return m_fCanBePrimarySet;};
    BOOL                CanBePrimary(void) {return m_fCanBePrimary;};
    void                SetCanBePrimary(BOOL fCanBePrimary)
                        {
                            m_fCanBePrimary = fCanBePrimary;
                            m_fCanBePrimarySet = TRUE;
                        };
    BOOL                SetSid(PSID pSid);
    PSID                GetSid(void) {return m_pSid;};
    BOOL                IsPrimary(void) {return m_fIsPrimary;};

    PWSTR   m_pwzDN;
    PTSTR   m_ptzName;
    PSID    m_pSid;
    ULONG   m_ulScopeType;
    BOOL    m_fSidSet;
    BOOL    m_fCanBePrimarySet;
    BOOL    m_fCanBePrimary;
    BOOL    m_fIsPrimary;
    BOOL    m_fIsAlreadyMember;
    BOOL    m_fIsExternal;      // member is from an external domain and is
                                // identified using the SID.
};

//+----------------------------------------------------------------------------
//
//  Class:      CMemberLinkList
//
//  Purpose:    Linked list of membership class objects.
//
//-----------------------------------------------------------------------------
class CMemberLinkList
{
public:
    CMemberLinkList(void) : m_pListHead(NULL) {};
    ~CMemberLinkList(void);

    CMemberListItem   * FindItemRemove(PWSTR pwzDN);
    CMemberListItem   * FindItemRemove(PSID pSid);
    CMemberListItem   * RemoveFirstItem(void);
    BOOL                AddItem(CMemberListItem * pItem, BOOL fMember = TRUE);
    int                 GetItemCount(void);

private:
    CMemberListItem   * m_pListHead;
};

const int IDX_NAME_COL = 0;
const int IDX_FOLDER_COL = 1;
const int IDX_ERROR_COL = 1;
const int OBJ_LIST_NAME_COL_WIDTH = 100;
const int OBJ_LIST_PAGE_COL_WIDTH = 72;

//+----------------------------------------------------------------------------
//
//  Class:      CDsObjList
//
//  Purpose:    Base class for DS object lists that employ a two column
//              list view to show object Name and Folder.
//
//-----------------------------------------------------------------------------
class CDsObjList
{
public:
    CDsObjList(HWND hPage, int idList);
    ~CDsObjList(void);

    HRESULT Init(BOOL fShowIcons = FALSE);
    HRESULT InsertIntoList(PTSTR ptzDisplayName, PVOID pData, int iIcon = -1);
    HRESULT GetItem(int index, PTSTR * pptzName, PVOID * ppData);
    BOOL    GetCurListItem(int * pIndex, PTSTR * pptzName, PVOID * ppData);
    BOOL    GetCurListItems(int ** ppIndex, PTSTR ** ppptzName, PVOID ** pppData, int* pNumSelected);
    virtual BOOL RemoveListItem(int Index);
    int     GetCount(void) {return ListView_GetItemCount(m_hList);};
    UINT    GetSelectedCount(void) { return ListView_GetSelectedCount(m_hList);}
    virtual void ClearList(void) = 0;

protected:
    HWND    m_hPage;
    HWND    m_hList;
    int     m_idList;
    int     m_nCurItem;
    BOOL    m_fShowIcons;
    BOOL    m_fLimitExceeded;
};

void GetNameParts(const CStr& cstrCanonicalNameEx, CStr& cstrFolder, CStr & cstrName);

//+----------------------------------------------------------------------------
//
//  Class:      CDsMembershipList
//
//  Purpose:    Membership list class for the list-view control.
//
//-----------------------------------------------------------------------------
class CDsMembershipList : public CDsObjList
{
public:
    CDsMembershipList(HWND hPage, int idList) : CDsObjList(hPage, idList) {};
    ~CDsMembershipList(void) {};

    HRESULT InsertIntoList(PTSTR ptzDisplayName, PVOID pData, int iIcon = -1)
                {return CDsObjList::InsertIntoList(ptzDisplayName, pData, iIcon);};

    HRESULT InsertIntoList(PWSTR pwzPath, int iIcon = -1)
                {return CDsMembershipList::InsertIntoList(pwzPath, iIcon, FALSE, FALSE,
                                                          FALSE, FALSE, 0);};

    HRESULT InsertIntoNewList(PWSTR pwzPath, BOOL fPrimary = FALSE)
                {return CDsMembershipList::InsertIntoList(pwzPath, -1, TRUE,
                                                          fPrimary, FALSE, TRUE, 0);};

    HRESULT InsertIntoList(PWSTR pwzPath, int iIcon, BOOL fAlreadyMember, BOOL fPrimary,
                           BOOL fIgnoreDups, BOOL fDontChkDups, ULONG flScopeType);

    HRESULT InsertIntoList(PSID pSid, PWSTR pwzPath);

    HRESULT InsertIntoList(CMemberListItem * pItem);

    HRESULT InsertExternalIntoList(PWSTR pwzPath, ULONG ulScopeType)
                {return CDsMembershipList::InsertIntoList(pwzPath, -1, FALSE,
                                                          FALSE, FALSE,
                                                          FALSE, ulScopeType);};
    HRESULT MergeIntoList(PWSTR pwzPath)
                {return CDsMembershipList::InsertIntoList(pwzPath, -1, TRUE, FALSE, TRUE, FALSE, 0);};

    HRESULT GetItem(int index, CMemberListItem ** ppData)
                {return CDsObjList::GetItem(index, NULL, (PVOID *)ppData);};

    BOOL    GetCurListItem(int * pIndex, PTSTR * pptzName, CMemberListItem ** ppData)
                {return CDsObjList::GetCurListItem(pIndex, pptzName, (PVOID *)ppData);};

    BOOL    GetCurListItems(int ** ppIndex, PTSTR ** ppptzName, CMemberListItem *** pppData, int* pNumSelected)
                {return CDsObjList::GetCurListItems(ppIndex, ppptzName, (PVOID **)pppData, pNumSelected);};

    int     GetIndex(LPCWSTR pwzDN, ULONG ulStart, ULONG ulEnd);

    BOOL    RemoveListItem(int Index);
    void    ClearList(void);

    HRESULT SetMemberIcons(CDsPropPageBase * pPage);
};

struct CLASS_CACHE_ENTRY
{
    WCHAR   wzClass[MAX_PATH];
    int     iIcon;
    int     iDisabledIcon;
};

#define ICON_CACHE_NUM_CLASSES  6

//+--------------------------------------------------------------------------
//
//  Class:      CClassIconCache
//
//  Purpose:    Build an image list for well known DS classes and map the
//              image indices to the class names.
//
//  Notes:      CAUTION: the imagelist is destroyed in the dtor, therefore
//              it should only be used with listview controls that have
//              the LVS_SHAREIMAGELISTS style set.
//
//---------------------------------------------------------------------------
class CClassIconCache
{
public:

  CClassIconCache(void);

 ~CClassIconCache(void);

  int GetClassIconIndex(PCWSTR pwzClass, BOOL fDisabled = FALSE);
  int AddClassIcon(PCWSTR pwzClass, BOOL fDisabled = FALSE);

  HIMAGELIST GetImageList(void);

  void ClearAll();
private:

  HRESULT Initialize(void);

  BOOL                m_fInitialized;
  CLASS_CACHE_ENTRY*  m_prgcce;
  UINT                m_nImageCount;
  HIMAGELIST          m_hImageList;
};

extern CClassIconCache g_ClassIconCache;

#endif // _OBJLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\pch.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       pch.h
//
//  Contents:   precompiled includes
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------
#ifndef _pch_h
#define _pch_h

#ifdef UNICODE
#   ifndef _UNICODE
#       define _UNICODE
#   endif
#endif


//
// Some public headers are still failing on these warnings
// so they need to be disabled in both chk and fre
//
//#ifndef DBG

#pragma warning (disable: 4189 4100)

//#endif // DBG

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <windowsx.h>
#if !defined(_WIN32_IE)
#  define _WIN32_IE 0x0500 // needed by Wizard97 for new trust wizard
#  pragma message("_WIN32_IE defined to be 0x0500")
#else
#  if _WIN32_IE >= 0x0500
#     pragma message("_WIN32_IE >= 0x0500")
#  else
#     pragma message("_WIN32_IE < 0x0500")
#  endif
#endif
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <cmnquery.h>
#include <winnls.h>
#include <htmlhelp.h>
#include <wincred.h>
#include <wincrui.h>
extern "C"
{
#include <ntlsa.h>
}
#include <ntsam.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <string.h>
#include <tchar.h>
#include <stdarg.h>
#include <process.h>

#include <ole2.h>
#include <ntdsapi.h>
#include <rassapi.h>

#include <winldap.h>
#include <activeds.h>
#include <iadsp.h>
#include <dsclient.h>
#include <dsquery.h>
#include <dsclintp.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h> // CComPtr et al

#include <mmc.h>

#define EXPORTDEF   // Needed by cdlink.hxx
#include <cdlink.hxx>

#include <objsel.h>
#include <objselp.h>

#include <dspropp.h>
#include "shluuid.h"
#include "propuuid.h"
#include "dll.h"
#include "debug.h"
#include "cstr.h"   // CStr
#include "dscmn.h"
#include "dsadminp.h"
#include "pcrack.h"

// Used to disable these warnings while compiling with /W4
//#pragma warning (disable: 4100)
//#pragma warning (disable: 4663)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\propbase.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       propbase.cxx
//
//  Contents:   CDsPropPageBase, the base class for property page classes.
//
//  History:    31-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::~CADsApplyErrors
//
//-----------------------------------------------------------------------------
CADsApplyErrors::~CADsApplyErrors()
{
  if (m_pszTitle != NULL)
  {
    delete[] m_pszTitle;
  }

  Clear();
}



//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::SetError
//
//-----------------------------------------------------------------------------
void CADsApplyErrors::SetError(PADSPROPERROR pError)
{
  if (m_nCount == m_nArraySize)
  {
    PAPPLY_ERROR_ENTRY pNewTable = new APPLY_ERROR_ENTRY[m_nCount + m_nIncAmount];
    m_nArraySize = m_nCount + m_nIncAmount;

    if (pNewTable != NULL)
    {
      memset(pNewTable, 0, sizeof(APPLY_ERROR_ENTRY) * (m_nCount + m_nIncAmount));

      if (m_pErrorTable != NULL)
      {
        for (UINT nIdx = 0; nIdx < m_nCount; nIdx++)
        {
          pNewTable[nIdx].pszPath = m_pErrorTable[nIdx].pszPath;
          pNewTable[nIdx].pszClass = m_pErrorTable[nIdx].pszClass;
          pNewTable[nIdx].hr = m_pErrorTable[nIdx].hr;
          pNewTable[nIdx].pszStringError = m_pErrorTable[nIdx].pszStringError;
        }
        delete[] m_pErrorTable;
      }
      m_pErrorTable = pNewTable;
    }
  }

  //
  // Copy the path to the object
  //
  if (pError->pszObjPath != NULL)
  {
    m_pErrorTable[m_nCount].pszPath = new WCHAR[wcslen(pError->pszObjPath) + 1];
    dspAssert(m_pErrorTable[m_nCount].pszPath != NULL);
    if (m_pErrorTable[m_nCount].pszPath != NULL)
    {
      wcscpy(m_pErrorTable[m_nCount].pszPath, pError->pszObjPath);
    }
  }

  //
  // Copy the class to the object
  //
  if (pError->pszObjClass != NULL)
  {
    // Note: this memory is freed in the Clear() method which is called from
    // the class destructor

    m_pErrorTable[m_nCount].pszClass = new WCHAR[wcslen(pError->pszObjClass) + 1];
    dspAssert(m_pErrorTable[m_nCount].pszClass != NULL);
    if (m_pErrorTable[m_nCount].pszClass != NULL)
    {
      wcscpy(m_pErrorTable[m_nCount].pszClass, pError->pszObjClass);
    }
  }

  //
  // Copy the error
  //
  if (pError->hr != S_OK)
  {
    m_pErrorTable[m_nCount].hr = pError->hr;
  }
  else
  {
    if (pError->pszError != NULL)
    {
      m_pErrorTable[m_nCount].pszStringError = new WCHAR[wcslen(pError->pszError) + 1];
      dspAssert(m_pErrorTable[m_nCount].pszStringError != NULL);
      if (m_pErrorTable[m_nCount].pszStringError != NULL)
      {
        wcscpy(m_pErrorTable[m_nCount].pszStringError, pError->pszError);
      }
    }
  }

  //
  // Copy the page title
  //
  if (pError->pszPageTitle != NULL)
  {
    m_pszTitle = new WCHAR[wcslen(pError->pszPageTitle) + 1];
    if (m_pszTitle != NULL)
    {
      wcscpy(m_pszTitle, pError->pszPageTitle);
    }
  }

  m_nCount++;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetError
//
//-----------------------------------------------------------------------------
HRESULT CADsApplyErrors::GetError(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].hr;
  }
  return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetStringError
//
//-----------------------------------------------------------------------------
PWSTR CADsApplyErrors::GetStringError(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].pszStringError;
  }
  return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::Clear
//
//-----------------------------------------------------------------------------
void CADsApplyErrors::Clear()
{
  if (m_pErrorTable != NULL)
  {
    for (UINT idx = 0; idx < m_nCount; idx++)
    {
      if (m_pErrorTable[idx].pszPath != NULL)
      {
        delete[] m_pErrorTable[idx].pszPath;
        m_pErrorTable[idx].pszPath = NULL;
      }
      if (m_pErrorTable[idx].pszClass != NULL)
      {
        delete[] m_pErrorTable[idx].pszClass;
        m_pErrorTable[idx].pszClass = NULL;
      }
      if (m_pErrorTable[idx].pszStringError != NULL)
      {
        delete[] m_pErrorTable[idx].pszStringError;
        m_pErrorTable[idx].pszStringError = NULL;
      }
    }
    delete[] m_pErrorTable;
    m_pErrorTable = NULL;
  }

  m_nCount = 0;
  m_nArraySize = 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetName
//
//-----------------------------------------------------------------------------
PWSTR CADsApplyErrors::GetName(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].pszPath;
  }
  return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CADsApplyErrors::GetClass
//
//-----------------------------------------------------------------------------
PWSTR CADsApplyErrors::GetClass(UINT nIndex)
{
  dspAssert(nIndex < m_nCount);
  if (nIndex < m_nCount)
  {
    return m_pErrorTable[nIndex].pszClass;
  }
  return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::CDsPropPageBase
//
//-----------------------------------------------------------------------------
CDsPropPageBase::CDsPropPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                 HWND hNotifyObj, DWORD dwFlags) :
    m_hPage(NULL),
    m_fInInit(FALSE),
    m_fPageDirty(FALSE),
    m_fReadOnly(FALSE),
    m_fMultiselectPage(FALSE),
    m_pDataObj(pDataObj),
    m_pWPTDataObj(NULL),
    m_pDataObjStrm(NULL),
    m_pDsObj(NULL),
    m_nPageTitle(pDsPage->nPageTitle),
    m_nDlgTemplate(pDsPage->nDlgTemplate),
    m_cAttrs(pDsPage->cAttrs),
    m_rgpAttrMap(pDsPage->rgpAttrMap),
    m_pwszObjPathName(NULL),
    m_pwszObjClass(NULL),
    m_pwszRDName(NULL),
    m_pDispSpec(NULL),
    m_pObjSel(NULL),
    m_fObjSelInited(FALSE),
    m_rgAttrData(NULL),
    m_uRefs(1),
    m_hNotifyObj(hNotifyObj),
    m_pWritableAttrs(NULL),
    m_hrInit(S_OK),
    m_pBasePathsInfo(0)
{
    TRACE2(CDsPropPageBase,CDsPropPageBase);
    //
    // Get the read-only state.
    //
    if (dwFlags & DSOBJECT_READONLYPAGES)
    {
        m_fReadOnly = TRUE;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::~CDsPropPageBase
//
//-----------------------------------------------------------------------------
CDsPropPageBase::~CDsPropPageBase()
{
  TRACE2(CDsPropPageBase,~CDsPropPageBase);
  if (m_pwszObjPathName)
  {
    delete m_pwszObjPathName;
  }
  if (m_pwszObjClass)
  {
    delete m_pwszObjClass;
  }
  if (m_pwszRDName)
  {
    delete m_pwszRDName;
  }
  if (m_rgAttrData)
  {
    delete [] m_rgAttrData;
  }
  if (m_pObjSel)
  {
    m_pObjSel->Release();
  }
  if (m_pDispSpec)
  {
    m_pDispSpec->Release();
  }

  if (m_pBasePathsInfo)
  {
     m_pBasePathsInfo->Release();
  }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void
CDsPropPageBase::Init(PWSTR pwzADsPath, LPWSTR pwzClass, CDSBasePathsInfo* pBasePathsInfo)
{
    TRACE(CDsPropPageBase,Init);
    CWaitCursor cWait;
    ADSPROPINITPARAMS InitParams = {0};
    InitParams.dwSize = sizeof(ADSPROPINITPARAMS);

    ADsPropGetInitInfo(m_hNotifyObj, &InitParams);

    if (FAILED(InitParams.hr))
    {
        m_hrInit = InitParams.hr;
        return;
    }

    if (!pBasePathsInfo)
    {
       m_hrInit = E_INVALIDARG;
       return;
    }
    m_pBasePathsInfo = pBasePathsInfo;
    m_pBasePathsInfo->AddRef();

    if (!AllocWStr(pwzADsPath, &m_pwszObjPathName) ||
        !AllocWStr(InitParams.pwzCN, &m_pwszRDName)      ||
        !AllocWStr(pwzClass, &m_pwszObjClass))
    {
        m_hrInit = E_OUTOFMEMORY;
        return;
    }

    dspAssert(InitParams.pDsObj);

    m_pDsObj = InitParams.pDsObj;
    DBG_OUT("+++++++++++++++++++++++++++addrefing object");
    m_pDsObj->AddRef();

    m_pWritableAttrs = InitParams.pWritableAttrs;

    //
    // Allocate memory for the attribute data.
    //
    m_rgAttrData = new ATTR_DATA[m_cAttrs];
    CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

    memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

    //
    // Marshall the data object pointer for passing to the window proc thread.
    //
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                               &m_pDataObjStrm);
    m_pDataObj = NULL; // to make sure no one calls here
    CHECK_HRESULT(hr, m_hrInit = hr; return);

}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::CreatePage
//
//  Synopsis:   Create the prop page
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::CreatePage(HPROPSHEETPAGE * phPage)
{
    TCHAR szTitle[MAX_PATH];
    if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    PROPSHEETPAGE   psp;

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
    psp.pszTemplate = MAKEINTRESOURCE((SUCCEEDED(m_hrInit)) ? m_nDlgTemplate : IDD_ERROR_PAGE);
    psp.pfnDlgProc  = (DLGPROC)StaticDlgProc;
    psp.pfnCallback = PageCallback;
    psp.pcRefParent = NULL; // do not set PSP_USEREFPARENT
    psp.lParam      = (LPARAM) this;
    psp.hInstance   = g_hInstance;
    psp.pszTitle    = szTitle;

    *phPage = CreatePropertySheetPage(&psp);

    if (*phPage == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::StaticDlgProc
//
//  Synopsis:   static dialog proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CDsPropPageBase::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDsPropPageBase * pPage = (CDsPropPageBase *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pPage = (CDsPropPageBase *) ppsp->lParam;
        pPage->m_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);

        if (pPage->m_pDataObjStrm)
        {
            // Unmarshall the Data Object pointer.
            //
            HRESULT hr;
            hr = CoGetInterfaceAndReleaseStream(pPage->m_pDataObjStrm,
                                                IID_IDataObject,
                                                reinterpret_cast<void**>(&pPage->m_pWPTDataObj));
            CHECK_HRESULT_REPORT(hr, hDlg, return FALSE);
        }
        return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
    }

    if (pPage != NULL && (SUCCEEDED(pPage->m_hrInit)))
    {
        if (uMsg == WM_ADSPROP_PAGE_GET_NOTIFY)
        {
            HWND* pHWnd = (HWND*)wParam;
            *pHWnd = pPage->m_hNotifyObj;
            return TRUE;
        }
        return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::InitDlg
//
//  Synopsis:   Handles dialog initialization for error cases. Passes non-
//              error initialization to subclass' OnInitDialog.
//
//-----------------------------------------------------------------------------
LRESULT CDsPropPageBase::InitDlg(LPARAM lParam)
{
    m_fInInit = TRUE;

    if (FAILED(m_hrInit))
    {
        // Bind to the object failed, display an error page with the error
        // message string.
        //
        PTSTR ptz = NULL;
        BOOL fSpecialCaseErr = TRUE;

        switch (HRESULT_CODE(m_hrInit))
        {
        case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
            LoadStringToTchar(IDS_ERROR_VIEW_PERMISSIONS, &ptz);
            break;

        case ERROR_DS_REFERRAL:
            LoadStringToTchar(IDS_ERRMSG_NO_DC_RESPONSE, &ptz);
            break;

        case ERROR_DS_NO_SUCH_OBJECT:
            LoadStringToTchar(IDS_ERRMSG_NO_LONGER_EXISTS, &ptz);
            break;

        default:
            fSpecialCaseErr = FALSE;
            break;
        }

        if (fSpecialCaseErr && ptz)
        {
            SetWindowText(GetDlgItem(m_hPage, IDC_ERROR_MSG), ptz);
            delete ptz;
        }
        else
        {
            int cch;

            cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                | FORMAT_MESSAGE_FROM_SYSTEM, NULL, m_hrInit,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PTSTR)&ptz, 0, NULL);
            if (!cch)
            {
                // Try ADSI errors.
                //
                cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                    | FORMAT_MESSAGE_FROM_HMODULE,
                                    GetModuleHandle(TEXT("activeds.dll")), m_hrInit,
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                    (PTSTR)&ptz, 0, NULL);
            }

            if (cch)
            {
                SetWindowText(GetDlgItem(m_hPage, IDC_ERROR_MSG), ptz);
                LocalFree(ptz);
            }
        }
        m_fInInit = FALSE;
        return S_OK;
    }

    HRESULT hResult = OnInitDialog(lParam);

    m_fInInit = FALSE;
    return hResult;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnNotify(WPARAM, LPARAM lParam)
{
    LRESULT lResult;
    BOOL fPageDirty;

    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_APPLY:
        if (FAILED(m_hrInit))
        {
            return PSNRET_NOERROR;
        }
        lResult = PSNRET_NOERROR;
        //
        // The member var m_fPageDirty gets cleared in OnApply, so save a local
        // copy for passing as the wParam of the WM_ADSPROP_NOTIFY_APPLY msg.
        //
        fPageDirty = m_fPageDirty;

        if (m_fPageDirty)
        {
            // Call the virtual function OnApply()
            lResult = OnApply();
        }
        // Store the result into the dialog
        SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, (LONG_PTR)lResult);
        if (lResult == PSNRET_NOERROR)
        {
          m_fPageDirty = FALSE;
          //
          // Signal the change notification. Note that the notify-apply
          // message must be sent even if the page is not dirty so that the
          // notify ref-counting will properly decrement.
          //
          SendMessage(m_hNotifyObj, WM_ADSPROP_NOTIFY_APPLY, fPageDirty, (LPARAM)m_hPage);
        }
        else
        {
          EnableWindow(GetDlgItem(GetParent(m_hPage), IDCANCEL), TRUE);
        }
        return lResult;

    case PSN_RESET:
        OnCancel();
        return FALSE; // allow the property sheet to be destroyed.

    case PSN_SETACTIVE:
        return OnPSNSetActive(lParam);

    case PSN_KILLACTIVE:
        return OnPSNKillActive(lParam);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnCommand
//
//  Synopsis:   Handles the WM_COMMAND message
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    dspDebugOut((DEB_USER3, "CDsPropPageBase::OnCommand - id: %d, code: %x\n",
                 id, codeNotify));

    if ((codeNotify == EN_CHANGE) && !m_fInInit)
    {
        SetDirty();
    }
    if ((codeNotify == BN_CLICKED) && (id == IDCANCEL))
    {
        //
        // Pressing ESC in a multi-line edit control results in this
        // WM_COMMAND being sent. Pass it on to the parent (the sheet proc) to
        // close the sheet.
        //
        PostMessage(GetParent(m_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                    (LPARAM)hwndCtl);
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::CheckIfPageAttrsWritable
//
//  Synopsis:   See which attributes are writable by checking if they are in
//              the allowedAttributesEffective array.
//
//  Notes:      The m_rgAttrData array is 1 to 1 with the m_rgpAttrMap array.
//-----------------------------------------------------------------------------
void
CDsPropPageBase::CheckIfPageAttrsWritable(void)
{
    DWORD iAllowed;

    if (m_fReadOnly || !m_pWritableAttrs)
    {
        return;
    }

    for (DWORD iAttrs = 0; iAttrs < m_cAttrs; iAttrs++)
    {
        if (m_rgpAttrMap[iAttrs]->AttrInfo.pszAttrName)
        {
            for (iAllowed = 0; iAllowed < m_pWritableAttrs->dwNumValues; iAllowed++)
            {
                if (_wcsicmp(m_rgpAttrMap[iAttrs]->AttrInfo.pszAttrName,
                             m_pWritableAttrs->pADsValues[iAllowed].CaseIgnoreString) == 0)
                {
                    ATTR_DATA_SET_WRITABLE(m_rgAttrData[iAttrs]);
                    break;
                }
            }
        }
    }
    return;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::CheckIfWritable
//
//  Synopsis:   See if the attribute is writable by checking if it is in
//              the allowedAttributesEffective array.
//
//-----------------------------------------------------------------------------
BOOL
CDsPropPageBase::CheckIfWritable(const PWSTR & wzAttr)
{
    BOOL fWritable = FALSE;

    if (m_fReadOnly || !m_pWritableAttrs)
    {
        return FALSE;
    }

    for (DWORD i = 0; i < m_pWritableAttrs->dwNumValues; i++)
    {
        if (_wcsicmp(m_pWritableAttrs->pADsValues[i].CaseIgnoreString,
                     wzAttr) == 0)
        {
            fWritable = TRUE;
            break;
        }
    }
    return fWritable;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnCancel
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnCancel(void)
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnSetFocus
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnSetFocus(HWND)
{
    // An application should return zero if it processes this message.
    return 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnPSNSetActive
//
//  Synopsis:   Page activation event.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnPSNSetActive(LPARAM)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnPSNKillActive
//
//  Synopsis:   Page deactivation event (when other pages cover this one).
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnPSNKillActive(LPARAM)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnDestroy(void)
{
    return 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnShowWindow
//
//  Synopsis:   On dialog window show operations, resizes the view window.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnShowWindow(void)
{
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::GetIDispSpec
//
//  Synopsis:   If needed, create the interface instance and return the pointer.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::GetIDispSpec(IDsDisplaySpecifier ** ppDispSpec)
{
    HRESULT hr;
    TRACE2(CDsPropPageBase, GetIDispSpec);
    if (!m_pDispSpec)
    {
        hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsDisplaySpecifier, (PVOID *)&m_pDispSpec);

        CHECK_HRESULT(hr, return hr);

        CStrW strDC;

        CComPtr<IDirectoryObject> spDsObj;
        if (m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          //
          // Get the objects path 
          //
          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                             IID_IDirectoryObject, (PVOID*)&spDsObj);
          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, strDC);

        CHECK_HRESULT(hr, return hr);

        hr = m_pDispSpec->SetServer(strDC, NULL, NULL, 0);

        CHECK_HRESULT(hr, return hr);
    }
    if (ppDispSpec)
    {
        *ppDispSpec = m_pDispSpec;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::GetADsPathname
//
//  Synopsis:   If needed, create the interface instance and return the pointer.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::GetADsPathname(CComPtr<IADsPathname>& refADsPath)
{
    HRESULT hr;

    if (!m_pADsPath)
    {
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&m_pADsPath);

        CHECK_HRESULT(hr, return hr);
    }
    refADsPath = m_pADsPath;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::SkipPrefix
//
//  Synopsis:   Given an object name, returns a buffer containing the same
//              name without the provider/server prefix. The buffer must be
//              freed using delete.
//
//  Notes: The fX500 parameter defaults to true and applies whenever the
//         input path uses the LDAP provider prefix. The path cracker
//         interface can be used to strip the prefix in this case. However,
//         if the provider is WINNT, then the path cracker doesn't give the
//         desired results so simple string manipulation is used instead.
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::SkipPrefix(PWSTR pwzObj, PWSTR * ppResult, BOOL fX500)
{
    if (fX500)
    {
        // Strip of the "LDAP://" prefix using the path cracker.
        //
        CComPtr<IADsPathname> spPathname;
        HRESULT hr = GetADsPathname(spPathname);

        CHECK_HRESULT(hr, return hr);

        hr = spPathname->Set(pwzObj, ADS_SETTYPE_FULL);

        CHECK_HRESULT(hr, return hr);

        BSTR bstr;

        hr = spPathname->Retrieve(ADS_FORMAT_X500_DN, &bstr);

        CHECK_HRESULT(hr, return hr);

        if (!AllocWStr(bstr, ppResult))
        {
            SysFreeString(bstr);
            return E_OUTOFMEMORY;
        }

        SysFreeString(bstr);
    }
    else
    {
        // Strip off the "WINNT://" prefix.
        //
        if (wcslen(pwzObj) < 9 || pwzObj[7] != L'/')
        {
            // Can't be a valid WINNT name if not at least "WINNT://x"
            //
            return E_INVALIDARG;
        }
        
        if (!AllocWStr(&pwzObj[8], ppResult))
        {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::AddLdapPrefix
//
//  Synopsis:   Given an object name, returns same name with the LDAP provider
//              prefix. The server name is also added by default.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::AddLDAPPrefix(PWSTR pwzObj, CStrW &pstrResult, BOOL fServer)
{
    return ::AddLDAPPrefix(this, pwzObj, pstrResult, fServer);
}

//
// Non-class member version.
//
HRESULT
AddLDAPPrefix(CDsPropPageBase * pPage, PWSTR pwzObj, CStrW &strResult,
              BOOL fServer)
{
    HRESULT hr;
    CComPtr<IADsPathname> spPathCracker;
    strResult.Empty();

    if (pPage)
    {
        hr = pPage->GetADsPathname(spPathCracker);

        CHECK_HRESULT(hr, return hr);
    }
    else
    {
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&spPathCracker);

        CHECK_HRESULT(hr, return hr);
    }

    hr = spPathCracker->Set(L"LDAP", ADS_SETTYPE_PROVIDER);

    CHECK_HRESULT(hr, return hr);

    if (pPage)
    {
        CStrW strDC;

        CComPtr<IDirectoryObject> spDsObj;
        if (pPage->m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          //
          // Get the objects path 
          //
          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                             IID_IDirectoryObject, (PVOID*)&spDsObj);
          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = pPage->m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, strDC);

        CHECK_HRESULT(hr, return hr);

        hr = spPathCracker->Set(const_cast<PWSTR>((LPCWSTR)strDC), ADS_SETTYPE_SERVER);

        CHECK_HRESULT(hr, return hr);
    }

    hr = spPathCracker->Set(pwzObj, ADS_SETTYPE_DN);

    CHECK_HRESULT(hr, return hr);

    CComBSTR bstr;

    hr = spPathCracker->Retrieve((fServer) ? ADS_FORMAT_X500 : ADS_FORMAT_X500_NO_SERVER,
                                &bstr);

    CHECK_HRESULT(hr, return hr);

    strResult = bstr;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::GetObjSel
//
//  Synopsis:   CoCreates the object picker if needed, returns the pointer.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPageBase::GetObjSel(IDsObjectPicker ** ppObjSel, PBOOL pfIsInited)
{
    HRESULT hr;
    TRACE2(CDsPropPageBase,GetObjSel);

    if (!m_pObjSel)
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker, (PVOID *)&m_pObjSel);
        if (FAILED(hr))
        {
            REPORT_ERROR(hr, m_hPage);
            return hr;
        }
    }

    *ppObjSel = m_pObjSel;

    if (pfIsInited)
    {
        *pfIsInited = m_fObjSelInited;
    }

    return S_OK;
}

#ifdef DO_HELP
#include "helpids.h"
#endif

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPageBase::OnHelp(LPHELPINFO pHelpInfo)
{
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(m_hPage, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
#ifdef DONT_DO_THIS
    WinHelp((HWND)pHelpInfo->hItemHandle, DSPROP_HELP_FILE_NAME, HELP_WM_HELP, (DWORD)g_aHelpIDs);
#endif

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::PageCallback
//
//  Synopsis:   Callback used to free the CDsPropPageBase object when the
//              property sheet has been destroyed.
//
//-----------------------------------------------------------------------------
UINT CALLBACK
CDsPropPageBase::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    TRACE_FUNCTION(CDsPropPageBase::PageCallback);

    if (uMsg == PSPCB_RELEASE)
    {
        //
        // Determine instance that invoked this static function
        //
        CDsPropPageBase * pPage = (CDsPropPageBase *) ppsp->lParam;

        //
        // Call all function pointers so that they can do any needed cleanup.
        //
        if (SUCCEEDED(pPage->m_hrInit))
        {
            for (DWORD i = 0; i < pPage->m_cAttrs; i++)
            {
                if (pPage->m_rgpAttrMap[i]->pAttrFcn)
                {
                    (*pPage->m_rgpAttrMap[i]->pAttrFcn)(pPage,
                                                        pPage->m_rgpAttrMap[i],
                                                        NULL, 0,
                                                        &pPage->m_rgAttrData[i],
                                                        fOnCallbackRelease);
                }
            }
        }

        if (IsWindow(pPage->m_hNotifyObj))
        {
            SendMessage(pPage->m_hNotifyObj, WM_ADSPROP_NOTIFY_EXIT, 0, 0);
        }

        // Release on same thread on which created.
        //
        DO_RELEASE(pPage->m_pWPTDataObj);

        //DBG_OUT("-----------------------releasing object in page callback.");
        DO_RELEASE(pPage->m_pDsObj);

        dspDebugOut((DEB_ITRACE, "Deleting CDsPropPageBase instance 0x%x\n",
                     pPage));

        pPage->Release();

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageBase::QueryInterface(REFIID riid, void ** ppvObject)
{
    TRACE2(CDsPropPageBase,QueryInterface);
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageBase::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPageBase::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageBase::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageBase::Release(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPageBase::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetLdapServerName
//
//  Synopsis:   Given an IDirectoryObject* that supports IADsObjectOptions, it
//              returns the server name ADSI is bound to.
//
//-----------------------------------------------------------------------------
HRESULT
GetLdapServerName(IUnknown * pDsObj, CStrW& strServer)
{
    HRESULT hr;

    strServer.Empty();

    CComPtr<IADsObjectOptions> spIADsObjectOptions;

    hr = pDsObj->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);

    CHECK_HRESULT(hr, return hr);

    CComVariant var;
    hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);

    CHECK_HRESULT(hr, return hr);

    dspAssert(var.vt == VT_BSTR);
    strServer = V_BSTR(&var);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   BindToGCcopyOfObj
//
//  Synopsis:   Bind to the GC copy of the object.
//
//-----------------------------------------------------------------------------
HRESULT
BindToGCcopyOfObj(CDsPropPageBase * pPage, PWSTR pwzObjADsPath,
                  IDirectoryObject ** ppDsObj)
{
    CSmartWStr cswzCleanObj;
    PWSTR pwzDnsDom;
    PDOMAIN_CONTROLLER_INFOW pDCInfo;
    HRESULT hr = pPage->SkipPrefix(pwzObjADsPath, &cswzCleanObj);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    // To bind to a GC, you need to supply the tree root domain name rather
    // than the server path because the current DC/domain may not be hosting a
    // GC.
    //
    hr = CrackName(cswzCleanObj, &pwzDnsDom, GET_DNS_DOMAIN_NAME, pPage->GetHWnd());

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    DWORD dwErr = DsGetDcNameW(NULL,
                               pwzDnsDom,
                               NULL,NULL,
                               DS_DIRECTORY_SERVICE_REQUIRED,
                               &pDCInfo);
    LocalFreeStringW(&pwzDnsDom);
    hr = HRESULT_FROM_WIN32(dwErr);
    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    CComPtr<IADsPathname> spADsPath;
    long lEscapeMode;

    hr = pPage->GetADsPathname(spADsPath);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    spADsPath->get_EscapedMode(&lEscapeMode);

    hr = spADsPath->Set(L"GC", ADS_SETTYPE_PROVIDER);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = spADsPath->Set(pDCInfo->DnsForestName, ADS_SETTYPE_SERVER);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    NetApiBufferFree(pDCInfo);

    hr = spADsPath->Set(cswzCleanObj, ADS_SETTYPE_DN);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    spADsPath->put_EscapedMode(ADS_ESCAPEDMODE_ON);

    CComBSTR bstrEscapedPath;

    hr = spADsPath->Retrieve(ADS_FORMAT_X500, &bstrEscapedPath);

    // restore defaults
    spADsPath->Set(L"LDAP", ADS_SETTYPE_PROVIDER);
    spADsPath->put_EscapedMode(lEscapeMode);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    dspDebugOut((DEB_ITRACE, "Binding to object at %ws\n", bstrEscapedPath));

    hr = ADsOpenObject(bstrEscapedPath, NULL, NULL,
                       ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (PVOID*)ppDsObj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\proppage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proppage.h
//
//  Contents:   DS object property pages class header
//
//  Classes:    CDsPropPagesHost, CDsPropPagesHostCF, CDsTableDrivenPage
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _PROPPAGE_H_
#define _PROPPAGE_H_

#include "adsprop.h"
#include "pages.h"
#include "strings.h"
#include "notify.h"

#define DSPROP_HELP_FILE_NAME TEXT("adprop.hlp")

#define ADM_S_SKIP  MAKE_HRESULT(SEVERITY_SUCCESS, 0, (PSNRET_INVALID_NOCHANGEPAGE + 2))

#define DSPROP_DESCRIPTION_RANGE_UPPER  1024

struct _DSPAGE; // forward declaration.

class CDsPropPagesHost; // forward declaration.
class CDsPropPageBase;  // forward declaration.

// Prototype for page creation function. The function should return S_FALSE if
// the page shouldn't be created due to a non-error condition.
//
typedef HRESULT (*CREATE_PAGE)(struct _DSPAGE * pDsPage, LPDATAOBJECT pDataObj,
                               PWSTR pwzObjDN, PWSTR pwszObjName,
                               HWND hNotifyWnd, DWORD dwFlags,
                               CDSBasePathsInfo* pBasePathsInfo,
                               HPROPSHEETPAGE * phPage);

typedef enum _DlgOp {
    fInit = 0,
    fApply,
    fOnCommand,
    fOnNotify,
    fOnDestroy,
    fOnCallbackRelease,
    fObjChanged,
    fAttrChange,
    fQuerySibling,
    fOnSetActive,
    fOnKillActive
} DLG_OP;

//+----------------------------------------------------------------------------
//
//  Struct:     ATTR_DATA
//
//  Purpose:    Per-Attribute data. The ATTR_DATA_WRITABLE bit is set if the
//              corresponding attribute is found in the Allowed-Attributes-
//              Effective list. The pAttrData struct pointer is passed to the
//              attr function where it can use the pVoid member for its private
//              storage needs.
//
//-----------------------------------------------------------------------------
typedef struct _ATTR_DATA {
    DWORD   dwFlags;
    LPARAM  pVoid;
} ATTR_DATA, * PATTR_DATA;

#define ATTR_DATA_WRITABLE  (0x00000001)
#define ATTR_DATA_DIRTY     (0x00000002)

#define ATTR_DATA_IS_WRITABLE(ad) (ad.dwFlags & ATTR_DATA_WRITABLE)
#define PATTR_DATA_IS_WRITABLE(pad) (pad->dwFlags & ATTR_DATA_WRITABLE)
#define ATTR_DATA_IS_DIRTY(ad) (ad.dwFlags & ATTR_DATA_DIRTY)
#define PATTR_DATA_IS_DIRTY(pad) (pad->dwFlags & ATTR_DATA_DIRTY)
#define ATTR_DATA_SET_WRITABLE(ad) (ad.dwFlags |= ATTR_DATA_WRITABLE)
#define PATTR_DATA_SET_WRITABLE(pad) (pad->dwFlags |= ATTR_DATA_WRITABLE)
#define ATTR_DATA_CLEAR_WRITABLE(ad) (ad.dwFlags &= ~ATTR_DATA_WRITABLE)
#define PATTR_DATA_CLEAR_WRITABLE(pad) (pad->dwFlags &= ~ATTR_DATA_WRITABLE)
#define ATTR_DATA_SET_DIRTY(ad) (ad.dwFlags |= ATTR_DATA_DIRTY)
#define PATTR_DATA_SET_DIRTY(pad) (pad->dwFlags |= ATTR_DATA_DIRTY)
#define ATTR_DATA_CLEAR_DIRTY(ad) (ad.dwFlags &= ~ATTR_DATA_DIRTY)
#define PATTR_DATA_CLEAR_DIRTY(pad) (pad->dwFlags &= ~ATTR_DATA_DIRTY)

struct _ATTR_MAP; // forward declaration.

typedef HRESULT (*PATTR_FCN)(CDsPropPageBase *, struct _ATTR_MAP *,
                             PADS_ATTR_INFO, LPARAM, PATTR_DATA, DLG_OP);

//+----------------------------------------------------------------------------
//
//  Struct:     ATTR_MAP
//
//  Purpose:    For each attribute on a property page, relates the control
//              ID, the attribute name and the attribute type.
//
//  Notes:      The standard table-driven processing assumes that nCtrlID is
//              valid unless pAttrFcn is defined, in which case the attr
//              function may choose to hard code the control ID.
//
//-----------------------------------------------------------------------------
typedef struct _ATTR_MAP {
    int             nCtrlID;        // Control resource ID
    BOOL            fIsReadOnly;
    BOOL            fIsMultiValued; // From schema.ini: Is-Single-Valued
    DWORD           nSizeLimit;
    ADS_ATTR_INFO   AttrInfo;
    PATTR_FCN       pAttrFcn;       // Optional function pointer.
    PVOID           pData;
} ATTR_MAP, * PATTR_MAP;

//+----------------------------------------------------------------------------
//
//  Struct:     DSPAGE
//
//  Purpose:    For each property page, lists the page title resource ID, the
//              page dialog templage ID, flags, the count and list of CLSIDs
//              for which this page should be shown, a pointer to a
//              page-class-specific creation function, and the count and list
//              of attributes. If nCLSIDs is zero, then the page should always
//              be shown.
//
//-----------------------------------------------------------------------------
typedef struct _DSPAGE {
    int             nPageTitle;
    int             nDlgTemplate;
    DWORD           dwFlags;
    DWORD           nCLSIDs;
    const CLSID   * rgCLSID;
    CREATE_PAGE     pCreateFcn;
    DWORD           cAttrs;
    PATTR_MAP     * rgpAttrMap;
} DSPAGE, * PDSPAGE;

//+----------------------------------------------------------------------------
//
//  Struct:     DSCLASSPAGES
//
//  Purpose:    For each CLSID, lists the prog ID, the number of pages, and the
//              list of pages.
//
//-----------------------------------------------------------------------------
typedef struct _DSCLASSPAGES {
    const CLSID * pcid;
    LPTSTR        szProgID;
    DWORD         cPages;
    PDSPAGE     * rgpDsPages;
} DSCLASSPAGES, * PDSCLASSPAGES;

//+----------------------------------------------------------------------------
//
//  Struct:     RGDSPPCLASSES
//
//  Purpose:    Contains the count and list of classes supported by this DLL.
//
//-----------------------------------------------------------------------------
typedef struct _RGDSPPCLASSES {
    int             cClasses;
    PDSCLASSPAGES * rgpClass;
} RGDSPPCLASSES, * PRGDSPPCLASSES;

// Table driven page creation function.
//
HRESULT
CreateTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzObjName,
                      HWND hNotifyWnd, DWORD dwFlags, 
                      CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE * phPage);

/*
HRESULT
CreateScheduleObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      LPWSTR pwszObjName, LPWSTR pwszClass,
                      HWND hNotifyWnd, DWORD dwFlags, HPROPSHEETPAGE * phPage);
*/

// Object page attribute function for object class.
//
HRESULT
GetObjectClass(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

// Object page attribute function for object timestamps.
//
HRESULT
GetObjectTimestamp(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                   PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                   DLG_OP DlgOp);

HRESULT
ObjectPathField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);

// FPO general page attribute function for finding account name from the SID.
//
HRESULT
GetAcctName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp);

// General-purpose attribute function for ES_NUMBER edit controls with
// associated spin button.  This must always be accompanied by a "msctls_updown32"
// control with the SpinButton attribute function.  Set ATTR_MAP.pData to the
// controlID of the associated spin button.
//
HRESULT
EditNumber(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// General-purpose READONLY attribute function for spin buttons accompaying EditNumber
// edit controls.  If you wish to limit the spinbutton range, set ATTR_MAP.nSizeLimit
// to the high end of the range and ATTR_MAP.pData to the low end of the range.
//
HRESULT
SpinButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// Special-purpose attribute function for spin buttons to change accelerator
// increment.  Use this as READONLY for controls which already have a
// SpinButton attribute function.  Set ATTR_MAP.pData to the integer
// multiple, e.g. 15 to move in increments of 15.
//
HRESULT
SpinButtonExtendIncrement(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// Special-purpose read-only attribute functions to pick apart a subnet mask and
// fill in an IP Address Control (WC_IPADDRESS)
HRESULT
SubnetExtractAddress(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);
HRESULT
SubnetExtractMask(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

//
// read-only attribute function to calculate the DNS alias of an NTDSDSA
//
HRESULT
NTDSDSA_DNSAlias(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);

// helper function to delete pADsValues (tablpage.cxx)
void HelperDeleteADsValues( PADS_ATTR_INFO pAttrs );

// global definitions
extern HINSTANCE g_hInstance;
extern RGDSPPCLASSES g_DsPPClasses;
extern CLIPFORMAT g_cfDsObjectNames;
extern CLIPFORMAT g_cfDsDispSpecOptions;
extern CLIPFORMAT g_cfShellIDListArray;
extern CLIPFORMAT g_cfMMCGetNodeType;
extern CLIPFORMAT g_cfDsPropCfg;
extern CLIPFORMAT g_cfDsSelList;
extern CLIPFORMAT g_cfDsMultiSelectProppages;
//extern CLIPFORMAT g_cfMMCGetCoClass;
extern UINT g_uChangeMsg;
extern int g_iInstance;

#ifndef DSPROP_ADMIN
extern CRITICAL_SECTION g_csNotifyCreate;
#endif

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPagesHost
//
//  Purpose:    property pages host object class
//
//-----------------------------------------------------------------------------
class CDsPropPagesHost : public IShellExtInit, IShellPropSheetExt
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif
    CDsPropPagesHost(PDSCLASSPAGES pDsPP);
    ~CDsPropPagesHost();

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // IShellExtInit methods
    //
    STDMETHOD(Initialize)(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                          HKEY hKeyID );

    //
    // IShellPropSheetExt methods
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc,
                           LPARAM lParam);

private:

    PDSCLASSPAGES       m_pDsPPages;
    LPDATAOBJECT        m_pDataObj;
    HWND                m_hNotifyObj;
    STGMEDIUM           m_ObjMedium;
    unsigned long       m_uRefs;
    CDllRef             m_DllRef;
};

typedef struct _ApplyErrorEntry
{
  PWSTR     pszPath;          // Path to the object that had the error
  PWSTR     pszClass;         // Class of the object that had the error
  HRESULT   hr;               // HRESULT of the error (if 0 then pszStringError must not be NULL)
  PWSTR     pszStringError;   // User defined string error (used only if hr == NULL)
} APPLY_ERROR_ENTRY, *PAPPLY_ERROR_ENTRY;

//+----------------------------------------------------------------------------
//
//  Class:      CADsApplyErrors
//
//  Purpose:    contains an association between DS objects and errors that
//              occurred while doing an apply
//
//-----------------------------------------------------------------------------
class CADsApplyErrors
{
public:
  CADsApplyErrors() 
    : m_nArraySize(0),
      m_nCount(0),
      m_nIncAmount(5),
      m_pErrorTable(NULL),
      m_hWndPage(NULL),
      m_pszTitle(NULL)
  {}
  ~CADsApplyErrors();

  void      SetError(PADSPROPERROR pError);
  HRESULT   GetError(UINT nIndex);
  PWSTR     GetStringError(UINT nIndex);
  PWSTR     GetName(UINT nIndex);
  PWSTR     GetClass(UINT nIndex);
  HWND      GetPageHwnd() { return m_hWndPage; }
  UINT      GetCount() { return m_nCount; }
  UINT      GetErrorCount() { return m_nCount; }
  PWSTR     GetPageTitle() { return m_pszTitle; }

  void      Clear();

private:
  PAPPLY_ERROR_ENTRY  m_pErrorTable;
  UINT                m_nCount;
  HWND                m_hWndPage;
  PWSTR               m_pszTitle;

  UINT                m_nArraySize;
  UINT                m_nIncAmount;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPageBase
//
//  Purpose:    property page object base class
//
//-----------------------------------------------------------------------------
class CDsPropPageBase : public IUnknown
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsPropPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyWnd,
                    DWORD dwFlags);
    virtual ~CDsPropPageBase(void);

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    //  Static WndProc to be passed to CreateWindow
    //
    static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                      WPARAM wParam, LPARAM lParam);
    //
    //  Instance specific wind proc
    //
    virtual LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                            LPARAM lParam) = 0;

    void Init(PWSTR pwzADsPath, PWSTR pwzClass, CDSBasePathsInfo* pBasePathsInfo);
    HRESULT CreatePage(HPROPSHEETPAGE * phPage);
    const LPWSTR GetObjPathName(void) {return m_pwszObjPathName;};
    const LPWSTR GetObjRDName(void) {return m_pwszRDName;};
    const LPWSTR GetObjClass(void) {return m_pwszObjClass;};
    HWND GetHWnd(void) {return m_hPage;};
    void SetDirty(BOOL fFullDirty = TRUE) {
             m_fPageDirty = TRUE;
             if (fFullDirty)
             {
                PropSheet_Changed(GetParent(m_hPage), m_hPage);
                EnableWindow(GetDlgItem(GetParent(m_hPage), IDCANCEL), TRUE);
             }
         };
    BOOL IsDirty() {return m_fPageDirty;}
    LRESULT OnHelp(LPHELPINFO pHelpInfo);

    virtual BOOL IsMultiselectPage() { return m_fMultiselectPage; }
    CDSBasePathsInfo* GetBasePathsInfo() { return m_pBasePathsInfo; }

protected:
    static  UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);
    //
    //  Member functions, called by WndProc
    //
    LRESULT InitDlg(LPARAM lParam);
    virtual HRESULT OnInitDialog(LPARAM lParam) = 0;
    virtual LRESULT OnApply(void) = 0;
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnCancel(void);
    LRESULT OnSetFocus(HWND hwndLoseFocus);
    LRESULT OnShowWindow(void);
    LRESULT OnDestroy(void);
    LRESULT OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    LRESULT OnPSNSetActive(LPARAM lParam);
    LRESULT OnPSNKillActive(LPARAM lParam);
    LRESULT OnDoInit();

    void    CheckIfPageAttrsWritable(void);
    BOOL    CheckIfWritable(const PWSTR & wzAttr);


public:
    HRESULT GetObjSel(IDsObjectPicker ** ppObjSel, PBOOL pfIsInited = NULL);
    void    ObjSelInited(void) {m_fObjSelInited = TRUE;};
    HRESULT SkipPrefix(PWSTR pwzObj, PWSTR * ppResult, BOOL fX500 = TRUE);
    HRESULT AddLDAPPrefix(PWSTR pwzObj, CStrW &pstrResult, BOOL fServer = TRUE);
    HRESULT GetADsPathname(CComPtr<IADsPathname>& refADsPath);
    HRESULT GetIDispSpec(IDsDisplaySpecifier ** ppDispSpec);
    BOOL    IsReadOnly(void) {return m_fReadOnly;};

    BOOL    SendErrorMessage(PADSPROPERROR pError)
    {
      return ADsPropSendErrorMessage(m_hNotifyObj, pError);
    }
    //
    //  Data members
    //
public:
    LPDATAOBJECT        m_pWPTDataObj;  // Wnd Proc Thread Data Obj.
    IDirectoryObject  * m_pDsObj;

protected:
    HWND                m_hPage;
    BOOL                m_fInInit;
    BOOL                m_fPageDirty;
    BOOL                m_fReadOnly;
    BOOL                m_fMultiselectPage;
    LPDATAOBJECT        m_pDataObj;     // Marshalled to the wndproc thread.
    LPSTREAM            m_pDataObjStrm; // Used to marshal data obj pointer.
    int                 m_nPageTitle;
    int                 m_nDlgTemplate;
    DWORD               m_cAttrs;
    PATTR_MAP         * m_rgpAttrMap;
    PWSTR               m_pwszObjPathName;
    PWSTR               m_pwszObjClass;
    PWSTR               m_pwszRDName;
    CDllRef             m_DllRef;
    CComPtr<IADsPathname> m_pADsPath;
    IDsObjectPicker   * m_pObjSel;
    IDsDisplaySpecifier * m_pDispSpec;
    BOOL                m_fObjSelInited;
    PATTR_DATA          m_rgAttrData;
    unsigned long       m_uRefs;
    HWND                m_hNotifyObj;
    PADS_ATTR_INFO      m_pWritableAttrs;
    HRESULT             m_hrInit;

    CDSBasePathsInfo*   m_pBasePathsInfo;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsTableDrivenPage
//
//  Purpose:    property page object class for table-driven attributes
//
//-----------------------------------------------------------------------------
class CDsTableDrivenPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyWnd,
                       DWORD dwFlags);
    ~CDsTableDrivenPage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL SetNamedAttrDirty( LPCWSTR pszAttrName );

protected:
    void SetDirty(DWORD i) {
        ATTR_DATA_SET_DIRTY(m_rgAttrData[i]);
        CDsPropPageBase::SetDirty();
    }

    LRESULT OnDestroy(void);
private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnObjChanged(void);
    LRESULT OnAttrChanged(WPARAM wParam);
    LRESULT OnQuerySibs(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

    HRESULT ReadAttrsSetCtrls(DLG_OP DlgOp);

    //
    //  Data members
    //
public:
    LPARAM   m_pData;
};

/*
//+----------------------------------------------------------------------------
//
//  Class:      CDsReplSchedulePage
//
//  Purpose:    property page object class for the schedule attribute.
//
//-----------------------------------------------------------------------------
class CDsReplSchedulePage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsReplSchedulePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, DWORD dwFlags);
    ~CDsReplSchedulePage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT GetServerName(void);

private:
    LRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnDestroy(void);

    //
    //  Data members
    //
    LPWSTR  m_pwszLdapServer;
};
*/

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPagesHostCF
//
//  Purpose:    object class factory
//
//-----------------------------------------------------------------------------
class CDsPropPagesHostCF : public IClassFactory
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif
    CDsPropPagesHostCF(PDSCLASSPAGES pDsPP);
    ~CDsPropPagesHostCF();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid,
                              void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

    static IClassFactory * Create(PDSCLASSPAGES pDsPP);

private:

    PDSCLASSPAGES   m_pDsPP;
    unsigned long   m_uRefs;
    CDllRef         m_DllRef;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropDataObj
//
//  Purpose:    Data object for property pages.
//
//  Notes:      This is not a first class COM object since there is no class
//              factory.
//
//-----------------------------------------------------------------------------
class CDsPropDataObj : public IDataObject
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif
    CDsPropDataObj(HWND hwndParentPage,
                   BOOL fReadOnly);
    ~CDsPropDataObj(void);

    HRESULT Init(LPWSTR pwszObjName, LPWSTR pwszClass);

    HRESULT Init(PDS_SELECTION_LIST pSelectionList);

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // Standard IDataObject methods
    //
    // Implemented
    //
    STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);

    // Not Implemented
private:
    STDMETHOD(QueryGetData)(FORMATETC*)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *,
                                     FORMATETC *)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD,
                             LPENUMFORMATETC *)
    { return E_NOTIMPL; };

    STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(FORMATETC *, STGMEDIUM *,
                       BOOL)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(FORMATETC *, DWORD,
                       IAdviseSink *, DWORD *)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(IEnumSTATDATA **)
    { return E_NOTIMPL; };

    BOOL                m_fReadOnly;
    PWSTR               m_pwszObjName;
    PWSTR               m_pwszObjClass;
    HWND                m_hwndParent;
    unsigned long       m_uRefs;
    PDS_SELECTION_LIST  m_pSelectionList;
};

//+----------------------------------------------------------------------------
//
//  Function:   PostPropSheet
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//-----------------------------------------------------------------------------
HRESULT
PostPropSheet(PWSTR pwszObj, CDsPropPageBase * pParentPage,
              BOOL fReadOnly = FALSE);
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 HWND hNotifyObj, BOOL fReadOnly);

#include "proputil.h"

#endif // _PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\proputil.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proputil.cxx
//
//  Contents:   CDsPropPagesHost IUnknown and ClassFactory, CDsPropDataObj.
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "notify.h"
#include <propcfg.h> // DS Admin definition of PPROPSHEETCFG
#include <ntdsapip.h>

#include <shlobjp.h> // SHCreatePropertyBag()

//
// This CLSID for the Domain Tree snapin is copied from cdomain.cpp.
//
const CLSID CLSID_DomainAdmin = { /* ebc53a38-a23f-11d0-b09b-00c04fd8dca6 */
    0xebc53a38,
    0xa23f,
    0x11d0,
    {0xb0, 0x9b, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}
};

//BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall);
HRESULT PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                            IDataObject * pParentObj, HWND hwndParent, HWND hNotifyObj, BOOL fReadOnly);

HRESULT PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                            IDataObject * pParentObj, HWND hwndParent, BOOL fReadOnly);

//+----------------------------------------------------------------------------
//
//      CDsPropPagesHost IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHost::QueryInterface(REFIID riid, void ** ppvObject)
{
    TRACE2(CDsPropPagesHost,QueryInterface);
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(LPSHELLEXTINIT)this;
    }
    else if (IID_IShellExtInit == riid)
    {
        *ppvObject = (LPSHELLEXTINIT)this;
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppvObject = (LPSHELLPROPSHEETEXT)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHost::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHost::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHost::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHost::Release(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHost::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CDsPropPagesHostCF - class factory for the CDsPropPagesHost object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CDsPropPagesHostCF::Create(PDSCLASSPAGES pDsPP)
{
    return new CDsPropPagesHostCF(pDsPP);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::CDsPropPagesHostCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CDsPropPagesHostCF::CDsPropPagesHostCF(PDSCLASSPAGES pDsPP) :
    m_pDsPP(pDsPP),
    m_uRefs(1)
{
    TRACE2(CDsPropPagesHostCF,CDsPropPagesHostCF);
#ifdef _DEBUG
    strcpy(szClass, "CDsPropPagesHostCF");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::~CDsPropPagesHostCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CDsPropPagesHostCF::~CDsPropPagesHostCF(void)
{
    TRACE2(CDsPropPagesHostCF,~CDsPropPagesHostCF);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHostCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHostCF::QueryInterface\n"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHostCF::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHostCF::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IUnknown::Release
//
//  Synopsis:   decrement the refcount
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPagesHostCF::Release(void)
{
    dspDebugOut((DEB_USER2, "CDsPropPagesHostCF::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the proppage host class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHostCF::CreateInstance(IUnknown*, REFIID riid,
                                   void **ppvObject)
{
    TRACE2(CDsPropPagesHostCF,CreateInstance);
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    CDsPropPagesHost * pPropPage = new CDsPropPagesHost(m_pDsPP);
    if (pPropPage == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pPropPage->QueryInterface(riid, ppvObject);
    if (FAILED(hr))
    {
        ERR_OUT("CDsPropPagesHostCF::CreateInstance, pPropPage->QueryInterface", hr);
        pPropPage->Release();
        return hr;
    }

    //
    // We got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1.
    //
    pPropPage->Release();
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPagesHostCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPagesHostCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   AllocWStr
//
//  Synopsis:   Creates a copy of the passed in string. Allocates memory for
//              the returned string using new. Callers must free the string
//              memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL AllocWStr(PWSTR pwzStrIn, PWSTR * ppwzNewStr)
{
  if (pwzStrIn == NULL)
  {
    *ppwzNewStr = NULL;
    return TRUE;
  }

  *ppwzNewStr = new WCHAR[wcslen(pwzStrIn) + 1];

  if (NULL == *ppwzNewStr)
  {
    return FALSE;
  }

  wcscpy(*ppwzNewStr, pwzStrIn);

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   AllocTStr
//
//  Synopsis:   Creates a copy of the passed in string. Allocates memory for
//              the returned string using new. Callers must free the string
//              memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL AllocTStr(PTSTR ptzStrIn, PTSTR * pptzNewStr)
{
    *pptzNewStr = new TCHAR[_tcslen(ptzStrIn) + 1];

    if (NULL == *pptzNewStr)
    {
        return FALSE;
    }

    _tcscpy(*pptzNewStr, ptzStrIn);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   UnicodeToTchar
//
//  Synopsis:   Converts a Unicode string to a TCHAR string. Allocates memory
//              for the returned string using new. Callers must free the
//              string memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL UnicodeToTchar(LPWSTR pwszIn, LPTSTR * pptszOut)
{
    size_t len;

#ifdef UNICODE
    len = wcslen(pwszIn);
#else
    len = WideCharToMultiByte(CP_ACP, 0, pwszIn, -1, NULL, 0, NULL, NULL);
#endif
    
    *pptszOut = new TCHAR[len + 1];
    CHECK_NULL(*pptszOut, return FALSE);

#ifdef UNICODE
    wcscpy(*pptszOut, pwszIn);
#else
    if (WideCharToMultiByte(CP_ACP, 0, pwszIn, -1,
                            *pptszOut, len, NULL, NULL) == 0)
    {
        delete *pptszOut;
        return FALSE;
    }
#endif
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   TcharToUnicode
//
//  Synopsis:   Converts a TCHAR string to a Unicode string. Allocates memory
//              for the returned string using new. Callers must free the
//              string memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL TcharToUnicode(LPTSTR ptszIn, LPWSTR * ppwszOut)
{
    size_t len;

#ifdef UNICODE
    len = wcslen(ptszIn);
#else
    len = MultiByteToWideChar(CP_ACP, 0, ptszIn, -1, NULL, 0);
#endif
    
    *ppwszOut = new WCHAR[len + 1];
    CHECK_NULL(*ppwszOut, return FALSE);

#ifdef UNICODE
    wcscpy(*ppwszOut, ptszIn);
#else
    if (MultiByteToWideChar(CP_ACP, 0, ptszIn, -1, *ppwszOut, len) == 0)
    {
        delete *ppwszOut;
        return FALSE;
    }
#endif
    return TRUE;
}



#ifdef _PROVIDE_CFSTR_SHELLIDLIST_FORMAT

// FROM DIZ (dsuiext\query.cpp)

//#if DELEGATE
//WCHAR c_szDsMagicPath[] = L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}";
//#else
WCHAR c_szDsMagicPath[] = L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\EntireNetwork\\::{fe1290f0-cfbd-11cf-a330-00aa00c16e65}";
//#endif


#if !DOWNLEVEL_SHELL
/*-----------------------------------------------------------------------------
/ BindToPath
/ ----------
/   Given a namespace path bind to it returning the shell object
/
/ In:
/   pszPath -> path to bind to
/   riid = interface to request
/   ppvObject -> receives the object pointer
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT BindToPath(LPWSTR pszPath, REFIID riid, LPVOID* ppObject)
{
    HRESULT hres;
    IShellFolder* psfDesktop = NULL;
    LPITEMIDLIST pidl = NULL;

    //TraceEnter(TRACE_VIEW, "BindToPath");

    hres = CoCreateInstance(CLSID_ShellDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IShellFolder, (LPVOID*)&psfDesktop);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get IShellFolder for the desktop object");
        goto exit_gracefully;
    }


    hres = psfDesktop->ParseDisplayName(NULL, NULL, pszPath, NULL, &pidl, NULL);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed when getting root path of DS");
        goto exit_gracefully;
    }
    
    if ( ILIsEmpty(pidl) )
    {
        //TraceMsg("PIDL is desktop, therefore just QIing for interface");
        hres = psfDesktop->QueryInterface(riid, ppObject);
    }
    else
    {
        //TraceMsg("Binding to IDLIST via BindToObject");
        hres = psfDesktop->BindToObject(pidl, NULL, riid, ppObject);
    }

exit_gracefully:

    if ( FAILED(hres) )
        *ppObject = NULL;

    if (psfDesktop)
      psfDesktop->Release();

    ILFree(pidl);
    pidl = NULL;

    return hres;
}
#endif

HRESULT _GetDirectorySF(IShellFolder **ppsf)
{
    HRESULT hres;
    IShellFolder *psf = NULL;
    IDsFolderInternalAPI *pdfi = NULL;
#if DOWNLEVEL_SHELL
    IPersistFolder* ppf = NULL;
#endif

    DWORD _dwFlags = 0;

    //TraceEnter(TRACE_VIEW, "CDsQuery::GetDirectorySF");

#if !DOWNLEVEL_SHELL
    // just bind to the path if this is not a downlevel shell.

    hres = BindToPath(c_szDsMagicPath, IID_IShellFolder, (void **)&psf);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get IShellFolder view of the DS namespace");
        goto exit_gracefully;
    }
#else
    // on the downlevel shell we need to CoCreate the IShellFolder implementation for the
    // DS namespace and initialize it manually

    hres = CoCreateInstance(CLSID_MicrosoftDS, NULL, CLSCTX_INPROC_SERVER, IID_IShellFolder, (void **)&psf);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get the IShellFolder interface we need");
        goto exit_gracefully;
    }
    if ( SUCCEEDED(psf->QueryInterface(IID_IPersistFolder, (void **)&ppf)) )
    {
        ITEMIDLIST idl = { 0 };
        ppf->Initialize(&idl);       // it calls ILCLone, so we are safe with stack stuff
        ppf->Release();
    }
#endif

    // using the internal API set all the parameters for dsfolder

    hres = psf->QueryInterface(IID_IDsFolderInternalAPI, (void **)&pdfi);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get the IDsFolderInternalAPI");
        goto exit_gracefully;
    }

    
    pdfi->SetAttributePrefix((_dwFlags & DSQPF_ENABLEADMINFEATURES) ? DS_PROP_ADMIN_PREFIX:NULL);

    if ( _dwFlags & DSQPF_ENABLEADVANCEDFEATURES )
        pdfi->SetProviderFlags(~DSPROVIDER_ADVANCED, DSPROVIDER_ADVANCED);

#if (FALSE)
    hres = pdfi->SetComputer(_pServer, _pUserName, _pPassword);
    //hres = pdfi->SetComputer(L"marcoc201-50.marcocdev.nttest.microsoft.com", NULL, NULL);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed when setting credential information to be used");
        goto exit_gracefully;
    }
#endif

exit_gracefully:
    
    if ( SUCCEEDED(hres) )
        psf->QueryInterface(IID_IShellFolder, (void **)ppsf);

    if (psf)
      psf->Release();
    if (pdfi)
      pdfi->Release();

    return hres;

}



/*-----------------------------------------------------------------------------
/ CDsQuery::_ADsPathToIdList
/ --------------------------
/   Convert an ADsPath into an IDLIST that is suitable for the DS ShellFolder
/   implementation.
/
/ In:
/   ppidl -> receives the resulting IDLIST
/   pPath = name to be parsed / = NULL then generate only the root of the namespace
/   pObjectClass = class to use
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT _ADsPathToIdList(LPITEMIDLIST* ppidl, LPWSTR pPath, LPWSTR pObjectClass)
{
    HRESULT hres;
    IBindCtx *pbc = NULL;
    IPropertyBag *ppb = NULL;
    IShellFolder *psf = NULL;
    VARIANT var;
    USES_CONVERSION;
    
    *ppidl = NULL;                  // incase we fail
                                       
    // if we have an object class then create a bind context containing it

    if ( pObjectClass )
    {
        // create a property bag
      hres = ::SHCreatePropertyBag(IID_IPropertyBag, (void **)&ppb);
        if (FAILED(hres))
        {
            //FailGracefully(hres, "Failed to create a property bag");
            goto exit_gracefully;
        }

        // allocate a variant BSTR and set it
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = ::SysAllocString(pObjectClass);

        if ( V_BSTR(&var) )
        {
            ppb->Write(DS_PDN_OBJECTLCASS, &var);
            ::VariantClear(&var);
        }

        hres = CreateBindCtx(0, &pbc);
        if (FAILED(hres))
        {
            //FailGracefully(hres, "Failed to create the BindCtx object");
            goto exit_gracefully;
        }

        hres = pbc->RegisterObjectParam(DS_PDN_PROPERTYBAG, ppb);
        if (FAILED(hres))
        {
            //FailGracefully(hres, "Failed to register the property bag with bindctx");
            goto exit_gracefully;
        }

    }

    hres = _GetDirectorySF(&psf);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to get ShellFolder for DS namespace");
        goto exit_gracefully;
    }

    hres = psf->ParseDisplayName(NULL, pbc, pPath, NULL, ppidl, NULL);
    if (FAILED(hres))
    {
        //FailGracefully(hres, "Failed to parse the name");
        goto exit_gracefully;
    }

exit_gracefully:

    if (pbc)
      pbc->Release();
    if (ppb)
      ppb->Release();
    if (psf)
      psf->Release();

    return hres;
}

#endif // _PROVIDE_CFSTR_SHELLIDLIST_FORMAT


//+----------------------------------------------------------------------------
//
//  Class:  CDsPropDataObj
//
//-----------------------------------------------------------------------------

CDsPropDataObj::CDsPropDataObj(HWND hwndParentPage,
                               BOOL fReadOnly) :
    m_fReadOnly(fReadOnly),
    m_pwszObjName(NULL),
    m_pwszObjClass(NULL),
    m_hwndParent(hwndParentPage),
    m_uRefs(1),
    m_pSelectionList(NULL)
{
#ifdef _DEBUG
    strcpy(szClass, "CDsPropDataObj");
#endif
    dspDebugOut((DEB_USER15, "dsprop's CDsPropDataObj::CDsPropDataObj 0x%x\n", this));
}

CDsPropDataObj::~CDsPropDataObj(void)
{
  if (m_pwszObjName)
  {
    delete m_pwszObjName;
  }
  if (m_pwszObjClass)
  {
    delete m_pwszObjClass;
  }

  if (m_pSelectionList != NULL)
  {
    for (ULONG idx = 0; idx < m_pSelectionList->cItems; idx++)
    {
      if (m_pSelectionList->aDsSelection[idx].pwzName != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzName;
        m_pSelectionList->aDsSelection[idx].pwzName = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzADsPath != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzADsPath;
        m_pSelectionList->aDsSelection[idx].pwzADsPath = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzClass != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzClass;
        m_pSelectionList->aDsSelection[idx].pwzClass = NULL;
      }
    }
    delete m_pSelectionList;
    m_pSelectionList = NULL;
  }

}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropDataObj::Init
//
//  Synopsis:   Second phase of object creation where failable operations are
//              performed.
//
//-----------------------------------------------------------------------------
HRESULT CDsPropDataObj::Init(LPWSTR pwszObjName, LPWSTR pwszClass)
{
  if (!pwszObjName || *pwszObjName == L'\0')
  {
    return E_INVALIDARG;
  }
  if (!pwszClass || *pwszClass == L'\0')
  {
    return E_INVALIDARG;
  }
  m_pwszObjName = new WCHAR[wcslen(pwszObjName) + 1];
  CHECK_NULL(m_pwszObjName, return E_OUTOFMEMORY);
  wcscpy(m_pwszObjName, pwszObjName);

  m_pwszObjClass = new WCHAR[wcslen(pwszClass) + 1];
  CHECK_NULL(m_pwszObjClass, return E_OUTOFMEMORY);
  wcscpy(m_pwszObjClass, pwszClass);

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropDataObj::Init
//
//  Synopsis:   Second phase of object creation where failable operations are
//              performed.
//
//-----------------------------------------------------------------------------
HRESULT CDsPropDataObj::Init(PDS_SELECTION_LIST pSelectionList)
{
  HRESULT hr = S_OK;

  if (m_pSelectionList != NULL)
  {
    for (ULONG idx = 0; idx < m_pSelectionList->cItems; idx++)
    {
      if (m_pSelectionList->aDsSelection[idx].pwzName != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzName;
        m_pSelectionList->aDsSelection[idx].pwzName = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzADsPath != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzADsPath;
        m_pSelectionList->aDsSelection[idx].pwzADsPath = NULL;
      }

      if (m_pSelectionList->aDsSelection[idx].pwzClass != NULL)
      {
        delete[] m_pSelectionList->aDsSelection[idx].pwzClass;
        m_pSelectionList->aDsSelection[idx].pwzClass = NULL;
      }
    }
    delete m_pSelectionList;
    m_pSelectionList = NULL;
  }

  m_pSelectionList = pSelectionList;
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropDataObj::IDataObject::GetData
//
//  Synopsis:   Returns data, in this case the Prop Page format data.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropDataObj::GetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium)
{
    TRACE(CDsPropDataObj,GetData);
    if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
    {
        return E_INVALIDARG;
    }
    if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
    {
        return DV_E_TYMED;
    }

    if (pFormatEtc->cfFormat == g_cfDsObjectNames)
    {
        // Return the object name and class.
        //
        size_t cbPath  = sizeof(WCHAR) * (wcslen(m_pwszObjName) + 1);
        size_t cbClass = sizeof(WCHAR) * (wcslen(m_pwszObjClass) + 1);
        size_t cbStruct = sizeof(DSOBJECTNAMES);

        LPDSOBJECTNAMES pDSObj;

        pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                              cbStruct + cbPath + cbClass);
        if (pDSObj == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        pDSObj->clsidNamespace = CLSID_MicrosoftDS;
        pDSObj->cItems = 1;
        pDSObj->aObjects[0].offsetName = static_cast<DWORD>(cbStruct);
        pDSObj->aObjects[0].offsetClass = static_cast<DWORD>(cbStruct + cbPath);
        if (m_fReadOnly)
        {
            pDSObj->aObjects[0].dwFlags = DSOBJECT_READONLYPAGES;
        }
        pDSObj->aObjects[0].dwProviderFlags = 0;

        dspDebugOut((DEB_ITRACE, "returning %ws and %ws\n", m_pwszObjName, m_pwszObjClass));
        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct), m_pwszObjName);
        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct + cbPath), m_pwszObjClass);

        pMedium->hGlobal = (HGLOBAL)pDSObj;
    }
    else if (pFormatEtc->cfFormat == g_cfDsPropCfg)
    {
        // Return the property sheet notification info. In this case, it is
        // the invokding sheet's hwnd.
        //
        PPROPSHEETCFG pSheetCfg;

        pSheetCfg = (PPROPSHEETCFG)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                               sizeof(PROPSHEETCFG));
        if (pSheetCfg == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        ZeroMemory(pSheetCfg, sizeof(PROPSHEETCFG));

        pSheetCfg->hwndParentSheet = m_hwndParent;

        pMedium->hGlobal = (HGLOBAL)pSheetCfg;
    }
#ifdef _PROVIDE_CFSTR_SHELLIDLIST_FORMAT
    else if (pFormatEtc->cfFormat == g_cfShellIDListArray)
    {
        // Return the CFSTR_SHELLIDLIST clipboard format
        LPITEMIDLIST pidl = NULL;
        HRESULT hr = _ADsPathToIdList(&pidl, m_pwszObjName, m_pwszObjClass);
        if (FAILED(hr))
        {
            return hr;
        }
        if (pidl == NULL)
        {
            return E_UNEXPECTED;
        }

        // we have a valid pidl, need to allocate global memory

        // get the count of bytes
        UINT cBytes = sizeof(CIDA) + ILGetSize(pidl) + sizeof(DWORD);

        LPIDA pIDArray = (LPIDA)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                               cBytes);
        if (pIDArray == NULL)
        {
            hr = STG_E_MEDIUMFULL;
        }
        else
        {
            hr = S_OK;
            pIDArray->cidl = 1;
            pIDArray->aoffset[0] = sizeof(CIDA);

            LPBYTE pMem = ((LPBYTE)pIDArray) + sizeof(CIDA);

            // copy the pidl past the CIDA
            ::memcpy(pMem, pidl, ILGetSize(pidl));

            pMem += ILGetSize(pidl);
            // make sure we have a NULL dword past the list
            ::ZeroMemory(pMem, sizeof(DWORD));

            pMedium->hGlobal = (HGLOBAL)pIDArray;
        }

        SHILFree(pidl);
        if (FAILED(hr))
        {
            return hr;
        }
    }
#endif // _PROVIDE_CFSTR_SHELLIDLIST_FORMAT
    else if (pFormatEtc->cfFormat == g_cfDsSelList)
    {
      //
      // Return the selection list for ObjectPicker
      //
      PDS_SELECTION_LIST pSelectionList = NULL;
      if (m_pSelectionList != NULL)
      {
        size_t cbRequired = sizeof(DS_SELECTION_LIST) + 
                            (sizeof(DS_SELECTION) * (m_pSelectionList->cItems - 1));
        pSelectionList = (PDS_SELECTION_LIST)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                                          cbRequired);
        if (pSelectionList == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        ZeroMemory(pSelectionList, cbRequired);

        memcpy(pSelectionList, m_pSelectionList, cbRequired);

        pMedium->hGlobal = (HGLOBAL)pSelectionList;
      }
      else
      {
        size_t cbRequired = sizeof(DS_SELECTION_LIST);
        pSelectionList = (PDS_SELECTION_LIST)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                                          cbRequired);
        if (pSelectionList == NULL)
        {
            return STG_E_MEDIUMFULL;
        }

        ZeroMemory(pSelectionList, cbRequired);
        pMedium->hGlobal = (HGLOBAL)pSelectionList;
      }
    }
    else
    {
        return DV_E_FORMATETC;
    }

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->pUnkForRelease = NULL;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropDataObj::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropDataObj::QueryInterface(REFIID riid, void ** ppvObject)
{
    TRACE2(CDsPropDataObj,QueryInterface);
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IID_IDataObject == riid)
    {
        *ppvObject = this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropDataObj::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropDataObj::AddRef(void)
{
    dspDebugOut((DEB_USER15, "CDsPropDataObj::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropDataObj::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropDataObj::Release(void)
{
    dspDebugOut((DEB_USER15, "CDsPropDataObj::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
      delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//-----------------------------------------------------------------------------
//BOOL CALLBACK
//AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall)
//{
//    HRESULT hr;

//    hr = ((LPPROPERTYSHEETCALLBACK)pCall)->AddPage(hPage);

//    return hr == S_OK;
//}

//+----------------------------------------------------------------------------
//
//  Function:   PostPropSheet, internal; used by CDsPropPageBase members.
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//  Arguments:  [pwzObjDN]   - the DN path of the DS object.
//              [pParentPage] - the invoking page's this pointer.
//              [fReadOnly]   - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostPropSheet(PWSTR pwzObjDN, CDsPropPageBase * pParentPage, BOOL fReadOnly)
{
    HRESULT hr;
    CComPtr<IADsPathname> spADsPath;

    dspDebugOut((DEB_ITRACE, "PostPropSheet passed path %ws\n", pwzObjDN));

    hr = pParentPage->GetADsPathname(spADsPath);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    hr = spADsPath->Set(pwzObjDN, ADS_SETTYPE_DN);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    hr = spADsPath->put_EscapedMode(ADS_ESCAPEDMODE_ON);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    BSTR bstrEscapedPath;

    hr = spADsPath->Retrieve(ADS_FORMAT_X500_DN, &bstrEscapedPath);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    dspDebugOut((DEB_ITRACE, "PostPropSheet escaped path %ws\n", bstrEscapedPath));

    hr = PostPropSheetWorker(pParentPage, bstrEscapedPath,
                             pParentPage->m_pWPTDataObj,
                             pParentPage->GetHWnd(), fReadOnly);

    SysFreeString(bstrEscapedPath);

    CHECK_HRESULT_REPORT(hr, pParentPage->GetHWnd(), return hr);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   PostADsPropSheet, exported from DLL.
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//  Arguments:  [pwzObjDN]   - the full LDAP DN of the DS object.
//              [pParentObj] - the invoking page's MMC data object pointer.
//              [hwndParent] - the invoking page's window handle.
//              [fReadOnly]  - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 BOOL fReadOnly)
{
    return PostPropSheetWorker(NULL, pwzObjDN, pParentObj, hwndParent, fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Function:   PostADsPropSheet, exported from DLL.
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//  Arguments:  [pwzObjDN]   - the full LDAP DN of the DS object.
//              [pParentObj] - the invoking page's MMC data object pointer.
//              [hwndParent] - the invoking page's window handle.
//              [hNotifyObj] - the handle to the notify object window
//              [fReadOnly]  - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 HWND hNotifyObj, BOOL fReadOnly)
{
    return PostPropSheetWorker(NULL, pwzObjDN, pParentObj, hwndParent, hNotifyObj, fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateSecondaryPageInfo
//
//  Synopsis:   Helper for posting a second sheet.
//
//-----------------------------------------------------------------------------
PDSA_SEC_PAGE_INFO CreateSecondaryPageInfo(HWND hwndParent,
                                           LPCWSTR lpszTitle,
                                           LPCWSTR lpszName,
                                           LPCWSTR lpszClass,
                                           BOOL fReadOnly)
{
  // determine memory allocation needs
  size_t nTitleLen = wcslen(lpszTitle)+1;
  size_t nNameLen = wcslen(lpszName)+1;
  size_t nClassLen = wcslen(lpszClass)+1;

  size_t cbStruct = sizeof(DSA_SEC_PAGE_INFO);
  size_t cbStrings = (nTitleLen+nNameLen+nClassLen)*sizeof(WCHAR);

  // allocate memory
  PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo = 
        (PDSA_SEC_PAGE_INFO) ::LocalAlloc(LPTR, (cbStruct + cbStrings));

  if (pDsaSecondaryPageInfo == NULL)
    return NULL;

  // set members

  pDsaSecondaryPageInfo->hwndParentSheet = hwndParent;

  // title string just at the end of the DSA_SEC_PAGE_INFO struct
  pDsaSecondaryPageInfo->offsetTitle = static_cast<DWORD>(cbStruct);
  wcscpy((LPWSTR)((BYTE *)pDsaSecondaryPageInfo + pDsaSecondaryPageInfo->offsetTitle), lpszTitle);


  DSOBJECTNAMES* pDsObjectNames = &(pDsaSecondaryPageInfo->dsObjectNames);
  pDsObjectNames->cItems = 1;

  DSOBJECT* pDsObject = &(pDsObjectNames->aObjects[0]);
  pDsObject->dwFlags = fReadOnly ? DSOBJECT_READONLYPAGES : 0;
  pDsObject->dwProviderFlags = 0; // not set

  // DSOBJECT strings past the DSA_SEC_PAGE_INFO strings
  // offsets are relative to the beginning of DSOBJECT struct
  pDsObject->offsetName = static_cast<DWORD>(sizeof(DSOBJECT) + nTitleLen*sizeof(WCHAR));
  wcscpy((LPWSTR)((BYTE *)pDsObject + pDsObject->offsetName), lpszName);

  pDsObject->offsetClass = static_cast<DWORD>(pDsObject->offsetName + nNameLen*sizeof(WCHAR));
  wcscpy((LPWSTR)((BYTE *)pDsObject + pDsObject->offsetClass), lpszClass);

  return pDsaSecondaryPageInfo;    
}


//+----------------------------------------------------------------------------
//
//  Function:   _WindowsPathFromDN
//
//  Synopsis:   Helper to translate a DN into a windows path
//              for example, from "CN=Joe,OU=test,DN=acme,DN=com"
//              to "LDAP://DN=com/DN=acme/OU=test/CN=Joe
//
//-----------------------------------------------------------------------------

HRESULT
_WindowsPathFromDN(IN PWSTR pwzObjDN, OUT BSTR* pbstrWindowsPath)
{
    // create a path cracker object
    CComPtr<IADsPathname> spIADsPathname;

    HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (void**)&spIADsPathname);
    if (FAILED(hr))
    {
        return hr;
    }

    spIADsPathname->Set(pwzObjDN,ADS_SETTYPE_DN);
    hr = spIADsPathname->Retrieve(ADS_FORMAT_WINDOWS, pbstrWindowsPath);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   PostPropSheetWorker
//
//  Synopsis:   Helper for posting a second sheet.
//
//-----------------------------------------------------------------------------
HRESULT
PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                    IDataObject * pParentObj, HWND hwndParent, BOOL fReadOnly)
{
    HWND hNotifyObj = NULL;
    ::SendMessage(hwndParent, WM_ADSPROP_PAGE_GET_NOTIFY, (WPARAM)&hNotifyObj, 0);
    if (hNotifyObj == NULL)
        return E_UNEXPECTED;

    return PostPropSheetWorker(pParentPage, pwzObjDN, pParentObj, hwndParent, hNotifyObj, fReadOnly);
}

HRESULT
PostPropSheetWorker(CDsPropPageBase * pParentPage, PWSTR pwzObjDN,
                    IDataObject * pParentObj, HWND hwndParent, HWND hNotifyObj, BOOL fReadOnly)
{
    HRESULT hr = S_OK;
    CDsPropDataObj * pDataObj = NULL;

    BSTR bstrName = NULL, bstrClass = NULL;
    BSTR bstrPath = NULL;
    CStrW strADsPath;
    CWaitCursor cWait;
    BOOL fShell = FALSE;
    PWSTR pwszName = NULL;
    CComPtr<IADsPathname> spPathCracker;

    hr = AddLDAPPrefix(pParentPage, pwzObjDN, strADsPath);

    CHECK_HRESULT(hr, return hr);

#ifdef DSADMIN

    // Check to see if a sheet is already posted for this object.
    //
    if (FindSheet(const_cast<PWSTR>((LPCWSTR)strADsPath)))
    {
        return S_OK;
    }

#endif // DSADMIN

    //
    // Activate the object as a test of the path's correctness. Get the
    // naming attribute, class, and schema class GUID while we are at it.
    //
    IADs * pObj = NULL;
    dspDebugOut((DEB_USER1, "Opening prop sheet on '%S'\n", strADsPath));

    hr = ADsOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), NULL, NULL,
                       ADS_SECURE_AUTHENTICATION, IID_IADs, (PVOID *)&pObj);

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        // Display the object-not-found error message.
        //
        TCHAR tzFormat[MAX_ERRORMSG+1], tzTitle[MAX_TITLE+1];
        PTSTR ptzObjDN, ptzMsg;

        LOAD_STRING(IDS_INVALID_NAME_FORMAT, tzFormat, MAX_ERRORMSG, return E_OUTOFMEMORY);
        LOAD_STRING(IDS_MSG_TITLE, tzTitle, MAX_TITLE, return E_OUTOFMEMORY);

        if (!UnicodeToTchar(pwzObjDN, &ptzObjDN))
        {
            return E_OUTOFMEMORY;
        }

        ptzMsg = new TCHAR[_tcslen(ptzObjDN) + _tcslen(tzFormat) + 1];

        CHECK_NULL(ptzMsg, delete ptzObjDN; return E_OUTOFMEMORY);

        wsprintf(ptzMsg, tzFormat, ptzObjDN);

        delete ptzObjDN;

        MessageBox(hwndParent, ptzMsg, tzTitle,
                    MB_ICONEXCLAMATION | MB_OK);

        goto Cleanup;
    }
    if (!CHECK_ADS_HR(&hr, hwndParent))
    {
        goto Cleanup;
    }

    hr = pObj->get_ADsPath(&bstrPath);

    CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

    hr = pObj->get_Class(&bstrClass);

    CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

    pObj->Release();
    pObj = NULL;

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&spPathCracker);
    if (SUCCEEDED(hr))
    {
      hr = spPathCracker->Set(bstrPath, ADS_SETTYPE_FULL);
      if (SUCCEEDED(hr))
      {
        LONG lEscapeMode = 0;
        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        if (SUCCEEDED(hr))
        {
          hr = spPathCracker->get_EscapedMode(&lEscapeMode);
          if (SUCCEEDED(hr))
          {
            hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
            if (SUCCEEDED(hr))
            {
              hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrName);
              dspAssert(bstrName != NULL);
            }
          }
        }

        //
        // Set the display back to full so we don't mess up other instances
        //
        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
        hr = spPathCracker->put_EscapedMode(lEscapeMode);
      }
    }
    //
    // If something went wrong with the path cracker just hack the name
    // ourselves.
    //
    if (bstrName == NULL)
    {
      hr = pObj->get_Name(&bstrName);

      CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

      pwszName = wcschr(bstrName, L'=');
      if (pwszName && (*pwszName != L'\0'))
      {
          pwszName++;
      }
      else
      {
          pwszName = bstrName;
      }
    }
    else
    {
      pwszName = bstrName;
    }

    bool fDomAdmin = false;

    //
    // Are we being called from the shell or from the admin snapin?
    //
    if (!pParentObj)
    {
        fShell = TRUE;
    }
    else
    {
        FORMATETC fmte = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM ObjMedium;
        PDSDISPLAYSPECOPTIONS pDsDispSpecOptions;
        PWSTR pwzAttribPrefix;

        hr = pParentObj->GetData(&fmte, &ObjMedium);

        if (DV_E_FORMATETC == hr)
        {
            fShell = TRUE;
        }
        else
        {
            CHECK_HRESULT(hr, return hr);

            pDsDispSpecOptions = (PDSDISPLAYSPECOPTIONS)ObjMedium.hGlobal;

            pwzAttribPrefix = (PWSTR)ByteOffset(pDsDispSpecOptions,
                                                pDsDispSpecOptions->offsetAttribPrefix);

            if (_wcsicmp(pwzAttribPrefix, DS_PROP_ADMIN_PREFIX) != 0)
            {
                fShell = TRUE;
            }
            ReleaseStgMedium(&ObjMedium);
        }

        fmte.cfFormat = g_cfDsObjectNames;
        fmte.ptd = NULL;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.lindex = -1;
        fmte.tymed = TYMED_HGLOBAL;

        hr = pParentObj->GetData(&fmte, &ObjMedium);

        CHECK_HRESULT(hr, return hr);

        LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)ObjMedium.hGlobal;

        if (IsEqualCLSID(pDsObjectNames->clsidNamespace, CLSID_DomainAdmin))
        {
           fDomAdmin = true;
        }

        ReleaseStgMedium(&ObjMedium);
    }

    if (fShell)
    {
        // the shell uses windows paths, so we have to convert the DN
        //
        BSTR bstrWindowsPath = NULL;
        CStrW strADsWindowsPath;

        hr = _WindowsPathFromDN(pwzObjDN, &bstrWindowsPath);
        if (SUCCEEDED(hr))
        {
            strADsWindowsPath = bstrWindowsPath;
            ::SysFreeString(bstrWindowsPath);
        }
        else
        {
            // if we fail, try to survive with the regular ADSI path
            strADsWindowsPath = strADsPath;
        }

        // try to see it a sheet with this title is already up
        if (FindSheet(const_cast<PWSTR>((LPCWSTR)strADsWindowsPath)))
        {
            goto Cleanup;
        }
      
        // Create the intermediary data object.
        //
        pDataObj = new CDsPropDataObj(hwndParent, fReadOnly);

        CHECK_NULL_REPORT(pDataObj, hwndParent, goto Cleanup;);

        hr = pDataObj->Init(const_cast<PWSTR>((LPCWSTR)strADsWindowsPath), bstrClass);

        CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

        //
        // Have the DS shell folder extension post the sheet.
        //
        IDsFolderProperties * pdfp = NULL;

        hr = CoCreateInstance(CLSID_DsFolderProperties, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsFolderProperties, (void **)&pdfp);

        CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);

        hr = pdfp->ShowProperties(hwndParent, pDataObj);

        CHECK_HRESULT_REPORT(hr, hwndParent, ;);

        pdfp->Release();

        goto Cleanup;
    }

    // called from DS Admin, delegate to it
    {
      //
      // First crack the path to something readable
      //
      PWSTR pwzCanEx = NULL;

      hr = CrackName(pwzObjDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, hwndParent);

      if (SUCCEEDED(hr) &&
          pwzCanEx)
      {
        PWSTR pwzSlash = wcsrchr(pwzCanEx, L'\n');
        if (pwzSlash)
        {
           pwszName = pwzSlash + 1;
        }
        else
        {
           pwszName = pwzCanEx;
        }
      }

      hr = S_OK;

      PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo = 
                          CreateSecondaryPageInfo(hwndParent, pwszName, pwzObjDN, bstrClass, fReadOnly);

      if (pDsaSecondaryPageInfo == NULL)
      {
          hr = E_OUTOFMEMORY;
          CHECK_HRESULT_REPORT(hr, hwndParent, goto Cleanup;);
      }

      PWSTR pwzDC = NULL;

      if (fDomAdmin)
      {
         //
         // Get the DC name to send to the snap in.
         //
         CStrW strDC;

         hr = GetLdapServerName(pParentPage->m_pDsObj, strDC);

         if (SUCCEEDED(hr))
         {
            pwzDC = (PWSTR) LocalAlloc(LPTR, (strDC.GetLength() + 1) * sizeof(WCHAR));

            CHECK_NULL_REPORT(pwzDC, hwndParent, goto Cleanup);

            wcscpy(pwzDC, strDC);
         }
      }

      ::SendMessage(hNotifyObj, WM_ADSPROP_SHEET_CREATE, (WPARAM)pDsaSecondaryPageInfo, (LPARAM)pwzDC);
    }

    cWait.SetOld();

Cleanup:

    if (pObj)
    {
        pObj->Release();
    }

    if (pDataObj)
    {
        // The prop sheet holds on to the dataobj, so don't delete it here.
        //
        dspDebugOut((DEB_USER15, "PostPropSheet releasing data obj 0x%x\n", pDataObj));
        pDataObj->Release();
    }

    if (bstrName)
    {
        SysFreeString(bstrName);
    }
    if (bstrClass)
    {
        SysFreeString(bstrClass);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetDomainScope
//
//  Synopsis:   Returns the full LDAP DN of the domain of the current object.
//
//-----------------------------------------------------------------------------
HRESULT GetDomainScope(CDsPropPageBase * pPage, BSTR * pBstrOut)
{
    PWSTR pwzObjDN;
    HRESULT hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwzObjDN);

    CHECK_HRESULT(hr, return hr);

    hr = GetObjectsDomain(pPage, pwzObjDN, pBstrOut);

    DO_DEL(pwzObjDN);
    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetObjectsDomain
//
//  Synopsis:   Returns the full LDAP DN of the domain of the passed in object.
//
//-----------------------------------------------------------------------------
HRESULT GetObjectsDomain(CDsPropPageBase * pPage, PWSTR pwzObjDN, BSTR * pBstrOut)
{
    PWSTR pwzDomainDN;
    HRESULT hr;

    hr = CrackName(pwzObjDN, &pwzDomainDN, GET_FQDN_DOMAIN_NAME, pPage->GetHWnd());

    CHECK_HRESULT(hr, return hr);
    CComPtr<IADsPathname> spPathCracker;

    hr = pPage->GetADsPathname(spPathCracker);

    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Set(g_wzLDAPProvider, ADS_SETTYPE_PROVIDER);

    CHECK_HRESULT(hr, return hr);

    CStrW strDC;

    hr = GetLdapServerName(pPage->m_pDsObj, strDC);

    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Set(const_cast<PWSTR>((LPCWSTR)strDC), ADS_SETTYPE_SERVER);

    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Set(pwzDomainDN, ADS_SETTYPE_DN);

    LocalFreeStringW(&pwzDomainDN);
    CHECK_HRESULT(hr, return hr);

    hr = spPathCracker->Retrieve(ADS_FORMAT_X500, pBstrOut);

    CHECK_HRESULT(hr, return hr);

    dspDebugOut((DEB_USER1, "Object's domain is: '%S'\n", *pBstrOut));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckRegisterClipFormats
//
//  Synopsis:   If the clipboard formats haven't been registered yet, register
//              them.
//
//-----------------------------------------------------------------------------
HRESULT
CheckRegisterClipFormats(void)
{
    // Check to see if we have our clipboard formats registered, if not then
    // lets do it.

    if (!g_cfDsObjectNames)
    {
        g_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    }
    if (!g_cfDsObjectNames)
    {
        ERR_OUT("No clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfDsDispSpecOptions)
    {
        g_cfDsDispSpecOptions = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_DISPLAY_SPEC_OPTIONS);
    }
    if (!g_cfDsDispSpecOptions)
    {
        ERR_OUT("No DS Display Spec Options clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfShellIDListArray)
    {
        g_cfShellIDListArray = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
    }
    if (!g_cfShellIDListArray)
    {
        ERR_OUT("No Shell IDList Array clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

#ifdef DSADMIN
    if (!g_cfMMCGetNodeType)
    {
        g_cfMMCGetNodeType = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
    }
    if (!g_cfMMCGetNodeType)
    {
        ERR_OUT("No node-type clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfDsPropCfg)
    {
        g_cfDsPropCfg = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_PROPSHEETCONFIG);
    }
    if (!g_cfDsPropCfg)
    {
        ERR_OUT("No propsheet cfg clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!g_cfDsSelList)
    {
        g_cfDsSelList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    }
    if (!g_cfDsSelList)
    {
        ERR_OUT("No object picker clipboard format registered", 0);
        return HRESULT_FROM_WIN32(GetLastError());
    }


    if (!g_cfDsMultiSelectProppages)
    {
      g_cfDsMultiSelectProppages = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_MULTISELECTPROPPAGE);
    }
    if (!g_cfDsMultiSelectProppages)
    {
      ERR_OUT("No multi-select proppages clipboard format registered", 0);
      return HRESULT_FROM_WIN32(GetLastError());
    }

    //if (!g_cfMMCGetCoClass)
    //{
    //    g_cfMMCGetCoClass = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
    //}
    //if (!g_cfMMCGetCoClass)
    //{
    //    ERR_OUT("No clipboard format registered", 0);
    //    return HRESULT_FROM_WIN32(GetLastError());
    //}
#endif
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CrackName
//
//  Synopsis:   Given an object name, returns the requested name. The string
//              allocated to hold this name must be freed using
//              LocalFreeStringW (it and LocalAllocStringW are imported from
//              dsuiext.dll).
//
//  Operations:
//    GET_OBJ_CAN_NAME     - return the object's canonical name.
//    GET_OBJ_CAN_NAME_EX  - leaf element delimited by CR character.
//    GET_OBJ_1779_DN      - return object's FQDN.
//    GET_OBJ_NT4_NAME     - return object's downlevel name (domain\name).
//    GET_DNS_DOMAIN_NAME  - return object's DNS domain name.
//    GET_NT4_DOMAIN_NAME  - return object's NT4 domain name.
//    GET_FQDN_DOMAIN_NAME - return object's FQDN domain name.
//    GET_OBJ_UPN          - return object's User Principal name.
//
//  Assumptions: Object (pwzNameIn) can be in any domain. Therefore, resolving
//               the name may require chasing referrals.
//               Syntactical-only name cracking is much faster, so don't bind
//               to the DC unless syntactical-only fails.
//
//  Methodology:
//    GET_OBJ_CAN_NAME - Try syntactical-only first. If that fails, go through
//      the loop again using the DC. Format requested is DS_CANONICAL_NAME.
//    GET_OBJ_CAN_NAME_EX - Same as above except name format requested is
//      DS_CANONICAL_NAME_EX.
//    GET_OBJ_1779_DN - Same as above except name format requested is
//      DS_FQDN_1779_NAME.
//    GET_OBJ_NT4_NAME = Same as above except name format requested is
//      DS_NT4_ACCOUNT_NAME (flat-domain\name).
//    GET_DNS_DOMAIN_NAME - Same as above except return the pDomain element of
//      the DS_NAME_RESULT struct.
//    GET_NT4_DOMAIN_NAME - The NT4 domain name is returned by DsGetDcName.
//      However, we don't know up front whether pwzNameIn is in the current
//      domain or not. Thus, the goal when the loop is first entered will be
//      to obtain a valid DNS domain name. That is, when DsCrackNames returns
//      with a zero status then pwzDomain will contain the DNS domain name for
//      the object's domain. After that, the DomainName value returned by
//      DsGetDcName will be the downlevel domain name.
//    GET_FQDN_DOMAIN_NAME - This is similar to GET_NT4_DOMAIN_NAME except that
//      once the DNS domain name is obtained, DsCrackNames must be called once
//      more to convert that to the 1779 name for the domain.
//
//-----------------------------------------------------------------------------
HRESULT
CrackName(PWSTR pwzNameIn, PWSTR * ppwzResultName, CRACK_NAME_OPR RequestedOpr,
          HWND hWnd)
{
    HRESULT hr = S_OK;
    CRACK_NAME_OPR CurOpr = RequestedOpr;
    HANDLE hDS = (HANDLE)-1;
    PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
    DWORD dwErr = 0;
    PDS_NAME_RESULTW pDsNameResult = NULL;
    PWSTR * ppwsIn = &pwzNameIn, pwzNameResult = NULL;
    PWSTR pwzDomain = NULL, pwzNT4Domain = NULL, pwzDomRoot = NULL;
    BOOL fLoopAgain = FALSE, fGotDnsDomain = FALSE, fNeedDcBind = FALSE;
    ULONG GetDcFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED |
                       DS_WRITABLE_REQUIRED;
    DS_NAME_FORMAT FormatOffered = DS_FQDN_1779_NAME;
    DS_NAME_FORMAT FormatRequested = DS_CANONICAL_NAME, OriginalFormatRequested = DS_CANONICAL_NAME;
    DS_NAME_FLAGS NameFlags = DS_NAME_FLAG_SYNTACTICAL_ONLY;

    dspDebugOut((DEB_USER1, "CrackName input: %ws\n", pwzNameIn));

    switch (RequestedOpr)
    {
    case GET_NT4_DOMAIN_NAME:
    case GET_FQDN_DOMAIN_NAME:
        CurOpr = GET_DNS_DOMAIN_NAME;
        break;

    case GET_OBJ_1779_DN:
        FormatOffered = DS_UNKNOWN_NAME;
        FormatRequested = DS_FQDN_1779_NAME;
        break;

    case GET_OBJ_NT4_NAME:
        FormatRequested = DS_NT4_ACCOUNT_NAME;
        break;

    case GET_OBJ_CAN_NAME_EX:
        FormatRequested = DS_CANONICAL_NAME_EX;
        break;

    case GET_OBJ_UPN:
        FormatOffered = DS_UNKNOWN_NAME;
        FormatRequested = DS_USER_PRINCIPAL_NAME;
        break;
    }

    do
    {
        if (!(NameFlags & DS_NAME_FLAG_SYNTACTICAL_ONLY))
        {
            // Get a DC name for the domain and bind to it.
            //
            if (CurOpr == GET_NT4_DOMAIN_NAME)
            {
                GetDcFlags |= DS_RETURN_FLAT_NAME;
            }

            dspDebugOut((DEB_ITRACE, "Getting DC for domain '%ws'\n", pwzDomain));

            dwErr = DsGetDcNameW(NULL, pwzDomain, NULL, NULL, GetDcFlags,
                                 &pDCInfo);

            CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));
            dspAssert(pDCInfo != NULL);

            if (CurOpr == GET_NT4_DOMAIN_NAME)
            {
                if (FAILED(LocalAllocStringW(&pwzNT4Domain,
                                             pDCInfo->DomainName)))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                dwErr = DsBindW(pDCInfo->DomainControllerName, NULL, &hDS);
            }

#ifdef DSADMIN
            NetApiBufferFree(pDCInfo);
#else
            LocalFree(pDCInfo);
#endif
            pDCInfo = NULL;

            if (dwErr != ERROR_SUCCESS)
            {
                // Try again, the DC returned above was unavailable (i.e., the
                // cache list was stale).
                //
                GetDcFlags |= DS_FORCE_REDISCOVERY;

                dwErr = DsGetDcNameW(NULL, pwzDomain, NULL, NULL, GetDcFlags,
                                     &pDCInfo);

                CHECK_WIN32_REPORT(dwErr, hWnd, ;);

                if (dwErr == ERROR_SUCCESS)
                {
                    dspAssert(pDCInfo != NULL);

                    if (CurOpr == GET_NT4_DOMAIN_NAME)
                    {
                        LocalFreeStringW(&pwzNT4Domain);

                        if (FAILED(LocalAllocStringW(&pwzNT4Domain,
                                                     pDCInfo->DomainName)))
                        {
                            REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                            return E_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        dwErr = DsBindW(pDCInfo->DomainControllerName,
                                        NULL, &hDS);
                    }
                }
#ifdef DSADMIN
                NetApiBufferFree(pDCInfo);
#else
                LocalFree(pDCInfo);
#endif
            }
            CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));

            if (CurOpr == GET_NT4_DOMAIN_NAME)
            {
                break;
            }
        }

        //
        // Convert the object name.
        //
        dwErr = DsCrackNamesW(hDS, NameFlags, FormatOffered,
                              FormatRequested, 1, ppwsIn, &pDsNameResult);

        if (!(NameFlags & DS_NAME_FLAG_SYNTACTICAL_ONLY))
        {
            DsUnBind(&hDS);
        }

        CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));

        dspAssert(pDsNameResult);

        dspAssert(pDsNameResult->cItems == 1);

        switch (pDsNameResult->rItems->status)
        {
        case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
            //
            // A syntactical-only cracking failed, so do it again and use
            // the DC.
            //
            if (fNeedDcBind)
            {
                // Can't syntactically get the domain name, format offered
                // must not be 1779; nothing we can do.
                //
                fLoopAgain = FALSE;
                fNeedDcBind = FALSE;
                pwzNameResult = pwzNameIn;
                hr = MAKE_HRESULT(SEVERITY_ERROR, 0, DS_NAME_ERROR_NO_MAPPING);
            }
            else
            {
                if (DS_FQDN_1779_NAME == FormatOffered)
                {
                    // If the format offered is 1779, then a syntactic-only
                    // crack for canonical name will supply the DNS domain name.
                    // So, set a flag that says we are getting the domain name.
                    //
                    fNeedDcBind = TRUE;
                    OriginalFormatRequested = FormatRequested;
                    FormatRequested = DS_CANONICAL_NAME;
                    //
                    // The DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC flag means to
                    // return the syntactic mapping even for FPOs which other-
                    // wise cannot be cracked syntactically.
                    //
                    NameFlags = (DS_NAME_FLAGS)((int)DS_NAME_FLAG_SYNTACTICAL_ONLY
                                                   | DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC);
                }
                else
                {
                    NameFlags = DS_NAME_NO_FLAGS;
                }
                fLoopAgain = TRUE;
            }
            continue;

        case DS_NAME_ERROR_DOMAIN_ONLY:
            //
            // The object info is in another domain. Go there and try again
            // (unless only the DNS domain name is needed).
            //
            LocalFreeStringW(&pwzDomain);

            if (FAILED(LocalAllocStringW(&pwzDomain,
                                         pDsNameResult->rItems->pDomain)))
            {
                REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                DsFreeNameResultW(pDsNameResult);
                return E_OUTOFMEMORY;
            }
            DsFreeNameResultW(pDsNameResult);
            pDsNameResult = NULL;

            fGotDnsDomain = TRUE;

            if (RequestedOpr == GET_DNS_DOMAIN_NAME)
            {
                fLoopAgain = FALSE;
            }
            else
            {
                NameFlags = DS_NAME_NO_FLAGS;
                fLoopAgain = TRUE;
            }
            break;

        case DS_NAME_NO_ERROR:
            //
            // Success!
            //

            fLoopAgain = FALSE;

            if (CurOpr == GET_DNS_DOMAIN_NAME || fNeedDcBind)
            {
                fGotDnsDomain = TRUE;
                LocalFreeStringW(&pwzDomain);
                if (FAILED(LocalAllocStringW(&pwzDomain,
                                             pDsNameResult->rItems->pDomain)))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, hWnd);
                    DsFreeNameResultW(pDsNameResult);
                    return E_OUTOFMEMORY;
                }
                DsFreeNameResultW(pDsNameResult);
                pDsNameResult = NULL;

                if (fNeedDcBind)
                {
                    fLoopAgain = TRUE;
                    NameFlags = DS_NAME_NO_FLAGS;
                    fNeedDcBind = FALSE;
                    FormatRequested = OriginalFormatRequested;
                }
            }
            else
            {
                pwzNameResult = pDsNameResult->rItems->pName;
            }
            break;

        case DS_NAME_ERROR_RESOLVING:
        case DS_NAME_ERROR_NOT_FOUND:
        case DS_NAME_ERROR_NO_MAPPING:
            //
            // Can't map the name for some reason, just return the original
            // name and set the return value to DS_NAME_ERROR_NO_MAPPING.
            //
            fLoopAgain = FALSE;
            pwzNameResult = pwzNameIn;
            hr = MAKE_HRESULT(SEVERITY_ERROR, 0, DS_NAME_ERROR_NO_MAPPING);
            break;

        default:
            CHECK_WIN32_REPORT(pDsNameResult->rItems->status, hWnd,
                return MAKE_HRESULT(SEVERITY_ERROR, 0, pDsNameResult->rItems->status));
            break;
        }

        if (RequestedOpr == GET_NT4_DOMAIN_NAME ||
            RequestedOpr == GET_FQDN_DOMAIN_NAME)
        {
            if (CurOpr == GET_FQDN_DOMAIN_NAME)
            {
                DO_DEL(*ppwsIn);
            }
            if (CurOpr == GET_DNS_DOMAIN_NAME)
            {
                if (fGotDnsDomain)
                {
                    // Got the DNS domain name, now loop once more to finish.
                    //
                    dspAssert(pwzDomain);
                    fLoopAgain = TRUE;
                    CurOpr = RequestedOpr;
                    NameFlags = DS_NAME_NO_FLAGS;

                    if (RequestedOpr == GET_FQDN_DOMAIN_NAME)
                    {
                        // JonN 3/3/99; per DaveStr this should be
                        FormatOffered = DS_CANONICAL_NAME;
                        NameFlags = DS_NAME_FLAG_SYNTACTICAL_ONLY;
                        // was FormatOffered = DS_UNKNOWN_NAME;
                        FormatRequested = DS_FQDN_1779_NAME;
                        pwzDomRoot = new WCHAR[wcslen(pwzDomain) + 2];
                        CHECK_NULL_REPORT(pwzDomRoot, hWnd, return E_OUTOFMEMORY);
                        wcscpy(pwzDomRoot, pwzDomain);
                        wcscat(pwzDomRoot, L"/");
                        ppwsIn = &pwzDomRoot;
                    }
                }
                else
                {
                    fLoopAgain = FALSE;
                }
            }
        }
    } while (fLoopAgain);

    switch (RequestedOpr)
    {
    case GET_OBJ_CAN_NAME:
    case GET_OBJ_CAN_NAME_EX:
    case GET_OBJ_1779_DN:
    case GET_OBJ_NT4_NAME:
    case GET_FQDN_DOMAIN_NAME:
    case GET_OBJ_UPN:
        dspAssert(pDsNameResult);
        if (FAILED(LocalAllocStringW(ppwzResultName, pwzNameResult)))
        {
            DsFreeNameResultW(pDsNameResult);
            REPORT_ERROR(E_OUTOFMEMORY, hWnd);
            return E_OUTOFMEMORY;
        }

        LocalFreeStringW(&pwzDomain);
        DO_DEL(pwzDomRoot);

        break;

    case GET_DNS_DOMAIN_NAME:
        dspAssert(pwzDomain);
        *ppwzResultName = pwzDomain;
        break;

    case GET_NT4_DOMAIN_NAME:
        dspAssert(pwzNT4Domain);
        *ppwzResultName = pwzNT4Domain;
        LocalFreeStringW(&pwzDomain);
        break;

    default:
        dspAssert(FALSE);
    }

    if (pDsNameResult)
    {
        DsFreeNameResultW(pDsNameResult);
    }

    return hr;
}

#ifdef DSADMIN

HRESULT DSPROP_GetGCSearchOnDomain(
    PWSTR pwzDomainDnsName,
    IN  REFIID iid,
    OUT void** ppvObject )
{
    HRESULT hr = S_OK;
    ASSERT( NULL != ppvObject && NULL == *ppvObject );

    CStrW strGC = L"GC:";

    if (pwzDomainDnsName)
    {
      strGC += L"//";
      //  strGC += pwzDomainDnsName;
      PDOMAIN_CONTROLLER_INFO pDCInfo;
      DWORD dwErr = DsGetDcName (NULL,
                                 pwzDomainDnsName,
                                 NULL,NULL,
                                 DS_DIRECTORY_SERVICE_REQUIRED,
                                 &pDCInfo);
      hr = HRESULT_FROM_WIN32(dwErr);
      CHECK_HRESULT(hr, return hr);
      strGC += pDCInfo->DnsForestName;
      NetApiBufferFree(pDCInfo);
    }

    dspDebugOut((DEB_ITRACE, "Binding to %ws\n", strGC));

    hr = ADsOpenObject(const_cast<PWSTR>((LPCWSTR)strGC),
                       NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       iid, (PVOID *)ppvObject);
    CHECK_HRESULT(hr, return hr);
    return S_OK;
}

//+----------------------------------------------------------------------------
//  SMTP address validation. This is adapted from code provided by Eric Dao
//  and Wayne Cranston of the Exchange team.
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:    bParse821IPv4Literal
//
//  parse:  IPv4literal ::= snum 3("." snum)
//                 snum ::= one, two or three digits representing a decimal
//                          integer in the range 0 through 255
//
//-----------------------------------------------------------------------------
static BOOL bParse821IPv4Literal(PSTR* ppsz)
{
    PSTR p        = *ppsz;
    DWORD n       = 0;
    DWORD cOctets = 0;
    DWORD cDigits = 0;

    dspAssert(*p == '[');

    while (*p) 
    {
        p++;
        n = 0;
        cDigits = 0;

        if (!isdigit(*p))
            return FALSE;

        while (isdigit(*p))
        {
            if (++cDigits > 3)
                return FALSE;

            n = n * 10 + *p - '0';
            p++;
        }

        if (++cOctets > 4)
            return FALSE;

        if (n > 255)
            return FALSE;

        if ('.' != *p)
            break;
    }

    if (']' != *p || cOctets != 4)
        return FALSE;

    p++;
    *ppsz = p;

    return TRUE;
}
//+----------------------------------------------------------------------------
//
//  Function:    bParse821AtDomain
//
//  parse:
//             <a-d-l> ::= <at-domain> | <at-domain> "," <a-d-l>
//         <at-domain> ::= "@" <domain>
//            <domain> ::= <element> | <element> "." <domain>
//         // IMC does not support #<number> or [127.0.0.1]
//           <element> ::= <name> | "#" <number> | "[" <dotnum> "]"
//           <element> ::= <name> 
//              <name> ::= <let-dig> <ldh-str> <let-dig>
//           <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
//           <let-dig> ::= <a> | <d>
//       <let-dig-hyp> ::= <a> | <d> | "-" | "_" ; underscore is invalid, but still used
//                 <a> ::= [A-Za-z]
//                 <d> ::= [0-9]
//-----------------------------------------------------------------------------
static BOOL bParse821AtDomain(PSTR* ppsz)
{
    PSTR p = *ppsz;

    dspAssert(*p == '@');

    p++;

    if ('\0' == *p)
         return FALSE;

    // Check for IPv4 literals
    // 
    if ('[' == *p)
    {
        if (!bParse821IPv4Literal(&p))
            return FALSE;

        goto Exit;
    }

    //
    // Check to be sure the next character is an alpha
    //
    if (!isalnum(*p) && '#' != *p)
    {
      return FALSE;
    }
    p++;

    while (*p)
    {
        if (!(isalnum(*p)))
            return FALSE;

        p++;

        while (*p && (isalnum(*p) || *p == '-'))
        {
            p++;
        }

        if (!isalnum(*(p-1)))
            return FALSE;

        if ('.' != *p)
            break;

        p++;
    }

Exit:
    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821String
//
//  parse:
//           <string> ::= <char> | <char> <string>
//             <char> ::= <c> | "\" <x>
//                <c> ::= any of the 128 ascii characters, but not any <special>
//                        or <sp>
//                <x> ::= any one of the 128 ascii characters (no exceptions)
//               <sp> ::= space (ASCII 32)
//          <special> ::= "<" | ">" | "(" | ")" | "[" | "]" | "\" | "."
//                            | "," | ";" | ":" | "@" | """ | <control>
//          <control> ::= ASCII 0 through ASCII 31 inclusive, and ASCII 127
//-----------------------------------------------------------------------------
static BOOL bParse821String(PSTR* ppsz)
{
    static char rg821Special[] = "<>()[]\\.,;:@\"";
    PSTR p = *ppsz;

    while (*p)
    {
        if ('\\' == *p)
        {
            p++;

            if ('\0' == *p)
                 return FALSE;
        }
        else
        {
            if (' ' == *p || strchr(rg821Special, *p) || *p < ' ' || '\x7f' == *p)
                 return FALSE;
        }

        p++;

        if ('\0' == *p || '@' == *p || '.' == *p)
            break;

        // Whitespace encountered at this point could be either trailing (if
        // there is no @domain), or it is embedded. We can't really tell the
        // difference (without a lot of work), so fail because there is
        // no other interpretation that is safe.
        //
        if (' ' == *p || '\t' == *p || '>' == *p)
            return FALSE;
    }

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821DotString
//
//  parse:
//       <dot-string> ::= <string> | <string> "." <string>
//-----------------------------------------------------------------------------
static BOOL bParse821DotString(PSTR* ppsz)
{
    PSTR p = *ppsz;

    while (*p)
    {
         if (!bParse821String(&p))
             return FALSE;

         if ('.' != *p)
             break;

         p++;
    }

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821QuotedString
//
//  parse:
//    <quoted-string> ::= """ <qtext> """
//            <qtext> ::= "\" <x> | "\" <x> <qtext> | <q> | <q> <qtext>
//                <q> ::= any one of the ascii characters except <cr>, <lf>,
//                        quote (") or backslash (\)
//-----------------------------------------------------------------------------
static BOOL bParse821QuotedString(PSTR* ppsz)
{
    PSTR p = *ppsz;

    dspAssert('"' == *p);

    p++;

    while (*p && '"' != *p)
    {
         if ('\\' == *p)
         {
             p++;

             if ('\0' == *p)
                  return FALSE;
         }
         else
         {
             if ('\r' == *p || '\n' == *p)
                  return FALSE;
         }

         p++;
    }
    if ('"' != *p)
         return FALSE;

    p++;

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:    bParse821Mailbox
//
//  parse:
//          <mailbox> ::= <local-part> "@" <domain>
//       <local-part> ::= <dot-string> | <quoted-string>
//-----------------------------------------------------------------------------
static BOOL bParse821Mailbox(PSTR* ppsz)
{
    PSTR p;
    BOOL  bSuccess = FALSE;

    dspAssert(ppsz);

    p = *ppsz;

    if ('\0' == *p)
         return FALSE;

    if ('<' == *p)
    {
      p++;
      if ('"' == *p)
           bSuccess = bParse821QuotedString(&p);
      else
           bSuccess = bParse821DotString(&p);

      if (!bSuccess)
           return FALSE;

      if ('@' == *p && !bParse821AtDomain(&p))
           return FALSE;

      if ('>' != *p)
        return FALSE;

      p++;
    }
    else
    {
      if ('"' == *p)
           bSuccess = bParse821QuotedString(&p);
      else
           bSuccess = bParse821DotString(&p);

      if (!bSuccess)
           return FALSE;

      if ('@' == *p && !bParse821AtDomain(&p))
           return FALSE;
    }

    *ppsz = p;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   FValidSMTPAddress
//
//  Synopsis:   Valididate mailbox + domain/host name (RFC 821).
//
//  Return TRUE if we find a valid RFC821 address at pwzBuffer. The UNICODE
//  buffer is converted to ANSI, checked, then converted back. This insures
//  that only ANSI characters are in the buffer when done.
//
//-----------------------------------------------------------------------------
BOOL
FValidSMTPAddress(PWSTR pwzBuffer)
{
    dspAssert(pwzBuffer);

    BOOL bUnmappedCharUsed = FALSE;
    int len;
    len = WideCharToMultiByte(CP_ACP, 0, pwzBuffer, -1, NULL, 0, NULL, &bUnmappedCharUsed);
    
    if (bUnmappedCharUsed)
    {
       return FALSE;
    }

    PSTR pszBuf = new char[len + 1];

    CHECK_NULL_REPORT(pszBuf, GetDesktopWindow(), return FALSE);

    if (WideCharToMultiByte(CP_ACP, 0, pwzBuffer, -1,
                            pszBuf, len, NULL, NULL) == 0)
    {
        ReportError(GetLastError(), 0);
        delete [] pszBuf;
        return FALSE;
    }

    PSTR p = pszBuf; // working pointer
    CHECK_NULL_REPORT(p, GetDesktopWindow(), return FALSE);

    if ('\0' == *p)
    {
        delete [] pszBuf;
        return FALSE;
    }

    // Parse routing
    //
    if ('@' == *p)
    {
        while ('@' == *p)
        {
            if (!bParse821AtDomain(&p))
            {
                delete [] pszBuf;
                return FALSE;
            }

            while (' ' == *p || '\t' == *p)
            {
                p++;
            }

            if (',' != *p)
                 break;

            p++;

            while (' ' == *p || '\t' == *p)
            {
                p++;
            }
        }

        if (':' != *p)
        {
            delete [] pszBuf;
            return FALSE;
        }

        p++;

        while (' ' == *p || '\t' == *p)
        {
            p++;
        }
    }

    if (!bParse821Mailbox(&p))
    {
        delete [] pszBuf;
        return FALSE;
    }

    // If we are not at end of string, then bParse821Mailbox found an invalid
    // character.
    //
    if ('\0' != *p)
    {
        delete [] pszBuf;
        return FALSE;
    }

    int lenOrig = len;

    len = MultiByteToWideChar(CP_ACP, 0, pszBuf, -1, NULL, 0);

    if (len > lenOrig)
    {
        // Assuming the string won't grow when converted to ANSI and back.
        //
        dspAssert(len <= lenOrig);
        delete [] pszBuf;
        return FALSE;
    }

    if (MultiByteToWideChar(CP_ACP, 0, pszBuf, -1, pwzBuffer, len) == 0)
    {
        ReportError(GetLastError(), 0);
        delete [] pszBuf;
        return FALSE;
    }

    delete [] pszBuf;

    return TRUE;
}

#endif // DSADMIN

void Smart_PADS_ATTR_INFO__Empty( PADS_ATTR_INFO* ppAttrs )
{
  if (NULL != *ppAttrs)
  {
    FreeADsMem( *ppAttrs );
    *ppAttrs = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\qrybase.cxx ===
// QryBase.cpp : Implementation of ds routines and classes

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      qrybase.cpp
//
//  Contents:  DS Enumeration routines and classes
//
//  History:   02-Oct-96 WayneSc    Created
//             08-Apr-98 JonN       Copied from DSADMIN QUERYSUP.CPP
//
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "qrybase.h"


///////////////////////////////////////////////////////////////////////////////
CDSSearch::CDSSearch()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}

CDSSearch::~CDSSearch()
{
  if (m_pObj != NULL) {
    if (m_SearchHandle) {
      m_pObj->CloseSearchHandle (m_SearchHandle);
    }
    m_pObj->Release();
  }
}


HRESULT CDSSearch::Init(IDirectorySearch * pObj)
{
  HRESULT            hr = S_OK;
  
  m_pObj = pObj;
  pObj->AddRef();
  m_bInitialized = TRUE;
  
  return hr;
}

HRESULT CDSSearch::Init(LPCWSTR lpcszObjectPath)
{
  HRESULT            hr;

  hr = ADsOpenObject (const_cast<LPWSTR>(lpcszObjectPath), NULL, NULL,
                      ADS_SECURE_AUTHENTICATION,
                      IID_IDirectorySearch, (void **)&m_pObj);
  if (SUCCEEDED(hr)) {
    m_bInitialized = TRUE;
  } else {
    m_bInitialized = FALSE;
    m_pObj = NULL;
  }
  return hr;
}

HRESULT CDSSearch::SetAttributeList (LPWSTR *pszAttribs, INT cAttrs)
{
  m_pszAttribs = pszAttribs;
  m_nAttrs = cAttrs;
  return S_OK;
}

HRESULT CDSSearch::SetSearchScope (ADS_SCOPEENUM scope)
{
  ADS_SEARCHPREF_INFO aSearchPref;
  HRESULT hr;

  if (m_bInitialized) {
    aSearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref.vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref.vValue.Integer = scope;
    return hr = m_pObj->SetSearchPreference (&aSearchPref, 1);
  } else {
    return E_ADS_BAD_PATHNAME;
  }
}


const int NUM_PREFS=2;
HRESULT CDSSearch::DoQuery()
{

  HRESULT            hr;
  ADS_SEARCHPREF_INFO aSearchPref[NUM_PREFS];

  if (m_bInitialized) {
    aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
    aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
    aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
    
    hr = m_pObj->SetSearchPreference (aSearchPref, NUM_PREFS);
    
    if (SUCCEEDED(hr)) {
      hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                  m_pszAttribs,
                                  m_nAttrs,
                                  &m_SearchHandle);
    }
  } else {
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}

HRESULT
CDSSearch::GetNextRow()
{
  if (m_bInitialized) {
    return m_pObj->GetNextRow (m_SearchHandle);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT
CDSSearch::GetColumn(LPWSTR Attribute,
                     PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) {
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\strings.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       strings.cxx
//
//  Contents:   String constants that don't need to be localized.
//
//  History:    06-Jun-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"

PWSTR g_wzLDAPPrefix = L"LDAP://";
PWSTR g_wzLDAPProvider = L"LDAP";
PWSTR g_wzWINNTPrefix = L"WinNT://";
PWSTR g_wzPartitionsContainer = L"CN=Partitions,";
PWSTR g_wzSidPathPrefix = L"<SID=";
PWSTR g_wzSidPathSuffix = L">";
PWSTR g_wzRootDSE = L"RootDSE";
PWSTR g_wzConfigNamingContext = L"configurationNamingContext";
PWSTR g_wzSchemaNamingContext = L"schemaNamingContext";

PWSTR g_wzCRLF = L"\r\n";

//
// Class names:
//
PWSTR g_wzUser = L"user";
PWSTR g_wzGroup = L"group";
PWSTR g_wzContact = L"contact";
PWSTR g_wzComputer = L"computer";
PWSTR g_wzFPO = L"foreignSecurityPrincipal";
#ifdef INETORGPERSON
PWSTR g_wzInetOrgPerson = L"inetOrgPerson";
#endif

//
// Attribute names:
//
PWSTR g_wzClass = L"class";
PWSTR g_wzObjectClass = L"objectClass";
PWSTR g_wzDescription = L"description"; // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzName = L"name";               // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzMemberAttr = L"member";       // ADSTYPE_DN_STRING
PWSTR g_wzObjectSID = L"objectSid";
PWSTR g_wzGroupType = L"groupType";
PWSTR g_wzADsPath = L"ADsPath";

PWSTR g_wzStreet = L"streetAddress";
PWSTR g_wzPOB = L"postOfficeBox";
PWSTR g_wzCity = L"l";
PWSTR g_wzState = L"st";
PWSTR g_wzZIP = L"postalCode";
PWSTR g_wzCountryName = L"c";
PWSTR g_wzCountryCode = L"countryCode";
PWSTR g_wzTextCountry = L"co";
PWSTR g_wzDN = L"distinguishedName";
PWSTR g_wzUserAccountControl = L"userAccountControl";
PWSTR g_wzAllowed = L"allowedAttributesEffective";
PWSTR g_wzDomainMode = L"nTMixedDomain";
PWSTR g_wzBehaviorVersion = L"msDS-Behavior-Version";
PWSTR g_wzHasMasterNCs = L"hasMasterNCs";
PWSTR g_wzA2D2 = L"msDS-AllowedToDelegateTo";
PWSTR g_wzSPN = L"servicePrincipalName";
PWSTR g_wzHost = L"HOST";
PWSTR g_wzSPNMappings = L"sPNMappings";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\proputil.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proputil.h
//
//  Contents:   DS object property pages utility and helper functions header
//
//  History:    29-Sept-98 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _PROPUTIL_H_
#define _PROPUTIL_H_

extern const CLSID CLSID_DomainAdmin; // Domains & Trusts snapin CLSID

const unsigned long DSPROP_FILETIMES_PER_MILLISECOND = 10000;
const DWORD DSPROP_FILETIMES_PER_SECOND = 1000 * DSPROP_FILETIMES_PER_MILLISECOND;
const DWORD DSPROP_FILETIMES_PER_MINUTE = 60 * DSPROP_FILETIMES_PER_SECOND;
const __int64 DSPROP_FILETIMES_PER_HOUR = 60 * (__int64)DSPROP_FILETIMES_PER_MINUTE;
const __int64 DSPROP_FILETIMES_PER_DAY  = 24 * DSPROP_FILETIMES_PER_HOUR;
const __int64 DSPROP_FILETIMES_PER_MONTH= 30 * DSPROP_FILETIMES_PER_DAY;

const UINT DSPROP_TIMER_DELAY = 300; // 300 millisecond delay.

extern ULONG g_ulMemberFilterCount;
extern ULONG g_ulMemberQueryLimit;

#define DSPROP_MEMBER_FILTER_COUNT_DEFAULT 35
#define DSPROP_MEMBER_QUERY_LIMIT_DEFAULT 500

//
// Helpers.
//
BOOL UnicodeToTchar(LPWSTR pwszIn, LPTSTR * pptszOut);
BOOL TcharToUnicode(LPTSTR ptszIn, LPWSTR * ppwszOut);
BOOL AllocWStr(PWSTR pwzStrIn, PWSTR * ppwzNewStr);
BOOL AllocTStr(PTSTR ptzStrIn, PTSTR * pptzNewStr);
BOOL LoadStringToTchar(int ids, PTSTR * pptstr);
HRESULT AddLDAPPrefix(CDsPropPageBase * pObj, PWSTR pwzObj, CStrW &strResult,
                      BOOL fServer = TRUE);
void InitAttrInfo(PADS_ATTR_INFO pAttr, PWSTR pwzName, ADSTYPEENUM type);
HRESULT GetLdapServerName(IUnknown * pDsObj, CStrW& strServer);
BOOL FValidSMTPAddress(PWSTR pwzBuffer);
HRESULT CheckRegisterClipFormats(void);
HRESULT BindToGCcopyOfObj(CDsPropPageBase * pPage, PWSTR pwzObjADsPath,
                          IDirectoryObject ** ppDsObj);
void ConvertSidToPath(PSID ObjSID, CStrW &strSIDname);

#define ARRAYLENGTH(x)  (sizeof(x)/sizeof((x)[0]))
#define DO_DEL(x) if (x) {delete x; x = NULL;}
#define DO_RELEASE(x) if (x) {x->Release(); x = NULL;}

HRESULT GetDomainScope(CDsPropPageBase * pPage, BSTR * pBstrOut);
HRESULT GetObjectsDomain(CDsPropPageBase * pPage, PWSTR pwzObjPath, BSTR * pBstrOut);

void ReportErrorWorker(HWND hWnd, PTSTR ptzMsg);

#if defined(DSADMIN)
//+----------------------------------------------------------------------------
//
//  Function:   DspFormatMessage
//
//  Synopsis:   Loads a string resource with replaceable parameters and uses
//              FormatMessage to populate the replaceable params from the
//              argument array. If dwErr is non-zero, will load the system
//              description for that error and include it in the argument array.
//
//-----------------------------------------------------------------------------
void
DspFormatMessage(
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PWSTR * ppwzMsg,    // The returned error string, free with LocalFree.
    HWND hWnd = NULL    // owning window, can be NULL.
    );
#endif // defined(DSADMIN)

//
// Predefined table-driven page auxiliary functions
//

//
// For these, set the bit you want in pAttrMap->pData.
// You can "reverse the sense" of the checkbox by providing the inverse of the bit.
//
HRESULT
FirstSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
SubsequentSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
HideBasedOnBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);

// Sets the context help ID to pAttrMap->pData on fInit/fObjChanged
// This is particularly useful for static text controls which cannot set
// context help ID in the resource file.
HRESULT
SetContextHelpIdAttrFn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);

HRESULT
DsQuerySite(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQueryInterSiteTransport(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQueryPolicy(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsReplicateListbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
/*
HRESULT
DsQueryFrsPrimaryMember(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
*/
HRESULT
GeneralPageIcon(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);

//
// Duelling listbox functions
//
// DuellingListbox can be used for all "out" listboxes,
// and DuellingListboxButton can be used for all Add and Remove buttons.
// Only the In listbox needs an individual handler.
// The control IDs for the four controls in a duelling listbox set are constrained;
// they must be in sequence OUT, ADD, REMOVE, IN, with the ID for OUT divisible by 4.
//
HRESULT
DuellingListbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DuellingListboxButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQuerySiteList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQuerySiteLinkList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQueryBridgeheadList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);


HRESULT IntegerAsBoolDefOn(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                           LPARAM, PATTR_DATA, DLG_OP);

HRESULT VolumeUNCpath(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

//  Flags for Validate Unc Path

#define VUP_mskfAllowEmptyPath  0x0001  // Empty path is valid
#define VUP_mskfAllowUNCPath    0x0002  // UNC path is valid

BOOL FIsValidUncPath(LPCTSTR pszPath, UINT uFlags = 0);

//+----------------------------------------------------------------------------
//
//  Class:      CPageInfo
//
//  Purpose:    Holds the HWNDs of all proppages and the errors associated with
//              them from the apply
//
//-----------------------------------------------------------------------------
class CPageInfo
{
public:
  CPageInfo() : m_hWnd(NULL), m_ptzTitle(NULL), m_ApplyStatus(notAttempted) {}
  ~CPageInfo() 
  {
    if (m_ptzTitle != NULL)
    {
      delete[] m_ptzTitle;
      m_ptzTitle = NULL;
    }
  }

  typedef enum
  {
    notAttempted = 0,
    success,
    failed,
  } APPLYSTATUS;

  HWND             m_hWnd;
  CADsApplyErrors  m_ApplyErrors;
  APPLYSTATUS      m_ApplyStatus;
  PTSTR            m_ptzTitle;
};

//+----------------------------------------------------------------------------
//
//  Class:      CNotifyObj
//
//  Purpose:    Handles inter-page and inter-sheet syncronization.
//
//-----------------------------------------------------------------------------
class CNotifyObj
{
#ifdef _DEBUG
    char szClass[32];
#endif

    friend VOID __cdecl NotifyThreadFcn(PVOID);
    friend VOID RegisterNotifyClass(void);

public:

    CNotifyObj(LPDATAOBJECT pDataObj, PPROPSHEETCFG pSheetCfg);
    ~CNotifyObj(void);

    //
    // Creation function to create an instance of the object.
    //
    static HRESULT Create(LPDATAOBJECT pAppThdDataObj, PWSTR pwzADsObjName,
                          HWND * phNotifyObj);
    //
    // Pages call this at their object init time to retreive DS object info.
    //
    static BOOL GetInitInfo(HWND hNotifyObj, PADSPROPINITPARAMS pInitParams);
    //
    // Pages call this at their dialog init time to send their hwnd.
    //
    static BOOL SetHwnd(HWND hNotifyObj, HWND hPage, PTSTR ptzTitle = NULL);
    //
    //  Static WndProc to be passed as class address.
    //
    static LRESULT CALLBACK StaticNotifyProc(HWND hWnd, UINT uMsg,
                                             WPARAM wParam, LPARAM lParam);
    //
    // Instance window procedure.
    //
    LRESULT CALLBACK NotifyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                                LPARAM lParam);
    //
    //  Member functions, called by WndProc
    //
    LRESULT OnCreate(void);

    //
    //  Data members
    //
    HWND                m_hWnd;
    DWORD               m_cPages;
    DWORD               m_cApplies;
    LPDATAOBJECT        m_pAppThdDataObj;
    UINT                m_nPageInfoArraySize;
    CPageInfo*          m_pPageInfoArray;

private:
//    HWND                m_hWnd;
    HWND                m_hPropSheet;
//    DWORD               m_cPages;
//    DWORD               m_cApplies;
//    LPDATAOBJECT        m_pAppThdDataObj;
    LPSTREAM            m_pStrmMarshalledDO;
    PROPSHEETCFG        m_sheetCfg;
    HANDLE              m_hInitEvent;
    BOOL                m_fBeingDestroyed;
    BOOL                m_fSheetDirty;
    HRESULT             m_hr;
    PWSTR               m_pwzObjDN;
    IDirectoryObject  * m_pDsObj;
    PWSTR               m_pwzCN;
    PADS_ATTR_INFO      m_pWritableAttrs;
    PADS_ATTR_INFO      m_pAttrs;
    CDllRef             m_DllRef;
    
//    UINT                m_nPageInfoArraySize;
//    CPageInfo*          m_pPageInfoArray;
};

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttr
//
//  Purpose:    Read, edit, and write a multi-valued, string property.
//
//-----------------------------------------------------------------------------
class CMultiStringAttr
{
public:
    CMultiStringAttr(CDsPropPageBase * pPage);
    ~CMultiStringAttr();

    HRESULT Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                 BOOL fWritable = TRUE, int nLimit = 0,
                 BOOL fCommaList = FALSE,
                 BOOL fAppend = FALSE);
    HRESULT Write(PADS_ATTR_INFO pAttr);

    BOOL    DoDlgInit(HWND hDlg);
    int     DoCommand(HWND hDlg, int id, int code);
    BOOL    DoNotify(HWND hDlg, NMHDR * pNmHdr);

    BOOL    HasValues(void) {return m_AttrInfo.dwNumValues > 0;};
    void    EnableControls(HWND hDlg, BOOL fEnable);
    void    SetDirty(HWND hDlg);
    BOOL    IsDirty(void) {return m_fDirty;};
    void    ClearDirty(void) {m_fDirty = FALSE;};
    BOOL    IsWritable(void) {return m_fWritable;};


private:
    void                ClearAttrInfo(void);

    CDsPropPageBase   * m_pPage;
    ADS_ATTR_INFO       m_AttrInfo;
    PWSTR               m_pAttrLDAPname;
    int                 m_nMaxLen;
    int                 m_nCurDefCtrl;
    BOOL                m_fListHasSel;
    int                 m_nLimit;
    int                 m_cValues;
    BOOL                m_fWritable;
    BOOL                m_fCommaList;
    BOOL                m_fDirty;
    BOOL                m_fAppend;
};

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttrDlg
//
//  Purpose:    Read, edit, and write a multi-valued, string property. This
//              is a dialog that hosts the CMultiStringAttr class.
//
//-----------------------------------------------------------------------------
class CMultiStringAttrDlg
{
public:
    CMultiStringAttrDlg(CDsPropPageBase * pPage);
    ~CMultiStringAttrDlg() {};
    //
    //  Static WndProc for multi-valued edit dialog.
    //
    static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                          WPARAM wParam, LPARAM lParam);
    HRESULT Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                 BOOL fWritable = TRUE, int nLimit = 0,
                 BOOL fCommaList = FALSE,
                 BOOL fMultiselectPage = FALSE);
    INT_PTR Edit(void);
    HRESULT Write(PADS_ATTR_INFO pAttr);

private:
    //
    // Dialog proc.
    //
    BOOL CALLBACK MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam);

    void                ClearAttrInfo(void);

    CMultiStringAttr    m_MSA;
    CDsPropPageBase   * m_pPage;
};

// Attribute function invoked by Other values button, manipulates the
// CMultiStringAttr class.
//
HRESULT
OtherValuesBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

//+----------------------------------------------------------------------------
//
//  Class:      CDsIconCtrl
//
//  Purpose:    sub-class window proc for icon control.
//
//-----------------------------------------------------------------------------
class CDsIconCtrl
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsIconCtrl(HWND hCtrl, HICON hIcon);
    ~CDsIconCtrl(void);

    //
    //  Static WndProc to be passed as subclass address.
    //
    static LRESULT CALLBACK StaticCtrlProc(HWND hWnd, UINT uMsg,
                                           WPARAM wParam, LPARAM lParam);
    //
    //  Member functions, called by WndProc
    //
    LRESULT OnPaint(void);

    //
    //  Data members
    //

protected:
    HWND                m_hCtrl;
    HWND                m_hDlg;
    WNDPROC             m_pOldProc;
    HICON               m_hIcon;
};

//+----------------------------------------------------------------------------
//
//  Template:   CSmartPtr
//
//  Purpose:    A simple smart pointer template that does cleanup with
//              the delete operator.
//
//-----------------------------------------------------------------------------
template <class T>
class CSmartPtr
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new T[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    T* operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(const T* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const T*() {return m_ptr;}
    operator T*() {return m_ptr;}
    T* operator->() {dspAssert(m_ptr); return m_ptr;}
    T** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    T* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    T     * m_ptr;
    BOOL    m_fDetached;
};

//+----------------------------------------------------------------------------
//
//  class:      CSmartPtr for character string pointers.
//
//  Purpose:    Simple types don't allow the -> operator, so specialize the
//              template.
//
//-----------------------------------------------------------------------------
#if !defined(UNICODE)
template <> class CSmartPtr <TCHAR>
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new TCHAR[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    TCHAR* operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(TCHAR* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const TCHAR*() {return m_ptr;}
    operator TCHAR*() {return m_ptr;}
    TCHAR** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    TCHAR* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    TCHAR * m_ptr;
    BOOL    m_fDetached;
};
#endif
template <> class CSmartPtr <WCHAR>
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new WCHAR[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    WCHAR* operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(WCHAR* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const WCHAR*() {return m_ptr;}
    operator WCHAR*() {return m_ptr;}
    WCHAR** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    WCHAR* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    WCHAR * m_ptr;
    BOOL    m_fDetached;
};

#define CSmartWStr CSmartPtr <WCHAR>

template <> class CSmartPtr <PVOID>
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new BYTE[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) 
    {
      if (!m_fDetached) 
        DO_DEL(m_ptr);
    }

    PVOID operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(PVOID src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const PVOID() {return m_ptr;}
    operator PVOID() {return m_ptr;}
    PVOID* operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    PVOID Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    PVOID   m_ptr;
    BOOL    m_fDetached;
};

class CSmartBytePtr
{
public:
    CSmartBytePtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartBytePtr(DWORD dwSize) {m_ptr = new BYTE[dwSize]; m_fDetached = FALSE;}
    ~CSmartBytePtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    BYTE* operator=(const CSmartBytePtr& src) {return src.m_ptr;}
    void operator=(BYTE* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const BYTE*() {return m_ptr;}
    operator BYTE*() {return m_ptr;}
    BYTE** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    BYTE* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    BYTE  * m_ptr;
    BOOL    m_fDetached;
};

class CSimpleSecurityDescriptorHolder
{
public:
  CSimpleSecurityDescriptorHolder()
  {
    m_pSD = NULL;
  }

  ~CSimpleSecurityDescriptorHolder()
  {
    if (m_pSD != NULL)
    {
      ::LocalFree(m_pSD);
      m_pSD = NULL;
    }
  }

  PSECURITY_DESCRIPTOR m_pSD;
private:
  CSimpleSecurityDescriptorHolder(const CSimpleSecurityDescriptorHolder&)
  {}

  CSimpleSecurityDescriptorHolder& operator=(const CSimpleSecurityDescriptorHolder&) {}
};

class CSimpleAclHolder
{
public:
  CSimpleAclHolder()
  {
    m_pAcl = NULL;
  }
  ~CSimpleAclHolder()
  {
    if (m_pAcl != NULL)
      ::LocalFree(m_pAcl);
  }

  PACL m_pAcl;
};

extern ATTR_MAP GenIcon;

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:      CMultiSelectErrorDialog
//
//  Purpose:    Error Message box when multi-select proppages fail to apply all
//              properties.  Each object is listed with each failure
//
//-----------------------------------------------------------------------------
class CMultiSelectErrorDialog
{
public:
  CMultiSelectErrorDialog(HWND hNotifyObj, HWND hParent);
  ~CMultiSelectErrorDialog() 
  {
    if (m_pDataObj != NULL)
    {
      m_pDataObj->Release();
    }
  }

  static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  HRESULT Init(CPageInfo* pPageInfoArray, UINT nPageCount, IDataObject* pDataObj);
  virtual int DoModal();
  virtual BOOL OnInitDialog(HWND hDlg);
  virtual void OnCopyButton();
  virtual void OnClose();
  virtual void ListItemActivate(LPNMHDR pnmh);
  virtual void ListItemClick(LPNMHDR pnmh);
  HRESULT InitializeListBox(HWND hDlg);
  virtual BOOL ShowWindow();

  BOOL ShowListViewItemProperties();

  HWND             m_hWnd;
  BOOL             m_bModal;

private:
  HWND             m_hNotifyObj;
  HWND             m_hParent;
  BOOL             m_bInit;
  HWND             m_hList;

  IDataObject*     m_pDataObj;
  UINT             m_nPageCount;
  CPageInfo*       m_pPageInfoArray;
};

#endif // DSADMIN
#endif // _PROPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\qrybase.h ===
// QryBase.h : Declaration of the CDSQuery object
//             this is an internal helper object only, not exposed
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      QryBase.h
//
//  Contents:  Query object for DS snapin
//
//  History:   04-dec-96 jimharr    Created
//             08-apr-98 jonn       Copied from DSADMIN QUERYSUP.H
//
//--------------------------------------------------------------------------


#ifndef __QRYBASE_H__
#define __QRYBASE_H__


#define QUERY_PAGESIZE 256
#define CMD_OPTIONS 2


/////////////////////////////////////////////////////////////////////////////
// CDSSearch

class CDSSearch
{
public:
  CDSSearch();
  ~CDSSearch();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT Init(LPCWSTR lpcszObjectPath);
  HRESULT DoQuery();
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) {
    return m_pObj->FreeColumn(pColumnData);
  };
  HRESULT SetAttributeList (LPWSTR *pszAttribs, INT cAttrs);
  HRESULT SetSearchScope (ADS_SCOPEENUM scope);
  HRESULT SetFilterString (LPWSTR pszFilter) {
    m_pwszFilter = pszFilter;
    return S_OK;
  };

  //Attributes
public:
  IDirectorySearch   * m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR             m_pwszFilter;
  LPWSTR           * m_pszAttribs;
  ULONG              m_nAttrs;


private:
  BOOL m_bInitialized;
  
};
        


#endif //__QRYBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\sources.inc ===
!IF 0

Microsoft Windows Actice Directory Property Pages

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

    sources include file with common definitions for the AD property pages

!ENDIF

MAJORCOMP=  admin
MINORCOMP=  dsprop

DLLENTRY=   _DllMainCRTStartup

PRECOMPILED_CXX=1
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj

USE_MSVCRT= 1
USE_ATL=1
ATL_VER=30

MSC_WARNING_LEVEL= /W4

!IF "$(PLATFORM)"=="WINNT"

LIB_PLATFORM_PATH=$(SDK_LIB_PATH)
C_DEFINES= -DUNICODE -DDSADMIN

!ELSE

CHICAGO_PRODUCT = 1
LIB_PLATFORM_PATH = $(SDK_LIB_DEST)\chicago\$(TARGET_DIRECTORY)
ALT_PROJECT_TARGET = win95
SUBSYSTEM_VERSION = 4.00
UMTYPE = console
C_DEFINES=

!ENDIF

MSC_WARNING_LEVEL=/W4 /WX

TARGETLIBS= \
    $(LIB_PLATFORM_PATH)\kernel32.lib \
    $(LIB_PLATFORM_PATH)\advapi32.lib \
    $(LIB_PLATFORM_PATH)\user32.lib   \
    $(LIB_PLATFORM_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\ntdsapi.lib       \
    $(SHELL_LIB_PATH)\shell32p.lib    \
    $(SDK_LIB_PATH)\shlwapi.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\adsiid.lib        \
    $(SDK_LIB_PATH)\activeds.lib      \
    $(SDK_LIB_PATH)\dsuiext.lib       \
    $(SDK_LIB_PATH)\mmc.lib           \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(PROJECT_ROOT)\dsadminlib\src\$(O)\dsadminp.lib

!IF "$(PLATFORM)"=="WINNT"
TARGETLIBS= $(TARGETLIBS) $(DS_LIB_PATH)\netapi32p.lib
!ELSE
TARGETLIBS= $(TARGETLIBS) $(SDK_LIB_PATH)\logonsrv.lib
!ENDIF

TARGETPATHLIB= obj

INCLUDES=   $(INCLUDES);       \
            $(DS_INC_PATH);    \
            $(SHELL_INC_PATH); \
            $(NET_INC_PATH);   \
            $(BASE_INC_PATH);  \
            $(PROJECT_ROOT)\dsadminlib\inc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\tablpage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       tablpage.cxx
//
//  Contents:   CDsTableDrivenPage, the class that implements table-driven
//              property pages
//
//  History:    1-April-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include <stdio.h>
#include "proppage.h"

//+----------------------------------------------------------------------------
//
//  Member:     CDsTableDrivenPage::CDsTableDrivenPage
//
//-----------------------------------------------------------------------------
CDsTableDrivenPage::CDsTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                       HWND hNotifyWnd, DWORD dwFlags) :
    m_pData(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyWnd, dwFlags)
{
    TRACE(CDsTableDrivenPage,CDsTableDrivenPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsTableDrivenPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsTableDrivenPage::~CDsTableDrivenPage
//
//-----------------------------------------------------------------------------
CDsTableDrivenPage::~CDsTableDrivenPage()
{
    TRACE(CDsTableDrivenPage,~CDsTableDrivenPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateTableDrivenPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyWnd,
                      DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                      HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateTableDrivenPage);

    CDsTableDrivenPage * pPageObj = new CDsTableDrivenPage(pDsPage, pDataObj,
                                                           hNotifyWnd, dwFlags);

    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == g_uChangeMsg)
    {
        return OnAttrChanged(wParam);
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case PSM_QUERYSIBLINGS:
        return OnQuerySibs(wParam, lParam);

    case WM_ADSPROP_NOTIFY_CHANGE:
        return OnObjChanged();

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return FALSE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsTableDrivenPage::OnInitDialog(LPARAM)
{
    TRACE(CDsTableDrivenPage,OnInitDialog);

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    if (SUCCEEDED(m_hrInit))
    {
        return ReadAttrsSetCtrls(fInit);
    }
    else
    {
        // error page is posted automatically.
        return 0;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnApply(void)
{
    TRACE(CDsTableDrivenPage,OnApply);
    HRESULT hr = S_OK;
    LPTSTR ptsz;
    LPWSTR pwszValue;
    PADSVALUE pADsValue;
    DWORD cAttrs = 0;

    if (m_fReadOnly)
    {
        return PSNRET_NOERROR;
    }

    PADS_ATTR_INFO pAttrs = new ADS_ATTR_INFO[m_cAttrs];
    CHECK_NULL_REPORT(pAttrs, GetHWnd(), return -1);

    memset(pAttrs, 0, sizeof(ADS_ATTR_INFO) * m_cAttrs);

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        if (m_rgpAttrMap[i]->fIsReadOnly ||
            (!m_rgpAttrMap[i]->pAttrFcn && 
             (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]) || 
              !ATTR_DATA_IS_DIRTY(m_rgAttrData[i]))))
        {
            // If the map defines it to be read-only or no attr function is
            // defined and the attribute is not writable or not dirty, then
            // skip it.
            //
            continue;
        }

        pAttrs[cAttrs] = m_rgpAttrMap[i]->AttrInfo;

        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            // Handle special-case attribute.
            //
            hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                              &pAttrs[cAttrs], 0,
                                              &m_rgAttrData[i], fApply);
            CHECK_HRESULT(hr, goto Cleanup);

            if (hr == ADM_S_SKIP)
            {
                // Don't write the attribute.
                //
                continue;
            }

            if (hr != S_FALSE)
            {
                // If the attr fcn didn't return S_FALSE, that means that it
                // handled the value. If it did return S_FALSE, then let the
                // standard edit control processing below handle the value.
                //
                cAttrs++;

                continue;
            }
        }

        if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
        {
            // Handle boolean checkbox attributes.
            //

            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

            pAttrs[cAttrs].pADsValues = pADsValue;
            pAttrs[cAttrs].dwNumValues = 1;
            pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

            pADsValue->Boolean = 
                        IsDlgButtonChecked(m_hPage, m_rgpAttrMap[i]->nCtrlID)
                            == BST_CHECKED;
            cAttrs++;

            continue;
        }

        // Assumes that all non-special-case attributes,
        // if single-valued and not boolean, come from a text control.
        //
        ptsz = new TCHAR[m_rgpAttrMap[i]->nSizeLimit + 1];
        CHECK_NULL_REPORT(ptsz, GetHWnd(), goto Cleanup);

        GetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptsz,
                       m_rgpAttrMap[i]->nSizeLimit + 1);

        CStr csValue = ptsz;

        csValue.TrimLeft();
        csValue.TrimRight();

        if (_tcslen(ptsz) != (size_t)csValue.GetLength())
        {
            // the length is different, it must have been trimmed. Write trimmed
            // value back to the control.
            //
            SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, const_cast<PTSTR>((LPCTSTR)csValue));
        }
        delete ptsz;

        if (csValue.IsEmpty())
        {
            // An empty control means remove the attribute value from the
            // object.
            //
            pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
            pAttrs[cAttrs].dwNumValues = 0;
            pAttrs[cAttrs].pADsValues = NULL;

            cAttrs++;
            continue;
        }

        if (!TcharToUnicode(const_cast<PTSTR>((LPCTSTR)csValue), &pwszValue))
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
        }

        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

        pAttrs[cAttrs].pADsValues = pADsValue;
        pAttrs[cAttrs].dwNumValues = 1;
        pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

        switch (pADsValue->dwType)
        {
        case ADSTYPE_DN_STRING:
            pADsValue->DNString = pwszValue;
            break;
        case ADSTYPE_CASE_EXACT_STRING:
            pADsValue->CaseExactString = pwszValue;
            break;
        case ADSTYPE_CASE_IGNORE_STRING:
            pADsValue->CaseIgnoreString = pwszValue;
            break;
        case ADSTYPE_PRINTABLE_STRING:
            pADsValue->PrintableString = pwszValue;
            break;
        case ADSTYPE_NUMERIC_STRING:
            pADsValue->NumericString = pwszValue;
            break;
        case ADSTYPE_INTEGER:
            pADsValue->Integer = _wtoi(pwszValue);
            break;
        default:
            dspDebugOut((DEB_ERROR, "OnApply: Unknown ADS Type %x\n",
                         pADsValue->dwType));
        }
        cAttrs++;
    }

    // cAttrs could be zero if a page was read-only. Don't call ADSI if so.
    //
    if (cAttrs < 1)
    {
        goto Cleanup;
    }

    dspDebugOut((DEB_USER1, "TablePage, about to write %d attrs.\n", cAttrs));
    //
    // Write the changes.
    //
    DWORD cModified;

    hr = m_pDsObj->SetObjectAttributes(pAttrs, cAttrs, &cModified);

    CHECK_ADS_HR(&hr, m_hPage);

Cleanup:

    for (i = 0; i < cAttrs; i++)
        HelperDeleteADsValues( &(pAttrs[i]) );

    delete pAttrs;

    if (SUCCEEDED(hr) && cAttrs > 0)
    {
        for (i = 0; i < m_cAttrs; i++)
        {
            ATTR_DATA_CLEAR_DIRTY(m_rgAttrData[i]);
        }
    }

    return SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

void HelperDeleteADsValues( ADS_ATTR_INFO* pAttrs )
{
    if (pAttrs && pAttrs->pADsValues)
    {
        for (DWORD j = 0; j < pAttrs->dwNumValues; j++)
        {
            LPWSTR pwszValue = NULL;
            switch (pAttrs->dwADsType)
            {
            case ADSTYPE_DN_STRING:
                pwszValue = pAttrs->pADsValues[j].DNString;
                break;
            case ADSTYPE_CASE_EXACT_STRING:
                pwszValue = pAttrs->pADsValues[j].CaseExactString;
                break;
            case ADSTYPE_CASE_IGNORE_STRING:
                pwszValue = pAttrs->pADsValues[j].CaseIgnoreString;
                break;
            case ADSTYPE_PRINTABLE_STRING:
                pwszValue = pAttrs->pADsValues[j].PrintableString;
                break;
            case ADSTYPE_NUMERIC_STRING:
                pwszValue = pAttrs->pADsValues[j].NumericString;
                break;
            }
            if (pwszValue)
                delete pwszValue;
        }
    }
    delete pAttrs->pADsValues;
    pAttrs->pADsValues = NULL;
    pAttrs->dwNumValues = 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    HRESULT hr;
    DWORD i;

    for (i = 0; i < m_cAttrs; i++)
    {
        if (id == m_rgpAttrMap[i]->nCtrlID)
        {
            // Give attr functions first crack at the command notification.
            //
            if (m_rgpAttrMap[i]->pAttrFcn)
            {
                hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                                  codeNotify, &m_rgAttrData[i],
                                                  fOnCommand);

                if (hr == S_FALSE)
                {
                    // If the attr function returns S_FALSE, then don't return
                    // to the base class OnCommand.
                    //
                    return 0;
                }
                else
                {
                    continue;
                }
            }
            if (codeNotify == BN_CLICKED &&
                m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
            {
                // NOTE: Must do this to allow saving from the WAB-hosted sheet.
                EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
                // NOTE: end hack.

                // The check box was clicked.
                //
                SetDirty(i);

                return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
            }
            if (codeNotify == EN_CHANGE)
            {
                // NOTE: Must do this to allow saving from the WAB-hosted sheet.
                EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
                // Note: End Hack.

                SetDirty(i);
            }
        }
    }

    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnObjChanged
//
//  Synopsis:   Object Change notification for inter-sheet syncronization.
//              Handles the private WM_ADSPROP_NOTIFY_CHANGE message.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnObjChanged(void)
{
    TRACE(CDsTableDrivenPage,OnObjChanged);
    return ReadAttrsSetCtrls(fObjChanged);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::ReadAttrsSetCtrls
//
//  Synopsis:   Refreshes the UI.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTableDrivenPage::ReadAttrsSetCtrls(DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0, i, j;
    CWaitCursor wait;

    PWSTR * rgpwszAttrNames = new LPWSTR[m_cAttrs];
    CHECK_NULL_REPORT(rgpwszAttrNames, GetHWnd(), return E_OUTOFMEMORY);

    if (fInit == DlgOp)
    {
        // Check what attributes are writable.
        //
        CheckIfPageAttrsWritable();
    }

    // Build the list of attribute names.
    //
    for (i = 0; i < m_cAttrs; i++)
    {
        // If the attr name in the table is null, then don't try to do a
        // fetch on that attr. Attr table entries of that sort are used for
        // special purposes such as push buttons or check boxes. If the
        // attr name is set to null, then the attr must be declared as read-
        // only.
        //
        if (m_rgpAttrMap[i]->AttrInfo.pszAttrName)
        {
            // If the attribute already appears in the attribute list
            // then don't add it again
            bool fAlreadyPresent = false;
            for (j = 0; j < cAttrs; j++)
            {
                if ( _wcsicmp(m_rgpAttrMap[i]->AttrInfo.pszAttrName,
                              rgpwszAttrNames[j] ) == 0 )
                {
                    fAlreadyPresent = true;
                    break;
                }
            }
            if (!fAlreadyPresent)
            {
                rgpwszAttrNames[cAttrs] = m_rgpAttrMap[i]->AttrInfo.pszAttrName;
                cAttrs++;
            }
        }
    }

    // Get the attribute values.
    //
    hr = m_pDsObj->GetObjectAttributes(rgpwszAttrNames, cAttrs, &pAttrs,
                                       &cAttrs);
    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
    {
        goto ExitCleanup;
    }

    // The returned values are a subset of the requested values. Loop over
    // both sets, checking for matches.
    //
    // JonN 5/5/98 Removed assumption that returned values are in same order,
    // added support for multiple table entries for same attribute (all but
    // one must be read-only)
    //
    for (i = 0; i < m_cAttrs; i++)
    {
        if (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]) &&
            !m_rgpAttrMap[i]->fIsReadOnly &&
            !m_rgpAttrMap[i]->pAttrFcn)
        {
            // If user does not have write permission for the attribute and
            // the control is not already read-only and there is no attr
            // function then disable the control.
            //
            if (ADSTYPE_CASE_IGNORE_STRING == m_rgpAttrMap[i]->AttrInfo.dwADsType &&
                !m_rgpAttrMap[i]->fIsMultiValued)
            {
               // If it is a single-valued text attribute, make its edit box
               // read only.
               //
               SendDlgItemMessage(m_hPage, m_rgpAttrMap[i]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
            }
            else
            {
               EnableWindow(GetDlgItem(m_hPage, m_rgpAttrMap[i]->nCtrlID), FALSE);
            }
        }
        BOOL fFound = FALSE;
        for (j = 0; j < cAttrs; j++)
        {
            if (m_rgpAttrMap[i]->AttrInfo.pszAttrName &&
                _wcsicmp(m_rgpAttrMap[i]->AttrInfo.pszAttrName,
                         pAttrs[j].pszAttrName) == 0)
            {
                dspAssert(!fFound);
                fFound = TRUE;

                if (m_rgpAttrMap[i]->AttrInfo.dwADsType != pAttrs[j].dwADsType)
                {
                    dspDebugOut((DEB_ITRACE,
                                 "ADsType: from table = %d, returned = %d.\n",
                                 m_rgpAttrMap[i]->AttrInfo.dwADsType,
                                 pAttrs[j].dwADsType));
                    m_rgpAttrMap[i]->AttrInfo.dwADsType = pAttrs[j].dwADsType;
                }

                if (m_rgpAttrMap[i]->pAttrFcn)
                {
                    // Handle special-case attribute
                    //
                    hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                                      &pAttrs[j], 0,
                                                      &m_rgAttrData[i], DlgOp);
                    if (hr != S_FALSE)
                    {
                        // If the attr function returns S_FALSE, that means
                        // let the standard text control processing below
                        // display the value.
                        //
                        break;
                    }
                }

                dspAssert(pAttrs[j].dwNumValues > 0);

                if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
                {
                    // Handle boolean attribute, initialize the checkbox.
                    //
                    if (pAttrs[j].pADsValues->Boolean)
                    {
                        CheckDlgButton(m_hPage, m_rgpAttrMap[i]->nCtrlID,
                                       BST_CHECKED);
                    }
                    break;
                }

                // Assumes that all non-special-case attributes, if
                // single-valued and not boolean, go into a text control.
                //
                SendDlgItemMessage(m_hPage, m_rgpAttrMap[i]->nCtrlID,
                                   EM_LIMITTEXT, m_rgpAttrMap[i]->nSizeLimit,
                                   0);
                LPTSTR ptszValue = NULL;
                LPWSTR pwszValue;
                WCHAR wszNum[64];
                switch (pAttrs[j].dwADsType)
                {
                case ADSTYPE_DN_STRING:
                    pwszValue = pAttrs[j].pADsValues->DNString;
                    break;
                case ADSTYPE_CASE_EXACT_STRING:
                    pwszValue = pAttrs[j].pADsValues->CaseExactString;
                    break;
                case ADSTYPE_CASE_IGNORE_STRING:
                    pwszValue = pAttrs[j].pADsValues->CaseIgnoreString;
                    break;
                case ADSTYPE_PRINTABLE_STRING:
                    pwszValue = pAttrs[j].pADsValues->PrintableString;
                    break;
                case ADSTYPE_NUMERIC_STRING:
                    pwszValue = pAttrs[j].pADsValues->NumericString;
                    break;
                case ADSTYPE_INTEGER:
                    wsprintfW(wszNum, L"%d", pAttrs[j].pADsValues->Integer);
                    pwszValue = wszNum;
                    break;
                case ADSTYPE_LARGE_INTEGER:
                    __int64 i64;
                    memcpy(&i64, &pAttrs[j].pADsValues->LargeInteger,
                           sizeof(pAttrs[j].pADsValues->LargeInteger));
                    swprintf(wszNum, L"%I64d", i64);
                    pwszValue = wszNum;
                    break;
                default:
                    dspDebugOut((DEB_ERROR, "Unknown ADS Type %x\n",
                                 pAttrs[j].dwADsType));
                    pwszValue = L"";
                }

                if (!UnicodeToTchar(pwszValue, &ptszValue))
                {
                    goto ExitCleanup;
                }

                SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptszValue);

                delete ptszValue;

                break;
            }
        }
        if (!fFound)
        {
            if (m_rgpAttrMap[i]->pAttrFcn)
            {
                (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                             0, &m_rgAttrData[i], DlgOp);
                continue;
            }
            if (!m_rgpAttrMap[i]->fIsMultiValued)
            {
                SendDlgItemMessage(m_hPage, m_rgpAttrMap[i]->nCtrlID,
                                   EM_LIMITTEXT, m_rgpAttrMap[i]->nSizeLimit,
                                   0);
                switch (m_rgpAttrMap[i]->AttrInfo.dwADsType)
                {
                case ADSTYPE_DN_STRING:
                case ADSTYPE_CASE_EXACT_STRING:
                case ADSTYPE_CASE_IGNORE_STRING:
                case ADSTYPE_PRINTABLE_STRING:
                case ADSTYPE_NUMERIC_STRING:
                    SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, TEXT(""));
                    break;
                }
            }
        }
    }

ExitCleanup:

    if (pAttrs)
    {
        FreeADsMem(pAttrs);
    }

    delete rgpwszAttrNames;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnAttrChanged
//
//  Synopsis:   Attribute Change notification for inter-page syncronization.
//              Handles the private DSPROP_ATTRCHANGED_MSG message.
//
//  Arguments:  wParam - contains a pointer to an ADS_ATTR_INFO that contains
//                       the changed attribute value. The attribute is named
//                       in this struct, so it is self-describing.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnAttrChanged(WPARAM wParam)
{
    if (m_fInInit)
    {
        return 0;
    }

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        // Call attr functions.
        //
        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                         (PADS_ATTR_INFO)wParam, 0,
                                         &m_rgAttrData[i], fAttrChange);
        }
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnQuerySibs
//
//  Synopsis:   Inter-page communication. Handles the PSM_QUERYSIBLINGS msg.
//
//  Arguments:  wParam - pointer to the name of the attribute in question.
//              lParam - HWND of the page that wants to know if the attr has
//                       changed.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnQuerySibs(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }

    LRESULT ret = 0;
    HRESULT hr;

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        // Call attr functions.
        //
        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                              (PADS_ATTR_INFO)wParam, lParam,
                                              &m_rgAttrData[i], fQuerySibling);
            if (hr != S_OK)
            {
                ret = hr;
            }
        }
    }
    return ret;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnNotify
//
//  Synopsis:   Handles notification messages
//
//  Arguments:  [lParam] - a pointer to a NMHDR structure.
//              [wParam] - the control ID.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    DWORD i;
    HRESULT hr = S_OK;

    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_SETACTIVE:
    case PSN_KILLACTIVE:
        if (m_fInInit)
        {
            return 0;
        }

        for (i = 0; i < m_cAttrs; i++)
        {
            // Call attr functions.
            //
            if (m_rgpAttrMap[i]->pAttrFcn)
            {
                hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                                  lParam,
                                                  &m_rgAttrData[i],
                                                  (PSN_SETACTIVE == ((LPNMHDR)lParam)->code) ?
                                                  fOnSetActive : fOnKillActive);

                if (PSNRET_INVALID_NOCHANGEPAGE == HRESULT_CODE(hr))
                {
                    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT,
                                     (LONG_PTR)PSNRET_INVALID_NOCHANGEPAGE);
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
            }
        }
        break;

    default:
        if (!m_fInInit)
        {
            for (i = 0; i < m_cAttrs; i++)
            {
                // Call attr functions.
                //
                if (m_rgpAttrMap[i]->pAttrFcn)
                {
                    (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                                 lParam,
                                                 &m_rgAttrData[i], fOnNotify);
                }
            }
        }
        break;
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnDestroy(void)
{
    if (FAILED(m_hrInit))
    {
        return 0;
    }
    //
    // Allow attr functions to do control cleanup.
    //
    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                         0, &m_rgAttrData[i], fOnDestroy);
        }
    }
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::SetNamedAttrDirty
//
//  Synopsis:   Set a specific attribute dirty
//
//-----------------------------------------------------------------------------
BOOL CDsTableDrivenPage::SetNamedAttrDirty( LPCWSTR pszAttrName )
{
    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        if (   NULL != m_rgpAttrMap[i]->AttrInfo.pszAttrName
            && !_wcsicmp(pszAttrName, m_rgpAttrMap[i]->AttrInfo.pszAttrName)
            && !m_rgpAttrMap[i]->fIsReadOnly
           )
        {
            SetDirty(i);
            return TRUE;
        }
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   GeneralPageIcon
//
//  Synopsis:   Fetches the icon for the object class from the display spec
//              cache and draws it on the page. The GenIcon ATTR_MAP uses the
//              control ID IDC_DS_ICON. To use this, add an icon control to
//              your page sized appropriately (20 x 20) and labeled
//              IDC_DS_ICON, then add GenIcon to your ATTR_MAP array.
//
//-----------------------------------------------------------------------------
HRESULT GeneralPageIcon(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                        PADS_ATTR_INFO, LPARAM, PATTR_DATA pAttrData,
                        DLG_OP DlgOp)
{
    HRESULT hr;
    HICON hIcon;
    HWND hIconCtrl;
    CDsIconCtrl * pIconCtrl;

    switch (DlgOp)
    {
    case fInit:
        IDsDisplaySpecifier * pDispSpec;

        hr = pPage->GetIDispSpec(&pDispSpec);

        CHECK_HRESULT(hr, return hr);

        hIconCtrl = GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID);

        hIcon = pDispSpec->GetIcon(pPage->GetObjClass(),
                                   DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                                   32, 32);

        // NULL return puts up a default icon
        CHECK_NULL(hIcon, return S_OK);

        pIconCtrl = new CDsIconCtrl(hIconCtrl, hIcon);

        CHECK_NULL_REPORT(pIconCtrl, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrData->pVoid = reinterpret_cast<LPARAM>(pIconCtrl);

        break;

    case fOnDestroy:
        if (pAttrData->pVoid)
        {
            pIconCtrl = (CDsIconCtrl *)pAttrData->pVoid;
            DO_DEL(pIconCtrl);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:      CDsIconCtrl
//
//  Synopsis:   Icon control window subclass object, so we can paint a class-
//              specific icon.
//
//-----------------------------------------------------------------------------
CDsIconCtrl::CDsIconCtrl(HWND hCtrl, HICON hIcon) :
    m_hCtrl(hCtrl),
    m_hIcon(hIcon),
    m_pOldProc(NULL)
{
    SetWindowLongPtr(hCtrl, GWLP_USERDATA, (LONG_PTR)this);
    m_pOldProc = (WNDPROC)SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LONG_PTR)StaticCtrlProc);
    m_hDlg = GetParent(hCtrl);
}

CDsIconCtrl::~CDsIconCtrl(void)
{
    SetWindowLongPtr(m_hCtrl, GWLP_WNDPROC, (LONG_PTR)m_pOldProc);
    DestroyIcon(m_hIcon);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsIconCtrl::StaticCtrlProc
//
//  Synopsis:   control sub-proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CDsIconCtrl::StaticCtrlProc(HWND hCtrl, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDsIconCtrl * pCCtrl = (CDsIconCtrl*)GetWindowLongPtr(hCtrl, GWLP_USERDATA);

    if (pCCtrl != NULL)
    {
        if (uMsg == WM_PAINT)
        {
            if (!pCCtrl->OnPaint())
            {
                return FALSE;
            }
        }
        return CallWindowProc(pCCtrl->m_pOldProc, hCtrl, uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hCtrl, uMsg, wParam, lParam);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsIconCtrl::OnPaint
//
//  Synopsis:   Paint the DS specified icon.
//
//-----------------------------------------------------------------------------
LRESULT
CDsIconCtrl::OnPaint(void)
{
    HDC hDC;
    PAINTSTRUCT ps;

    hDC = BeginPaint(m_hCtrl, &ps);

    CHECK_NULL_REPORT(hDC, m_hDlg, return FALSE);

    if (!DrawIcon(hDC, 0, 0, m_hIcon))
    {
        REPORT_ERROR(GetLastError(), m_hDlg);
        return FALSE;
    }

    EndPaint(m_hCtrl, &ps);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\strings.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       strings.h
//
//  Contents:   String constants that don't need to be localized.
//
//  History:    06-Jun-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __STRINGS_H__
#define __STRINGS_H__

extern PWSTR g_wzLDAPPrefix;
extern PWSTR g_wzLDAPProvider;
extern PWSTR g_wzWINNTPrefix;
extern PWSTR g_wzPartitionsContainer;
extern PWSTR g_wzSidPathPrefix;
extern PWSTR g_wzSidPathSuffix;
extern PWSTR g_wzRootDSE;
extern PWSTR g_wzConfigNamingContext;
extern PWSTR g_wzSchemaNamingContext;

extern PWSTR g_wzCRLF;

extern PWSTR g_wzUser;
extern PWSTR g_wzGroup;
extern PWSTR g_wzContact;
extern PWSTR g_wzComputer;
extern PWSTR g_wzFPO;
#ifdef INETORGPERSON
extern PWSTR g_wzInetOrgPerson;
#endif

extern PWSTR g_wzClass;
extern PWSTR g_wzObjectClass;
extern PWSTR g_wzDescription;
extern PWSTR g_wzName;
extern PWSTR g_wzMemberAttr;
extern PWSTR g_wzObjectSID;
extern PWSTR g_wzGroupType;
extern PWSTR g_wzADsPath;
extern PWSTR g_wzStreet;
extern PWSTR g_wzPOB;
extern PWSTR g_wzCity;
extern PWSTR g_wzState;
extern PWSTR g_wzZIP;
extern PWSTR g_wzCountryName;
extern PWSTR g_wzCountryCode;
extern PWSTR g_wzTextCountry;
extern PWSTR g_wzDN;
extern PWSTR g_wzUserAccountControl;
extern PWSTR g_wzDomainMode;
extern PWSTR g_wzAllowed;
extern PWSTR g_wzBehaviorVersion;
extern PWSTR g_wzHasMasterNCs;
extern PWSTR g_wzA2D2;
extern PWSTR g_wzSPN;
extern PWSTR g_wzHost;
extern PWSTR g_wzSPNMappings;

#endif // __STRINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\attrfcns.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       attrfcns.cxx
//
//  Contents:   Various attribute functions for table-driven pages.
//
//  History:    2-April-98 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#if defined(DSADMIN)
#   include "trust.h"
#endif

//+----------------------------------------------------------------------------
//
//  Function:   ADsIntegerToCheckbox
//
//  Synopsis:   Handles an integer attribute and display its boolean value
//              in a checkbox control.
//
//  Remarks:    There are cases where an attribute is stored as an
//              integer while the UI wants to display the integer as
//              a boolean flag.
//
//-----------------------------------------------------------------------------
/* unused
HRESULT
ADsIntegerToCheckbox(
    CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
    PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
    DLG_OP DlgOp)
{
    dspAssert(pPage != NULL);
    dspAssert(pAttrMap != NULL);

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        //
        // If pAttrInfo is NULL, this means the attribute is not set. Treat
        // that the same as FALSE (i.e. don't check the box).
        //
        if (pAttrInfo)
        {
            dspAssert(pAttrInfo->pADsValues != NULL);
            dspAssert(pAttrInfo->dwADsType == ADSTYPE_INTEGER);
            dspAssert(pAttrInfo->dwNumValues == 1);
            dspAssert(pAttrInfo->pADsValues->dwType == ADSTYPE_INTEGER);
            dspAssert(IsWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID)));
            // Initialize the checkbox with the boolean value
            if (pAttrInfo->pADsValues->Integer != 0)
            {
                CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID, BST_CHECKED);
                #ifdef _DEBUG
                if (pAttrInfo->pADsValues->Integer != TRUE)
                {
                    dspDebugOut((DEB_ERROR, "WRN: ADsIntegerToCheckbox() - Integer is NOT boolean."));
                }
                #endif
            }
        }
        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        return S_OK;

    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            pPage->SetDirty();  // Page has been modified
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        return S_FALSE;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        dspAssert(pAttrInfo != NULL);
        dspAssert(pAttrInfo->dwADsType == ADSTYPE_INTEGER);
        dspAssert(pAttrInfo->pADsValues == NULL && "Memory Leak");
        dspAssert(pAttrInfo->dwNumValues == 0);
        dspAssert(IsWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID)));
        pAttrInfo->pADsValues = new ADSVALUE;
        if (pAttrInfo->pADsValues == NULL)
			return E_OUTOFMEMORY;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->pADsValues->dwType = ADSTYPE_INTEGER;
        pAttrInfo->pADsValues->Integer =
            (IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID)
                == BST_CHECKED);
        return S_OK;
    } // switch

    return S_FALSE;
}
*/

//+----------------------------------------------------------------------------
//
//  Function:   IntegerAsBoolDefOn
//
//  Synopsis:   Handles an integer attribute that is functioning as a BOOL to
//              set a check box.
//
//  Notes:      If the attribute is unset, the default is set to TRUE (the
//              checkbox is checked).
//
//-----------------------------------------------------------------------------
HRESULT
IntegerAsBoolDefOn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                   PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                   DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    BOOL fSet = TRUE;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            fSet = pAttrInfo->pADsValues->Integer;
        }
        CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID,
                       (fSet) ? BST_CHECKED : BST_UNCHECKED);

        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pADsValue->Integer = IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID) == BST_CHECKED;
        break;

    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetAcctName
//
//  Synopsis:   Get the account name using the SID.
//
//-----------------------------------------------------------------------------
HRESULT
GetAcctName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO, LPARAM, PATTR_DATA,
            DLG_OP DlgOp)
{
    HRESULT hr = S_OK;

    if (DlgOp != fInit)
    {
        return S_OK;
    }

#ifdef YANK // If the object is in another domain, we would need to supply a
            // valid DC name to LookupAccountSid. CrackNames already does that,
            // so use it instead.

    PSID pSid = NULL;
    TCHAR tzName[MAX_PATH], tzDomain[MAX_PATH], tzFullName[MAX_PATH+MAX_PATH];
    TCHAR tzErr[] = TEXT("Name not found");
    PTSTR ptzName;
    DWORD cchName = MAX_PATH-1, cchDomain = MAX_PATH-1;

    dspAssert(pAttrData);
    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pSid = pAttrInfo->pADsValues->OctetString.lpValue;
        SID_NAME_USE sne;

        if (!LookupAccountSid(NULL, pSid, tzName, &cchName, tzDomain, &cchDomain, &sne))
        {
            DWORD dwErr = GetLastError();
            dspDebugOut((DEB_ITRACE, "LookupAccountSid failed with error %d\n", dwErr));
            ptzName = tzErr;
        }
        else
        {
            _tcscpy(tzFullName, tzDomain);
            _tcscat(tzFullName, TEXT("\\"));
            _tcscat(tzFullName, tzName);

            ptzName = tzFullName;
        }
    }
    else
    {
        ptzName = tzErr;
    }
#endif // YANK

    PWSTR pwzPath, pwzDNSname;

    hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwzPath);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = CrackName(pwzPath, &pwzDNSname, GET_OBJ_CAN_NAME, pPage->GetHWnd());

    delete pwzPath;

    CHECK_HRESULT(hr, return hr);

    if (DS_NAME_ERROR_NO_MAPPING == HRESULT_CODE(hr))
    {
        MsgBox(IDS_FPO_NO_NAME_MAPPING, pPage->GetHWnd());
    }
    PTSTR ptszPath;

    if (!UnicodeToTchar(pwzDNSname, &ptszPath))
    {
        LocalFreeStringW(&pwzDNSname);
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    LocalFreeStringW(&pwzDNSname);

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptszPath);

    delete ptszPath;

    return hr;
}

#ifdef REMOVE_SPN_SUFFIX_CODE

#define MAX_SPN_LEN 4096

//+----------------------------------------------------------------------------
//
//  Class:      CSPNSuffixEdit
//
//  Purpose:    Read, edit, and write the multi-valued SPN Suffix string property.
//
//-----------------------------------------------------------------------------
CSPNSuffixEdit::CSPNSuffixEdit(CDsPropPageBase * pPage, PATTR_DATA pAttrData) :
    m_pPage(pPage),
    m_pAttrData(pAttrData),
    m_fListHasSel(FALSE),
    m_cValues(0)
{
}

CSPNSuffixEdit::~CSPNSuffixEdit()
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr type.
//              [pAttrInfo]  - place to store the values.
//-----------------------------------------------------------------------------
HRESULT
CSPNSuffixEdit::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo)
{
    // Limit the entry length of the edit control.
    //
    SendDlgItemMessage(m_pPage->GetHWnd(), IDC_EDIT, EM_LIMITTEXT, MAX_SPN_LEN, 0);

    //
    // Disable the Add, Change, and Remove buttons.
    //
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), IDC_ADD_BTN), FALSE);
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), IDC_DELETE_BTN), FALSE);
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), IDC_EDIT_BTN), FALSE);

    //
    // Initialize the list view.
    //
    RECT rect;
    LV_COLUMN lvc;
    HWND hList = GetDlgItem(m_pPage->GetHWnd(), IDC_LIST);
    ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);

    GetClientRect(hList, &rect);
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right;
    lvc.iSubItem = 0;

    ListView_InsertColumn(hList, 0, &lvc);

    if (NULL == pAttrInfo)
    {
        return S_OK;
    }

    // Load the list view.
    //
    LPTSTR ptz;
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 0;

    for (LONG i = 0; (DWORD)i < pAttrInfo->dwNumValues; i++)
    {
        if (!UnicodeToTchar(pAttrInfo->pADsValues[i].CaseIgnoreString, &ptz))
        {
            ReportError(E_OUTOFMEMORY, 0, m_pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        lvi.pszText = ptz;
        lvi.iItem = i;
        ListView_InsertItem(hList, &lvi);
        m_cValues++;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT
CSPNSuffixEdit::Write(PADS_ATTR_INFO pAttrInfo)
{
    pAttrInfo->dwNumValues = 0;

    HWND hList = GetDlgItem(m_pPage->GetHWnd(), IDC_LIST);
    int nItems = ListView_GetItemCount(hList);

    if (nItems == 0)
    {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        return S_OK;
    }

    pAttrInfo->pADsValues = new ADSVALUE[nItems];

    CHECK_NULL_REPORT(pAttrInfo->pADsValues, m_pPage->GetHWnd(), return -1);

    LPTSTR ptz = new TCHAR[MAX_SPN_LEN + 1];

    CHECK_NULL_REPORT(ptz, m_pPage->GetHWnd(), return -1);

    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 0;
    lvi.pszText = ptz;
    lvi.cchTextMax = MAX_SPN_LEN + 1;

    for (LONG i = 0; i < nItems; i++)
    {
        lvi.iItem = i;
        if (!ListView_GetItem(hList, &lvi))
        {
            DWORD dwErr = GetLastError();
            REPORT_ERROR(dwErr, m_pPage->GetHWnd());
            return HRESULT_FROM_WIN32(dwErr);
        }
        if (!TcharToUnicode(ptz, &pAttrInfo->pADsValues[i].CaseIgnoreString))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        pAttrInfo->pADsValues[i].dwType = pAttrInfo->dwADsType;
        pAttrInfo->dwNumValues++;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::EnableControls
//
//  Synopsis:   Enable or disable all of the controls.
//
//-----------------------------------------------------------------------------
void
CSPNSuffixEdit::EnableControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_LIST), fEnable);
    if (!fEnable)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
        m_fListHasSel = FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::DoCommand
//
//  Synopsis:   WM_COMMAND code.
//
//-----------------------------------------------------------------------------
HRESULT
CSPNSuffixEdit::DoCommand(HWND hDlg, int id, int code)
{
    LPTSTR ptz;
    LONG i;
    HWND hList;
    LV_ITEM lvi;
    switch (code)
    {
    case BN_CLICKED:
        switch (id)
        {
        case IDC_ADD_BTN:
            int nLen;

            nLen = (int)SendDlgItemMessage(hDlg, IDC_EDIT, WM_GETTEXTLENGTH, 0, 0);
            ptz = new TCHAR[++nLen];

            CHECK_NULL_REPORT(ptz, hDlg, return E_OUTOFMEMORY);

            if (GetWindowText(GetDlgItem(hDlg, IDC_EDIT), ptz, nLen))
            {
                hList = GetDlgItem(hDlg, IDC_LIST);
                i = ListView_GetItemCount(hList);
                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 0;
                lvi.pszText = ptz;
                lvi.iItem = i;
                ListView_InsertItem(hList, &lvi);
                m_cValues++;

                SetWindowText(GetDlgItem(hDlg, IDC_EDIT), TEXT(""));
                m_pPage->SetDirty();
                PATTR_DATA_SET_DIRTY(m_pAttrData);
                SetFocus(GetDlgItem(hDlg, IDC_EDIT));
            }

            delete ptz;

            return S_OK;

        case IDC_DELETE_BTN:
        case IDC_EDIT_BTN:
            hList = GetDlgItem(hDlg, IDC_LIST);

            i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);
            dspDebugOut((DEB_ITRACE, "List element %d selected\n", i));

            if (i >= 0)
            {
                if (id == IDC_DELETE_BTN)
                {
                    ListView_DeleteItem(hList, i);
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT));
                    m_fListHasSel = FALSE;
                    m_cValues--;
                    m_pPage->SetDirty();
                    PATTR_DATA_SET_DIRTY(m_pAttrData);
                }
                else
                {
                    SetFocus(GetDlgItem(hDlg, IDC_LIST));
                    ListView_EditLabel(hList, i);
                }
            }

            return S_OK;
        }
        break;

    case EN_CHANGE:
        if (id == IDC_EDIT)
        {
            BOOL fHasChars = 0 != SendDlgItemMessage(hDlg, IDC_EDIT,
                                                     WM_GETTEXTLENGTH,
                                                     0, 0);

            EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), fHasChars);

            // Return S_FALSE to skip default processing so that merely adding
            // text to the edit control won't set the dirty state. The page
            // isn't dirty until the Add button is clicked.
            //
            return S_FALSE;
        }
        break;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::DoNotify
//
//  Synopsis:   WM_NOTIFY code.
//
//-----------------------------------------------------------------------------
BOOL
CSPNSuffixEdit::DoNotify(HWND hDlg, NMHDR * pNmHdr)
{
    if (pNmHdr->idFrom != IDC_LIST)
    {
        return TRUE;
    }

    LV_DISPINFO * pldi = (LV_DISPINFO *)pNmHdr;

    switch (pNmHdr->code)
    {
    case LVN_ENDLABELEDIT:
        if (pldi->item.pszText)
        {
            dspDebugOut((DEB_ITRACE, "Editing item %d, new value %S\n",
                         pldi->item.iItem, pldi->item.pszText));
            ListView_SetItemText(pldi->hdr.hwndFrom, pldi->item.iItem, 0,
                                 pldi->item.pszText);
            m_pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(m_pAttrData);
        }
        break;

    case NM_SETFOCUS:
        dspDebugOut((DEB_ITRACE, "NM_SETFOCUS received\n"));
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            //
            // If the list control gets the focus by tabbing and no item
            // is selected, then set the selection to the first item.
            //
            if (!m_fListHasSel)
            {
                dspDebugOut((DEB_ITRACE, "setting the list selection\n"));
                m_fListHasSel = TRUE;
                ListView_SetItemState(GetDlgItem(hDlg, IDC_LIST), 0, 
                                      LVIS_FOCUSED | LVIS_SELECTED,
                                      LVIS_FOCUSED | LVIS_SELECTED);
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
            }
        }
        return 1;

    case LVN_ITEMCHANGED:
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            m_fListHasSel = TRUE;
            EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
        }
        return 1;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNEdit
//
//  Synopsis:   Attr function for the SPN page Edit control.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        pCSPN = new CSPNSuffixEdit(pPage, pAttrData);

        CHECK_NULL_REPORT(pCSPN, pPage->GetHWnd(), return E_OUTOFMEMORY);

        ((CDsTableDrivenPage *)pPage)->m_pData = pCSPN;

        hr = pCSPN->Init(pAttrMap, pAttrInfo);

        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        hr = pCSPN->Write(pAttrInfo);

        break;

    case fOnCommand:
        if (pCSPN)
        {
            return pCSPN->DoCommand(pPage->GetHWnd(), IDC_EDIT, (int)lParam);
        }
        break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNList
//
//  Synopsis:   Attr function for the SPN page List control.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnNotify && pCSPN)
    {
        pCSPN->DoNotify(pPage->GetHWnd(), reinterpret_cast<LPNMHDR>(lParam));
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNAdd
//
//  Synopsis:   Attr function for the SPN page Add button.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNAdd(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnCommand && pCSPN)
    {
        pCSPN->DoCommand(pPage->GetHWnd(), IDC_ADD_BTN, (int)lParam);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNRemove
//
//  Synopsis:   Attr function for the SPN page Remove button.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNRemove(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnCommand && pCSPN)
    {
        pCSPN->DoCommand(pPage->GetHWnd(), IDC_DELETE_BTN, (int)lParam);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNChange
//
//  Synopsis:   Attr function for the SPN page Edit button.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNChange(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnCommand && pCSPN)
    {
        return pCSPN->DoCommand(pPage->GetHWnd(), IDC_EDIT_BTN, (int)lParam);
    }

    return S_OK;
}
#endif //REMOVE_SPN_SUFFIX_CODE

//+----------------------------------------------------------------------------
//
//  Function:   VolumeUNCpath
//
//  Synopsis:   Attr function for the UNC path.
//
//-----------------------------------------------------------------------------
HRESULT
VolumeUNCpath(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA,
              DLG_OP DlgOp)
{
    int cch;

    switch (DlgOp)
    {
    case fInit:
        return S_FALSE; // let the tablepage code display the value.
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                          WM_GETTEXTLENGTH, 0, 0);
            if (0 == cch)
            {
                // UNC name is a required property, so disable the
                // apply button if blank.
                //
                dspDebugOut((DEB_ITRACE, "no characters, disabling Apply.\n"));
                //
                // Gotta set the dirty state here cause returning S_FALSE
                // means that the base class will not be called. The page needs
                // to be dirty because PropSheet_UnChanged does not disable the
                // OK button and if it is pressed the sheet will be closed
                // without the warning to the user that the UNC field is empty.
                // This is actually benign because the OnApply is skipped because
                // the page isn't dirty. However its appearance is deceptive;
                // it looke like a save is made when in fact it isn't.
                //
                pPage->SetDirty(FALSE);
                //
                // Now disable the Apply button.
                //
                PropSheet_UnChanged(GetParent(pPage->GetHWnd()), pPage->GetHWnd());
                return S_FALSE;
            }
        }
        break;

    case fApply:
        cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      WM_GETTEXTLENGTH, 0, 0);
        if (0 == cch)
        {
            // UNC name is a required property
            //
            ErrMsg(IDS_ERRMSG_NO_VOLUME_PATH, pPage->GetHWnd());
            SetFocus(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
            return E_INVALIDARG;  // Path is not valid
        }

        PTSTR ptz = new TCHAR[++cch];

        CHECK_NULL_REPORT(ptz, pPage->GetHWnd(), return E_OUTOFMEMORY);

        GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz, cch);

        if (!FIsValidUncPath(ptz, VUP_mskfAllowUNCPath))
        {
            ErrMsg(IDS_ERRMSG_INVALID_VOLUME_PATH, pPage->GetHWnd());
            SetFocus(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
            return E_INVALIDARG;  // Path is not valid
        }

        PWSTR pwz;

        if (!TcharToUnicode(ptz, &pwz))
        {
            delete [] ptz;
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
        }
        delete [] ptz;

        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pADsValue->CaseIgnoreString = pwz;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\behaviorversion.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       BehaviorVersion.h
//
//  Contents:   AD behavior version viewing/modification dialogs and fcns.
//
//  Classes:    
//
//  History:    6-April-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef BEHAVIOR_VERSION_H_GUARD
#define BEHAVIOR_VERSION_H_GUARD

#include <list>
#include "dlgbase.h"

// Definitions of levels. TODO: Revise whenever Whistler gets a permanent name.
//
#define DC_VER_WIN2K              (DS_BEHAVIOR_WIN2000)
#define DC_VER_XP_BETA            (DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
#define DC_VER_XP                 (DS_BEHAVIOR_WHISTLER)

#define DOMAIN_VER_WIN2K_MIXED    (DS_BEHAVIOR_WIN2000)
#define DOMAIN_VER_WIN2K_NATIVE   (DS_BEHAVIOR_WIN2000)
#define DOMAIN_VER_XP_BETA_MIXED  (DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
#define DOMAIN_VER_XP_BETA_NATIVE (DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
#define DOMAIN_VER_XP_NATIVE      (DS_BEHAVIOR_WHISTLER)
#define DOMAIN_VER_UNKNOWN        (0xffffffff)

#define FOREST_VER_WIN2K          (DS_BEHAVIOR_WIN2000)
#define FOREST_VER_XP_BETA        (DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
#define FOREST_VER_XP             (DS_BEHAVIOR_WHISTLER)
#define FOREST_VER_ERROR          (0xffffffff)

//+----------------------------------------------------------------------------
//
//  Class:     CDcListItem
//
//-----------------------------------------------------------------------------
class CDcListItem
{
public:
   CDcListItem(PCWSTR pwzDomainName, PCWSTR pwzDcName,
               PCWSTR pwzCompObjDN, UINT nCurVer) :
      _strDomainName(pwzDomainName),
      _strDcName(pwzDcName),
      _strComputerObjDN(pwzCompObjDN),
      _nCurVer(nCurVer) {};
   ~CDcListItem() {};

   PCWSTR GetDomainName(void) const {return _strDomainName;};
   PCWSTR GetDcName(void) const {return _strDcName;};
   PCWSTR GetCompObjDN(void) const {return _strComputerObjDN;};
   UINT   GetVersion(void) const {return _nCurVer;};

private:
   CStrW    _strDomainName;
   CStrW    _strDcName;
   CStrW    _strComputerObjDN;
   UINT     _nCurVer;
};

//+----------------------------------------------------------------------------
//
//  Class:     CVersionBase
//
//-----------------------------------------------------------------------------
class CVersionBase
{
public:
   CVersionBase(void) :
      _fReadOnly(true),
      _fCanRaiseBehaviorVersion(true),
      _fHelpInited(false),
      _nMinDcVerFound(0),
      _dwHelpCookie(0),
      _hDlg(NULL) {};
   virtual ~CVersionBase(void);

   void    InitHelp(void);
   void    ShowHelp(PCWSTR pwzHelpFile, HWND hWnd);
   bool    IsReadOnly(void) const {return _fReadOnly;};
   HRESULT BuildDcListString(CStrW & strList);
   PCWSTR  GetDC(void) const {return _strDC;};
   void    SetDlgHwnd(HWND hDlg) {_hDlg = hDlg;};
   HWND    GetDlgHwnd(void) const {return _hDlg;};
   HRESULT ReadDnsSrvName(PCWSTR pwzNTDSDSA, CComPtr<IADs> & spServer,
                          CComVariant & varSrvDnsName);
   HRESULT EnumDsaObjs(PCWSTR pwzSitesPath, PCWSTR pwzFilterClause,
                       PCWSTR pwzDomainDnsName, UINT nMinVer);

   typedef std::list<CDcListItem *> DC_LIST;

protected:
   bool                    _fReadOnly;
   bool                    _fCanRaiseBehaviorVersion;
   CStrW                   _strDC;
   DC_LIST                 _DcLogList;
   UINT                    _nMinDcVerFound;

private:
   bool     _fHelpInited;
   DWORD    _dwHelpCookie;
   HWND     _hDlg;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDomainVersion
//
//  Purpose:    Manages the interpretation of the domain version value.
//
//-----------------------------------------------------------------------------
class CDomainVersion : public CVersionBase
{
public:
   CDomainVersion() :
      _nCurVer(0),
      _fMixed(true),
      _fInitialized(false),
      _fPDCfound(false),
      _eHighest(WhistlerNative) {};
   CDomainVersion(PCWSTR pwzDomPath, PCWSTR pwzDomainDnsName) :
      _strFullDomainPath(pwzDomPath),
      _strDomainDnsName(pwzDomainDnsName),
      _nCurVer(0),
      _fMixed(true),
      _fInitialized(false),
      _fPDCfound(false),
      _eHighest(WhistlerNative) {};
   ~CDomainVersion(void) {};

   enum eDomVer {
      Win2kMixed = 0,
      Win2kNative,
      WhistlerBetaMixed,
      WhistlerBetaNative,
      WhistlerNative,
      VerHighest = WhistlerNative,
      unknown,
      error
   };

   HRESULT  Init(void);
   eDomVer  MapVersion(UINT nVer, bool fMixed) const;
   eDomVer  GetVer(void) const {return MapVersion(_nCurVer, _fMixed);};
   eDomVer  Highest(void) const {return VerHighest;};
   eDomVer  HighestCanGoTo(void) const {return _eHighest;};
   bool     IsHighest(void) const {return GetVer() == Highest();};
   bool     GetString(eDomVer ver, CStrW & strVersion) const;
   bool     GetString(UINT nVer, bool fMixed, CStrW & strVersion) const;
   bool     IsPDCfound(void) {return _fPDCfound;};
   bool     CanRaise(void) const {return _fCanRaiseBehaviorVersion || _fMixed;};
   HRESULT  GetMode(bool & fMixed);
   HRESULT  CheckHighestPossible(void);
   HRESULT  SetNativeMode(void);
   HRESULT  RaiseVersion(eDomVer NewVer);

private:
   CStrW    _strDomainDnsName;
   CStrW    _strFullDomainPath;
   CStrW    _strDomainDN;
   UINT     _nCurVer;
   bool     _fMixed;
   bool     _fInitialized;
   bool     _fPDCfound;
   eDomVer  _eHighest;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDomainVersionDlg
//
//  Purpose:    Posts a dialog to display and manipulate the domain version.
//
//-----------------------------------------------------------------------------
class CDomainVersionDlg : public CModalDialog
{
public:
   CDomainVersionDlg(HWND hParent, PCWSTR pwzDomDNS, CDomainVersion & DomVer,
                     int nTemplateID);
   ~CDomainVersionDlg(void) {};

private:
   LRESULT OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnOK(void);
   //LRESULT OnHelp(LPHELPINFO pHelpInfo);
   void    OnSaveLog(void);

   void    InitCombobox(void);
   CDomainVersion::eDomVer ReadComboSel(void);

   CStrW             _strDomainDnsName;
   CDomainVersion &  _DomainVer;
};

//+----------------------------------------------------------------------------
//
//  Class:     CDomainListItem
//
//-----------------------------------------------------------------------------
class CDomainListItem
{
public:
   CDomainListItem(PCWSTR pwzDnsDomainName, UINT nVer, bool fMixed) :
      _strDnsDomainName(pwzDnsDomainName), _nCurVer(nVer), _fMixed(fMixed) {};
   ~CDomainListItem() {};

   PCWSTR   GetDnsDomainName(void) const {return _strDnsDomainName;};
   UINT     GetVer(void) const {return _nCurVer;};
   bool     GetMode(void) const {return _fMixed;}

private:
   UINT  _nCurVer;
   bool  _fMixed;
   CStrW _strDnsDomainName;
};

//+----------------------------------------------------------------------------
//
//  Class:      CForestVersion
//
//  Purpose:    Manages the interpretation of the forest version value.
//
//-----------------------------------------------------------------------------
class CForestVersion : public CVersionBase
{
public:
   CForestVersion() :
      _fInitialized(false),
      _fFsmoDcFound(true),
      _nCurVer(0) {};
   ~CForestVersion();

   HRESULT  Init(PCWSTR pwzDC);
   HRESULT  Init(PCWSTR pwzConfigPath, PCWSTR pwzPartitionsPath,
                 PCWSTR pwzSchemaPath);
   HRESULT  FindSchemaMasterReadVersion(PCWSTR pwzSchemaPath);
   UINT     GetVer(void) const {dspAssert(_fInitialized); return _nCurVer;};
   bool     GetString(UINT nVer, CStrW & strVer);
   bool     CanRaise(void) const {return _fCanRaiseBehaviorVersion;};
   bool     IsHighest(void) const {return FOREST_VER_XP == _nCurVer;};
   bool     IsFsmoDcFound(void) const {return _fFsmoDcFound;};
   HRESULT  CheckHighestPossible(void);
   HRESULT  CheckDomainVersions(PCWSTR pwzPartitionsPath);
   HRESULT  BuildMixedModeList(CStrW & strMsg);
   HRESULT  RaiseVersion(UINT nVer);

   typedef std::list<CDomainListItem *> DOMAIN_LIST;

private:
   bool        _fInitialized;
   bool        _fFsmoDcFound;
   UINT        _nCurVer;
   CStrW       _strConfigPath;
   CStrW       _strPartitionsPath;
   DOMAIN_LIST _DomainLogList;
};

//+----------------------------------------------------------------------------
//
//  Class:      CForestVersionDlg
//
//  Purpose:    
//
//-----------------------------------------------------------------------------
class CForestVersionDlg : public CModalDialog
{
public:
   CForestVersionDlg(HWND hParent, PCWSTR pwzRootDnsName,
                     CForestVersion & ForestVer, int nTemplateID);
   ~CForestVersionDlg(void) {};

private:
   LRESULT OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnOK(void);
   //LRESULT OnHelp(LPHELPINFO pHelpInfo);
   void    OnSaveLog(void);

   void    InitCombobox(void);
   UINT    ReadComboSel(void);

   CStrW            _strRootDnsName;
   CForestVersion & _ForestVer;
   UINT             _nTemplateID;
};

#endif // BEHAVIOR_VERSION_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\certifct.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       Certifct.cpp
//
//  Contents:   Implementation of CCertmgrApp and DLL registration.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "pages.h"
#include "proppage.h"
#include "Certifct.h"

#ifdef DSADMIN

/////////////////////////////////////////////////////////////////////////////
//
enum {
	FIELD_CAN_DELETE = 0x00000001
};

CCertificate::CCertificate(const PCCERT_CONTEXT pCertContext,
		HCERTSTORE hCertStore) 
:	m_pCertContext (::CertDuplicateCertificateContext (pCertContext)),
	m_pCertInfo (0),
	m_hCertStore (::CertDuplicateStore (hCertStore)),
	m_szEnhancedKeyUsage (0),
	m_szAltSubjectName (0),
	m_szAltIssuerName (0),
	m_szValidNotAfter (0),
	m_szSubjectName (0),
	m_szIssuerName (0),
	m_bCertContextFreed (false),
	m_fieldChecked (0),
	m_bCanDelete (false)
{
	dspAssert (m_pCertContext);
	if ( m_pCertContext )
		m_pCertInfo = m_pCertContext->pCertInfo;
}



CCertificate::~CCertificate()
{
	if ( m_szEnhancedKeyUsage )
		delete [] m_szEnhancedKeyUsage;
	if ( m_szAltSubjectName )
		delete [] m_szAltSubjectName;
	if ( m_szAltIssuerName )
		delete [] m_szAltIssuerName;
	if ( m_szValidNotAfter )
		delete [] m_szValidNotAfter;
	if ( m_szSubjectName )
		delete [] m_szSubjectName;
	if ( m_szIssuerName )
		delete [] m_szIssuerName;
	if ( m_pCertContext && !m_bCertContextFreed )
		::CertFreeCertificateContext (m_pCertContext);

	if ( m_hCertStore )
		::CertCloseStore (m_hCertStore, 0);
}


HRESULT CCertificate::GetIssuerName (PWSTR *ppszIssuerName)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszIssuerName);
	if ( m_pCertInfo && ppszIssuerName )
	{
		// Decode issuer name if not already present
		if ( !m_szIssuerName )
		{
			hResult = GetNameString (CERT_NAME_ISSUER_FLAG, &m_szIssuerName);
		}
		if ( SUCCEEDED (hResult) )
		{
			if ( *ppszIssuerName )
				delete [] *ppszIssuerName;
			*ppszIssuerName = new WCHAR[wcslen (m_szIssuerName) + 1];
			if ( *ppszIssuerName )
			{
				wcscpy (*ppszIssuerName, m_szIssuerName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
	}
	else
		hResult = E_POINTER;


	return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetSubjectName(PWSTR *ppszSubjectName)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszSubjectName);
	if ( m_pCertInfo && ppszSubjectName )
	{
		// Decode issuer name if not already present
		if ( !m_szSubjectName )
		{
			hResult = GetNameString (0, &m_szSubjectName);
		}
		if ( SUCCEEDED (hResult) )
		{
			if ( *ppszSubjectName )
				delete [] *ppszSubjectName;
			*ppszSubjectName = new WCHAR[wcslen (m_szSubjectName) + 1];
			if ( *ppszSubjectName )
			{
				wcscpy (*ppszSubjectName, m_szSubjectName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
	}
	else
		hResult = E_POINTER;


	return hResult;
}


///////////////////////////////////////////////////////////////////////////
//	GetValidNotAfter ()
//
//	pszDateTime (IN / OPTIONAL)	 - returns the formatted date and time.
//	cbDateTime	(IN / OUT)		 - If pszDateTime is NULL, then the required length
//								of pszDateTime is returned.  
//								Otherwise, contains the length of pszDateTime.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetValidNotAfter (PWSTR* ppszValidNotAfter)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszValidNotAfter);
	if ( m_pCertInfo && ppszValidNotAfter )
	{
		// Format date/time string if not already present
		if ( !m_szValidNotAfter )
		{
			hResult = FormatDate (m_pCertInfo->NotAfter, &m_szValidNotAfter);
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszValidNotAfter )
					delete [] *ppszValidNotAfter;
				*ppszValidNotAfter = new WCHAR[wcslen (m_szValidNotAfter)+1];
				if ( *ppszValidNotAfter )
				{
					wcscpy (*ppszValidNotAfter, m_szValidNotAfter);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


HRESULT CCertificate::GetEnhancedKeyUsage (PWSTR* ppszUsages)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszUsages);
	if ( m_pCertInfo && ppszUsages )
	{
		// Format date/time string if not already present
		if ( !m_szEnhancedKeyUsage )
		{
			hResult = FormatEnhancedKeyUsagePropertyString ();
			if ( SUCCEEDED (hResult) && m_szEnhancedKeyUsage )
			{
				if ( *ppszUsages )
					delete [] *ppszUsages;
				*ppszUsages = new WCHAR[wcslen (m_szEnhancedKeyUsage)+1];
				if ( *ppszUsages )
				{
					wcscpy (*ppszUsages, m_szEnhancedKeyUsage);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


HRESULT CCertificate::FormatEnhancedKeyUsagePropertyString ()
{
	HRESULT	hResult = S_OK;
	DWORD	cbUsage = 0;
	DWORD	dwErr = 0;
	BOOL	bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
			NULL, &cbUsage);
	if ( bReturn )
	{
		PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbUsage];
		if ( pUsage )
		{
			bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
					pUsage, &cbUsage);
			if ( bReturn )
			{
				size_t	dwLen = 0;
				PWSTR	pszComma = _T(", ");
				size_t	dwCommaLen = wcslen (pszComma);
				PWSTR	pszUsageName = 0;


				// Get accumulated lengths first
				for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
				{
					hResult = GetOIDInfo (&pszUsageName, pUsage->rgpszUsageIdentifier[dwIndex]);
					if ( SUCCEEDED (hResult) )
					{
						// add delimeter if not first iteration
						if ( dwIndex != 0 )
							dwLen += dwCommaLen;
						dwLen += wcslen (pszUsageName);
						delete [] pszUsageName;
						pszUsageName = 0;
					}
					else
						break;
				}

				// Allocate buffer and get strings
				if ( m_szEnhancedKeyUsage )
				{
					delete [] m_szEnhancedKeyUsage;
				}
				m_szEnhancedKeyUsage = new WCHAR[dwLen+1];
				if ( m_szEnhancedKeyUsage )
				{
					::ZeroMemory (m_szEnhancedKeyUsage, (dwLen+1)* sizeof (WCHAR));
					for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
					{
						hResult = GetOIDInfo (&pszUsageName, pUsage->rgpszUsageIdentifier[dwIndex]);
						if ( SUCCEEDED (hResult) )
						{
							// add delimeter if not first iteration
							if ( dwIndex != 0 )
								wcscat (m_szEnhancedKeyUsage, pszComma);
							wcscat (m_szEnhancedKeyUsage, pszUsageName);
							dspAssert (wcslen (m_szEnhancedKeyUsage) <= dwLen);
							delete [] pszUsageName;
							pszUsageName = 0;
						}
						else
							break;
					}
				}
				else
					hResult = E_OUTOFMEMORY;
			}
			else
			{
				dwErr = GetLastError ();
				dspAssert (dwErr == CRYPT_E_NOT_FOUND);
				if ( dwErr == CRYPT_E_NOT_FOUND )
				{
					if ( !LoadStringToTchar (IDS_ANY, &m_szEnhancedKeyUsage) )
						hResult = E_UNEXPECTED;
				}
				else
				{
					hResult = HRESULT_FROM_WIN32 (GetLastError ());
				}
			}
			delete [] pUsage;
		}
		else
			hResult = E_OUTOFMEMORY;
	}
	else
	{
		dwErr = GetLastError ();
		dspAssert (dwErr == CRYPT_E_NOT_FOUND);
		if ( dwErr != CRYPT_E_NOT_FOUND )
			hResult = HRESULT_FROM_WIN32 (GetLastError ());
	}
    return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateIssuerName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetAlternateIssuerName (PWSTR* ppszAltIssuerName)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszAltIssuerName);
	if ( m_pCertInfo && ppszAltIssuerName )
	{
		if ( !m_szAltIssuerName )
		{
			hResult = ConvertAltNameToString (_T(szOID_ISSUER_ALT_NAME),
					CERT_ALT_NAME_URL, &m_szAltIssuerName);
			dspAssert (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszAltIssuerName )
					delete [] *ppszAltIssuerName;
				*ppszAltIssuerName = new WCHAR[wcslen (m_szAltIssuerName)+1];
				if ( *ppszAltIssuerName )
				{
					wcscpy (*ppszAltIssuerName, m_szAltIssuerName);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;
	
	return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetAlternateSubjectName (PWSTR* ppszAltSubjectName)
{
	HRESULT	hResult = S_OK;
	dspAssert (m_pCertInfo && ppszAltSubjectName);
	if ( m_pCertInfo && ppszAltSubjectName )
	{
		if ( !m_szAltSubjectName )
		{
			hResult = ConvertAltNameToString (_T(szOID_SUBJECT_ALT_NAME),
					CERT_ALT_NAME_URL, &m_szAltSubjectName);
			dspAssert (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszAltSubjectName )
					delete [] *ppszAltSubjectName;
				*ppszAltSubjectName = new WCHAR[wcslen (m_szAltSubjectName)+1];
				if ( *ppszAltSubjectName )
				{
					wcscpy (*ppszAltSubjectName, m_szAltSubjectName);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;
	
	return hResult;
}


//////////////////////////////////////////////////////////////////////////////
//	ConvertAltNameToString ()
//
//  szOID (IN)			- The OID of the alternate name to retrieve
//	dwNameChoice (IN)	- The type of alternate name to return
//	altName (OUT)		- The version of the desired alternate name indicated
//							by dwNameChoice
//////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::ConvertAltNameToString (PWSTR szOID, const DWORD dwNameChoice, PWSTR* ppszAltName)
{
	HRESULT	hResult = S_OK;
	dspAssert (ppszAltName && szOID);
	if ( !ppszAltName || !szOID )
		return E_POINTER;

	// Iterate through the extensions until the one indicated by the
	// passed-in szOID is found.
	for (DWORD	index = 0; index < m_pCertInfo->cExtension; index++)
	{
		dspAssert (m_pCertInfo->rgExtension);
		size_t	len = strlen (m_pCertInfo->rgExtension[index].pszObjId);
		LPTSTR	wcsObjId = new WCHAR[len];
		if ( !wcsObjId )
		{
			hResult = E_OUTOFMEMORY;
			break;
		}
		mbstowcs (wcsObjId,  m_pCertInfo->rgExtension[index].pszObjId, len);

		if ( !wcscmp (wcsObjId, szOID) )
		{
			CERT_ALT_NAME_INFO	nameInfo;
			DWORD				cbNameInfo = sizeof (CERT_ALT_NAME_INFO);

			BOOL	bResult = CryptDecodeObject(
					MY_ENCODING_TYPE,
					X509_ALTERNATE_NAME,	// in
					m_pCertInfo->rgExtension[index].Value.pbData,	// in
					m_pCertInfo->rgExtension[index].Value.cbData,	// in
					0,	// in
					(void *) &nameInfo,	// out
					&cbNameInfo);	// in/out
			dspAssert (bResult);
			if ( bResult )
			{
				//  We've found the right extension, now iterate through
				//	the alternate names until we find the desired type.
				for (DWORD	dwIndex = 0; dwIndex < nameInfo.cAltEntry; dwIndex++)
				{
					if ( nameInfo.rgAltEntry[dwIndex].dwAltNameChoice ==
							dwNameChoice )
					{
						if ( *ppszAltName )
							delete [] *ppszAltName;
						*ppszAltName = 
								new WCHAR[wcslen (nameInfo.rgAltEntry[dwIndex].pwszURL)+1];
						if ( *ppszAltName )
						{
							wcscpy (*ppszAltName, 
									nameInfo.rgAltEntry[dwIndex].pwszURL);
						}
						else
							hResult = E_OUTOFMEMORY;
						break;
					}
				}
			}
			else
				hResult = E_UNEXPECTED;
			break;
		}
		delete [] wcsObjId;
	}

	return hResult;
}



HCERTSTORE CCertificate::GetCertStore() const	
{
	return m_hCertStore;
}

PCCERT_CONTEXT CCertificate::GetCertContext() const
{
	return m_pCertContext;
}


HRESULT CCertificate::GetNameString (DWORD dwFlag, PWSTR* ppszNameOut)
{
	HRESULT	hResult = S_OK;
	dspAssert (ppszNameOut);
	if ( ppszNameOut )
	{
		DWORD	dwTypePara = CERT_SIMPLE_NAME_STR;
		DWORD	cchNameString = 0;
		DWORD	dwResult = ::CertGetNameString (m_pCertContext,
						CERT_NAME_SIMPLE_DISPLAY_TYPE, 
						dwFlag,
						&dwTypePara,
						NULL,
						cchNameString);
		if ( dwResult > 1 )
		{
			cchNameString = dwResult;
			if ( *ppszNameOut )
				delete [] *ppszNameOut;
			*ppszNameOut = new TCHAR[cchNameString];
			if ( *ppszNameOut )
			{
				dwResult = ::CertGetNameString (m_pCertContext,
								CERT_NAME_SIMPLE_DISPLAY_TYPE,
								dwFlag,
								&dwTypePara,
								*ppszNameOut,
								cchNameString);
				dspAssert (dwResult > 1);
				if ( dwResult <= 1 )
				{
					if ( !LoadStringToTchar (IDS_NOT_AVAILABLE, ppszNameOut) )
						hResult = E_FAIL;
				}
			}
			else 
				hResult = E_OUTOFMEMORY;
		}
		else
		{
			dwResult = ::CertGetNameString (m_pCertContext,
							CERT_NAME_EMAIL_TYPE,
							dwFlag,
							NULL,
							NULL,
							cchNameString);
			if ( dwResult > 1 )
			{
				cchNameString = dwResult;
		        if ( *ppszNameOut )
			        delete [] *ppszNameOut;
				*ppszNameOut = new TCHAR[cchNameString];
				if ( *ppszNameOut )
				{
					dwResult = ::CertGetNameString (m_pCertContext,
									CERT_NAME_EMAIL_TYPE,
									dwFlag,
									NULL,
									*ppszNameOut,
									cchNameString);
					dspAssert (dwResult > 1);
					if ( dwResult <= 1 )
					{
						if ( !LoadStringToTchar (IDS_NOT_AVAILABLE, ppszNameOut) )
							hResult = E_FAIL;
					}
				}
				else 
					hResult = E_OUTOFMEMORY;
			}
			else
			{
				if ( !LoadStringToTchar (IDS_NOT_AVAILABLE, ppszNameOut) )
					hResult = E_FAIL;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


int CCertificate::CompareExpireDate(const CCertificate & cert) const
{
	int	compVal = 0;

	dspAssert (m_pCertInfo && cert.m_pCertInfo);
	if ( m_pCertInfo && cert.m_pCertInfo )
	{
		compVal = ::CompareFileTime (&m_pCertInfo->NotAfter, 
				&cert.m_pCertInfo->NotAfter);
	}

	return compVal;
}

HRESULT CCertificate::GetOIDInfo (PWSTR* ppszString, PSTR pszObjId)
{   
	HRESULT	hResult = S_OK;
	dspAssert (pszObjId && ppszString);
	if ( pszObjId && ppszString )
	{
		PCCRYPT_OID_INFO	pOIDInfo;
            
		pOIDInfo = ::CryptFindOIDInfo (CRYPT_OID_INFO_OID_KEY, (void *) pszObjId, 0);

		if ( pOIDInfo )
		{
			if ( *ppszString )
				delete [] *ppszString;
			*ppszString = new WCHAR[wcslen (pOIDInfo->pwszName)+1];
			if ( *ppszString )
			{
				wcscpy (*ppszString, pOIDInfo->pwszName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
		else
		{
			int nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, NULL, 0);
			dspAssert (nLen);
			if ( nLen )
			{
				if ( *ppszString )
					delete [] *ppszString;
				*ppszString = new WCHAR[nLen];
				if ( *ppszString )
				{
					nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, 
							*ppszString, nLen);
					dspAssert (nLen);
					if ( !nLen )
						hResult = E_UNEXPECTED;
				}
				else
					hResult = E_OUTOFMEMORY;
			}
			else
				hResult = E_FAIL;
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//	FormatDate ()
//
//	utcDateTime (IN)	-	A FILETIME in UTC format.
//	pszDateTime (OUT)	-	A string containing the local date and time 
//							formatted by locale and user preference
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::FormatDate (FILETIME utcDateTime, PWSTR* ppszDateTime)
{
	dspAssert (ppszDateTime);
	if ( !ppszDateTime )
		return E_POINTER;
	//	Time is returned as UTC, will be displayed as local.  
	//	Use FileTimeToLocalFileTime () to make it local, 
	//	then call FileTimeToSystemTime () to convert to system time, then 
	//	format with GetDateFormat () and GetTimeFormat () to display 
	//	according to user and locale preferences	
	HRESULT		hResult = S_OK;
	FILETIME	localDateTime;


	BOOL bResult = FileTimeToLocalFileTime (&utcDateTime, // pointer to UTC file time to convert 
			&localDateTime); // pointer to converted file time 
	dspAssert (bResult);
	if ( bResult )
	{
		SYSTEMTIME	sysTime;

		bResult = FileTimeToSystemTime (
				&localDateTime, // pointer to file time to convert 
				&sysTime); // pointer to structure to receive system time 
		if ( bResult )
		{

			// Get date
			// Get length to allocate buffer of sufficient size
			int iLen = GetDateFormat (
					LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
					0, // flags specifying function options 
					&sysTime, // date to be formatted 
					0, // date format string 
					0, // buffer for storing formatted string 
					0); // size of buffer 
			dspAssert (iLen > 0);
			if ( iLen > 0 )
			{
				*ppszDateTime = new WCHAR[iLen];
				if ( *ppszDateTime )
				{
					int iResult = GetDateFormat (
							LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
							0, // flags specifying function options 
							&sysTime, // date to be formatted 
							0, // date format string 
							*ppszDateTime, // buffer for storing formatted string 
							iLen); // size of buffer 
					dspAssert (iResult);
					if ( !iResult )
						hResult = HRESULT_FROM_WIN32 (GetLastError ());
				}
				else
					hResult = E_OUTOFMEMORY;
			}
			else
			{
				hResult = HRESULT_FROM_WIN32 (GetLastError ());
			}
		}
		else
		{
			hResult = HRESULT_FROM_WIN32 (GetLastError ());
		}
	}
	else
	{
		hResult = HRESULT_FROM_WIN32 (GetLastError ());
	}

	return hResult;
}


void CCertificate::Refresh()
{
	if ( m_szEnhancedKeyUsage )
    {
        delete [] m_szEnhancedKeyUsage;
        m_szEnhancedKeyUsage = 0;
    }
	if ( m_szAltSubjectName )
    {
        delete [] m_szAltSubjectName;
        m_szAltSubjectName = 0;
    }
	if ( m_szAltIssuerName )
    {
        delete [] m_szAltIssuerName;
        m_szAltIssuerName = 0;
    }
	if ( m_szValidNotAfter )
    {
        delete [] m_szValidNotAfter;
        m_szValidNotAfter = 0;
    }
	if ( m_szSubjectName )
    {
        delete [] m_szSubjectName;
        m_szSubjectName = 0;
    }
	if ( m_szIssuerName )
    {
        delete [] m_szIssuerName;
        m_szIssuerName = 0;
    }
}

HRESULT CCertificate::WriteToFile(HANDLE hFile)
{
	dspAssert (hFile && hFile != INVALID_HANDLE_VALUE && m_pCertContext);
	HRESULT	hResult = S_OK;

	if ( hFile && hFile != INVALID_HANDLE_VALUE && m_pCertContext )
	{
		DWORD	dwBytesWritten = 0;
		BOOL	bResult = ::WriteFile (hFile, 
					m_pCertContext->pbCertEncoded,  
					m_pCertContext->cbCertEncoded,  
					&dwBytesWritten,
					NULL);
		dspAssert (bResult && (dwBytesWritten == m_pCertContext->cbCertEncoded));
		if ( !bResult )
			hResult = E_FAIL;
	}
	else
		hResult = E_FAIL;

	return hResult;
}

BOOL CCertificate::DeleteFromStore()
{
	BOOL bResult = ::CertDeleteCertificateFromStore (m_pCertContext);
	if ( bResult )
	{
		// NB: PhilH says "CertDeleteCertificateFromStore (), always does an 
		// implicit CertFreeCertificateContext."
		// Can't set m_pCertContext to 0 because it is const - set this flag instead
		m_bCertContextFreed = true;
	}

	return bResult;
}

#endif // DSADMIN


bool CCertificate::CanDelete()
{
	if ( m_pCertContext && !(m_fieldChecked & FIELD_CAN_DELETE) )
	{	
		DWORD	dwAccessFlags = 0;
		DWORD	cbData = sizeof (DWORD);
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_ACCESS_STATE_PROP_ID,
				&dwAccessFlags,
				&cbData);
		if ( bResult )
		{
			if ( dwAccessFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG )
				m_bCanDelete = true;
		}
		m_fieldChecked |= FIELD_CAN_DELETE;
    }

	return m_bCanDelete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\certifct.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certifct.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __CERTIFICT_H
#define __CERTIFICT_H

#include "wincrypt.h"

#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

/////////////////////////////////////////////////////////////////////////////
// CCertificate

class CCertificate
{
public:
	CCertificate(const PCCERT_CONTEXT pCertContext, HCERTSTORE hCertStore);
	virtual ~CCertificate();


public:
	bool CanDelete();
	BOOL DeleteFromStore ();
	HRESULT WriteToFile (HANDLE hFile);
	void Refresh ();
	int CompareExpireDate (const CCertificate& cert) const;
	BOOL IsMyStore () const;
	PCCERT_CONTEXT GetCertContext () const;
	HCERTSTORE GetCertStore () const;
	HRESULT GetAlternateSubjectName (PWSTR* ppszAltIssuerName);
	HRESULT GetAlternateIssuerName (PWSTR* ppszAltIssuerName);
	HRESULT GetEnhancedKeyUsage (PWSTR* ppszUsages);
	HRESULT GetValidNotAfter (PWSTR* pszValidNotAfter);
	HRESULT GetSubjectName (PWSTR *ppszSubjectName);
	HRESULT GetIssuerName (PWSTR *ppszIssuerName);

private:
	HRESULT FormatEnhancedKeyUsagePropertyString ();
	HRESULT ConvertAltNameToString (PWSTR szOID, const DWORD dwNameChoice, PWSTR* ppszAltName);

private:	// data
	bool					m_bCanDelete;
	DWORD					m_fieldChecked;
	bool					m_bCertContextFreed;
	PWSTR					m_szEnhancedKeyUsage;
	HCERTSTORE				m_hCertStore;
	PWSTR					m_szAltSubjectName;
	PWSTR					m_szAltIssuerName;
	PWSTR					m_szValidNotAfter;
	PWSTR					m_szSubjectName;
	PWSTR					m_szIssuerName;
	PCERT_INFO				m_pCertInfo;
	const PCCERT_CONTEXT	m_pCertContext;
protected:
	HRESULT GetNameString (DWORD dwFlag, PWSTR* ppszNameOut);
	HRESULT GetOIDInfo (PWSTR* string, PSTR pszObjId);
	HRESULT FormatDate (FILETIME utcDateTime, PWSTR* ppszDateTime);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\chklist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chklist.cxx
//
//--------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////
// CHKLIST.CXX
//
// This file contains the implementation of the CheckList control.
//
// HISTORY
// 26-Sep-96	JefferyS	Creation of chklist.cpp.
// 23-Jul-97	t-danm		Copied from \nt\private\windows\shell\security\aclui\chklist.cpp
//							and adapted to MFC project.
// 27-Jul-97	t-danm		Created all CheckList_* wrappers.
// 28-Jul-97	t-danm		Added CLS_LEFTALIGN and CLS_EXTENDEDTEXT styles.
// 30-Nov-99  JeffJon   Added CLS_3STATE style
//
/////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "chklist.h"

// The following are wrappers to make the code compile
#define TraceEnter(f, sz)
#define TraceLeaveVoid()
#define TraceLeaveValue(v)	return v
#define TraceAssert(f)		dspAssert(f)

extern HINSTANCE g_hInstance;

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    28
#define DEFAULT_CHECK_WIDTH     8
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8


//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
// 

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK

/////////////////////////////////////////////////////////////////////
// Compute the number extra pixel to set the position of the
// checkbox to provide a better UI.
int ComputeCheckboxExtraCy(DWORD dwStyle)
	{
	if (dwStyle & CLS_LEFTALIGN)
		return 0;
	return 2;
	}

/////////////////////////////////////////////////////////////////////
class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_rgxCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;	// Width of a checkbox item
	LONG m_cyCheckBox;	// Height of a checkbox item

    HWND    m_hwndCheckFocus;
    HBRUSH  m_hbrCheckPattern;
    HFONT   m_hFont;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);
    ~CCheckList();

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd);
    void SetTopIndex(HWND hWnd, LONG nIndex)
    { MsgVScroll(hWnd, SB_THUMBPOSITION, nIndex * m_rcItemLabel.bottom); }
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw = FALSE);

public:
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
}; // CCheckList


/////////////////////////////////////////////////////////////////////
void RegisterCheckListWndClass()
{
	WNDCLASS wc = { 0 };
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName    = WC_CHECKLIST;
    (void)::RegisterClass(&wc);
}


/////////////////////////////////////////////////////////////////////
CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL);

	memset(OUT this, 0, sizeof(*this));	// Initialize everything to zeroes

    //
    // Create a pattern brush to use for drawing a focus rect
    // around the check boxes.  This is a checkerboard pattern
    // with every other pixel turned on.
    //
    static const BYTE bits[] = {
					0x55, 0x00,
                    0xaa, 0x00,
                    0x55, 0x00,
                    0xaa, 0x00,
                    0x55, 0x00,
                    0xaa, 0x00,
                    0x55, 0x00,
                    0xaa, 0x00 };

    HBITMAP hbm = CreateBitmap(8, 8, 1, 1, bits);
    if (hbm)
    {
        m_hbrCheckPattern = CreatePatternBrush(hbm);
        DeleteObject(hbm);
    }

    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_3CHECK;

    // If only 1 column, don't allow radio button style.
    if (m_cSubItems == 1)
		{
        lpcs->style &= ~(CLS_RADIOBUTTON | CLS_AUTORADIOBUTTON);
		}

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
	rc.top = 0;
	rc.bottom = DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
	m_cyCheckBox = rc.bottom;
    LONG cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
	if (lpcs->style & CLS_EXTENDEDTEXT)
		rc.bottom += DEFAULT_ITEM_HEIGHT;	// Add one more item height
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    // SetColumnWidth calculates m_rgxCheckPos and m_rcItemLabel.right.
    // Note that it makes use of m_cSubItems, m_cxCheckBox (set above)
    // and also uses the other m_rcItemLabel values if m_cItems is
    // nonzero (it's 0 here).
    SetColumnWidth(hWnd, lpcs->cx, cxCheckColumn);

    // Hide the scroll bar (no controls yet)
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);

    TraceLeaveVoid();
}


CCheckList::~CCheckList()
{
    if (m_hbrCheckPattern != NULL)
        DeleteObject(m_hbrCheckPattern);
}


LRESULT CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
  DWORD dwStyle;
  DWORD dwState;

  TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

  // Should only get notifications from visible, enabled, check boxes
  TraceAssert(GET_ITEM(idCmd) < m_cItems);
  TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
  TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

  switch (wNotify)
  {
    case BN_CLICKED:
      dwStyle = (DWORD)GetWindowLongPtr(hWnd, GWL_STYLE);
      dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);

      if (dwStyle & CLS_RADIOBUTTON)
      {
        // Toggle the check state of non-automatic radio buttons here.
        // This overrides the normal radio button behavior to allow
        // unchecking them.
        dwState ^= CLST_CHECKED;
        SendMessage(hwndCtrl, BM_SETCHECK, dwState & CLST_CHECKED, 0);
      }
      else if (dwStyle & CLS_3STATE)
      {
        if (dwState & BST_INDETERMINATE)
        {
          dwState ^= BST_INDETERMINATE;
        }
        dwState ^= CLST_CHECKED;
        SendMessage(hwndCtrl, BM_SETCHECK, dwState, 0);
      }
      {
        NM_CHECKLIST nmc;
        nmc.hdr.hwndFrom = hWnd;
        nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
        nmc.hdr.code = CLN_CLICK;
        nmc.iItem = GET_ITEM(idCmd);
        nmc.iSubItem = GET_SUBITEM(idCmd);
        nmc.dwState = dwState;
        if (!IsWindowEnabled(hwndCtrl))
            nmc.dwState |= CLST_DISABLED;
        nmc.dwItemData = GetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                       GWLP_USERDATA);

	// Notify the parent about the event
        SendMessage(GetParent(hWnd),
                    WM_NOTIFY,
                    nmc.hdr.idFrom,
                    (LPARAM)&nmc);
      }
      break;

    case BN_SETFOCUS:
      if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
      {
        // Remember where the focus is
        m_hwndCheckFocus = hwndCtrl;
        // Make sure the row is scrolled into view
        EnsureVisible(hWnd, GET_ITEM(idCmd));
      }
      // Always draw the focus rect
      DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
      break;

    case BN_KILLFOCUS:
      // Remove the focus rect
      m_hwndCheckFocus = NULL;
      DrawCheckFocusRect(hWnd, hwndCtrl);
      break;
  }

  TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - m_rcItemLabel.bottom;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + m_rcItemLabel.bottom;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
  for (LONG i = 0; i < m_cItems; i++)
  {
    for (LONG j = 0; j <= m_cSubItems; j++)
    {
      EnableWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)), fEnabled);
    }
  }
	DWORD_PTR dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
	dwStyle &= ~WS_DISABLED;	// Turn off the disabled style
	SetWindowLongPtr(hWnd, GWL_STYLE, (LONG_PTR)dwStyle);
}


LONG CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
  DWORD dwChkListStyle;
  DWORD dwButtonStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_NOTIFY;
  HWND hwndNew;
  HWND hwndPrev;
  RECT rc;
  LONG cyOffset;

  TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
  TraceAssert(hWnd != NULL);
  TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));

  dwChkListStyle = (DWORD)GetWindowLongPtr(hWnd, GWL_STYLE);

  if (dwChkListStyle & CLS_AUTORADIOBUTTON)
    dwButtonStyle |= BS_AUTORADIOBUTTON;
  else if (dwChkListStyle & CLS_RADIOBUTTON)
    dwButtonStyle |= BS_RADIOBUTTON;
  else if (dwChkListStyle & CLS_3STATE)
    dwButtonStyle |= BS_3STATE;
  else
    dwButtonStyle |= BS_AUTOCHECKBOX;

  // Calculate the position of the new static label
  rc = m_rcItemLabel;
  cyOffset = m_cItems * rc.bottom;
  OffsetRect(&rc, 0, cyOffset);

  INT_PTR intPtr = static_cast<INT_PTR>(MAKE_LABEL_ID(m_cItems));
  HMENU hMenu = reinterpret_cast<HMENU>(intPtr);

  // Create a new label control
  hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             TEXT("STATIC"),
                             pszLabel,
                             WS_CHILD | WS_VISIBLE | WS_GROUP | SS_NOPREFIX,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top,
                             hWnd,
                             hMenu,
                             g_hInstance,
                             NULL);
  if (!hwndNew)
  {
    TraceLeaveValue(-1);
  }

  // Save item data
  SetWindowLongPtr(hwndNew, GWLP_USERDATA, lParam);

  // Set the font if we have one
  if (m_hFont)
  {
    SendMessage(hwndNew, WM_SETFONT, (WPARAM)m_hFont, 0);
  }

  // Set Z-order position just after the last checkbox. This keeps
  // tab order correct.
  if (m_cItems > 0)
  {
    hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
//        hwndPrev = GetWindow(hwndNew, GW_HWNDLAST);
//        if (hwndPrev != hwndNew)
        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
  }

  // Create new checkboxes
  for (LONG j = 0; j < m_cSubItems; j++)
  {
    INT_PTR intPtrToo = static_cast<INT_PTR>(MAKE_CTRL_ID(m_cItems, j + 1));
    HMENU hMenuToo = reinterpret_cast<HMENU>(intPtrToo);

    hwndPrev = hwndNew;
    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             TEXT("BUTTON"),
                             NULL,
                             dwButtonStyle,
                             m_rgxCheckPos[j],
                             rc.top + ComputeCheckboxExtraCy(dwChkListStyle),
                             m_cxCheckBox,
						                 m_cyCheckBox,
                             hWnd,
                             hMenuToo,
                             g_hInstance,
                             NULL);
    if (!hwndNew)
    {
      while (j >= 0)
      {
        DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
        j--;
      }

      TraceLeaveValue(-1);
    }

    SetWindowPos(hwndNew,
                 hwndPrev,
                 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
  }

  //
  // The last thing is to calculate the scroll range
  //
  GetClientRect(hWnd, &rc);

  if (m_rcItemLabel.bottom + cyOffset > rc.bottom) // Is the bottom control visible?
  {
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nMin = 0;
    si.nMax = m_rcItemLabel.bottom + cyOffset + m_rcItemLabel.top;
    si.nPage = rc.bottom;                       // ^^^^^^^^^ extra space
    si.nPos = 0;

    SetScrollInfo(hWnd, SB_VERT, &si, FALSE);
  }

  TraceLeaveValue(m_cItems++);
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
  TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
  TraceAssert(hWnd != NULL);
  TraceAssert(iItem < m_cItems);
  TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

  HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
  if (hwndCtrl != NULL)
  {
    LONG_PTR dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
    if ((dwStyle & CLS_AUTORADIOBUTTON)
        && (lState & CLST_CHECKED))
    {
      CheckRadioButton(hWnd,
                       MAKE_CTRL_ID(iItem, 1),
                       MAKE_CTRL_ID(iItem, m_cSubItems),
                       MAKE_CTRL_ID(iItem, iSubItem));
      EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
    }
    else if (dwStyle & CLS_3STATE)
    {
      SendMessage(hwndCtrl, BM_SETCHECK, lState, 0);
    }
    else
    {
      SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
      EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
    }
  }

//    TraceLeaveValue(lPrevState);
  TraceLeaveVoid();
}


LONG CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
  LONG lState = 0;

  TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
  TraceAssert(hWnd != NULL);
  TraceAssert(iItem < m_cItems);
  TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

  HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

  if (hwndCtrl != NULL)
  {
    lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);

    if (!IsWindowEnabled(hwndCtrl))
      lState |= CLST_DISABLED;
  }
  TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
	{
    LONG j;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

	DWORD dwChkListStyle = (DWORD)GetWindowLongPtr(hWnd, GWL_STYLE);
    if (m_cSubItems > 0)
		{
		if (dwChkListStyle & CLS_LEFTALIGN)
			{
			// Put the checkboxes at the left of the text
			int xSubItem = m_rcItemLabel.left;
			for (j = 0; j < m_cSubItems; j++, xSubItem += cxColumn)
				m_rgxCheckPos[j] = xSubItem;
			m_rcItemLabel.left = xSubItem - (cxColumn + m_cxCheckBox)/2;
			m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;
			}
		else
			{
			// Put the checkboxes at the right of the text
			m_rgxCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
										- m_rcItemLabel.left            // right margin
										- (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox
			for (j = m_cSubItems - 1; j > 0; j--)
				m_rgxCheckPos[j-1] = m_rgxCheckPos[j] - cxColumn;
			//              (leftmost check pos) - (horz margin)
			m_rcItemLabel.right = m_rgxCheckPos[0] - m_rcItemLabel.left;
			} // if...else
		}
    else
		{
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;
		}

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

	// Move each item in the checklist
    for (LONG i = 0; i < m_cItems; i++)
		{
        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nBottom - nTop,
                   FALSE);

		// Move each checkbox
        for (j = 0; j < m_cSubItems; j++)
			{
		    MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_rgxCheckPos[j],
                       nTop + ComputeCheckboxExtraCy(dwChkListStyle),
                       m_cxCheckBox,
                       m_cyCheckBox,
                       FALSE);
			}
        nTop += m_rcItemLabel.bottom;
        nBottom += m_rcItemLabel.bottom;
		} // for
    TraceLeaveVoid();
	} // SetColumnWidth()


void
CCheckList::ResetContent(HWND hWnd)
{
    for (LONG i = 0; i < m_cItems; i++)
        for (LONG j = 0; j <= m_cSubItems; j++)
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));

    // Hide the scroll bar
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);
    m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG nCount = 1;
    RECT rc;

    if (GetClientRect(hWnd, &rc) && m_rcItemLabel.bottom > 0)
        nCount = max(1, rc.bottom / m_rcItemLabel.bottom);

    return nCount;
}


LONG
CCheckList::GetTopIndex(HWND hWnd)
{
    LONG nIndex = 0;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
        nIndex = max(0, si.nPos / m_rcItemLabel.bottom);

    return nIndex;
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG nTopIndex = GetTopIndex(hWnd);

    if (nItemIndex < nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
            SetTopIndex(hWnd, nItemIndex - nVisible + 1);
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;
    HDC hdc;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(COLOR_3DFACE));

        if (fDraw)
        {
            if (m_hbrCheckPattern)
            {
                COLORREF crText = SetTextColor(hdc, RGB(0,0,0));
                COLORREF crBack = SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
                FrameRect(hdc, &rcCheck, m_hbrCheckPattern);
                SetTextColor(hdc, crText);
                SetBkColor(hdc, crBack);
            }
            else
                DrawFocusRect(hdc, &rcCheck);
        }
        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}


LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND:
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        pThis->m_hFont = (HFONT)wParam;
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_GETFONT:
        TraceAssert(pThis != NULL);
        lResult = (LRESULT)pThis->m_hFont;
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        SetWindowLongPtr(GetDlgItem(hWnd, (int)MAKE_LABEL_ID(wParam)),
                      GWLP_USERDATA,
                      lParam);
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        lResult = GetWindowLongPtr(GetDlgItem(hWnd, (int)MAKE_LABEL_ID(wParam)),
                                GWLP_USERDATA);
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}


/////////////////////////////////////////////////////////////////////
//	CheckList_AddItem()
//
//	Add one item to the checklist control and optionally
//	check the checkbox of that item.
//
//	Returns the index of the new item if successful or -1 otherwise.
//
int
CheckList_AddItem(HWND hwndChecklist, LPCTSTR pszLabel, LPARAM lParam, BOOL fCheckItem)
{
	dspAssert(::IsWindow(hwndChecklist));
	int iItem = (int)::SendMessage(hwndChecklist, CLM_ADDITEM, (WPARAM)pszLabel, lParam);
	dspAssert(iItem >= 0);
	if (fCheckItem)
	{
		CheckList_SetItemCheck(hwndChecklist, iItem, fCheckItem);
	}
	return iItem;
} // CheckList_AddItem()


/////////////////////////////////////////////////////////////////////
//	CheckList_AddString()
//
//	Load a string from the resource and add it to the checklist control.
//
//	Returns the index of the new item if successful or -1 otherwise.
//
//	REMARKS
//	The routine will set the lParam to the string Id.
//
int
CheckList_AddString(HWND hwndChecklist, UINT uStringId, BOOL fCheckItem)
	{
	dspAssert(::IsWindow(hwndChecklist));
	TCHAR szT[1024];
	int cch = ::LoadString(g_hInstance, uStringId, OUT szT, ARRAYLENGTH(szT));
	dspAssert(cch > 0 && "String not found");
	dspAssert((cch < ARRAYLENGTH(szT) - 10) && "Buffer too small");
	int iItem = (int)::SendMessage(hwndChecklist, CLM_ADDITEM, (WPARAM)szT, uStringId);
	dspAssert(iItem >= 0);
	if (fCheckItem)
		{
		CheckList_SetItemCheck(hwndChecklist, iItem, fCheckItem);
		}
	return iItem;
	} // CheckList_AddString()


/////////////////////////////////////////////////////////////////////
//	CheckList_SetItemCheck()
//
//	Set the state of a checkbox item.
//		fCheckItem == TRUE => Check the checkbox item
//		fCheckItem == FALSE => Uncheck the checkbox item
//		fCheckItem == BST_INDETERMINATE => Checkbox is grayed, indicating an indeterminate state.
//
void
CheckList_SetItemCheck(HWND hwndChecklist, int iItem, BOOL fCheckItem, int iColumn)
	{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iItem >= 0);
	dspAssert(iColumn >= 1);
	(void)::SendMessage(hwndChecklist, CLM_SETSTATE, MAKELONG(iItem, iColumn), fCheckItem);
	} // CheckList_SetItemCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_GetItemCheck()
//
//	Return the state of the checkbox item.
//		BST_UNCHECKED == 0
//		BST_CHECKED == 1
//		BST_INDETERMINATE == 2
//
int
CheckList_GetItemCheck(HWND hwndChecklist, int iItem, int iColumn)
	{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iItem >= 0);
	dspAssert(iColumn >= 1);
	return (int)::SendMessage(hwndChecklist, CLM_GETSTATE, MAKELONG(iItem, iColumn), 0);
	} // CheckList_GetItemCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_GetLParamCheck()
//
//	Searches the list of items for the matching lParam and return
//	the state of that item.
//
//	Return -1 if no matching lParam.
//
int CheckList_GetLParamCheck(HWND hwndChecklist, LPARAM lParam, int iColumn)
{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iColumn >= 1);
	int iItem = CheckList_FindLParamItem(hwndChecklist, lParam);
	if (iItem < 0)
  {
		dspAssert(FALSE && "Item not found");
		return -1;
	}
	return (int)::SendMessage(hwndChecklist, CLM_GETSTATE, MAKELONG(iItem, iColumn), 0);
} // CheckList_GetLParamCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_SetLParamCheck()
//
//	Searches the list of items for the matching lParam and set
//	the state of that item.
//
void
CheckList_SetLParamCheck(HWND hwndChecklist, LPARAM lParam, BOOL fCheckItem, int iColumn)
	{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iColumn >= 1);
	int iItem = CheckList_FindLParamItem(hwndChecklist, lParam);
	dspAssert(iItem >= 0);
	(void)::SendMessage(hwndChecklist, CLM_SETSTATE, MAKELONG(iItem, iColumn), fCheckItem);
	} // CheckList_SetLParamCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_FindLParamItem()
//
//	Return the index of the item matching lParam.
//	If no matches found return -1.
//
//	REMARKS
//	Each item should have a unique lParam, otherwise the search
//	will return the first matching lParam.
//
int
CheckList_FindLParamItem(HWND hwndChecklist, LPARAM lParam)
	{
	dspAssert(::IsWindow(hwndChecklist));
	int cItemCount = (int)::SendMessage(hwndChecklist, CLM_GETITEMCOUNT, 0, 0);
	dspAssert(cItemCount >= 0);
	for (int iItem = 0; iItem < cItemCount; iItem++)
		{
		if (lParam == ::SendMessage(hwndChecklist, CLM_GETITEMDATA, iItem, 0))
			{
			return iItem;
			}
		}
	return -1;
	} // CheckList_FindLParamItem()


/////////////////////////////////////////////////////////////////////
//	CheckList_EnableWindow()
//
//	Send a WM_ENABLE message to the checklist control.
//
//	REMARKS
//	The user should NOT use EnableWindow() to disable the checklist
//	control because it will prevent the checklist control to scroll
//	when disable.
//	The routine CheckList_EnableWindow() will disable all the
//	checkboxes inside the control but will allow the control to scroll.
//
void
CheckList_EnableWindow(HWND hwndChecklist, BOOL fEnableWindow)
	{
	dspAssert(::IsWindow(hwndChecklist));
	(void)::SendMessage(hwndChecklist, WM_ENABLE, fEnableWindow, 0);
	} // CheckList_EnableWindow()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\chklist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chklist.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
// CHKLIST.H
//
// This file contains the definitions of the CheckList control.
//
/////////////////////////////////////////////////////////////////////

#ifndef __CHKLIST_H_INCLUDED__
#define __CHKLIST_H_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define ARRAYLENGTH(x)	(sizeof(x)/sizeof((x)[0]))

/////////////////////////////////////////////////////////////////////
//
// CheckList window class name
//
#ifdef RC_INVOKED
#define WC_CHECKLIST        "CHECKLIST"
#else
#define WC_CHECKLIST        TEXT("CHECKLIST")
#endif

/////////////////////////////////////////////////////////////////////
//
// CheckList window styles
//
// TIP
// When creating a control on a dialog template, here are the
// styles to use:
//		Class =		CHECKLIST
//		Style =		0x500000c1
//		ExStyle =	0x00010204
//
#define CLS_1CHECK          0x0001		// One column of checkboxes
#define CLS_2CHECK          0x0002		// Two columns of checkboxes
#define CLS_3CHECK			0x0003		// Three columns of checkboxes
#define CLS_3STATE          0x0004    // Three state checkbox
#define CLS_RADIOBUTTON     0x0010
#define CLS_AUTORADIOBUTTON 0x0020
#define CLS_LEFTALIGN		0x0040		// Align the checkboxes at the left of the text (default = right)
#define CLS_EXTENDEDTEXT	0x0080		// Create the static controls to have enough room for two lines of text


/////////////////////////////////////////////////////////////////////
//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)


/////////////////////////////////////////////////////////////////////
// CheckList messages
//
// INTERFACE NOTES
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible


/////////////////////////////////////////////////
typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;							// BST_CHECKED or BST_UNCHECKED
    DWORD_PTR dwItemData;						// lParam of the checklist item
} NM_CHECKLIST, *PNM_CHECKLIST;


/////////////////////////////////////////////////
//	CLN_CLICK
//
//	This message is sent when a checkbox item has been clicked.
//
//		uMsg = WM_NOTIFY;
//		idControl = (int)wParam;	// Id of the checklist control sending the message
//		pNmChecklist = (NM_CHECKLIST *)lParam;	// Pointer to notification structure
//
#define CLN_CLICK           (0U-1000U)


/////////////////////////////////////////////////////////////////////
void RegisterCheckListWndClass();

/////////////////////////////////////////////////////////////////////
//
//	Handy Wrappers
//
int  CheckList_AddItem(HWND hwndCheckList, LPCTSTR pszLabel, LPARAM lParam = 0, BOOL fCheckItem = FALSE);
int  CheckList_AddString(HWND hwndCheckList, UINT uStringId, BOOL fCheckItem = FALSE);
void CheckList_SetItemCheck(HWND hwndChecklist, int iItem, BOOL fCheckItem, int iColumn = 1);
int  CheckList_GetItemCheck(HWND hwndChecklist, int iItem, int iColumn = 1);
void CheckList_SetLParamCheck(HWND hwndChecklist, LPARAM lParam, BOOL fCheckItem, int iColumn = 1);
int  CheckList_GetLParamCheck(HWND hwndChecklist, LPARAM lParam, int iColumn = 1);
int  CheckList_FindLParamItem(HWND hwndChecklist, LPARAM lParam);
void CheckList_EnableWindow(HWND hwndChecklist, BOOL fEnableWindow);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* __CHKLIST_H_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\behaviorversion.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      BehaviorVersion.cxx
//
//  Contents:  Supporting code for displaying and raising the domain and
//             forest version.
//
//  History:   5-April-01 EricB created
//
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "proppage.h"
#include "qrybase.h"
#include "BehaviorVersion.h"

//+----------------------------------------------------------------------------
//
//  Class:     CVersionBase
//
//  Purpose:   Base class for version management.
//
//-----------------------------------------------------------------------------

CVersionBase::~CVersionBase(void)
{
   TRACE(CVersionBase,~CVersionBase);

   for (DC_LIST::iterator i = _DcLogList.begin(); i != _DcLogList.end(); ++i)
   {
      delete *i;
   }

   if (_fHelpInited)
   {
      HtmlHelp(NULL, NULL, HH_UNINITIALIZE, _dwHelpCookie);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CVersionBase::ReadDnsSrvName
//
//-----------------------------------------------------------------------------
HRESULT
CVersionBase::ReadDnsSrvName(PCWSTR pwzNTDSDSA,
                             CComPtr<IADs> & spServer,
                             CComVariant & varSrvDnsName)
{
   HRESULT hr = S_OK;
   if (!pwzNTDSDSA)
   {
      dspAssert(FALSE);
      return E_INVALIDARG;
   }
   CPathCracker PathCrack;

   hr = PathCrack.Set(const_cast<BSTR>(pwzNTDSDSA), ADS_SETTYPE_DN);

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.RemoveLeafElement();

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

   CHECK_HRESULT(hr, return hr);
   CComBSTR bstrServer;

   hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrServer);

   CHECK_HRESULT(hr, return hr);

   hr = ADsOpenObject(bstrServer, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IADs), (void **)&spServer);

   CHECK_HRESULT(hr, return hr);

   hr = spServer->Get(L"dNSHostName", &varSrvDnsName);

   CHECK_HRESULT(hr, return hr);
   dspAssert(VT_BSTR == varSrvDnsName.vt);
   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVersionBase::EnumDsaObjs
//
//  Synopsis:  Enumerate the nTDSDSA objects which represent the DCs and check
//             the version on each. Build a list of DCs whose version is too low.
//
//  Arguments: [pwzSitesPath] - ADSI path to the Sites container.
//             [pwzFilterClause] - optional search filter expression to be
//                combined with the objectCategory clause to narrow the search.
//             [pwzDomainDnsName] - optional name of the domain for whose DC
//                objects we're searching.
//             [nMinVer] - the minimum DC behavior version needed for the
//                domain or forest version upgrade.
//
//  Notes:  If searching for a domain's DC objects, the search filter clause
//          parameter will request those objects whose hasMasterNCs contains
//          the domain's DN. The pwzDomainDnsName value will be passed to the
//          log list elements.
//          If searching for a forest's DCs, then the search filter param is
//          NULL so as to get all nTDSDSA objects and the domain name param is
//          NULL since we want the objects for all domains.
//
//-----------------------------------------------------------------------------
HRESULT
CVersionBase::EnumDsaObjs(PCWSTR pwzSitesPath, PCWSTR pwzFilterClause,
                          PCWSTR pwzDomainDnsName, UINT nMinVer)
{
   if (!pwzSitesPath)
   {
      dspAssert(FALSE);
      return E_INVALIDARG;
   }
   dspDebugOut((DEB_ITRACE, "Searching for nTDSDSA objects under %ws\n",
                pwzSitesPath));
   CDSSearch Search;

   HRESULT hr = Search.Init(pwzSitesPath);

   CHECK_HRESULT(hr, return hr);
   PWSTR rgwzAttrs[] = {g_wzBehaviorVersion, g_wzDN, g_wzHasMasterNCs};

   Search.SetAttributeList(rgwzAttrs, ARRAYLENGTH(rgwzAttrs));

   hr = Search.SetSearchScope(ADS_SCOPE_SUBTREE);

   CHECK_HRESULT(hr, return hr);
   CStrW strSearchFilter;

   if (pwzFilterClause)
   {
      WCHAR wzSearchFormat[] = L"(&(objectCategory=nTDSDSA)%s)";

      strSearchFilter.Format(wzSearchFormat, pwzFilterClause);
   }
   else
   {
      strSearchFilter = L"(objectCategory=nTDSDSA)";
   }

   Search.SetFilterString(const_cast<LPWSTR>((LPCWSTR)strSearchFilter));

   hr = Search.DoQuery();

   CHECK_HRESULT(hr, return hr);

   while (SUCCEEDED(hr))
   {
      hr = Search.GetNextRow();

      if (hr == S_ADS_NOMORE_ROWS)
      {
         hr = S_OK;
         break;
      }

      CHECK_HRESULT(hr, return hr);
      ADS_SEARCH_COLUMN Column = {0};
      UINT nVer = 0;

      hr = Search.GetColumn(g_wzBehaviorVersion, &Column);

      if (E_ADS_COLUMN_NOT_SET != hr)
      {
         // If hr == E_ADS_COLUMN_NOT_SET then it is a Win2k domain. nVer is
         // initialized to zero for this case.
         //
         CHECK_HRESULT(hr, return hr);

         nVer = Column.pADsValues->Integer;

         Search.FreeColumn(&Column);
      }

      if (nVer < nMinVer)
      {
         // Found a DC that prevents raising the domain version. Read its DNS
         // name off of the Server object which contains this nTDSDSA object.
         //
         hr = Search.GetColumn(g_wzDN, &Column);

         CHECK_HRESULT(hr, return hr);
         CComVariant varDcDnsName, varSrvRef;
         CComPtr<IADs> spServer;
         dspAssert(Column.pADsValues);
         dspAssert(Column.pADsValues->CaseIgnoreString);

         hr = ReadDnsSrvName(Column.pADsValues->CaseIgnoreString,
                             spServer,
                             varDcDnsName);

         Search.FreeColumn(&Column);

         CHECK_HRESULT(hr, return hr);

         hr = spServer->Get(L"serverReference", &varSrvRef);

         CHECK_HRESULT(hr, return hr);
         dspAssert(VT_BSTR == varSrvRef.vt);
         bool fFreeDnsName = false;

         if (!pwzDomainDnsName)
         {
            // Get domain to which the DC belongs. The hasMasterNCs attribute
            // is multi-valued and includes the DN of the domain. Check the
            // class of each DN to see which is Domain-DNS.
            //
            hr = Search.GetColumn(g_wzHasMasterNCs, &Column);

            CHECK_HRESULT(hr, return hr);
            WCHAR wzErr[] = L"error";
            pwzDomainDnsName = wzErr;

            for (DWORD i = 0; i < Column.dwNumValues; i++)
            {
               dspAssert(Column.pADsValues[i].CaseIgnoreString);
               CComPtr<IADs> spNC;
               CStrW strPath = g_wzLDAPPrefix;
               strPath += _strDC;
               strPath += L"/";
               strPath += Column.pADsValues[i].CaseIgnoreString;

               hr = ADsOpenObject(strPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                                  __uuidof(IADs), (void **)&spNC);

               CHECK_HRESULT(hr, return hr);
               CComBSTR bstrClass;

               hr = spNC->get_Class(&bstrClass);

               CHECK_HRESULT(hr, return hr);

               if (_wcsicmp(bstrClass, L"domainDNS") == 0)
               {
                  // Found it.
                  //
                  hr = CrackName(Column.pADsValues[i].CaseIgnoreString,
                                 const_cast<PWSTR *>(&pwzDomainDnsName),
                                 GET_DNS_DOMAIN_NAME, GetDlgHwnd());

                  CHECK_HRESULT(hr, return hr);
                  fFreeDnsName = true;
                  break;
               }
            }
         }

         dspDebugOut((DEB_ITRACE, "Found DC %ws, ver: %d, for domain %ws\n",
                      varDcDnsName.bstrVal, nVer, pwzDomainDnsName));

         CDcListItem * pDcItem = new CDcListItem(pwzDomainDnsName,
                                                 varDcDnsName.bstrVal,
                                                 varSrvRef.bstrVal,
                                                 nVer);

         if (fFreeDnsName)
         {
            LocalFreeStringW(const_cast<PWSTR *>(&pwzDomainDnsName));
            pwzDomainDnsName = NULL;
         }

         CHECK_NULL(pDcItem, return E_OUTOFMEMORY;);

         _DcLogList.push_back(pDcItem);

         _fCanRaiseBehaviorVersion = false;

         _nMinDcVerFound = min(_nMinDcVerFound, nVer);
      }
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVersionBase::BuildDcListString
//
//-----------------------------------------------------------------------------
HRESULT
CVersionBase::BuildDcListString(CStrW & strList)
{
   HRESULT hr = S_OK;
   CPathCracker PathCrack;

   for (DC_LIST::iterator i = _DcLogList.begin(); i != _DcLogList.end(); ++i)
   {
      strList += (*i)->GetDomainName();
      strList += L"\t";
      strList += (*i)->GetDcName();
      strList += L"\t";

      hr = PathCrack.Set(const_cast<BSTR>((*i)->GetCompObjDN()), ADS_SETTYPE_DN);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);
      CComBSTR bstrDC;

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrDC);

      CHECK_HRESULT(hr, return hr);

      CComPtr<IADs> spDC;
      CComVariant varOS, varOsVer;

      hr = ADsOpenObject(bstrDC, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                         __uuidof(IADs), (void **)&spDC);

      CHECK_HRESULT(hr, return hr);

      hr = spDC->Get(L"operatingSystem", &varOS);

      if (SUCCEEDED(hr))
      {
         dspAssert(VT_BSTR == varOS.vt);

         strList += varOS.bstrVal;
      }
      else
      {
         CHECK_HRESULT(hr, ;);
      }

      strList += L" ";

      hr = spDC->Get(L"operatingSystemVersion", &varOsVer);

      if (SUCCEEDED(hr))
      {
         dspAssert(VT_BSTR == varOsVer.vt);

         strList += varOsVer.bstrVal;
      }
      else
      {
         CHECK_HRESULT(hr, ;);
         hr = S_OK;
      }

      strList += g_wzCRLF;
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVersionBase::InitHelp
//
//-----------------------------------------------------------------------------
void
CVersionBase::InitHelp(void)
{
   if (!_fHelpInited)
   {
      dspDebugOut((DEB_TRACE, "Initializing HtmlHelp\n"));
      HtmlHelp(NULL, NULL, HH_INITIALIZE, (DWORD_PTR)&_dwHelpCookie);
      _fHelpInited = true;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:   CVersionBase::ShowHelp
//
//-----------------------------------------------------------------------------
void
CVersionBase::ShowHelp(PCWSTR pwzHelpFile, HWND hWnd)
{
   TRACER(CTrustWizPageBase,ShowHelp);
   if (!pwzHelpFile)
   {
      dspAssert(FALSE);
      return;
   }
   CStrW strHelpPath;

   PWSTR pwz = strHelpPath.GetBufferSetLength(MAX_PATH + MAX_PATH);

   GetWindowsDirectory(pwz, MAX_PATH + MAX_PATH);

   if (strHelpPath.IsEmpty())
   {
      dspAssert(false);
      return;
   }

   strHelpPath.GetBufferSetLength((int)wcslen(pwz));

   HWND hHelp;

   InitHelp();

   strHelpPath += L"\\help\\";

   strHelpPath += pwzHelpFile;

   dspDebugOut((DEB_ITRACE, "Help topic is: %ws\n", strHelpPath.GetBuffer(0)));

   hHelp =
   HtmlHelp(hWnd,
            strHelpPath,
            HH_DISPLAY_TOPIC,
            NULL);

   if (!hHelp)
   {
      dspDebugOut((DEB_TRACE, "HtmlHelp returns %d\n", GetLastError()));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\bitfield.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       bitfield.cxx
//
//  Contents:
//
//  History:    07-May-97 JonN  copied from user.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"

//
// If you want to reverse the sense of a checkbox, provide a reverse mask.
// The checkbox is reversed if more than 16 of the bits are set.
//
BOOL IsPositiveMask( DWORD dwMask )
{
	int nBitsSet = 0;
	while (0 != dwMask)
	{
		if (1 & dwMask)
			nBitsSet++;
		dwMask /= 2;
	}
	return (nBitsSet <= 16);
}

BOOL BitField_IsChecked( DWORD dwValue, DWORD dwMask )
{
	if (IsPositiveMask(dwMask))
		return !!(dwValue & dwMask);
	else
		return !(dwValue & ~dwMask);
}

DWORD BitField_SetChecked( DWORD dwOldValue, DWORD dwMask, BOOL fChecked )
{
	if (!IsPositiveMask(dwMask))
	{
		fChecked = !fChecked;
		dwMask = ~dwMask;
	}
	if (fChecked)
		return dwOldValue | dwMask;
	else
		return dwOldValue & ~dwMask;
}

// only use this for the first shared bit control on a table-driven page.  It uses the
// shared CDsTableDrivenPage.m_pData rather than the per-attribute pAttrData->pVoid.
HRESULT
FirstSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
	switch (DlgOp)
	{
	case fInit:
    //
    // Save the address of this function's instance of pAttrData in the
    // page's m_pData member so that SubsequentSharedBitField can access it.
    //
    ((CDsTableDrivenPage*)pPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);
    // fall through.
	case fObjChanged:
		DBG_OUT("BitField: fInit or fObjChanged");
		//
		// See if the bitfield is currently turned on
		//
		// We just save the integer value in *pInitialValue, not a pointer to anything
		//
		if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
		{
			ASSERT( NULL != pAttrInfo->pADsValues );
      pAttrData->pVoid = static_cast<LPARAM>(pAttrInfo->pADsValues->Integer);
		}
		else
		{
      pAttrData->pVoid = NULL;
		}
		// fall through to SubsequentSharedBitField
		break;

	case fApply:
		DBG_OUT("BitField: fApply");
    if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
		{
      return ADM_S_SKIP;
		}
    PADSVALUE pADsValue;
    pADsValue = new ADSVALUE;
		CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
		pAttrInfo->pADsValues = pADsValue;
		pAttrInfo->dwNumValues = 1;
		pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
		pADsValue->dwType = pAttrInfo->dwADsType;
		pADsValue->Integer = (ADS_INTEGER)((DWORD_PTR)pAttrData->pVoid);
		break;

	case fOnCommand:
		DBG_OUT("BitField: fOnCommand");
		// fall through to SubsequentSharedBitField
		break;
	}

	return SubsequentSharedBitField(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp);
}

// only use this for subsequent shared bit controls on a table-driven page.  It uses the
// shared CDsTableDrivenPage.m_pData rather than the per-attribute pAttrData->pVoid.
HRESULT
SubsequentSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
                         LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
  PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage*)pPage)->m_pData);
  DWORD* pInitialValue = reinterpret_cast<DWORD*>(&pData->pVoid);
	ASSERT( NULL != pData );
	switch (DlgOp)
	{
	case fInit:
	case fObjChanged:
		DBG_OUT("SubsequentSharedBitField: fInit or fObjChanged");

		// JonN 7/2/99: disable if attribute not writable
		if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
			EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);

		//
		// See if the bitfield is currently turned on
		//
		SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID, BM_SETCHECK,
			(WPARAM)((BitField_IsChecked(*pInitialValue, pAttrMap->nSizeLimit))
				? TRUE : FALSE), 0);
		break;

	case fOnCommand:
		DBG_OUT("SubsequentSharedBitField: fOnCommand");
		if (lParam == BN_CLICKED)
		{
			BOOL fChecked = (BOOL)SendDlgItemMessage(
				pPage->GetHWnd(), pAttrMap->nCtrlID, BM_GETCHECK, 0, 0);
			ASSERT( 0 == fChecked || 1 == fChecked );
			*pInitialValue = BitField_SetChecked( *pInitialValue, pAttrMap->nSizeLimit, fChecked );
			pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pData);
		}
		break;
	}

	return S_OK;
}

// Hide and disable the control if this bit is set (reverse flag for not-set)
HRESULT
HideBasedOnBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                    LPARAM, PATTR_DATA, DLG_OP DlgOp)
{
	switch (DlgOp)
	{
	case fInit:
	case fObjChanged:
		{
			//
			// See if the bitfield is currently turned on
			//
			ADS_INTEGER nValue = 0;
			if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
			{
				ASSERT( NULL != pAttrInfo->pADsValues );
				nValue = pAttrInfo->pADsValues->Integer;
			}
			BOOL fSet = BitField_IsChecked(nValue, pAttrMap->nSizeLimit);
			HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
			ASSERT( NULL != hwnd );
			(void)::ShowWindow( hwnd, (fSet) ? SW_SHOW : SW_HIDE );
			(void)::EnableWindow( hwnd, fSet );
		}
		break;
	default:
		break;
	}

	return S_OK;
}

// Sets the context help ID to pAttrMap->pData on fInit/fObjChanged
// This is particularly useful for static text controls which cannot set
// context help ID in the resource file.
HRESULT
SetContextHelpIdAttrFn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP DlgOp)
{
	switch (DlgOp)
	{
	case fInit:
	case fObjChanged:
		{
			HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
			ASSERT( NULL != hwnd );
			::SetWindowContextHelpId( hwnd, pAttrMap->nSizeLimit );
		}
		break;
	default:
		break;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\computer.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.cxx
//
//  Contents:   Computer object functionality.
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "computer.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   PuterCanDelegateChk
//
//  Synopsis:   Handles the computer can delegate checkbox value.
//
//-----------------------------------------------------------------------------
HRESULT
PuterCanDelegateChk(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                    PADS_ATTR_INFO pAttrInfo, LPARAM lParam,
                    PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    TRACE_FUNCTION(PuterCanDelegateChk);

    switch (DlgOp)
    {
    case fInit:
      {
        dspAssert(pAttrData);
        //
        // Check the delegation value. The user may not have the rights to
        // read the User-Account-Control attribute, so handle that case.
        //
        if (!pAttrInfo || !pAttrInfo->dwNumValues || !pAttrInfo->pADsValues)
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
            ((CDsTableDrivenPage *)pPage)->m_pData = NULL;
            PATTR_DATA_CLEAR_WRITABLE(pAttrData);
            break;
        }

        //
        // If this is a Whistler domain, then don't show the delegation check
        // because we will handle delegation from the scope of delegation page
        //

        UINT domainBehaviorVersion = pPage->GetBasePathsInfo()->GetDomainBehaviorVersion();
        bool bShowCheck = domainBehaviorVersion < DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS;

        if (domainBehaviorVersion >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
        {
           EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
           EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_ICON), FALSE);
           EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_STATIC), FALSE);
           ShowWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), SW_HIDE);
           ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_ICON), SW_HIDE);
           ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_STATIC), SW_HIDE);

           break;
        }

        if (pAttrInfo->pADsValues->Integer & UF_TRUSTED_FOR_DELEGATION)
        {
            CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID, BST_CHECKED);
        }

        // Save the original user-account-control value.
        //
        ((CDsTableDrivenPage *)pPage)->m_pData = (LPARAM)pAttrInfo->pADsValues->Integer;

        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }

        break;
      }

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
          if( IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID ) )
          {
            SuperMsgBox(pPage->GetHWnd(),
                    IDS_COMPUTER_DELEGATE, 0,
                    MB_OK ,
                    0, NULL, 0,
                    FALSE, __FILE__, __LINE__);
          }

            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        HRESULT hr;
        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pAttrInfo->pADsValues->Integer = (ADS_INTEGER)(ULONG_PTR)(((CDsTableDrivenPage *)pPage)->m_pData);

        if (IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID) == BST_CHECKED)
        {
            pAttrInfo->pADsValues->Integer |= UF_TRUSTED_FOR_DELEGATION;
        }
        else
        {
            pAttrInfo->pADsValues->Integer &= ~(UF_TRUSTED_FOR_DELEGATION);
        }

        DWORD cModified;

        hr = pPage->m_pDsObj->SetObjectAttributes(pAttrInfo, 1, &cModified);

        if (FAILED(hr))
        {
            DWORD dwErr;
            WCHAR wszErrBuf[MAX_PATH+1];
            WCHAR wszNameBuf[MAX_PATH+1];
            ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

            if (dwErr)
            {
                dspDebugOut((DEB_ERROR,
                             "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                             wszErrBuf, wszNameBuf, __FILE__, __LINE__));

                if (ERROR_PRIVILEGE_NOT_HELD == dwErr)
                {
                    // Whoda thunk that a single bit in UAC has an access check on
                    // it. Do special case error checking and reporting for the
                    // delegate bit.
                    //
                    CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                   (pAttrInfo->pADsValues->Integer & UF_TRUSTED_FOR_DELEGATION) ?
                                        BST_UNCHECKED : BST_CHECKED);
                    ErrMsg(IDS_ERR_CANT_DELEGATE, pPage->GetHWnd());
                }
                else
                {
                    ReportError(dwErr, IDS_ADS_ERROR_FORMAT, pPage->GetHWnd());
                }
            }
            else
            {
                dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", hr, __FILE__, __LINE__));
                ReportError(hr, IDS_ADS_ERROR_FORMAT, pPage->GetHWnd());
            }
            return hr;
        }

        return ADM_S_SKIP;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ComputerRole
//
//  Synopsis:   Handles the computer Role value.
//
//-----------------------------------------------------------------------------
HRESULT
ComputerRole(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerRole);

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    //
    // Set the computer role value. It was stored by the PuterCanDelegateChk
    // which means that it must be called before this attr function.
    //
    int id;
    PTSTR ptz;

    id = IDS_ROLE_WKS;  // UF_WORKSTATION_TRUST_ACCOUNT

    if ((ULONG_PTR)((CDsTableDrivenPage *)pPage)->m_pData & UF_SERVER_TRUST_ACCOUNT)
    {
        id = IDS_ROLE_SVR;
    }

    if (!LoadStringToTchar(id, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    SetDlgItemText(pPage->GetHWnd(), IDC_ROLE_EDIT, ptz);

    delete ptz;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ComputerDnlvlName
//
//  Synopsis:   Handles the computer SAM account name value.
//
//-----------------------------------------------------------------------------
HRESULT
ComputerDnlvlName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerDnlvlName);
    PTSTR ptz;
    size_t len;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        //
        // Strip the dollar sign off of the SAM account name value. This is a
        // must-have attribute, so it is expected to exist although the user
        // may not have read permission. If the latter, ADSI returns no value.
        //
        if (!pAttrInfo || !pAttrInfo->dwNumValues || !pAttrInfo->pADsValues)
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
            PATTR_DATA_CLEAR_WRITABLE(pAttrData);
            break;
        }

        if (!UnicodeToTchar(pAttrInfo->pADsValues->CaseIgnoreString, &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }

        len = _tcslen(ptz);

        if (ptz[len - 1] == TEXT('$'))
        {
            ptz[len - 1] = TEXT('\0');
        }
        //
        // Set the max edit control length to one less than the max attr length
        // to allow for the $ that we stripped off.
        //
        SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                           EM_LIMITTEXT, pAttrMap->nSizeLimit - 1, 0);

        SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz);

        delete ptz;

        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }

        break;

    }
    return S_OK;
}

#endif  //DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   ShComputerRole
//
//  Synopsis:   Handles the computer Role value for the shell computer general
//              page.
//
//-----------------------------------------------------------------------------
HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerRole);

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    //
    // Set the computer role value.
    //
    PTSTR ptz;

    int id = IDS_ROLE_WKS;  // UF_WORKSTATION_TRUST_ACCOUNT

    if (pAttrInfo && pAttrInfo->dwNumValues && pAttrInfo->pADsValues &&
        (pAttrInfo->pADsValues->Integer & UF_SERVER_TRUST_ACCOUNT))
    {
        id = IDS_ROLE_SVR;
    }

    if (!LoadStringToTchar(id, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz);

    delete ptz;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\domain.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       domain.h
//
//  Contents:   DS domain object and policy object property pages header
//
//  Classes:    CDsDomainGenPage, CDsDomPolicyGenPage, CDsDomPwPolicyPage,
//              CDsLockoutPolicyPage, CDsDomainTrustPage
//
//  History:    16-May-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __DOMAIN_H__
#define __DOMAIN_H__

HRESULT DomainDNSname(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT DownlevelName(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT GetDomainName(CDsPropPageBase * pPage, CRACK_NAME_OPR RequestedOpr,
                      PWSTR * pptz);

#endif // __DOMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dllmisc.cxx
//
//  Contents:   DS property pages class objects handler DLL fcn strings.
//
//  History:    21-Mar-97 EricB created
//              25-Mar-01 EricB split out admin version for adprop.dll.
//
//-----------------------------------------------------------------------------

#include "pch.h"

WCHAR const c_szDsProppagesProgID[] = L"ADPropertyPages.";
WCHAR const c_szDsProppagesDllName[] = L"adprop.dll";

#define DSPROP_ADMIN
#include "misc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\dlgbase.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dlgbase.cxx
//
//  Contents:   base classes for dialog boxes.
//
//  Classes:    CModalDialog
//
//  History:    29-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "dlgbase.h"

//+----------------------------------------------------------------------------
//
//  Method:    CModalDialog::StaticDlgProc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CModalDialog::StaticDlgProc(HWND hDlg, UINT uMsg,
                            WPARAM wParam, LPARAM lParam)
{
   CModalDialog * pDlg = (CModalDialog *)GetWindowLongPtr(hDlg, DWLP_USER);

   if (uMsg == WM_INITDIALOG)
   {
      pDlg = (CModalDialog *)lParam;

      pDlg->_hDlg = hDlg;

      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pDlg);

      return pDlg->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   if (pDlg != NULL)
   {
      return pDlg->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Method:    CModalDialog::DlgProc
//
//  Synopsis:  Instance specific wind proc
//
//-----------------------------------------------------------------------------
LRESULT
CModalDialog::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   LRESULT lr;

   switch (uMsg)
   {
   case WM_INITDIALOG:
      _fInInit = TRUE;
      lr = OnInitDialog(lParam);
      _fInInit = FALSE;
      return (lr == S_OK) ? TRUE : FALSE;

   case WM_NOTIFY:
      return OnNotify(wParam, lParam);

   case WM_HELP:
      return OnHelp((LPHELPINFO)lParam);

   case WM_COMMAND:
      if (_fInInit)
      {
         return TRUE;
      }
      return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                       GET_WM_COMMAND_HWND(wParam, lParam),
                       GET_WM_COMMAND_CMD(wParam, lParam)));
   case WM_DESTROY:
      return OnDestroy();

   default:
      return FALSE;
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CModalDialog::DoModal
//
//  Synopsis:  Launch the dialog.
//
//-----------------------------------------------------------------------------
INT_PTR
CModalDialog::DoModal(void)
{
   INT_PTR nRet = DialogBoxParam(g_hInstance,
                                 MAKEINTRESOURCE(_nID),
                                 _hParent,
                                 (DLGPROC)StaticDlgProc,
                                 (LPARAM)this);
   return nRet;
}

//+----------------------------------------------------------------------------
//
//  Function:  FormatWindowText
//
//  Synopsis:  Read the window text string as a format string, insert the
//             pwzInsert parameter at the %s replacement param in the string,
//             and write it back to the window.
//             Assumes that the window text contains a %s replacement param.
//
//-----------------------------------------------------------------------------
void
FormatWindowText(HWND hWnd, PCWSTR pwzInsert)
{
   CStrW strMsg, strFormat;
   int nLen;

   nLen = GetWindowTextLength(hWnd) + 1;

   strFormat.GetBufferSetLength(nLen);

   GetWindowText(hWnd, strFormat, nLen);

   strMsg.Format(strFormat, pwzInsert);

   SetWindowText(hWnd, strMsg);
}

//+----------------------------------------------------------------------------
//
//  Function:  UseOneOrTwoLine
//
//  Synopsis:  Read the label text string and see if it exceeds the length
//             of the label control. If it does, hide the label control,
//             show the big label control, and insert the text in it.
//
//-----------------------------------------------------------------------------
void
UseOneOrTwoLine(HWND hDlg, int nID, int nIdLarge)
{
   /* This doesn't work, so don't use it yet.
   CStrW strMsg;
   int nLen;
   HWND hLabel = GetDlgItem(hDlg, nID);

   nLen = GetWindowTextLength(hLabel) + 1;

   strMsg.GetBufferSetLength(nLen);

   GetDlgItemText(hDlg, nID, strMsg, nLen);

   RECT rc;
   SIZE size;

   GetClientRect(hLabel, &rc);
   MapDialogRect(hDlg, &rc);

   HDC hdc = GetDC(hLabel);

   GetTextExtentPoint32(hdc, strMsg, strMsg.GetLength(), &size);

   ReleaseDC(hLabel, hdc);

   if (size.cx > rc.right)
   {
      EnableWindow(hLabel, FALSE);
      ShowWindow(hLabel, SW_HIDE);
      hLabel = GetDlgItem(hDlg, nIdLarge);
      EnableWindow(hLabel, TRUE);
      ShowWindow(hLabel, SW_SHOW);
      SetWindowText(hLabel, strMsg);
   }
   */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\domain.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       domain.cxx
//
//  Contents:   Domain object support
//
//  History:    16-May-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "domain.h"
#include "BehaviorVersion.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   DomainDNSname
//
//  Synopsis:   Get the domain DNS name.
//
//-----------------------------------------------------------------------------
HRESULT
DomainDNSname(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
   if (DlgOp != fInit)
   {
      return S_OK;
   }
   PWSTR pwzDnsName = NULL;

   HRESULT hr = GetDomainName(pPage, GET_OBJ_CAN_NAME, &pwzDnsName);

   CHECK_HRESULT(hr, return hr);

   SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwzDnsName);

   //
   // Get the domain and forest versions.
   //
   CDomainVersion DomainVersion(pPage->GetObjPathName(), pwzDnsName);
   delete [] pwzDnsName;
   pwzDnsName = NULL;

   hr = DomainVersion.Init();

   CHECK_HRESULT(hr, return hr);
   CStrW strDomVer;

   DomainVersion.GetString(DomainVersion.GetVer(), strDomVer);

   SetDlgItemText(pPage->GetHWnd(), IDC_DOMAIN_VERSION_STATIC, strDomVer);

   CStrW strDC, strForestVer;
   hr = GetLdapServerName(pPage->m_pDsObj, strDC);

   CHECK_HRESULT(hr, return hr);
   
   CForestVersion ForestVersion;

   hr = ForestVersion.Init(strDC);

   CHECK_HRESULT(hr, return hr);

   ForestVersion.GetString(ForestVersion.GetVer(), strForestVer);

   SetDlgItemText(pPage->GetHWnd(), IDC_FOREST_VERSION_STATIC, strForestVer);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   DownlevelName
//
//  Synopsis:   Get the domain downlevel name.
//
//-----------------------------------------------------------------------------
HRESULT
DownlevelName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    PWSTR pwzNbName = NULL;

    HRESULT hr = GetDomainName(pPage, GET_NT4_DOMAIN_NAME, &pwzNbName);

    CHECK_HRESULT(hr, return hr);

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwzNbName);

    delete [] pwzNbName;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetDomainName
//
//  Synopsis:   Get the indicated domain name.
//
//-----------------------------------------------------------------------------
HRESULT
GetDomainName(CDsPropPageBase * pPage, CRACK_NAME_OPR RequestedOpr,
              PWSTR * ppwz)
{
    CSmartWStr pwz1779;
    PWSTR pwzDNSname;
    HRESULT hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwz1779);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = CrackName(pwz1779, &pwzDNSname, RequestedOpr, pPage->GetHWnd());

    CHECK_HRESULT(hr, return hr);

    if (!AllocWStr(pwzDNSname, ppwz))
    {
        LocalFreeStringW(&pwzDNSname);
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }
    LocalFreeStringW(&pwzDNSname);

    if (RequestedOpr == GET_OBJ_CAN_NAME)
    {
        if ((*ppwz)[wcslen(*ppwz) - 1] == TEXT('/'))
        {
            (*ppwz)[wcslen(*ppwz) - 1] = TEXT('\0');
        }
    }

    return S_OK;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\dlgbase.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dlgbase.h
//
//  Contents:   base classes for dialog boxes.
//
//  Classes:    CModalDialog
//
//  History:    29-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef DLGBASE_H_GUARD
#define DLGBASE_H_GUARD

//+----------------------------------------------------------------------------
//
//  Class:      CModalDialog
//
//  Purpose:    Base class for modal dialogs.
//
//-----------------------------------------------------------------------------
class CModalDialog
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CModalDialog(HWND hParent, int nTemplateID) :
      _nID(nTemplateID), _hParent(hParent), _fInInit(FALSE), _hDlg(NULL) {};
   virtual ~CModalDialog(void) {};

   //
   //  Static WndProc to be passed to CreateWindow
   //
   static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam);
   //
   //  Instance specific wind proc
   //
   LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

   INT_PTR DoModal(void);

protected:
   HWND     _hDlg;
   BOOL     _fInInit;

   virtual LRESULT OnInitDialog(LPARAM lParam) = 0;
   virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify) = 0;
   virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam) {return 0;};
   virtual LRESULT OnHelp(LPHELPINFO pHelpInfo) {return 0;};
   virtual LRESULT OnDestroy(void) {return 1;};

private:
   HWND     _hParent;
   int      _nID;
};

//+----------------------------------------------------------------------------
//
//  Function:  FormatWindowText
//
//  Synopsis:  Read the window text string as a format string, insert the
//             pwzInsert parameter at the %s replacement param in the string,
//             and write it back to the window.
//             Assumes that the window text contains a %s replacement param.
//
//-----------------------------------------------------------------------------
void
FormatWindowText(HWND hWnd, PCWSTR pwzInsert);

//+----------------------------------------------------------------------------
//
//  Function:  UseOneOrTwoLine
//
//  Synopsis:  Read the label text string and see if it exceeds the length
//             of the label control. If it does, hide the label control,
//             show the big label control, and insert the text in it.
//
//-----------------------------------------------------------------------------
void
UseOneOrTwoLine(HWND hDlg, int nID, int nIdLarge);

#endif // DLGBASE_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\computer.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.h
//
//  Contents:   DS computer object property pages header
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _COMPUTER_H_
#define _COMPUTER_H_

HRESULT
ComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
ComputerDnlvlName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp);
HRESULT
PuterCanDelegateChk(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                    PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                    DLG_OP DlgOp);
//HRESULT
//ADsIntegerToCheckbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
//             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
//             DLG_OP DlgOp);
HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

#endif // _COMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\domainversion.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      DomainVersion.cxx
//
//  Contents:  Dialogs and supporting code for displaying and raising the
//             domain version.
//
//  History:   14-April-01 EricB created
//
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "proppage.h"
#include "BehaviorVersion.h"

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_DomainVersionDlg
//
//  Synopsis:  Puts up a dialog that allows the user to view the domain version
//             levels available and if not at the highest level, to raise the
//             domain version.
//
//  Arguments: [pwzDomainPath] - The full ADSI path to the Domain-DNS object.
//             [pwzDomainDnsName] - The DNS name of the domain.
//             [hWndParent] - The caller's top level window handle.
//
//-----------------------------------------------------------------------------
void
DSPROP_DomainVersionDlg(PCWSTR pwzDomainPath,
                        PCWSTR pwzDomainDnsName,
                        HWND hWndParent)
{
   dspDebugOut((DEB_ITRACE, "DSPROP_DomainVersionDlg, domain: %ws\n", pwzDomainPath));
   if (!pwzDomainPath || !pwzDomainDnsName || !hWndParent || !IsWindow(hWndParent))
   {
      dspAssert(FALSE);
      return;
   }
   HRESULT hr = S_OK;

   CDomainVersion DomVer(pwzDomainPath, pwzDomainDnsName);

   //
   // Call CDomainVersion::Init to locate a PDC and read the intial state.
   //
   hr = DomVer.Init();

   if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
   {
      ErrMsgParam(IDS_ERR_NO_DC, (LPARAM)pwzDomainDnsName, hWndParent);
      return;
   }
   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   hr = DomVer.CheckHighestPossible();

   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   int nTemplateID = IDD_RAISE_DOMAIN_VERSION;
   if (!DomVer.CanRaise())
   {
      nTemplateID = (DomVer.IsHighest()) ?
                         IDD_HIGHEST_DOMAIN_VERSION : IDD_CANT_RAISE_DOMAIN;
   }

   CDomainVersionDlg dialog(hWndParent, pwzDomainDnsName, DomVer, nTemplateID);

   dialog.DoModal();
}

//+----------------------------------------------------------------------------
//
//  Class:     CDomainVersionDlg
//
//  Purpose:   Raise the domain behavior version and/or mode.
//
//-----------------------------------------------------------------------------
CDomainVersionDlg::CDomainVersionDlg(HWND hParent,
                                     PCWSTR pwzDomDNS,
                                     CDomainVersion & DomVer,
                                     int nTemplateID) :
   _strDomainDnsName(pwzDomDNS),
   _DomainVer(DomVer),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CDomainVersionDlg,CDomainVersionDlg);
#ifdef _DEBUG
    strcpy(szClass, "CDomainVersionDlg");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnInitDialog
//
//  Synopsis:  Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CDomainVersionDlg::OnInitDialog(LPARAM lParam)
{
   TRACE(CDomainVersionDlg,OnInitDialog);

   SetDlgItemText(_hDlg, IDC_VER_NAME_STATIC, _strDomainDnsName);

   _DomainVer.SetDlgHwnd(_hDlg);

   CStrW strVersion;
   _DomainVer.GetString(_DomainVer.GetVer(), strVersion);

   SetDlgItemText(_hDlg, IDC_CUR_VER_STATIC, strVersion);

   if (_DomainVer.CanRaise())
   {
      InitCombobox();

      if (!_DomainVer.IsPDCfound() || _DomainVer.IsReadOnly())
      {
         EnableWindow(GetDlgItem(_hDlg, IDOK), FALSE);
         CStrW strMsg;
         strMsg.LoadString(g_hInstance, _DomainVer.IsReadOnly() ?
                              IDS_CANT_RAISE_ACCESS : IDS_CANT_RAISE_PDC);
         SetDlgItemText(_hDlg, IDC_CANT_RAISE_STATIC, strMsg);
      }
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnCommand
//
//  Synopsis:  Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDomainVersionDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   switch (codeNotify)
   {
   case BN_CLICKED:
      switch (id)
      {
      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      case IDC_HELP_BTN:
         // BUGBUG: need help topic URL.
         _DomainVer.ShowHelp(L"ADConcepts.chm::/ADHelpNewTrustIntro.htm", _hDlg);
         break;

      case IDC_SAVE_LOG:
         OnSaveLog();
         break;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnOK
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CDomainVersionDlg::OnOK(void)
{
   CDomainVersion::eDomVer Ver = ReadComboSel();

   dspDebugOut((DEB_ITRACE, "Combobox selection was %d\n", Ver));

   if (CDomainVersion::error == Ver)
   {
      // No user selection. Set one and return.
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
      return;
   }

   int iRet = IDCANCEL;
   CStrW strTitle, strMsg;
   strTitle.LoadString(g_hInstance, IDS_RAISE_DOM_VER_TITLE);
   strMsg.LoadString(g_hInstance, IDS_CONFIRM_DOM_RAISE);

   iRet = MessageBox(_hDlg, strMsg, strTitle, MB_OKCANCEL | MB_ICONEXCLAMATION);

   if (iRet == IDOK)
   {
      HRESULT hr = _DomainVer.RaiseVersion(Ver);

      if (SUCCEEDED(hr))
      {
         strMsg.LoadString(g_hInstance, IDS_MODE_CHANGED);
         MessageBox(_hDlg, strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
      }
      else
      {
         REPORT_ERROR_FORMAT(hr, IDS_VERSION_ERROR_FORMAT, _hDlg);
      }

      EndDialog(_hDlg, IDOK);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnHelp
//
//  Synopsis:  Put up popup help for the control.
//
//-----------------------------------------------------------------------------
/* LRESULT
CDomainVersionDlg::OnHelp(LPHELPINFO pHelpInfo)
{
   if (!pHelpInfo)
   {
      dspAssert(FALSE);
      return 0;
   }
   dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

   if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
   {
      return 0;
   }
   WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

   return 0;
} */

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnSaveLog
//
//  Synopsis:  Prompts the user for a file name to save the DC log.
//
//-----------------------------------------------------------------------------
void
CDomainVersionDlg::OnSaveLog(void)
{
   TRACE(CDomainVersionDlg,OnSaveLog);
   HRESULT hr = S_OK;
   OPENFILENAME ofn = {0};
   WCHAR wzFilter[MAX_PATH + 1] = {0}, wzFileName[MAX_PATH + MAX_PATH + 1] = {0};
   CStrW strFilter, strExt, strMsg;
   CWaitCursor Wait;

   wcsncpy(wzFileName, _strDomainDnsName, MAX_PATH + MAX_PATH);
   strExt.LoadString(g_hInstance, IDS_FTFILE_SUFFIX);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));
   wcsncat(wzFileName, L".", MAX_PATH + MAX_PATH - wcslen(wzFileName));
   strExt.LoadString(g_hInstance, IDS_FTFILE_CSV_EXT);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));

   LoadString(g_hInstance, IDS_FTFILE_FILTER, wzFilter, MAX_PATH);

   ofn.lStructSize = sizeof(ofn);
   ofn.hwndOwner = _hDlg;
   ofn.lpstrFile = wzFileName;
   ofn.nMaxFile = MAX_PATH + MAX_PATH + 1;
   ofn.Flags = OFN_OVERWRITEPROMPT;
   ofn.lpstrDefExt = strExt;
   ofn.lpstrFilter = wzFilter;

   if (GetSaveFileName(&ofn))
   {
      dspDebugOut((DEB_ITRACE, "Saving domain DC version info to %ws\n", ofn.lpstrFile));
      PWSTR pwzErr = NULL;
      BOOL fSucceeded = TRUE;

      HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0,
                                NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);

      if (INVALID_HANDLE_VALUE != hFile)
      {
         CStrW str;
         str.LoadString(g_hInstance, IDS_DOM_VER_LOG_PREFIX);
         strMsg.Format(str, _strDomainDnsName);
         _DomainVer.GetString(_DomainVer.GetVer(), str);
         strMsg += str;
         strMsg += g_wzCRLF;
         strMsg += g_wzCRLF;
         str.LoadString(g_hInstance, IDS_DOM_VER_LOG_HDR);
         strMsg += str;
         strMsg += g_wzCRLF;

         hr = _DomainVer.BuildDcListString(strMsg);

         if (SUCCEEDED(hr))
         {
            strMsg += g_wzCRLF;

            DWORD dwWritten;

            fSucceeded = WriteFile(hFile, strMsg.GetBuffer(0),
                                   strMsg.GetLength() * sizeof(WCHAR),
                                   &dwWritten, NULL);
         }
         CloseHandle(hFile);
      }
      else
      {
         fSucceeded = FALSE;
      }


      if (!fSucceeded || FAILED(hr))
      {
         CStrW strTitle;
         strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
         LoadErrorMessage(FAILED(hr) ? hr : GetLastError(), 0, &pwzErr);
         if (pwzErr)
         {
            strMsg.FormatMessage(g_hInstance, IDS_LOGFILE_CREATE_FAILED, pwzErr);
            delete [] pwzErr;
         }
         MessageBox(_hDlg, strMsg, strTitle, MB_ICONERROR);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::InitCombobox
//
//  Synopsis:  Fills the combobox with levels appropriate for the current
//             state.
//
//-----------------------------------------------------------------------------
void
CDomainVersionDlg::InitCombobox(void)
{
   CStrW strVersion;

   switch (_DomainVer.GetVer())
   {
   case CDomainVersion::Win2kMixed:
      //
      // Can go to Win2kNative.
      //
      _DomainVer.GetString(CDomainVersion::Win2kNative, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 0,
                         (LPARAM)(PCWSTR)strVersion);
      if (_DomainVer.HighestCanGoTo() == CDomainVersion::WhistlerNative)
      {
         //
         // Can also go all the way to Whistler.
         //
         _DomainVer.GetString(CDomainVersion::WhistlerNative, strVersion);
         SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 1,
                            (LPARAM)(PCWSTR)strVersion);
      }
      break;

   case CDomainVersion::WhistlerBetaMixed:
      //
      // Can go to either WhistlerBetaNative or to Whistler.
      //
      _DomainVer.GetString(CDomainVersion::WhistlerBetaNative, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 0,
                         (LPARAM)(PCWSTR)strVersion);
      _DomainVer.GetString(CDomainVersion::WhistlerNative, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 1,
                         (LPARAM)(PCWSTR)strVersion);
      break;

   case CDomainVersion::Win2kNative:
   case CDomainVersion::WhistlerBetaNative:
      //
      // Can only go to Whistler.
      //
      _DomainVer.GetString(CDomainVersion::WhistlerNative, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 0,
                         (LPARAM)(PCWSTR)strVersion);
      break;

   default:
      dspAssert(FALSE);
      return;
   }

   SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::ReadComboSel
//
//  Synopsis:  Read the current selection of the combobox.
//
//-----------------------------------------------------------------------------
CDomainVersion::eDomVer
CDomainVersionDlg::ReadComboSel(void)
{
   LONG_PTR lRet = SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_GETCURSEL, 0, 0);

   if (CB_ERR == lRet)
   {
      return CDomainVersion::error;
   }

   switch (_DomainVer.GetVer())
   {
   case CDomainVersion::Win2kMixed:
      return (0 == lRet) ? CDomainVersion::Win2kNative : CDomainVersion::WhistlerNative;

   case CDomainVersion::WhistlerBetaMixed:
      dspAssert(2 == SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_GETCOUNT, 0, 0));
      return (0 == lRet) ? CDomainVersion::WhistlerBetaNative : CDomainVersion::WhistlerNative;

   case CDomainVersion::Win2kNative:
   case CDomainVersion::WhistlerBetaNative:
      dspAssert(1 == SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_GETCOUNT, 0, 0));
      return CDomainVersion::WhistlerNative;

   default:
      dspAssert(FALSE);
      return CDomainVersion::error;
   }
}

//+----------------------------------------------------------------------------
//
//  Class:     CDomainVersion
//
//  Purpose:   Manages the interpretation of the domain version value.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::Init
//
//  Synopsis:  Locate a PDC and set up the initial state.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::Init(void)
{
   TRACE(CDomainVersion,Init);
   CWaitCursor Wait;
   HRESULT hr = S_OK;
   DWORD dwErr;
   PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
   CComBSTR bstrPath;
   CPathCracker PathCrack;

   hr = PathCrack.Set(_strFullDomainPath.GetBuffer(0), ADS_SETTYPE_FULL);

   CHECK_HRESULT(hr, return hr);

   CComBSTR bstrDC;

   hr = PathCrack.Retrieve(ADS_FORMAT_SERVER, &bstrDC);

   CHECK_HRESULT(hr, return hr);

   //
   // Get the PDC's name.
   //
   dwErr = DsGetDcNameW(NULL, _strDomainDnsName, NULL, NULL, 
                        DS_PDC_REQUIRED, &pDCInfo);

   if (dwErr != ERROR_SUCCESS)
   {
      dspDebugOut((DEB_ERROR, "DsGetDcName failed with error 0x%08x in domain %ws\n",
                   dwErr, _strDomainDnsName.GetBuffer(0)));

      _fPDCfound = false;

      //
      // PDC is not online. Check to see if any DC is available.
      //
      dwErr = DsGetDcNameW(NULL, _strDomainDnsName, NULL, NULL, 
                           DS_DIRECTORY_SERVICE_REQUIRED, &pDCInfo);

      CHECK_WIN32(dwErr, return HRESULT_FROM_WIN32(dwErr));
      NetApiBufferFree(pDCInfo);

      _strDC = bstrDC; // continue to use the DC the snapin is bound to.
   }
   else
   {
      _fPDCfound = true;

      _strDC = pDCInfo->DomainControllerName + 2; // skip the backslashes

      NetApiBufferFree(pDCInfo);

      //
      // Reset the domain path to include the PDC name.
      //
      if (_strDC.CompareNoCase(bstrDC))
      {
         hr = PathCrack.Set(_strDC.GetBuffer(0), ADS_SETTYPE_SERVER);         

         CHECK_HRESULT(hr, return hr);

         hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrPath);

         CHECK_HRESULT(hr, return hr);

         _strFullDomainPath = bstrPath;

         dspDebugOut((DEB_ITRACE, "new path: %ws\n", _strFullDomainPath.GetBuffer(0)));
      }
   }

   //
   // Get the base DN for the domain;
   //
   hr = PathCrack.Retrieve(ADS_FORMAT_X500_DN, &bstrPath);

   CHECK_HRESULT(hr, return hr);

   _strDomainDN = bstrPath;

   //
   // Check if the user has write access to the behavior version and mode
   // attrs. Read the mode and version.
   //
   CComPtr<IDirectoryObject> spDomain;

   hr = ADsOpenObject(_strFullDomainPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IDirectoryObject), (void **)&spDomain);

   CHECK_HRESULT(hr, return hr);

   Smart_PADS_ATTR_INFO pAttrs;
   DWORD cAttrs = 0;
   PWSTR rgwzNames[] = {g_wzAllowed, g_wzDomainMode, g_wzBehaviorVersion};

   hr = spDomain->GetObjectAttributes(rgwzNames, ARRAYLENGTH(rgwzNames),
                                      &pAttrs, &cAttrs);

   if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, NULL))
   {
      return hr;
   }
   bool fBVfound = false, fModeFound = false;

   for (UINT i = 0; i < cAttrs; i++)
   {
      if (_wcsicmp(pAttrs[i].pszAttrName, g_wzAllowed) == 0)
      {
         for (DWORD j = 0; j < pAttrs[i].dwNumValues && !(fBVfound && fModeFound); j++)
         {
            if (_wcsicmp(pAttrs[i].pADsValues[j].CaseIgnoreString, g_wzBehaviorVersion) == 0)
            {
               fBVfound = true;
               continue;
            }
            if (_wcsicmp(pAttrs[i].pADsValues[j].CaseIgnoreString, g_wzDomainMode) == 0)
            {
               fModeFound = true;
            }
         }
         continue;
      }
      if (_wcsicmp(pAttrs[i].pszAttrName, g_wzBehaviorVersion) == 0)
      {
         _nCurVer = (UINT)pAttrs[i].pADsValues->Integer;
         continue;
      }
      if (_wcsicmp(pAttrs[i].pszAttrName, g_wzDomainMode) == 0)
      {
         _fMixed = pAttrs[i].pADsValues->Integer != 0;
      }
   }

   if (fBVfound && fModeFound)
   {
      _fReadOnly = false;
   }

   if (0 == _nCurVer && fModeFound)
   {
      // Pure Win2k domains don't have a behavior version attribute.
      //
      _fReadOnly = false;
   }

   _fInitialized = true;

   dspDebugOut((DEB_ITRACE, "mode on %ws is %s, version is %u\n", _strFullDomainPath.GetBuffer(0),
                _fMixed ? "mixed" : "native", _nCurVer));

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::CheckHighestPossible
//
//  Synopsis:  Check what version is the highest allowable: query those nTDSDSA
//             objects whose hasMasterNCs includes the DN of the domain. Calc
//             the min version of the result set.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::CheckHighestPossible(void)
{
   TRACE(CDomainVersion,CheckHighestPossible);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   if (IsHighest())
   {
      // We are already at the highest version, it can't be raised any further.
      //
      dspAssert(!_fMixed);
      _fCanRaiseBehaviorVersion = false;
      return S_OK;
   }

   dspAssert(!_DcLogList.size());
   HRESULT hr = S_OK;
   CWaitCursor Wait;
   //
   // Get the config container path from the RootDSE and then build the path to
   // the Sites container.
   //
   CComPtr<IADs> spRoot;
   CStrW strRootPath = g_wzLDAPPrefix;
   strRootPath += _strDC;
   strRootPath += L"/";
   strRootPath += g_wzRootDSE;

   hr = ADsOpenObject(strRootPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IADs), (void **)&spRoot);

   CHECK_HRESULT(hr, return hr);

   CComVariant var;

   hr = spRoot->Get(g_wzConfigNamingContext, &var);

   CHECK_HRESULT(hr, return hr);
   dspAssert(VT_BSTR == var.vt);

   CStrW strSitesPath = g_wzLDAPPrefix;
   strSitesPath += _strDC;
   strSitesPath += L"/CN=Sites,";
   strSitesPath += var.bstrVal;

   //
   // Search for the nTDSDSA objects that belong to this domain.
   //
   WCHAR wzSearchClauseFormat[] = L"(hasMasterNCs=%s)";
   CStrW strFilterClause;
   strFilterClause.Format(wzSearchClauseFormat, _strDomainDN.GetBuffer(0));

   hr = EnumDsaObjs(strSitesPath, strFilterClause, _strDomainDnsName, _nCurVer + 1);

   CHECK_HRESULT(hr, return hr);

   if (!_fCanRaiseBehaviorVersion)
   {
      // Non-conforming DCs were found, set the max version.
      //
      _eHighest = (DC_VER_WIN2K == _nMinDcVerFound) ? Win2kNative : WhistlerBetaNative;
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::MapVersion
//
//  Synopsis:  Returns an enum value for the legal combinations of version and
//             mode.
//
//-----------------------------------------------------------------------------
CDomainVersion::eDomVer
CDomainVersion::MapVersion(UINT nVer, bool fMixed) const
{
   switch (nVer)
   {
   case DOMAIN_VER_WIN2K_MIXED: // and DOMAIN_VER_WIN2K_NATIVE:
      return (fMixed) ? Win2kMixed : Win2kNative;

   case DOMAIN_VER_XP_BETA_MIXED: // and DOMAIN_VER_XP_BETA_NATIVE:
      return (fMixed) ? WhistlerBetaMixed : WhistlerBetaNative;

   case DOMAIN_VER_XP_NATIVE:
      if (fMixed)
      {
         dspAssert(FALSE);
         return error;
      }
      return WhistlerNative;

   case DOMAIN_VER_UNKNOWN:
      return unknown;
   }
   return error;
}


//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::GetString
//
//  Synopsis:  Returns the string description of the domain version.
//
//  Note:      The GetString methods can be called without having called Init
//             first.
//
//-----------------------------------------------------------------------------
bool
CDomainVersion::GetString(UINT nVer, bool fMixed, CStrW & strVersion) const
{
   return GetString(MapVersion(nVer, fMixed), strVersion);
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::GetString
//
//-----------------------------------------------------------------------------
bool
CDomainVersion::GetString(eDomVer ver, CStrW & strVersion) const
{
   UINT nID = 0;

   switch (ver)
   {
   case Win2kMixed:
      nID = IDS_DOM_VER_W2K_MIXED;
      break;

   case Win2kNative:
      nID = IDS_DOM_VER_W2K_NATIVE;
      break;

   case WhistlerBetaMixed:
      nID = IDS_DOM_VER_XP_BETA_MIXED;
      break;

   case WhistlerBetaNative:
      nID = IDS_DOM_VER_XP_BETA_NATIVE;
      break;

   case WhistlerNative:
      nID = IDS_DOM_VER_XP;
      break;

   case unknown:
      nID = IDS_REL_UNKNOWN;
      break;

   default:
      dspAssert(FALSE);
      return false;
   }

   return strVersion.LoadString(g_hInstance, nID) == TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::GetMode
//
//  Synopsis:  Return the domain mode. Read it from the nTMixedDomain attribute
//             if not yet checked.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::GetMode(bool & fMixed)
{
   TRACE(CDomainVersion,GetMode);

   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   fMixed = _fMixed;

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::SetNativeMode
//
//  Synopsis:  Set the domain into native mode.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::SetNativeMode(void)
{
   TRACE(CDomainVersion,SetNativeMode);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   HRESULT hr = S_OK;
   CComPtr<IADs> spDomain;

   hr = ADsOpenObject(_strFullDomainPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IADs), (void **)&spDomain);

   CHECK_HRESULT(hr, return hr);
   CComVariant var;

   var.vt = VT_I4;
   var.lVal = 0;

   hr = spDomain->Put(g_wzDomainMode, var);

   CHECK_HRESULT(hr, return hr);

   hr = spDomain->SetInfo();

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::RaiseVersion
//
//  Synopsis:  Raise the domain version. If needed, set the domain mode to
//             native.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::RaiseVersion(eDomVer NewVer)
{
   TRACE(CDomainVersion,RaiseVersion);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   CWaitCursor Wait;
   HRESULT hr = S_OK;
   CComPtr<IADs> spDomain;

   hr = ADsOpenObject(_strFullDomainPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IADs), (void **)&spDomain);

   CHECK_HRESULT(hr, return hr);

   CComVariant var;

   switch (NewVer)
   {
   case Win2kNative:
      dspAssert(MapVersion(_nCurVer, _fMixed) == Win2kMixed);
      hr = SetNativeMode();
      CHECK_HRESULT(hr, ;);
      return hr;

   case WhistlerBetaMixed:
      //
      // Should never be requesting this version.
      //
      dspAssert(FALSE);
      return E_INVALIDARG;

   case WhistlerBetaNative:
      //
      // This option is provided to allow moving a Whistler Beta 2 domain to
      // native mode.
      //
      dspAssert(MapVersion(_nCurVer, _fMixed) == WhistlerBetaMixed);
      hr = SetNativeMode();
      CHECK_HRESULT(hr, ;);
      return hr;

   case WhistlerNative:
      if (_fMixed)
      {
         hr = SetNativeMode();
         CHECK_HRESULT(hr, return hr);
      }
      var.vt = VT_I4;
      var.lVal = DOMAIN_VER_XP_NATIVE;
      break;

   default:
      dspAssert(FALSE);
      return E_INVALIDARG;
   }

   hr = spDomain->Put(g_wzBehaviorVersion, var);

   CHECK_HRESULT(hr, return hr);

   hr = spDomain->SetInfo();

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\dscmn.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dscmn.cxx
//
//  Contents:   Shared functionality between DSPROP and DSADMIN
//
//  History:    02-Mar-98 JonN created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "siterepl.h"

#ifdef DSADMIN

#define BREAK_ON_TRUE(b) if (b) { ASSERT(FALSE); break; }
#define BREAK_ON_FAIL BREAK_ON_TRUE(FAILED(hr))
#define RETURN_IF_FAIL CHECK_HRESULT(hr, return hr);

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    01-13-1999   JonN       Copied from DavidMun sample code
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(
    LPCWSTR lpcwszTarget,
    IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType =   DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = lpcwszTarget;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}


HRESULT ExtractServerName(
	IN LPCWSTR lpcwszRootPath, // only the server name is used
	OUT BSTR* pbstrServerName )
{
	ASSERT( NULL != pbstrServerName && NULL == *pbstrServerName );

	if (NULL == lpcwszRootPath)
		return S_OK;

	HRESULT hr = S_OK;
	CComPtr<IADsPathname> spPathCracker;
	do
	{
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
		                              IID_IADsPathname, (PVOID *)&spPathCracker);
		BREAK_ON_FAIL;
		ASSERT( !!spPathCracker );

		hr = spPathCracker->Set(const_cast<LPWSTR>(lpcwszRootPath), ADS_SETTYPE_FULL);
		BREAK_ON_FAIL;

		hr = spPathCracker->Retrieve(ADS_FORMAT_SERVER, pbstrServerName);
		BREAK_ON_FAIL;

		// CODEWORK so what happens if this is still NULL?
	} while (false); // false loop

	return hr;
}


HRESULT DSPROP_PickComputer(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath, // only the server name is used
	OUT BSTR* pbstrADsPath )
{
	ASSERT( NULL != pbstrADsPath && NULL == *pbstrADsPath );

	HRESULT hr = S_OK;
	FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
	PDS_SELECTION_LIST pDsSelList = NULL;
	bool fGotStgMedium = false;

	do
	{
		CComBSTR sbstrTarget;
		hr = ExtractServerName( lpcwszRootPath, &sbstrTarget );
		BREAK_ON_FAIL;

		CComPtr<IDsObjectPicker> spDsObjectPicker;
		hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
		                      IID_IDsObjectPicker, (PVOID *)&spDsObjectPicker);
		BREAK_ON_FAIL;
		ASSERT( !!spDsObjectPicker );

		hr = InitObjectPickerForComputers(sbstrTarget, spDsObjectPicker);
		BREAK_ON_FAIL;

		CComPtr<IDataObject> pdoSelections;
		hr = spDsObjectPicker->InvokeDialog(hwndParent, &pdoSelections);
		BREAK_ON_FAIL;

		if (hr == S_FALSE || !pdoSelections)
		{
			hr = S_FALSE;
			break;
		}

		hr = pdoSelections->GetData(&fmte, &medium);
		BREAK_ON_FAIL;

		fGotStgMedium = true;

		pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

		if (   NULL == pDsSelList
		    || 1 != pDsSelList->cItems
		    || NULL == pDsSelList->aDsSelection[0].pwzADsPath
		    || L'\0' == *(pDsSelList->aDsSelection[0].pwzADsPath)
		   )
		{
		  hr = E_FAIL;
		  BREAK_ON_FAIL;
		}

		*pbstrADsPath = ::SysAllocString(pDsSelList->aDsSelection[0].pwzADsPath);
		ASSERT( NULL != *pbstrADsPath );

	} while (false); // false loop

	if (pDsSelList)
		GlobalUnlock( pDsSelList );
	if (fGotStgMedium)
		ReleaseStgMedium( &medium );

	return hr;
}

HRESULT DSPROP_DSQuery(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath,
	IN CLSID* pclsidDefaultForm,
	OUT BSTR* pbstrADsPath )
{
	ASSERT( NULL != hwndParent
		 // && NULL != lpcwszRootPath  JonN 3/23/99 this is actually OK
		 && NULL != pclsidDefaultForm
		 && NULL != pbstrADsPath );
	CComPtr<ICommonQuery> spCommonQuery;
	CComPtr<IDataObject> spDataObject;
	CComBSTR sbstrADsPath;
	HRESULT hr = S_OK;

	hr = ::CoCreateInstance(
		CLSID_CommonQuery,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ICommonQuery,
		(LPVOID*)&spCommonQuery );
	RETURN_IF_FAIL;

	// 373849 JonN 7/28/99
	CComBSTR sbstrTarget;
	hr = ExtractServerName( lpcwszRootPath, &sbstrTarget );
	RETURN_IF_FAIL;

	DSQUERYINITPARAMS dqip;
	::ZeroMemory(&dqip,sizeof(dqip));
	dqip.cbStruct = sizeof(dqip);
	dqip.dwFlags =   DSQPF_SHOWHIDDENOBJECTS
	               | DSQPF_ENABLEADMINFEATURES
	               | DSQPF_NOSAVE
	               | DSQPF_HASCREDENTIALS; // 373849 JonN 7/28/99

	// 122519 JonN 11/06/00
	// If you remove a column in CLSID_DsFindDomainController, you can't
	// restore it.  This is due to a weakness in Display Specifiers, but a
	// fix there will have to wait until Blackcomb.  I would also prefer to
	// change the DSPROP_DSQuery() signature, but this is the lightest-touch
	// option at this stage.
	if (CLSID_DsFindDomainController == *pclsidDefaultForm)
		dqip.dwFlags |= DSQPF_NOCHOOSECOLUMNS;

	dqip.pDefaultScope = const_cast<LPWSTR>(lpcwszRootPath); // use selected server
	dqip.pServer = sbstrTarget; // 373849 JonN 7/28/99

	OPENQUERYWINDOW oqw;
	::ZeroMemory(&oqw,sizeof(oqw));
	oqw.cbStruct = sizeof(oqw);
	oqw.dwFlags = OQWF_OKCANCEL |
				  OQWF_SINGLESELECT |
				  OQWF_DEFAULTFORM |
				  OQWF_REMOVESCOPES |
				  OQWF_REMOVEFORMS |
				  OQWF_ISSUEONOPEN;
	oqw.clsidHandler = CLSID_DsQuery;
	oqw.pHandlerParameters = &dqip;
	oqw.clsidDefaultForm = *pclsidDefaultForm;
	oqw.pPersistQuery = NULL;

	hr = spCommonQuery->OpenQueryWindow(hwndParent, &oqw, &spDataObject);
	if (S_FALSE == hr) // user hit cancel
		return S_FALSE;
	RETURN_IF_FAIL;
	ASSERT( spDataObject );

	static CLIPFORMAT cfDsObjectNames = 0;
	if ( 0 == cfDsObjectNames )
	{
		cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
		ASSERT( 0 != cfDsObjectNames );
	}

	FORMATETC fmte = {cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = { TYMED_NULL, NULL, NULL };
	hr = spDataObject->GetData(&fmte, &medium);
	if( FAILED(hr) )
		return S_FALSE;

	// CODEWORK does this have to be freed?
	LPDSOBJECTNAMES pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;
	ASSERT( NULL != pDsObjects );
	if (0 == pDsObjects->cItems)
		return S_FALSE;
	ASSERT( 1 == pDsObjects->cItems );

	*pbstrADsPath = ::SysAllocString(
		(LPTSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetName) );

	return hr;
}


HRESULT DSPROP_PickNTDSDSA(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath,
	OUT BSTR* pbstrADsPath )
{
	return DSPROP_DSQuery(
		hwndParent,
		lpcwszRootPath,
		const_cast<CLSID*>(&CLSID_DsFindDomainController),
		pbstrADsPath );
}


HRESULT DSPROP_IsFrsObject( IN LPWSTR pszClassName, OUT bool* pfIsFrsObject )
{
	if (NULL == pszClassName || NULL == pfIsFrsObject)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	*pfIsFrsObject = false;
	if ( !lstrcmp( L"nTDSDSA", pszClassName ) )
	{
		// nothing
	}
	else if (   !lstrcmp( L"nTFRSMember", pszClassName )
			 || !lstrcmp( L"nTFRSReplicaSet", pszClassName ) )
	{
		*pfIsFrsObject = true;
	}
	else
	{
		ASSERT(FALSE);
	}
	return S_OK;
}

HRESULT DSPROP_RemoveX500LeafElements(
    IN unsigned int nElements,
    IN OUT BSTR* pbstrADsPath )
{
    ASSERT( NULL != pbstrADsPath );
    CComPtr<IADsPathname> spADsPath;
    HRESULT hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                      IID_IADsPathname, (PVOID *)&spADsPath);
    RETURN_IF_FAIL;
    hr = spADsPath->Set( *pbstrADsPath, ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    for (unsigned int i = 0; i < nElements; i++)
    {
        hr = spADsPath->RemoveLeafElement();
        RETURN_IF_FAIL;
    }
    hr = spADsPath->SetDisplayType( ADS_DISPLAY_FULL );
    RETURN_IF_FAIL;
    CComBSTR sbstr;
    // determine whether a servername is present, if so preserve  it
    hr = spADsPath->Retrieve( ADS_FORMAT_SERVER, &sbstr );
    bool fNoServer = ( FAILED(hr) || !sbstr || *sbstr == L'\0');
    ::SysFreeString( *pbstrADsPath );
    *pbstrADsPath = NULL;
    hr = spADsPath->Retrieve(
        (fNoServer) ? ADS_FORMAT_X500_NO_SERVER : ADS_FORMAT_X500,
        pbstrADsPath );
    RETURN_IF_FAIL;
    return hr;
}


HRESULT DSPROP_TweakADsPath(
    IN     LPCWSTR       lpcwszInitialADsPath,
    IN     int           iTargetLevelsUp,
    IN     PWCHAR*       ppwszTargetLevelsBack,
    OUT    BSTR*         pbstrResultDN
    )
{
    ASSERT( NULL != lpcwszInitialADsPath
         && NULL != pbstrResultDN
         && NULL == *pbstrResultDN );

    CComPtr<IADsPathname> spIADsPathname;
    HRESULT hr = CoCreateInstance(
        CLSID_Pathname,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsPathname,
        (PVOID *)&spIADsPathname );
    RETURN_IF_FAIL;
    ASSERT( !!spIADsPathname );

    hr = spIADsPathname->Set(
        const_cast<LPWSTR>(lpcwszInitialADsPath),
        ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    for (int i = 0; i < iTargetLevelsUp; i++)
    {
        hr = spIADsPathname->RemoveLeafElement();
        RETURN_IF_FAIL;
    }
    if ( NULL != ppwszTargetLevelsBack )
    {
        for (int i = 0; NULL != ppwszTargetLevelsBack[i]; i++)
        {
            hr = spIADsPathname->AddLeafElement( ppwszTargetLevelsBack[i] );
            RETURN_IF_FAIL;
        }
    }
    hr = spIADsPathname->Retrieve( ADS_FORMAT_X500, pbstrResultDN );
    RETURN_IF_FAIL;
    ASSERT( NULL != pbstrResultDN );

    return S_OK;
}

HRESULT DSPROP_RetrieveRDN(
    IN     LPCWSTR         lpcwszDN,
    OUT    BSTR*           pbstrRDN
    )
{
    ASSERT( NULL != lpcwszDN
         && NULL != pbstrRDN
         && NULL == *pbstrRDN );

    CComPtr<IADsPathname> spIADsPathname;
    HRESULT hr = CoCreateInstance(
        CLSID_Pathname,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsPathname,
        (PVOID *)&spIADsPathname );
    RETURN_IF_FAIL;
    ASSERT( !!spIADsPathname );

    hr = spIADsPathname->Set(
        const_cast<LPWSTR>(lpcwszDN),
        ADS_SETTYPE_DN );
    RETURN_IF_FAIL;
    hr = spIADsPathname->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    RETURN_IF_FAIL;
    hr = spIADsPathname->put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
    RETURN_IF_FAIL;
    hr = spIADsPathname->GetElement( 0L, pbstrRDN );
    RETURN_IF_FAIL;
    ASSERT( NULL != *pbstrRDN );

    return S_OK;
}

/* currently unused.
//
// lifted from uacct.cxx CDsUserAcctPage::OnApply -- JonN 4/21/98
// Obtains an instance of IDirectorySearch against a GC
// returns S_FALSE if no GC was found
//
HRESULT DSPROP_GetGCSearch(
    IN  REFIID iid,
    OUT void** ppvObject )
{
    ASSERT( NULL != ppvObject && NULL == *ppvObject );

    CComPtr <IADsContainer> spGCRoot;
    HRESULT hr = ADsOpenObject(L"GC:", NULL, NULL, ADS_SECURE_AUTHENTICATION,
                               IID_IADsContainer, (PVOID *)&spGCRoot);
    RETURN_IF_FAIL;
    IEnumVARIANT * pEnum = NULL;
    hr = ADsBuildEnumerator(spGCRoot, &pEnum);
    RETURN_IF_FAIL;
    CComVariant varEnum;
    ULONG fetched = 0L;
    hr = ADsEnumerateNext(pEnum, 1, &varEnum, &fetched);
    ADsFreeEnumerator(pEnum);
    RETURN_IF_FAIL;
    if (S_FALSE == hr)
      return hr; // no GC found
    if (1 != fetched || VT_DISPATCH != varEnum.vt || NULL == varEnum.pdispVal)
    {
      ASSERT(FALSE);
      return E_FAIL;
    }
    hr = varEnum.pdispVal->QueryInterface(iid,ppvObject);
    RETURN_IF_FAIL;
    return S_OK;
}
*/

#endif // DSADMIN

//
// Smartpointer functions for PADS_ATTR_INFO pointers and for DsBind handles
// JonN 4/7/98
//

void Smart_DsHandle__Empty( HANDLE* phDs )
{
  if (NULL != *phDs)
  {
    DsUnBind( phDs );
    dspAssert( NULL == *phDs );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in propuuid.h
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

#include <propuuid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\forestversion.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      ForestVersion.cxx
//
//  Contents:  Dialogs and supporting code for displaying and raising the
//             forest version.
//
//  History:   14-April-01 EricB created
//
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ntdsadef.h>
#include "proppage.h"
#include "qrybase.h"
#include "BehaviorVersion.h"

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_ForestVersionDlg
//
//  Synopsis:  Puts up a dialog that allows the user to view the forest version
//             levels available and if not at the highest level, to raise the
//             forest version.
//
//  Arguments: [pwzConfigPath] - The full ADSI path to the configuration container.
//             [pwzPartitionsPath] - The full ADSI path to the partitions container.
//             [pwzSchemaPath] - The full ADSI path to the schema container.
//             [pwzRootDnsName] - The DNS name of the enterprise root domain.
//             [hWndParent] - The caller's top level window handle.
//
//  Notes:     This function is called only from Domains & Trusts. If the
//             snapin is running on a child domain, the DC named in the ADSI
//             path will be for the child domain. In that case will need to
//             get the PDC (if possible) for the root domain.
//
//-----------------------------------------------------------------------------
void
DSPROP_ForestVersionDlg(PCWSTR pwzConfigPath,
                        PCWSTR pwzPartitionsPath,
                        PCWSTR pwzSchemaPath,
                        PCWSTR pwzRootDnsName,
                        HWND hWndParent)
{
   dspDebugOut((DEB_ITRACE, "DSPROP_ForestVersionDlg, config: %ws\n", pwzPartitionsPath));
   if (!pwzConfigPath || !pwzPartitionsPath || !pwzSchemaPath ||
       !pwzRootDnsName || !hWndParent || !IsWindow(hWndParent))
   {
      dspAssert(FALSE);
      return;
   }

   CForestVersion ForestVer;

   HRESULT hr = ForestVer.Init(pwzConfigPath, pwzPartitionsPath, pwzSchemaPath);

   if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
   {
      ErrMsgParam(IDS_ERR_NO_DC, (LPARAM)pwzRootDnsName, hWndParent);
      return;
   }
   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   hr = ForestVer.CheckHighestPossible();

   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   int nTemplateID = IDD_RAISE_FOREST_VERSION;
   if (!ForestVer.CanRaise())
   {
      nTemplateID = (ForestVer.IsHighest()) ?
                         IDD_HIGHEST_FOREST_VERSION : IDD_CANT_RAISE_FOREST;
   }

   CForestVersionDlg dialog(hWndParent, pwzRootDnsName, ForestVer, nTemplateID);

   dialog.DoModal();
}

//+----------------------------------------------------------------------------
//
//  Class:     CForestVersionDlg
//
//  Purpose:   Raise the forest behavior version.
//
//-----------------------------------------------------------------------------
CForestVersionDlg::CForestVersionDlg(HWND hParent,
                                     PCWSTR pwzRootDNS,
                                     CForestVersion & ForestVer,
                                     int nTemplateID) :
   _strRootDnsName(pwzRootDNS),
   _ForestVer(ForestVer),
   _nTemplateID(nTemplateID),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CForestVersionDlg,CForestVersionDlg);
#ifdef _DEBUG
    strcpy(szClass, "CForestVersionDlg");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnInitDialog
//
//  Synopsis:  Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CForestVersionDlg::OnInitDialog(LPARAM lParam)
{
   TRACE(CForestVersionDlg,OnInitDialog);

   SetDlgItemText(_hDlg, IDC_VER_NAME_STATIC, _strRootDnsName);

   CStrW strVersion;
   _ForestVer.GetString(_ForestVer.GetVer(), strVersion);

   SetDlgItemText(_hDlg, IDC_CUR_VER_STATIC, strVersion);

   _ForestVer.SetDlgHwnd(_hDlg);

   if (_ForestVer.CanRaise())
   {
      InitCombobox();

      if (!_ForestVer.IsFsmoDcFound() || _ForestVer.IsReadOnly())
      {
         EnableWindow(GetDlgItem(_hDlg, IDOK), FALSE);
         CStrW strMsg;
         strMsg.LoadString(g_hInstance, _ForestVer.IsReadOnly() ?
                              IDS_FOREST_CANT_RAISE_ACCESS : IDS_FOREST_CANT_RAISE_FSMO);
         SetDlgItemText(_hDlg, IDC_CANT_RAISE_STATIC, strMsg);
      }
   }

   if (IDD_CANT_RAISE_FOREST == _nTemplateID)
   {
      CStrW strCantRaise;
      strCantRaise.LoadString(g_hInstance, IDS_FOR_CANT_RAISE_STATIC);
      SetDlgItemText(_hDlg, IDC_FOR_CANT_RAISE_STATIC, strCantRaise);
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnCommand
//
//  Synopsis:  Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CForestVersionDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   switch (codeNotify)
   {
   case BN_CLICKED:
      switch (id)
      {
      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      case IDC_HELP_BTN:
         // BUGBUG: need help topic URL.
         _ForestVer.ShowHelp(L"ADConcepts.chm::/ADHelpNewTrustIntro.htm", _hDlg);
         break;

      case IDC_SAVE_LOG:
         OnSaveLog();
         break;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnOK
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CForestVersionDlg::OnOK(void)
{
   UINT nVer = ReadComboSel();

   dspDebugOut((DEB_ITRACE, "Combobox selection was %d\n", nVer));

   if (FOREST_VER_ERROR == nVer)
   {
      // No user selection. Set one and return.
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
      return;
   }

   int iRet = IDCANCEL;
   CStrW strTitle, strMsg;
   strTitle.LoadString(g_hInstance, IDS_RAISE_FOR_VER_TITLE);
   strMsg.LoadString(g_hInstance, IDS_CONFIRM_FOR_RAISE);

   iRet = MessageBox(_hDlg, strMsg, strTitle, MB_OKCANCEL | MB_ICONEXCLAMATION);

   if (iRet == IDOK)
   {
      HRESULT hr = _ForestVer.RaiseVersion(nVer);

      if (SUCCEEDED(hr))
      {
         strMsg.LoadString(g_hInstance, IDS_MODE_CHANGED);
         MessageBox(_hDlg, strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
      }
      else
      {
         REPORT_ERROR_FORMAT(hr, IDS_VERSION_ERROR_FORMAT, _hDlg);
      }

      EndDialog(_hDlg, IDOK);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnHelp
//
//  Synopsis:  Put up popup help for the control.
//
//-----------------------------------------------------------------------------
/* LRESULT
CForestVersionDlg::OnHelp(LPHELPINFO pHelpInfo)
{
   if (!pHelpInfo)
   {
      dspAssert(FALSE);
      return 0;
   }
   dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

   if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
   {
      return 0;
   }
   WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

   return 0;
} */

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnSaveLog
//
//  Synopsis:  Prompts the user for a file name to save the DC log.
//
//-----------------------------------------------------------------------------
void
CForestVersionDlg::OnSaveLog(void)
{
   TRACE(CForestVersionDlg,OnSaveLog);
   HRESULT hr = S_OK;
   OPENFILENAME ofn = {0};
   WCHAR wzFilter[MAX_PATH + 1] = {0}, wzFileName[MAX_PATH + MAX_PATH + 1] = {0};
   CStrW strFilter, strExt, strMsg;
   CWaitCursor Wait;

   wcsncpy(wzFileName, _strRootDnsName, MAX_PATH + MAX_PATH);
   strExt.LoadString(g_hInstance, IDS_FTFILE_SUFFIX);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));
   wcsncat(wzFileName, L".", MAX_PATH + MAX_PATH - wcslen(wzFileName));
   strExt.LoadString(g_hInstance, IDS_FTFILE_CSV_EXT);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));

   LoadString(g_hInstance, IDS_FTFILE_FILTER, wzFilter, MAX_PATH);

   ofn.lStructSize = sizeof(ofn);
   ofn.hwndOwner = _hDlg;
   ofn.lpstrFile = wzFileName;
   ofn.nMaxFile = MAX_PATH + MAX_PATH + 1;
   ofn.Flags = OFN_OVERWRITEPROMPT;
   ofn.lpstrDefExt = strExt;
   ofn.lpstrFilter = wzFilter;

   if (GetSaveFileName(&ofn))
   {
      dspDebugOut((DEB_ITRACE, "Saving forest DC version info to %ws\n", ofn.lpstrFile));
      PWSTR pwzErr = NULL;
      BOOL fSucceeded = TRUE;

      HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0,
                                NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);

      if (INVALID_HANDLE_VALUE != hFile)
      {
         CStrW str;
         str.LoadString(g_hInstance, IDS_FOR_VER_LOG_PREFIX);
         strMsg.Format(str, _strRootDnsName);
         _ForestVer.GetString(_ForestVer.GetVer(), str);
         strMsg += str;
         strMsg += g_wzCRLF;
         strMsg += g_wzCRLF;
         str.LoadString(g_hInstance, IDS_FOR_VER_LOG_HDR);
         strMsg += str;
         strMsg += g_wzCRLF;

         hr = _ForestVer.BuildDcListString(strMsg);

         if (SUCCEEDED(hr))
         {
            strMsg += g_wzCRLF;
            strMsg += g_wzCRLF;
            str.LoadString(g_hInstance, IDS_FOR_VER_LOG_MODE_HDR);
            strMsg += str;
            strMsg += g_wzCRLF;

            hr = _ForestVer.BuildMixedModeList(strMsg);

            if (SUCCEEDED(hr))
            {
               strMsg += g_wzCRLF;

               DWORD dwWritten;

               fSucceeded = WriteFile(hFile, strMsg.GetBuffer(0),
                                      strMsg.GetLength() * sizeof(WCHAR),
                                      &dwWritten, NULL);
            }
         }
         CloseHandle(hFile);
      }
      else
      {
         fSucceeded = FALSE;
      }


      if (!fSucceeded || FAILED(hr))
      {
         CStrW strTitle;
         strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
         LoadErrorMessage(FAILED(hr) ? hr : GetLastError(), 0, &pwzErr);
         if (pwzErr)
         {
            strMsg.FormatMessage(g_hInstance, IDS_LOGFILE_CREATE_FAILED, pwzErr);
            delete [] pwzErr;
         }
         MessageBox(_hDlg, strMsg, strTitle, MB_ICONERROR);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::InitCombobox
//
//  Synopsis:  Fills the combobox with levels appropriate for the current
//             state.
//
//-----------------------------------------------------------------------------
void
CForestVersionDlg::InitCombobox(void)
{
   CStrW strVersion;

   switch (_ForestVer.GetVer())
   {
   case FOREST_VER_WIN2K:
   case FOREST_VER_XP_BETA:
      //
      // Can go to Whistler.
      //
      _ForestVer.GetString(FOREST_VER_XP, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 0,
                         (LPARAM)(PCWSTR)strVersion);
      break;

   case FOREST_VER_XP:
      break;

   default:
      dspAssert(FALSE);
      return;
   }

   SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::ReadComboSel
//
//  Synopsis:  Read the current selection of the combobox.
//
//  Notes:     Currently only one choice for the new version which is why the
//             value of lRet is not used.
//
//-----------------------------------------------------------------------------
UINT
CForestVersionDlg::ReadComboSel(void)
{
   LONG_PTR lRet = SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_GETCURSEL, 0, 0);

   if (CB_ERR == lRet)
   {
      return FOREST_VER_ERROR;
   }

   dspAssert(0 == lRet);

   return FOREST_VER_XP;
}

//+----------------------------------------------------------------------------
//
//  Class:     CForestVersion
//
//  Purpose:   Manages the interpretation of the forest version value.
//
//-----------------------------------------------------------------------------

CForestVersion::~CForestVersion(void)
{
   TRACE(CForestVersion,~CForestVersion);

   for (DOMAIN_LIST::iterator i = _DomainLogList.begin();
        i != _DomainLogList.end();
        ++i)
   {
      delete *i;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::Init
//
//  Synopsis:  Called from the Domain General property page. Use the local DC
//             to read the partitiona and schema paths.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::Init(PCWSTR pwzDC)
{
   TRACE(CForestVersion,Init);
   HRESULT hr = S_OK;
   CWaitCursor Wait;

   _strDC = pwzDC;

   CDSBasePathsInfo BasePaths;

   hr = BasePaths.InitFromName(_strDC);

   CHECK_HRESULT(hr, return hr);
   CSmartPtr<WCHAR> spwzPartitionsPath, spwzSchemaPath, spwzConfigPath;

   if (!BasePaths.GetPartitionsPath(&spwzPartitionsPath))
   {
      CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
   }

   _strPartitionsPath = spwzPartitionsPath;

   if (!BasePaths.GetConfigPath(&spwzConfigPath))
   {
      CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
   }

   _strConfigPath = spwzConfigPath;

   if (!BasePaths.GetSchemaPath(&spwzSchemaPath))
   {
      CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
   }

   hr = FindSchemaMasterReadVersion(spwzSchemaPath);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::Init
//
//  Synopsis:  Called from DSPROP_ForestVersionDlg.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::Init(PCWSTR pwzConfigPath, PCWSTR pwzPartitionsPath,
                     PCWSTR pwzSchemaPath)
{
   TRACE(CForestVersion,Init);
   CWaitCursor Wait;

   _strConfigPath = pwzConfigPath;
   _strPartitionsPath = pwzPartitionsPath;

   //
   // Save the local DC name in case the FSMO role holder is unavailable.
   //
   CPathCracker PathCrack;
   HRESULT hr = PathCrack.Set(_strConfigPath, ADS_SETTYPE_FULL);

   CHECK_HRESULT(hr, return hr);
   CComBSTR bstrDC;

   hr = PathCrack.Retrieve(ADS_FORMAT_SERVER, &bstrDC);

   CHECK_HRESULT(hr, return hr);

   _strDC = bstrDC;

   //
   // Locate the Schema FSMO role holder.
   //
   hr = FindSchemaMasterReadVersion(pwzSchemaPath);

   CHECK_HRESULT(hr, return hr);

   //
   // Check if the caller has write access.
   //

   CComPtr<IDirectoryObject> spPartitions;

   hr = ADsOpenObject(_strPartitionsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IDirectoryObject), (void **)&spPartitions);

   CHECK_HRESULT(hr, return hr);

   Smart_PADS_ATTR_INFO pAttrs;
   DWORD cAttrs = 0;
   PWSTR rgwzNames[] = {g_wzAllowed};

   hr = spPartitions->GetObjectAttributes(rgwzNames, ARRAYLENGTH(rgwzNames),
                                          &pAttrs, &cAttrs);

   if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, NULL))
   {
      return hr;
   }

   for (DWORD j = 0; cAttrs && j < pAttrs->dwNumValues; j++)
   {
      if (_wcsicmp(pAttrs->pADsValues[j].CaseIgnoreString, g_wzBehaviorVersion) == 0)
      {
         _fReadOnly = false;
         break;
      }
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::FindSchemaMasterReadVersion
//
//  Synopsis:  Discover which DC is the schema master by reading the
//             fSMORoleOwner attribute on the schema container. It lists the
//             nTDSDSA object for that DC. Strip off the nTDSDSA object CN,
//             bind to the Server object and read its dNSHostName value for
//             the name of the FSMO role holder DC.
//             Then using the DC bind to the partitions container to read the
//             forest version.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::FindSchemaMasterReadVersion(PCWSTR pwzSchemaPath)
{
   HRESULT hr = S_OK;
   CComPtr<IADs> spSchema;

   hr = ADsOpenObject(pwzSchemaPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IADs), (void **)&spSchema);

   CHECK_HRESULT(hr, return hr);
   CComVariant var;

   hr = spSchema->Get(L"fSMORoleOwner", &var);

   CHECK_HRESULT(hr, return hr);
   CComVariant varSrvDnsName;
   CComPtr<IADs> spServer;

   hr = ReadDnsSrvName(var.bstrVal, spServer, varSrvDnsName);

   CHECK_HRESULT(hr, return hr);
   CPathCracker PathCrack;

   hr = PathCrack.Set(_strPartitionsPath, ADS_SETTYPE_FULL);

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.Set(varSrvDnsName.bstrVal, ADS_SETTYPE_SERVER);

   CHECK_HRESULT(hr, return hr);
   CComBSTR bstrPartitionsPath;

   hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrPartitionsPath);

   CHECK_HRESULT(hr, return hr);

   CComPtr<IADs> spPartitions;

   hr = ADsOpenObject(bstrPartitionsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IADs), (void **)&spPartitions);
   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      //
      // Perhaps the FSMO holder is offline, try with the local DC.
      //
      hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrPartitionsPath);

      CHECK_HRESULT(hr, return hr);

      hr = ADsOpenObject(bstrPartitionsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                         __uuidof(IADs), (void **)&spPartitions);

      CHECK_HRESULT(hr, return hr);

      _fFsmoDcFound = false;
   }
   else
   {
      // Save the FSMO DC name.
      //
      _strDC = varSrvDnsName.bstrVal;

      // Set the server name on the saved paths to the new DC.
      //
      hr = PathCrack.Set(_strConfigPath, ADS_SETTYPE_FULL);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Set(varSrvDnsName.bstrVal, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);
      CComBSTR bstrConfigPath;

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrConfigPath);

      CHECK_HRESULT(hr, return hr);

      _strConfigPath = bstrConfigPath;
      _strPartitionsPath = bstrPartitionsPath;
   }

   CComVariant varVer;

   hr = spPartitions->Get(g_wzBehaviorVersion, &varVer);

   if (E_ADS_PROPERTY_NOT_FOUND == hr)
   {
      _nCurVer = FOREST_VER_WIN2K;
      hr = S_OK;
   }
   else
   {
      CHECK_HRESULT(hr, return hr);

      _nCurVer = varVer.lVal;
   }

   _fInitialized = true;

   dspDebugOut((DEB_ITRACE, "Forest version on %ws is %u\n",
                _strPartitionsPath.GetBuffer(0), _nCurVer));
   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::GetString
//
//  Synopsis:  Return the string representation of the behavior version.
//
//-----------------------------------------------------------------------------
bool
CForestVersion::GetString(UINT nVer, CStrW & strVer)
{
   UINT nID = 0;

   switch (nVer)
   {
   case FOREST_VER_WIN2K:
      nID = IDS_FOR_VER_W2K;
      break;

   case FOREST_VER_XP_BETA:
      nID = IDS_FOR_VER_XP_BETA;
      break;

   case FOREST_VER_XP:
      nID = IDS_FOR_VER_XP;
      break;

   default:
      dspAssert(FALSE);
      return false;
   }

   strVer.LoadString(g_hInstance, nID);

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::RaiseVersion
//
//  Synopsis:  Raise the forest behavior version.
//
//  Notes:     Currently only one choice for the new version which is why the
//             nVer parameter is not used.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::RaiseVersion(UINT nVer)
{
   TRACE(CForestVersion,RaiseVersion);
   UNREFERENCED_PARAMETER(nVer);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   HRESULT hr = S_OK;
   CComPtr<IADs> spPartitions;

   hr = ADsOpenObject(_strPartitionsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                      __uuidof(IADs), (void **)&spPartitions);

   CHECK_HRESULT(hr, return hr);
   CComVariant var;

   var.vt = VT_I4;
   var.lVal = FOREST_VER_XP;

   hr = spPartitions->Put(g_wzBehaviorVersion, var);

   CHECK_HRESULT(hr, return hr);

   hr = spPartitions->SetInfo();

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::CheckHighestPossible
//
//  Synopsis:  Enumerate all of the DCs to find the lowest version which thus
//             imposes a constraint on the highest version to which the forest
//             can be raised.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::CheckHighestPossible(void)
{
   TRACE(CForestVersion,CheckHighestPossible);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   if (IsHighest())
   {
      // We are already at the highest version, it can't be raised any further.
      //
      _fCanRaiseBehaviorVersion = false;
      return S_OK;
   }

   dspAssert(!_DcLogList.size());
   HRESULT hr = S_OK;
   CWaitCursor Wait;
   CPathCracker PathCrack;

   //
   // Search for the nTDSDSA objects.
   //
   hr = PathCrack.Set(_strConfigPath, ADS_SETTYPE_FULL);

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.AddLeafElement(L"CN=Sites");

   CHECK_HRESULT(hr, return hr);
   CComBSTR bstrSites;

   hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrSites);

   CHECK_HRESULT(hr, return hr);

   hr = EnumDsaObjs(bstrSites, NULL, NULL, DOMAIN_VER_XP_NATIVE);

   CHECK_HRESULT(hr, return hr);

   //
   // Check the domain versions.
   //
   hr = CheckDomainVersions(_strPartitionsPath);

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}

WCHAR wzNcName[] = L"nCName";
WCHAR wzFlags[] = L"systemFlags";
WCHAR wzDnsRoot[] = L"dnsRoot";

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::CheckDomainVersions
//
//  Synopsis:  Enumerate the domains and check the version and mode on each.
//             Build a list of mixed mode domains.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::CheckDomainVersions(PCWSTR pwzPartitionsPath)
{
   dspDebugOut((DEB_ITRACE, "Searching for crossRef objects under %ws\n",
                pwzPartitionsPath));
   CDSSearch Search;

   HRESULT hr = Search.Init(pwzPartitionsPath);

   CHECK_HRESULT(hr, return hr);
   PWSTR rgwzAttrs[] = {wzNcName, wzFlags, wzDnsRoot};

   Search.SetAttributeList(rgwzAttrs, ARRAYLENGTH(rgwzAttrs));

   hr = Search.SetSearchScope(ADS_SCOPE_SUBTREE);

   CHECK_HRESULT(hr, return hr);

   Search.SetFilterString(L"(objectCategory=crossRef)");

   hr = Search.DoQuery();

   CHECK_HRESULT(hr, return hr);
   CPathCracker PathCrack;

   while (SUCCEEDED(hr))
   {
      hr = Search.GetNextRow();

      if (hr == S_ADS_NOMORE_ROWS)
      {
         hr = S_OK;
         break;
      }

      CHECK_HRESULT(hr, return hr);
      ADS_SEARCH_COLUMN Column = {0};

      hr = Search.GetColumn(wzFlags, &Column);

      CHECK_HRESULT(hr, return hr);

      DWORD dwFlags = Column.pADsValues->Integer;

      Search.FreeColumn(&Column);

      if (!(FLAG_CR_NTDS_DOMAIN & dwFlags))
      {
         // Only domain cross-refs have the FLAG_CR_NTDS_DOMAIN bit set.
         //
         continue;
      }

      CStrW strNcName;

      hr = Search.GetColumn(wzNcName, &Column);

      CHECK_HRESULT(hr, return hr);

      strNcName = Column.pADsValues->CaseIgnoreString;

      Search.FreeColumn(&Column);

      hr = PathCrack.Set(strNcName, ADS_SETTYPE_DN);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);
      CComBSTR bstrDomain;

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrDomain);

      CHECK_HRESULT(hr, return hr);

      hr = Search.GetColumn(wzDnsRoot, &Column);

      CHECK_HRESULT(hr, return hr);
      CStrW strDnsDomainName;

      strDnsDomainName = Column.pADsValues->CaseIgnoreString;

      Search.FreeColumn(&Column);

      CComPtr<IADs> spDomain;
      CComVariant varMode, varVer;

      //
      // BUGBUG: when bug 159633 is implemented, then the domain mode attribute
      // will be reflected to the cross-ref obviating the need to visit each
      // domain-DNS object.
      //
      hr = ADsOpenObject(bstrDomain, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                         __uuidof(IADs), (void **)&spDomain);

      if (HRESULT_FROM_WIN32(ERROR_DS_REFERRAL) == hr)
      {
         // No DC is available for the domain. Thus can't tell if it is mixed
         // or native mode.
         //
         ErrMsgParam(IDS_FOR_ERR_NO_DC, (LPARAM)strDnsDomainName.GetBuffer(0),
                     GetDlgHwnd());

         CDomainListItem * pDomainItem = new CDomainListItem(strDnsDomainName,
                                                             DOMAIN_VER_UNKNOWN,
                                                             true);
         CHECK_NULL(pDomainItem, return E_OUTOFMEMORY);

         _DomainLogList.push_back(pDomainItem);

         _fCanRaiseBehaviorVersion = false;

         continue;
      }

      CHECK_HRESULT(hr, return hr);

      hr = spDomain->Get(g_wzBehaviorVersion, &varVer);

      if (E_ADS_PROPERTY_NOT_FOUND == hr)
      {
         // W2K domain won't have the behavior version attribute.
         //
         hr = S_OK;
         varVer.vt = VT_I4;
         varVer.lVal = 0;
      }

      CHECK_HRESULT(hr, return hr);

      if (varVer.lVal < DOMAIN_VER_XP_NATIVE)
      {
         hr = spDomain->Get(g_wzDomainMode, &varMode);

         CHECK_HRESULT(hr, return hr);
         dspAssert(VT_I4 == varMode.vt);

         if (varMode.lVal != 0)
         {
            // The domain is still in mixed mode, can't do a forest behavior
            // version upgrade.
            //
            CDomainListItem * pDomainItem = new CDomainListItem(strDnsDomainName,
                                                                varVer.lVal,
                                                                true);
            CHECK_NULL(pDomainItem, return E_OUTOFMEMORY);

            _DomainLogList.push_back(pDomainItem);

            _fCanRaiseBehaviorVersion = false;
         }
      }
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::BuildMixedModeList
//
//  Synopsis:  Build the display string for the log file.
//
//  Notes:     Using the domain object to get domain version strings. The
//             domain object does not need to be initialized in this case.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::BuildMixedModeList(CStrW & strList)
{
   CDomainVersion DomVer;

   for (DOMAIN_LIST::iterator i = _DomainLogList.begin();
        i != _DomainLogList.end();
        ++i)
   {
      strList += (*i)->GetDnsDomainName();

      strList += L"\t";

      CStrW strVer;

      DomVer.GetString((*i)->GetVer(), (*i)->GetMode(), strVer);

      strList += strVer;

      strList += g_wzCRLF;
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\ftinfo.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       ftinfo.cxx
//
//  Contents:   Domain trust support, forest trust name information.
//
//  History:    03-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include <stdio.h>
#include <lmerr.h>
#include <dnsapi.h>
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"

#ifdef DSADMIN

void FormatSID(PSID Sid, CStrW & str);

//+----------------------------------------------------------------------------
//
//  Class:     CFTInfo
//
//  Purpose:   Wrap an LSA_FOREST_TRUST_INFORMATION structure.
//
//-----------------------------------------------------------------------------

CFTInfo::CFTInfo(void) :
   _pFTInfo(NULL),
   _pExtraInfo(NULL)
{
   TRACER(CFTInfo,CFTInfo);
#ifdef _DEBUG
   strcpy(szClass, "CFTInfo");
#endif
}

CFTInfo::CFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo) :
   _pFTInfo(NULL),
   _pExtraInfo(NULL)
{
   TRACER(CFTInfo,CFTInfo pointer copy ctor);
#ifdef _DEBUG
   strcpy(szClass, "CFTInfo");
#endif

   bool fOK = SetFTInfo(pFTInfo);
   dspAssert(fOK);
}

CFTInfo::CFTInfo(CFTInfo & FTInfo) :
   _pFTInfo(NULL),
   _pExtraInfo(NULL)
{
   TRACER(CFTInfo,CFTInfo obj copy ctor);
#ifdef _DEBUG
   strcpy(szClass, "CFTInfo");
#endif

   bool fOK = SetFTInfo(FTInfo.GetFTInfo());
   dspAssert(fOK);
}

CFTInfo::~CFTInfo(void)
{
   DeleteFTInfo();
}

const CFTInfo &
CFTInfo::operator= (const PLSA_FOREST_TRUST_INFORMATION pFTInfo)
{
   bool fOK = SetFTInfo(pFTInfo);
   dspAssert(fOK);
   return *this;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetFTInfo
//
//  Synopsis:  Copy the FTInfo data.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo)
{
   TRACER(CFTInfo,SetFTInfo);
   dspAssert(pFTInfo);
   if (!pFTInfo)
   {
      return false;
   }

   DeleteFTInfo();

   _pFTInfo = new LSA_FOREST_TRUST_INFORMATION;

   CHECK_NULL(_pFTInfo, return false);

   ZeroMemory(_pFTInfo, sizeof(LSA_FOREST_TRUST_INFORMATION));

   if (!pFTInfo->RecordCount)
   {
      DBG_OUT("RecordCount is zero.\n");
      return true;
   }
   dspDebugOut((DEB_ITRACE, "RecordCount is %d\n", pFTInfo->RecordCount));

   _pFTInfo->Entries = new PLSA_FOREST_TRUST_RECORD[pFTInfo->RecordCount];

   CHECK_NULL(_pFTInfo->Entries, return false);

   ZeroMemory(_pFTInfo->Entries, sizeof(PLSA_FOREST_TRUST_RECORD) * pFTInfo->RecordCount);

   PWSTR pwz = NULL;
   size_t cch = 0;

   for (ULONG i = 0; i < pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = pFTInfo->Entries[i], pCopyRec;
      dspAssert(pRec);

      _pFTInfo->Entries[i] = pCopyRec = new LSA_FOREST_TRUST_RECORD;

      CHECK_NULL(pCopyRec, return false);

      ZeroMemory(pCopyRec, sizeof(LSA_FOREST_TRUST_RECORD));

      _pFTInfo->RecordCount++;
      pCopyRec->ForestTrustType = pRec->ForestTrustType;
      pCopyRec->Flags = pRec->Flags;
      pCopyRec->Time = pRec->Time;

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
      case ForestTrustTopLevelNameEx:
         cch = pRec->ForestTrustData.TopLevelName.Length / sizeof(WCHAR);
         pwz = new WCHAR[cch + 1];
         CHECK_NULL(pwz, return false);
         wcsncpy(pwz, pRec->ForestTrustData.TopLevelName.Buffer, cch);
         pwz[cch] = L'\0';
         RtlInitUnicodeString(&pCopyRec->ForestTrustData.TopLevelName, pwz);
         dspDebugOut((DEB_USER1, "%s: %ws, Flags 0x%x\n",
                      (ForestTrustTopLevelName == pCopyRec->ForestTrustType) ?
                      "ForestTrustTopLevelName" : "ForestTrustTopLevelNameEx",
                      pwz, pCopyRec->Flags));
         break;

      case ForestTrustDomainInfo:
         cch = pRec->ForestTrustData.DomainInfo.DnsName.Length / sizeof(WCHAR);
         pwz = new WCHAR[cch + 1];
         CHECK_NULL(pwz, return false);
         wcsncpy(pwz, pRec->ForestTrustData.DomainInfo.DnsName.Buffer, cch);
         pwz[cch] = L'\0';
         RtlInitUnicodeString(&pCopyRec->ForestTrustData.DomainInfo.DnsName, pwz);
         dspDebugOut((DEB_USER1, "ForestTrustDomainInfo: %ws, Flags 0x%x\n",
                     pwz, pCopyRec->Flags));

         cch = pRec->ForestTrustData.DomainInfo.NetbiosName.Length / sizeof(WCHAR);
         pwz = new WCHAR[cch + 1];
         CHECK_NULL(pwz, return false);
         wcsncpy(pwz, pRec->ForestTrustData.DomainInfo.NetbiosName.Buffer, cch);
         pwz[cch] = L'\0';
         RtlInitUnicodeString(&pCopyRec->ForestTrustData.DomainInfo.NetbiosName, pwz);

         pCopyRec->ForestTrustData.DomainInfo.Sid = new BYTE[GetLengthSid(pRec->ForestTrustData.DomainInfo.Sid)];
         CHECK_NULL(pCopyRec->ForestTrustData.DomainInfo.Sid, return false);
         CopyMemory(pCopyRec->ForestTrustData.DomainInfo.Sid,
                    pRec->ForestTrustData.DomainInfo.Sid,
                    GetLengthSid(pRec->ForestTrustData.DomainInfo.Sid));
         break;

      default:
         pCopyRec->ForestTrustData.Data.Buffer = new UCHAR[pRec->ForestTrustData.Data.Length];
         CHECK_NULL(pCopyRec->ForestTrustData.Data.Buffer, return false);
         CopyMemory(pCopyRec->ForestTrustData.Data.Buffer,
                    pRec->ForestTrustData.Data.Buffer,
                    pRec->ForestTrustData.Data.Length);
         dspDebugOut((DEB_USER1, "Unknown type: Flags 0x%x\n", pCopyRec->Flags));
         break;
      }
   }

   _pExtraInfo = new FT_EXTRA_INFO[pFTInfo->RecordCount];

   CHECK_NULL(_pExtraInfo, return false);

   SetDomainState();

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::AddNewExclusion
//
//-----------------------------------------------------------------------------
bool
CFTInfo::AddNewExclusion(PCWSTR pwzName, ULONG & NewIndex)
{
   if (!_pFTInfo || !pwzName || wcslen(pwzName) < 3) // to be subordinate to something requires at least 3 chars.
   {
      dspAssert(FALSE);
      return false;
   }
   dspDebugOut((DEB_ITRACE, "CFTInfo::AddNewExclusion for name %ws\n", pwzName));

   PLSA_FOREST_TRUST_RECORD * rgpNewEntries;
   ULONG nEntries = _pFTInfo->RecordCount;

   rgpNewEntries = new PLSA_FOREST_TRUST_RECORD[nEntries + 1];

   CHECK_NULL(rgpNewEntries, return false);

   ZeroMemory(rgpNewEntries, sizeof(PLSA_FOREST_TRUST_RECORD) * (nEntries + 1));
   CopyMemory(rgpNewEntries, _pFTInfo->Entries, nEntries * sizeof(PLSA_FOREST_TRUST_RECORD));

   rgpNewEntries[nEntries] = new LSA_FOREST_TRUST_RECORD;

   CHECK_NULL(rgpNewEntries[nEntries], return false);

   FT_EXTRA_INFO * pNewExtraInfo = new FT_EXTRA_INFO[nEntries + 1];

   CHECK_NULL(pNewExtraInfo, return false);

   // Flags and Time both implicitly set to zero.
   //
   ZeroMemory(rgpNewEntries[nEntries], sizeof(LSA_FOREST_TRUST_RECORD));

   _pFTInfo->RecordCount++;

   rgpNewEntries[nEntries]->ForestTrustType = ForestTrustTopLevelNameEx;

   PWSTR pwz = new WCHAR[wcslen(pwzName) + 1];
   CHECK_NULL(pwz, return false);
   wcscpy(pwz, pwzName);

   RtlInitUnicodeString(&rgpNewEntries[nEntries]->ForestTrustData.TopLevelName,
                        pwz);

   delete [] _pFTInfo->Entries;

   _pFTInfo->Entries = rgpNewEntries;

   NewIndex = nEntries;

   ZeroMemory(pNewExtraInfo, (nEntries + 1) * sizeof(FT_EXTRA_INFO));
   dspAssert(_pExtraInfo);
   CopyMemory(pNewExtraInfo, _pExtraInfo, nEntries * sizeof(FT_EXTRA_INFO));

   delete [] _pExtraInfo;

   _pExtraInfo = pNewExtraInfo;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::RemoveExclusion
//
//-----------------------------------------------------------------------------
bool
CFTInfo::RemoveExclusion(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }
   PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[index];

   if (ForestTrustTopLevelNameEx != pRec->ForestTrustType)
   {
      dspAssert(FALSE);
      return false;
   }

   delete [] pRec->ForestTrustData.TopLevelName.Buffer;

   delete pRec;

   for (ULONG i = index; i < _pFTInfo->RecordCount - 1; i++)
   {
      _pFTInfo->Entries[i] = _pFTInfo->Entries[i + 1];
   }

   _pFTInfo->RecordCount--;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::DeleteFTInfo
//
//-----------------------------------------------------------------------------
void
CFTInfo::DeleteFTInfo(void)
{
   if (!_pFTInfo)
   {
      return;
   }

   PLSA_FOREST_TRUST_INFORMATION pFTInfo = _pFTInfo;

   _pFTInfo = NULL;

   for (ULONG i = 0; i < pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = pFTInfo->Entries[i];

      if (!pRec)
      {
         return;
      }

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
      case ForestTrustTopLevelNameEx:
         if (pRec->ForestTrustData.DomainInfo.DnsName.Buffer)
         {
            delete [] pRec->ForestTrustData.DomainInfo.DnsName.Buffer;
         }
         break;

      case ForestTrustDomainInfo:
         if (pRec->ForestTrustData.DomainInfo.DnsName.Buffer)
         {
            delete [] pRec->ForestTrustData.DomainInfo.DnsName.Buffer;
         }
         if (pRec->ForestTrustData.DomainInfo.NetbiosName.Buffer)
         {
            delete [] pRec->ForestTrustData.DomainInfo.NetbiosName.Buffer;
         }
         if (pRec->ForestTrustData.DomainInfo.Sid)
         {
            delete [] pRec->ForestTrustData.DomainInfo.Sid;
         }
         break;

      default:
         if (pRec->ForestTrustData.Data.Buffer)
         {
            delete [] pRec->ForestTrustData.Data.Buffer;
         }
         break;
      }

      delete pRec;
   }

   delete [] pFTInfo->Entries;

   delete pFTInfo;

   if (_pExtraInfo)
   {
      delete [] _pExtraInfo;
      _pExtraInfo = NULL;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetIndex
//
//  Synopsis:  Return the index that matches the passed in name.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetIndex(PCWSTR pwzName, ULONG & index)
{
   if (!_pFTInfo || !pwzName)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strName;

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[i];

      dspAssert(pFTRec);

      switch (pFTRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
      case ForestTrustTopLevelNameEx:
         strName = pFTRec->ForestTrustData.TopLevelName;
         break;

      case ForestTrustDomainInfo:
         strName = pFTRec->ForestTrustData.DomainInfo.DnsName;
         break;

      default:
         dspAssert(FALSE);
         break;
      }

      if (!strName.IsEmpty())
      {
         if (wcscmp(strName, pwzName) == 0)
         {
            index = i;
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::FindSID
//
//  Synopsis:  Return the index if the passed in string SID is found.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::FindSID(PCWSTR pwzSID, ULONG & index)
{
   if (!_pFTInfo || !pwzSID)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strSID;

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];

      dspAssert(pRec);

      if (ForestTrustDomainInfo == pRec->ForestTrustType)
      {
         FormatSID(pRec->ForestTrustData.DomainInfo.Sid, strSID);

         if (!strSID.IsEmpty())
         {
            if (strSID.CompareNoCase(pwzSID) == 0)
            {
               index = i;
               return true;
            }
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsDomainMatch
//
//  Synopsis:  Is there a domain whose name matches the passed-in TLNEx?
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsDomainMatch(ULONG index)
{
   if (!_pFTInfo)
   {
      dspAssert(FALSE);
      return false;
   }

   LSA_FOREST_TRUST_RECORD_TYPE type;

   if (!GetType(index, type))
   {
      dspAssert(FALSE);
      return false;
   }

   if (ForestTrustTopLevelNameEx != type)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTlnEx, strDomain;

   if (!GetDnsName(index, strTlnEx))
   {
      dspAssert(FALSE);
      return false;
   }

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];

      dspAssert(pRec);

      if (ForestTrustDomainInfo == pRec->ForestTrustType)
      {
         strDomain = pRec->ForestTrustData.DomainInfo.DnsName;

         if (strDomain.CompareNoCase(strTlnEx) == 0)
         {
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetDnsName
//
//  Synopsis:  Return the name for the passed in index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetDnsName(ULONG index, CStrW & strName)
{
   strName.Empty();

   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
   case ForestTrustTopLevelNameEx:
      strName = pFTRec->ForestTrustData.TopLevelName;
      return true;

   case ForestTrustDomainInfo:
      strName = pFTRec->ForestTrustData.DomainInfo.DnsName;
      return true;

   default:
      dspAssert(FALSE);
      break;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetNbName
//
//  Synopsis:  Return the NetBIOS name for the passed in index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetNbName(ULONG index, CStrW & strName)
{
   strName.Empty();

   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   if (ForestTrustDomainInfo == pFTRec->ForestTrustType)
   {
      strName = pFTRec->ForestTrustData.DomainInfo.NetbiosName;
      return true;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetType
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetType(ULONG index, LSA_FOREST_TRUST_RECORD_TYPE & type)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   type = _pFTInfo->Entries[index]->ForestTrustType;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetFlags
//
//-----------------------------------------------------------------------------
ULONG
CFTInfo::GetFlags(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return 0;
   }

   return _pFTInfo->Entries[index]->Flags;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetDomainState
//
//  Synopsis:  Set the extra-info flags to indicate status based on relation-
//             ships between TLN exclusion records and domain records..
//
//-----------------------------------------------------------------------------
void
CFTInfo::SetDomainState(void)
{
   if (!_pFTInfo)
   {
      return;
   }

   LSA_FOREST_TRUST_RECORD_TYPE type;

   for (ULONG iTLNEx = 0; iTLNEx < _pFTInfo->RecordCount; iTLNEx++)
   {
      // Scan FTInfos for TLNEx records.
      //
      if (IsTlnExclusion(iTLNEx))
      {
         CStrW strTLNEx;

         if (!GetDnsName(iTLNEx, strTLNEx))
         {
            dspAssert(FALSE);
            continue;
         }
         // Search for a matching domain record.
         //
         for (ULONG jDomain = 0; jDomain < _pFTInfo->RecordCount; jDomain++)
         {
            if (!GetType(jDomain, type))
            {
               dspAssert(FALSE);
               continue;
            }
            if (ForestTrustDomainInfo != type)
            {
               continue;
            }
            CStrW strDNS;

            if (!GetDnsName(jDomain, strDNS))
            {
               dspAssert(FALSE);
               continue;
            }

            if (strTLNEx == strDNS)
            {
               // If there is a matching domain record, mark it as
               // disabled-via-matching-TLNEx in the extra info.
               //
               _pExtraInfo[jDomain]._Status = FT_EXTRA_INFO::STATUS::DisabledViaMatchingTLNEx;

               // Set the status on the TLNEx as well.
               //
               _pExtraInfo[iTLNEx]._Status = FT_EXTRA_INFO::STATUS::TLNExMatchesExistingDomain;

               // Search for children of the domain and mark each as
               // disabled-via-parent-matching-TLNEx in the extra info.
               //
               for (ULONG kChild = 0; kChild < _pFTInfo->RecordCount; kChild++)
               {
                  if (kChild == jDomain || kChild == iTLNEx)
                  {
                     continue;
                  }
                  if (IsChildDomain(jDomain, kChild))
                  {
                     _pExtraInfo[kChild]._Status = FT_EXTRA_INFO::STATUS::DisabledViaParentMatchingTLNEx;
                  }
               }
               // Only one domain record can match the exclusion.
               //
               break;
            }
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsInConflict
//
//  Synopsis:  Are any of the FTInfo records in confict.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsInConflict(void)
{
   if (!_pFTInfo)
   {
      return false;
   }

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      if (IsConflictFlagSet(i))
      {
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsConflictFlagSet
//
//  Synopsis:  Is the FTInfo record in confict.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsConflictFlagSet(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      if (LSA_TLN_DISABLED_CONFLICT & pFTRec->Flags)
      {
         return true;
      }
      break;

   case ForestTrustDomainInfo:
      if (LSA_SID_DISABLED_CONFLICT & pFTRec->Flags ||
          LSA_NB_DISABLED_CONFLICT & pFTRec->Flags)
      {
         return true;
      }
      break;

   default:
      break;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetAdminDisable
//
//  Synopsis:  Admin-disables the name. Returns false if not a name record.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetAdminDisable(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      pFTRec->Flags = LSA_TLN_DISABLED_ADMIN;
      break;

   case ForestTrustDomainInfo:
      pFTRec->Flags = LSA_NB_DISABLED_ADMIN;
      break;

   default:
      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetConflictDisable
//
//  Synopsis:  Sets the conflict-disabled flag. Returns false if not a name record.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetConflictDisable(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      pFTRec->Flags = LSA_TLN_DISABLED_CONFLICT;
      break;

   case ForestTrustDomainInfo:
      pFTRec->Flags = LSA_NB_DISABLED_CONFLICT;
      break;

   default:
      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetSidAdminDisable
//
//  Synopsis:  Admin-disables the SID, returns false if not a domain record.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetSidAdminDisable(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   if (!pFTRec || ForestTrustDomainInfo != pFTRec->ForestTrustType)
   {
      dspAssert(FALSE);
      return false;
   }

   pFTRec->Flags = LSA_SID_DISABLED_ADMIN;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsEnabled
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsEnabled(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustDomainInfo:
      if (FT_EXTRA_INFO::STATUS::Enabled == _pExtraInfo[index]._Status)
      {
         return true;
      }
      break;

   case ForestTrustTopLevelName:
      if (!(pFTRec->Flags & (LSA_TLN_DISABLED_NEW | LSA_TLN_DISABLED_ADMIN | LSA_TLN_DISABLED_CONFLICT)))
      {
         return true;
      }
      break;

   default:
      break;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::DisableDomain
//
//  Synopsis:  Disable a domain subtree rooted at the domain named by index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::DisableDomain(ULONG index)
{
   TRACER(CFTInfo,DisableDomain);
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   if (ForestTrustDomainInfo != _pFTInfo->Entries[index]->ForestTrustType)
   {
      dspAssert(false);
      return false;
   }

   CStrW strDomainName;

   if (!GetDnsName(index, strDomainName))
   {
      dspAssert(false);
      return false;
   }

   // Add an exclusion record for the domain's DNS name.
   //
   ULONG iNewTLNEx;

   if (!AddNewExclusion(strDomainName, iNewTLNEx))
   {
      dspAssert(false);
      return false;
   }

   _pExtraInfo[iNewTLNEx]._Status = FT_EXTRA_INFO::STATUS::TLNExMatchesExistingDomain;

   // Mark the domain and all of its children as disabled.
   //
   _pExtraInfo[index]._Status = FT_EXTRA_INFO::STATUS::DisabledViaMatchingTLNEx;

   for (ULONG j = 0; j < _pFTInfo->RecordCount; j++)
   {
      if (j == index || j == iNewTLNEx)
      {
         continue;
      }

      if (IsChildDomain(index, j))
      {
         _pExtraInfo[j]._Status = FT_EXTRA_INFO::STATUS::DisabledViaParentMatchingTLNEx;
      }
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::EnableDomain
//
//  Synopsis:  Enable a domain subtree rooted at the domain named by index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::EnableDomain(ULONG index)
{
   TRACER(CFTInfo,EnableDomain);
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   if (ForestTrustDomainInfo != _pFTInfo->Entries[index]->ForestTrustType)
   {
      dspAssert(false);
      return false;
   }

   // Remove the exclusion record.
   //
   ULONG iExclusion;

   if (!FindMatchingExclusion(index, iExclusion))
   {
      dspAssert(false);
      return false;
   }

   if (!RemoveExclusion(iExclusion))
   {
      dspAssert(false);
      return false;
   }

   // Mark the domain and all of its children as enabled.
   //
   _pExtraInfo[index]._Status = FT_EXTRA_INFO::STATUS::Enabled;

   for (ULONG j = 0; j < _pFTInfo->RecordCount; j++)
   {
      if (j == index || j == iExclusion)
      {
         continue;
      }

      if (IsChildDomain(index, j))
      {
         _pExtraInfo[j]._Status = FT_EXTRA_INFO::STATUS::Enabled;
      }
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetUsedToBeInConflict
//
//-----------------------------------------------------------------------------
void
CFTInfo::SetUsedToBeInConflict(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return;
   }

   _pExtraInfo[index]._fWasInConflict = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::WasInConflict
//
//-----------------------------------------------------------------------------
bool
CFTInfo::WasInConflict(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return false;
   }

   return _pExtraInfo[index]._fWasInConflict;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::ClearAnyConflict
//
//-----------------------------------------------------------------------------
void
CFTInfo::ClearAnyConflict(void)
{
   if (!_pFTInfo)
   {
      dspAssert(FALSE);
      return;
   }

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      ClearConflict(i);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::ClearConflict
//
//-----------------------------------------------------------------------------
void
CFTInfo::ClearConflict(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      if (LSA_TLN_DISABLED_CONFLICT & pFTRec->Flags)
      {
         pFTRec->Flags &= ~(LSA_TLN_DISABLED_CONFLICT);
      }
      break;

   case ForestTrustDomainInfo:
      if (LSA_SID_DISABLED_CONFLICT & pFTRec->Flags)
      {
         pFTRec->Flags &= ~(LSA_SID_DISABLED_CONFLICT);
      }
      if (LSA_NB_DISABLED_CONFLICT & pFTRec->Flags)
      {
         pFTRec->Flags &= ~(LSA_NB_DISABLED_CONFLICT);
      }
      break;

   default:
      break;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::ClearDisableFlags
//
//-----------------------------------------------------------------------------
void
CFTInfo::ClearDisableFlags(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   pFTRec->Flags = 0;

   if (_pExtraInfo)
   {
      _pExtraInfo[index]._fWasInConflict = false;
   }

   return;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::AnyChildDisabled
//
//  Synopsis:  Are any matching or child domain names disabled.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::AnyChildDisabled(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount ||
       _pFTInfo->Entries[index]->ForestTrustType != ForestTrustTopLevelName)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTLN, strDNS;

   GetDnsName(index, strTLN);

   dspAssert(!strTLN.IsEmpty());

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];
      dspAssert(pRec);

      strDNS.Empty();

      // See if any subordinate names are disabled.
      //
      if (pRec->ForestTrustType == ForestTrustTopLevelName)
      {
         // No need to check the passed in or other TLNs.
         //
         continue;
      }

      bool fIsException = false;

      switch (pRec->ForestTrustType)
      {
         case ForestTrustDomainInfo:
            strDNS = pRec->ForestTrustData.DomainInfo.DnsName;
            break;

         case ForestTrustTopLevelNameEx:
            strDNS = pRec->ForestTrustData.TopLevelName;
            fIsException = true;
            break;

         default:
            continue;
      }

      if (!strDNS.IsEmpty())
      {
         DNS_NAME_COMPARE_STATUS compare;

         compare = DnsNameCompareEx_W(strDNS, strTLN, 0);

         if ((DnsNameCompareRightParent == compare ||
              DnsNameCompareEqual == compare) &&
             (fIsException || pRec->Flags))
         {
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsTlnExclusion
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsTlnExclusion(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   return _pFTInfo->Entries[index]->ForestTrustType == ForestTrustTopLevelNameEx;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::FindMatchingExclusion
//
//  Synopsis:  Search for an exclusion record that matches the indicated
//             record. If CheckParents is true, will look for parent matches.
//             CheckParents defaults to false.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::FindMatchingExclusion(ULONG index, ULONG & iExclusion, bool CheckParents)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   LSA_FOREST_TRUST_RECORD_TYPE type;

   if (!GetType(index, type) || ForestTrustDomainInfo != type)
   {
      dspAssert(false);
      return false;
   }

   CStrW strDomain, strExclusion;

   if (!GetDnsName(index, strDomain))
   {
      dspAssert(false);
      return false;
   }

   for (ULONG j = 0; j < _pFTInfo->RecordCount; j++)
   {
      if (!GetType(j, type))
      {
         dspAssert(false);
         return false;
      }

      if (ForestTrustTopLevelNameEx != type)
      {
         continue;
      }

      if (!GetDnsName(j, strExclusion))
      {
         dspAssert(false);
         return false;
      }

      if (strDomain == strExclusion)
      {
         iExclusion = j;
         return true;
      }

      if (CheckParents && (DnsNameCompareEx_W(strDomain, strExclusion, 0) == DnsNameCompareRightParent))
      {
         iExclusion = j;
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsMatchingDomain
//
//  Synopsis:  Is the name of 'index' the domain with the same name as the
//             top level name iTLN.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsMatchingDomain(ULONG iTLN, ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   if (iTLN == index)
   {
      return false;
   }

   if (ForestTrustTopLevelName != _pFTInfo->Entries[iTLN]->ForestTrustType ||
       ForestTrustDomainInfo != _pFTInfo->Entries[index]->ForestTrustType)
   {
      return false;
   }

   CStrW strTLN, strDomain;

   if (!GetDnsName(iTLN, strTLN))
   {
      dspAssert(FALSE);
      return false;
   }

   if (!GetDnsName(index, strDomain))
   {
      dspAssert(FALSE);
      return false;
   }

   if (strTLN == strDomain)
   {
      return true;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsChildDomain
//
//  Synopsis:  Is the name of 'index' a child of the iParent DNS names.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsChildDomain(ULONG iParent, ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strName;

   if (!GetDnsName(index, strName))
   {
      return false;
   }

   return IsChildName(iParent, strName);
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsChildName
//
//  Synopsis:  Is the name pwzName a child of the iParent DNS names.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsChildName(ULONG iParent, PCWSTR pwzName)
{
   if (!_pFTInfo || iParent >= _pFTInfo->RecordCount || !pwzName)
   {
      dspAssert(FALSE);
      return false;
   }

   if (wcslen(pwzName) < 3)
   {
      return false;
   }

   CStrW strParent;

   if (!GetDnsName(iParent, strParent))
   {
      return false;
   }

   return DnsNameCompareEx_W(strParent, pwzName, 0) == DnsNameCompareLeftParent;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsNameTLNExChild
//
//  Synopsis:  Is the name a child of a TLN exclusion.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsNameTLNExChild(PCWSTR pwzName)
{
   if (!_pFTInfo || !pwzName || wcslen(pwzName) < 3)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTLNEx;

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      if (ForestTrustTopLevelNameEx == _pFTInfo->Entries[i]->ForestTrustType)
      {
         if (!GetDnsName(i, strTLNEx))
         {
            dspAssert(FALSE);
            return false;
         }
         if (DnsNameCompareEx_W(strTLNEx, pwzName, 0) == DnsNameCompareLeftParent)
         {
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsParentDisabled
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsParentDisabled(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTLN, strDNS;

   GetDnsName(index, strDNS);

   dspAssert(!strDNS.IsEmpty());

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];
      dspAssert(pRec);

      if (pRec->ForestTrustType != ForestTrustTopLevelName)
      {
         // Check only TLNs.
         //
         continue;
      }

      strTLN = pRec->ForestTrustData.TopLevelName;

      if (DnsNameCompareEx_W(strDNS, strTLN, 0) == DnsNameCompareRightParent &&
          pRec->Flags)
      {
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetExtraStatus
//
//  Synopsis:  Return the extra-info status of the item.
//
//-----------------------------------------------------------------------------
FT_EXTRA_INFO::STATUS
CFTInfo::GetExtraStatus(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return FT_EXTRA_INFO::STATUS::Invalid;
   }

   return _pExtraInfo[index]._Status;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetTlnEditStatus
//
//  Synopsis:  Return the routing status of the item.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetTlnEditStatus(ULONG index, TLN_EDIT_STATUS & status)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   status = Enabled;

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      if (pFTRec->Flags)
      {
         status = Disabled;
      }
      break;

   case ForestTrustDomainInfo:
      //
      // Find the parent. If the parent is disabled, then so is this DNS name.
      //
      if (IsParentDisabled(index))
      {
         status = Disabled;
      }
      else
      {
         switch (pFTRec->Flags)
         {
         case LSA_SID_DISABLED_ADMIN:
         case LSA_SID_DISABLED_CONFLICT:
            //
            // The SID is disabled but the NB name is enabled. The DNS
            // name is disabled by virtue of the SID being disabled. NB
            // names will still route though.
            //
            status = Disabled_Exceptions;
            break;

         case LSA_NB_DISABLED_ADMIN:
         case LSA_NB_DISABLED_CONFLICT:
            //
            // SID enabled means DNS name enabled. Only NB names disabled.
            //
            status = Enabled_Exceptions;
            break;

         case LSA_SID_DISABLED_ADMIN | LSA_NB_DISABLED_ADMIN:
         case LSA_SID_DISABLED_CONFLICT | LSA_NB_DISABLED_ADMIN:
         case LSA_SID_DISABLED_ADMIN | LSA_NB_DISABLED_CONFLICT:
         case LSA_SID_DISABLED_CONFLICT | LSA_NB_DISABLED_CONFLICT:
            //
            // If both NB and SID disabled, then no routing.
            //
            status = Disabled;
            break;

         default:
            // already enabled above.
            break;
         }
      }
      break;

   default:
      break;
   }
   return true;
}


//+----------------------------------------------------------------------------
//
//  Class:     CFTCollisionInfo
//
//  Purpose:   Encapsulate the forest trust naming information.
//
//-----------------------------------------------------------------------------

CFTCollisionInfo::CFTCollisionInfo(void) :
   _pFTCollisionInfo(NULL)
{
   TRACER(CFTCollisionInfo,CFTCollisionInfo);
#ifdef _DEBUG
   strcpy(szClass, "CFTCollisionInfo");
#endif
}

CFTCollisionInfo::CFTCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo) :
   _pFTCollisionInfo(NULL)
{
   TRACER(CFTCollisionInfo,CFTCollisionInfo);
#ifdef _DEBUG
   strcpy(szClass, "CFTCollisionInfo");
#endif

   SetCollisionInfo(pColInfo);
}

CFTCollisionInfo::~CFTCollisionInfo(void)
{
   if (_pFTCollisionInfo)
   {
      // The collision info is allocated by LsaSetForestTrustInformation
      //
      LsaFreeMemory(_pFTCollisionInfo);
   }
}

const CFTCollisionInfo &
CFTCollisionInfo::operator = (const PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo)
{
   SetCollisionInfo(pColInfo);
   return *this;
}

void
CFTCollisionInfo::SetCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo)
{
   TRACER(CFTCollisionInfo,SetCollisionInfo);
   if (_pFTCollisionInfo)
   {
      // The collision info is allocated by LsaSetForestTrustInformation
      //
      LsaFreeMemory(_pFTCollisionInfo);
   }
   _pFTCollisionInfo = pColInfo;
#if DBG
   if (_pFTCollisionInfo)
   {
      dspDebugOut((DEB_ITRACE, "pCollisionInfo->RecordCount = %d\n",
                   _pFTCollisionInfo->RecordCount));
   }
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTCollisionInfo::IsInCollisionInfo
//
//  Synopsis:  Is the FTRecord index found on a collision record?
//
//-----------------------------------------------------------------------------
bool
CFTCollisionInfo::IsInCollisionInfo(ULONG index)
{
   if (!_pFTCollisionInfo)
   {
      return false;
   }

   for (ULONG i = 0; i < _pFTCollisionInfo->RecordCount; i++)
   {
      if (_pFTCollisionInfo->Entries[i]->Index == index)
      {
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTCollisionInfo::GetCollisionName
//
//  Synopsis:  Return the name of the source of the collision.
//
//-----------------------------------------------------------------------------
bool
CFTCollisionInfo::GetCollisionName(ULONG index, CStrW & strName)
{
   strName.Empty();

   if (!_pFTCollisionInfo)
   {
      return false;
   }

   for (ULONG i = 0; i < _pFTCollisionInfo->RecordCount; i++)
   {
      if (_pFTCollisionInfo->Entries[i]->Index == index)
      {
         strName = _pFTCollisionInfo->Entries[i]->Name;
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Function:  ComposeLineTabSep
//
//  Synopsis:  Format a line of tab-separated-values.
//
//  D&Ts Write-to-File functionality uses tabs as delimiters because
//  Excel treats unicode CSV files as unknown format but it will
//  nevertheless properly parse fields separated by tabs (but not commas).
//
//  ulLineNum is ignored.
//
//-----------------------------------------------------------------------------
void
ComposeLineTabSep(CStrW & strOut, ULONG ulLineNum, PCWSTR pwzCol1,
                  PCWSTR pwzCol2, PCWSTR pwzCol3, PCWSTR pwzCol4)
{
   dspAssert(pwzCol1 && pwzCol2);

   strOut += pwzCol1;
   strOut += L"\t";
   strOut += pwzCol2;
   if (pwzCol3 && *pwzCol3)
   {
      strOut += L"\t";
      strOut += pwzCol3;
   }
   if (pwzCol4 && *pwzCol4)
   {
      strOut += L"\t";
      strOut += pwzCol4;
   }
   strOut += g_wzCRLF;
}

//+----------------------------------------------------------------------------
//
//  Function:  ComposeNumberedLine
//
//  Synopsis:  Format a line of comma-separated-values.
//
//  Used by netdom to list names to stdout.
//
//-----------------------------------------------------------------------------
void
ComposeNumberedLine(CStrW & strOut, ULONG ulLineNum, PCWSTR pwzCol1,
                    PCWSTR pwzCol2, PCWSTR pwzCol3, PCWSTR pwzCol4)
{
   dspAssert(pwzCol1 && pwzCol2);

   if (ulLineNum > 0)
   {
      CStrW strNumber;
      strNumber.Format(L"%d. ", ulLineNum);
      strOut += strNumber;
   }
   else
   {
      strOut += L"   ";
   }

   strOut += pwzCol1;
   strOut += L", ";
   strOut += pwzCol2;
   if (pwzCol3 && *pwzCol3)
   {
      strOut += L", ";
      strOut += pwzCol3;
   }
   if (pwzCol4 && *pwzCol4)
   {
      strOut += L", ";
      strOut += pwzCol4;
   }
   strOut += g_wzCRLF;
}

//+----------------------------------------------------------------------------
//
//  Function:  SaveFTInfoAs
//
//  Synopsis:  Prompt the user for a file name and then save the FTInfo as a
//             CSV text file.
//
//-----------------------------------------------------------------------------
void
SaveFTInfoAs(HWND hWnd, PCWSTR pwzFlatName, PCWSTR pwzDnsName,
             CFTInfo & FTInfo, CFTCollisionInfo & ColInfo)
{
   TRACE_FUNCTION(SaveFTInfoAs);
   if (!pwzFlatName || !pwzDnsName)
   {
      dspAssert(FALSE);
      return;
   }

   OPENFILENAME ofn = {0};
   WCHAR wzFilter[MAX_PATH + 1] = {0}, wzFileName[MAX_PATH + MAX_PATH + 1];
   CStrW strFilter, strExt, strMsg;

   wcscpy(wzFileName, pwzFlatName);
   strExt.LoadString(g_hInstance, IDS_FTFILE_SUFFIX);
   wcscat(wzFileName, strExt);
   wcscat(wzFileName, L".");
   strExt.LoadString(g_hInstance, IDS_FTFILE_CSV_EXT);
   wcscat(wzFileName, strExt);

   LoadString(g_hInstance, IDS_FTFILE_FILTER, wzFilter, MAX_PATH);

   ofn.lStructSize = sizeof(ofn);
   ofn.hwndOwner = hWnd;
   ofn.lpstrFile = wzFileName;
   ofn.nMaxFile = MAX_PATH + MAX_PATH + 1;
   ofn.Flags = OFN_OVERWRITEPROMPT;
   ofn.lpstrDefExt = strExt;
   ofn.lpstrFilter = wzFilter;

   if (GetSaveFileName(&ofn))
   {
      dspDebugOut((DEB_ITRACE, "Saving FTInfo to %ws\n", ofn.lpstrFile));
      PWSTR pwzErr;
      BOOL fSucceeded = TRUE;

      HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0,
                                NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);

      if (INVALID_HANDLE_VALUE != hFile)
      {
         CStrW strPrefix;
         strPrefix.LoadString(g_hInstance, IDS_LOG_PREFIX);

         ComposeLineTabSep(strMsg, 0, strPrefix, pwzDnsName, NULL, NULL);

         strMsg += g_wzCRLF;

         FormatFTNames(FTInfo, ColInfo, ComposeLineTabSep, strMsg);

         strMsg += g_wzCRLF;

         DWORD dwWritten;

         fSucceeded = WriteFile(hFile, strMsg.GetBuffer(0),
                                strMsg.GetLength() * sizeof(WCHAR),
                                &dwWritten, NULL);
         CloseHandle(hFile);
      }
      else
      {
         fSucceeded = FALSE;
      }


      if (!fSucceeded)
      {
         CStrW strTitle;
         strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
         LoadErrorMessage(GetLastError(), 0, &pwzErr);
         if (pwzErr)
         {
            strMsg.FormatMessage(g_hInstance, IDS_LOGFILE_CREATE_FAILED, pwzErr);
            delete [] pwzErr;
         }
         MessageBox(hWnd, strMsg, strTitle, MB_ICONERROR);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Function:  FormatFTNames
//
//-----------------------------------------------------------------------------
void
FormatFTNames(CFTInfo & FTInfo, CFTCollisionInfo & ColInfo,
              LINE_COMPOSER pLineFcn, CStrW & strMsg)
{
   TRACE_FUNCTION(FormatFTNames);
   PLSA_FOREST_TRUST_RECORD pRec = NULL;
   CStrW strName, strType, strStatus, strNotes, strDnsName,
         strAdminDisabled, strNewDisabled, strEnabled, strTlnExMatch,
         strExclusion, strTypeSuffix, strTypeDnsDomain, strTypeNBDomain,
         strConflict, strTypeSID, strWith, strFor, strUnknown;

   strName.LoadString(g_hInstance, IDS_COL_TITLE_OBJNAME);
   strType.LoadString(g_hInstance, IDS_LOG_TYPE);
   strStatus.LoadString(g_hInstance, IDS_LOG_STATUS);
   strNotes.LoadString(g_hInstance, IDS_LOG_NOTES);

   (*pLineFcn)(strMsg, 0, strName, strType, strStatus, strNotes);

   if (!FTInfo.GetCount())
   {
      return;
   }

   strTypeSuffix.LoadString(g_hInstance, IDS_LOG_NAME_SUFFIX);
   strTypeDnsDomain.LoadString(g_hInstance, IDS_LOG_DOM_DNS_NAME);
   strTypeNBDomain.LoadString(g_hInstance, IDS_LOG_DOM_FLAT_NAME);
   strTypeSID.LoadString(g_hInstance, IDS_LOG_SID);
   strEnabled.LoadString(g_hInstance, IDS_LOG_ENABLED);
   strAdminDisabled.LoadString(g_hInstance, IDS_LOG_ADMIN_DISABLED);
   strNewDisabled.LoadString(g_hInstance, IDS_LOG_NEW_DISABLED);
   strExclusion.LoadString(g_hInstance, IDS_LOG_EXCLUSION);
   strTlnExMatch.LoadString(g_hInstance, IDS_LOG_MATCHING_EXCLUSION);
   strConflict.LoadString(g_hInstance, IDS_LOG_CONFLICT);
   strWith.LoadString(g_hInstance, IDS_LOG_WITH);
   strFor.LoadString(g_hInstance, IDS_LOG_FOR);
   strUnknown.LoadString(g_hInstance, IDS_LOG_UNKNOWN);

   CStrW strCollisionName;
   ULONG j = 1;

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      bool fCollision = false;
      bool fExcluded = false;

      pRec = FTInfo.GetFTInfo()->Entries[i];

      dspAssert(pRec);

      if (ColInfo.IsInCollisionInfo(i))
      {
         fCollision = TRUE;
         ColInfo.GetCollisionName(i, strCollisionName);
      }

      strNotes.Empty();
      strStatus.Empty();

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
         strName = pRec->ForestTrustData.TopLevelName;
         AddAsteriskPrefix(strName);
         if (pRec->Flags)
         {
            if (LSA_TLN_DISABLED_NEW & pRec->Flags)
            {
               strStatus = strNewDisabled;
            }
            if (LSA_TLN_DISABLED_ADMIN & pRec->Flags)
            {
               strStatus = strAdminDisabled;
            }
            if (LSA_TLN_DISABLED_CONFLICT & pRec->Flags)
            {
               strStatus = strConflict;
            }
         }
         else
         {
            strStatus = strEnabled;
         }
         if (fCollision)
         {
            strStatus = strConflict;
            strNotes = strWith;
            strNotes += strCollisionName;
         }
         (*pLineFcn)(strMsg, j++, strName, strTypeSuffix, strStatus, strNotes);
         break;

      case ForestTrustTopLevelNameEx:
         strName = pRec->ForestTrustData.TopLevelName;
         AddAsteriskPrefix(strName);
         (*pLineFcn)(strMsg, j++, strName,
                     FTInfo.IsDomainMatch(i) ? strTlnExMatch : strExclusion,
                     NULL, NULL);
         break;

      case ForestTrustDomainInfo:
         strDnsName = pRec->ForestTrustData.DomainInfo.DnsName;
         strStatus = strEnabled;
         ULONG iExclusion;
         if (FTInfo.FindMatchingExclusion(i, iExclusion, true))
         {
            strStatus = strAdminDisabled;
            strType.LoadString(g_hInstance, IDS_LOG_HAS_EXCLUSION);
            strNotes = strType;
            fExcluded = true;
         }
         (*pLineFcn)(strMsg, j++, strDnsName, strTypeDnsDomain, strStatus, strNotes);

         strName = pRec->ForestTrustData.DomainInfo.NetbiosName;
         strNotes = strFor;
         strNotes += strDnsName;
         if (fCollision)
         {
            strStatus = strConflict;
            strNotes += ", ";
            strNotes += strWith;
            strNotes += strCollisionName;
         }
         if (fExcluded)
         {
            strStatus = strAdminDisabled;
            strNotes += ", ";
            strNotes += strType;
         }
         else
         {
            if (LSA_NB_DISABLED_ADMIN & pRec->Flags)
            {
               strStatus = strAdminDisabled;
            }
            else if (LSA_NB_DISABLED_CONFLICT & pRec->Flags)
            {
               strStatus = strConflict;
            }
            else
            {
               strStatus = strEnabled;
            }
         }
         (*pLineFcn)(strMsg, j++, strName, strTypeNBDomain, strStatus, strNotes);

         FormatSID(pRec->ForestTrustData.DomainInfo.Sid, strName);
         strNotes = strFor;
         strNotes += strDnsName;
         if (fCollision)
         {
            strStatus = strConflict;
            strNotes += ", ";
            strNotes += strWith;
            strNotes += strCollisionName;
         }
         if (fExcluded)
         {
            strStatus = strAdminDisabled;
            strNotes += ", ";
            strNotes += strType;
         }
         else
         {
            if (LSA_SID_DISABLED_ADMIN & pRec->Flags)
            {
               strStatus = strAdminDisabled;
            }
            else if (LSA_SID_DISABLED_CONFLICT & pRec->Flags)
            {
               strStatus = strConflict;
            }
            else
            {
               strStatus = strEnabled;
            }
         }
         (*pLineFcn)(strMsg, j++, strName, strTypeSID, strStatus, strNotes);
         break;

      default:
         (*pLineFcn)(strMsg, j++, strUnknown, L"", NULL, NULL);
         break;
      }
   }
   return;
}

//+----------------------------------------------------------------------------
//
//  Function:  FormatSID
//
//-----------------------------------------------------------------------------
void
FormatSID(PSID Sid, CStrW & str)
{
   TRACE_FUNCTION(FormatSID);
   SID_IDENTIFIER_AUTHORITY * sia;
   ULONG i = 0;
   CStrW strTmp;

   dspAssert(Sid);

   sia = RtlIdentifierAuthoritySid(Sid);

   str = L"s-1-";

   for (i = 0; i < 5; i++)
   {
      if (sia->Value[i])
      {
         strTmp.Format(L"%d", sia->Value[i]);
         str += strTmp;
      }
   }

   strTmp.Format(L"%d", sia->Value[5]);
   str += strTmp;

   for (i = 0; i < *RtlSubAuthorityCountSid(Sid); i++)
   {
      strTmp.Format(L"-%ld", *RtlSubAuthoritySid(Sid, i));
      str += strTmp;
   }
}

void AddAsteriskPrefix(CStrW & strName)
{
   CStrW strTemp = L"*.";
   strTemp += strName;
   strName = strTemp;
}

void RemoveAsteriskPrefix(CStrW & strName)
{
   CStrW strTemp;
   strTemp = strName.Left(2);
   if (strTemp != L"*.")
   {
      return;
   }
   strTemp = strName.Right(strName.GetLength() - 2);
   strName = strTemp;
}

//+----------------------------------------------------------------------------
//
//  Function:  NDReadFTNames
//
//  Synopsis:  Reads the forest trust names claimed by the trust partner and
//             stored on the TDO. No attempt is made to contact the other
//             domain to refresh the names.
//
//-----------------------------------------------------------------------------
DWORD
NDReadFTNames(PCWSTR pwzLocalDc, PCWSTR pwzTrust, CFTInfo & FTInfo,
              CFTCollisionInfo & ColInfo)
{
   DWORD dwRet = NO_ERROR;
   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING TrustPartner = {0};
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL;

   if (!pwzLocalDc || !pwzTrust)
   {
      return ERROR_INVALID_PARAMETER;
   }

   RtlInitUnicodeString(&TrustPartner, pwzTrust);

   CPolicyHandle cPolicy(pwzLocalDc);

   dwRet = cPolicy.OpenNoAdmin();

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   status = LsaQueryForestTrustInformation(cPolicy,
                                           &TrustPartner,
                                           &pFTInfo);
   if (STATUS_NOT_FOUND == status)
   {
      // no FT info stored yet, which can occur on a new trust.
      //
      CStrW strErr;
      strErr.LoadString(g_hInstance, IDS_NETDOM_NO_FTINFOS);
      printf("%ws\n", strErr.GetBuffer(0));
      return LsaNtStatusToWinError(status);
   }

   if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
   {
      if (ERROR_INVALID_DOMAIN_STATE == dwRet)
      {
         CStrW strMsg;
         strMsg.LoadString(g_hInstance, IDS_NETDOM_NOT_FOREST);
         printf("%ws\n", strMsg.GetBuffer(0));
         return ERROR_INVALID_PARAMETER;
      }
      if (ERROR_NO_SUCH_DOMAIN == dwRet)
      {
         CStrW strMsg;
         strMsg.FormatMessage(g_hInstance, IDS_NETDOM_NO_TRUST, pwzTrust);
         printf("%ws\n", strMsg.GetBuffer(0));
         return ERROR_INVALID_PARAMETER;
      }
      return dwRet;
   }

   dspAssert(pFTInfo);

   FTInfo = pFTInfo;

   LsaFreeMemory(pFTInfo);

   // Make a temp copy and clear the conflict bit before submitting to LSA.
   // This will return current conflict info.
   //
   CFTInfo TempFTInfo(FTInfo);

   TempFTInfo.ClearAnyConflict();

   // Now check the data. On return from the call the pColInfo struct
   // will contain current collision data.
   //
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         TempFTInfo.GetFTInfo(),
                                         TRUE, // check only, don't write to TDO
                                         &pColInfo);

   if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
   {
      if (ERROR_INVALID_DOMAIN_STATE == dwRet)
      {
         CStrW strMsg;
         strMsg.LoadString(g_hInstance, IDS_NETDOM_NOT_FOREST);
         printf("%ws\n", strMsg.GetBuffer(0));
         return ERROR_INVALID_PARAMETER;
      }
      return dwRet;
   }

   ColInfo = pColInfo;

   // Look for names that used to be or are now in conflict.
   //
   for (ULONG i = 0; i < FTInfo.GetCount(); i++)
   {
      // Any names that used to be in conflict but aren't now are marked as
      // admin-disabled.
      //
      if (FTInfo.IsConflictFlagSet(i))
      {
         if (!ColInfo.IsInCollisionInfo(i))
         {
            FTInfo.SetAdminDisable(i);
            FTInfo.SetUsedToBeInConflict(i);
            continue;
         }
      }
      // If a name is in the collision info, then set the conflict flag.
      //
      if (ColInfo.IsInCollisionInfo(i))
      {
         FTInfo.SetConflictDisable(i);
      }
   }

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  NDWriteFTNames
//
//  Synopsis:  Writes the forest trust names to the TDO.
//
//-----------------------------------------------------------------------------
DWORD
NDWriteFTNames(PCWSTR pwzLocalDc, PCWSTR pwzTrust, CFTInfo & FTInfo)
{
   DWORD dwRet = NO_ERROR;
   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING TrustPartner = {0};
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL;

   if (!pwzLocalDc || !pwzTrust || !FTInfo.GetCount())
   {
      return ERROR_INVALID_PARAMETER;
   }

   RtlInitUnicodeString(&TrustPartner, pwzTrust);

   CPolicyHandle cPolicy(pwzLocalDc);

   dwRet = cPolicy.OpenNoAdmin();

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         FTInfo.GetFTInfo(),
                                         FALSE,
                                         &pColInfo);

   if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
   {
      return dwRet;
   }

   if (pColInfo)
   {
      LsaFreeMemory(pColInfo);
   }

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_DumpFTInfos
//
//  Synopsis:  Exported function that netdom can use to dump the FTInfos for a
//             forest trust.
//
//-----------------------------------------------------------------------------
extern "C" INT_PTR WINAPI 
DSPROP_DumpFTInfos(PCWSTR pwzLocalDc, PCWSTR pwzTrust,
                   PCWSTR pwzUser, PCWSTR pwzPw)
{
   TRACE_FUNCTION(DSPROP_DumpFTInfos);

   if (!pwzLocalDc || !pwzTrust)
   {
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Read the FTInfos, using the creds if needed.
   //
   DWORD dwRet = NO_ERROR;

   CCreds Creds;

   if (pwzUser && *pwzUser)
   {
      dwRet = Creds.SetUserAndPW(pwzUser, pwzPw, NULL);

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }

      dwRet = Creds.Impersonate();

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }
   }

   CFTInfo FTInfo;
   CFTCollisionInfo ColInfo;

   dwRet = NDReadFTNames(pwzLocalDc, pwzTrust, FTInfo, ColInfo);

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   CStrW strMsg;

   FormatFTNames(FTInfo, ColInfo, ComposeNumberedLine, strMsg);

   printf("%ws\n", strMsg.GetBuffer(0));

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_ToggleFTName
//
//  Synopsis:  Exported function that netdom can use to toggle the state of an
//             FTInfo name for a forest trust.
//
//-----------------------------------------------------------------------------
extern "C" INT_PTR WINAPI
DSPROP_ToggleFTName(PCWSTR pwzLocalDc, PWSTR pwzTrust, ULONG iSel,
                    PCWSTR pwzUser, PCWSTR pwzPW)
{
   dspDebugOut((DEB_ITRACE, "DSPROP_ToggleFTName, TDO: %ws, name: %d\n",
                pwzTrust, iSel));

   if (!pwzLocalDc || !pwzTrust)
   {
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Read the FTInfos, using the creds if needed.
   //
   DWORD dwRet = NO_ERROR;
   NTSTATUS status = 0;

   CCreds Creds;

   if (pwzUser && *pwzUser)
   {
      dwRet = Creds.SetUserAndPW(pwzUser, pwzPW, NULL);

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }

      dwRet = Creds.Impersonate();

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }
   }

   CFTInfo FTInfo;
   CFTCollisionInfo ColInfo;
   CStrW strMsg, strName, strCollisionName;

   dwRet = NDReadFTNames(pwzLocalDc, pwzTrust, FTInfo, ColInfo);

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   PLSA_FOREST_TRUST_RECORD pRec = NULL;
   ULONG j = 1;
   bool fFound = false;

   for (UINT i = 0; i < FTInfo.GetCount() && !fFound; i++)
   {
      pRec = FTInfo.GetFTInfo()->Entries[i];
      dspAssert(pRec);
      bool fExcluded = false;

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
         if (iSel == j)
         {
            if (pRec->Flags)
            {
               if (pRec->Flags & (LSA_TLN_DISABLED_NEW | LSA_TLN_DISABLED_ADMIN))
               {
                  pRec->Flags = 0;
               }
               if ((LSA_TLN_DISABLED_CONFLICT & pRec->Flags) ||
                   ColInfo.IsInCollisionInfo(i))
               {
                  strName = pRec->ForestTrustData.TopLevelName;
                  if (ColInfo.GetCollisionName(i, strCollisionName))
                  {
                     strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT_NAME,
                                          strName.GetBuffer(0),
                                          strCollisionName.GetBuffer(0));
                  }
                  else
                  {
                     strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT,
                                          strName.GetBuffer(0));
                  }
                  printf("%ws\n", strMsg.GetBuffer(0));
                  return ERROR_INVALID_PARAMETER;
               }
            }
            else
            {
               pRec->Flags = LSA_TLN_DISABLED_ADMIN;
            }
            fFound = true;
            break;
         }
         j++;
         break;

      case ForestTrustTopLevelNameEx:
         if (iSel == j)
         {
            strName = pRec->ForestTrustData.TopLevelName;
            strMsg.FormatMessage(g_hInstance, 
                                 FTInfo.IsDomainMatch(i) ? IDS_NETDOM_MATCHING_TLNEX :
                                                           IDS_NETDOM_TLNEX,
                                 strName.GetBuffer(0));
            printf("%ws\n", strMsg.GetBuffer(0));
            return ERROR_INVALID_PARAMETER;
         }
         j++;
         break;

      case ForestTrustDomainInfo:
         ULONG iExclusion;
         fExcluded = FTInfo.FindMatchingExclusion(i, iExclusion, true);
         if (iSel == j)
         {
            strName = pRec->ForestTrustData.DomainInfo.DnsName;
            strMsg.FormatMessage(g_hInstance, 
                                 (fExcluded) ? IDS_NETDOM_ENABLE_DOMAIN :
                                               IDS_NETDOM_DISABLE_DOMAIN,
                                 strName.GetBuffer(0));
            printf("%ws\n", strMsg.GetBuffer(0));
            return ERROR_INVALID_PARAMETER;
         }
         j++;

         if (iSel == j)
         {
            strName = pRec->ForestTrustData.DomainInfo.NetbiosName;
            if ((LSA_NB_DISABLED_CONFLICT & pRec->Flags) ||
                ColInfo.IsInCollisionInfo(i))
            {
               if (ColInfo.GetCollisionName(i, strCollisionName))
               {
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT_NAME,
                                       strName.GetBuffer(0),
                                       strCollisionName.GetBuffer(0));
               }
               else
               {
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT,
                                       strName.GetBuffer(0));
               }
               printf("%ws\n", strMsg.GetBuffer(0));
               return ERROR_INVALID_PARAMETER;
            }
            if (fExcluded)
            {
               strMsg.FormatMessage(g_hInstance, IDS_NETDOM_EXCLUDED,
                                    strName.GetBuffer(0));
               printf("%ws\n", strMsg.GetBuffer(0));
               return ERROR_INVALID_PARAMETER;
            }
            if (LSA_NB_DISABLED_ADMIN & pRec->Flags)
            {
               pRec->Flags &= ~LSA_NB_DISABLED_ADMIN;
            }
            else
            {
               pRec->Flags |= LSA_NB_DISABLED_ADMIN;
            }
            fFound = true;
            break;
         }
         j++;

         if (iSel == j)
         {
            FormatSID(pRec->ForestTrustData.DomainInfo.Sid, strName);
            if ((LSA_SID_DISABLED_CONFLICT & pRec->Flags) ||
                ColInfo.IsInCollisionInfo(i))
            {
               if (ColInfo.GetCollisionName(i, strCollisionName))
               {
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_SID_CONFLICT_NAME,
                                       strName.GetBuffer(0),
                                       strCollisionName.GetBuffer(0));
               }
               else
               {
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_SID_CONFLICT,
                                       strName.GetBuffer(0));
               }
            }
            if (fExcluded)
            {
               strMsg.FormatMessage(g_hInstance, IDS_NETDOM_EXCLUDED,
                                    strName.GetBuffer(0));
               printf("%ws\n", strMsg.GetBuffer(0));
               return ERROR_INVALID_PARAMETER;
            }
            if (LSA_SID_DISABLED_ADMIN & pRec->Flags)
            {
               pRec->Flags &= ~LSA_SID_DISABLED_ADMIN;
            }
            else
            {
               pRec->Flags |= LSA_SID_DISABLED_ADMIN;
            }
            fFound = true;
            break;
         }
         j++;
         break;

      default:
         if (iSel == j)
         {
            return ERROR_INVALID_PARAMETER;
         }
         j++;
         break;
      }
   }

   if (!fFound)
   {
      strMsg.FormatMessage(g_hInstance, IDS_NETDOM_RANGE_ERROR, --j);
      printf("%ws\n", strMsg.GetBuffer(0));
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Save the updated FTInfo.
   //
   dwRet = NDWriteFTNames(pwzLocalDc, pwzTrust, FTInfo);

   if (NO_ERROR != dwRet)
   {
      strMsg.LoadString(g_hInstance, IDS_NETDOM_WRITE_FTINFO_FAILED);
      printf("%ws\n", strMsg.GetBuffer(0));
      return dwRet;
   }

   //
   // Print out the changes for the user.
   //
   FormatFTNames(FTInfo, ColInfo, ComposeNumberedLine, strMsg);

   printf("%ws\n", strMsg.GetBuffer(0));

   return NO_ERROR;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\fpnw.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       fpnw.cxx
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////
// fpnw.cxx : 
//  Handles the FPNW page on the user object property sheet
//

#include "pch.h"
#include "proppage.h"
#include "pages.h"
#include "fpnw.h"
#include "fpnwcomm.h"
extern "C" {
#include "usrprop.h"
#include "icanon.h" // NetpPathType
}
#include "lmerr.h" // NERR_Success
#include "lmaccess.h" // USER_MODALS_INFO_0
#include "netlibnt.h" // NetpNtStatusToApiStatus 

// CODEWORK net\ui\admin\user\h\nwlb.hxx
#define NETWORKSIZE  8
#define NODESIZE     12

#define SZ_ALL_NODES_ADDR             _T("ffffffffffff")

#define SZ_FPNWCLNT_DLL               _T("fpnwclnt.dll")
#define SZ_MAPRIDTOOBJECTID           "MapRidToObjectId"
#define SZ_SWAPOBJECTID               "SwapObjectId"
#define SZ_RETURNNETWAREFORM          "ReturnNetwareForm"
#define SZ_FPNWVOLUMEGETINFO          "FpnwVolumeGetInfo"
#define SZ_FPNWAPIBUFFERFREE          "FpnwApiBufferFree"

#define MIN_PASS_LEN_MAX                14 // from net\ui\admin\user\user\secset.cxx
#define SZ_MAIL_DIR                     _T("MAIL\\")  // from net\ui\admin\user\user\ncp.cxx
#define SZ_LOGIN_FILE                   _T("\\LOGIN") // from net\ui\admin\user\user\ncp.cxx
#define NO_GRACE_LOGIN_LIMIT            0xFF      // from net\ui\admin\user\user\ncp.cxx
#define NT_TIME_RESOLUTION_IN_SECOND    10000000  // from net\ui\admin\user\user\nwuser.cxx

#define FPNW_FIELDS_NWPASSWORD          0x00000001
#define FPNW_FIELDS_NWTIMEPASSWORDSET   0x00000002
#define FPNW_FIELDS_GRACELOGINALLOWED   0x00000004
#define FPNW_FIELDS_GRACELOGINREMAINING 0x00000008
#define FPNW_FIELDS_MAXCONNECTIONS      0x00000010
#define FPNW_FIELDS_NWHOMEDIR           0x00000020
#define FPNW_FIELDS_LOGONFROM           0x00000040

#define ATTR_USERPARMS                  L"userParameters"
#define ATTR_USERACCOUNTCONTROL         L"userAccountControl"
#define ATTR_OBJECTSID                  L"objectSid"
#define ATTR_SAMACCOUNTNAME             L"sAMAccountName"
#define ATTR_FSMOROLEOWNER              L"fSMORoleOwner"

#define LOGIN_SCRIPT_FILE_READ          0
#define LOGIN_SCRIPT_FILE_WRITE         1

#define FPNW_CHECK_RETURN(bVal, idError, nStr, hWnd, returnVal) \
if (!(bVal)) \
{if (hWnd) ReportError((idError), (nStr), (hWnd)); \
return (returnVal);}

// globals

extern Cache g_FPNWCache;

static WNDPROC g_fnOldEditCtrlProc;

///////////////////////////////////////////
// Implementation for class CFPNWLinkList 
//

void FreeFPNWCacheElem(PFPNWCACHE p)
{
  if (p) {
    if (p->pwzPDCName)
      LocalFree(p->pwzPDCName);
    LocalFree(p);
  }

  return;
}

//////////////////////////////////////////
// Implementation for class CDsFPNWPage
//

CDsFPNWPage::CDsFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                         HWND hNotifyObj, DWORD dwFlags) 
  : CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsFPNWPage,CDsFPNWPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsFPNWPage");
#endif

  m_cstrUserParms = _T("");
  m_pwzPDCName = NULL;
  m_pwzSecretKey = NULL;
  m_bMaintainNetwareLogin = false;
  m_bNetwarePasswordExpired = DEFAULT_NWPASSWORDEXPIRED;
  m_bLimitGraceLogins = true;
  m_bLimitConnections = false;
  m_ushGraceLoginLimit = DEFAULT_GRACELOGINALLOWED;
  m_ushGraceLoginsRemaining = DEFAULT_GRACELOGINREMAINING;
  m_ushConnectionLimit = DEFAULT_MAXCONNECTIONS;
  m_cstrHmDirRelativePath = _T("");

  m_hFPNWClntDll = NULL;
  m_pfnMapRidToObjectId = NULL;
  m_pfnSwapObjectId = NULL;
  m_pfnReturnNetwareForm = NULL;
  m_pfnFPNWVolumeGetInfo = NULL;
  m_pfnFpnwApiBufferFree = NULL;

  m_dwMinPasswdLen = 0;
  m_dwMaxPasswdAge = static_cast<DWORD>(-1);

  m_cstrUserName = _T("");
  m_dwObjectID = 0;
  m_dwSwappedObjectID = 0;
  m_cstrNWPassword = _T("");
  m_cstrLogonFrom = _T("");
  m_cstrNewLogonFrom = _T("");

  m_cstrLoginScriptFileName = _T("");
  m_pLoginScriptBuffer = NULL;
  m_dwBytesToWrite = 0;
  m_bLoginScriptChanged = false;
}

CDsFPNWPage::~CDsFPNWPage()
{
  if (m_pLoginScriptBuffer)
    LocalFree(m_pLoginScriptBuffer);
  
  if (m_hFPNWClntDll) 
    FreeLibrary(m_hFPNWClntDll);

}

LRESULT
CDsFPNWPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);
    case WM_NOTIFY:
        return OnNotify(wParam, lParam);
    case WM_SHOWWINDOW:
        return OnShowWindow();
    case WM_SETFOCUS:
        return OnSetFocus(reinterpret_cast<HWND>(wParam));
    case WM_HELP:
        return OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
    case WM_COMMAND:
        if (m_fInInit)
            return TRUE;
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();
    default:
        return(FALSE);
    }

    return(TRUE);
}

HRESULT CDsFPNWPage::OnInitDialog(LPARAM)
{
    HWND currWindow;

    ADsPropSetHwnd(m_hNotifyObj, m_hPage);

    if (m_bMaintainNetwareLogin)
        CheckDlgButton(m_hPage, IDC_NETWARE_ENABLE, BST_CHECKED);

    EnableWindow(GetDlgItem(m_hPage, IDC_NWPWEXPIRED),
                 m_bMaintainNetwareLogin);
    if (m_bNetwarePasswordExpired)
        CheckDlgButton(m_hPage, IDC_NWPWEXPIRED, BST_CHECKED);

    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LOGINS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_GRACELOGINS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_GRACELOGINS),
                 m_bMaintainNetwareLogin);
    CheckRadioButton( m_hPage,
                      IDC_UNLIMITED_GRACELOGINS,
                      IDC_LIMIT_GRACELOGINS,
                      m_bLimitGraceLogins ? IDC_LIMIT_GRACELOGINS : IDC_UNLIMITED_GRACELOGINS );

    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LIMIT),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_SPIN),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_TEXT),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    currWindow = GetDlgItem(m_hPage, IDC_GRACE_SPIN);

    // JonN 5/25/00 92903: dsadmin: fpnw5 : should allow user to set Grace Logins Remaining to 0
    SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG(0xFF, 0));
    SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( m_ushGraceLoginLimit, 0));
    currWindow = GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN);
    SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG( m_ushGraceLoginLimit, 0));

    SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( min(m_ushGraceLoginLimit, m_ushGraceLoginsRemaining), 0));

    EnableWindow(GetDlgItem(m_hPage, IDC_CONCURRENT_CONNECTIONS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_CONNECTIONS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_CONNECTIONS),
                 m_bMaintainNetwareLogin);
    CheckRadioButton( m_hPage,
                      IDC_UNLIMITED_CONNECTIONS,
                      IDC_LIMIT_CONNECTIONS,
                      m_bLimitConnections ? IDC_LIMIT_CONNECTIONS : IDC_UNLIMITED_CONNECTIONS );

    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_LIMIT),
                 m_bMaintainNetwareLogin && m_bLimitConnections);
    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_SPIN),
                 m_bMaintainNetwareLogin && m_bLimitConnections);
    currWindow = GetDlgItem(m_hPage, IDC_CONNECTION_SPIN);
    SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG(0xFF, 1));
    SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( m_ushConnectionLimit, 0));

    EnableWindow(GetDlgItem(m_hPage, IDC_SCRIPT_BUTTON),
                 m_bMaintainNetwareLogin && IsServiceRunning(m_pwzPDCName, NW_SERVER_SERVICE));
    EnableWindow(GetDlgItem(m_hPage, IDC_ADVANCED_BUTTON),
                 m_bMaintainNetwareLogin);

    EnableWindow(GetDlgItem(m_hPage, IDC_OBJECTID_TEXT),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_OBJECT_ID),
                 m_bMaintainNetwareLogin);
    CStr cstrObjectID;
    cstrObjectID.Format(_T("%08x"), m_dwSwappedObjectID);
    SetWindowText(GetDlgItem(m_hPage, IDC_OBJECT_ID), cstrObjectID);

    EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH_TEXT),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH),
                 m_bMaintainNetwareLogin);
    SetWindowText(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH), m_cstrHmDirRelativePath);

    return S_OK;
}

LRESULT
CDsFPNWPage::OnApply() 
{
    bool bValue;
    DWORD dwFPNWFields = 0;
    TCHAR szPath[MAX_PATH] = {0};

    //
    // validate the NetWare Relative Home Directory
    //
    if (GetWindowText(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH), szPath, MAX_PATH)) {
      DWORD dwPathType = 0;
      LONG err = NetpPathType(NULL, szPath, &dwPathType, 0);

      if ( (err != NERR_Success) || (dwPathType != ITYPE_PATH_RELND) ) {
        CStr cstrFormat, cstrMsg, cstrTitle;
        cstrFormat.LoadString(g_hInstance, IDS_INVALID_RELPATH);
        cstrTitle.LoadString(g_hInstance, IDS_MSG_TITLE);
        cstrMsg.Format(cstrFormat, szPath);
        MessageBox(m_hPage, cstrMsg, cstrTitle, MB_OK | MB_ICONINFORMATION);
        return TRUE;
      }
    }

    //
    // collect all the input
    //
    if (m_cstrHmDirRelativePath.CompareNoCase(szPath)) {
      m_cstrHmDirRelativePath = szPath;
      dwFPNWFields |= FPNW_FIELDS_NWHOMEDIR;
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
    if (m_bMaintainNetwareLogin != bValue) {
      m_bMaintainNetwareLogin = bValue;
      dwFPNWFields |= FPNW_FIELDS_NWPASSWORD;
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NWPWEXPIRED));
    if (m_bNetwarePasswordExpired != bValue) {
      m_bNetwarePasswordExpired = bValue;
      dwFPNWFields |= FPNW_FIELDS_NWTIMEPASSWORDSET;
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_GRACELOGINS));
    if (m_bLimitGraceLogins != bValue) {
      m_bLimitGraceLogins = bValue;
      if (!m_bLimitGraceLogins) {
        m_ushGraceLoginLimit = DEFAULT_GRACELOGINALLOWED;
        m_ushGraceLoginsRemaining = NO_GRACE_LOGIN_LIMIT;
      }
      dwFPNWFields |= ( FPNW_FIELDS_GRACELOGINALLOWED |
                        FPNW_FIELDS_GRACELOGINREMAINING );
    }
    if (m_bLimitGraceLogins) {
      USHORT ushAllowed = (USHORT)SendDlgItemMessage(
                                      m_hPage, 
                                      IDC_GRACE_SPIN, 
                                      UDM_GETPOS, 0, 0);
      USHORT ushRemaining = (USHORT)SendDlgItemMessage(
                                        m_hPage, 
                                        IDC_GRACE_REMAINING_SPIN, 
                                        UDM_GETPOS, 0, 0);
      if (m_ushGraceLoginLimit != ushAllowed) {
        m_ushGraceLoginLimit = ushAllowed;
        dwFPNWFields |= FPNW_FIELDS_GRACELOGINALLOWED;
      }
      if (m_ushGraceLoginsRemaining != ushRemaining) {
        m_ushGraceLoginsRemaining = ushRemaining;
        dwFPNWFields |= FPNW_FIELDS_GRACELOGINREMAINING;
      }
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_CONNECTIONS));
    if (m_bLimitConnections != bValue) {
      m_bLimitConnections = bValue;
      if (!m_bLimitConnections)
        m_ushConnectionLimit = NO_LIMIT; 
      dwFPNWFields |= FPNW_FIELDS_MAXCONNECTIONS;
    }
    if (m_bLimitConnections) {
      USHORT ushConnections = (USHORT)SendDlgItemMessage(
                                          m_hPage, 
                                          IDC_CONNECTION_SPIN, 
                                          UDM_GETPOS, 0, 0);
      if (m_ushConnectionLimit != ushConnections) {
        m_ushConnectionLimit = ushConnections;
        dwFPNWFields |= FPNW_FIELDS_MAXCONNECTIONS;
      }
    }

    if (m_cstrLogonFrom.CompareNoCase(m_cstrNewLogonFrom)) {
      m_cstrLogonFrom = m_cstrNewLogonFrom;
      dwFPNWFields |= FPNW_FIELDS_LOGONFROM;
    }

    //
    // apply any change
    //
    if (dwFPNWFields) {
      //
      // Re-get the toxic waste dump from DS
      // Update it
      // Write it back to the DS
      //
      HRESULT hr = S_OK;
      hr = ReadUserParms(m_pDsObj, m_cstrUserParms);
      if (SUCCEEDED(hr))
      {
        if (UpdateUserParms(dwFPNWFields))
        {
          hr = WriteUserParms(m_pDsObj, m_cstrUserParms);
          if (FAILED(hr)) {
            ReportError(hr, IDS_FAILED_TO_WRITE_NWPARMS, m_hPage);
            ParseUserParms(); // re-store the member values
            return TRUE;
          }
        } else {
          ParseUserParms(); // re-store the member values
          return TRUE;
        }
      }
    }

    //
    // if user has updated his login script, 
    // write the new scripts to the file
    //
    if (m_pLoginScriptBuffer) {
      LONG err = UpdateLoginScriptFile(
          m_cstrLoginScriptFileName, 
          m_pLoginScriptBuffer, 
          m_dwBytesToWrite);
      if (err != ERROR_SUCCESS) {
        ReportError(err, IDS_FAILED_TO_UPDATE_LOGINSCRIPTS, m_hPage);
        ParseUserParms(); // re-store the member values
        return TRUE;
      }
      LocalFree(m_pLoginScriptBuffer);
      m_pLoginScriptBuffer = NULL;
      m_dwBytesToWrite = 0;
    //
    // JonN 5/25/00 93137 Create the directory when the user becomes
    //     FPNW-enabled, regardless of whether the logon script has
    //     been edited.
    //
    } else if ( (dwFPNWFields & FPNW_FIELDS_NWPASSWORD)
             && m_bMaintainNetwareLogin
             && !m_cstrLoginScriptFileName.IsEmpty()) {
      TCHAR *p = _tcsrchr(m_cstrLoginScriptFileName, _T('\\'));
      if (p) {
        *p = _T('\0');

        if (!CreateDirectory(m_cstrLoginScriptFileName, NULL)) {
          LONG dwErr = GetLastError() ;
          int nMsgId = IDS_FPNW_HOME_DIR_CREATE_OTHER;
          switch (dwErr)
          {
          case ERROR_ALREADY_EXISTS:
            break; // no error message in this case
          case ERROR_PATH_NOT_FOUND:
            nMsgId = IDS_FPNW_HOME_DIR_CREATE_NO_PARENT;
            break;
          case ERROR_LOGON_FAILURE:
          case ERROR_ACCESS_DENIED:
          case ERROR_NOT_AUTHENTICATED:
            nMsgId = IDS_FPNW_HOME_DIR_CREATE_NO_ACCESS;
            break;
          default:
            break;
          }
          if (dwErr != ERROR_ALREADY_EXISTS)
          {
                //
                // Report a warning
                //
                SuperMsgBox(m_hPage,
                  nMsgId,
                  0, MB_OK | MB_ICONEXCLAMATION,
                  dwErr,
                  (PVOID *)&m_cstrLoginScriptFileName, 1,
                  FALSE, __FILE__, __LINE__);
          }
        }

        *p = _T('\\'); // restore the '\'
      }
    }

    //
    // clean the dirty flag
    //
    m_fPageDirty = FALSE;

    return FALSE;
}

LRESULT
CDsFPNWPage::OnCommand(int id, HWND, UINT codeNotify) 
{
    if (codeNotify == BN_CLICKED) {
      bool bMaintainNetwareLogin, bLimitGraceLogins, bLimitConnections;

      switch (id) {
      case IDC_NETWARE_ENABLE:
        {
          bMaintainNetwareLogin = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
          if (!bMaintainNetwareLogin) {
            m_cstrNWPassword.Empty();
          } else {
            if (!m_bMaintainNetwareLogin && m_cstrNWPassword.IsEmpty() ) {
              //
              // ask user for the Netware password
              //
              if (IDCANCEL == DoFPNWPasswordDlg()) {
                CheckDlgButton(m_hPage, IDC_NETWARE_ENABLE, BST_UNCHECKED);
                bMaintainNetwareLogin = 
                  (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
              }
            }
          }
            
          bLimitGraceLogins = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_GRACELOGINS));
          bLimitConnections = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_CONNECTIONS));

          EnableWindow(GetDlgItem(m_hPage, IDC_NWPWEXPIRED), 
                       bMaintainNetwareLogin);

          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LOGINS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_GRACELOGINS), 
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_GRACELOGINS), 
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LIMIT), 
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_SPIN), 
                       bMaintainNetwareLogin && bLimitGraceLogins);

          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_TEXT),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN),
                       bMaintainNetwareLogin && bLimitGraceLogins);

          EnableWindow(GetDlgItem(m_hPage, IDC_CONCURRENT_CONNECTIONS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_CONNECTIONS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_CONNECTIONS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_LIMIT),
                       bMaintainNetwareLogin && bLimitConnections);
          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_SPIN),
                       bMaintainNetwareLogin && bLimitConnections);

          EnableWindow(GetDlgItem(m_hPage, IDC_SCRIPT_BUTTON),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_ADVANCED_BUTTON),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_OBJECTID_TEXT),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_OBJECT_ID),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH_TEXT),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH),
                       bMaintainNetwareLogin);

          SetDirty();
        }
        break;
      case IDC_NWPWEXPIRED:
        {
          SetDirty();
        }
        break;
      case IDC_LIMIT_GRACELOGINS:
      case IDC_UNLIMITED_GRACELOGINS:
        {
          bMaintainNetwareLogin = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
          bLimitGraceLogins = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_GRACELOGINS));

          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LIMIT),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_SPIN),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_TEXT),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN),
                       bMaintainNetwareLogin && bLimitGraceLogins);

          SetDirty();
        }
        break;
      case IDC_LIMIT_CONNECTIONS:
      case IDC_UNLIMITED_CONNECTIONS:
        {
          bMaintainNetwareLogin = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
          bLimitConnections = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_CONNECTIONS));

          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_LIMIT),
                       bMaintainNetwareLogin && bLimitConnections);
          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_SPIN),
                       bMaintainNetwareLogin && bLimitConnections);

          SetDirty();
        }
        break;
      case IDC_SCRIPT_BUTTON:
        {
          DoFPNWLoginScriptDlg();
          if (m_pLoginScriptBuffer)
            SetDirty();
        }
        break;
      case IDC_ADVANCED_BUTTON:
        {
          DoFPNWLogonDlg();
          if (m_cstrLogonFrom.CompareNoCase(m_cstrNewLogonFrom))
            SetDirty();
        }
        break;
      default:
        break;
      } // end of switch statement
    } else if ((codeNotify == EN_CHANGE) && !m_fInInit) {
      if (id == IDC_GRACE_LIMIT) {
        //
        // adjust the Remaining Grace Logins value accordingly
        //
        USHORT ushCurrLimit = (USHORT)SendDlgItemMessage(
                                          m_hPage, 
                                          IDC_GRACE_SPIN, 
                                          UDM_GETPOS, 0, 0);
        HWND currWindow = GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN);
        SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG( ushCurrLimit, 1));
        SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( ushCurrLimit, 0));
      }

      SetDirty();
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::LoadFPNWClntDll
//
//  Synopsis:   Load fpnwclnt.dll into memory.
//
//-----------------------------------------------------------------------------
DWORD
CDsFPNWPage::LoadFPNWClntDll()
{
  DWORD dwErr = 0;

  if (m_hFPNWClntDll) 
    return dwErr;

  m_hFPNWClntDll = LoadLibrary(SZ_FPNWCLNT_DLL);
  m_pfnMapRidToObjectId = reinterpret_cast<PMapRidToObjectId>(GetProcAddress(m_hFPNWClntDll, SZ_MAPRIDTOOBJECTID));
  m_pfnSwapObjectId = reinterpret_cast<PSwapObjectId>(GetProcAddress(m_hFPNWClntDll, SZ_SWAPOBJECTID));
  m_pfnReturnNetwareForm = reinterpret_cast<PReturnNetwareForm>(GetProcAddress(m_hFPNWClntDll, SZ_RETURNNETWAREFORM));
  m_pfnFPNWVolumeGetInfo = reinterpret_cast<PFPNWVolumeGetInfo>(GetProcAddress(m_hFPNWClntDll, SZ_FPNWVOLUMEGETINFO));
  m_pfnFpnwApiBufferFree = reinterpret_cast<PFpnwApiBufferFree>(GetProcAddress(m_hFPNWClntDll, SZ_FPNWAPIBUFFERFREE));

  if (!m_hFPNWClntDll ||
      !m_pfnMapRidToObjectId ||
      !m_pfnSwapObjectId ||
      !m_pfnReturnNetwareForm ||
      !m_pfnFPNWVolumeGetInfo ||
      !m_pfnFpnwApiBufferFree)
  {
    dwErr = GetLastError();
  }

  return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::InitFPNWUser
//
//  Synopsis:   Initiate information related to this user. 
//              If the initialization fails, don't put up the FPNW property page.
//
//-----------------------------------------------------------------------------
bool
CDsFPNWPage::InitFPNWUser()
{
  if (!IsServiceRunning(m_pwzPDCName, NW_SERVER_SERVICE))
    return FALSE;

  HRESULT hr = S_OK;
  DWORD dwErr = 0;

  HWND hwndFrame = NULL;
  // CODEWORK: get the window handle to the mmc main frame
  // use this handle in error reporting

  //
  // load fpnwclnt.dll
  //
  dwErr = LoadFPNWClntDll();
  if (dwErr)
  {
    ReportError(dwErr, IDS_FAILED_TO_LOADFPNWCLNTDLL, hwndFrame);
    return FALSE;
  }

  //
  // get account policy on minimum pwd length and maximum pwd age
  //
  GetAccountPolicyInfo(m_pwzPDCName, &m_dwMinPasswdLen, &m_dwMaxPasswdAge);

  //
  // get user name and NetWare-style object id
  //
  hr = GetNWUserInfo(
            m_pDsObj,
            m_cstrUserName,       // OUT
            m_dwObjectID,         // OUT
            m_dwSwappedObjectID,  // OUT
            m_pfnMapRidToObjectId,
            m_pfnSwapObjectId
            );

  if (FAILED(hr))
  {
    ReportError(dwErr, IDS_FAILED_TO_GETNWUSERINFO, hwndFrame);
    return FALSE;
  }

  //
  // get the path of user's NetWare login script file
  //
  LONG lErr = GetLoginScriptFilePath(m_cstrLoginScriptFileName);
  if (lErr != NERR_Success)
  {
    ReportError(lErr, IDS_FAILED_TO_GETNWLOGINSCRIPTFILE, hwndFrame);
    return FALSE;
  }

  //
  // get the toxic waste dump string from the user object, and parse it
  //
  hr = ReadUserParms(m_pDsObj, m_cstrUserParms);
  if (FAILED(hr))
  {
    ReportError(hr, IDS_FAILED_TO_GETUSERPARMS, hwndFrame);
    return FALSE;
  }

  ParseUserParms();

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::GetLoginScriptFilePath
//
//  Synopsis:   Calculate the path of user's login script file. 
//
//-----------------------------------------------------------------------------
LONG
CDsFPNWPage::GetLoginScriptFilePath(
    OUT CStr&   cstrLoginScriptFilePath
)
{
  LONG err = NERR_Success;
  PFPNWVOLUMEINFO lpnwVolumeInfo ;

  cstrLoginScriptFilePath.Empty();

  err = m_pfnFPNWVolumeGetInfo(
                          m_pwzPDCName,
                          SYSVOL_NAME_STRING,
                          1,
                          reinterpret_cast<LPBYTE *>(&lpnwVolumeInfo));

  if (NERR_Success == err) {

    CStr cstrSysVol = lpnwVolumeInfo->lpPath;
    m_pfnFpnwApiBufferFree(lpnwVolumeInfo);

    if (cstrSysVol.Right(1) != _T('\\'))
      cstrSysVol += _T("\\");

    if ( !m_pwzPDCName || !(*m_pwzPDCName) ) {
      cstrLoginScriptFilePath.Format(
        _T("%s%s%x%s"),
        static_cast<LPCTSTR>(cstrSysVol), 
        SZ_MAIL_DIR, 
        m_dwSwappedObjectID,
        SZ_LOGIN_FILE);
    } else {
      cstrLoginScriptFilePath.Format(
        _T("%s\\%s%s%x%s"),
        m_pwzPDCName,
        static_cast<LPCTSTR>(cstrSysVol), 
        SZ_MAIL_DIR, 
        m_dwSwappedObjectID,
        SZ_LOGIN_FILE);

      int index = cstrLoginScriptFilePath.Find(_T(':'));
      if (-1 != index)
        cstrLoginScriptFilePath.SetAt(index, _T('$'));
    }
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::ParseUserParms
//
//  Synopsis:   Parse each field of the waste dump string, 
//              and assign values to appropriate members in the class instance. 
//
//-----------------------------------------------------------------------------
void
CDsFPNWPage::ParseUserParms()
{
  if (!m_cstrUserParms.IsEmpty()) {
    PVOID pBuffer = NULL;
    WORD  nLength = 0;
    bool  fFound = false;

    QueryUserProperty(m_cstrUserParms, 
                      NWPASSWORD, 
                      &pBuffer, 
                      &nLength, 
                      &m_bMaintainNetwareLogin);
    
    if (m_bMaintainNetwareLogin) {
      LocalFree(pBuffer);

      QueryNWPasswordExpired(m_cstrUserParms, m_dwMaxPasswdAge, &m_bNetwarePasswordExpired);

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            GRACELOGINALLOWED, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        m_ushGraceLoginLimit = (USHORT)(fFound? 
                               (*(static_cast<USHORT *>(pBuffer))) : 
                               DEFAULT_GRACELOGINALLOWED);
        if (fFound)
          LocalFree(pBuffer);
      }

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            GRACELOGINREMAINING, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        m_ushGraceLoginsRemaining = (USHORT)(fFound? 
                                    (*(static_cast<USHORT *>(pBuffer))) : 
                                    DEFAULT_GRACELOGINREMAINING);
        if (fFound)
          LocalFree(pBuffer);
      }
      m_bLimitGraceLogins = (m_ushGraceLoginsRemaining != NO_GRACE_LOGIN_LIMIT);

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            MAXCONNECTIONS, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        m_ushConnectionLimit = (USHORT)(fFound? 
                               (*(static_cast<USHORT *>(pBuffer))) : 
                               NO_LIMIT);
        if (fFound)
          LocalFree(pBuffer);
      }
      m_bLimitConnections = (m_ushConnectionLimit != NO_LIMIT);

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            NWHOMEDIR, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        if (fFound) {
          //
          // NWHOMEDIR is in single CHAR format, convert it to WCHAR
          //
          m_cstrHmDirRelativePath = static_cast<LPCSTR>(pBuffer);
          LocalFree(pBuffer);
        }
      }

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            NWLOGONFROM, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        if (fFound) {
          //
          // NWLOGONFROM is in single CHAR format, convert it to WCHAR
          //
          m_cstrLogonFrom = static_cast<LPCSTR>(pBuffer);
          m_cstrNewLogonFrom = m_cstrLogonFrom;
          LocalFree(pBuffer);
        }
      }

    }
  }

}



HRESULT
WideCharToMultiByteHelper(
   const CStr& str,
   char*       buffer,
   int         bufferSize,
   int&        result)
{
   ASSERT(!str.IsEmpty());

   HRESULT hr = S_OK;

   result = 
      ::WideCharToMultiByte(
         CP_ACP,
         0,
         str,
         str.GetLength(),
         buffer,
         static_cast<int>(bufferSize),
         0,
         0);
   if (!result)
   {
      DWORD err = ::GetLastError();
      hr = HRESULT_FROM_WIN32(err);
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



// Caller must call delete[] on the result

HRESULT
ConvertWideStringToAnsiString(
   const CStr& wide,
   PSTR&       ansi,
   int&        ansiLengthInBytes)
{
   ansi              = 0;
   ansiLengthInBytes = 0;

   HRESULT hr = S_OK;      

   do
   {
      if (wide.IsEmpty())
      {
         break;
      }

      hr =
         WideCharToMultiByteHelper(
            wide,
            0,
            0,
            ansiLengthInBytes);
      if (FAILED(hr))
      {
         break;
      }

      ansiLengthInBytes++;

      ansi = new CHAR[ansiLengthInBytes];
      if (!ansi)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      memset(ansi, 0, ansiLengthInBytes);

      // convert unicode value to ansi

      int written = 0;
      hr =
         ::WideCharToMultiByteHelper(
            wide,
            ansi,
            ansiLengthInBytes,
            written);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(written == ansiLengthInBytes - 1);
   }
   while (0);

   return hr;
}



// Helper for UpdateUserParams.

HRESULT
CDsFPNWPage::UpdateUserParamsStringValue(
   PCWSTR      propertyName,
   const CStr& propertyValue)
{
   ASSERT(propertyName);

   HRESULT hr = S_OK;

   // Convert the unicode value into ansi, then stuff the result into a
   // UNICODE_STRING structure, where the Length field is the length in bytes
   // of the ansi representation.

   char* ansiValue = 0;

   do
   {
      // determine length of ansi representation, in bytes.

      int byteLength = 0;
      hr =
         ConvertWideStringToAnsiString(
            propertyValue,
            ansiValue,
            byteLength);
      if (FAILED(hr))
      {
         break;
      }

      UNICODE_STRING us;
      us.Buffer        = reinterpret_cast<PWSTR>(ansiValue);
      us.Length        = static_cast<USHORT>(byteLength);   
      us.MaximumLength = static_cast<USHORT>(byteLength);

      LONG err = SetUserProperty(m_cstrUserParms, propertyName, us);
      hr = HRESULT_FROM_WIN32(err);
   }
   while (0);

   delete[] ansiValue;

   return hr;
}




//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::UpdateUserParms
//
//  Synopsis:   Update the waste dump string with the new values 
//              user has specified on the FPNW property page 
//
//-----------------------------------------------------------------------------
bool
CDsFPNWPage::UpdateUserParms(IN DWORD dwFPNWFields)
{
  HRESULT hr = S_OK;
  LONG err = NERR_Success;
  UNICODE_STRING uniPropertyValue;

  uniPropertyValue.Buffer = NULL;
  uniPropertyValue.Length = 0;
  uniPropertyValue.MaximumLength = 0;

  if (dwFPNWFields & FPNW_FIELDS_NWPASSWORD) {
    if (!m_bMaintainNetwareLogin) {
      //
      // remove all FPNW fields from the waste dump, and return
      //
      if ( ((err = RemoveUserProperty(m_cstrUserParms, NWPASSWORD)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, NWTIMEPASSWORDSET)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, GRACELOGINALLOWED)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, GRACELOGINREMAINING)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, MAXCONNECTIONS)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, NWHOMEDIR)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, NWLOGONFROM)) != NERR_Success) )
      {
        FPNW_CHECK_RETURN(FALSE, err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
      }

      SetUserFlag(m_pDsObj, FALSE, UF_MNS_LOGON_ACCOUNT);

      return (err == NERR_Success);

    } else {

      hr = SetUserPassword(m_pDsObj, m_cstrNWPassword);
      
      if (SUCCEEDED(hr))
        hr = SetUserFlag(m_pDsObj, TRUE, UF_MNS_LOGON_ACCOUNT);

      if (FAILED(hr)) {
        ReportError(hr, IDS_FAILED_TO_ENABLE_NWUSER, m_hPage);
        return FALSE;
      } else {
        //
        // Encrypt the Netware password user has typed in,
        // set it in the waste dump, and reset the expired flag
        // to be FALSE
        //

        err = SetNetWareUserPassword(
                  m_cstrUserParms,
                  m_pwzSecretKey,
                  m_dwObjectID,
                  m_cstrNWPassword,
                  m_pfnReturnNetwareForm);

        FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);

        // JonN 5/24/00 101819
        // only set this to false if the user did not explicitly request true
        if ( !(FPNW_FIELDS_NWTIMEPASSWORDSET & dwFPNWFields) )
        {
          m_bNetwarePasswordExpired = false;
          dwFPNWFields |= FPNW_FIELDS_NWTIMEPASSWORDSET;
        }
      }

    }
  }

  if (dwFPNWFields & FPNW_FIELDS_NWTIMEPASSWORDSET) {
    err = ResetNetWareUserPasswordTime(
              m_cstrUserParms,
              m_bNetwarePasswordExpired);

    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }
  
  if (dwFPNWFields & FPNW_FIELDS_GRACELOGINALLOWED) {
    uniPropertyValue.Buffer = &m_ushGraceLoginLimit;
    uniPropertyValue.Length = sizeof(m_ushGraceLoginLimit);
    uniPropertyValue.MaximumLength = sizeof(m_ushGraceLoginLimit);
    err = SetUserProperty(m_cstrUserParms, GRACELOGINALLOWED, uniPropertyValue);
    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }

  if (dwFPNWFields & FPNW_FIELDS_GRACELOGINREMAINING) {
    uniPropertyValue.Buffer = &m_ushGraceLoginsRemaining;
    uniPropertyValue.Length = sizeof(m_ushGraceLoginsRemaining);
    uniPropertyValue.MaximumLength = sizeof(m_ushGraceLoginsRemaining);
    err = SetUserProperty(m_cstrUserParms, GRACELOGINREMAINING, uniPropertyValue);
    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }

  if (dwFPNWFields & FPNW_FIELDS_MAXCONNECTIONS) {
    uniPropertyValue.Buffer = &m_ushConnectionLimit;
    uniPropertyValue.Length = sizeof(m_ushConnectionLimit);
    uniPropertyValue.MaximumLength = sizeof(m_ushConnectionLimit);
    err = SetUserProperty(m_cstrUserParms, MAXCONNECTIONS, uniPropertyValue);
    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }

  if (dwFPNWFields & FPNW_FIELDS_NWHOMEDIR) {
    if (m_cstrHmDirRelativePath.IsEmpty()) {
      err = RemoveUserProperty(m_cstrUserParms, NWHOMEDIR);
      FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
    } else {

      hr = UpdateUserParamsStringValue(NWHOMEDIR, m_cstrHmDirRelativePath);
      if (FAILED(hr))
      {
        ReportError(hr, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage);
        return FALSE;
      }
    }
  }

  if (dwFPNWFields & FPNW_FIELDS_LOGONFROM) {
    if (m_cstrLogonFrom.IsEmpty()) {
      err = RemoveUserProperty(m_cstrUserParms, NWLOGONFROM);
      FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
    } else {

      hr = UpdateUserParamsStringValue(NWLOGONFROM, m_cstrLogonFrom);
      if (FAILED(hr))
      {
        ReportError(hr, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage);
        return FALSE;
      }
    }
  }

  return (err == NERR_Success);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWPasswordDlg
//
//  Synopsis:   Pop up a dialog for specifying the Password for 
//              NetWare Compatible User. 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWPasswordDlg()
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_PASSWORD), 
              m_hPage, 
              (DLGPROC)FPNWPasswordDlgProc, 
              reinterpret_cast<LPARAM>(this)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWPasswordDlgProc
//
//  Synopsis:   The password dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
FPNWPasswordDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  CDsFPNWPage * pPage = reinterpret_cast<CDsFPNWPage *>(GetWindowLongPtr(hDlg, DWLP_USER));

  switch (uMsg)
  {
  case WM_INITDIALOG:
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    pPage = reinterpret_cast<CDsFPNWPage *>(lParam);
    SetWindowText(GetDlgItem(hDlg, IDC_FPNWPASSWORD_USERNAME), pPage->m_cstrUserName);
    SendDlgItemMessage(hDlg, IDC_FPNWPASSWORD_EDIT1, 
                       EM_LIMITTEXT, MIN_PASS_LEN_MAX, 0);
    SendDlgItemMessage(hDlg, IDC_FPNWPASSWORD_EDIT2, 
                       EM_LIMITTEXT, MIN_PASS_LEN_MAX, 0);
    return TRUE;
  case WM_HELP:
      return pPage->OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
  case WM_COMMAND:
    if ( BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam) ) {
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
        {
          TCHAR szPW1[MIN_PASS_LEN_MAX + 1], szPW2[MIN_PASS_LEN_MAX + 1];

          ZeroMemory(szPW1, sizeof(szPW1));
          ZeroMemory(szPW2, sizeof(szPW2));

          UINT cchPW1 = GetDlgItemText(hDlg, 
                                       IDC_FPNWPASSWORD_EDIT1, 
                                       szPW1, 
                                       MIN_PASS_LEN_MAX);
          UINT cchPW2 = GetDlgItemText(hDlg, 
                                       IDC_FPNWPASSWORD_EDIT2, 
                                       szPW2, 
                                       MIN_PASS_LEN_MAX);

          if ( (cchPW1 < pPage->m_dwMinPasswdLen) || 
               (cchPW2 < pPage->m_dwMinPasswdLen) || 
               _tcscmp(szPW1, szPW2) ) {
            ErrMsg(IDS_ERRMSG_PW_MATCH, hDlg);
            SetDlgItemText(hDlg, IDC_FPNWPASSWORD_EDIT1, _T(""));
            SetDlgItemText(hDlg, IDC_FPNWPASSWORD_EDIT2, _T(""));
            SetFocus(GetDlgItem(hDlg, IDC_FPNWPASSWORD_EDIT1));
          } else {
            pPage->m_cstrNWPassword = szPW1;
            EndDialog(hDlg, IDOK);
          }
        }
        break;
      case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;
      default:
        break;
      }
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWLoginScriptDlg
//
//  Synopsis:   Pop up the dialog once the Login Script button is clicked 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWLoginScriptDlg()
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_LOGIN_SCRIPT), 
              m_hPage, 
              (DLGPROC)FPNWLoginScriptDlgProc, 
              reinterpret_cast<LPARAM>(this)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWLoginScriptDlgProc
//
//  Synopsis:   The Login Script dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK 
FPNWLoginScriptDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  CDsFPNWPage * pPage = reinterpret_cast<CDsFPNWPage *>(GetWindowLongPtr(hDlg, DWLP_USER));

  switch (uMsg)
  {
  case WM_INITDIALOG:
    {
      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
      pPage = reinterpret_cast<CDsFPNWPage *>(lParam);

      pPage->m_bLoginScriptChanged = false; // reset this flag

      HWND hEdit = GetDlgItem(hDlg, IDC_FPNWLOGINSCRIPT_EDIT);
      if (pPage->m_pLoginScriptBuffer) {
        SetWindowText(hEdit, static_cast<LPCTSTR>(pPage->m_pLoginScriptBuffer));
      } else {
        LoadLoginScriptTextFromFile(hEdit, pPage->m_cstrLoginScriptFileName);
      }

      return FALSE;
    }
  case WM_HELP:
      return pPage->OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
  case WM_COMMAND:
    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
    case BN_CLICKED:
      {
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
          {
            if (pPage->m_bLoginScriptChanged) {
              //
              // get the new login script text into the buffer
              //
              if (pPage->m_pLoginScriptBuffer)
                LocalFree(pPage->m_pLoginScriptBuffer);

              HWND hEdit = GetDlgItem(hDlg, IDC_FPNWLOGINSCRIPT_EDIT);
              int nTextLength = GetWindowTextLength(hEdit) + 1;
              pPage->m_pLoginScriptBuffer = LocalAlloc(LPTR, nTextLength * sizeof(WCHAR));
                
              if (pPage->m_pLoginScriptBuffer)
              {
                nTextLength = GetWindowText(
                                  hEdit, 
                                  static_cast<LPTSTR>(pPage->m_pLoginScriptBuffer), 
                                  nTextLength);
                pPage->m_dwBytesToWrite = (nTextLength + 1)* sizeof(WCHAR);
              } else {
                ReportError(ERROR_NOT_ENOUGH_MEMORY, 0, hDlg);
              }
            }

            EndDialog(hDlg, IDOK);
          }
          break;
        case IDCANCEL:
          EndDialog(hDlg, IDCANCEL);
          break;
        default:
          break;
        }
        break;
      }
    case EN_SETFOCUS:
      {
        SendMessage (reinterpret_cast<HWND>(lParam), EM_SETSEL, 0, 0);
      }
      break;
    case EN_CHANGE:
      {
        pPage->m_bLoginScriptChanged = TRUE; // raise the flag
      }
      break;
    default:
      break;
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWLogonDlg
//
//  Synopsis:   Pop up the dialog once the Advanced button is clicked 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWLogonDlg()
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_LOGON), 
              m_hPage, 
              (DLGPROC)FPNWLogonDlgProc, 
              reinterpret_cast<LPARAM>(this)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWLogonDlgProc
//
//  Synopsis:   The Logon dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK 
FPNWLogonDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  CDsFPNWPage * pPage = reinterpret_cast<CDsFPNWPage *>(GetWindowLongPtr(hDlg, DWLP_USER));
  HWND hlvAddress = GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS);

  switch (uMsg)
  {
  case WM_INITDIALOG:
    {
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
    pPage = reinterpret_cast<CDsFPNWPage *>(lParam);
    SetWindowText(GetDlgItem(hDlg, IDC_FPNWLOGON_USERNAME), pPage->m_cstrUserName);
    
    BOOL bLogonFromIsEmpty = pPage->m_cstrNewLogonFrom.IsEmpty();
    CheckRadioButton( hDlg, 
                      IDC_FPNWLOGON_ALL, 
                      IDC_FPNWLOGON_SELECTED,
                      bLogonFromIsEmpty ? IDC_FPNWLOGON_ALL : IDC_FPNWLOGON_SELECTED );
    EnableWindow(hlvAddress, !bLogonFromIsEmpty);

    LV_COLUMN col;
    RECT      rect;
    LONG      width;
    CStr      cstrText;

    ZeroMemory(&rect, sizeof(rect));
    GetWindowRect(hlvAddress, &rect);
    width = rect.right - rect.left - 4; // -4 to prevent the horizontal scrollbar from appearing

    ZeroMemory(&col, sizeof(col));
    col.mask = LVCF_TEXT | LVCF_WIDTH;
    col.cx = width/2;
    cstrText.LoadString(g_hInstance, IDS_FPNWLOGON_NETWORKADDR);
    col.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrText));
    ListView_InsertColumn(hlvAddress, 0, &col);
    col.cx = width/2;
    cstrText.LoadString(g_hInstance, IDS_FPNWLOGON_NODEADDR);
    col.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrText));
    ListView_InsertColumn(hlvAddress, 1, &col);

    DisplayFPNWLogonSelected(hlvAddress, pPage->m_cstrNewLogonFrom);

    EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADD), !bLogonFromIsEmpty);
    EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), !bLogonFromIsEmpty);

    return TRUE;
    }
  case WM_HELP:
      return pPage->OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
  case WM_COMMAND:
    if ( BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam) ) {
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
        {
          // update pPage->m_cstrNewLogonFrom
          pPage->m_cstrNewLogonFrom.Empty();

          if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FPNWLOGON_SELECTED))
          {
            CStr cstrAllNodes;
            cstrAllNodes.LoadString(g_hInstance, IDS_ALL_NODES);

            TCHAR szBuffer[MAX_PATH + 1];
          
            int count = ListView_GetItemCount(hlvAddress);

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.mask = LVIF_TEXT;
            item.pszText = szBuffer;
            item.cchTextMax = sizeof(szBuffer);
            for (int i=0; i < count; i++) {
              item.iItem = i;
              item.iSubItem = 0;
              if (ListView_GetItem(hlvAddress, &item)) {
                pPage->m_cstrNewLogonFrom += CStr(szBuffer, NETWORKSIZE);

                item.iSubItem = 1;
                if (ListView_GetItem(hlvAddress, &item)) {
                  if (cstrAllNodes.CompareNoCase(szBuffer)) {
                    pPage->m_cstrNewLogonFrom += CStr(szBuffer, NODESIZE);
                  } else {
                    pPage->m_cstrNewLogonFrom += SZ_ALL_NODES_ADDR;
                  }
                }
              }
            }
          }

          EndDialog(hDlg, IDOK);
        }
        break;
      case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;
      case IDC_FPNWLOGON_ADD:
        {
          if (IDOK == pPage->DoFPNWLogonAddDlg(hDlg, hlvAddress)) {
            EnableWindow(
                GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), 
                ListView_GetItemCount(hlvAddress) );
          }
          break;
        }
      case IDC_FPNWLOGON_REMOVE:
        {
          int index = ListView_GetNextItem(
                          hlvAddress,
                          -1,
                          LVNI_SELECTED);
          if (index != -1) {
            ListView_DeleteItem(hlvAddress, index);

            if (ListView_GetItemCount(hlvAddress)) {
              //
              // set focus to the previous item
              //
              if (index)
                index--;

              ListView_SetItemState(hlvAddress, index, 
                LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED );
              ListView_RedrawItems(hlvAddress, index, index);
              SetFocus(hlvAddress);
              UpdateWindow(hlvAddress);
            } else {
              EnableWindow( GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), FALSE );
            }
          }

          break;
        }
      case IDC_FPNWLOGON_ALL:
        {
          CheckRadioButton( hDlg, 
                            IDC_FPNWLOGON_ALL, 
                            IDC_FPNWLOGON_SELECTED,
                            IDC_FPNWLOGON_ALL );
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS), FALSE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADD), FALSE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), FALSE);
          break;
        }
      case IDC_FPNWLOGON_SELECTED:
        {
          CheckRadioButton( hDlg, 
                            IDC_FPNWLOGON_ALL, 
                            IDC_FPNWLOGON_SELECTED,
                            IDC_FPNWLOGON_SELECTED );
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS), TRUE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADD), TRUE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), 
              ListView_GetItemCount(GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS)));
          break;
        }
      default:
        break;
      }
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWLogonAddDlg
//
//  Synopsis:   Pop up the dialog once the ADD button is clicked 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWLogonAddDlg(HWND hwndParent, HWND hlvAddress)
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_LOGON_ADDDLG), 
              hwndParent, 
              (DLGPROC)FPNWLogonAddDlgProc, 
              reinterpret_cast<LPARAM>(hlvAddress)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWLogonAddDlgProc
//
//  Synopsis:   The Logon Add dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK 
FPNWLogonAddDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  HWND hlvAddress = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

  switch (uMsg)
  {
  case WM_INITDIALOG:
    {
      SetWindowLongPtr(hDlg, DWLP_USER, lParam);

      SendMessage(GetDlgItem(hDlg, IDC_FPNWLOGONADD_NETWORKADDR), 
                  EM_LIMITTEXT, NETWORKSIZE, 0);
      SendMessage(GetDlgItem(hDlg, IDC_FPNWLOGONADD_NODEADDR), 
                  EM_LIMITTEXT, NODESIZE, 0);

      //
      // both edit controls use the same wndproc
      //
      g_fnOldEditCtrlProc = reinterpret_cast<WNDPROC>(
                                SetWindowLongPtr(
                                         GetDlgItem(hDlg, IDC_FPNWLOGONADD_NETWORKADDR),
                                         GWLP_WNDPROC, 
                                         reinterpret_cast<LONG_PTR>(HexEditCtrlProc)));
      SetWindowLongPtr(
          GetDlgItem(hDlg, IDC_FPNWLOGONADD_NODEADDR),
          GWLP_WNDPROC, 
          reinterpret_cast<LONG_PTR>(HexEditCtrlProc));

      return TRUE;
    }
  case WM_HELP:
    {
      LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
      if (pHelpInfo->iCtrlId >= 1)
          WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

      return TRUE;
    }
  case WM_COMMAND:
    if ( BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam) ) {
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
        {
          TCHAR tchNetworkAddr[NETWORKSIZE + 1], tchNodeAddr[NODESIZE + 1];
          int nNetworkAddr = 0, nNodeAddr = 0;

          ZeroMemory(tchNetworkAddr, sizeof(tchNetworkAddr));
          ZeroMemory(tchNodeAddr, sizeof(tchNodeAddr));

          nNetworkAddr = GetDlgItemText(
                             hDlg, 
                             IDC_FPNWLOGONADD_NETWORKADDR, 
                             tchNetworkAddr,
                             NETWORKSIZE+1);
          if (0 == nNetworkAddr) {
            // network address is required
            ErrMsg(IDS_ERRMSG_NETWORKADDR_REQUIRED, hDlg);
            break;
          } else {
            InsertZerosToHexString(tchNetworkAddr, NETWORKSIZE - nNetworkAddr);
          }

          nNodeAddr = GetDlgItemText(
                          hDlg, 
                          IDC_FPNWLOGONADD_NODEADDR, 
                          tchNodeAddr,
                          NODESIZE+1);
          
          if (nNodeAddr) {
            InsertZerosToHexString(tchNodeAddr, NODESIZE - nNodeAddr);
          } else {
            _tcsncpy(tchNodeAddr, SZ_ALL_NODES_ADDR, NODESIZE);
          }

          InsertLogonAddress(hlvAddress, tchNetworkAddr, tchNodeAddr);

          EndDialog(hDlg, IDOK);
          break;
        }
      case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;
      default:
        break;
      }
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   HexEditCtrlProc
//
//  Synopsis:   The subclassed edit control callback procedure. 
//              This edit control only allows hex input, paste is disabled. 
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK 
HexEditCtrlProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  switch (uMsg)
  {
  case WM_PASTE:
    {
      ::MessageBeep (0);
      return TRUE;
    }
  case WM_CHAR:
    {
      TCHAR chKey = static_cast<TCHAR>(wParam);
      if ((!iswxdigit(chKey)) &&
          (chKey != VK_BACK) &&
          (chKey != VK_DELETE) &&
          (chKey != VK_END) &&
          (chKey != VK_HOME) )
      {
          ::MessageBeep (0);
          return TRUE;
      }
    }
    break;
  default:
    break;
  }

  return CallWindowProc(g_fnOldEditCtrlProc, hwnd, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateFPNWPage
//
//  Synopsis:   Creates an instance of a page window for a user object.
//              This page is enabled if FPNW Global LsaSecret is defined in 
//              the domain where the user object belongs to. 
//
//-----------------------------------------------------------------------------

HRESULT
CreateFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
              PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
              DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
              HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateFPNWPage);

  LPWSTR pwzPDCName = NULL, pwzSecretKey = NULL;
  PWSTR pwzPath = NULL;
  HRESULT hr = S_OK;

  hr = SkipLDAPPrefix(pwzADsPath, pwzPath);
  if (FAILED(hr))
    goto cleanup;

  hr = GetPDCInfo(pwzPath, pwzPDCName, pwzSecretKey);
  if (FAILED(hr))
    goto cleanup;

  if (pwzSecretKey && *pwzSecretKey) {
    CDsFPNWPage * pPageObj = new CDsFPNWPage(pDsPage,
                                             pDataObj,
                                             hNotifyObj,
                                             dwFlags);
    if (!pPageObj) {
      hr = E_OUTOFMEMORY;
    } else {
      pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);
      pPageObj->InitPDCInfo(pwzPDCName, pwzSecretKey);
      if (pPageObj->InitFPNWUser()) {
        hr = pPageObj->CreatePage(phPage);
      } else {
        hr = S_FALSE;
      }
    }
  } else {
    hr = S_FALSE;
  }

cleanup:
  if (pwzPath)
    delete pwzPath;

  return hr;
}

/////////////////////////////////////////////////////////////////////
// Helper functions
//

//+----------------------------------------------------------------------------
//
//  Function:   ReadUserParms
//
//  Synopsis:   Retrieve the waste dump string from the user object
//
//-----------------------------------------------------------------------------
HRESULT
ReadUserParms(
    IN IDirectoryObject *pDsObj,
    OUT CStr&           cstrUserParms
)
{
  HRESULT hr = S_OK;
  PADS_ATTR_INFO pAttrs = NULL;
  DWORD cAttrs = 0;
  LPWSTR rgpwszAttrNames[] = {ATTR_USERPARMS};

  cstrUserParms.Empty();

  hr = pDsObj->GetObjectAttributes(
                  rgpwszAttrNames, 
                  sizeof(rgpwszAttrNames)/sizeof(rgpwszAttrNames[0]), 
                  &pAttrs, 
                  &cAttrs);

  if (FAILED(hr))
    return hr;

  if ( (cAttrs == 1) &&
       (pAttrs->dwADsType == ADSTYPE_CASE_IGNORE_STRING) ) {
    cstrUserParms = pAttrs->pADsValues->CaseIgnoreString;
  }

  if (pAttrs) 
    FreeADsMem(pAttrs);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   WriteUserParms
//
//  Synopsis:   Write the waste dump string back into the user object
//
//-----------------------------------------------------------------------------
HRESULT
WriteUserParms(
    IN IDirectoryObject *pDsObj,
    IN const CStr&      cstrUserParms
)
{
  DWORD         cModifiedIgnored = 0;
  ADS_ATTR_INFO aAttrs[1];
  ADSVALUE      Value;

  ZeroMemory(&Value, sizeof(Value));
  Value.dwType = ADSTYPE_CASE_IGNORE_STRING;
  Value.CaseIgnoreString = const_cast<LPWSTR>(static_cast<LPCWSTR>(cstrUserParms));

  ZeroMemory(&(aAttrs[0]), sizeof(aAttrs[0]));
  aAttrs[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
  aAttrs[0].pszAttrName = ATTR_USERPARMS;
  aAttrs[0].pADsValues = &Value;
  aAttrs[0].dwNumValues = 1;
  aAttrs[0].dwControlCode = ADS_ATTR_UPDATE;

  HRESULT hr = pDsObj->SetObjectAttributes(
                    aAttrs, 
                    sizeof(aAttrs)/sizeof(aAttrs[0]), 
                    &cModifiedIgnored);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetUserFlag
//
//  Synopsis:   Set userAccountControl on an user object. 
//              Add/remove bits specified in dwFlag.
//
//-----------------------------------------------------------------------------
HRESULT
SetUserFlag(
    IN IDirectoryObject *pDsObj,
    IN bool             bAction,
    IN DWORD            dwFlag
)
{
  HRESULT         hr = S_OK;
  PADS_ATTR_INFO  pAttrs = NULL;
  DWORD           cAttrs = 0;
  LPWSTR          rgpwszAttrNames[] = {ATTR_USERACCOUNTCONTROL};
  DWORD           dwValue = 0;
  DWORD           cModifiedIgnored = 0;
  PADSVALUE       pADsValue = NULL;

  hr = pDsObj->GetObjectAttributes(
                  rgpwszAttrNames, 
                  sizeof(rgpwszAttrNames)/sizeof(rgpwszAttrNames[0]), 
                  &pAttrs, 
                  &cAttrs);

  if (FAILED(hr))
    return hr;

  if ( (cAttrs != 1) ||
       (pAttrs->dwADsType != ADSTYPE_INTEGER) )
  {
    hr = E_FAIL;
    goto cleanup;
  }
  
  dwValue = pAttrs->pADsValues->Integer;

  if (bAction)
    dwValue |= dwFlag;
  else
    dwValue &= ~dwFlag;

  pADsValue = pAttrs->pADsValues;

  ZeroMemory(pADsValue, sizeof(*pADsValue));
  pADsValue->dwType = ADSTYPE_INTEGER;
  pADsValue->Integer = dwValue;

  ZeroMemory(pAttrs, sizeof(*pAttrs));
  pAttrs->dwADsType = ADSTYPE_INTEGER;
  pAttrs->pszAttrName = ATTR_USERACCOUNTCONTROL;
  pAttrs->pADsValues = pADsValue;
  pAttrs->dwNumValues = 1;
  pAttrs->dwControlCode = ADS_ATTR_UPDATE;

  hr = pDsObj->SetObjectAttributes(
                    pAttrs, 
                    1, 
                    &cModifiedIgnored);

cleanup:

  if (pAttrs) 
    FreeADsMem(pAttrs);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   QueryUserProperty
//
//  Synopsis:   Query the field in the waste dump string
//              The caller needs to call LocalFree() on the buffer afterwards.
//
//-----------------------------------------------------------------------------
LONG
QueryUserProperty(
    IN  LPCTSTR       lpszUserParms,
    IN  LPCTSTR       lpszPropertyName,
    OUT PVOID         *ppBuffer,
    OUT WORD          *pnLength,
    OUT bool          *pbFound
)
{
  ASSERT (lpszPropertyName != NULL);

  *pbFound = false;

  WCHAR PropertyFlag;
  UNICODE_STRING PropertyValue;

  PropertyValue.Buffer = NULL;
  PropertyValue.Length = 0;
  PropertyValue.MaximumLength = 0;

  LONG err = NERR_Success;
  NTSTATUS status = NetpParmsQueryUserProperty(
                        const_cast<LPWSTR>(lpszUserParms),
                        const_cast<LPWSTR>(lpszPropertyName),
                        &PropertyFlag,
                        &PropertyValue
                    );
  if (!NT_SUCCESS(status)) {
    err = NetpNtStatusToApiStatus(status);
  } else if (PropertyValue.Length) {
    *pbFound = TRUE;
    *ppBuffer = PropertyValue.Buffer; // the caller needs to call LocalFree()
    *pnLength = PropertyValue.Length;
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetUserProperty
//
//  Synopsis:   Set the field in the waste dump string
//
//-----------------------------------------------------------------------------
LONG
SetUserProperty(
    IN OUT CStr&       cstrUserParms,
    IN LPCTSTR         lpszPropertyName,
    IN UNICODE_STRING  uniPropertyValue
)
{
  ASSERT (lpszPropertyName != NULL);
  LONG err = NERR_Success;

  LPWSTR  lpNewUserParms = NULL;
  BOOL    fUpdate = false;
  NTSTATUS status = NetpParmsSetUserProperty (
                       const_cast<LPWSTR>(static_cast<LPCWSTR>(cstrUserParms)),
                       const_cast<LPWSTR>(lpszPropertyName),
                       uniPropertyValue,
                       USER_PROPERTY_TYPE_ITEM,
                       &lpNewUserParms,
                       &fUpdate
                   );

  if (!NT_SUCCESS(status)) {
    err = NetpNtStatusToApiStatus(status);
  } else if (fUpdate) {
    cstrUserParms = lpNewUserParms;
  }

  if (lpNewUserParms)
    NetpParmsUserPropertyFree(lpNewUserParms);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveUserProperty
//
//  Synopsis:   Remove the field from the waste dump string
//
//-----------------------------------------------------------------------------
LONG
RemoveUserProperty(
    IN OUT CStr& cstrUserParms, 
    IN LPCTSTR   lpszPropertyName
)
{
  UNICODE_STRING uniPropertyValue;

  uniPropertyValue.Buffer = NULL;
  uniPropertyValue.Length = 0;
  uniPropertyValue.MaximumLength = 0;

  return SetUserProperty(cstrUserParms, lpszPropertyName, uniPropertyValue);
}

//+----------------------------------------------------------------------------
//
//  Function:   QueryNWPasswordExpired
//
//  Synopsis:   Calculate whether the password expires or not
//
//-----------------------------------------------------------------------------
LONG
QueryNWPasswordExpired(
    IN LPCTSTR lpszUserParms, 
    IN DWORD   dwMaxPasswordAge,
    OUT bool   *pbExpired
)
{
  bool fFound = false;
  PVOID pBuffer = NULL;
  WORD nLength = 0;
  DWORD dwNWPasswordAge = 0;

  //
  // Query the current password age
  //
  LONG err = QueryUserProperty(
                           lpszUserParms, 
                           NWTIMEPASSWORDSET, 
                           &pBuffer, 
                           &nLength, 
                           &fFound);

  if ((NERR_Success == err) && fFound)
  {
    LARGE_INTEGER oldTime = *(reinterpret_cast<LARGE_INTEGER*>(pBuffer));

    LocalFree(pBuffer);

    if ((oldTime.LowPart == 0xffffffff) && 
        (oldTime.HighPart == 0xffffffff))
    {
      dwNWPasswordAge = 0xffffffff;
    } else {
      LARGE_INTEGER currentTime;
      NtQuerySystemTime (&currentTime);
      LARGE_INTEGER deltaTime ;

      deltaTime.QuadPart = currentTime.QuadPart - oldTime.QuadPart ;
      deltaTime.QuadPart /= NT_TIME_RESOLUTION_IN_SECOND;

      dwNWPasswordAge = deltaTime.LowPart;
    }
  }

  //
  // decide if the password expired
  //
  *pbExpired = (dwNWPasswordAge >= dwMaxPasswordAge);
  
  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   QueryDCforNCPLSASecretKey
//
//  Synopsis:   Query a domain controller for the Netware secret key
//
//-----------------------------------------------------------------------------
DWORD
QueryDCforNCPLSASecretKey(
    IN PCWSTR   pwzMachineName, 
    OUT LPWSTR& pwzNWSecretKey
)
{
  DWORD err = ERROR_SUCCESS;
  LSA_HANDLE hlsaPolicy = NULL;
  OBJECT_ATTRIBUTES oa;
  SECURITY_QUALITY_OF_SERVICE sqos;
  LSA_HANDLE hlsaSecret = NULL;
  UNICODE_STRING uMachineName, uSecretName;

  RtlInitUnicodeString( &uMachineName, pwzMachineName );
  RtlInitUnicodeString( &uSecretName, NCP_LSA_SECRET_KEY );

  ZeroMemory(&sqos, sizeof(sqos));
  sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
  sqos.ImpersonationLevel = SecurityImpersonation;
  sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
  sqos.EffectiveOnly = FALSE;

  InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );
  oa.SecurityQualityOfService = &sqos;

  err = RtlNtStatusToDosError(
          LsaOpenPolicy(&uMachineName, &oa, GENERIC_READ | GENERIC_EXECUTE, &hlsaPolicy) );

  if (ERROR_SUCCESS == err)
  {
    err = RtlNtStatusToDosError(
            LsaOpenSecret(hlsaPolicy, &uSecretName, SECRET_QUERY_VALUE, &hlsaSecret) );

    if (ERROR_SUCCESS == err) {
      UNICODE_STRING *puSecretValue = NULL;
      LARGE_INTEGER lintCurrentSetTime, lintOldSetTime;

      err = RtlNtStatusToDosError(
              LsaQuerySecret(hlsaSecret, &puSecretValue,
                    &lintCurrentSetTime, NULL, &lintOldSetTime) );

      if (ERROR_SUCCESS == err && puSecretValue)
      {
        memcpy(pwzNWSecretKey, puSecretValue->Buffer, NCP_LSA_SECRET_LENGTH);
        LsaFreeMemory( puSecretValue );
      }

      LsaClose( hlsaSecret );

    } else if (ERROR_FILE_NOT_FOUND == err) {

      err = ERROR_SUCCESS;

    }

    LsaClose( hlsaPolicy );
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetPDCInfo
//
//  Synopsis:   Given a user object path, get PDC in the domain and 
//              query it for the Netware secret key. 
//              Store the PDC name and the secret key in a cache
//              for efficiency reason.
//
//-----------------------------------------------------------------------------
HRESULT
GetPDCInfo(
    IN  PCWSTR  pwzPath,
    OUT LPWSTR& pwzPDCName,
    OUT LPWSTR& pwzSecretKey
)
{
  HRESULT hr = S_OK;
  DWORD dwErr = ERROR_SUCCESS;
  bool bRetry = false;
  PWSTR pwzDomain = NULL;
  PFPNWCACHE pElem = NULL;
  PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
  pwzSecretKey = NULL;
  Cache::iterator i;

  //
  // get the domain name where the user object belongs to
  //
  hr = CrackName(const_cast<PWSTR>(pwzPath), &pwzDomain, GET_DNS_DOMAIN_NAME);
  if (FAILED(hr))
    goto cleanup;

  ASSERT(pwzDomain);

  //
  // Lookup the secret key in the cache first
  //
  i = g_FPNWCache.find(pwzDomain);
  if (i != g_FPNWCache.end()) {
    pElem = (*i).second;
    if (pElem->dwError == ERROR_SUCCESS &&
       (pElem->pwzPDCName && pElem->pwzPDCName[0]) &&
       (pElem->wzSecretKey && pElem->wzSecretKey[0]) ) {
      pwzPDCName = pElem->pwzPDCName;
      pwzSecretKey = pElem->wzSecretKey;
      goto cleanup;
    } else {
      bRetry = true;
    }
  }

  //
  // not found in the cache or need to re-get it because of previous error
  //
  if (!bRetry)
  {
    pElem = static_cast<PFPNWCACHE>(LocalAlloc(LPTR, sizeof(FPNWCACHE)));
    if (!pElem)
    {
      hr = E_OUTOFMEMORY;
      goto cleanup;
    }
  }

  pwzSecretKey = pElem->wzSecretKey;
  dwErr = DsGetDcName(NULL, pwzDomain, NULL, NULL, 
              0, &pDCInfo);   // sburns for richardw: don't hit the PDC
  if (ERROR_SUCCESS == dwErr) 
  {
    ASSERT(pDCInfo);
    dwErr = QueryDCforNCPLSASecretKey(
                pDCInfo->DomainControllerName, 
                pwzSecretKey);
  
    pElem->pwzPDCName = static_cast<PWSTR>(LocalAlloc(LPTR, (lstrlen(pDCInfo->DomainControllerName) + 1) * sizeof(WCHAR)));
    if (pElem->pwzPDCName) 
    {
      _tcscpy(pElem->pwzPDCName, pDCInfo->DomainControllerName);
    }
    NetApiBufferFree(pDCInfo);

    if (pElem->pwzPDCName) {
      pwzPDCName = pElem->pwzPDCName;
      dwErr = QueryDCforNCPLSASecretKey(
                  pElem->pwzPDCName, 
                  pwzSecretKey);
    } else {
      FreeFPNWCacheElem(pElem);
      hr = E_OUTOFMEMORY;
      goto cleanup;
    }
  }
  pElem->dwError = dwErr;

  //
  // store the result in the cache
  //
  if (!bRetry)
    g_FPNWCache.insert(Cache::value_type(CStr(pwzDomain), pElem));

  hr = HRESULT_FROM_WIN32(dwErr);

cleanup:

  if (pwzDomain)
    LocalFreeStringW(&pwzDomain);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SkipLDAPPrefix
//
//  Synopsis:   Drop the "LDAP://server" prefix of an object path 
//
//-----------------------------------------------------------------------------
HRESULT
SkipLDAPPrefix(
    IN PCWSTR   pwzObj, 
    OUT PWSTR&  pwzResult
)
{
    CComPtr<IADsPathname> pADsPath;

    HRESULT hr = CoCreateInstance(
                     CLSID_Pathname, 
                     NULL, 
                     CLSCTX_INPROC_SERVER,
                     IID_IADsPathname, 
                     reinterpret_cast<void **>(&pADsPath));

    if (SUCCEEDED(hr)) {
      hr = pADsPath->Set(const_cast<PWSTR>(pwzObj), ADS_SETTYPE_FULL);
      if (SUCCEEDED(hr)) {
        BSTR bstr;
        hr = pADsPath->Retrieve(ADS_FORMAT_X500_DN, &bstr);
        if (SUCCEEDED(hr)) {
          if (!AllocWStr(bstr, &pwzResult))
            hr = E_OUTOFMEMORY;
          SysFreeString(bstr);
        }
      }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   InsertZerosToHexString
//
//  Synopsis:   Insert nTimes of 0's at the beginning of the hex string. 
//
//-----------------------------------------------------------------------------
void
InsertZerosToHexString(
    IN OUT LPTSTR lpszBuffer, 
    IN UINT       nTimes
)
{
  if (nTimes > 0) {
    TCHAR *pTmp, *pDest = NULL;

    for (pTmp = lpszBuffer + _tcslen(lpszBuffer); pTmp >= lpszBuffer; pTmp--) {
      pDest = pTmp + nTimes;
      *pDest = *pTmp;   
    }

    pTmp++;

    for ( ; pTmp < pDest; pTmp++) {
      *pTmp = _T('0');
    }
  }
}

//+----------------------------------------------------------------------------
//
//  Function:   InsertLogonAddress
//
//  Synopsis:   Insert the network/node address pair into the list view box. 
//
//-----------------------------------------------------------------------------
void
InsertLogonAddress(
    IN HWND     hlvAddress, 
    IN LPCTSTR  lpszNetworkAddr,
    IN LPCTSTR  lpszNodeAddr
)
{
  LV_ITEM item;

  ZeroMemory(&item, sizeof(item));
  item.mask = LVIF_TEXT;
  item.pszText = const_cast<LPTSTR>(lpszNetworkAddr);

  int index = ListView_InsertItem(hlvAddress, &item);

  if (index != -1) {
    if (_tcsicmp(lpszNodeAddr, SZ_ALL_NODES_ADDR)) {
      ListView_SetItemText(hlvAddress, index, 1, const_cast<LPTSTR>(lpszNodeAddr));
    } else {
      CStr cstrAllNodes;
      cstrAllNodes.LoadString(g_hInstance, IDS_ALL_NODES);
      ListView_SetItemText(hlvAddress, index, 1, const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrAllNodes)));
    }
  }

}

//+----------------------------------------------------------------------------
//
//  Function:   DisplayFPNWLogonSelected
//
//  Synopsis:   Parse the NWLOGONFROM string and insert 
//              each network/node address pair into the 
//              list view box. 
//
//-----------------------------------------------------------------------------
void
DisplayFPNWLogonSelected(
    IN HWND     hlvAddress,
    IN LPCTSTR  lpszLogonFrom
)
{
  LPTSTR ptr = NULL, tail = NULL;
  TCHAR szNetworkAddr[NETWORKSIZE + 1], szNodeAddr[NODESIZE + 1];

  ZeroMemory(szNetworkAddr, sizeof(szNetworkAddr));
  ZeroMemory(szNodeAddr, sizeof(szNodeAddr));

  ptr = const_cast<LPTSTR>(lpszLogonFrom);
  tail = ptr + _tcslen(ptr);

  while (ptr < tail) {
    _tcsncpy(szNetworkAddr, ptr, NETWORKSIZE);
    ptr += NETWORKSIZE;
    _tcsncpy(szNodeAddr, ptr, NODESIZE);
    ptr += NODESIZE;

    InsertLogonAddress(hlvAddress, szNetworkAddr, szNodeAddr);
  }
}

//+----------------------------------------------------------------------------
//
//  Function:   IsServiceRunning
//
//  Synopsis:   Return TRUE if the specified service is running on the machine. 
//
//-----------------------------------------------------------------------------
bool
IsServiceRunning(
    IN LPCTSTR lpMachineName,
    IN LPCTSTR lpServiceName
)
{
    DWORD dwStatus = 0;
    SC_HANDLE hScManager = NULL, hService = NULL;
    SERVICE_STATUS svcStatus;

    hScManager = OpenSCManager(lpMachineName, NULL, GENERIC_READ);
    hService = OpenService(hScManager, lpServiceName, GENERIC_READ);
    int iServiceStatus = QueryServiceStatus(hService, &svcStatus);

    if (hScManager && hService && iServiceStatus)
    {
      dwStatus = svcStatus.dwCurrentState;
    }

    if (hService)
      CloseServiceHandle(hService);
    if (hScManager)
      CloseServiceHandle(hScManager);

    return (SERVICE_RUNNING == dwStatus);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReadFileToBuffer
//
//  Synopsis:   Read a MBCS file to a MBCS or UNICODE buffer.
//              The caller needs to invoke LocalFree() on the buffer after use.
//
//-----------------------------------------------------------------------------
LONG
ReadFileToBuffer(
    IN  HANDLE hFile,
    IN  bool   bWideBuffer,
    OUT LPVOID *ppBuffer,    
    OUT DWORD  *pdwBytesRead
)
{
  LONG err = ERROR_SUCCESS;

  *ppBuffer = NULL;
  *pdwBytesRead = 0;
  
  do {
    DWORD dwFileSize = GetFileSize (hFile, NULL);
    if (dwFileSize == -1)
    {
        err = GetLastError();
        break;
    }

    if (dwFileSize == 0)
        break;

    LPSTR lpFile = static_cast<LPSTR>(LocalAlloc (LPTR, dwFileSize));
    if (!lpFile)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;
    }

    DWORD dwBytesRead;
    if (!ReadFile (hFile,
                   lpFile,
                   dwFileSize,
                   &dwBytesRead,
                   NULL))
    {
        err = GetLastError();
        LocalFree(lpFile);
        break;
    }

    ASSERT (dwBytesRead == dwFileSize);

    // Remove special end of file character added by editor.
    if (*(lpFile+dwBytesRead-2) == 13) {
      *(lpFile+dwBytesRead-2) = 0;
    }

    if (!bWideBuffer) {

      *ppBuffer = lpFile;
      *pdwBytesRead = dwBytesRead;
 
    } else {
  
      DWORD dwWideBuffer = (dwBytesRead+1)*sizeof (WCHAR);
      LPWSTR lpWideBuffer = static_cast<LPWSTR>(LocalAlloc (LPTR, dwWideBuffer));
    
      if (!lpWideBuffer) {
        err = ERROR_NOT_ENOUGH_MEMORY;
      } else {
        if (MultiByteToWideChar (CP_ACP,
                                  0,
                                  lpFile,
                                  dwBytesRead,
                                  lpWideBuffer,
                                  dwWideBuffer)) {
            *ppBuffer = lpWideBuffer;
            *pdwBytesRead = dwWideBuffer;
        } else {
            err = GetLastError();
        }
      }

      LocalFree (lpFile);
    }

  } while (FALSE);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   WriteBufferToFile
//
//  Synopsis:   Write a MBCS or UNICODE buffer to a MBCS file.
//
//-----------------------------------------------------------------------------
LONG
WriteBufferToFile(
    IN HANDLE hFile,
    IN bool   bWideBuffer,
    IN LPVOID pBuffer,    
    IN DWORD  dwBytesToWrite
)
{
  LONG err = ERROR_SUCCESS;
  LPSTR lpFile = static_cast<LPSTR>(pBuffer);

  do {
    if (bWideBuffer) {

      lpFile    = 0;
      int bytes = 0;
      HRESULT hr =
         ConvertWideStringToAnsiString(

            // 99721 
            // this will create a temporary CStr from pBuffer, which is a
            // waste, but is necessary to get the correct byte count for
            // the ansi form of the text (without changing the call
            // signatures of the functions leading to this point, which
            // seemed not worth it) 

            static_cast<PCWSTR>(pBuffer),
            lpFile,
            bytes);
      if (FAILED(hr))
      {
         err = HRESULT_CODE(hr);
         break;
      }

      dwBytesToWrite = bytes;
    }

    DWORD dwBytesWritten;
    if (!WriteFile (hFile,
                    lpFile,
                    dwBytesToWrite-1,  //don't write the last null character.
                    &dwBytesWritten,
                    NULL))
        err = GetLastError();

    ASSERT (dwBytesWritten == dwBytesToWrite-1);
  
    if (bWideBuffer)
    {
      delete[] lpFile;
    }

  } while (FALSE);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   OpenLoginScriptFileHandle
//
//  Synopsis:   Open the login script file handle appropriately.
//              The caller needs to call CloseHandle() afterwards.
//
//-----------------------------------------------------------------------------
LONG
OpenLoginScriptFileHandle(
    IN  LPTSTR lpszFileName,
    IN  int    iDirection,
    OUT HANDLE *phFile
)
{
  LONG err = ERROR_SUCCESS;
  HANDLE hFile = INVALID_HANDLE_VALUE;

  if (LOGIN_SCRIPT_FILE_READ == iDirection) { 
    //
    // open for read
    //
    hFile = CreateFile(lpszFileName, 
                              GENERIC_READ, 
                              FILE_SHARE_READ | FILE_SHARE_WRITE, 
                              NULL, 
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
      err = GetLastError();
      if ((err == ERROR_PATH_NOT_FOUND) || (err == ERROR_FILE_NOT_FOUND))
        err = NERR_Success; // this is ok, we'll create this file later
    } else {
      *phFile = hFile;
    }

  } else { 
    //
    // open for write
    //
    hFile = CreateFile(lpszFileName, 
                              GENERIC_WRITE, 
                              FILE_SHARE_WRITE, 
                              NULL, 
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
      err = GetLastError();
      if ((err == ERROR_PATH_NOT_FOUND) || (err == ERROR_FILE_NOT_FOUND)) {
        //
        // path not found. create dir now- strip off last component first.
        //
        TCHAR *p = _tcsrchr(lpszFileName, _T('\\'));
        if (p) {
          *p = _T('\0');

          if (!CreateDirectory(lpszFileName, NULL)) {
            err = GetLastError() ;

            *p = _T('\\'); // restore the '\'

          } else {
            
            *p = _T('\\'); // restore the '\'

            //
            // try again to create the file
            //
            hFile = CreateFile (lpszFileName,
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
            err = (hFile == INVALID_HANDLE_VALUE) ? GetLastError() : ERROR_SUCCESS;

          }
        }
      }
    }

    if (ERROR_SUCCESS == err)
      *phFile = hFile;

  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadLoginScriptTextFromFile
//
//  Synopsis:   Read the login script file into the edit box. 
//
//-----------------------------------------------------------------------------
LONG
LoadLoginScriptTextFromFile(
    IN HWND     hEdit,
    IN LPCTSTR  lpszFileName
)
{
  LONG err = ERROR_SUCCESS;
  HANDLE hFile = INVALID_HANDLE_VALUE;

  err = OpenLoginScriptFileHandle(
            const_cast<LPTSTR>(lpszFileName), 
            LOGIN_SCRIPT_FILE_READ, 
            &hFile);

  if ((ERROR_SUCCESS == err) && 
      (INVALID_HANDLE_VALUE != hFile)) 
  {
    PVOID pBuffer = NULL;
    DWORD dwBytesRead = 0;
    err = ReadFileToBuffer(hFile, TRUE, &pBuffer, &dwBytesRead);

    if ((ERROR_SUCCESS == err) && pBuffer) {
      SetWindowText(hEdit, static_cast<LPCTSTR>(pBuffer));
      LocalFree(pBuffer);
    }

    CloseHandle(hFile);
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   UpdateLoginScriptFile
//
//  Synopsis:   Write the buffer contents into the login script file.
//
//-----------------------------------------------------------------------------
LONG
UpdateLoginScriptFile(
    IN LPCTSTR   lpszFileName,
    IN PVOID    pBuffer,
    IN DWORD    dwBytesToWrite
)
{
  LONG err = ERROR_SUCCESS;
  HANDLE hFile = INVALID_HANDLE_VALUE;

  err = OpenLoginScriptFileHandle(
            const_cast<LPTSTR>(lpszFileName), 
            LOGIN_SCRIPT_FILE_WRITE, 
            &hFile);

  if ((ERROR_SUCCESS == err) && 
      (INVALID_HANDLE_VALUE != hFile)) 
  {
    err = WriteBufferToFile(hFile, TRUE, pBuffer, dwBytesToWrite);

    CloseHandle(hFile);
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetUserPassword
//
//  Synopsis:   Set user's password.
//
//-----------------------------------------------------------------------------
HRESULT
SetUserPassword(
    IN IDirectoryObject *pDsObj,
    IN PCWSTR           pwszPassword
)
{
  CComPtr<IADsUser> pADsUser;

  HRESULT hr = pDsObj->QueryInterface(IID_IADsUser, reinterpret_cast<void **>(&pADsUser));
  
  if (SUCCEEDED(hr))
    hr = pADsUser->SetPassword(const_cast<PWSTR>(pwszPassword));

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetAccountPolicyInfo
//
//  Synopsis:   Get allowed minimum password length and maximum password age.
//
//-----------------------------------------------------------------------------
void
GetAccountPolicyInfo(
    IN  PCTSTR pszServer,
    OUT PDWORD pdwMinPasswdLen,
    OUT PDWORD pdwMaxPasswdAge
)
{
  USER_MODALS_INFO_0 *pModals = NULL;

  *pdwMinPasswdLen = 0;
  *pdwMaxPasswdAge = static_cast<DWORD>(-1);

  if ( NERR_Success == NetUserModalsGet(pszServer, 0, reinterpret_cast<PBYTE *>(&pModals) ) )
  {
    *pdwMinPasswdLen = pModals->usrmod0_min_passwd_len;
    *pdwMaxPasswdAge = pModals->usrmod0_max_passwd_age;
  }
  
  if (pModals)
    NetApiBufferFree( reinterpret_cast<LPVOID>(pModals) );

  return;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNWUserInfo
//
//  Synopsis:   Get the user name and its NW style objectId. 
//
//-----------------------------------------------------------------------------
HRESULT
GetNWUserInfo(
    IN IDirectoryObject*    pDsObj,
    OUT CStr&               cstrUserName,
    OUT DWORD&              dwObjectID,
    OUT DWORD&              dwSwappedObjectID,
    IN  PMapRidToObjectId&  pfnMapRidToObjectId,
    IN  PSwapObjectId       pfnSwapObjectId
)
{
  ASSERT(pDsObj);

  HRESULT hr = S_OK;
  PADS_ATTR_INFO pAttrs = NULL;
  DWORD cAttrs = 0;
  LPWSTR rgpwszAttrNames[] = {ATTR_SAMACCOUNTNAME, ATTR_OBJECTSID};
  PADS_ATTR_INFO pAttrAccount = NULL, pAttrObjSid = NULL;
  PUCHAR psaCount = NULL;
  PDWORD pRid = NULL;
  PSID pObjSID = NULL;

  hr = pDsObj->GetObjectAttributes(
                  rgpwszAttrNames, 
                  sizeof(rgpwszAttrNames)/sizeof(rgpwszAttrNames[0]), 
                  &pAttrs, 
                  &cAttrs);

  if ( FAILED(hr) )
    return hr;

  if (cAttrs != 2)
  {
    hr = E_FAIL;
    goto cleanup;
  }

  if (_tcscmp(pAttrs[0].pszAttrName, rgpwszAttrNames[0]) == 0)
  {
    pAttrAccount = pAttrs; 
    pAttrObjSid = pAttrs + 1;
  } else {
    pAttrAccount = pAttrs + 1;
    pAttrObjSid = pAttrs;
  }

  if ( (pAttrAccount->dwADsType != ADSTYPE_CASE_IGNORE_STRING) ||
       (pAttrObjSid->dwADsType != ADSTYPE_OCTET_STRING) )
  {
    hr = E_FAIL;
    goto cleanup;
  }

  cstrUserName = pAttrAccount->pADsValues->CaseIgnoreString;

  pObjSID = new BYTE[pAttrObjSid->pADsValues->OctetString.dwLength];
  if (!pObjSID) {
    hr = E_OUTOFMEMORY;
    goto cleanup;
  }

  memcpy(pObjSID, 
         pAttrObjSid->pADsValues->OctetString.lpValue,
         pAttrObjSid->pADsValues->OctetString.dwLength);

  psaCount = GetSidSubAuthorityCount(pObjSID);
  pRid = GetSidSubAuthority(pObjSID, *psaCount - 1);
  if ( psaCount && pRid)
  {
    dwObjectID = pfnMapRidToObjectId(
                    *pRid, 
                    const_cast<LPWSTR>(static_cast<LPCWSTR>(cstrUserName)), 
                    TRUE, // TRUE in dsadmin snapin; FALSE in local usrmgr
                    FALSE // always pass in FALSE
                    );

    dwSwappedObjectID = (SUPERVISOR_USERID == dwObjectID) ? SUPERVISOR_USERID : (pfnSwapObjectId(dwObjectID));

  } else {
    hr = HRESULT_FROM_WIN32(GetLastError());
  }

  delete [] pObjSID;

cleanup:
  if (pAttrs) 
    FreeADsMem(pAttrs);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetNetWareUserPassword
//
//  Synopsis:   encrypt the pwd, and change NWPASSWORD field in userParms
//
//-----------------------------------------------------------------------------
LONG
SetNetWareUserPassword(
    IN OUT  CStr&           cstrUserParms,
    IN PCWSTR               pwzSecretKey,
    IN DWORD                dwObjectID,
    IN PCWSTR               pwzNewPassword,
    IN PReturnNetwareForm   pfnReturnNetwareForm
)
{
  LONG err = NERR_Success;
  TCHAR szEncryptedNWPassword[NWENCRYPTEDPASSWORDLENGTH];
  char pszNWSecretKey[NCP_LSA_SECRET_LENGTH + 1];

  ZeroMemory(pszNWSecretKey, sizeof(pszNWSecretKey));
  memcpy(pszNWSecretKey, pwzSecretKey, NCP_LSA_SECRET_LENGTH);
  NTSTATUS status = pfnReturnNetwareForm(
                        pszNWSecretKey,
                        dwObjectID,
                        pwzNewPassword,
                        reinterpret_cast<UCHAR *>(szEncryptedNWPassword)
                        );

  if (!NT_SUCCESS( status)) {
    err = NetpNtStatusToApiStatus(status);
  } else {
    UNICODE_STRING uniPropertyValue;
    uniPropertyValue.Buffer = szEncryptedNWPassword;
    uniPropertyValue.Length = NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);
    uniPropertyValue.MaximumLength = NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);
    err = SetUserProperty(cstrUserParms, NWPASSWORD, uniPropertyValue);
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   ResetNetWareUserPasswordTime
//
//  Synopsis:   change NWTIMEPASSWORDSET field in userParms
//
//-----------------------------------------------------------------------------
LONG
ResetNetWareUserPasswordTime(
    IN OUT  CStr&  cstrUserParms,
    IN      bool   bNetwarePasswordExpired
)
{
  LONG err = NERR_Success;

  LARGE_INTEGER currentTime;
  if (bNetwarePasswordExpired) {
      currentTime.HighPart = 0xffffffff;
      currentTime.LowPart = 0xffffffff;
  } else {
      NtQuerySystemTime (&currentTime);
  }

  UNICODE_STRING uniPropertyValue;
  uniPropertyValue.Buffer = reinterpret_cast<PWSTR>(&currentTime);
  uniPropertyValue.Length = sizeof(currentTime);
  uniPropertyValue.MaximumLength = sizeof(currentTime);
  err = SetUserProperty(cstrUserParms, NWTIMEPASSWORDSET, uniPropertyValue);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   ModifyNetWareUserPassword
//
//  Synopsis:   Exported in dsprop.lib
//      Called by dsadmin.dll to set NetWare enabled user's password
//      when NT password changes.
//
//-----------------------------------------------------------------------------
HRESULT
ModifyNetWareUserPassword(
    IN IADsUser*          pADsUser,
    IN PCWSTR             pwzADsPath,
    IN PCWSTR             pwzNewPassword
)
{
  CComPtr<IDirectoryObject> spDsObj;
  HRESULT hr = pADsUser->QueryInterface(IID_IDirectoryObject, reinterpret_cast<void **>(&spDsObj));
  if (FAILED(hr))
    return hr;

  // make sure the waste dump for fpnw user exist
  CStr cstrUserParms;
  hr = ReadUserParms(spDsObj, cstrUserParms);
  if (SUCCEEDED(hr))
  {
    PVOID pBuffer = NULL;
    WORD  nLength = 0;
    bool  bFound = FALSE;
    QueryUserProperty(cstrUserParms,
                      NWPASSWORD,
                      &pBuffer,
                      &nLength,
                      &bFound);
    if (bFound)
      LocalFree(pBuffer);

    hr = bFound ? S_OK : S_FALSE;
  }
  if (FAILED(hr))
    return hr;

  if (S_OK == hr)
  {
    // This is a NetWare enabled user

    // load fpnwclnt.dll
    HINSTANCE           hFPNWClntDll = NULL;
    PMapRidToObjectId   pfnMapRidToObjectId = NULL;
    PSwapObjectId       pfnSwapObjectId = NULL;
    PReturnNetwareForm  pfnReturnNetwareForm = NULL;
    
    hFPNWClntDll = LoadLibrary(SZ_FPNWCLNT_DLL);
    pfnMapRidToObjectId = reinterpret_cast<PMapRidToObjectId>(GetProcAddress(hFPNWClntDll, SZ_MAPRIDTOOBJECTID));
    pfnSwapObjectId = reinterpret_cast<PSwapObjectId>(GetProcAddress(hFPNWClntDll, SZ_SWAPOBJECTID));
    pfnReturnNetwareForm = reinterpret_cast<PReturnNetwareForm>(GetProcAddress(hFPNWClntDll, SZ_RETURNNETWAREFORM));

    if (!hFPNWClntDll || !pfnMapRidToObjectId || !pfnSwapObjectId || !pfnReturnNetwareForm)
    {
      hr = HRESULT_FROM_WIN32( GetLastError() );
    } 
    else 
    {

      // get secret key
      PWSTR pwzPath = NULL;
      hr = SkipLDAPPrefix(pwzADsPath, pwzPath);
      if (SUCCEEDED(hr))
      {
        PWSTR pwzPDCName = NULL, pwzSecretKey = NULL;
        hr = GetPDCInfo(pwzPath, pwzPDCName, pwzSecretKey);

        if (SUCCEEDED(hr))
        {
          // get object id
          CStr cstrUserName;
          DWORD dwObjectID = 0, dwSwappedObjectID = 0;
          hr = GetNWUserInfo(
                  spDsObj,
                  cstrUserName,       // OUT
                  dwObjectID,         // OUT
                  dwSwappedObjectID,  // OUT
                  pfnMapRidToObjectId,
                  pfnSwapObjectId
                  );

          if (SUCCEEDED(hr))
          {
            // change password in the userParms
            LONG err = SetNetWareUserPassword(
                      cstrUserParms,
                      pwzSecretKey,
                      dwObjectID,
                      pwzNewPassword,
                      pfnReturnNetwareForm);

            if (NERR_Success == err)
              err = ResetNetWareUserPasswordTime(cstrUserParms, false); // clear the expire flag

            hr = HRESULT_FROM_WIN32(err);

            // write userParms back to DS
            if (SUCCEEDED(hr))
              hr = WriteUserParms(spDsObj, cstrUserParms);
          }
        }
        if (pwzPath)
          delete pwzPath;
      }
    }

    if (hFPNWClntDll)
      FreeLibrary(hFPNWClntDll);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\ftinfo.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       ftinfo.h
//
//  Contents:   AD cross-forest trust pages.
//
//  Classes:    CFTInfo, CFTCollisionInfo
//
//  History:    05-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef FTINFO_H_GUARD
#define FTINFO_H_GUARD

//#ifdef __cplusplus
//extern "C" {
//#endif

// Exported entrypoints used by netdom to view/manipulate forest trust infos.
//
extern "C" INT_PTR WINAPI
DSPROP_DumpFTInfos(PCWSTR pwzLocalDomain, PCWSTR pwzTrust,
                   PCWSTR pwzUser, PCWSTR pwzPw);

extern "C" INT_PTR WINAPI
DSPROP_ToggleFTName(PCWSTR pwzLocalDc, PWSTR pwzTrust, ULONG iSel,
                    PCWSTR pwzUser, PCWSTR pwzPW);
//#ifdef __cplusplus
//}
//#endif // __cplusplus


//+----------------------------------------------------------------------------
//
//  Class:     FT_EXTRA_INFO
//
//  Purpose:   The PLSA_FOREST_TRUST_INFORMATION structure maintained by
//             CFTInfo is passed to LSA and cannot be extended. Hence this
//             class as a separate, parallel extension for storing state
//             internal to the trust admin tools.
//
//-----------------------------------------------------------------------------
class FT_EXTRA_INFO
{
public:
   FT_EXTRA_INFO(void) : _Status(Enabled), _fWasInConflict(false) {};
   ~FT_EXTRA_INFO(void) {};

   enum STATUS {
      Enabled,
      DisabledViaParentTLNDisabled,
      DisabledViaMatchingTLNEx,
      DisabledViaParentMatchingTLNEx,
      TLNExMatchesExistingDomain,
      Invalid
   };

   STATUS   _Status;
   bool     _fWasInConflict;
};

//+----------------------------------------------------------------------------
//
//  Class:     CFTInfo
//
//  Purpose:   Encapsulate the forest trust naming information.
//
//-----------------------------------------------------------------------------
class CFTInfo
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CFTInfo(void);
   CFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo);
   CFTInfo(CFTInfo & FTInfo);
   ~CFTInfo(void);

	const CFTInfo & operator= (const PLSA_FOREST_TRUST_INFORMATION pFTInfo);
   bool  SetFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo);
   void  DeleteFTInfo(void);
   ULONG GetCount(void) {return (_pFTInfo) ? _pFTInfo->RecordCount : 0;};
   bool  GetIndex(PCWSTR pwzName, ULONG & index);
   bool  GetDnsName(ULONG index, CStrW & strName);
   bool  GetNbName(ULONG index, CStrW & strName);
   bool  GetType(ULONG index, LSA_FOREST_TRUST_RECORD_TYPE & type);
   ULONG GetFlags(ULONG index);
   PLSA_FOREST_TRUST_INFORMATION GetFTInfo(void) {return _pFTInfo;};
   void  SetDomainState(void);
   bool  IsInConflict(void);
   void  ClearAnyConflict(void);
   void  ClearConflict(ULONG index);
   bool  IsConflictFlagSet(ULONG index);
   bool  SetAdminDisable(ULONG index);
   bool  SetConflictDisable(ULONG index);
   void  SetUsedToBeInConflict(ULONG index);
   bool  WasInConflict(ULONG index);
   bool  IsEnabled(ULONG index);
   void  ClearDisableFlags(ULONG index);
   bool  SetSidAdminDisable(ULONG index);
   bool  AnyChildDisabled(ULONG index);
   bool  IsParentDisabled(ULONG index);
   bool  IsTlnExclusion(ULONG index);
   bool  IsMatchingDomain(ULONG iTLN, ULONG index);
   bool  IsChildDomain(ULONG iParent, ULONG index);
   bool  IsChildName(ULONG iParent, PCWSTR pwzName);
   bool  GetTlnEditStatus(ULONG index, TLN_EDIT_STATUS & status);
   bool  AddNewExclusion(PCWSTR pwzName, ULONG & NewIndex);
   bool  RemoveExclusion(ULONG index);
   bool  IsNameTLNExChild(PCWSTR pwzName);
   bool  DisableDomain(ULONG index);
   bool  EnableDomain(ULONG index);
   FT_EXTRA_INFO::STATUS GetExtraStatus(ULONG index);
   bool  FindMatchingExclusion(ULONG index, ULONG & iExclusion, bool CheckParent = false);
   bool  IsDomainMatch(ULONG index);
   bool  FindSID(PCWSTR pwzSID, ULONG & index);

private:

   PLSA_FOREST_TRUST_INFORMATION _pFTInfo;
   FT_EXTRA_INFO               * _pExtraInfo;
};

//+----------------------------------------------------------------------------
//
//  Class:     CFTCollisionInfo
//
//  Purpose:   Encapsulate the forest trust collision information.
//
//-----------------------------------------------------------------------------
class CFTCollisionInfo
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CFTCollisionInfo(void);
   CFTCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo);
   ~CFTCollisionInfo(void);

   //operator PLSA_FOREST_TRUST_COLLISION_INFORMATION() {return _pFTCollisionInfo};
   const CFTCollisionInfo & operator= (const PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo);
   void  SetCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo);
   bool  IsInCollisionInfo(PCWSTR pwzName) {return false;};
   bool  IsInCollisionInfo(ULONG index);
   bool  GetCollisionName(ULONG index, CStrW & strName);
   bool  IsInConflict(void) {return _pFTCollisionInfo != NULL;};

private:
   PLSA_FOREST_TRUST_COLLISION_INFORMATION _pFTCollisionInfo;
};

typedef void (*LINE_COMPOSER)(CStrW & strOut, ULONG ulLineNum, PCWSTR pwzCol1,
                              PCWSTR pwzCol2, PCWSTR pwzCol3, PCWSTR pwzCol4);

//+----------------------------------------------------------------------------
//
//  Function:  FormatFTNames
//
//-----------------------------------------------------------------------------
void
FormatFTNames(CFTInfo & FTInfo, CFTCollisionInfo & ColInfo,
              LINE_COMPOSER pLineFcn, CStrW & strMsg);

//+----------------------------------------------------------------------------
//
//  Function:  SaveFTInfoAs
//
//  Synopsis:  Prompt the user for a file name and then save the FTInfo as a
//             text file.
//
//-----------------------------------------------------------------------------
void
SaveFTInfoAs(HWND hWnd, PCWSTR wzFlatName, PCWSTR wzDnsName,
             CFTInfo & FTInfo, CFTCollisionInfo & ColInfo);

void AddAsteriskPrefix(CStrW & strName);
void RemoveAsteriskPrefix(CStrW & strName);

#endif // FTINFO_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\fpnw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       fpnw.h
//
//--------------------------------------------------------------------------

#ifndef _FPNW_H_
#define _FPNW_H_

#include "crypt.h" // USER_SESSION_KEY_LENGTH
#include "fpnwapi.h" // FPNWVOLUMEINFO
#include <map>
using namespace std;

typedef struct _FPNWCACHE {
  DWORD             dwError;
  PWSTR             pwzPDCName;
  WCHAR             wzSecretKey[NCP_LSA_SECRET_LENGTH + 1];
} FPNWCACHE, * PFPNWCACHE;

typedef map<CStr, PFPNWCACHE> Cache;

typedef ULONG (* PMapRidToObjectId)(
    IN  DWORD   dwRid,
    IN  LPWSTR  pszUserName,
    IN  BOOL    fNTAS,
    IN  BOOL    fBuiltin );

typedef ULONG (* PSwapObjectId)(
    IN  ULONG   ulObjectId );

typedef NTSTATUS (* PReturnNetwareForm)(
    IN  LPCSTR  pszSecretValue,
    IN  DWORD   dwUserId,
    IN  LPCWSTR pchNWPassword,
    OUT UCHAR   *pchEncryptedNWPassword
    );

typedef DWORD (* PFPNWVolumeGetInfo)(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo
);

typedef DWORD (* PFpnwApiBufferFree)(
    IN  LPVOID pBuffer
);

/////////////////////////////////////////////////////////////////////////////
// CDsFPNWPage dialog

class CDsFPNWPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
  char szClass[32];
#endif

public:
  CDsFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);
  ~CDsFPNWPage();

public:
  LRESULT DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
  HRESULT OnInitDialog(LPARAM lParam);
  virtual LRESULT OnApply(void);
  LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
  int     DoFPNWPasswordDlg();
  int     DoFPNWLoginScriptDlg();
  int     DoFPNWLogonDlg();
  int     DoFPNWLogonAddDlg(HWND hwndParent, HWND hlvAddress);

  bool    InitFPNWUser();
  DWORD   LoadFPNWClntDll();
  LONG    GetLoginScriptFilePath(
      OUT CStr&   cstrLoginScriptFilePath
  );

  inline void InitPDCInfo(
      IN LPCWSTR lpszPDCName, 
      IN LPCWSTR lpwzSecretKey
  )
  { 
    m_pwzPDCName = (LPWSTR)lpszPDCName;
    m_pwzSecretKey = (LPWSTR)lpwzSecretKey; 
  };
  void    ParseUserParms();
  bool    UpdateUserParms(DWORD dwFPNWFields);

  HRESULT
  UpdateUserParamsStringValue(
    PCWSTR      propertyName,
    const CStr& propertyValue);

protected:
  CStr    m_cstrUserParms;
  LPWSTR  m_pwzPDCName;
  LPWSTR  m_pwzSecretKey;

  bool    m_bMaintainNetwareLogin;
  bool    m_bNetwarePasswordExpired;
  bool    m_bLimitGraceLogins;
  bool    m_bLimitConnections;
  USHORT  m_ushGraceLoginLimit;
  USHORT  m_ushGraceLoginsRemaining;
  USHORT  m_ushConnectionLimit;
  CStr    m_cstrHmDirRelativePath;

  HINSTANCE           m_hFPNWClntDll;
  PMapRidToObjectId   m_pfnMapRidToObjectId;
  PSwapObjectId       m_pfnSwapObjectId;
  PReturnNetwareForm  m_pfnReturnNetwareForm;
  PFPNWVolumeGetInfo  m_pfnFPNWVolumeGetInfo;
  PFpnwApiBufferFree  m_pfnFpnwApiBufferFree;

public:
  DWORD   m_dwMinPasswdLen;
  DWORD   m_dwMaxPasswdAge;

  CStr    m_cstrUserName;
  DWORD   m_dwObjectID;
  DWORD   m_dwSwappedObjectID;
  CStr    m_cstrNWPassword;
  CStr    m_cstrLogonFrom;
  CStr    m_cstrNewLogonFrom;

  CStr    m_cstrLoginScriptFileName;
  LPVOID  m_pLoginScriptBuffer;
  DWORD   m_dwBytesToWrite;
  bool    m_bLoginScriptChanged;
};

INT_PTR CALLBACK 
FPNWPasswordDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

INT_PTR CALLBACK 
FPNWLoginScriptDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

INT_PTR CALLBACK
FPNWLogonDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

INT_PTR CALLBACK
FPNWLogonAddDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

LRESULT CALLBACK 
HexEditCtrlProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

HRESULT
CreateFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
              PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
              DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
              HPROPSHEETPAGE * phPage);

// Helper functions
void
FreeFPNWCacheElem(
    PFPNWCACHE p
);

HRESULT
ReadUserParms(
    IN IDirectoryObject *pDsObj,
    OUT CStr&           cstrUserParms
);

HRESULT
WriteUserParms(
    IN IDirectoryObject *pDsObj,
    IN const CStr&      cstrUserParms
);

HRESULT
SetUserFlag(
    IN IDirectoryObject *pDsObj,
    IN bool             bAction,
    IN DWORD            dwFlag
);

LONG
QueryUserProperty(
    IN  LPCTSTR       lpszUserParms,
    IN  LPCTSTR       lpszPropertyName,
    OUT PVOID         *ppBuffer,
    OUT WORD          *pnLength,
    OUT bool          *pbFound
);

LONG
SetUserProperty(
    IN OUT CStr&       cstrUserParms,
    IN LPCTSTR         lpszPropertyName,
    IN UNICODE_STRING  uniPropertyValue
);

LONG
RemoveUserProperty (
    IN OUT CStr& cstrUserParms, 
    IN LPCTSTR   lpszPropertyName
);

LONG
QueryNWPasswordExpired(
    IN LPCTSTR lpszUserParms, 
    IN DWORD   dwMaxPasswordAge,
    OUT bool   *pbExpired
);

DWORD
QueryDCforNCPLSASecretKey(
    IN PCWSTR   pwzMachineName, 
    OUT LPWSTR& pwzSecretKey
);

HRESULT
GetPDCInfo(
    IN  PCWSTR  pwzPath,
    OUT LPWSTR& pwzPDCName,
    OUT LPWSTR& pwzSecretKey
);

HRESULT
SkipLDAPPrefix(
    IN PCWSTR   pwzObj, 
    OUT PWSTR&  pwzResult
);

void
InsertZerosToHexString(
    IN OUT LPTSTR lpszBuffer, 
    IN UINT       nTimes
);

void
InsertLogonAddress(
    IN HWND     hlvAddress, 
    IN LPCTSTR  lpszNetworkAddr,
    IN LPCTSTR  lpszNodeAddr
);

void
DisplayFPNWLogonSelected(
    IN HWND     hlvAddress,
    IN LPCTSTR  lpszLogonFrom
);

bool
IsServiceRunning(
    IN LPCTSTR lpMachineName,
    IN LPCTSTR lpServiceName
);

LONG
ReadFileToBuffer(
    IN  HANDLE hFile,
    IN  bool   bWideBuffer,
    OUT LPVOID *ppBuffer,    
    OUT DWORD  *pdwBytesRead
);

LONG
WriteBufferToFile(
    IN HANDLE hFile,
    IN bool   bWideBuffer,
    IN LPVOID pBuffer,    
    IN DWORD  dwBytesToWrite
);

LONG
OpenLoginScriptFileHandle(
    IN  LPTSTR lpszFileName,
    IN  int    iDirection,
    OUT HANDLE *phFile
);

LONG
LoadLoginScriptTextFromFile(
    IN HWND     hEdit,
    IN LPCTSTR  lpszFileName
);

LONG
UpdateLoginScriptFile(
    IN LPCTSTR  lpszFileName,
    IN PVOID    pBuffer,
    IN DWORD    dwBytesToWrite
);

HRESULT
SetUserPassword(
    IN IDirectoryObject *pDsObj,
    IN PCWSTR           pwszPassword
);

void
GetAccountPolicyInfo(
    IN  PCTSTR pszServer,
    OUT PDWORD pdwMinPasswdLen,
    OUT PDWORD pdwMaxPasswdAge
);

HRESULT
GetNWUserInfo(
    IN IDirectoryObject*    pDsObj,
    OUT CStr&               cstrUserName,
    OUT DWORD&              dwObjectID,
    OUT DWORD&              dwSwappedObjectID,
    IN  PMapRidToObjectId&  pfnMapRidToObjectId,
    IN  PSwapObjectId       pfnSwapObjectId
);

LONG
SetNetWareUserPassword(
    IN OUT  CStr&           cstrUserParms,
    IN PCWSTR               pwzSecretKey,
    IN DWORD                dwObjectID,
    IN PCWSTR               pwzNewPassword,
    IN PReturnNetwareForm   pfnReturnNetwareForm
);

LONG
ResetNetWareUserPasswordTime(
    IN OUT  CStr&  cstrUserParms,
    IN      bool   bNetwarePasswordExpired
);

#endif // _FPNW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\dsquery.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dsquery.cxx
//
//  Contents:
//
//  History:    07-May-97 JonN  copied from bitfield.cxx
//              31-Dec-97 JonN  Revamped using IADsPathname
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"

#include "qrybase.h" // CDSSearch

#ifdef DSADMIN

#define BreakOnFail(hr)  if ( FAILED(hr) ) { dspAssert( FALSE ); break; }
#define ReturnOnFail(hr) if ( FAILED(hr) ) { dspAssert( FALSE ); return hr; }


//+----------------------------------------------------------------------------
//
//  Function:   FillDNDropdown
//
//  Synopsis:   Fills in the dropdown listbox for DsQueryAttributeDN.
//
//  Notes:      For each entry in the dropdown listbox, the ItemData points to
//              a BSTR containing the X500 DN for this selection.  If the admin
//              chooses this item, just set the DN attribute to this value.
//              If this pointer is NULL then clear the attribute instead.
//
//              When you're finished with the combobox you will have to
//              free these strings.
//
//-----------------------------------------------------------------------------

HRESULT
FillDNDropdown( HWND hwnd,
                LPCWSTR lpcwszADsPathDirectory,
                LPCWSTR lpcwszTargetDesiredClass,
                LPCWSTR lpcwszCurrentDNValue,
                int     residBlankEntryDisplay)
{
	HRESULT hr = S_OK;

	PTSTR ptsz = NULL;

	if ( 0 != residBlankEntryDisplay )
	{
		if ( !LoadStringToTchar (residBlankEntryDisplay, &ptsz) )
		{
			ReportError(GetLastError(), 0, hwnd);
			return E_OUTOFMEMORY;
		}
	}

	// first add the empty string (attribute clear)
	int iIndex = ComboBox_AddString( hwnd, (NULL != ptsz) ? ptsz : L"" );
	if ( NULL != ptsz )
		delete [] ptsz;
	if ( 0 > iIndex )
	{
		hr = E_FAIL;
		ReturnOnFail(hr);
	}
	int iRetval = ComboBox_SetItemData(
		hwnd,
		iIndex,
		NULL );
	dspAssert( CB_ERR != iRetval );

	// now add the current setting if the attribute is not clear
	if ( NULL != lpcwszCurrentDNValue && L'\0' != *lpcwszCurrentDNValue )
	{
    CComBSTR sbstrRDN;
    hr = DSPROP_RetrieveRDN( lpcwszCurrentDNValue, &sbstrRDN );
    ReturnOnFail(hr);
		ASSERT( !!sbstrRDN );

		iIndex = ComboBox_AddString( hwnd, sbstrRDN );
		if ( 0 > iIndex )
		{
			hr = E_FAIL;
			ReturnOnFail(hr);
		}
		iRetval = ComboBox_SetItemData(
			hwnd,
			iIndex,
			::SysAllocString( lpcwszCurrentDNValue ) );
		dspAssert( CB_ERR != iRetval );
	}

	// Set initial selection
	iRetval = ComboBox_SetCurSel( hwnd, iIndex );
	dspAssert( CB_ERR != iRetval );

	// now add all of the objects of the specified class
	// in the specified container
	CDSSearch Search;
	Search.Init(lpcwszADsPathDirectory);
	CStr strFilterString;
	strFilterString.Format(L"(&(objectClass=%s))", lpcwszTargetDesiredClass);
	Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strFilterString));
	LPWSTR pAttrs[2] = {L"name",
	                    L"distinguishedName"};
	Search.SetAttributeList(pAttrs, 2);
	Search.SetSearchScope(ADS_SCOPE_ONELEVEL);
	hr = Search.DoQuery();
	while (SUCCEEDED(hr)) {
		hr = Search.GetNextRow();
		if (S_ADS_NOMORE_ROWS == hr)
		{
			hr = S_OK;
			break;
		}
		BreakOnFail(hr);

		ADS_SEARCH_COLUMN NameColumn, DistinguishedNameColumn;
		::ZeroMemory( &NameColumn, sizeof(NameColumn) );
		::ZeroMemory( &DistinguishedNameColumn, sizeof(DistinguishedNameColumn) );
		hr = Search.GetColumn (pAttrs[0], &NameColumn);
		BreakOnFail(hr);
		hr = Search.GetColumn (pAttrs[1], &DistinguishedNameColumn);
		BreakOnFail(hr);
		dspAssert( ADSTYPE_CASE_IGNORE_STRING == NameColumn.pADsValues->dwType );
		dspAssert( ADSTYPE_DN_STRING == DistinguishedNameColumn.pADsValues->dwType );

		// if the current value has already been added, don't add it twice
		if ( lstrcmpi( lpcwszCurrentDNValue,
		               DistinguishedNameColumn.pADsValues->DNString ) )
		{
			iIndex = ComboBox_AddString(
				hwnd, NameColumn.pADsValues->CaseIgnoreString );
			if ( 0 > iIndex )
			{
				hr = E_FAIL;
				BreakOnFail(hr);
			}
			iRetval = ComboBox_SetItemData(
				hwnd,
				iIndex,
				::SysAllocString( DistinguishedNameColumn.pADsValues->DNString ) );
			dspAssert( CB_ERR != iRetval );
		}
		Search.FreeColumn (&NameColumn);
		Search.FreeColumn (&DistinguishedNameColumn);
	}
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQueryAttributeDN
//
//  Synopsis:   Handles single-valued DN pointer to arbitrary object in a known
//              container.  Uses dropdown listbox.
//
//  Notes:      This function adds three parameters to the usual button-handler pfn.
//
//              iTargetLevelsUp and ppwszTargetLevelsBack are used to
//              locate the known container relative to the current container
//              if the attribute is currently clear.  DsQueryAttributeDN starts
//              with the current container, counts back iTargetLevelsUp containers,
//              then looks for subcontainer ppwszTargetLevelsBack.
//              CODEWORK It might be possible to simplify this mechanism by
//              starting at the naming context root if it is available.
//
//              pwzTargetClass is the class of the object to which the DN
//              pointer should be made to point.
//
//-----------------------------------------------------------------------------

HRESULT
DsQueryAttributeDN(CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                   LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp,
                   int iTargetLevelsUp, PWCHAR* ppwszTargetLevelsBack,
                   PWCHAR pwszTargetClass, int residBlankEntryDisplay)
{
	dspAssert( NULL != pPropPage && NULL != pAttrMap );

	HRESULT hr = S_OK;
	switch (DlgOp)
	{
	case fInit:
		DBG_OUT("DsQueryAttributeDN: fInit");
		{
			HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
			dspAssert( NULL != hwndCtrl );

			// JonN 7/2/99: disable if attribute not writable
			if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
				EnableWindow(hwndCtrl, FALSE);

			//
			// Determine the initial attribute value if any
			//
			LPWSTR pszCurrentDN = NULL;
			if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
			{
				dspAssert( NULL != pAttrInfo->pADsValues
						 && NULL != pAttrInfo->pADsValues->DNString );
				pszCurrentDN = pAttrInfo->pADsValues->DNString;
			}

			LPWSTR pcwstrThisObject = pPropPage->GetObjPathName();
			dspAssert(NULL != pcwstrThisObject);

			CComBSTR sbstr;
			hr = DSPROP_TweakADsPath(
			          pcwstrThisObject,
			          iTargetLevelsUp,
			          ppwszTargetLevelsBack,
			          &sbstr );
			BreakOnFail(hr);

			hr = FillDNDropdown( hwndCtrl,
			                     sbstr,
			                     pwszTargetClass,
			                     pszCurrentDN,
			                     residBlankEntryDisplay );
		}
		break;

	case fApply:
		DBG_OUT("DsQueryAttributeDN: fApply");
		{
			HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
			dspAssert( NULL != hwndCtrl );

			int iIndex = ComboBox_GetCurSel( hwndCtrl );
			if (0 > iIndex)
			{
				hr = E_FAIL;
				BreakOnFail(hr);
			}
			BSTR bstrTargetPath = (BSTR)ComboBox_GetItemData( hwndCtrl, iIndex );
			if ( NULL == bstrTargetPath || L'\0' == *bstrTargetPath )
			{
				pAttrInfo->pADsValues = NULL;
				pAttrInfo->dwNumValues = 0;
				pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
				break;
			}

			// transfer it to a "new"-allocated string
			LPWSTR pwszFinal = new WCHAR[ wcslen(bstrTargetPath)+1 ];
      if (pwszFinal != NULL)
      {
			  wcscpy( pwszFinal, bstrTargetPath );

			  PADSVALUE pADsValue;
			  pADsValue = new ADSVALUE;
			  if (NULL == pADsValue)
			  {
				  dspAssert(FALSE);
				  hr = E_OUTOFMEMORY;
				  break;
			  }
			  pAttrInfo->pADsValues = pADsValue;
			  pAttrInfo->dwNumValues = 1;
			  pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
			  pADsValue->dwType = pAttrInfo->dwADsType;
			  pADsValue->DNString = pwszFinal;
      }
      else
      {
        dspAssert(FALSE);
        hr = E_OUTOFMEMORY;
        break;
      }
		}
        break;

    case fOnCommand:
        DBG_OUT("DsQueryAttributeDN: fOnCommand");
        if (lParam == CBN_SELCHANGE)
            pPropPage->SetDirty();
        break;

    case fOnDestroy:
	DBG_OUT("DsQueryAttributeDN: fOnDestroy");
	// release itemdata associated with combobox items
	{
		HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
		dspAssert( NULL != hwndCtrl );
		while (0 < ComboBox_GetCount( hwndCtrl ))
		{
			BSTR bstrFirstItem = (BSTR)ComboBox_GetItemData( hwndCtrl, 0 );
			if (NULL != bstrFirstItem)
				::SysFreeString( bstrFirstItem );
			int iRetval = ComboBox_DeleteString( hwndCtrl, 0 );
			dspAssert( CB_ERR != iRetval );
		}
	}
	break;

    case fOnCallbackRelease:
	DBG_OUT("DsQueryAttributeDN: fOnCallbackRelease");
	break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQuerySite
//
//  Synopsis:   Handles single-valued DN pointer from Subnet to Site object,
//              or from SiteSettings to Site object.
//
//-----------------------------------------------------------------------------
HRESULT
DsQuerySite(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               2, NULL, L"site", 0 );
}


//+----------------------------------------------------------------------------
//
//  Function:   DsQueryInterSiteTransport
//
//  Synopsis:   Handles single-valued DN pointer from NTDS-Connection to
//              Inter-Site-Transport object
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryInterSiteTransport(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    static WCHAR* apwszLevelsBack[2] = {
        L"CN=Inter-Site Transports",
        (WCHAR*)NULL };
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               5, apwszLevelsBack, L"interSiteTransport", IDS_RPC );
}


//+----------------------------------------------------------------------------
//
//  Function:   DsQueryPolicy
//
//  Synopsis:  Handles single-valued DN pointer to Domain Policy object
//             Uses edit field for now
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryPolicy(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    static WCHAR* apwszLevelsBack[5] = {
        L"CN=Services",
        L"CN=Windows NT",
        L"CN=Directory Service",
        L"CN=Query-Policies",
        (WCHAR*)NULL };
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               5, apwszLevelsBack, L"queryPolicy", 0 );
}


/*
//+----------------------------------------------------------------------------
//
//  Function:   DsQueryFrsPrimaryMember
//
//  Synopsis:  Handles single-valued DN pointer to NTFRS-Member object
//             Uses edit field for now
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryFrsPrimaryMember(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               0, NULL, L"nTFRSMember" );
}
*/

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\listview.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       listview.cxx
//
//  Contents:   Classes for list view controls.
//
//  Classes:    CListViewBase, CSuffixesList
//
//  History:    01-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "listview.h"

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::CListViewBase
//
//-----------------------------------------------------------------------------
CListViewBase::CListViewBase(void) :
   _nID(0),
   _hParent(NULL),
   _hList(NULL)
{
}

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::SetStyles
//
//-----------------------------------------------------------------------------
void
CListViewBase::SetStyles(DWORD dwStyles, DWORD dwExtStyles)
{
   if (dwStyles)
   {
   }

   if (dwExtStyles)
   {
      ListView_SetExtendedListViewStyle(_hList, dwExtStyles);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::AddColumn
//
//-----------------------------------------------------------------------------
void
CListViewBase::AddColumn(int textID, int cx, int nID)
{
   CStrW strText;

   strText.LoadString(g_hInstance, textID);

   LV_COLUMN lvc;
   lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   lvc.fmt = LVCFMT_LEFT;
   lvc.cx = cx;
   lvc.pszText = strText;
   lvc.iSubItem = nID;

   ListView_InsertColumn(_hList, nID, &lvc);
}

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::Clear
//
//-----------------------------------------------------------------------------
void
CListViewBase::Clear(void)
{
   dspAssert(_hList);
   ListView_DeleteAllItems(_hList);
}

//+----------------------------------------------------------------------------
//
//  Class:      CTLNList
//
//  Purpose:    TLN list on the Name Suffix Routing property page.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::CTLNList
//
//-----------------------------------------------------------------------------
CTLNList::CTLNList(void) :
   _nItem(0),
   CListViewBase()
{
   TRACE(CTLNList,CTLNList);
#ifdef _DEBUG
   strcpy(szClass, "CTLNList");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::Init
//
//-----------------------------------------------------------------------------
void
CTLNList::Init(HWND hParent, int nControlID)
{
   _nID = nControlID;
   _hParent = hParent;

   _hList = GetDlgItem(hParent, nControlID);
   dspAssert(_hList);

   SetStyles(0, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP | LVS_EX_INFOTIP);

   AddColumn(IDS_COL_TITLE_SUFFIX, 117, IDX_SUFFIXNAME_COL);
   AddColumn(IDS_COL_TITLE_ROUTING, 118, IDX_ROUTINGENABLED_COL);
   AddColumn(IDS_COL_TITLE_STATUS, 118, IDX_STATUS_COL);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::AddItem
//
//-----------------------------------------------------------------------------
void
CTLNList::AddItem(PCWSTR pwzName, ULONG i, PCWSTR pwzEnabled, PCWSTR pwzStatus)
{
   dspAssert(pwzName && pwzEnabled);
   LV_ITEM lvi;
   lvi.mask = LVIF_TEXT | LVIF_PARAM;
   lvi.iSubItem = IDX_SUFFIXNAME_COL;
   lvi.lParam = i; // the lParam stores the index of the item in pFTInfo
   lvi.pszText = const_cast<PWSTR>(pwzName);
   lvi.iItem = _nItem++;

   int iItem = ListView_InsertItem(_hList, &lvi);

   ListView_SetItemText(_hList, iItem, IDX_ROUTINGENABLED_COL,
                        const_cast<PWSTR>(pwzEnabled));

   if (pwzStatus && wcslen(pwzStatus) >= 1)
   {
      ListView_SetItemText(_hList, iItem, IDX_STATUS_COL,
                           const_cast<PWSTR>(pwzStatus));
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::GetSelection
//
//-----------------------------------------------------------------------------
int
CTLNList::GetSelection(void)
{
   return ListView_GetNextItem(_hList, -1, LVNI_ALL | LVIS_SELECTED);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::GetFTInfoIndex
//
//-----------------------------------------------------------------------------
ULONG
CTLNList::GetFTInfoIndex(int iSel)
{
   LV_ITEM lvi;
   lvi.mask = LVIF_PARAM;
   lvi.iItem = iSel;
   lvi.iSubItem = IDX_SUFFIXNAME_COL;

   if (!ListView_GetItem(_hList, &lvi))
   {
       dspAssert(FALSE);
       return (ULONG)-1;
   }

   return static_cast<ULONG>(lvi.lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::Clear
//
//-----------------------------------------------------------------------------
void
CTLNList::Clear(void)
{
   _nItem = 0;
   CListViewBase::Clear();
}


//+----------------------------------------------------------------------------
//
//  Class:      CSuffixesList
//
//  Purpose:    TLN subnames edit dialog list.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::CSuffixesList
//
//-----------------------------------------------------------------------------
CSuffixesList::CSuffixesList(void) :
   CListViewBase()
{
   TRACE(CSuffixesList,CSuffixesList);
#ifdef _DEBUG
   strcpy(szClass, "CSuffixesList");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::Init
//
//-----------------------------------------------------------------------------
void
CSuffixesList::Init(HWND hParent, int nControlID)
{
   _nID = nControlID;
   _hParent = hParent;

   _hList = GetDlgItem(hParent, nControlID);
   dspAssert(_hList);

   SetStyles(0, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

   AddColumn(IDS_TLNEDIT_NAME_COL, 222, IDX_NAME_COL);
   AddColumn(IDS_TLNEDIT_STATUS_COL, 196, IDX_STATUS_COL);
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::AddItem
//
//-----------------------------------------------------------------------------
void
CSuffixesList::AddItem(PCWSTR pwzName, ULONG i, TLN_EDIT_STATUS Status)
{
   LV_ITEM lvi;
   lvi.mask = LVIF_TEXT | LVIF_PARAM;
   lvi.iSubItem = IDX_NAME_COL;
   lvi.lParam = i; // the lParam stores the index of the item in pFTInfo
   lvi.pszText = const_cast<PWSTR>(pwzName);
   lvi.iItem = _nItem++;

   int iItem = ListView_InsertItem(_hList, &lvi);

   CStrW strStatus;

   strStatus.LoadString(g_hInstance, 
                        (Enabled == Status) ? IDS_ROUTING_ENABLED :
                        (Disabled == Status) ? IDS_ROUTING_DISABLED :
                        (Enabled_Exceptions == Status) ? IDS_ROUTING_EXCEPT_ENABLE :
                           IDS_ROUTING_EXCEPT_DISABLE);

   ListView_SetItemText(_hList, iItem, IDX_STATUS_COL, strStatus);
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::UpdateItemStatus
//
//-----------------------------------------------------------------------------
void
CSuffixesList::UpdateItemStatus(int item, TLN_EDIT_STATUS Status)
{
   CStrW strStatus;

   strStatus.LoadString(g_hInstance, 
                        (Enabled == Status) ? IDS_ROUTING_ENABLED :
                        (Disabled == Status) ? IDS_ROUTING_DISABLED :
                        (Enabled_Exceptions == Status) ? IDS_ROUTING_EXCEPT_ENABLE :
                           IDS_ROUTING_EXCEPT_DISABLE);

   ListView_SetItemText(_hList, item, IDX_STATUS_COL, strStatus);
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::GetFTInfoIndex
//
//-----------------------------------------------------------------------------
ULONG
CSuffixesList::GetFTInfoIndex(int iSel)
{
   LV_ITEM lvi;
   lvi.mask = LVIF_PARAM;
   lvi.iItem = iSel;
   lvi.iSubItem = IDX_NAME_COL;

   if (!ListView_GetItem(_hList, &lvi))
   {
       dspAssert(FALSE);
       return (ULONG)-1;
   }

   return static_cast<ULONG>(lvi.lParam);
}

/*
//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::
//
//-----------------------------------------------------------------------------

CSuffixesList::
{
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\managdby.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       managdby.h
//
//  Contents:   DS object Managed-By property page definitions
//
//  History:    21-Oct-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _MANAGEDBY_H_
#define _MANAGEDBY_H_

#include "proppage.h"
#include "pages.h"

extern WCHAR g_wszUserClass[];
extern WCHAR g_wszContactClass[];

HRESULT ManagedByEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ChangeButton(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ViewButton(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ClearButton(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT UpdateListCheck(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                        LPARAM, PATTR_DATA, DLG_OP);

HRESULT OfficeEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT StreetEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CityEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT StateEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CountryEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT PhoneEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT FaxEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

class CManagedByPage
{
public:
    CManagedByPage(CDsPropPageBase * pPage);
    ~CManagedByPage(void);

    HRESULT             SetObj(PWSTR pwzObjDN);
    void                SetNameCtrlID(int nCtrl) {m_nNameCtlID = nCtrl;};
    HRESULT             SetEditCtrl(PATTR_MAP pAttrMap);
    void                Clear(void);
    HRESULT             RefreshCtrls(void);
    IDirectoryObject  * Obj(void) {return m_pDsObj;};
    IDirectoryObject  * PreviousObj(void) { return m_pPrevDsObj;}
    PWSTR               Name(void) {return m_pwzObjName;};
    PWSTR               PreviousName(void) {return m_pwzPrevObjName;}
    BOOL                IsValid(void) {return m_pDsObj && m_pwzObjName;};
    BOOL                IsUser(void) {return m_fIsUser;};
    void                SetWritable(BOOL fWritable) {m_fWritable = fWritable;};
    BOOL                IsWritable(void) {return m_fWritable;};
    void                SetMembershipWritable(BOOL fWritable) {m_fWritableMembership = fWritable;}
    BOOL                IsMembershipWritable(void) { return m_fWritableMembership; }
    void                SetUpdateListCheckEnable(BOOL fEnable) {m_fUpdateListCheckEnable = fEnable;}
    BOOL                IsUpdateCheckEnable(void) { return m_fUpdateListCheckEnable; }
   
private:
    IDirectoryObject  * m_pDsObj;
    CDsPropPageBase   * m_pPage;
    PWSTR               m_pwzObjName;
    BOOL                m_fIsUser;
    int                 m_nNameCtlID;
    BOOL                m_fWritable;
    BOOL                m_fWritableMembership;
    BOOL                m_fUpdateListCheckEnable;

public:
    IDirectoryObject  * m_pPrevDsObj;
    PWSTR               m_pwzPrevObjName;
    int                 m_nViewBtnID;
    int                 m_nClearBtnID;
    int                 m_nUpdateListChkID;
    PATTR_MAP           m_pOfficeAttrMap;
    PATTR_MAP           m_pStreetAttrMap;
    PATTR_MAP           m_pCityAttrMap;
    PATTR_MAP           m_pStateAttrMap;
    PATTR_MAP           m_pCountryAttrMap;
    PATTR_MAP           m_pPhoneAttrMap;
    PATTR_MAP           m_pFaxAttrMap;
};

#endif // _MANAGEDBY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\managdby.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       managdby.cxx
//
//  Contents:   Managed-By property page implementation
//
//  History:    21-Oct-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"
#include "managdby.h"

#include <ntsam.h>
#include <aclapi.h>

WCHAR g_wszUserClass[] = L"user";
WCHAR g_wszContactClass[] = L"contact";

extern const GUID GUID_MemberAttribute = 
   { 0xbf9679c0, 0x0de6, 0x11d0,  { 0xa2, 0x85, 0x00,0xaa, 0x00, 0x30, 0x49, 0xe2}};

CManagedByPage::CManagedByPage(CDsPropPageBase * pPage) :
    m_pDsObj(NULL),
    m_pPrevDsObj(NULL),
    m_pPage(pPage),
    m_pwzObjName(NULL),
    m_pwzPrevObjName(NULL),
    m_fIsUser(FALSE),
    m_fWritable(FALSE),
    m_fWritableMembership(FALSE),
    m_fUpdateListCheckEnable(FALSE),
    m_nNameCtlID(0),
    m_pOfficeAttrMap(NULL),
    m_pStreetAttrMap(NULL),
    m_pCityAttrMap(NULL),
    m_pStateAttrMap(NULL),
    m_pCountryAttrMap(NULL),
    m_pPhoneAttrMap(NULL),
    m_pFaxAttrMap(NULL)
{
}

CManagedByPage::~CManagedByPage()
{
    if (m_pDsObj != m_pPrevDsObj)
    {
       DO_RELEASE(m_pPrevDsObj);
    }

    DO_RELEASE(m_pDsObj);
    if (m_pwzPrevObjName && 
        m_pwzObjName &&
        0 != _wcsicmp(m_pwzPrevObjName, m_pwzObjName))
    {
       delete[] m_pwzPrevObjName;
    }

    if (m_pwzObjName)
    {
        delete[] m_pwzObjName;
    }

}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::SetObj
//
//  Synopsis:   Initialize the CManagedBy class and set the edit control value.
//
//-----------------------------------------------------------------------------
HRESULT CManagedByPage::SetObj(PWSTR pwzObjDN)
{
    HRESULT hr;
    PWSTR pwzCanonical = NULL;

    Clear();

    // Save the Managed-By object DN.
    //
    if (!AllocWStr(pwzObjDN, &m_pwzObjName))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    //
    // Save the name as a previous value if the previous value isn't already set
    //
    if (!m_pwzPrevObjName)
    {
       m_pwzPrevObjName = m_pwzObjName;
    }

    // Put the "friendly" name into the edit control.
    //
    hr = CrackName(m_pwzObjName, &pwzCanonical, GET_OBJ_CAN_NAME,
                   m_pPage->GetHWnd());
    if (FAILED(hr))
    {
        return hr;
    }
    PTSTR ptsz;
    if (!UnicodeToTchar(pwzCanonical, &ptsz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        LocalFreeStringW(&pwzCanonical);
        return E_OUTOFMEMORY;
    }
    LocalFreeStringW(&pwzCanonical);
    SetDlgItemText(m_pPage->GetHWnd(), m_nNameCtlID, ptsz);
    delete ptsz;

    // Bind to the Managed-By object.
    //
    CStrW strADsPath;
    IDirectoryObject * pObj;

    hr = AddLDAPPrefix(m_pPage, m_pwzObjName, strADsPath);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);

    hr = ADsOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), NULL, NULL,
                       ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject,
                       (PVOID *)&pObj);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_pPage->GetHWnd());
            return S_OK;
        }
        else
        {
            REPORT_ERROR(hr, m_pPage->GetHWnd());
            return hr;
        }
    }

    m_pDsObj = pObj;
    if (m_pPrevDsObj == NULL)
    {
       m_pPrevDsObj = m_pDsObj;
       m_pPrevDsObj->AddRef();
    }

    // Determine if the Managed-By object is of class user or contact.
    //
    BSTR bstr;
    IADs * pADs;

    hr = m_pDsObj->QueryInterface(IID_IADs, (PVOID *)&pADs);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr;);

    hr = pADs->get_Class(&bstr);

    pADs->Release();

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr;);

    m_fIsUser = (_wcsicmp(bstr, g_wszUserClass) == 0 ||
                 _wcsicmp(bstr, g_wszContactClass) == 0
#ifdef INETORGPERSON
                 || _wcsicmp(bstr, g_szInetOrgPerson) == 0
#endif
                 );

    SysFreeString(bstr);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::SetEditCtrl
//
//  Synopsis:   If a user or contact object, fetch the corresponding value and
//              put it in the control. Otherwise, clear the control.
//
//-----------------------------------------------------------------------------
HRESULT
CManagedByPage::SetEditCtrl(PATTR_MAP pAttrMap)
{
    HRESULT hr = S_OK;

    if (!IsUser())
    {
        // No user values, so clear the control.
        //
        SetDlgItemText(m_pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
        return S_OK;
    }

    PADS_ATTR_INFO pAttr = NULL;
    DWORD cAttrs = 0;
    hr = m_pDsObj->GetObjectAttributes(&pAttrMap->AttrInfo.pszAttrName, 1,
                                       &pAttr, &cAttrs);
    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_pPage->GetHWnd()))
    {
        return hr;
    }
    if (!cAttrs)
    {
        // Attribute not present.
        //
        SetDlgItemText(m_pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
        return S_OK;
    }

    PTSTR ptsz;
    if (!UnicodeToTchar(pAttr->pADsValues->CaseIgnoreString, &ptsz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        FreeADsMem(pAttr);
        return E_OUTOFMEMORY;
    }
    SetDlgItemText(m_pPage->GetHWnd(), pAttrMap->nCtrlID, ptsz);
    delete ptsz;
    FreeADsMem(pAttr);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::Clear
//
//  Synopsis:   Return to the base state.
//
//-----------------------------------------------------------------------------
void CManagedByPage::Clear(void)
{
    DO_RELEASE(m_pDsObj);
    
    if (!m_pwzPrevObjName)
    {
       m_pwzPrevObjName = m_pwzObjName;
    }
    else
    {
       if (m_pwzPrevObjName && m_pwzObjName && 0 != _wcsicmp(m_pwzPrevObjName, m_pwzObjName))
       {
         DO_DEL(m_pwzObjName);
       }
       m_pwzObjName = NULL;
    }

    m_fIsUser = FALSE;
    SetDlgItemText(m_pPage->GetHWnd(), m_nNameCtlID, TEXT(""));
}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::RefreshCtrls
//
//  Synopsis:   Update the dependent controls.
//
//-----------------------------------------------------------------------------
HRESULT CManagedByPage::RefreshCtrls(void)
{
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), m_nViewBtnID), IsValid());
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), m_nClearBtnID), IsValid() && IsWritable());

    HRESULT hr;

    hr = UpdateListCheck(m_pPage, NULL, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = OfficeEdit(m_pPage, m_pOfficeAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = StreetEdit(m_pPage, m_pStreetAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = CityEdit(m_pPage, m_pCityAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = StateEdit(m_pPage, m_pStateAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = CountryEdit(m_pPage, m_pCountryAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = PhoneEdit(m_pPage, m_pPhoneAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = FaxEdit(m_pPage, m_pFaxAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ManagedByEdit
//
//  Synopsis:   If the Managed-By attribute is non-empty, binds to the named
//              object and stores the ADSI pointer in the page object.
//
//  WARNING:    This MUST be the first ATTR_FCN called because it creates the
//              CManagedByPage object.
//-----------------------------------------------------------------------------
HRESULT
ManagedByEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp)
{
    CManagedByPage * pManagedBy;
    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fInit:
    case fObjChanged:
        if (DlgOp == fInit)
        {
            pManagedBy = new CManagedByPage(pPage);

            ((CDsTableDrivenPage *)pPage)->m_pData = reinterpret_cast<LPARAM>(pManagedBy);

            CHECK_NULL_REPORT(pManagedBy, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pManagedBy->SetNameCtrlID(pAttrMap->nCtrlID);
            pManagedBy->SetWritable(PATTR_DATA_IS_WRITABLE(pAttrData));
        }
        else
        {
            pManagedBy = reinterpret_cast<CManagedByPage*>(((CDsTableDrivenPage *)pPage)->m_pData);
            if (!pManagedBy)
            {
                return E_FAIL;
            }
        }
        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            hr = pManagedBy->SetObj(pAttrInfo->pADsValues->DNString);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

        if (pManagedBy)
        {
            if (pManagedBy->IsValid())
            {
                PADSVALUE pADsValue;
                pADsValue = new ADSVALUE;
                CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);
                PWSTR pwz;
                if (!AllocWStr(pManagedBy->Name(), &pwz))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                    return E_OUTOFMEMORY;
                }
                pAttrInfo->pADsValues = pADsValue;
                pAttrInfo->dwNumValues = 1;
                pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
                pADsValue->dwType = pAttrInfo->dwADsType;
                pADsValue->DNString = pwz;
            }
            else
            {
                pAttrInfo->pADsValues = NULL;
                pAttrInfo->dwNumValues = 0;
                pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
            }
        }
        break;

    case fOnDestroy:
        pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
        DO_DEL(pManagedBy);
        break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ChangeButton
//
//  Synopsis:   Handles the Change Managed-By button.
//
//-----------------------------------------------------------------------------
HRESULT
ChangeButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
             DLG_OP DlgOp)
{
    if (fInit == DlgOp)
    {
        CManagedByPage * pManagedBy;
        pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
        dspAssert(pManagedBy);
        if (!pManagedBy->IsWritable())
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
    }

    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }
    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    HRESULT hr = S_OK;
    LPWSTR cleanstr = NULL;
    CWaitCursor WaitCursor;
    IDsObjectPicker * pObjSel;
    BOOL fIsObjSelInited;

    hr = pPage->GetObjSel(&pObjSel, &fIsObjSelInited);

    CHECK_HRESULT(hr, return hr);

    if (!fIsObjSelInited)
    {
        CStrW cstrDC;
        CComPtr<IDirectoryObject> spDsObj;
        if (pPage->m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                             IID_IDirectoryObject, (PVOID*)&spDsObj);
          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = pPage->m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, cstrDC);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        DSOP_SCOPE_INIT_INFO rgScopes[3];
        DSOP_INIT_INFO InitInfo;

        ZeroMemory(rgScopes, sizeof(rgScopes));
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        rgScopes[0].pwzDcName = cstrDC;
        rgScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        rgScopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        rgScopes[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
        InitInfo.cDsScopeInfos = 3;
        InitInfo.aDsScopeInfos = rgScopes;
        InitInfo.pwzTargetComputer = cstrDC;

        hr = pObjSel->Initialize(&InitInfo);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        pPage->ObjSelInited();
    }

    IDataObject * pdoSelections = NULL;

    hr = pObjSel->InvokeDialog(pPage->GetHWnd(), &pdoSelections);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    if (hr == S_FALSE || !pdoSelections)
    {
        return S_OK;
    }

    FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

    hr = pdoSelections->GetData(&fmte, &medium);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

    if (!pSelList || !pSelList->cItems || !pSelList->aDsSelection->pwzADsPath)
    {
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
        pdoSelections->Release();
        return S_OK;
    }

    WaitCursor.SetWait();

    hr = pPage->SkipPrefix(pSelList->aDsSelection->pwzADsPath, &cleanstr);

    GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    pdoSelections->Release();

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), goto Cleanup);

    hr = pManagedBy->SetObj(cleanstr);

    CHECK_HRESULT(hr, goto Cleanup);

    pPage->SetDirty();

    pManagedBy->RefreshCtrls();

Cleanup:

    DO_DEL(cleanstr);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ViewButton
//
//  Synopsis:   Handles the View button.
//
//-----------------------------------------------------------------------------
HRESULT
ViewButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
           DLG_OP DlgOp)
{
    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pManagedBy);
        //
        // Save the control ID.
        //
        pManagedBy->m_nViewBtnID = pAttrMap->nCtrlID;
        // fall through
    case fObjChanged:
        //
        // Enable/Disable as appropriate.
        //
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pManagedBy->m_nViewBtnID),
                     pManagedBy->IsValid());
        break;

    case fOnCommand:
        CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

        if (lParam == BN_CLICKED && pManagedBy->IsValid())
        {
            PostPropSheet(pManagedBy->Name(), pPage);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ClearButton
//
//  Synopsis:   Handles the Clear pushbutton.
//
//-----------------------------------------------------------------------------
HRESULT
ClearButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
            DLG_OP DlgOp)
{
    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pManagedBy);
        //
        // Save the control ID.
        //
        pManagedBy->m_nClearBtnID = pAttrMap->nCtrlID;
        // fall through
    case fObjChanged:
        //
        // Enable/Disable as appropriate.
        //
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pManagedBy->m_nClearBtnID),
                     pManagedBy->IsValid() && pManagedBy->IsWritable());
        break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

            pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
            pManagedBy->Clear();
            pManagedBy->RefreshCtrls();
            
            pPage->SetDirty();
        }
        break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfoMask
//
//  Synopsis:   Reads the security descriptor from the specied DS object
//
//  Arguments:  [IN  punk]          --  IUnknown from IDirectoryObject
//              [IN  si]            --  SecurityInformation
////  History:  25-Dec-2000         --  Hiteshr Created
//----------------------------------------------------------------------------
HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}

WCHAR const c_szSDProperty[]        = L"nTSecurityDescriptor";


//+---------------------------------------------------------------------------
//
//  Function:   DSReadObjectSecurity
//
//  Synopsis:   Reads the Dacl from the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [psdControl]        -- Control Setting for SD
//                                     They can be returned when calling
//                                      DSWriteObjectSecurity                 
//              [OUT ppDacl]        --  DACL returned here
//              
//
//  History     25-Oct-2000         -- hiteshr created
//
//  Notes:  If Object Doesn't have DACL, function will succeed but *ppDacl will
//          be NULL. 
//          Caller must free *ppDacl, if not NULL, by calling LocalFree
//
//----------------------------------------------------------------------------
HRESULT 
DSReadObjectSecurity(IN IDirectoryObject *pDsObject,
                     OUT SECURITY_DESCRIPTOR_CONTROL * psdControl,
                     OUT PACL *ppDacl)
{
   HRESULT hr = S_OK;

   PADS_ATTR_INFO pSDAttributeInfo = NULL;

   do // false loop
   {
      LPWSTR pszSDProperty = (LPWSTR)c_szSDProperty;
      DWORD dwAttributesReturned;
      PSECURITY_DESCRIPTOR pSD = NULL;
      PACL pAcl = NULL;

      if(!pDsObject || !ppDacl)
      {
         hr = E_INVALIDARG;
         break;
      }

      *ppDacl = NULL;

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         break;
      }

      //
      // Read the security descriptor
      //
      hr = pDsObject->GetObjectAttributes(&pszSDProperty,
                                         1,
                                         &pSDAttributeInfo,
                                         &dwAttributesReturned);
      if (SUCCEEDED(hr) && !pSDAttributeInfo)    
         hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege

      if(FAILED(hr))
      {
         break;
      }                

      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType);
      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType);

      pSD = (PSECURITY_DESCRIPTOR)pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue;


      //
      //Get the security descriptor control
      //
      if(psdControl)
      {
         DWORD dwRevision;
         if(!GetSecurityDescriptorControl(pSD, psdControl, &dwRevision))
         {
             hr = HRESULT_FROM_WIN32(GetLastError());
             break;
         }
      }

      //
      //Get pointer to DACL
      //
      BOOL bDaclPresent, bDaclDefaulted;
      if(!GetSecurityDescriptorDacl(pSD, 
                                   &bDaclPresent,
                                   &pAcl,
                                   &bDaclDefaulted))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      if(!bDaclPresent || !pAcl)
         break;

      dspAssert(IsValidAcl(pAcl));

      //
      //Make a copy of the DACL
      //
      *ppDacl = (PACL)LocalAlloc(LPTR,pAcl->AclSize);
      if(!*ppDacl)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      CopyMemory(*ppDacl,pAcl,pAcl->AclSize);

    }while(0);


    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DSWriteObjectSecurity
//
//  Synopsis:   Writes the Dacl to the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [sdControl]         -- control for security descriptor
//              [IN  pDacl]         --  The DACL to be written
//
//  History     25-Oct-2000         -- hiteshr created
//----------------------------------------------------------------------------
HRESULT 
DSWriteObjectSecurity(IN IDirectoryObject *pDsObject,
                      IN SECURITY_DESCRIPTOR_CONTROL sdControl,
                      PACL pDacl)
{
   HRESULT hr = S_OK;
   PISECURITY_DESCRIPTOR pSD = NULL;
   PSECURITY_DESCRIPTOR psd = NULL;

   do // false loop
   {
      ADSVALUE attributeValue;
      ADS_ATTR_INFO attributeInfo;
      DWORD dwAttributesModified;
      DWORD dwSDLength;

      if(!pDsObject || !pDacl)
      {
         dspAssert(FALSE);
         hr = E_INVALIDARG;
         break;
      }

      dspAssert(IsValidAcl(pDacl));

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         break;
      }


      //
      //Build the Security Descriptor
      //
      pSD = (PISECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
      if (pSD == NULL)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
        
      InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

      //
      // Finally, build the security descriptor
      //
      pSD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ
                     | (sdControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

      if(pDacl->AclSize)
      {
         pSD->Dacl = pDacl;
      }

      //
      // Need the total size
      //
      dwSDLength = GetSecurityDescriptorLength(pSD);

      //
      // If necessary, make a self-relative copy of the security descriptor
      //
      psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

      if (psd == NULL ||
          !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }


      attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeValue.SecurityDescriptor.dwLength = dwSDLength;
      attributeValue.SecurityDescriptor.lpValue = (LPBYTE)psd;

      attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
      attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
      attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeInfo.pADsValues = &attributeValue;
      attributeInfo.dwNumValues = 1;

      // Write the security descriptor
      hr = pDsObject->SetObjectAttributes(&attributeInfo,
                                         1,
                                         &dwAttributesModified);
   } while (false);
    
   if (psd != NULL)
   {
      LocalFree(psd);
   }

   if(pSD != NULL)
   {
      LocalFree(pSD);
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Helper Attr Function:  GetMembershipPermsFor
//
//  Synopsis:   Checks the ACL for the group to determine if the manager has
//              rights to write group membership.
//
//-----------------------------------------------------------------------------
HRESULT
GetMembershipPermsFor(IDirectoryObject* pManagerObject,
                      IDirectoryObject* pGroupObject,
                      BOOL* pbHasWritePerms,
                      BOOL* pbIsSecurityPrinciple)
{
  HRESULT hr = S_OK;

  //
  // Validate parameters
  //
  if (!pManagerObject ||
      !pGroupObject ||
      !pbHasWritePerms ||
      !pbIsSecurityPrinciple)
  {
     return E_INVALIDARG;
  }

  *pbHasWritePerms = FALSE;
  *pbIsSecurityPrinciple = FALSE;

  //
  // Get the SID of the manager
  //
  static DWORD dwAttrCount = 1;
  PWSTR pszAttrs[] = { g_wzObjectSID };
  PADS_ATTR_INFO pAttrInfo = NULL;
  DWORD dwAttrRet = 0;
  hr = pManagerObject->GetObjectAttributes(pszAttrs,
                                           dwAttrCount,
                                           &pAttrInfo,
                                           &dwAttrRet);
  if (FAILED(hr))
  {
     *pbIsSecurityPrinciple = FALSE;
     return S_OK;
  }

  PSID pManagerSID = NULL;
  if (pAttrInfo && dwAttrRet == 1)
  {
     if (_wcsicmp(pAttrInfo->pszAttrName, g_wzObjectSID) == 0 &&
         pAttrInfo->pADsValues)
     {
        pManagerSID = pAttrInfo->pADsValues->OctetString.lpValue;
     }
  }

  if (pManagerSID == NULL)
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     *pbIsSecurityPrinciple = FALSE;
     return S_FALSE;
  }

  *pbIsSecurityPrinciple = TRUE;

  //
  // Now get the Security Descriptor from the group
  //
  SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
  CSimpleAclHolder Dacl;

  hr = DSReadObjectSecurity(pGroupObject,
                            &sdControl,
                            &(Dacl.m_pAcl));
  if (FAILED(hr))
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return hr;
  }

  ULONG ulCount = 0, j = 0;
  PEXPLICIT_ACCESS rgEntries = NULL;
  DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);
  if (ERROR_SUCCESS != dwErr)
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     hr = HRESULT_FROM_WIN32(dwErr);
     return hr;
  }

  bool bManagerAllowWrite = false;

  //
  // Loop through looking for the can change password ACE for the manager SID
  //
  for (j = 0; j < ulCount; j++)
  {
    //
    // Look for allow ACEs
    //
    OBJECTS_AND_SID* pObjectsAndSid = NULL;
    pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;
    if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                    GUID_MemberAttribute))
    {
      if ((rgEntries[j].grfAccessPermissions & ACTRL_DS_WRITE_PROP) &&
          rgEntries[j].grfAccessMode == GRANT_ACCESS)
      {
        //
        // See if it is for the manager SID
        //
        if (EqualSid(pObjectsAndSid->pSid, pManagerSID))
        {
          //
          // Allow manager found
          //
          bManagerAllowWrite = true;
          break;
        }
      }
    }
  }

  *pbHasWritePerms = bManagerAllowWrite;

  if (pAttrInfo)
  {
     FreeADsMem(pAttrInfo);
     pAttrInfo = NULL;
  }

  LocalFree(rgEntries);
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Helper Attr Function:  WriteMembershipPermsFor
//
//  Synopsis:   Updates the ACL for the group to with the manager has
//              rights to write group membership.
//
//-----------------------------------------------------------------------------
HRESULT
WriteMembershipPermsFor(IDirectoryObject* pManagerObject,
                        IDirectoryObject* pGroupObject,
                        BOOL bGiveWritePerms)
{
  HRESULT hr = S_OK;

  //
  // Validate parameters
  //
  if (!pManagerObject ||
      !pGroupObject)
  {
     return E_INVALIDARG;
  }

  //
  // Get the SID of the manager
  //
  static DWORD dwAttrCount = 1;
  PWSTR pszAttrs[] = { g_wzObjectSID };
  PADS_ATTR_INFO pAttrInfo = NULL;
  DWORD dwAttrRet = 0;
  hr = pManagerObject->GetObjectAttributes(pszAttrs,
                                           dwAttrCount,
                                           &pAttrInfo,
                                           &dwAttrRet);
  if (FAILED(hr))
  {
     //
     // Not a Security principle, just return
     //
     return S_OK;
  }

  PSID pManagerSID = NULL;
  if (pAttrInfo && dwAttrRet == 1)
  {
     if (_wcsicmp(pAttrInfo->pszAttrName, g_wzObjectSID) == 0 &&
         pAttrInfo->pADsValues)
     {
        pManagerSID = pAttrInfo->pADsValues->OctetString.lpValue;
     }
  }

  if (pManagerSID == NULL)
  {
     //
     // Not a Security principle, just return
     //
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return S_OK;
  }


  //
  // Now get the Security Descriptor from the group
  //
  SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
  CSimpleAclHolder Dacl;

  hr = DSReadObjectSecurity(pGroupObject,
                            &sdControl,
                            &(Dacl.m_pAcl));
  if (FAILED(hr))
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return hr;
  }

  ULONG ulCount = 0, j = 0;
  PEXPLICIT_ACCESS rgEntries = NULL;
  DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);
  if (ERROR_SUCCESS != dwErr)
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     hr = HRESULT_FROM_WIN32(dwErr);
     return hr;
  }

  PEXPLICIT_ACCESS rgNewEntries = NULL;
  ULONG ulNewCount = 0;

  //
  // At the most we will add an Allow ACE so allocate enough space for that
  //
  rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, sizeof(EXPLICIT_ACCESS)*(ulCount + 1));
  if (!rgNewEntries)
  {
     if(pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return E_OUTOFMEMORY;
  }

  bool bManagerAllowWrite = false;

  //
  // Loop through looking for the can change password ACE for the manager SID
  //
  for (j = 0; j < ulCount; j++)
  {
    bool bCopyACE = true;
    //
    // Look for allow ACEs
    //
    OBJECTS_AND_SID* pObjectsAndSid = NULL;
    pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;
    if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                    GUID_MemberAttribute))
    {
      if ((rgEntries[j].grfAccessPermissions & ACTRL_DS_WRITE_PROP) &&
          rgEntries[j].grfAccessMode == GRANT_ACCESS)
      {
        //
        // See if it is for the manager SID
        //
        if (EqualSid(pObjectsAndSid->pSid, pManagerSID))
        {
          //
          // Allow manager found
          //
          bManagerAllowWrite = true;

          if (!bGiveWritePerms)
          {
             bCopyACE = false;
          }
        }
      }
    }

    if (bCopyACE)
    {
      rgNewEntries[ulNewCount] = rgEntries[j];
      ulNewCount++;
    }
  }

  //
  // If we want the manager to have write perms but we didn't
  // find an Allow ACE add one now
  //
  if (bGiveWritePerms && !bManagerAllowWrite)
  {
    rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_WRITE_PROP;
    rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
    rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

    //
    // build the trustee structs for change password
    //
    OBJECTS_AND_SID rgObjectsAndSid = {0};
    BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                  &rgObjectsAndSid,
                                  const_cast<GUID *>(&GUID_MemberAttribute),
                                  NULL, // inherit guid
                                  pManagerSID);
    ulNewCount++;
  }

  CSimpleAclHolder NewDacl;
  dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, NULL, &(NewDacl.m_pAcl));
  dspAssert(IsValidAcl(NewDacl.m_pAcl));

  hr = DSWriteObjectSecurity(pGroupObject,
                             sdControl,
                             NewDacl.m_pAcl);
 
  if (pAttrInfo)
  {
     FreeADsMem(pAttrInfo);
     pAttrInfo = NULL;
  }

  LocalFree(rgNewEntries);
  LocalFree(rgEntries);
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  UpdateListCheck
//
//  Synopsis:   Handles the allow manager to update membership list checkbox
//
//-----------------------------------------------------------------------------
HRESULT
UpdateListCheck(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
                DLG_OP DlgOp)
{
    CManagedByPage* pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pManagedBy);
        //
        // Save the control ID.
        //
        pManagedBy->m_nUpdateListChkID = pAttrMap->nCtrlID;

        // fall through
    case fObjChanged:
      {
        //
        // See if the object is a security principle and if so then see
        // if it has permission to write group membership
        //
        BOOL bHasWritePerms = FALSE;
        BOOL bIsSecurityPrinciple = FALSE;
        HRESULT hr = GetMembershipPermsFor(pManagedBy->Obj(),
                                           pPage->m_pDsObj,
                                           &bHasWritePerms,
                                           &bIsSecurityPrinciple);

        //
        // Ignore failures and use the defaults
        //
        pManagedBy->SetMembershipWritable(bHasWritePerms);
        pManagedBy->SetUpdateListCheckEnable(bIsSecurityPrinciple);

        hr = S_OK;

        //
        // Enable/Disable as appropriate.
        //
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pManagedBy->m_nUpdateListChkID),
                     pManagedBy->IsUpdateCheckEnable());
        SendDlgItemMessage(pPage->GetHWnd(), 
                           pManagedBy->m_nUpdateListChkID,
                           BM_SETCHECK, 
                           (WPARAM)(pManagedBy->IsMembershipWritable()) ? BST_CHECKED : BST_UNCHECKED,
                           0);
      }
      break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CHECK_NULL(pManagedBy, return ADM_S_SKIP);

            pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
            pPage->SetDirty();
        }
        break;

    case fApply:
        if (pManagedBy)
        {
           //
           // Set the ownership of the group to the new manager
           //
           HRESULT hr = S_OK;
           if ((pManagedBy->PreviousName() && pManagedBy->Name() && 
                _wcsicmp(pManagedBy->Name(), pManagedBy->PreviousName()) != 0) ||
               !pManagedBy->Name())
           {
              //
              // The new name and the old name are different so we need to update
              // the ACL
              //

              //
              // First remove the old manager from the ACL
              //
              hr = WriteMembershipPermsFor(pManagedBy->PreviousObj(),
                                           pPage->m_pDsObj,
                                           FALSE);
           }
           //
           // Now add the new manager to the ACL if checkbox is checked
           //
           BOOL bAddGrantACE = (SendDlgItemMessage(pPage->GetHWnd(), 
                                                   pManagedBy->m_nUpdateListChkID,
                                                   BM_GETCHECK, 
                                                   0, 
                                                   0) == BST_CHECKED);
           hr = WriteMembershipPermsFor(pManagedBy->Obj(),
                                        pPage->m_pDsObj,
                                        bAddGrantACE);

           DO_RELEASE(pManagedBy->m_pPrevDsObj);
           pManagedBy->m_pPrevDsObj = pManagedBy->Obj();
           if (pManagedBy->m_pPrevDsObj)
           {
             pManagedBy->m_pPrevDsObj->AddRef();
           }

           if (pManagedBy->PreviousName() && pManagedBy->Name() &&
               _wcsicmp(pManagedBy->Name(), pManagedBy->PreviousName()) != 0)
           {
              DO_DEL(pManagedBy->m_pwzPrevObjName);
           }
           pManagedBy->m_pwzPrevObjName = pManagedBy->Name();
        }
        break;

    }

    return ADM_S_SKIP;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  OfficeEdit
//
//-----------------------------------------------------------------------------
HRESULT
OfficeEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pOfficeAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pOfficeAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pOfficeAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  StreetEdit
//
//-----------------------------------------------------------------------------
HRESULT
StreetEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pStreetAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pStreetAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pStreetAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  CityEdit
//
//-----------------------------------------------------------------------------
HRESULT
CityEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pCityAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pCityAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pCityAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  StateEdit
//
//-----------------------------------------------------------------------------
HRESULT
StateEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pStateAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pStateAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pStateAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  CountryEdit
//
//-----------------------------------------------------------------------------
HRESULT
CountryEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
            DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pCountryAttrMap == NULL)
    {
        pManagedBy->m_pCountryAttrMap = pAttrMap;
    }

    if (pManagedBy->IsUser())
    {
        HRESULT hr;
        PADS_ATTR_INFO pAttr = NULL;
        DWORD cAttrs = 0;
        hr = pManagedBy->Obj()->GetObjectAttributes(&pManagedBy->m_pCountryAttrMap->AttrInfo.pszAttrName,
                                                    1, &pAttr, &cAttrs);
        if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, pPage->GetHWnd()))
        {
            return hr;
        }
        ATTR_DATA AttrData = {0};

        hr = CountryName(pPage, pManagedBy->m_pCountryAttrMap, pAttr, lParam,
                         &AttrData, DlgOp);
        if (pAttr)
            FreeADsMem(pAttr);

        return hr;
    }
    else
    {
        SetDlgItemText(pPage->GetHWnd(), pManagedBy->m_pCountryAttrMap->nCtrlID,
                       TEXT(""));
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  PhoneEdit
//
//-----------------------------------------------------------------------------
HRESULT
PhoneEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pPhoneAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pPhoneAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pPhoneAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  FaxEdit
//
//-----------------------------------------------------------------------------
HRESULT
FaxEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pFaxAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pFaxAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pFaxAttrMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\multi.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       multi.h
//
//  Contents:   DS multi-select object property pages header
//
//  Classes:    CDsMultiPageBase, CDsGenericMultiPage
//
//  History:    16-Nov-99 JeffJon created
//
//-----------------------------------------------------------------------------

#ifndef __MULTI_H_
#define __MULTI_H_

#include "proppage.h"
#include "user.h"


HRESULT CreateGenericMultiPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                               DWORD, CDSBasePathsInfo* pBasePathsInfo,
                               HPROPSHEETPAGE *);
HRESULT CreateMultiUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                               DWORD, CDSBasePathsInfo* pBasePathsInfo,
                               HPROPSHEETPAGE *);
HRESULT CreateMultiGeneralUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                    DWORD, CDSBasePathsInfo* pBasePathsInfo,
                                    HPROPSHEETPAGE *);
HRESULT CreateMultiOrganizationUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                        DWORD, CDSBasePathsInfo* pBasePathsInfo,
                                        HPROPSHEETPAGE*);
HRESULT CreateMultiAddressUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                        DWORD, CDSBasePathsInfo* pBasePathsInfo,
                                        HPROPSHEETPAGE*);

//+----------------------------------------------------------------------------
//
//  Struct:     ATTR_MAP
//
//  Purpose:    For each attribute on a property page, relates the control
//              ID, the attribute name and the attribute type.
//
//  Notes:      The standard table-driven processing assumes that nCtrlID is
//              valid unless pAttrFcn is defined, in which case the attr
//              function may choose to hard code the control ID.
//
//-----------------------------------------------------------------------------
typedef struct _APPLY_MAP {
    int             nCtrlID;        // Control resource ID
    UINT            nCtrlCount;
    int*            pMappedCtrls;
    int*            pCtrlFlags;
} APPLY_MAP, * PAPPLY_MAP;

//+----------------------------------------------------------------------------
//
//  Class:      CDsMultiPageBase
//
//  Purpose:    base class for multi-select property pages
//
//-----------------------------------------------------------------------------
class CDsMultiPageBase : public CDsTableDrivenPage
{
public:
  CDsMultiPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
  ~CDsMultiPageBase(void);

  //
  //  Instance specific wind proc
  //
  LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
  void    Init(PWSTR pszClass);

protected:
  HRESULT OnInitDialog(LPARAM lParam);
  virtual LRESULT OnApply(void);

  PAPPLY_MAP m_pApplyMap;

private:
  virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
};


//+----------------------------------------------------------------------------
//
//  Class:      CDsGenericMultiPage
//
//  Purpose:    property page object class for the generic multi-select page.
//
//-----------------------------------------------------------------------------
class CDsGenericMultiPage : public CDsMultiPageBase
{
public:
  CDsGenericMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
  ~CDsGenericMultiPage(void);

private:
  HRESULT OnInitDialog(LPARAM lParam);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsUserMultiPage
//
//  Purpose:    property page object class for the user address multi-select page.
//
//-----------------------------------------------------------------------------
class CDsUserMultiPage : public CDsMultiPageBase
{
public:
  CDsUserMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
  ~CDsUserMultiPage(void);
};

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:      CDsGeneralMultiUserPage
//
//  Purpose:    property page object class for the general user multi-select page.
//
//-----------------------------------------------------------------------------
class CDsGeneralMultiUserPage : public CDsUserMultiPage
{
public:  
  CDsGeneralMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);

  virtual LRESULT OnApply();
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsOrganizationMultiUserPage
//
//  Purpose:    property page object class for the organization user multi-select page.
//
//-----------------------------------------------------------------------------
class CDsOrganizationMultiUserPage : public CDsUserMultiPage
{
public:  
  CDsOrganizationMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsAddressMultiUserPage
//
//  Purpose:    property page object class for the address user multi-select page.
//
//-----------------------------------------------------------------------------
class CDsAddressMultiUserPage : public CDsUserMultiPage
{
public:  
  CDsAddressMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsMultiUserAcctPage
//
//  Purpose:    multi-select user account page
//
//-----------------------------------------------------------------------------
class CDsMultiUserAcctPage : public CDsPropPageBase
{
public:
  CDsMultiUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                  DWORD dwFlags);
  ~CDsMultiUserAcctPage(void);

  //
  //  Instance specific wind proc
  //
  LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void    Init(PWSTR pwzClass);

private:
  HRESULT OnInitDialog(LPARAM lParam);
  LRESULT OnApply(void);
  LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

  BOOL FillSuffixCombo();

  //
  //  Data members
  //
  DWORD           m_dwUsrAcctCtrl;
  BOOL            m_fOrigCantChangePW;
  LARGE_INTEGER   m_PwdLastSet;
  BYTE *          m_pargbLogonHours;  // Pointer to allocated array of bytes for the logon hours (array length=21 bytes)
  PSID            m_pSelfSid;
  PSID            m_pWorldSid;
  BOOL            m_fAcctCtrlChanged;
  BOOL            m_fAcctExpiresChanged;
  BOOL            m_fLogonHoursChanged;
  BOOL            m_fIsAdmin;
  CLogonWkstaDlg        * m_pWkstaDlg;
};

HRESULT CreateUserMultiAcctPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND, DWORD,
                                CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE *);



/////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
HRESULT CreateMultiUsrProfilePage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND, DWORD,
                                  CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsMultiUsrProfilePage
//
//  Purpose:    property page object class for the user object profile page.
//
//-----------------------------------------------------------------------------
class CDsMultiUsrProfilePage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
  char szClass[32];
#endif

  CDsMultiUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                         DWORD dwFlags);
  ~CDsMultiUsrProfilePage(void);

  //
  //  Instance specific wind proc
  //
  LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void    Init(PWSTR pwzClass);

private:
  HRESULT OnInitDialog(LPARAM lParam);
  LRESULT OnApply(void);
  LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
  LRESULT OnDestroy(void);
  BOOL    ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded, PADSPROPERROR pError);

  //
  //  Data members
  //
  PTSTR       m_ptszLocalHomeDir;
  PTSTR       m_ptszRemoteHomeDir;
  PWSTR       m_pwzSamName;
  int         m_nDrive;
  int         m_idHomeDirRadio;
  BOOL        m_fProfilePathWritable;
  BOOL        m_fScriptPathWritable;
  BOOL        m_fHomeDirWritable;
  BOOL        m_fHomeDriveWritable;
  BOOL        m_fProfilePathChanged;
  BOOL        m_fLogonScriptChanged;
  BOOL        m_fHomeDirChanged;
  BOOL        m_fHomeDriveChanged;
  BOOL        m_fSharedDirChanged;
  PSID        m_pObjSID;
};


#endif // DSADMIN

#endif // __MULTI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\multi.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       multi.cxx
//
//  Contents:   CDsMultiPageBase, the class that implements the generic
//              multi-select property page.
//
//  History:    16-Nov-99 JeffJon created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "multi.h"

#include "uacct.h"
#include "chklist.h"
#include "user.h"   // ExpandUsername

#include <aclapi.h>

extern ATTR_MAP LogonWkstaBtn;
extern const GUID GUID_CONTROL_UserChangePassword;

#ifdef DSADMIN

//
// Attr map flags
//
#define DISABLE_ON_EMPTY  0x80000000  // Ctrl is enabled/disabled based on the contents of another control
#define ALWAYS_DISABLED   0x40000000  // Ctrl is always disabled  
#define CLEAR_FIELD       0x20000000  // Clear the window text of the control when the apply check is removed


//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiPageBase::CDsMultiPageBase
//
//-----------------------------------------------------------------------------
CDsMultiPageBase::CDsMultiPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) 
  : CDsTableDrivenPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsMultiPageBase,CDsMultiPageBase);
  m_pApplyMap = NULL;
  m_fMultiselectPage = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiPageBase::~CDsMultiPageBase
//
//-----------------------------------------------------------------------------
CDsMultiPageBase::~CDsMultiPageBase()
{
    TRACE(CDsMultiPageBase,~CDsMultiPageBase);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateGenericMultiPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateGenericMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               CDSBasePathsInfo* /*pBasePathsInfo*/, 
                               HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGenericMultiPage);

    CDsGenericMultiPage * pPageObj = new CDsGenericMultiPage(pDsPage, pDataObj,
                                                              hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzClass);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiUserPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               CDSBasePathsInfo* /*pBasePathsInfo*/, 
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CDsUserMultiPage);

  CDsUserMultiPage * pPageObj = new CDsUserMultiPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiGeneralUserPage
//
//  Synopsis:   Creates an instance of the multi-select general user page
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiGeneralUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               CDSBasePathsInfo* /*pBasePathsInfo*/, 
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiGeneralUserPage);

  CDsGeneralMultiUserPage * pPageObj = new CDsGeneralMultiUserPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiOrganizationUserPage
//
//  Synopsis:   Creates an instance of the multi-select general user page
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiOrganizationUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               CDSBasePathsInfo* /*pBasePathsInfo*/,
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiOrganizationUserPage);

  CDsOrganizationMultiUserPage* pPageObj = new CDsOrganizationMultiUserPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiAddressUserPage
//
//  Synopsis:   Creates an instance of the multi-select address user page
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiAddressUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               CDSBasePathsInfo* /*pBasePathsInfo*/,
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiAddressUserPage);

  CDsAddressMultiUserPage* pPageObj = new CDsAddressMultiUserPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void CDsMultiPageBase::Init(PWSTR pszClass)
{
  TRACE(CDsMultiPageBase,Init);
  CWaitCursor cWait;

  if (!AllocWStr(pszClass, &m_pwszObjClass))
  {
      m_hrInit = E_OUTOFMEMORY;
      return;
  }

  //
  // Allocate memory for the attribute data.
  //
  m_rgAttrData = new ATTR_DATA[m_cAttrs];
  CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

  memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

  //
  // Marshall the data object pointer for passing to the window proc thread.
  //
  HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                             &m_pDataObjStrm);
  m_pDataObj = NULL; // to make sure no one calls here
  CHECK_HRESULT(hr, m_hrInit = hr; return);
}
  
//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiPageBase::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return SUCCEEDED(InitDlg(lParam));

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMultiPageBase::OnInitDialog(LPARAM)
{
  TRACE(CDsMultiPageBase,OnInitDialog);
  HRESULT hr = S_OK;

  TCHAR szTitle[MAX_PATH];
  if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
  {
      return HRESULT_FROM_WIN32(GetLastError());
  }

  ADsPropSetHwndWithTitle(m_hNotifyObj, m_hPage, szTitle);

  //
  // Mark all the attrs as writable since we are in the multiselect state
  //
  for (DWORD iAttrs = 0; iAttrs < m_cAttrs; iAttrs++)
  {
    ATTR_DATA_SET_WRITABLE(m_rgAttrData[iAttrs]);
    if (m_rgpAttrMap[iAttrs]->pAttrFcn)
    {
      (*m_rgpAttrMap[iAttrs]->pAttrFcn)(this, m_rgpAttrMap[iAttrs], NULL,
                                        0, &m_rgAttrData[iAttrs], fInit);
    }
  }
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiPageBase::OnApply(void)
{
  TRACE(CDsMultiPageBase,OnApply);

  HRESULT hr = S_OK;
  LPTSTR ptsz;
  LPWSTR pwszValue;
  PADSVALUE pADsValue;
  DWORD cAttrs = 0;
  BOOL bErrorOccurred = FALSE;
  UINT idx = 0;
  PWSTR pszTitle = NULL;
  ADSPROPERROR adsPropError = {0};

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  ZeroMemory(&objMedium, sizeof(STGMEDIUM));

  LPDSOBJECTNAMES pDsObjectNames;

  if (m_fReadOnly)
  {
    return PSNRET_NOERROR;
  }

  PADS_ATTR_INFO pAttrs = new ADS_ATTR_INFO[m_cAttrs];
  CHECK_NULL_REPORT(pAttrs, GetHWnd(), return -1);

  memset(pAttrs, 0, sizeof(ADS_ATTR_INFO) * m_cAttrs);

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    bErrorOccurred = TRUE;
    goto Cleanup;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, bErrorOccurred = TRUE; goto Cleanup);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      bErrorOccurred = TRUE;
      goto Cleanup;
  }


  //
  // Prepare the error structure
  //
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  //
  // Resort to the single select manner for applying
  //
  for (DWORD i = 0; i < m_cAttrs; i++)
  {
    if (m_rgpAttrMap[i]->fIsReadOnly ||
        (!m_rgpAttrMap[i]->pAttrFcn && 
          (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]))))
    {
      // If the map defines it to be read-only or no attr function is
      // defined and the attribute is not writable, then
      // skip it.
      // NOTE: we ignore the dirty flag because we key off the checkbox
      //
      continue;
    }

    //
    // Now lets see if the apply check box is checked
    //
    BOOL bCanApply = FALSE;
    PAPPLY_MAP pMapEntry = m_pApplyMap;
    while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
    {
      if (pMapEntry->nCtrlID == IDC_ALWAYS_APPLY)
      {
        bCanApply = TRUE;
      }
      else
      {
        LRESULT lRes = SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_GETCHECK, 0, 0);
        if (lRes == BST_CHECKED)
        {
          for (UINT nIDCount = 0; nIDCount < pMapEntry->nCtrlCount; nIDCount++)
          {
            if (m_rgpAttrMap[i]->nCtrlID == pMapEntry->pMappedCtrls[nIDCount])
            {
              bCanApply = TRUE;
            }
          }
        }
      }
      if (bCanApply)
      {
        break;
      }
      pMapEntry++;
    }

    if (!bCanApply)
    {
      //
      // The apply check wasn't checked
      //
      continue;
    }

    pAttrs[cAttrs] = m_rgpAttrMap[i]->AttrInfo;

    if (m_rgpAttrMap[i]->pAttrFcn)
    {
      // Handle special-case attribute.
      //
      hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                        &pAttrs[cAttrs], 0,
                                        &m_rgAttrData[i], fApply);
      if (FAILED(hr))
      {
        goto Cleanup;
      }

      if (hr == ADM_S_SKIP)
      {
        // Don't write the attribute.
        //
        continue;
      }

      if (hr != S_FALSE)
      {
        //
        // If the attr fcn didn't return S_FALSE, that means that it
        // handled the value. If it did return S_FALSE, then let the
        // standard edit control processing below handle the value.
        //
        cAttrs++;

        continue;
      }
    }

    if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
    {
      //
      // Handle boolean checkbox attributes.
      //

      pADsValue = new ADSVALUE;
      CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

      pAttrs[cAttrs].pADsValues = pADsValue;
      pAttrs[cAttrs].dwNumValues = 1;
      pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

      pADsValue->Boolean = IsDlgButtonChecked(m_hPage, m_rgpAttrMap[i]->nCtrlID) == BST_CHECKED;
      cAttrs++;

      continue;
    }

    // Assumes that all non-special-case attributes,
    // if single-valued and not boolean, come from a text control.
    //
    ptsz = new TCHAR[m_rgpAttrMap[i]->nSizeLimit + 1];
    CHECK_NULL_REPORT(ptsz, GetHWnd(), goto Cleanup);

    GetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptsz,
                   m_rgpAttrMap[i]->nSizeLimit + 1);

    CStr csValue = ptsz;

    csValue.TrimLeft();
    csValue.TrimRight();

    if (_tcslen(ptsz) != (size_t)csValue.GetLength())
    {
      // the length is different, it must have been trimmed. Write trimmed
      // value back to the control.
      //
      SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, const_cast<PTSTR>((LPCTSTR)csValue));
    }
    delete[] ptsz;

    if (csValue.IsEmpty())
    {
      // An empty control means remove the attribute value from the
      // object.
      //
      pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
      pAttrs[cAttrs].dwNumValues = 0;
      pAttrs[cAttrs].pADsValues = NULL;

      cAttrs++;
      continue;
    }

    if (!TcharToUnicode(const_cast<PTSTR>((LPCTSTR)csValue), &pwszValue))
    {
      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
    }

    pADsValue = new ADSVALUE;
    CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

    pAttrs[cAttrs].pADsValues = pADsValue;
    pAttrs[cAttrs].dwNumValues = 1;
    pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

    switch (pADsValue->dwType)
    {
      case ADSTYPE_DN_STRING:
        pADsValue->DNString = pwszValue;
        break;
      case ADSTYPE_CASE_EXACT_STRING:
        pADsValue->CaseExactString = pwszValue;
        break;
      case ADSTYPE_CASE_IGNORE_STRING:
        pADsValue->CaseIgnoreString = pwszValue;
        break;
      case ADSTYPE_PRINTABLE_STRING:
        pADsValue->PrintableString = pwszValue;
        break;
      case ADSTYPE_NUMERIC_STRING:
        pADsValue->NumericString = pwszValue;
        break;
      case ADSTYPE_INTEGER:
        pADsValue->Integer = _wtoi(pwszValue);
        break;
      default:
        dspDebugOut((DEB_ERROR, "OnApply: Unknown ADS Type %x\n",
                     pADsValue->dwType));
    }
    cAttrs++;
  }

  // cAttrs could be zero if a page was read-only. Don't call ADSI if so.
  //
  if (cAttrs < 1)
  {
    goto Cleanup;
  }

  dspDebugOut((DEB_USER1, "TablePage, about to write %d attrs.\n", cAttrs));

  
  

  for (; idx < pDsObjectNames->cItems; idx++)
  {
    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    adsPropError.pszObjPath = pwzObjADsPath;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                       IID_IDirectoryObject, (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }
  
    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(pAttrs, cAttrs, &cModified);
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
    }
  }

Cleanup:

  //
  // Cleanup medium
  //
  ReleaseStgMedium(&objMedium);

  for (i = 0; i < cAttrs; i++)
  {
    if (pAttrs[i].pADsValues)
    {
      for (DWORD j = 0; j < pAttrs[i].dwNumValues; j++)
      {
        pwszValue = NULL;
        switch (pAttrs[i].dwADsType)
        {
          case ADSTYPE_DN_STRING:
            pwszValue = pAttrs[i].pADsValues[j].DNString;
            break;
          case ADSTYPE_CASE_EXACT_STRING:
            pwszValue = pAttrs[i].pADsValues[j].CaseExactString;
            break;
          case ADSTYPE_CASE_IGNORE_STRING:
            pwszValue = pAttrs[i].pADsValues[j].CaseIgnoreString;
            break;
          case ADSTYPE_PRINTABLE_STRING:
            pwszValue = pAttrs[i].pADsValues[j].PrintableString;
            break;
          case ADSTYPE_NUMERIC_STRING:
            pwszValue = pAttrs[i].pADsValues[j].NumericString;
            break;
        }
        if (pwszValue)
        {
          delete pwszValue;
        }
      }
    }
    delete pAttrs[i].pADsValues;
  }
  delete[] pAttrs;

  if (pszTitle != NULL)
  {
    delete pszTitle;
    pszTitle = NULL;
  }

  if (!bErrorOccurred && cAttrs > 0)
  {
    for (i = 0; i < m_cAttrs; i++)
    {
      ATTR_DATA_CLEAR_DIRTY(m_rgAttrData[i]);
    }

    PAPPLY_MAP pMapEntry = m_pApplyMap;
    while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
    {
      SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_SETCHECK, BST_UNCHECKED, 0);
      //
      // Loop through the mapped controls
      //
      for (UINT iCount = 0; iCount < pMapEntry->nCtrlCount; iCount++)
      {
        HWND hwndCtrl = GetDlgItem(m_hPage, (pMapEntry->pMappedCtrls[iCount]));
        if (hwndCtrl != NULL)
        {
          EnableWindow(hwndCtrl, FALSE);
        }
      }
      pMapEntry++;
    }
  }

  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }
  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiPageBase::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
  if (m_fInInit)
  {
    return 0;
  }

  HRESULT hr;
  DWORD i;

  for (i = 0; i < m_cAttrs; i++)
  {
    if (id == m_rgpAttrMap[i]->nCtrlID)
    {
      // Give attr functions first crack at the command notification.
      //
      if (m_rgpAttrMap[i]->pAttrFcn)
      {
        hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                          codeNotify, &m_rgAttrData[i],
                                          fOnCommand);

        if (hr == S_FALSE)
        {
          // If the attr function returns S_FALSE, then don't return
          // to the base class OnCommand.
          //
          return 0;
        }
        else
        {
          continue;
        }
      }
      if (codeNotify == BN_CLICKED &&
          m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
      {
        // NOTE: Must do this to allow saving from the WAB-hosted sheet.
        EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
        // NOTE: end hack.

        // The check box was clicked.
        //
        SetDirty(i);

        return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
      }
      if (codeNotify == EN_CHANGE)
      {
        // NOTE: Must do this to allow saving from the WAB-hosted sheet.
        EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
        // NOTE: End Hack.

        SetDirty(i);
      }
    }
  }

  //
  // Since it wasn't an attribute control see if it was a apply check box
  // then we should enable/disable the associated controls
  //
  if (m_pApplyMap != NULL)
  {
    PAPPLY_MAP pNextMap = m_pApplyMap;
    while (pNextMap != NULL && pNextMap->nCtrlID != NULL)
    {
      if (id == pNextMap->nCtrlID)
      {
        //
        // Get the state of the apply check
        //
        LRESULT lRes = SendDlgItemMessage(m_hPage, id, BM_GETCHECK, 0, 0);
        if (lRes != BST_INDETERMINATE)
        {
          //
          // Enable or disable the control as appropriate
          //
          BOOL bEnable = FALSE;
          if (lRes == BST_CHECKED)
          {
            bEnable = TRUE;
          }

          //
          // Loop through the mapped controls
          //
          for (UINT iCount = 0; iCount < pNextMap->nCtrlCount; iCount++)
          {
            HWND hwndCtrl = GetDlgItem(m_hPage, (pNextMap->pMappedCtrls[iCount]));
            if (hwndCtrl != NULL)
            {
              if (0 == static_cast<int>(pNextMap->pCtrlFlags[iCount] & (ALWAYS_DISABLED | DISABLE_ON_EMPTY)))
              {
                EnableWindow(hwndCtrl, bEnable);
              }

              //
              // Clear the window text if the CLEAR_FIELD flag is present
              //
              if (!bEnable && 0 != static_cast<int>(pNextMap->pCtrlFlags[iCount] & CLEAR_FIELD))
              {
                SetDlgItemText(m_hPage, pNextMap->pMappedCtrls[iCount], L"");
              }

              //
              // There are some controls that should be disabled if the edit box they
              // are associated with is empty
              //
              if (pNextMap->pCtrlFlags[iCount] & DISABLE_ON_EMPTY)
              {
                int nCtrlID = pNextMap->pCtrlFlags[iCount] & ~DISABLE_ON_EMPTY;
                if (nCtrlID != 0)
                {
                  LRESULT lLen = SendDlgItemMessage(m_hPage, nCtrlID, WM_GETTEXTLENGTH, 0, 0);
                  if (lLen > 0)
                  {
                    EnableWindow(GetDlgItem(m_hPage, pNextMap->pMappedCtrls[iCount]), bEnable);
                  }
                  else
                  {
                    EnableWindow(GetDlgItem(m_hPage, pNextMap->pMappedCtrls[iCount]), FALSE);
                  }
                }
              }
            }

            //
            // Mark the associated control as dirty
            //
            for (UINT nCtrlIdx = 0; nCtrlIdx < m_cAttrs; nCtrlIdx++)
            {
              if (pNextMap->pMappedCtrls[iCount] == m_rgpAttrMap[nCtrlIdx]->nCtrlID)
              {
                SetDirty(nCtrlIdx);
              }
            }            
          }
        }
      }
      pNextMap++;
    } // while
  }
  return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiPageBase::OnNotify(WPARAM wParam, LPARAM lParam)
{
  LRESULT lResult = CDsPropPageBase::OnNotify(wParam, lParam);
  //
  // The base class will take care of notifying the console if there wasn't
  // an error, but for the multiselect pages we also have to do the notification
  // if there was an error so that objects that didn't fail can be updated
  //
  if (((LPNMHDR)lParam)->code == PSN_APPLY &&
      (lResult == PSNRET_INVALID ||
       lResult == PSNRET_INVALID_NOCHANGEPAGE))
  {
    //
    // Signal the change notification. Note that the notify-apply
    // message must be sent even if the page is not dirty so that the
    // notify ref-counting will properly decrement.
    //
    SendMessage(m_hNotifyObj, WM_ADSPROP_NOTIFY_APPLY, TRUE, (LPARAM)m_hPage);
  }
  return lResult;
}



//////////////////////////////////////////////////////////////////////////////////

int gDescGenericIDs[] = { IDC_DESC_STATIC,  IDC_DESCRIPTION_EDIT };
int gDescFlags[]      = { 0,                CLEAR_FIELD          };

APPLY_MAP gpGenericPageMap[] = 
{ 
  { IDC_APPLY_DESC_CHK, sizeof(gDescGenericIDs)/sizeof(int), gDescGenericIDs, gDescFlags },
  { NULL, NULL, NULL }
};


//+----------------------------------------------------------------------------
//
//  Member:     CDsGenericMultiPage::CDsGenericMultiPage
//
//-----------------------------------------------------------------------------
CDsGenericMultiPage::CDsGenericMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) :
    CDsMultiPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsGenericMultiPage,CDsGenericMultiPage);
  m_pApplyMap = gpGenericPageMap;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGenericMultiPage::~CDsGenericMultiPage
//
//-----------------------------------------------------------------------------
CDsGenericMultiPage::~CDsGenericMultiPage()
{
  TRACE(CDsGenericMultiPage,~CDsGenericMultiPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGenericMultiPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsGenericMultiPage::OnInitDialog(LPARAM lParam)
{
  TRACE(CDsGenericMultiPage,OnInitDialog);
  HRESULT hr = S_OK;

  hr = CDsMultiPageBase::OnInitDialog(lParam);

  //
  // Retrieve the DS object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;

  LPDSOBJECTNAMES pDsObjectNames;
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return E_FAIL;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return hr);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
    DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
    return ERROR_INVALID_DATA;
  }

  UINT nTotalCount = 0, nOUCount = 0, nUserCount = 0, nGroupCount = 0, nContactCount = 0;
  UINT nOtherCount = 0, nComputerCount = 0;

  for (UINT idx = 0; idx < pDsObjectNames->cItems; idx++)
  {
    LPWSTR pwzClass = (PWSTR)ByteOffset(pDsObjectNames,
                                        pDsObjectNames->aObjects[idx].offsetClass);
    
    if (_wcsicmp(pwzClass, L"user") == 0)
    {
      nUserCount++;
    }
    else if (_wcsicmp(pwzClass, L"organizationalUnit") == 0)
    {
      nOUCount++;
    }
    else if (_wcsicmp(pwzClass, L"group") == 0)
    {
      nGroupCount++;
    }
    else if (_wcsicmp(pwzClass, L"Contact") == 0)
    {
      nContactCount++;
    }
    else if (_wcsicmp(pwzClass, L"Computer") == 0)
    {
      nComputerCount++;
    }
    else
    {
      nOtherCount++;
    }
    nTotalCount++;
  }
  dspAssert(nTotalCount == nOtherCount + nContactCount + nGroupCount + nOUCount + nUserCount + nComputerCount);

  //
  // Cleanup medium
  //
  ReleaseStgMedium(&objMedium);

  //
  // REVIEW_JEFFJON_PORT : hardcoded 
  //
  TCHAR ptzTotal[MAX_PATH]    = {0}, 
        ptzOU[MAX_PATH]       = {0}, 
        ptzUser[MAX_PATH]     = {0}, 
        ptzGroup[MAX_PATH]    = {0}, 
        ptzComputer[MAX_PATH] = {0}, 
        ptzContact[MAX_PATH]  = {0}, 
        ptzOther[MAX_PATH]    = {0};
  
  if (nTotalCount > 0)
  {
    wsprintf(ptzTotal, _T("%d"), nTotalCount);
  }

  if (nOUCount > 0)
  {
    wsprintf(ptzOU, _T("%d"), nOUCount);
  }

  if (nUserCount > 0)
  {
    wsprintf(ptzUser, _T("%d"), nUserCount);
  }

  if (nGroupCount > 0)
  {
    wsprintf(ptzGroup, _T("%d"), nGroupCount);
  }

  if (nComputerCount > 0)
  {
    wsprintf(ptzComputer, _T("%d"), nComputerCount);
  }

  if (nContactCount > 0)
  {
    wsprintf(ptzContact, _T("%d"), nContactCount);
  }

  if (nOtherCount > 0)
  {
    wsprintf(ptzOther, _T("%d"), nOtherCount);
  }

  ::SendDlgItemMessage(m_hPage, IDC_SUMMARY_STATIC, WM_SETTEXT, 0, (LPARAM)ptzTotal);
  ::SendDlgItemMessage(m_hPage, IDC_OU_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzOU);
  ::SendDlgItemMessage(m_hPage, IDC_USER_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzUser);
  ::SendDlgItemMessage(m_hPage, IDC_GROUP_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzGroup);
  ::SendDlgItemMessage(m_hPage, IDC_COMPUTER_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzComputer);
  ::SendDlgItemMessage(m_hPage, IDC_CONTACT_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzContact);
  ::SendDlgItemMessage(m_hPage, IDC_OTHER_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzOther);

  return hr;
}


/////////////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserMultiPage::CDsUserMultiPage
//
//-----------------------------------------------------------------------------
CDsUserMultiPage::CDsUserMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) :
    CDsMultiPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsUserMultiPage,CDsUserMultiPage);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserMultiPage::~CDsUserMultiPage
//
//-----------------------------------------------------------------------------
CDsUserMultiPage::~CDsUserMultiPage()
{
  TRACE(CDsUserMultiPage,~CDsUserMultiPage);
}

//////////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsGeneralMultiUserPage::CDsGeneralMultiUserPage
//
//-----------------------------------------------------------------------------
int gDescGenIDs[]   = { IDC_DESCRIPTION_EDIT };
int gDescGenFlags[] = { CLEAR_FIELD };
int gOfficeGenIDs[] = { IDC_OFFICE_EDIT };
int gOfficeFlags[]  = { CLEAR_FIELD };
int gPhoneGenIDs[]  = { IDC_PHONE_EDIT, IDC_OTHER_PHONE_BTN };
int gPhoneFlags[]   = { CLEAR_FIELD, 0 };
int gEmailGenIDs[]  = { IDC_EMAIL_EDIT };
int gEmailFlags[]   = { CLEAR_FIELD };
int gWebGenIDs[]    = { IDC_HOME_PAGE_EDIT, IDC_OTHER_URL_BTN };
int gWebFlags[]     = { CLEAR_FIELD, 0 };
int gFaxGenIDs[]    = { IDC_FAX_EDIT, IDC_OTHER_FAX_BTN };
int gFaxFlags[]     = { CLEAR_FIELD, 0 };

APPLY_MAP gpGeneralPageMap[] = 
{ 
  { IDC_APPLY_DESC_CHK, sizeof(gDescGenIDs)/sizeof(int), gDescGenIDs, gDescGenFlags },
  { IDC_APPLY_OFFICE_CHK, sizeof(gOfficeGenIDs)/sizeof(int), gOfficeGenIDs, gOfficeFlags },
  { IDC_APPLY_PHONE_CHK, sizeof(gPhoneGenIDs)/sizeof(int), gPhoneGenIDs, gPhoneFlags },
  { IDC_APPLY_EMAIL_CHK, sizeof(gEmailGenIDs)/sizeof(int), gEmailGenIDs, gEmailFlags },
  { IDC_APPLY_WEB_CHK, sizeof(gWebGenIDs)/sizeof(int), gWebGenIDs, gWebFlags },
  { IDC_APPLY_FAX_CHK, sizeof(gFaxGenIDs)/sizeof(int), gFaxGenIDs, gFaxFlags },
  { NULL, NULL, NULL }
};


CDsGeneralMultiUserPage::CDsGeneralMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags)
  : CDsUserMultiPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  m_pApplyMap = gpGeneralPageMap;
}

LRESULT CDsGeneralMultiUserPage::OnApply()
{
  TRACE(CDsGeneralMultiUserPage,OnApply);

  HRESULT hr = S_OK;
  LPTSTR ptsz;
  LPWSTR pwszValue;
  PADSVALUE pADsValue;
  DWORD cAttrs = 0;
  BOOL bErrorOccurred = FALSE;
  UINT idx = 0;
  PWSTR pszTitle = NULL;

  LPWSTR rgpwzAttrNames[] = {wzSAMname};
  Smart_PADS_ATTR_INFO spAttrs;
  ULONG nCount = 0;

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  if (m_fReadOnly)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return hr);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      return PSNRET_INVALID_NOCHANGEPAGE;
  }


  //
  // Prepare the error structure
  //
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  ADSPROPERROR adsPropError = {0};
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  for (; idx < pDsObjectNames->cItems; idx++)
  {
    cAttrs = 0;
    hr = S_OK;
    PWSTR pwzSamName = NULL;

    PADS_ATTR_INFO pAttrs = new ADS_ATTR_INFO[m_cAttrs];
    CHECK_NULL_REPORT(pAttrs, GetHWnd(), return -1);

    memset(pAttrs, 0, sizeof(ADS_ATTR_INFO) * m_cAttrs);

    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    adsPropError.pszObjPath = pwzObjADsPath;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                       IID_IDirectoryObject, (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      goto Cleanup;
    }

    hr = spDirObject->GetObjectAttributes(rgpwzAttrNames,
                                          ARRAYLENGTH(rgpwzAttrNames),
                                          &spAttrs, &nCount);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      goto Cleanup;
    }

    if (nCount > 0 && spAttrs)
    {
      pwzSamName = spAttrs->pADsValues->CaseIgnoreString;
    }

    //
    // Resort to the single select manner for applying
    //

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
      if (m_rgpAttrMap[i]->fIsReadOnly ||
          (!m_rgpAttrMap[i]->pAttrFcn && 
            (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]))))
      {
        // If the map defines it to be read-only or no attr function is
        // defined and the attribute is not writable or not dirty, then
        // skip it.
        // NOTE: we ignore the dirty flag because we key off the check box
        //
        continue;
      }

      //
      // Now lets see if the apply check box is checked
      //
      BOOL bCanApply = FALSE;
      PAPPLY_MAP pMapEntry = m_pApplyMap;
      while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
      {
        LRESULT lRes = SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_GETCHECK, 0, 0);
        if (lRes == BST_CHECKED)
        {
          for (UINT nIDCount = 0; nIDCount < pMapEntry->nCtrlCount; nIDCount++)
          {
            if (m_rgpAttrMap[i]->nCtrlID == static_cast<int>(pMapEntry->pMappedCtrls[nIDCount])) 
            {
              bCanApply = TRUE;
            }
          }
        }
        if (bCanApply)
        {
          break;
        }
        pMapEntry++;
      }

      if (!bCanApply)
      {
        //
        // The apply check wasn't checked
        //
        continue;
      }

      pAttrs[cAttrs] = m_rgpAttrMap[i]->AttrInfo;

      if (m_rgpAttrMap[i]->pAttrFcn)
      {
        //
        // Special case the email field because we need to provide the
        // error handling the correct way for multiselect
        //
        if (m_rgpAttrMap[i]->pAttrFcn == MailAttr)
        {
          SendMessage(GetParent(GetHWnd()), PSM_QUERYSIBLINGS,
                      (WPARAM)m_rgpAttrMap[i]->AttrInfo.pszAttrName,
                      (LPARAM)GetHWnd());

          PWSTR pwz = NULL;
          int cch = (int)SendDlgItemMessage(GetHWnd(), m_rgpAttrMap[i]->nCtrlID,
                                            WM_GETTEXTLENGTH, 0, 0);
          if (cch)
          {
            cch++;
            pwz = new WCHAR[cch];
            if (pwz == NULL)
            {
              adsPropError.hr = E_OUTOFMEMORY;
              SendErrorMessage(&adsPropError);
              bErrorOccurred = TRUE;
              continue;
            }

            GetDlgItemText(GetHWnd(), m_rgpAttrMap[i]->nCtrlID, pwz, cch);
          }
          if (pwz)
          {
            BOOL fExpanded = FALSE;
            ExpandUsername(pwz, pwzSamName, fExpanded);

            if (!FValidSMTPAddress(pwz))
            {
              PTSTR ptzError = NULL;
              if (LoadStringToTchar(IDS_INVALID_MAIL_ADDR, &ptzError))
              {
                adsPropError.hr = 0;
                adsPropError.pszError = ptzError;
                SendErrorMessage(&adsPropError);
                bErrorOccurred = TRUE;

                delete[] pwz;
                pwz = NULL;
                continue;
              }
            }
            else
            {
              pADsValue = new ADSVALUE;
              if (pADsValue == NULL)
              {
                adsPropError.hr = E_OUTOFMEMORY;
                SendErrorMessage(&adsPropError);
                bErrorOccurred = TRUE;

                delete[] pwz;
                pwz = NULL;
                continue;
              }
              else
              {
                pAttrs[cAttrs].pADsValues = pADsValue;
                pAttrs[cAttrs].dwNumValues = 1;
                pAttrs[cAttrs].dwControlCode = ADS_ATTR_UPDATE;
                pADsValue->dwType = pAttrs[cAttrs].dwADsType;
                pADsValue->CaseIgnoreString = pwz;
              }
            }
          }
          else
          {
            pAttrs[cAttrs].pADsValues = NULL;
            pAttrs[cAttrs].dwNumValues = 0;
            pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
          }
          cAttrs++;
          continue;
        }
        else
        {
          // Handle special-case attribute.
          //
          hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                            &pAttrs[cAttrs], (LPARAM)pwzSamName,
                                            &m_rgAttrData[i], fApply);
          if (FAILED(hr))
          {
            goto Cleanup;
          }

          if (hr == ADM_S_SKIP)
          {
            // Don't write the attribute.
            //
            continue;
          }

          if (hr != S_FALSE)
          {
            //
            // If the attr fcn didn't return S_FALSE, that means that it
            // handled the value. If it did return S_FALSE, then let the
            // standard edit control processing below handle the value.
            //
            cAttrs++;

            continue;
          }
        }
      }

      if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
      {
        //
        // Handle boolean checkbox attributes.
        //

        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

        pAttrs[cAttrs].pADsValues = pADsValue;
        pAttrs[cAttrs].dwNumValues = 1;
        pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

        pADsValue->Boolean = IsDlgButtonChecked(m_hPage, m_rgpAttrMap[i]->nCtrlID) == BST_CHECKED;
        cAttrs++;

        continue;
      }

      // Assumes that all non-special-case attributes,
      // if single-valued and not boolean, come from a text control.
      //
      ptsz = new TCHAR[m_rgpAttrMap[i]->nSizeLimit + 1];
      CHECK_NULL_REPORT(ptsz, GetHWnd(), goto Cleanup);

      GetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptsz,
                     m_rgpAttrMap[i]->nSizeLimit + 1);

      CStr csValue = ptsz;

      csValue.TrimLeft();
      csValue.TrimRight();

      if (_tcslen(ptsz) != (size_t)csValue.GetLength())
      {
        // the length is different, it must have been trimmed. Write trimmed
        // value back to the control.
        //
        SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, const_cast<PTSTR>((LPCTSTR)csValue));
      }
      delete[] ptsz;

      if (csValue.IsEmpty())
      {
        // An empty control means remove the attribute value from the
        // object.
        //
        pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
        pAttrs[cAttrs].dwNumValues = 0;
        pAttrs[cAttrs].pADsValues = NULL;

        cAttrs++;
        continue;
      }

      if (!TcharToUnicode(const_cast<PTSTR>((LPCTSTR)csValue), &pwszValue))
      {
        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
      }

      pADsValue = new ADSVALUE;
      CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

      pAttrs[cAttrs].pADsValues = pADsValue;
      pAttrs[cAttrs].dwNumValues = 1;
      pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

      switch (pADsValue->dwType)
      {
        case ADSTYPE_DN_STRING:
          pADsValue->DNString = pwszValue;
          break;
        case ADSTYPE_CASE_EXACT_STRING:
          pADsValue->CaseExactString = pwszValue;
          break;
        case ADSTYPE_CASE_IGNORE_STRING:
          pADsValue->CaseIgnoreString = pwszValue;
          break;
        case ADSTYPE_PRINTABLE_STRING:
          pADsValue->PrintableString = pwszValue;
          break;
        case ADSTYPE_NUMERIC_STRING:
          pADsValue->NumericString = pwszValue;
          break;
        case ADSTYPE_INTEGER:
          pADsValue->Integer = _wtoi(pwszValue);
          break;
        default:
          dspDebugOut((DEB_ERROR, "OnApply: Unknown ADS Type %x\n",
                       pADsValue->dwType));
      }
      cAttrs++;
    }

    // cAttrs could be zero if a page was read-only. Don't call ADSI if so.
    //
    if (cAttrs < 1)
    {
      goto Cleanup;
    }

    dspDebugOut((DEB_USER1, "TablePage, about to write %d attrs.\n", cAttrs));

  
    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(pAttrs, cAttrs, &cModified);
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
    }

Cleanup:

    //
    // Cleanup medium
    //

    for (DWORD i = 0; i < cAttrs; i++)
    {
      if (pAttrs[i].pADsValues)
      {
        for (DWORD j = 0; j < pAttrs[i].dwNumValues; j++)
        {
          pwszValue = NULL;
          switch (pAttrs[i].dwADsType)
          {
            case ADSTYPE_DN_STRING:
              pwszValue = pAttrs[i].pADsValues[j].DNString;
              break;
            case ADSTYPE_CASE_EXACT_STRING:
              pwszValue = pAttrs[i].pADsValues[j].CaseExactString;
              break;
            case ADSTYPE_CASE_IGNORE_STRING:
              pwszValue = pAttrs[i].pADsValues[j].CaseIgnoreString;
              break;
            case ADSTYPE_PRINTABLE_STRING:
              pwszValue = pAttrs[i].pADsValues[j].PrintableString;
              break;
            case ADSTYPE_NUMERIC_STRING:
              pwszValue = pAttrs[i].pADsValues[j].NumericString;
              break;
          }
          if (pwszValue)
          {
            delete pwszValue;
          }
        }
      }
      delete pAttrs[i].pADsValues;
    }
    delete[] pAttrs;
  }

  ReleaseStgMedium(&objMedium);

  if (pszTitle != NULL)
  {
    delete pszTitle;
    pszTitle = NULL;
  }

  if (!bErrorOccurred && cAttrs > 0)
  {
    for (UINT i = 0; i < m_cAttrs; i++)
    {
      ATTR_DATA_CLEAR_DIRTY(m_rgAttrData[i]);
    }

    //
    // Uncheck the Apply checkboxes
    //
    PAPPLY_MAP pMapEntry = m_pApplyMap;
    while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
    {
      SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_SETCHECK, BST_UNCHECKED, 0);
      //
      // Loop through the mapped controls
      //
      for (UINT iCount = 0; iCount < pMapEntry->nCtrlCount; iCount++)
      {
        HWND hwndCtrl = GetDlgItem(m_hPage, (pMapEntry->pMappedCtrls[iCount]));
        if (hwndCtrl != NULL)
        {
          EnableWindow(hwndCtrl, FALSE);
        }
      }

      pMapEntry++;
    }

  }
  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }

  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////


//+----------------------------------------------------------------------------
//
//  Member:     CDsOrganizationMultiUserPage::CDsOrganizationMultiUserPage
//
//-----------------------------------------------------------------------------
int gTitleOrgIDs[]    = { IDC_TITLE_EDIT };
int gTitleFlags[]     = { CLEAR_FIELD };
int gDeptOrgIDs[]     = { IDC_DEPT_EDIT };
int gDeptFlags[]      = { CLEAR_FIELD };
int gCompanyOrgIDs[]  = { IDC_COMPANY_EDIT };
int gCompanyFlags[]   = { CLEAR_FIELD };
int gManagerOrgIDs[]  = { IDC_NAME_STATIC, IDC_MANAGER_EDIT,               IDC_MGR_CHANGE_BTN, IDC_PROPPAGE_BTN,                    IDC_MGR_CLEAR_BTN };
int gManagerFlags[]   = { 0,               ALWAYS_DISABLED | CLEAR_FIELD,  0,                  IDC_MANAGER_EDIT | DISABLE_ON_EMPTY, 0 };

APPLY_MAP gpOrganizationPageMap[] = 
{ 
  { IDC_APPLY_TITLE_CHK, sizeof(gTitleOrgIDs)/sizeof(int), gTitleOrgIDs, gTitleFlags },
  { IDC_APPLY_DEPT_CHK, sizeof(gDeptOrgIDs)/sizeof(int), gDeptOrgIDs, gDeptFlags },
  { IDC_APPLY_COMPANY_CHK, sizeof(gCompanyOrgIDs)/sizeof(int), gCompanyOrgIDs, gCompanyFlags },
  { IDC_APPLY_MANAGER_CHK, sizeof(gManagerOrgIDs)/sizeof(int), gManagerOrgIDs, gManagerFlags },
  { NULL, NULL, NULL }
};


CDsOrganizationMultiUserPage::CDsOrganizationMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags)
  : CDsUserMultiPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  m_pApplyMap = gpOrganizationPageMap;
}

////////////////////////////////////////////////////////////////////////////////////


//+----------------------------------------------------------------------------
//
//  Member:     CDsAddressMultiUserPage::CDsAddressMultiUserPage
//
//-----------------------------------------------------------------------------
int gStreetAddrIDs[]  = { IDC_ADDRESS_EDIT };
int gStreetFlags[]    = { CLEAR_FIELD };
int gPOBoxAddrIDs[]   = { IDC_POBOX_EDIT };
int gPOBoxFlags[]     = { CLEAR_FIELD };
int gCityAddrIDs[]    = { IDC_CITY_EDIT };
int gCityFlags[]      = { CLEAR_FIELD };
int gStateAddrIDs[]   = { IDC_STATE_EDIT };
int gStateFlags[]     = { CLEAR_FIELD };
int gZipAddrIDs[]     = { IDC_ZIP_EDIT };
int gZipFlags[]       = { CLEAR_FIELD };
int gCountryAddrIDs[] = { IDC_COUNTRY_COMBO };
int gCountryFlags[]   = { 0 };

APPLY_MAP gpAddressPageMap[] = 
{ 
  { IDC_APPLY_STREET_CHK, sizeof(gStreetAddrIDs)/sizeof(int),   gStreetAddrIDs, gStreetFlags    },
  { IDC_APPLY_POBOX_CHK,  sizeof(gPOBoxAddrIDs)/sizeof(int),    gPOBoxAddrIDs,  gPOBoxFlags     },
  { IDC_APPLY_CITY_CHK,   sizeof(gCityAddrIDs)/sizeof(int),     gCityAddrIDs,   gCityFlags      },
  { IDC_APPLY_STATE_CHK,  sizeof(gStateAddrIDs)/sizeof(int),    gStateAddrIDs,  gStateFlags     },
  { IDC_APPLY_ZIP_CHK,    sizeof(gZipAddrIDs)/sizeof(int),      gZipAddrIDs,    gZipFlags       },
  { IDC_APPLY_COUNTRY_CHK,sizeof(gCountryAddrIDs)/sizeof(int),  gCountryAddrIDs,gCountryFlags   },
  { NULL, NULL, NULL }
};


CDsAddressMultiUserPage::CDsAddressMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags)
  : CDsUserMultiPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  m_pApplyMap = gpAddressPageMap;
}

////////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUserAcctPage::CDsMultiUserAcctPage
//
//-----------------------------------------------------------------------------
CDsMultiUserAcctPage::CDsMultiUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                           HWND hNotifyObj, DWORD dwFlags) :
    m_dwUsrAcctCtrl(0),
    m_pargbLogonHours(NULL),
    m_pWkstaDlg(NULL),
    m_fOrigCantChangePW(FALSE),
    m_pSelfSid(NULL),
    m_pWorldSid(NULL),
    m_fAcctCtrlChanged(FALSE),
    m_fAcctExpiresChanged(FALSE),
    m_fLogonHoursChanged(FALSE),
    m_fIsAdmin(FALSE),
    
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsMultiUserAcctPage,CDsMultiUserAcctPage);
  m_PwdLastSet.HighPart = m_PwdLastSet.LowPart = 0;
  m_fMultiselectPage = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUserAcctPage::~CDsMultiUserAcctPage
//
//-----------------------------------------------------------------------------
CDsMultiUserAcctPage::~CDsMultiUserAcctPage()
{
  TRACE(CDsMultiUserAcctPage,~CDsMultiUserAcctPage);
  if (m_pargbLogonHours != NULL)
  {
    LocalFree(m_pargbLogonHours);
  }
  if (m_pSelfSid)
  {
    FreeSid(m_pSelfSid);
  }
  if (m_pWorldSid)
  {
    FreeSid(m_pWorldSid);
  }
  DO_DEL(m_pWkstaDlg);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserMultiAcctPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateUserMultiAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                                PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                                CDSBasePathsInfo* /*pBasePathsInfo*/,
                                HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CDsMultiUserAcctPage);

  CDsMultiUserAcctPage * pPageObj = new CDsMultiUserAcctPage(pDsPage, pDataObj,
                                                             hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUserAcctPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uMsg)
  {
  case WM_INITDIALOG:
    return InitDlg(lParam);

  case WM_NOTIFY:
    return OnNotify(wParam, lParam);

  case WM_SHOWWINDOW:
    return OnShowWindow();

  case WM_SETFOCUS:
    return OnSetFocus((HWND)wParam);

  case WM_HELP:
    return OnHelp((LPHELPINFO)lParam);

  case WM_COMMAND:
    if (m_fInInit)
    {
      return TRUE;
    }
    return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                     GET_WM_COMMAND_HWND(wParam, lParam),
                     GET_WM_COMMAND_CMD(wParam, lParam)));
  case WM_DESTROY:
    return OnDestroy();

  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void CDsMultiUserAcctPage::Init(PWSTR pwzClass)
{
  TRACE(CDsMultiPageBase,Init);
  CWaitCursor cWait;

  if (!AllocWStr(pwzClass, &m_pwszObjClass))
  {
      m_hrInit = E_OUTOFMEMORY;
      return;
  }

  //
  // Allocate memory for the attribute data.
  //
  m_rgAttrData = new ATTR_DATA[m_cAttrs];
  CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

  memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

  //
  // Marshall the data object pointer for passing to the window proc thread.
  //
  HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                             &m_pDataObjStrm);
//  m_pDataObj = NULL; // to make sure no one calls here
  CHECK_HRESULT(hr, m_hrInit = hr; return);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMultiUserAcctPage::OnInitDialog(LPARAM)
{
  TRACE(CDsMultiUserAcctPage,OnInitDialog);
  HRESULT hr = S_OK;
  DWORD i, cAttrs = 0, iLogonWksta, iUPN, iLoghrs, iUAC, iLastSet,
        iExpires, iSid;
  CWaitCursor wait;

  TCHAR szTitle[MAX_PATH];
  if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
  {
      return HRESULT_FROM_WIN32(GetLastError());
  }

  if (!ADsPropSetHwndWithTitle(m_hNotifyObj, m_hPage, szTitle))
  {
    m_pWritableAttrs = NULL;
  }

  //
  // Add the check boxes to the scrolling checkbox list.
  //
  TCHAR tzList[161];
  HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);
  UINT rgIDS[] = {IDS_MUST_CHANGE_PW, IDS_CANT_CHANGE_PW, IDS_NO_PW_EXPIRE,
                  IDS_CLEAR_TEXT_PW, IDS_ACCT_DISABLED, IDS_SMARTCARD_REQ,
                  IDS_DELEGATION_OK, IDS_NOT_DELEGATED, IDS_DES_KEY_ONLY,
                  IDS_DONT_REQ_PREAUTH};
  for (i = 0; i < ARRAYLENGTH(rgIDS); i++)
  {
    LOAD_STRING(rgIDS[i], tzList, 160, return E_OUTOFMEMORY);
    int iItem = CheckList_AddItem(hChkList, tzList, rgIDS[i], BST_UNCHECKED);
    if (iItem != -1)
    {
      CheckList_SetItemCheck(hChkList, iItem, CLST_DISABLED, 2);
    }
  }

  iLogonWksta = iUPN = iLoghrs = iUAC = iLastSet = iExpires = iSid = cAttrs; // set to a flag value.

  //
  // Set default expiration
  //
  LARGE_INTEGER li;
  SYSTEMTIME st;
  GetSystemTime(&st);
  SystemTimeToFileTime(&st, (LPFILETIME)&li);

  //
  // The default account expiration time is 30 days from today.
  //
  li.QuadPart += DSPROP_FILETIMES_PER_MONTH;
  FILETIME ft;
  
  //
  // Convert the GMT time to Local time
  //
  FileTimeToLocalFileTime((LPFILETIME)&li, &ft);
  FileTimeToSystemTime(&ft, &st);

  //  
  // Initialize datepicker to expiration date
  //
  HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);

  DateTime_SetSystemtime(hctlDateTime, GDT_VALID, &st);
  EnableWindow(hctlDateTime, FALSE);

  SendDlgItemMessage(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO, BM_SETCHECK, BST_CHECKED, 0);

  //
  // Logon Workstations.
  //
  m_pWkstaDlg = new CLogonWkstaDlg(this);
  CHECK_NULL_REPORT(m_pWkstaDlg, m_hPage, return E_OUTOFMEMORY);

  if (iLogonWksta < cAttrs)
  {
    // User-Workstations is a comma-separated list of workstation names.
    // It is a single-valued attribute. We are using the Multi-valued
    // attribute edit dialog for updating this attribue but by setting the
    // last parameter to TRUE it will accept the the comma list.
    //
    hr = m_pWkstaDlg->Init(&LogonWkstaBtn, NULL,
                           TRUE,
                           MAX_LOGON_WKSTAS, TRUE);
  }
  else
  {
    hr = m_pWkstaDlg->Init(&LogonWkstaBtn, NULL,
                           TRUE,
                           MAX_LOGON_WKSTAS, TRUE);
  }
  CHECK_HRESULT(hr, return hr);

  //
  // Logon Hours.
  //
  if (iLoghrs < cAttrs)
  {
    ASSERT(m_pargbLogonHours == NULL && "Memory Leak");
    m_pargbLogonHours = (BYTE *)LocalAlloc(0, cbLogonHoursArrayLength); // Allocate 21 bytes
  }

  //
  // User Can't change password.
  //
  // Allocate Self and World (Everyone) SIDs.
  //
  {
    SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                             WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    if (!AllocateAndInitializeSid(&NtAuth,
                                  1,
                                  SECURITY_PRINCIPAL_SELF_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &m_pSelfSid))
    {
      DBG_OUT("AllocateAndInitializeSid failed!");
      ReportError(GetLastError(), 0, m_hPage);
      return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!AllocateAndInitializeSid(&WorldAuth,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &m_pWorldSid))
    {
      DBG_OUT("AllocateAndInitializeSid failed!");
      ReportError(GetLastError(), 0, m_hPage);
      return HRESULT_FROM_WIN32(GetLastError());
    }
  }

  FillSuffixCombo();

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUserAcctPage::FillSuffixCombo
//
//  Synopsis:   Put the UPN suffixes into the combo box.
//
//-----------------------------------------------------------------------------
BOOL CDsMultiUserAcctPage::FillSuffixCombo()
{
  HRESULT hr;
  int iCurSuffix = -1;
  PWSTR pwzDomain;
  DWORD cAttrs, i;
  CComPtr <IDirectoryObject> spOU;
  Smart_PADS_ATTR_INFO spAttrs;


  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return FALSE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return FALSE);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;
  dspAssert(pDsObjectNames != NULL);

  CStrW strServer;

  for (UINT idx = 0; idx < pDsObjectNames->cItems; idx++)
  {
    BOOL fFoundInOU = FALSE;
    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    //
    // See if there is a UPN Suffixes attribute set on the containing OU and
    // use that if found.
    //

    CComPtr<IADs> spIADs;
    CComPtr<IDirectoryObject> spDirObj;
    CComBSTR sbParentPath;
    Smart_PADS_ATTR_INFO pAttrs;
    PWSTR pwzUsrSuffix = NULL;

    hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (PVOID*)&spDirObj);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    //
    // Retrieve the user's suffix
    //
    PWSTR rgpwzAttrNames[] = {wzUPN};

    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames,
                                       ARRAYLENGTH(rgpwzAttrNames),
                                       &pAttrs, &cAttrs);
    if (!CHECK_ADS_HR(&hr, GetHWnd()))
    {
        return FALSE;
    }

    for (i = 0; i < cAttrs; i++)
    {
      dspAssert(pAttrs[i].dwNumValues);
      dspAssert(pAttrs[i].pADsValues);

      if (_wcsicmp(pAttrs[i].pszAttrName, wzUPN) == 0)
      {
        pwzUsrSuffix = wcsrchr(pAttrs[i].pADsValues->CaseIgnoreString, L'@');
      }
    }

    hr = spDirObj->QueryInterface(IID_IADs, (PVOID *)&spIADs);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spIADs->get_Parent(&sbParentPath);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = ADsOpenObject(sbParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (void **)&spOU);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    //
    // Store the server
    //
    hr = GetLdapServerName(spOU, strServer);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    PWSTR rgAttrs[] = {L"uPNSuffixes"};

    hr = spOU->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
      return FALSE;
    }

    if (cAttrs)
    {
      dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

      for (i = 0; i < spAttrs->dwNumValues; i++)
      {
        CStr csSuffix = L"@";
        csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

        if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                               (WPARAM)-1, (LPARAM)(LPCTSTR)csSuffix) == CB_ERR)
        {
          int pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                            CB_ADDSTRING, 0,
                                            (LPARAM)(LPCTSTR)csSuffix);

          if (pwzUsrSuffix && !wcscmp(csSuffix, pwzUsrSuffix))
          {
            iCurSuffix = pos;
          }
        }
      }

      SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                         (iCurSuffix > -1) ? iCurSuffix : 0, 0);
      fFoundInOU = TRUE;
    }

    if (fFoundInOU)
    {
      continue;
    }

    //
    // Add the user's suffix if it isn't already there
    //
    if (pwzUsrSuffix)
    {
      // User's UPN suffix does not match any of the defaults, so put
      // the user's into the combobox and select it.
      //
      if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                             (WPARAM)-1, (LPARAM)pwzUsrSuffix) == CB_ERR)
      {
        iCurSuffix = (int)SendDlgItemMessage(GetHWnd(),
                                             IDC_UPN_SUFFIX_COMBO,
                                             CB_ADDSTRING, 0,
                                             (LPARAM)pwzUsrSuffix);
      }
    }

    //
    // No UPN suffixes on the OU, get those for the domain.
    //

    // Get the name of the user's domain.
    //
    CSmartWStr spwzUserDN;

    hr = SkipPrefix(pwzObjADsPath, &spwzUserDN);
    CHECK_HRESULT(hr, return FALSE);

    //
    // Get the name of the root domain.
    //
    CComPtr <IDsBrowseDomainTree> spDsDomains;

    hr = CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          (LPVOID*)&spDsDomains);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    dspAssert(!strServer.IsEmpty());
    hr = spDsDomains->SetComputer(strServer, NULL, NULL);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    int pos;
    CStr csRootDomain = L"@";
    PDOMAIN_TREE pDomTree = NULL;

    hr = spDsDomains->GetDomains(&pDomTree, 0);

    CHECK_HRESULT(hr,;);

    hr = CrackName(spwzUserDN, &pwzDomain, GET_DNS_DOMAIN_NAME, GetHWnd());

    CHECK_HRESULT(hr, return FALSE);

    if (pDomTree)
    {
      for (UINT index = 0; index < pDomTree->dwCount; index++)
      {
        if (pDomTree->aDomains[index].pszTrustParent == NULL)
        {
          // Add the root domain only if it is a substring of the current
          // domain.
          //
          size_t cchRoot = wcslen(pDomTree->aDomains[index].pszName);
          PWSTR pRoot = pwzDomain + wcslen(pwzDomain) - cchRoot;

          if (!_wcsicmp(pRoot, pDomTree->aDomains[index].pszName))
          {
            csRootDomain += pDomTree->aDomains[index].pszName;

            if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                                   (WPARAM)-1, (LPARAM)(LPCTSTR)csRootDomain) == CB_ERR)
            {
              pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                            CB_ADDSTRING, 0,
                                            (LPARAM)(LPCTSTR)csRootDomain);

              if (pwzUsrSuffix && !_wcsicmp(csRootDomain, pwzUsrSuffix))
              {
                iCurSuffix = pos;
              }
            }
            break;
          }
        }
      }

      spDsDomains->FreeDomains(&pDomTree);
    }

    // If the local domain is not the root, add it as well.
    //
    CStr csLocalDomain = L"@";
    csLocalDomain += pwzDomain;

    LocalFreeStringW(&pwzDomain);

    if (_wcsicmp(csRootDomain, csLocalDomain))
    {
      if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                             (WPARAM)-1, (LPARAM)(LPCTSTR)csLocalDomain) == CB_ERR)
      {
        pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                      CB_ADDSTRING, 0,
                                      (LPARAM)(LPCTSTR)csLocalDomain);

        if (pwzUsrSuffix && !_wcsicmp(csLocalDomain, pwzUsrSuffix))
        {
          iCurSuffix = pos;
        }
      }
    }

    // Get UPN suffixes
    //
    CComBSTR bstrPartitions;
    //
    // get config path from main object
    //
    CComPtr<IADsPathname> spPathCracker;
    CDSBasePathsInfo CPaths;
    PWSTR pwzConfigPath;
    PDSDISPLAYSPECOPTIONS pDsDispSpecOptions;
    STGMEDIUM ObjMedium = {TYMED_NULL};
    FORMATETC fmteDispSpec = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1,
                              TYMED_HGLOBAL};

    hr = m_pWPTDataObj->GetData(&fmteDispSpec, &ObjMedium);

    if (RPC_E_SERVER_DIED_DNE == hr)
    {
      hr = CPaths.InitFromName(strServer);

      CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

      pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();
    }
    else
    {
      CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

      pDsDispSpecOptions = (PDSDISPLAYSPECOPTIONS)ObjMedium.hGlobal;

      if (pDsDispSpecOptions->offsetServerConfigPath)
      {
        pwzConfigPath = (PWSTR)ByteOffset(pDsDispSpecOptions,
                                          pDsDispSpecOptions->offsetServerConfigPath);
      }
      else
      {
        hr = CPaths.InitFromName(strServer);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

        pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();
      }
    }
    dspDebugOut((DEB_USER1, "Config path: %ws\n", pwzConfigPath));

    hr = GetADsPathname(spPathCracker);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

    hr = spPathCracker->Set(pwzConfigPath, ADS_SETTYPE_FULL);

    ReleaseStgMedium(&ObjMedium);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spPathCracker->AddLeafElement(g_wzPartitionsContainer);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);
    dspDebugOut((DEB_ITRACE, "Config path: %ws\n", bstrPartitions));

    CComPtr <IDirectoryObject> spPartitions;

    hr = ADsOpenObject(bstrPartitions, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (void **)&spPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    spAttrs.Empty();

    hr = spPartitions->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
      return FALSE;
    }

    if (cAttrs)
    {
      dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

      for (i = 0; i < spAttrs->dwNumValues; i++)
      {
        CStr csSuffix = L"@";
        csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

        if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                               CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)(LPCTSTR)csSuffix) == CB_ERR)
        {
          int suffixPos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                            CB_ADDSTRING, 0,
                                            (LPARAM)(LPCTSTR)csSuffix);

          if (pwzUsrSuffix && !wcscmp(csSuffix, pwzUsrSuffix))
          {
            iCurSuffix = suffixPos;
          }
        }
      }
    }

    SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                       (iCurSuffix > -1) ? iCurSuffix : 0, 0);
  } // for
  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUserAcctPage::OnApply(void)
{
  TRACE(CDsMultiUserAcctPage,OnApply);
  HRESULT hr = S_OK;
  BOOL fWritePwdLastSet = FALSE;
  BOOL bErrorOccurred = FALSE;

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
    DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Prepare the error structure
  //
  PWSTR pszTitle = NULL;
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  ADSPROPERROR adsPropError = {0};
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  ADSVALUE ADsValueAcctCtrl = {ADSTYPE_INTEGER, 0};
  ADS_ATTR_INFO AttrInfoAcctCtrl = {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                    ADSTYPE_INTEGER, &ADsValueAcctCtrl, 1};
  ADSVALUE ADsValueAcctExpires = {ADSTYPE_LARGE_INTEGER, 0};
  ADS_ATTR_INFO AttrInfoAcctExpires = {wzAcctExpires, ADS_ATTR_UPDATE,
                                       ADSTYPE_LARGE_INTEGER,
                                       &ADsValueAcctExpires, 1};
  ADSVALUE ADsValuePwdLastSet = {ADSTYPE_LARGE_INTEGER, NULL};
  ADS_ATTR_INFO AttrInfoPwdLastSet = {wzPwdLastSet, ADS_ATTR_UPDATE,
                                     ADSTYPE_LARGE_INTEGER,
                                     &ADsValuePwdLastSet, 1};
  ADSVALUE ADsValueLogonHours = {ADSTYPE_OCTET_STRING, NULL};
  ADS_ATTR_INFO AttrInfoLogonHours = {wzLogonHours, ADS_ATTR_UPDATE,
                                      ADSTYPE_OCTET_STRING,
                                      &ADsValueLogonHours, 1};
  ADS_ATTR_INFO AttrInfoLogonWksta = {wzUserWksta, ADS_ATTR_UPDATE,
                                      ADSTYPE_CASE_IGNORE_STRING,
                                      NULL, 1};
  // Array of attributes to write
  ADS_ATTR_INFO rgAttrs[5];
  DWORD cAttrs = 0;  // Number of attributes to write


  BOOL fDelegationChanged = FALSE;
  HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);
  //
  // User-Account-Control check boxes.
  //
  int dwNoPWExpire      = 0;
  int dwAcctDisabled    = 0;
  int dwClearTextPW     = 0;
  int dwSmartCardReq    = 0;
  int dwDelegOK         = 0;
  int dwNotDelegated    = 0;
  int dwDesKeyOnly      = 0;
  int dwDontReqPreAuth  = 0;

  DWORD dwUsrAcctCtrl   = 0;

  BOOL fApplyNoPWExpire     = FALSE;
  BOOL fApplyAcctDisabled   = FALSE;
  BOOL fApplyClearTextPW    = FALSE;
  BOOL fApplySmartCardReq   = FALSE;
  BOOL fApplyDelegOK        = FALSE;
  BOOL fApplyNotDelegated   = FALSE;
  BOOL fApplyDesKeyOnly     = FALSE;
  BOOL fApplyDontReqPreAuth = FALSE;

  if (m_fAcctCtrlChanged)
  {
    fApplyNoPWExpire = CheckList_GetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, 1);
    dwNoPWExpire = CheckList_GetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, 2);

    fApplyAcctDisabled = CheckList_GetLParamCheck(hChkList, IDS_ACCT_DISABLED, 1);
    dwAcctDisabled = CheckList_GetLParamCheck(hChkList, IDS_ACCT_DISABLED, 2);

    fApplyClearTextPW = CheckList_GetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, 1);
    dwClearTextPW = CheckList_GetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, 2);

    fApplySmartCardReq = CheckList_GetLParamCheck(hChkList, IDS_SMARTCARD_REQ, 1);
    dwSmartCardReq = CheckList_GetLParamCheck(hChkList, IDS_SMARTCARD_REQ, 2);

    fApplyDelegOK = CheckList_GetLParamCheck(hChkList, IDS_DELEGATION_OK, 1);
    dwDelegOK = CheckList_GetLParamCheck(hChkList, IDS_DELEGATION_OK, 2);

    fApplyNotDelegated = CheckList_GetLParamCheck(hChkList, IDS_NOT_DELEGATED, 1);
    dwNotDelegated = CheckList_GetLParamCheck(hChkList, IDS_NOT_DELEGATED, 2);

    fApplyDesKeyOnly = CheckList_GetLParamCheck(hChkList, IDS_DES_KEY_ONLY, 1);
    dwDesKeyOnly = CheckList_GetLParamCheck(hChkList, IDS_DES_KEY_ONLY, 2);

    fApplyDontReqPreAuth = CheckList_GetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, 1);
    dwDontReqPreAuth = CheckList_GetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, 2);

    ADsValueAcctCtrl.Integer = dwUsrAcctCtrl;
    rgAttrs[cAttrs++] = AttrInfoAcctCtrl;
  }

  //
  // Account Expires
  //
  LRESULT fApplyAcctExpires = SendDlgItemMessage(m_hPage, IDC_APPLY_EXPIRES_CHK, BM_GETCHECK, 0, 0);
  if (fApplyAcctExpires == BST_CHECKED)
  {
    ADsValueAcctExpires.LargeInteger.LowPart = 0;
    ADsValueAcctExpires.LargeInteger.HighPart = 0;
    if (IsDlgButtonChecked(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO) == BST_CHECKED)
    {
      //
      // Get the expire date from the control
      //
      HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);
      SYSTEMTIME st;   // Local time in a human-readable format

      LRESULT lResult = DateTime_GetSystemtime(hctlDateTime, &st);
      dspAssert(lResult == GDT_VALID); // The control should always have a valid time

      //
      // Zero the time part of the struct.
      //
      st.wHour = st.wMinute = st.wSecond = st.wMilliseconds = 0;
      FILETIME ftLocal;   // Local filetime
      FILETIME ftGMT;     // GMT filetime

      //
      // Convert the human-readable time to a cryptic local filetime format
      //
      SystemTimeToFileTime(&st, &ftLocal);

      //
      // Add a day since it expires at the beginning of the next day.
      //
      ADS_LARGE_INTEGER liADsExpiresDate;
      liADsExpiresDate.LowPart = ftLocal.dwLowDateTime;
      liADsExpiresDate.HighPart = ftLocal.dwHighDateTime;
      liADsExpiresDate.QuadPart += DSPROP_FILETIMES_PER_DAY;
      ftLocal.dwLowDateTime = liADsExpiresDate.LowPart;
      ftLocal.dwHighDateTime = liADsExpiresDate.HighPart;

      FileTimeToSystemTime(&ftLocal,&st);

      //
      //Convert time to UTC time
      //
      SYSTEMTIME stGMT;
      TzSpecificLocalTimeToSystemTime(NULL,&st,&stGMT);
      SystemTimeToFileTime(&stGMT,&ftGMT);

      //
      // Store the GMT time into the ADs value
      //
      ADsValueAcctExpires.LargeInteger.LowPart = ftGMT.dwLowDateTime;
      ADsValueAcctExpires.LargeInteger.HighPart = ftGMT.dwHighDateTime;
      dspDebugOut((DEB_ITRACE, "Setting Account-Expires to 0x%x,%08x\n",
                   ADsValueAcctExpires.LargeInteger.HighPart,
                   ADsValueAcctExpires.LargeInteger.LowPart));
    }
    rgAttrs[cAttrs++] = AttrInfoAcctExpires;
  }

  //
  // Logon hours
  //
  LRESULT fApplyLogonHours = SendDlgItemMessage(m_hPage, IDC_APPLY_HOURS_CHK, BM_GETCHECK, 0, 0);
  if (fApplyLogonHours == BST_CHECKED && m_pargbLogonHours != NULL && m_fLogonHoursChanged)
  {
    ADsValueLogonHours.OctetString.dwLength = cbLogonHoursArrayLength;
    ADsValueLogonHours.OctetString.lpValue = m_pargbLogonHours;
    ASSERT(cAttrs < ARRAYLENGTH(rgAttrs));
    rgAttrs[cAttrs++] = AttrInfoLogonHours;
  }

  //
  // Get PW check box values.
  //
  BOOL fApplyMustChangePW = CheckList_GetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, 1);
  BOOL fMustChangePW = CheckList_GetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, 2);

  BOOL fApplyCantChangePW = CheckList_GetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, 1);
  BOOL fNewCantChangePW = CheckList_GetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, 2);

  //
  // Enforce PW combination rules.
  //
  if (fApplyMustChangePW && fMustChangePW && 
      fApplyCantChangePW && fNewCantChangePW)
  {
    ErrMsg(IDS_ERR_BOTH_PW_BTNS, m_hPage);
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  if ((fApplyNoPWExpire && dwNoPWExpire) && (fApplyMustChangePW && fMustChangePW))
  {
    ErrMsg(IDS_PASSWORD_MUTEX, m_hPage);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 2);
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Logon Workstations.
  //
  LRESULT fApplyLogonComputers = SendDlgItemMessage(m_hPage, IDC_APPLY_COMPUTERS_CHK, BM_GETCHECK, 0, 0);
  if (fApplyLogonComputers == BST_CHECKED && m_pWkstaDlg && m_pWkstaDlg->IsDirty())
  {
    hr = m_pWkstaDlg->Write(&AttrInfoLogonWksta);

    CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

    rgAttrs[cAttrs++] = AttrInfoLogonWksta;
  }

  if (!cAttrs)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  for (UINT idx = 0; idx < pDsObjectNames->cItems; idx++)
  {
    DWORD dwNumAttrs = cAttrs;
    
    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);
    adsPropError.pszObjPath = pwzObjADsPath;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                       IID_IDirectoryObject, (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    //
    // Get the current user account control attribute value.
    //
    PADS_ATTR_INFO pAttrs = NULL;
    ULONG cUACAttrs = 0;
    PWSTR rgpwzAttrNames[] = {g_wzUserAccountControl, wzPwdLastSet};

    hr = spDirObject->GetObjectAttributes(rgpwzAttrNames,
                                          ARRAYLENGTH(rgpwzAttrNames),
                                          &pAttrs, 
                                          &cUACAttrs);
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    if (pAttrs == NULL || cUACAttrs < 1)
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    for (UINT iCount = 0; iCount < cUACAttrs; iCount++)
    {
      if (_wcsicmp(pAttrs[iCount].pszAttrName, g_wzUserAccountControl) == 0)
      {
        dwUsrAcctCtrl = pAttrs[iCount].pADsValues->Integer;
      }

      if (_wcsicmp(pAttrs[iCount].pszAttrName, wzPwdLastSet) == 0)
      {
        m_PwdLastSet.HighPart = pAttrs[iCount].pADsValues->LargeInteger.HighPart;
        m_PwdLastSet.LowPart = pAttrs[iCount].pADsValues->LargeInteger.LowPart;
      }

    }

    //
    // Set the new user account control value
    //
    if (fApplyNoPWExpire && (dwNoPWExpire == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_DONT_EXPIRE_PASSWD;
    }
    else if (fApplyNoPWExpire && dwNoPWExpire == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_DONT_EXPIRE_PASSWD);
    }

    if (fApplyAcctDisabled && (dwAcctDisabled == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_ACCOUNTDISABLE;
    }
    else if (fApplyAcctDisabled && dwAcctDisabled == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_ACCOUNTDISABLE);
    }

    if (fApplyClearTextPW && (dwClearTextPW == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
    }
    else if (fApplyClearTextPW && dwClearTextPW == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED);
    }

    if (fApplySmartCardReq && (dwSmartCardReq == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_SMARTCARD_REQUIRED;
    }
    else if (fApplySmartCardReq && dwSmartCardReq == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_SMARTCARD_REQUIRED);
    }

    if (fApplyDelegOK && (dwDelegOK == BST_CHECKED))
    {
      if (!(dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION))
      {
        dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
        fDelegationChanged = TRUE;
      }
    }
    else if (fApplyDelegOK && dwDelegOK == BST_UNCHECKED)
    {
      if (dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
      {
        dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
        fDelegationChanged = TRUE;
      }
    }

    if (fApplyNotDelegated && (dwNotDelegated == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_NOT_DELEGATED;
    }
    else if (fApplyNotDelegated && dwNotDelegated == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_NOT_DELEGATED);
    }

    if (fApplyDesKeyOnly && (dwDesKeyOnly == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_USE_DES_KEY_ONLY;
    }
    else if (fApplyDesKeyOnly && dwDesKeyOnly == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_USE_DES_KEY_ONLY);
    }

    if (fApplyDontReqPreAuth && (dwDontReqPreAuth == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_DONT_REQUIRE_PREAUTH;
    }
    else if (fApplyDontReqPreAuth && dwDontReqPreAuth == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_DONT_REQUIRE_PREAUTH);
    }

    ADsValueAcctCtrl.Integer = dwUsrAcctCtrl;
    
    if (fApplyMustChangePW && fMustChangePW)
    {
      if ((m_PwdLastSet.HighPart != 0) || (m_PwdLastSet.LowPart != 0))
      {
        ADsValuePwdLastSet.LargeInteger.LowPart = 0;
        ADsValuePwdLastSet.LargeInteger.HighPart = 0;
        fWritePwdLastSet = TRUE;
      }

      //
      // Make sure "User can't change password..." isn't set
      //
      CSimpleSecurityDescriptorHolder SDHolder;
      PACL pDacl = NULL;

      DWORD dwErr = GetNamedSecurityInfo(pwzObjADsPath,
                                         SE_DS_OBJECT_ALL,
                                         DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         &pDacl,
                                         NULL,
                                         &(SDHolder.m_pSD));

      dspAssert(IsValidAcl(pDacl));

      if (dwErr == ERROR_SUCCESS)
      {
        ULONG ulCount, j;
        PEXPLICIT_ACCESS rgEntries;

        dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);
        if (dwErr == ERROR_SUCCESS)
        {
          if (ulCount > 0)
          {
            BOOL fDenyAceFound = FALSE;

            for (j = 0; j < ulCount; j++)
            {
              if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                  (rgEntries[j].grfAccessMode == DENY_ACCESS))
              {
                OBJECTS_AND_SID * pObjectsAndSid;
                pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

                if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                                GUID_CONTROL_UserChangePassword) &&
                    (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                     EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
                {
                  fDenyAceFound = TRUE;
                  break;
                }
              }
            }

            if (fDenyAceFound)
            {
              if (!fApplyCantChangePW)
              {
                PTSTR ptzError = NULL;
                if (LoadStringToTchar(IDS_ERR_BOTH_PW_BTNS, &ptzError))
                {
                  adsPropError.hr = 0;
                  adsPropError.pszError = ptzError;
                  SendErrorMessage(&adsPropError);
                  bErrorOccurred = TRUE;
                  delete ptzError;

                  continue;
                }
              }
            }
          }
        }
      }
    }
    else if (fApplyMustChangePW && !fMustChangePW)
    {
      if ((m_PwdLastSet.HighPart == 0) && (m_PwdLastSet.LowPart == 0))
      {
        ADsValuePwdLastSet.LargeInteger.LowPart = 0xffffffff;
        ADsValuePwdLastSet.LargeInteger.HighPart = 0xffffffff;
        fWritePwdLastSet = TRUE;
      }
    }

    if (fWritePwdLastSet)
    {
      //
      // User-must-change-PW.
      //
      AttrInfoPwdLastSet.dwNumValues = 1;
      ASSERT(dwNumAttrs < ARRAYLENGTH(rgAttrs));
      rgAttrs[dwNumAttrs++] = AttrInfoPwdLastSet;
    }

    //
    // Check to be sure the user doesn't have "Password doesn't expire..." and
    // "User must change password..." set
    //
    if (((m_PwdLastSet.LowPart == 0 &&
          m_PwdLastSet.HighPart == 0 &&
          !fWritePwdLastSet) ||
         (ADsValuePwdLastSet.LargeInteger.LowPart == 0 &&
          ADsValuePwdLastSet.LargeInteger.HighPart == 0 &&
          fWritePwdLastSet)) &&
        (dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD))
    {
      PTSTR ptzError = NULL;
      if (LoadStringToTchar(IDS_ERR_BOTH_MUST_EXPIRES, &ptzError))
      {
        adsPropError.hr = 0;
        adsPropError.pszError = ptzError;
        SendErrorMessage(&adsPropError);
        bErrorOccurred = TRUE;
        delete ptzError;

        continue;
      }
    }



    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(rgAttrs, dwNumAttrs, &cModified);

    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;

      DWORD dwErr;
      WCHAR wszErrBuf[MAX_PATH+1];
      WCHAR wszNameBuf[MAX_PATH+1];
      ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

      if (dwErr)
      {
        dspDebugOut((DEB_ERROR,
                     "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                     wszErrBuf, wszNameBuf, __FILE__, __LINE__));

        if ((ERROR_PRIVILEGE_NOT_HELD == dwErr) && fDelegationChanged)
        {
          // Whoda thunk that a single bit in UAC has an access check on
          // it. Do special case error checking and reporting for the
          // delegate bit.
          //
          if (dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
          {
            dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
            CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_UNCHECKED);
          }
          else
          {
            dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
            CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_CHECKED);
          }
        }
      }
      else
      {
        dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", hr, __FILE__, __LINE__));
      }
      continue;
    }


    //
    // User-can't change password
    //
    if (fApplyCantChangePW)
    {

      //
      // Check to see if the user already had "User must change password..."
      // enabled outside the ui and warn the admin if it was and we are trying
      // to set "Can't change password..."
      //
      if (m_PwdLastSet.LowPart == 0 &&
          m_PwdLastSet.HighPart == 0)
      {
        if (!fApplyMustChangePW)
        {
          PTSTR ptzError = NULL;
          if (LoadStringToTchar(IDS_ERR_BOTH_PW_BTNS, &ptzError))
          {
            adsPropError.hr = hr;
            adsPropError.pszError = ptzError;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            delete ptzError;

            continue;
          }
        }
      }

      CSimpleSecurityDescriptorHolder SDHolder;
      PACL pDacl = NULL;
      CSimpleAclHolder NewDacl;

      DWORD dwErr = GetNamedSecurityInfo(pwzObjADsPath,
                                         SE_DS_OBJECT_ALL,
                                         DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         &pDacl,
                                         NULL,
                                         &(SDHolder.m_pSD));

      dspAssert(IsValidAcl(pDacl));
      CHECK_WIN32_REPORT(dwErr, m_hPage, adsPropError.hr = HRESULT_FROM_WIN32(dwErr); SendErrorMessage(&adsPropError); bErrorOccurred = TRUE; continue;);

      if (fNewCantChangePW)
      {
        //
        // Revoke the user's change password right by writing DENY ACEs.
        // Note that this can be an inherited right (which is the default
        // case), so attempting to remove GRANT ACEs is not sufficient.
        //
        EXPLICIT_ACCESS rgAccessEntry[2] = {0};
        OBJECTS_AND_SID rgObjectsAndSid[2] = {0};

        //
        // initialize the new entries (DENY ACE's)
        //
        rgAccessEntry[0].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgAccessEntry[0].grfAccessMode = DENY_ACCESS;
        rgAccessEntry[0].grfInheritance = NO_INHERITANCE;

        rgAccessEntry[1].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgAccessEntry[1].grfAccessMode = DENY_ACCESS;
        rgAccessEntry[1].grfInheritance = NO_INHERITANCE;

        // build the trustee structs for change password
        //
        BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[0].Trustee),
                                      &(rgObjectsAndSid[0]),
                                      const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pSelfSid);

        BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[1].Trustee),
                                      &(rgObjectsAndSid[1]),
                                      const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pWorldSid);
        // add the entries to the ACL
        //
        DBG_OUT("calling SetEntriesInAcl()");

        dwErr = SetEntriesInAcl(2, rgAccessEntry, pDacl, &(NewDacl.m_pAcl));
      }
      else
      {
        // Restore the user's change password right by removing any DENY ACEs.
        // If the GRANT ACEs are not present then we will add them back.
        // Bug #435315
        //
        ULONG ulCount, ulNewCount = 0, ulOldCount = 0, j;
        PEXPLICIT_ACCESS rgEntries, rgNewEntries;

        dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);

        if (dwErr != ERROR_SUCCESS) 
        {
          adsPropError.hr = HRESULT_FROM_WIN32(dwErr);
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          continue;
        }

        if (!ulCount)
        {
          adsPropError.hr = HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE; 
          continue;
        }


        //
        // Add to the count for the Allow ACEs if they are not there
        //
        ulOldCount = ulCount;
        ulCount += 2;

        rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, (ulCount) * sizeof(EXPLICIT_ACCESS));

        if (rgNewEntries == NULL)
        {
          LocalFree(rgEntries); 
          adsPropError.hr = E_OUTOFMEMORY;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          return PSNRET_INVALID_NOCHANGEPAGE;
        }

        for (j = 0; j < ulOldCount; j++)
        {
          BOOL fDenyAceFound = FALSE;

          if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
              (rgEntries[j].grfAccessMode == DENY_ACCESS))
          {
            OBJECTS_AND_SID * pObjectsAndSid;
            pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword) &&
                (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                 EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
            {
              fDenyAceFound = TRUE;
            }
          }

          if (!fDenyAceFound)
          {
            rgNewEntries[ulNewCount] = rgEntries[j];
            ulNewCount++;
          }
        }

        //
        // Add the allow aces
        //
        OBJECTS_AND_SID rgObjectsAndSid = {0};
        rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
        rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

        BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                      &(rgObjectsAndSid),
                                      const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pSelfSid);
        ulNewCount++;

        memset(&rgObjectsAndSid, 0, sizeof(OBJECTS_AND_SID));
        rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
        rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

        BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                      &(rgObjectsAndSid),
                                      const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pWorldSid);
        ulNewCount++;


        ACL EmptyAcl;
        InitializeAcl(&EmptyAcl, sizeof(ACL), ACL_REVISION_DS);

        //
        // Create a new ACL without the DENY entries.
        //
        DBG_OUT("calling SetEntriesInAcl()");

        dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, &EmptyAcl, &(NewDacl.m_pAcl));

        dspAssert(IsValidAcl(NewDacl.m_pAcl));
        LocalFree(rgEntries);
        LocalFree(rgNewEntries);
      }

      if (dwErr != ERROR_SUCCESS)
      {
        adsPropError.hr = HRESULT_FROM_WIN32(dwErr);
        SendErrorMessage(&adsPropError);
        bErrorOccurred = TRUE;
        continue;
      }

      dwErr = SetNamedSecurityInfo(pwzObjADsPath,
                                   SE_DS_OBJECT_ALL,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   NULL,
                                   NewDacl.m_pAcl,
                                   NULL);

      if (dwErr != ERROR_SUCCESS)
      {
        adsPropError.hr = HRESULT_FROM_WIN32(dwErr);
        SendErrorMessage(&adsPropError);
        bErrorOccurred = TRUE;
        continue;
      }
    }
  }  // for

  if (!bErrorOccurred)
  {
    //
    // Clean the changed flags for the controls and the workstation dialog
    //
    m_fAcctCtrlChanged = FALSE;
    m_fAcctExpiresChanged = FALSE;
    m_fLogonHoursChanged = FALSE;

    if (m_pWkstaDlg && m_pWkstaDlg->IsDirty())
    {
      m_pWkstaDlg->ClearDirty();
    }

    SendDlgItemMessage(m_hPage, IDC_APPLY_UPN_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_UPN_SUFFIX_COMBO), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_HOURS_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_HOURS_BTN), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_COMPUTERS_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_TO_BTN), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_EXPIRES_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), FALSE);

    CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, CLST_DISABLED, 2);
  }

  if (AttrInfoLogonWksta.pADsValues)
  {
    DO_DEL(AttrInfoLogonWksta.pADsValues->CaseIgnoreString);
    delete AttrInfoLogonWksta.pADsValues;
  }

  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }
  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUserAcctPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
  if (m_fInInit)
  {
    return 0;
  }

  switch (id)
  {
    case IDC_LOGON_HOURS_BTN:
      if (codeNotify == BN_CLICKED)
      {
        if (m_fIsAdmin)
        {
          MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_HOURS, m_hPage);
          break;
        }

        LPCWSTR pszRDN = GetObjRDName();
        HRESULT hr = DllScheduleDialog(m_hPage,
                                       &m_pargbLogonHours,
                                       (NULL != pszRDN)
                                           ? IDS_s_LOGON_HOURS_FOR
                                           : IDS_LOGON_HOURS,
                                       pszRDN );
        if (hr == S_OK)
        {
          m_fLogonHoursChanged = TRUE;
          SetDirty();
        }
      }
      break;

    case IDC_LOGON_TO_BTN:
      if (codeNotify == BN_CLICKED)
      {
        if (m_fIsAdmin)
        {
          MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_WKSTA, m_hPage);
          break;
        }
        if (m_pWkstaDlg && (m_pWkstaDlg->Edit() == IDOK))
        {
          if (m_pWkstaDlg->IsDirty())
          {
            SetDirty();
          }
        }
      }
      break;

    case IDC_ACCT_NEVER_EXPIRES_RADIO:
    case IDC_ACCT_EXPIRES_ON_RADIO:
      if (codeNotify == BN_CLICKED)
      {
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), id == IDC_ACCT_EXPIRES_ON_RADIO);
        m_fAcctExpiresChanged = TRUE;
        SetDirty();
      }
      return 1;

    case IDC_APPLY_UPN_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyUPN = SendDlgItemMessage(m_hPage, IDC_APPLY_UPN_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_UPN_SUFFIX_COMBO), lApplyUPN == BST_CHECKED);
        SetDirty();
      }
      break;

    case IDC_APPLY_HOURS_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyHours = SendDlgItemMessage(m_hPage, IDC_APPLY_HOURS_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_HOURS_BTN), lApplyHours == BST_CHECKED);
        SetDirty();
      }
      break;

    case IDC_APPLY_COMPUTERS_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyComputers = SendDlgItemMessage(m_hPage, IDC_APPLY_COMPUTERS_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_TO_BTN), lApplyComputers == BST_CHECKED);
        SetDirty();
      }
      break;

    case IDC_APPLY_EXPIRES_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyExpires = SendDlgItemMessage(m_hPage, IDC_APPLY_EXPIRES_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO), lApplyExpires == BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), lApplyExpires == BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), lApplyExpires == BST_CHECKED);
        SetDirty();
      }
      break;
  }
  return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUserAcctPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    NMHDR * pNmHdr = (NMHDR *)lParam;
    int codeNotify = pNmHdr->code;
    switch (wParam)
    {
    case IDC_CHECK_LIST:
      if (codeNotify == CLN_CLICK)
      {
        m_fAcctCtrlChanged = TRUE;
        SetDirty();

        NM_CHECKLIST* pnmc = reinterpret_cast<NM_CHECKLIST*>(lParam);
        if (pnmc != NULL)
        {
          int iResult = CheckList_GetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem);
          if (iResult == CLST_CHECKED)
          {
            int iCurrState = CheckList_GetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, 2);
            iCurrState = iCurrState & ~(CLST_DISABLED);
            CheckList_SetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, iCurrState, 2);
          }
          else if (iResult == CLST_UNCHECKED)
          {
            int iCurrState = CheckList_GetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, 2);
            iCurrState = (iCurrState | CLST_DISABLED) & ~CLST_CHECKED;
            CheckList_SetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, iCurrState, 2);
          }
        }
      }
      break;

    case IDC_ACCT_EXPIRES:
      dspDebugOut((DEB_ITRACE,
                   "OnNotify, id = IDC_ACCT_EXPIRES, code = 0x%x\n",
                   codeNotify));
      if (codeNotify == DTN_DATETIMECHANGE)
      {
        m_fAcctExpiresChanged = TRUE;
        SetDirty();
      }
      break;
    }
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUsrProfilePage::CDsMultiUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsMultiUsrProfilePage::CDsMultiUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                               HWND hNotifyObj, DWORD dwFlags) :
    m_ptszLocalHomeDir(NULL),
    m_ptszRemoteHomeDir(NULL),
    m_pwzSamName(NULL),
    m_nDrive(COMBO_Z_DRIVE),
    m_idHomeDirRadio(IDC_LOCAL_PATH_RADIO),
    m_fProfilePathWritable(FALSE),
    m_fScriptPathWritable(FALSE),
    m_fHomeDirWritable(FALSE),
    m_fHomeDriveWritable(FALSE),
    m_fProfilePathChanged(FALSE),
    m_fLogonScriptChanged(FALSE),
    m_fHomeDirChanged(FALSE),
    m_fHomeDriveChanged(FALSE),
    m_fSharedDirChanged(FALSE),
    m_pObjSID(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsUsrProfilePage,CDsUsrProfilePage);
#ifdef _DEBUG
  strcpy(szClass, "CDsUsrProfilePage");
#endif
  m_fMultiselectPage = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUsrProfilePage::~CDsMultiUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsMultiUsrProfilePage::~CDsMultiUsrProfilePage()
{
  TRACE(CDsMultiUsrProfilePage,~CDsMultiUsrProfilePage);
  if (m_ptszLocalHomeDir)
  {
    delete m_ptszLocalHomeDir;
  }
  if (m_ptszRemoteHomeDir)
  {
    delete m_ptszRemoteHomeDir;
  }
  if (m_pwzSamName)
  {
    delete[] m_pwzSamName;
  }
  DO_DEL(m_pObjSID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsMultiUsrProfilePage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateMultiUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                          PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                          CDSBasePathsInfo* /*pBasePathsInfo*/,
                          HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiUsrProfilePage);

  CDsMultiUsrProfilePage * pPageObj = new CDsMultiUsrProfilePage(pDsPage, pDataObj,
                                                       hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsMultiUsrProfilePage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uMsg)
  {
  case WM_INITDIALOG:
    return InitDlg(lParam);

  case WM_NOTIFY:
    return OnNotify(wParam, lParam);

  case WM_SHOWWINDOW:
    return OnShowWindow();

  case WM_SETFOCUS:
    return OnSetFocus((HWND)wParam);

  case WM_HELP:
    return OnHelp((LPHELPINFO)lParam);

  case WM_COMMAND:
    if (m_fInInit)
    {
      return TRUE;
    }
    return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                     GET_WM_COMMAND_HWND(wParam, lParam),
                     GET_WM_COMMAND_CMD(wParam, lParam)));
  case WM_DESTROY:
    return OnDestroy();

  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMultiUsrProfilePage::OnInitDialog(LPARAM)
{
  TRACE(CDsMultiUsrProfilePage,OnInitDialog);
  CWaitCursor wait;

  TCHAR szTitle[MAX_PATH];
  if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
  {
      return HRESULT_FROM_WIN32(GetLastError());
  }

  if (!ADsPropSetHwndWithTitle(m_hNotifyObj, m_hPage, szTitle))
  {
    m_pWritableAttrs = NULL;
  }

  m_fProfilePathWritable  = TRUE;
  m_fScriptPathWritable   = TRUE;
  m_fHomeDirWritable      = TRUE;
  m_fHomeDriveWritable    = TRUE;

  //
  // Set edit control length limits.
  //
  SendDlgItemMessage(m_hPage, IDC_PROFILE_PATH_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);
  SendDlgItemMessage(m_hPage, IDC_LOGON_SCRIPT_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);
  SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);
  SendDlgItemMessage(m_hPage, IDC_CONNECT_TO_PATH_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);

  //
  // Set the default radio to Local Path
  //
  SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_RADIO, BM_SETCHECK, BST_CHECKED, 0);

  //
  // Fill the home drive combobox.
  //
  TCHAR szDrive[3];
  _tcscpy(szDrive, TEXT("C:"));
  for (int i = 0; i <= COMBO_Z_DRIVE; i++)
  {
    szDrive[0]++;
    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_ADDSTRING, 0,
                       (LPARAM)szDrive);
  }

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUsrProfilePage::OnApply(void)
{
  TRACE(CDsMultiUsrProfilePage,OnApply);
  HRESULT hr = S_OK;
  BOOL bErrorOccurred = FALSE;
  UINT idx = 0;
  UINT i = 0;
  PADS_ATTR_INFO pAttrs = NULL;
  ULONG nCount = 0;
  LPWSTR rgpwzAttrNames[] = {g_wzObjectSID, wzSAMname};
  PWSTR pszTitle = NULL;

  LRESULT lApplyProfile = SendDlgItemMessage(m_hPage, IDC_APPLY_PROFILE_CHK, BM_GETCHECK, 0, 0);
  LRESULT lApplyScript  = SendDlgItemMessage(m_hPage, IDC_APPLY_SCRIPT_CHK, BM_GETCHECK, 0, 0);
  LRESULT lApplyHomeDir = SendDlgItemMessage(m_hPage, IDC_APPLY_HOMEDIR_CHK, BM_GETCHECK, 0, 0);

  if (lApplyProfile != BST_CHECKED &&
      lApplyScript  != BST_CHECKED &&
      lApplyHomeDir != BST_CHECKED)
  {
    //
    // Nothing is marked for apply
    //
    return PSNRET_NOERROR;
  }

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Prepare the error structure
  //
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  ADSPROPERROR adsPropError = {0};
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  ADSVALUE ADsValueProfilePath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoProfilePath = {wzProfilePath, ADS_ATTR_UPDATE,
                                       ADSTYPE_CASE_IGNORE_STRING,
                                       &ADsValueProfilePath, 1};
  ADSVALUE ADsValueScriptPath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoScriptPath = {wzScriptPath, ADS_ATTR_UPDATE,
                                      ADSTYPE_CASE_IGNORE_STRING,
                                      &ADsValueScriptPath, 1};
  ADSVALUE ADsValueHomeDir = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoHomeDir = {wzHomeDir, ADS_ATTR_UPDATE,
                                   ADSTYPE_CASE_IGNORE_STRING,
                                   &ADsValueHomeDir};
  ADSVALUE ADsValueHomeDrive = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoHomeDrive = {wzHomeDrive, ADS_ATTR_UPDATE,
                                     ADSTYPE_CASE_IGNORE_STRING,
                                     &ADsValueHomeDrive};
  // Array of attributes to write
  ADS_ATTR_INFO rgAttrs[4];
  DWORD cAttrs = 0, cDynamicAttrs = 0;
  TCHAR tsz[MAX_PATH+MAX_PATH+1];
  PTSTR ptsz;
  PWSTR pwzValue;
  BOOL bDirExist = FALSE;
  BOOL fExpanded = FALSE;

  //
  // Logon Script
  //
  if (lApplyScript == BST_CHECKED && m_fScriptPathWritable && m_fLogonScriptChanged)
  {
    if (GetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, tsz,
                       MAX_PATH+MAX_PATH) == 0)
    {
      // An empty control means remove the attribute value from the object.
      //
      AttrInfoScriptPath.dwControlCode = ADS_ATTR_CLEAR;
      AttrInfoScriptPath.dwNumValues = 0;
      AttrInfoScriptPath.pADsValues = NULL;
    }
    else
    {
      if (!TcharToUnicode(tsz, &pwzValue))
      {
        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
      }
      ADsValueScriptPath.CaseIgnoreString = pwzValue;
    }
    rgAttrs[cAttrs++] = AttrInfoScriptPath;
  }


  for (; idx < pDsObjectNames->cItems; idx++)
  {
    cDynamicAttrs = 0;
    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    adsPropError.pszObjPath = pwzObjADsPath;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = ADsOpenObject(pwzObjADsPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, 
                       IID_IDirectoryObject, (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    //
    // Get the object SID
    //
    hr = spDirObject->GetObjectAttributes(rgpwzAttrNames,
                                          ARRAYLENGTH(rgpwzAttrNames),
                                          &pAttrs, &nCount);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    //
    // Retrieve the current values
    //
    for (i = 0; i < nCount; i++)
    {
      if (_wcsicmp(pAttrs[i].pszAttrName, g_wzObjectSID) == 0)
      {
        if (IsValidSid(pAttrs[i].pADsValues->OctetString.lpValue))
        {
          if (m_pObjSID != NULL)
          {
            delete[] m_pObjSID;
          }
          m_pObjSID = new BYTE[pAttrs[i].pADsValues->OctetString.dwLength];

          if (m_pObjSID == NULL)
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            continue;
          }

          memcpy(m_pObjSID, pAttrs[i].pADsValues->OctetString.lpValue,
                 pAttrs[i].pADsValues->OctetString.dwLength);
        }
      }
      if (_wcsicmp(pAttrs[i].pszAttrName, wzSAMname) == 0)
      {
        if (m_pwzSamName != NULL)
        {
          delete[] m_pwzSamName;
          m_pwzSamName = NULL;
        }
        if (!AllocWStr(pAttrs[i].pADsValues->CaseIgnoreString, &m_pwzSamName))
        {
          adsPropError.hr = E_OUTOFMEMORY;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
        }
        continue;
      }
    }

    //
    // Profile Path
    //
    if (lApplyProfile == BST_CHECKED && m_fProfilePathWritable && m_fProfilePathChanged)
    {
      if (GetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, tsz,
                         MAX_PATH+MAX_PATH) == 0)
      {
        //
        // An empty control means remove the attribute value from the object.
        //
        AttrInfoProfilePath.dwControlCode = ADS_ATTR_CLEAR;
        AttrInfoProfilePath.dwNumValues = 0;
        AttrInfoProfilePath.pADsValues = NULL;
      }
      else
      {
        if (!TcharToUnicode(tsz, &pwzValue))
        {
          adsPropError.hr = E_OUTOFMEMORY;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          continue;
        }

        if (!ExpandUsername(pwzValue, fExpanded, &adsPropError))
        {
          continue;
        }
        if (fExpanded)
        {
          if (!UnicodeToTchar(pwzValue, &ptsz))
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            continue;
          }
          delete [] ptsz;
        }
        ADsValueProfilePath.CaseIgnoreString = pwzValue;
      }
      rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoProfilePath;
      cDynamicAttrs++;
    }

    //
    // Home Directory, Drive.
    //
    int nDirCtrl;
    if (lApplyHomeDir == BST_CHECKED && m_fHomeDirWritable && m_fHomeDriveWritable &&
        (m_fHomeDirChanged || m_fHomeDriveChanged))
    {
      LONG iSel;
      if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
      {
        nDirCtrl = IDC_LOCAL_PATH_EDIT;

        AttrInfoHomeDrive.dwControlCode = ADS_ATTR_CLEAR;
        AttrInfoHomeDrive.dwNumValues = 0;
        AttrInfoHomeDrive.pADsValues = NULL;
        rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoHomeDrive;
        cDynamicAttrs++;
      }
      else
      {
        nDirCtrl = IDC_CONNECT_TO_PATH_EDIT;

        iSel = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_GETCURSEL, 0, 0);

        dspAssert(iSel >= 0);

        if (iSel >= 0)
        {
          GetDlgItemText(m_hPage, IDC_DRIVES_COMBO, tsz, MAX_PATH+MAX_PATH);
        }
        else
        {
          _tcscpy(tsz, TEXT("Z:"));
        }

        if (!TcharToUnicode(tsz, &pwzValue))
        {
          if (pwzValue == NULL)
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            continue;
          }
        }

        AttrInfoHomeDrive.dwControlCode = ADS_ATTR_UPDATE;
        AttrInfoHomeDrive.dwNumValues = 1;
        AttrInfoHomeDrive.pADsValues = &ADsValueHomeDrive;
        ADsValueHomeDrive.CaseIgnoreString = pwzValue;
        rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoHomeDrive;
        cDynamicAttrs++;
      }

      int cch;
      cch = GetDlgItemText(m_hPage, nDirCtrl, tsz, MAX_PATH+MAX_PATH);

      if (!FIsValidUncPath(tsz, (nDirCtrl == IDC_LOCAL_PATH_EDIT) ? VUP_mskfAllowEmptyPath : VUP_mskfAllowUNCPath))
      {
        PTSTR ptzError = NULL;
        UINT nStringID = (nDirCtrl == IDC_LOCAL_PATH_EDIT) ? IDS_ERRMSG_INVALID_PATH : IDS_ERRMSG_INVALID_UNC_PATH;
        if (LoadStringToTchar(nStringID, &ptzError))
        {
          adsPropError.hr = 0;
          adsPropError.pszError = ptzError;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          delete ptzError;
          continue;
        }
      }

      if (cch == 0)
      {
        // An empty control means remove the attribute value from the object.
        //
        AttrInfoHomeDir.dwControlCode = ADS_ATTR_CLEAR;
        AttrInfoHomeDir.dwNumValues = 0;
        AttrInfoHomeDir.pADsValues = NULL;
      }
      else
      {
        if (!TcharToUnicode(tsz, &pwzValue))
        {
          adsPropError.hr = E_OUTOFMEMORY;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          continue;
        }

        if (!ExpandUsername(pwzValue, fExpanded, &adsPropError))
        {
          bErrorOccurred = TRUE;
          continue;
        }
        if (fExpanded)
        {
          if (!UnicodeToTchar(pwzValue, &ptsz))
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            continue;
          }
          if (nDirCtrl == IDC_LOCAL_PATH_EDIT)
          {
            if (m_ptszLocalHomeDir)
            {
              delete [] m_ptszLocalHomeDir;
            }
            m_ptszLocalHomeDir = new TCHAR[_tcslen(ptsz) + 1];
            if (m_ptszLocalHomeDir == NULL)
            {
              adsPropError.hr = E_OUTOFMEMORY;
              SendErrorMessage(&adsPropError);
              bErrorOccurred = TRUE;
              delete[] ptsz;
              continue;
            }
            _tcscpy(m_ptszLocalHomeDir, ptsz);
          }
          else
          {
            if (m_ptszRemoteHomeDir)
            {
              delete [] m_ptszRemoteHomeDir;
            }
            m_ptszRemoteHomeDir = new TCHAR[_tcslen(ptsz) + 1];
            if (m_ptszRemoteHomeDir == NULL)
            {
              adsPropError.hr = E_OUTOFMEMORY;
              SendErrorMessage(&adsPropError);
              bErrorOccurred = TRUE;
              delete[] ptsz;
              continue;
            }
            _tcscpy(m_ptszRemoteHomeDir, ptsz);
          }
          delete [] ptsz;
        }

        AttrInfoHomeDir.dwControlCode = ADS_ATTR_UPDATE;
        AttrInfoHomeDir.dwNumValues = 1;
        AttrInfoHomeDir.pADsValues = &ADsValueHomeDir;
        ADsValueHomeDir.CaseIgnoreString = pwzValue;
      }
      rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoHomeDir;
      cDynamicAttrs++;

      if (nDirCtrl == IDC_CONNECT_TO_PATH_EDIT)
      {
        dspAssert(m_pObjSID != NULL);

        //
        // attempt to create the directory.
        //  
        DWORD dwErr = ERROR_SUCCESS;             
        if(!fExpanded)        
        {   
            //If directory doesn't exist try to create it
            if(!bDirExist)
            {
                dwErr = DSPROP_CreateHomeDirectory(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
                if(dwErr != ERROR_SUCCESS)
                {
                    switch(dwErr)
                    {
                        case ERROR_ALREADY_EXISTS:
                        {
                            bDirExist = TRUE;
                            // Report a warning but continue
                            //
                            PWSTR* ppwzHomeDirName = &(ADsValueHomeDir.CaseIgnoreString);
                            SuperMsgBox(GetHWnd(),
                                        IDS_ALL_USERS_GIVEN_FULL_CONTROL, 
                                        0, 
                                        MB_OK | MB_ICONEXCLAMATION,
                                        hr, 
                                        (PVOID *)ppwzHomeDirName, 
                                        1,
                                        FALSE, 
                                        __FILE__, 
                                        __LINE__);
                            dwErr = ERROR_SUCCESS;
                            dwErr = AddFullControlForUser(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
                        
                        }
                        break;
                    }
                }
                else
                {
                    bDirExist = TRUE;

                    CComBSTR sbstrName;
                    CComPtr<IADsPathname> spPathCracker;
                    hr = GetADsPathname(spPathCracker);
                    if (SUCCEEDED(hr))
                    {
                      hr = spPathCracker->Set(pwzObjADsPath, ADS_SETTYPE_FULL);
                      if (SUCCEEDED(hr))
                      {
                        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
                        if (SUCCEEDED(hr))
                        {
                          hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &sbstrName);
                        }
                      }
                    }

                    if (sbstrName.Length() == 0)
                    {
                      sbstrName = pwzObjADsPath;
                    }

                    // Report a warning but continue
                    //
                    PVOID pvArgs[2] = {(PVOID)(ADsValueHomeDir.CaseIgnoreString),
                                        (PVOID)(PWSTR)sbstrName};

                    SuperMsgBox(GetHWnd(),
                                IDS_FIRST_USER_OWNER_ALL_FULL_CONTROL, 
                                0, 
                                MB_OK | MB_ICONEXCLAMATION,
                                hr, 
                                pvArgs,
                                2,
                                FALSE, 
                                __FILE__, 
                                __LINE__);
    
                }

            }
            else
                dwErr = AddFullControlForUser(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
        }                        
        else
            dwErr = DSPROP_CreateHomeDirectory(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);

        //Handle All Errors here
        if(dwErr != ERROR_SUCCESS)
        {
            switch(dwErr)
            {
                case ERROR_PATH_NOT_FOUND:
                case ERROR_BAD_NETPATH:
                case ERROR_ALREADY_EXISTS:
                case ERROR_LOGON_FAILURE:
                case ERROR_NOT_AUTHENTICATED:
                case ERROR_INVALID_PASSWORD:
                case ERROR_PASSWORD_EXPIRED:
                case ERROR_ACCOUNT_DISABLED:
                case ERROR_ACCOUNT_LOCKED_OUT:
                {
                    UINT nStringID = (ERROR_PATH_NOT_FOUND == dwErr) ? IDS_HOME_DIR_CREATE_FAILED :
                                                    IDS_HOME_DIR_CREATE_NO_ACCESS;
                    PTSTR ptzError = NULL;
                    if (LoadStringToTchar(nStringID, &ptzError))
                    {
                        adsPropError.hr = 0;
                        adsPropError.pszError = ptzError;
                        SendErrorMessage(&adsPropError);
                        bErrorOccurred = TRUE;
                        delete ptzError;
                    }
                }
                break;
                default:
                {
                    PTSTR ptzMsg = NULL;
                    LoadErrorMessage(dwErr, IDS_ERR_CREATE_DIR, &ptzMsg);
                    if (NULL == ptzMsg)
                    {
                      TCHAR tzBuf[80];
                      wsprintf(tzBuf, TEXT("Active Directory failure with code '0x%08x'!"), hr);
                      adsPropError.hr = 0;
                      adsPropError.pszError = tzBuf;
                      SendErrorMessage(&adsPropError);
                      bErrorOccurred = TRUE;
                      continue;
                    }
                    adsPropError.hr = 0;
                    adsPropError.pszError = ptzMsg;
                    SendErrorMessage(&adsPropError);
                    bErrorOccurred = TRUE;
                    delete ptzMsg;
                    continue;
                }
            }
        }
      }
    }

    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(rgAttrs, cAttrs + cDynamicAttrs, &cModified);
    
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
    }

    //
    // Cleanup allocated values
    //
    if (ADsValueProfilePath.CaseIgnoreString)
    {
      delete ADsValueProfilePath.CaseIgnoreString;
      ADsValueProfilePath.CaseIgnoreString = NULL;
    }
    if (ADsValueHomeDir.CaseIgnoreString)
    {
      delete ADsValueHomeDir.CaseIgnoreString;
      ADsValueHomeDir.CaseIgnoreString = NULL;
    }
    if (ADsValueHomeDrive.CaseIgnoreString)
    {
      delete ADsValueHomeDrive.CaseIgnoreString;
      ADsValueHomeDrive.CaseIgnoreString = NULL;
    }
  }

  //Clean Up this after the for loop
  if (ADsValueScriptPath.CaseIgnoreString)
  {
    delete ADsValueScriptPath.CaseIgnoreString;
    ADsValueScriptPath.CaseIgnoreString = NULL;
  }

  if (!bErrorOccurred)
  {
    m_fProfilePathChanged = FALSE;
    m_fLogonScriptChanged = FALSE;
    m_fHomeDirChanged = FALSE;
    m_fHomeDriveChanged = FALSE;
    m_fSharedDirChanged = FALSE;

    //
    // Uncheck the Apply checkboxes
    //
    SendDlgItemMessage(m_hPage, IDC_APPLY_PROFILE_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_PROFILE_PATH_EDIT), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_SCRIPT_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_SCRIPT_EDIT), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_HOMEDIR_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
  }

Cleanup:

  if (ADsValueProfilePath.CaseIgnoreString)
  {
    delete ADsValueProfilePath.CaseIgnoreString;
  }
  if (ADsValueScriptPath.CaseIgnoreString)
  {
    delete ADsValueScriptPath.CaseIgnoreString;
  }
  if (ADsValueHomeDir.CaseIgnoreString)
  {
    delete ADsValueHomeDir.CaseIgnoreString;
  }
  if (ADsValueHomeDrive.CaseIgnoreString)
  {
    delete ADsValueHomeDrive.CaseIgnoreString;
  }

  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }

  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::ExpandUsername
//
//  Synopsis:   If the %username% token is found in the string, substitute
//              the SAM account name.
//
//-----------------------------------------------------------------------------
BOOL CDsMultiUsrProfilePage::ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded, PADSPROPERROR pError)
{
  dspAssert(pwzValue);

  CStrW strUserToken;

  strUserToken.LoadString(g_hInstance, IDS_PROFILE_USER_TOKEN);

  unsigned int TokenLength = strUserToken.GetLength();

  if (!TokenLength)
  {
    if (pError == NULL)
    {
      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
    }
    else
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }
  }

  PWSTR pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

  if (pwzTokenStart)
  {
    if (!m_pwzSamName)
    {
      TCHAR szMsg[MAX_ERRORMSG+1];
      PTSTR ptzFormatString = NULL;
      if (LoadStringToTchar(IDS_NO_SAMNAME_FOR_PROFILE, &ptzFormatString))
      {
        wsprintf(szMsg, ptzFormatString, strUserToken);
        pError->hr = 0;
        pError->pszError = szMsg;
        SendErrorMessage(pError);
        return FALSE;
      }
      return FALSE;
    }
    if ((wcslen(pwzTokenStart) >= TokenLength) &&
        (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0))
    {
      fExpanded = TRUE;
    }
    else
    {
      fExpanded = FALSE;
      return TRUE;
    }
  }
  else
  {
    fExpanded = FALSE;
    return TRUE;
  }

  CStrW strValue, strAfterToken;

  while (pwzTokenStart)
  {
    *pwzTokenStart = L'\0';

    strValue = pwzValue;

    if ((L'\0' != *pwzValue) && !strValue.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

    strAfterToken = pwzAfterToken;

    if ((L'\0' != *pwzAfterToken) && !strAfterToken.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    delete pwzValue;

    strValue += m_pwzSamName;

    if (!strValue.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    strValue += strAfterToken;

    if (!strValue.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    if (!AllocWStr((PWSTR)(LPCWSTR)strValue, &pwzValue))
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

    if (!(pwzTokenStart &&
          (wcslen(pwzTokenStart) >= TokenLength) &&
          (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0)))
    {
      return TRUE;
    }
  }

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsMultiUsrProfilePage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    TCHAR tsz[MAX_PATH+MAX_PATH+1];
    int idNewHomeDirRadio = -1;

    switch (id)
    {
    case IDC_LOCAL_PATH_EDIT:
        if (codeNotify == EN_KILLFOCUS)
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszLocalHomeDir)
                {
                    delete m_ptszLocalHomeDir;
                    m_ptszLocalHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszLocalHomeDir || _tcscmp(tsz, m_ptszLocalHomeDir))
                {
                    if (m_ptszLocalHomeDir)
                    {
                        delete m_ptszLocalHomeDir;
                    }

                    m_ptszLocalHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszLocalHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszLocalHomeDir, tsz);
                }
            }
            break;
        }
        // fall through
    case IDC_CONNECT_TO_PATH_EDIT:
    case IDC_DRIVES_COMBO:
        if ((codeNotify == EN_KILLFOCUS) || (codeNotify == CBN_KILLFOCUS))
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszRemoteHomeDir)
                {
                    delete m_ptszRemoteHomeDir;
                    m_ptszRemoteHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszRemoteHomeDir || _tcscmp(tsz, m_ptszRemoteHomeDir))
                {
                    if (m_ptszRemoteHomeDir)
                    {
                        delete m_ptszRemoteHomeDir;
                    }

                    m_ptszRemoteHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszRemoteHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszRemoteHomeDir, tsz);
                }
            }
            break;
        }

        if ((codeNotify == EN_SETFOCUS) || (codeNotify == CBN_SETFOCUS))
        {
            // Toggle the radio buttons if needed.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (IsDlgButtonChecked(m_hPage, IDC_CONNECT_TO_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_LOCAL_PATH_RADIO;

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_UNCHECKED);
                }
            }
            else
            {
                if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_CONNECT_TO_RADIO;

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_UNCHECKED);
                }
            }
            //
            // Restore the incoming edit control and clear the other if needed.
            // Also set or clear the drives combo as appropiate.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (idNewHomeDirRadio == IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);
                }
            }
            else
            {
                if (idNewHomeDirRadio == IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);
                }
            }
            if (idNewHomeDirRadio != -1)
            {
                m_idHomeDirRadio = idNewHomeDirRadio;
            }
            break;
        }

        if (id == IDC_DRIVES_COMBO && codeNotify == CBN_SELCHANGE)
        {
            m_nDrive = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO,
                                               CB_GETCURSEL, 0, 0);
            SetDirty();
            m_fHomeDriveChanged = TRUE;
            break;
        }
        if ((id == IDC_LOCAL_PATH_EDIT || IDC_CONNECT_TO_PATH_EDIT == id)
            && codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fHomeDirChanged = TRUE;
        }
        break;

    case IDC_PROFILE_PATH_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fProfilePathChanged = TRUE;
        }
        break;

    case IDC_LOGON_SCRIPT_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fLogonScriptChanged = TRUE;
        }
        break;

    case IDC_LOCAL_PATH_RADIO:
    case IDC_CONNECT_TO_RADIO:
        if (codeNotify == BN_CLICKED)
        {
            if (id == IDC_LOCAL_PATH_RADIO)
            {
                if (m_idHomeDirRadio != IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);

                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
                }
            }
            else
            {
                if (m_idHomeDirRadio != IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);

                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
                }
            }
            if (m_idHomeDirRadio != id)
            {
                m_idHomeDirRadio = id;
                SetDirty();
                m_fHomeDriveChanged = TRUE;
                m_fHomeDirChanged = TRUE;
            }
        }
        return 1;
    case IDC_APPLY_PROFILE_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyProfile = SendDlgItemMessage(m_hPage, IDC_APPLY_PROFILE_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_PROFILE_PATH_EDIT), lApplyProfile == BST_CHECKED);
        if (lApplyProfile == BST_UNCHECKED)
        {
          SetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, L"");
        }
        else
        {
          //This is to allow NULL value for Profile.
          m_fProfilePathChanged = TRUE;
        }
        SetDirty();
      }
      break;

    case IDC_APPLY_SCRIPT_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyScript = SendDlgItemMessage(m_hPage, IDC_APPLY_SCRIPT_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_SCRIPT_EDIT), lApplyScript == BST_CHECKED);
        if (lApplyScript == BST_UNCHECKED)
        {
          SetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, L"");
        }
        else
        {
            m_fLogonScriptChanged = TRUE;
        }
        SetDirty();
      }
      break;
        
    case IDC_APPLY_HOMEDIR_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyHomeDir = SendDlgItemMessage(m_hPage, IDC_APPLY_HOMEDIR_CHK, BM_GETCHECK, 0, 0);
        LRESULT lLocalPathChk = SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_RADIO, BM_GETCHECK, 0, 0);

        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_RADIO), lApplyHomeDir == BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_RADIO), lApplyHomeDir == BST_CHECKED);

        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), lApplyHomeDir == BST_CHECKED && lLocalPathChk == BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), lApplyHomeDir == BST_CHECKED && lLocalPathChk != BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), lApplyHomeDir == BST_CHECKED && lLocalPathChk != BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), lApplyHomeDir == BST_CHECKED && lLocalPathChk != BST_CHECKED);
        if (lApplyHomeDir == BST_UNCHECKED)
        {
          SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, L"");
          SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, L"");
        }
        else
        {
            m_fHomeDirChanged = TRUE;
        }
        SetDirty();
      }
      break;

    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void CDsMultiUsrProfilePage::Init(PWSTR pwzClass)
{
  TRACE(CDsMultiUsrProfilePage,Init);
  CWaitCursor cWait;

  if (!AllocWStr(pwzClass, &m_pwszObjClass))
  {
    m_hrInit = E_OUTOFMEMORY;
    return;
  }

  //
  // Allocate memory for the attribute data.
  //
  m_rgAttrData = new ATTR_DATA[m_cAttrs];
  CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

  memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

  //
  // Marshall the data object pointer for passing to the window proc thread.
  //
  HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                             &m_pDataObjStrm);
//  m_pDataObj = NULL; // to make sure no one calls here
  CHECK_HRESULT(hr, m_hrInit = hr; return);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUsrProfilePage::OnNotify(WPARAM wParam, LPARAM lParam)
{
  return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUsrProfilePage::OnDestroy(void)
{
  if (m_ptszLocalHomeDir)
  {
    delete m_ptszLocalHomeDir;
    m_ptszLocalHomeDir = NULL;
  }
  if (m_ptszRemoteHomeDir)
  {
    delete m_ptszRemoteHomeDir;
    m_ptszRemoteHomeDir = NULL;
  }
  CDsPropPageBase::OnDestroy();
  // If an application processes this message, it should return zero.
  return 0;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\pagetable.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       pagetable.cxx
//
//  Contents:   Tables and definitions for table-driven DS property pages
//
//  History:    24-March-97 EricB created
//
//  Note:       Attribute LDAP display names, types, upper ranges, and so
//              forth, have been manually copied from schema.ini. Thus,
//              consistency is going to be difficult to maintain. If you know
//              of schema.ini changes that affect any of the attributes in
//              this file, then please make any necessary corrections here.
//
//  Note:       Some attr table entries are used to handle the processing of
//              buttons and check boxes by declaring attr functions. If an
//              attr map entry of this sort is not going to read or write an
//              actual DS attribute, then the attr name must be NULL and the
//              read-only element must be set to TRUE.
//
//              Attr functions can store data between DLG_OP calls by the
//              use of the second to last param, a PVOID * value, which has
//              a unique instance allocated for each attr function. If
//              different attr functions (on the same page) need to share data,
//              they can all use the pPage->m_pData member. This datum is a
//              member of the CDsTableDrivenPage class rather than the base
//              class, so you will need to cast pPage to CDsTableDrivenPage to
//              access m_pData.
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"
#include "group.h"
#include "domain.h"
#include "computer.h"
#include "trust.h"
#include "siterepl.h"
#include "managdby.h"
#include "UserCert.h"
#include "fpnw.h"
#include "multi.h"
#include "ScopeDelegation.h"
#include "pages.hm" // HIDC_*
#include <ntdsadef.h>

#include "dsprop.cxx"

//+----------------------------------------------------------------------------
// User Object.
//-----------------------------------------------------------------------------

//
// General page, first name
//
ATTR_MAP UGFirstName = {IDC_FIRST_NAME_EDIT, FALSE, FALSE, 64,
                        {L"givenName", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, first name
//
ATTR_MAP UGInitials = {IDC_INITIALS_EDIT, FALSE, FALSE, 6,
                       {L"initials", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, last name
//
ATTR_MAP UGLastName = {IDC_LAST_NAME_EDIT, FALSE, FALSE, 64,
                       {L"sn", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// General page, display name
//
ATTR_MAP UGDisplayName = {IDC_DISPLAYNAME_EDIT, FALSE, FALSE, 256,
                          {L"displayName", ADS_ATTR_UPDATE,
                           ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, office
//
ATTR_MAP UGOffice = {IDC_OFFICE_EDIT, FALSE, FALSE, 128,
                     {L"physicalDeliveryOfficeName", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, phone number
//
ATTR_MAP UGPhone = {IDC_PHONE_EDIT, FALSE, FALSE, 64,
                    {L"telephoneNumber", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, other phone numbers
//
ATTR_MAP UGOtherPhone = {IDC_OTHER_PHONE_BTN, FALSE, TRUE, 64,
                         {L"otherTelephone", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// General page, email
//
ATTR_MAP UGEMail = {IDC_EMAIL_EDIT, FALSE, FALSE, 256,
                    {L"mail", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                     NULL, 0}, MailAttr, NULL};

//
// General page, user's home page
//
ATTR_MAP UGURL = {IDC_HOME_PAGE_EDIT, FALSE, FALSE, 2048,
                  {L"wWWHomePage", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                   NULL, 0}, NULL, NULL};
//
// General page, other home pages
//
ATTR_MAP UGOtherURL = {IDC_OTHER_URL_BTN, FALSE, TRUE, 2048,
                       {L"url", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// The list of attributes on the User General page.
//
PATTR_MAP rgpUGAttrMap[] = {{&GenIcon}, {&AttrName}, {&UGFirstName},
                            {&UGInitials},
                            {&UGLastName}, {&UGDisplayName}, {&Description},
                            {&UGOffice}, {&UGPhone}, {&UGOtherPhone},
                            {&UGEMail}, {&UGURL}, {&UGOtherURL}};
//
// The User General page description.
//
DSPAGE UserGeneral = {IDS_TITLE_GENERAL, IDD_USER, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpUGAttrMap)/sizeof(PATTR_MAP), rgpUGAttrMap};

//----------------------------------------------
// The User Account page description.
//
DSPAGE UserAccount = {IDS_USER_TITLE_ACCT, IDD_ACCOUNT, 0, 0, NULL,
                      CreateUserAcctPage, 0, NULL};

//----------------------------------------------
// The User Profile page description.
//
DSPAGE UserProfile = {IDS_USER_TITLE_PROFILE, IDD_USR_PROFILE, 0, 0, NULL,
                      CreateUsrProfilePage, 0, NULL};

//----------------------------------------------
// Phone/Notes page, Home phone primary/other
//
ATTR_MAP UPhHomePhone = {IDC_HOMEPHONE_EDIT, FALSE, FALSE, 64,
                         {L"homePhone", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP UPhHomeOther = {IDC_OTHER_HOME_BTN, FALSE, TRUE, 64,
                         {L"otherHomePhone", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, Pager
//
ATTR_MAP UPhPager = {IDC_PAGER_EDIT, FALSE, FALSE, 64,
                     {L"pager", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherPager = {IDC_OTHER_PAGER_BTN, FALSE, TRUE, 64,
                          {L"otherPager", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, Mobile
//
ATTR_MAP UPhMobile = {IDC_MOBILE_EDIT, FALSE, FALSE, 64,
                      {L"mobile", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherMobile = {IDC_OTHER_MOBLE_BTN, FALSE, TRUE, 64,
                          {L"otherMobile", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, FAX
//
ATTR_MAP UPhFax = {IDC_FAX_EDIT, FALSE, FALSE, 64,
                   {L"facsimileTelephoneNumber", ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherFax = {IDC_OTHER_FAX_BTN, FALSE, TRUE, 64,
                        {L"otherFacsimileTelephoneNumber", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, IP phone
//
ATTR_MAP UPhIP = {IDC_IP_EDIT, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                   {L"ipPhone", ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherIP = {IDC_OTHER_IP_BTN, FALSE, TRUE, ATTR_LEN_UNLIMITED,
                        {L"otherIpPhone", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, Comments (the size limit is arbitrary; the schema doesn't
// specify an absolute limit).
//
ATTR_MAP UPhComments = {IDC_COMMENT_EDIT, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                        {L"info", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Phone/Notes page.
//
PATTR_MAP rgpUPhoneAttrMap[] = {{&UPhHomePhone}, {&UPhHomeOther}, {&UPhPager},
                                {&UPhOtherPager}, {&UPhMobile}, {&UPhOtherMobile},
                                {&UPhOtherFax}, {&UPhFax}, {&UPhIP},
                                {&UPhOtherIP}, {&UPhComments}};
//
// The Phone/Notes page description.
//
DSPAGE PhoneNotes = {IDS_PHONE_NOTES, IDD_PHONE, 0, 0, NULL,
                     CreateTableDrivenPage,
                     sizeof(rgpUPhoneAttrMap)/sizeof(PATTR_MAP),
                     rgpUPhoneAttrMap};

//----------------------------------------------
// Organization page, Title
//
ATTR_MAP UOrgTitle = {IDC_TITLE_EDIT, FALSE, FALSE, 64,
                      {L"title", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Organization page, Department
//
ATTR_MAP UOrgDept = {IDC_DEPT_EDIT, FALSE, FALSE, 64,
                     {L"department", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Organization page, Company
//
ATTR_MAP UOrgCo = {IDC_COMPANY_EDIT, FALSE, FALSE, 64,
                   {L"company", ADS_ATTR_UPDATE,
                   ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Organization page, Manager
//
ATTR_MAP UOrgMgr = {IDC_MANAGER_EDIT, FALSE, FALSE,
                    ATTR_LEN_UNLIMITED, {L"manager", ADS_ATTR_UPDATE,
                    ADSTYPE_DN_STRING, NULL, 0}, ManagerEdit, NULL};
//
// Organization page, Manager Change Button
//
ATTR_MAP UOrgChgBtn = {IDC_MGR_CHANGE_BTN, TRUE, FALSE, 0,
                       {NULL, ADS_ATTR_UPDATE,
                       ADSTYPE_INVALID, NULL, 0}, ManagerChangeBtn, NULL};
//
// Organization page, View Manager Properties Button
//
ATTR_MAP UOrgPropBtn = {IDC_PROPPAGE_BTN, TRUE, FALSE, 0,
                        {NULL, ADS_ATTR_UPDATE,
                        ADSTYPE_INVALID, NULL, 0}, MgrPropBtn, NULL};
//
// Organization page, Clear Manager Button
//
ATTR_MAP UOrgClrMgrBtn = {IDC_MGR_CLEAR_BTN, TRUE, FALSE, 0,
                          {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INVALID, NULL, 0}, ClearMgrBtn, NULL};
//
// Organization page, Direct Reports
//
ATTR_MAP UOrgReports = {IDC_REPORTS_LIST, TRUE /* fReadOnly */, TRUE, 0,
                        {L"directReports", ADS_ATTR_UPDATE,
                        ADSTYPE_DN_STRING, NULL, 0}, DirectReportsList, NULL};
//
// Organization page, Add Direct Reports Button (NOT IMPLEMENTED)
//
ATTR_MAP UOrgAddReportsBtn = {IDC_ADD_BTN, TRUE /* fReadOnly */, FALSE, 0,
                              {NULL, ADS_ATTR_UPDATE, ADSTYPE_INVALID, NULL, 0},
                              AddReportsBtn, NULL};
//
// Organization page, Remove Direct Reports Button (NOT IMPLEMENTED)
//
ATTR_MAP UOrgRmReportsBtn = {IDC_REMOVE_BTN, TRUE, FALSE, 0,
                             {NULL, ADS_ATTR_UPDATE, ADSTYPE_INVALID, NULL, 0},
                             RmReportsBtn, NULL};
//
// The list of attributes on the Organization page.
//
PATTR_MAP rgpUOrgAttrMap[] = {{&UOrgTitle}, {&UOrgDept}, {&UOrgCo},
                              {&UOrgMgr}, {&UOrgChgBtn}, {&UOrgPropBtn},
                              {&UOrgClrMgrBtn}, {&UOrgReports}};
                              //{&UOrgAddReportsBtn}, {&UOrgRmReportsBtn}};
//
// The Organization page description.
//
DSPAGE UserOrg = {IDS_USER_TITLE_ORG, IDD_USER_ORG, 0, 0, NULL,
                  CreateTableDrivenPage,
                  sizeof(rgpUOrgAttrMap)/sizeof(PATTR_MAP), rgpUOrgAttrMap};

//+----------------------------------------------------------------------------
// Delegation Page.
//-----------------------------------------------------------------------------
//
// The Computer Delegation page
//
DSPAGE UserDelegationPage = { IDS_TITLE_DELEGATION, IDD_COMPUTER_DELEGATION, 0, 0, NULL,
                                  CreateUserDelegationPage,
                                  0, NULL };

//+----------------------------------------------------------------------------
// Membership Page.
//-----------------------------------------------------------------------------

//
// The Membership page description.
//
DSPAGE MemberPage = {IDS_USER_TITLE_MBR_OF, IDD_MEMBER, 0, 0, NULL,
                     CreateMembershipPage, 0, NULL};

//
// The Membership page description for non-security-principle objects.
//
DSPAGE NonSecMemberPage = {IDS_USER_TITLE_MBR_OF, IDD_MEMBER, 0, 0, NULL,
                           CreateNonSecMembershipPage, 0, NULL};
//
// The list of Membership pages.
//
PDSPAGE rgMemberPages[] = {{&MemberPage}};

//
// The Membership class description.
//
DSCLASSPAGES MemberCls = {&CLSID_DsMemberOfPropPages, TEXT("Membership"),
                          sizeof(rgMemberPages)/sizeof(PDSPAGE),
                          rgMemberPages};

//+----------------------------------------------------------------------------
// Published Certificates Page.
//-----------------------------------------------------------------------------

//
// The Published Certificates page description.
//
DSPAGE PubCertPage = {IDS_USER_TITLE_PUBLISHED_CERTS, IDD_USER_CERTIFICATES,
                      DSPROVIDER_ADVANCED, 0, NULL, CreateUserCertPage,
                      0, NULL};
//
// Note that this page uses CreateFPNWPage rather than
// CreateTableDrivenPage.  See fpnw.cxx for more details.
//

DSPAGE FPNWPage = {IDS_FPNWPAGE_TITLE, IDD_FPNW_PROPERTIES,
                  0, 0, NULL, CreateFPNWPage,
                  0, NULL};

//----------------------------------------------
// The list of User pages.
//
PDSPAGE rgUserPages[] = {{&UserGeneral}, {&UserAddress}, {&UserAccount},
                         {&UserProfile}, {&PhoneNotes}, {&UserDelegationPage},
                         {&FPNWPage}, {&UserOrg}, {&PubCertPage}, 
                         {&MemberPage}};

//
// The User class description.
//
DSCLASSPAGES UserCls = {&CLSID_DsUserPropPages, TEXT("User"),
                        sizeof(rgUserPages)/sizeof(PDSPAGE),
                        rgUserPages};

//
// The inetOrgPerson class description.
//

//
// REVIEW_JEFFJON : this is to enable the user property pages to be shown for the inetOrgPerson class
//                  as well.  See JC Cannon for more information
//
#define INETORGPERSON
#ifdef INETORGPERSON
DSCLASSPAGES inetOrgPersonCls = {&CLSID_DsUserPropPages, TEXT("inetOrgPerson"),
                                  sizeof(rgUserPages)/sizeof(PDSPAGE),
                                  rgUserPages};
#endif
//+----------------------------------------------------------------------------
// Contact Object.
//-----------------------------------------------------------------------------

//
// The list of Contact pages. It uses the user general and organization pages.
//
PDSPAGE rgContactPages[] = {{&UserGeneral}, {&UserAddress}, {&PhoneNotes},
                            {&UserOrg}, {&NonSecMemberPage}};

//
// The Contact class description.
//
DSCLASSPAGES ContactCls = {&CLSID_DsContactPropPages, TEXT("Contact"),
                           sizeof(rgContactPages)/sizeof(PDSPAGE),
                           rgContactPages};

//+----------------------------------------------------------------------------
// Group Object.
//-----------------------------------------------------------------------------

//
// Group General page, downlevel name
//
ATTR_MAP GrpGenSAMname = {IDC_SAM_NAME_EDIT, FALSE, FALSE, 256,
                          {L"sAMAccountName", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Group General page.
//
ATTR_MAP GrpGenEmail = {IDC_EMAIL_EDIT, FALSE, FALSE, 1123,
                        {L"mail", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, MailAttr, NULL};
//
// Group General page, Comment
//
ATTR_MAP GrpGenComment = {IDC_EDIT_COMMENT, FALSE, FALSE, 1024,
                          {L"info", ADS_ATTR_UPDATE,
                           ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Group General page.
//
PATTR_MAP rgpGroupGenAttrMap[] = {{&Description}, {&GrpGenSAMname},
                                  {&GrpGenEmail}, {&GrpGenComment}};
//
// The Group General page description.
//
DSPAGE GroupGeneral = {IDS_TITLE_GENERAL, IDD_GROUP_GEN, 0, 0, NULL,
                       CreateGroupGenObjPage,
                       ARRAYLENGTH(rgpGroupGenAttrMap), rgpGroupGenAttrMap};
//
// The Group Members page description.
//
DSPAGE GroupMembers = {IDS_TITLE_GROUP, IDD_GROUP, 0, 0, NULL,
                       CreateGroupMembersPage, 0, NULL};
//
// The list of Group pages.
//
PDSPAGE rgGroupPages[] = {{&GroupGeneral},{&GroupMembers}, {&NonSecMemberPage}};

//
// The Group class description.
//
DSCLASSPAGES GroupCls = {&CLSID_DsGroupPropPages, TEXT("Group"),
                         ARRAYLENGTH(rgGroupPages), rgGroupPages};

//+----------------------------------------------------------------------------
// Organizational-Unit Object.
//-----------------------------------------------------------------------------
//
// OU General page, Address (Street)
//
ATTR_MAP OuGenAddress = {IDC_ADDRESS_EDIT, FALSE, FALSE, 1024,
                         {L"street", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// OU General page, City (Locality-Name)
//
ATTR_MAP OuGenCity = {IDC_CITY_EDIT, FALSE, FALSE, 128,
                      {L"l", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};
//
// OU General page, State (State-Or-Provence-Name)
//
ATTR_MAP OuGenState = {IDC_STATE_EDIT, FALSE, FALSE, 128,
                       {L"st", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// OU General page, ZIP (Postal-Code)
//
ATTR_MAP OuGenZIP = {IDC_ZIP_EDIT, FALSE, FALSE, 40,
                     {L"postalCode", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, CountryName
//
ATTR_MAP OuGenCntryName = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryName, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                         NULL, 0}, CountryName, NULL};
//
// Address page, CountryCode. Thus MUST be after UAddrCntryName.
//
ATTR_MAP OuGenCntryCode = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryCode, ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                         NULL, 0}, CountryCode, NULL};
//
// Address page, Text-Country
//
ATTR_MAP OuGenTextCntry = {IDC_COUNTRY_COMBO, FALSE, FALSE, 128,
                     {g_wzTextCountry, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TextCountry, NULL};

//
// The list of attributes on the OU General page.
//
PATTR_MAP rgpOuGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}, {&OuGenAddress},
                               {&OuGenCity}, {&OuGenState}, {&OuGenZIP}
                              , {&OuGenCntryName},{&OuGenCntryCode},{&OuGenTextCntry}
                               };
//
// The OU General page description.
//
DSPAGE OUGeneral = {IDS_TITLE_GENERAL, IDD_OU_GEN, 0, 0, NULL,
                    CreateTableDrivenPage,
                    sizeof(rgpOuGenAttrMap)/sizeof(PATTR_MAP),
                    rgpOuGenAttrMap};
//
// The list of OU pages.
//
PDSPAGE rgOUPages[] = {{&OUGeneral}};

//
// The OU class description.
//
DSCLASSPAGES OUCls = {&CLSID_DsOuGenPropPage, TEXT("OU"),
                      sizeof(rgOUPages)/sizeof(PDSPAGE),
                      rgOUPages};

//+----------------------------------------------------------------------------
// Domain Object.
//-----------------------------------------------------------------------------

//
// DNS Name
//
ATTR_MAP DomAttrName = {IDC_CN, TRUE, FALSE, 64,
                        {L"dc", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, DomainDNSname, NULL};
//
// Downlevel Name
//
ATTR_MAP DownlevelAttrName = {IDC_DOWNLEVEL_NAME, TRUE, FALSE, 64,
                              {L"dc", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                              NULL, 0}, DownlevelName, NULL};
//
// The list of attributes on the Domain General page.
//
PATTR_MAP rgpDomainGenAttrMap[] = {{&GenIcon}, {&DomAttrName}, {&Description},
                                   {&DownlevelAttrName}};

//
// The Domain General page description.
//
DSPAGE DomainGeneral = {IDS_TITLE_GENERAL, IDD_DOMAIN, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpDomainGenAttrMap)/sizeof(PATTR_MAP),
                        rgpDomainGenAttrMap};
//----------------------------------------------
//
// Trust Page: Flat-Name
//
ATTR_MAP AttrTrustName = {0, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                          {L"flatName", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust-Attributes
//
ATTR_MAP AttrTrustAttr = {0, FALSE, FALSE, 0,
                          {L"trustAttributes", ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust-Direction
//
ATTR_MAP AttrTrustDir = {0, FALSE, FALSE, 0,
                         {L"trustDirection", ADS_ATTR_UPDATE,
                         ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust-Type
//
ATTR_MAP AttrTrustType = {0, FALSE, FALSE, 0,
                          {L"trustType", ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust Partner (the uplevel trusted domain name).
//
ATTR_MAP AttrTrustPartner = {0, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"trustPartner", ADS_ATTR_UPDATE,
                              ADSTYPE_DN_STRING, NULL, 0}, NULL, NULL};
//
// Trust Page: Domain-Cross-Ref
//
//ATTR_MAP AttrCrossRef = {0, FALSE, FALSE, ATTR_LEN_UNLIMITED,
//                         {L"domainCrossRef", ADS_ATTR_UPDATE,
//                         ADSTYPE_DN_STRING, NULL, 0}, NULL};
//
// The list of attributes on the Domain Trust page.
//
PATTR_MAP rgpDomTrustAttrMap[] = {{&AttrTrustName}, {&AttrTrustAttr},
                                  {&AttrTrustDir}, {&AttrTrustType},
                                  {&AttrTrustPartner}};
//                                  {&AttrCrossRef}};
//
// The Domain Trust page description.
//
DSPAGE DomainTrust = {IDS_TITLE_TRUST, IDD_DOMAIN_TRUST, 0, 1,
                      &CLSID_DomainAdmin, CreateDomTrustPage,
                      sizeof(rgpDomTrustAttrMap)/sizeof(PATTR_MAP),
                      rgpDomTrustAttrMap};
//
// The list of Domain pages.
//
PDSPAGE rgDomainPages[] = {{&DomainGeneral}, {&DomainTrust}};

//
// The Domain class description.
//
DSCLASSPAGES DomainCls = {&CLSID_DsDomainPropPages, TEXT("Domain"),
                          sizeof(rgDomainPages)/sizeof(PDSPAGE),
                          rgDomainPages};

//+----------------------------------------------------------------------------
// Trusted-Domain Object.
//-----------------------------------------------------------------------------
//
// Trusted Domain General page: current domain name
// Warning:    This must be the first attr function called as it allocates
//             the class object.
//
ATTR_MAP TDomGenCurDomAttr = {IDC_DOMAIN_NAME_EDIT, TRUE, FALSE, 0,
                              {L"flatName", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, CurDomainText, NULL};
//
// Trusted Domain General page: Peer Domain name.
//
ATTR_MAP TDomGenPeerAttr = {IDC_PEER_NAME_EDIT, TRUE, FALSE, 0,
                            {L"trustPartner", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, PeerDomain, NULL};
//
// Trusted Domain General page: TrustType
// Note, this attr function fetches the trust-type value which is used
// by the trust-attributes attr function. Thus, this function must be called
// before the TransitiveTextOrButton function.
//
ATTR_MAP TDomTrustTypeAttr = {IDC_TRUST_TYPE_EDIT, TRUE, FALSE, 0,
                              {L"trustType", ADS_ATTR_UPDATE,
                              ADSTYPE_INTEGER, NULL, 0}, TrustType, NULL};
//
// Trusted Domain General page: Trust Direction
//
ATTR_MAP TDomTrustDirAttr = {IDC_TRUST_DIR_EDIT, TRUE, FALSE, 0,
                             {L"trustDirection", ADS_ATTR_UPDATE,
                             ADSTYPE_INTEGER, NULL, 0}, TrustDirection, NULL};
//
// Trusted Domain General page: Transitive Textbox or Yes button.
//
ATTR_MAP TDomTransAttrYes = {IDC_TRANS_YES_RADIO, FALSE, FALSE, 0,
                             {L"trustAttributes", ADS_ATTR_UPDATE,
                             ADSTYPE_INTEGER, NULL, 0}, TransitiveTextOrButton, NULL};
//
// Trusted Domain General page: Trust Transistivity No Radio Button.
//
ATTR_MAP TDomTransAttrNo = {IDC_TRANS_NO_RADIO, FALSE, FALSE, 0,
                            {NULL, ADS_ATTR_UPDATE,
                            ADSTYPE_INTEGER, NULL, 0}, TrustTransNo, NULL};
//
// Trusted Domain General page: Verify/Reset trust button
//
ATTR_MAP TDomResetBtn = {IDC_TRUST_RESET_BTN, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, TrustVerifyBtn, NULL};
//
// Trusted Domain General page: Save FTInfo button
//
ATTR_MAP TDomFTSaveBtn = {IDC_SAVE_FOREST_NAMES_BTN, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, SaveFTInfoBtn, NULL};
#if DBG == 1 // TRUSTBREAK
ATTR_MAP TDomBreakBtn = {IDC_BUTTON1, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, TrustBreakBtn, NULL};
#endif
//
// The list of attributes on the Trusted Domain General page.
//
PATTR_MAP rgpTrustDomGenAttrMap[] = {{&TDomGenCurDomAttr}, {&TDomGenPeerAttr},
                                     {&TDomTrustTypeAttr}, {&TDomTrustDirAttr},
                                     {&TDomTransAttrYes}, {&TDomTransAttrNo},
                                     {&TDomResetBtn}, {&TDomFTSaveBtn}
#if DBG == 1 // TRUSTBREAK
,{&TDomBreakBtn}
#endif
};
//
// The Trusted Domain General page description.
//
DSPAGE TrustDomGen = {IDS_TITLE_GENERAL, IDD_TRUSTED_DOM_GEN, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpTrustDomGenAttrMap)/sizeof(PATTR_MAP),
                      rgpTrustDomGenAttrMap};
#ifdef REMOVE_SPN_SUFFIX_CODE
//----------------------------------------------
//
// Trust Domain SPN Suffix Page: Edit control
//
ATTR_MAP TrustSPNAttrEdit = {IDC_EDIT, FALSE, TRUE, ATTR_LEN_UNLIMITED,
                             {L"additionalTrustedServiceNames", ADS_ATTR_UPDATE,
                             ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNEdit, NULL};
//
// Trust Domain SPN Suffix Page: List control
//
ATTR_MAP TrustSPNAttrList = {IDC_LIST, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                             {NULL, ADS_ATTR_UPDATE,
                             ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNList, NULL};
//
// Trust Domain SPN Suffix Page: Add button
//
ATTR_MAP TrustSPNAttrAdd = {IDC_ADD_BTN, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                            {NULL, ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNAdd, NULL};
//
// Trust Domain SPN Suffix Page: Remove button
//
ATTR_MAP TrustSPNAttrRemove = {IDC_DELETE_BTN, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                               {NULL, ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNRemove, NULL};
//
// Trust Domain SPN Suffix Page: Edit button
//
ATTR_MAP TrustSPNAttrChange = {IDC_EDIT_BTN, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                               {NULL, ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNChange, NULL};
//
// The list of attributes on the Trusted Domain SPN Suffix page.
//
PATTR_MAP rgpTrustDomSPNAttrMap[] = {{&TrustSPNAttrEdit}, {&TrustSPNAttrList},
                                     {&TrustSPNAttrAdd}, {&TrustSPNAttrRemove},
                                     {&TrustSPNAttrChange}};
//
// The Trusted Domain Suffix Page description.
//
DSPAGE TrustDomSPNpage = {IDS_ADVANCED, IDD_SPN_SUFFIX, 0, 0, NULL,
                          CreateTableDrivenPage,
                          sizeof(rgpTrustDomSPNAttrMap)/sizeof(PATTR_MAP),
                          rgpTrustDomSPNAttrMap};

PDSPAGE rgTrustedDomainPages[] = {{&TrustDomGen}, {&TrustDomSPNpage}};
#endif //REMOVE_SPN_SUFFIX_CODE
//
// The list of Trusted Domain pages.
//
PDSPAGE rgTrustedDomainPages[] = {{&TrustDomGen}};
//
// The Trusted Domain class description.
//
DSCLASSPAGES TrustedDomainCls = {&CLSID_DsTrustedDomainPropPages,
                                 TEXT("TrustedDomain"),
                                 sizeof(rgTrustedDomainPages)/sizeof(PDSPAGE),
                                 rgTrustedDomainPages};

//+----------------------------------------------------------------------------
// Domain Policy Object.
//-----------------------------------------------------------------------------

//
// The list of attributes on the Domain Policy General page.
//
PATTR_MAP rgpDomPolGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Domain Policy General page description.
//
DSPAGE DomainPolicyGeneral = {IDS_TITLE_GENERAL, IDD_DOMAINPOLICY, 0, 0, NULL,
                              CreateTableDrivenPage,
                              sizeof(rgpDomPolGenAttrMap)/sizeof(PATTR_MAP),
                              rgpDomPolGenAttrMap};
//
// The list of Domain Policy pages.
//
PDSPAGE rgDomainPolicyPages[] = {{&DomainPolicyGeneral}};

//
// The Domain Policy class description.
//
DSCLASSPAGES DomainPolicyCls = {&CLSID_DsDomainPolicyPropPages,
                                TEXT("DomainPolicy"),
                                sizeof(rgDomainPolicyPages)/sizeof(PDSPAGE),
                                rgDomainPolicyPages};

//+----------------------------------------------------------------------------
// Local Policy Object.
//-----------------------------------------------------------------------------

//
// The list of attributes on the Local Policy General page.
//
PATTR_MAP rgpLocPolGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Local Policy General page description.
//
DSPAGE LocalPolicyGeneral = {IDS_TITLE_GENERAL, IDD_LOCALPOLICY_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpLocPolGenAttrMap)/sizeof(PATTR_MAP),
                             rgpLocPolGenAttrMap};
//
// The list of Local Policy pages.
//
PDSPAGE rgLocalPolicyPages[] = {{&LocalPolicyGeneral}};
//
// The Local Policy class description.
//
DSCLASSPAGES LocalPolicyCls = {&CLSID_DsLocalPolicyPropPages,
                               TEXT("LocalPolicy"),
                               sizeof(rgLocalPolicyPages)/sizeof(PDSPAGE),
                               rgLocalPolicyPages};

//+----------------------------------------------------------------------------
// Managed-By Page.
//-----------------------------------------------------------------------------

//
// Managed-by page, Managed-By DN. THIS MUST BE THE FIRST Managed-By ATTR_MAP!
//
ATTR_MAP MgdByDN = {IDC_MANAGEDBY_EDIT, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                    {L"managedBy", ADS_ATTR_UPDATE,
                     ADSTYPE_DN_STRING, NULL, 0}, ManagedByEdit, NULL};
//
// Managed-by page, Change button.
//
ATTR_MAP MgdByChange = {IDC_CHANGE_BTN, TRUE, FALSE, 0,
                        {NULL, ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ChangeButton, NULL};
//
// Managed-by page, View button.
//
ATTR_MAP MgdByView = {IDC_VIEW_BTN, TRUE, FALSE, 0,
                      {NULL, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ViewButton, NULL};
//
// Managed-by page, Clear button.
//
ATTR_MAP MgdByClear = {IDC_CLEAR_BTN, TRUE, FALSE, 0,
                       {NULL, ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ClearButton, NULL};

//
// Managed-by page, Can update list check box
//
ATTR_MAP MgdByUpdateCheck = {IDC_UPDATE_LIST_CHECK, FALSE, FALSE, 0,
                              {NULL, ADS_ATTR_UPDATE,
                              ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, UpdateListCheck, NULL};

//
// Managed-by page, Office.
//
ATTR_MAP MgdByOffice = {IDC_OFFICE_EDIT, TRUE, FALSE, 128,
                        {L"physicalDeliveryOfficeName", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OfficeEdit, NULL};
//
// Managed-by page, Street.
//
ATTR_MAP MgdByStreet = {IDC_STREET_EDIT, TRUE, FALSE, 128,
                        {L"streetAddress", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, StreetEdit, NULL};
//
// Managed-by page, City (locality).
//
ATTR_MAP MgdByCity = {IDC_CITY_EDIT, TRUE, FALSE, 128,
                      {L"l", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, CityEdit, NULL};
//
// Managed-by page, State.
//
ATTR_MAP MgdByState = {IDC_STATE_EDIT, TRUE, FALSE, 128,
                       {L"st", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, StateEdit, NULL};
//
// Managed-by page, Country.
//
ATTR_MAP MgdByCountry = {IDC_COUNTRY_EDIT, TRUE, FALSE, 3,
                         {L"c", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, CountryEdit, NULL};
//
// Managed-by page, Phone.
//
ATTR_MAP MgdByPhone = {IDC_PHONE_EDIT, TRUE, FALSE, 32,
                       {L"telephoneNumber", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, PhoneEdit, NULL};
//
// Managed-by page, Fax.
//
ATTR_MAP MgdByFax = {IDC_FAX_EDIT, TRUE, FALSE, 64,
                     {L"facsimileTelephoneNumber", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, FaxEdit, NULL};
//
// The list of attributes on the Managed-by page.
//
PATTR_MAP rgpManagedByAttrMap[] = {{&MgdByDN}, {&MgdByChange}, {&MgdByView},
                                   {&MgdByClear}, {&MgdByUpdateCheck}, {&MgdByOffice},
                                   {&MgdByStreet}, {&MgdByCity}, {&MgdByState},
                                   {&MgdByCountry}, {&MgdByPhone}, {&MgdByFax}};
//
// The Managed-by page description.
//
DSPAGE ManagedByPage = {IDS_MANAGED_BY_TITLE, IDD_MANAGEDBY, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpManagedByAttrMap)/sizeof(PATTR_MAP),
                        rgpManagedByAttrMap};
//
// The list of Managed-by pages.
//
PDSPAGE rgManagedByPages[] = {{&ManagedByPage}};

//
// The Managed-by class description.
//
DSCLASSPAGES ManagedByCls = {&CLSID_DsManageableObjPropPages,
                             TEXT("Managed-By"),
                             sizeof(rgManagedByPages)/sizeof(PDSPAGE),
                             rgManagedByPages};

//+----------------------------------------------------------------------------
// Computer Object.
//-----------------------------------------------------------------------------

//
// Computer General page, DNS Name.
//
ATTR_MAP ComputerDnsName = {IDC_NET_ADDR_EDIT, TRUE, FALSE, 2048,
                            {L"dNSHostName", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Computer General page, Downlevel Name. The length includes the $ at the end.
// The attr function will limit the edit control to one less than this.
//
ATTR_MAP ComputerDwnlvlName = {IDC_DOWNLEVEL_EDIT, TRUE, FALSE, 16,
                               {L"sAMAccountName", ADS_ATTR_UPDATE,
                                ADSTYPE_CASE_IGNORE_STRING, NULL, 0},
                                ComputerDnlvlName, NULL};
//
// Computer General page, Delegation checkbox. This attr function must be
// called before ComputerRoleAttr because it uses a values fetched by this
// function and stored in the page's m_pData element.
//
ATTR_MAP ComputerDelegateChk = {IDC_DELEGATION_CHK, FALSE, FALSE, 0,
                               {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                ADSTYPE_INTEGER, NULL, 0},
                                PuterCanDelegateChk, NULL};
//
// Computer General page, Role, from User-Account-Control.
// Note that there is a machineRole attribute, but it is not used.
// Note also that this attribute is used by two different controls (this and
// the delegation checkbox). However, a last-writer-wins situation is avoided
// because the Role edit control is read-only.
//
ATTR_MAP ComputerRoleAttr = {IDC_ROLE_EDIT, TRUE, FALSE, 0,
                             {NULL /* L"userAccountControl" */, ADS_ATTR_UPDATE,
                             ADSTYPE_INTEGER, NULL, 0}, ComputerRole, NULL};
//
// The list of attributes on the Computer General page.
//
PATTR_MAP rgpComputerGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
                                     {&ComputerDnsName}, {&ComputerDwnlvlName},
                                     {&ComputerDelegateChk}, {&ComputerRoleAttr}};
//
// The Computer General page description.
//
DSPAGE ComputerGeneral = {IDS_TITLE_GENERAL, IDD_COMPUTER, 0, 0, NULL,
                          CreateTableDrivenPage,
                          sizeof(rgpComputerGenAttrMap)/sizeof(PATTR_MAP),
                          rgpComputerGenAttrMap};
//
// Computer OS page, OS Name.
//
ATTR_MAP ComputerOsName = {IDC_OS_EDIT, TRUE, FALSE, 2048,
                           {L"operatingSystem", ADS_ATTR_UPDATE,
                           ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Computer OS page, OS Version.
//
ATTR_MAP ComputerOsVer = {IDC_OS_VER_EDIT, TRUE, FALSE, 2048,
                          {L"operatingSystemVersion", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Computer OS page, OS Service Pack Level.
//
ATTR_MAP ComputerSvcPack = {IDC_SVC_PACK_EDIT, TRUE, FALSE, 2048,
                            {L"operatingSystemServicePack", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Computer OS page.
//
PATTR_MAP rgpComputerOSAttrMap[] = {{&ComputerOsName}, {&ComputerOsVer},
                                     {&ComputerSvcPack}};
//
// The Computer OS page description.
//
DSPAGE ComputerOSPage = {IDS_TITLE_OS, IDD_COMPUTER_OS, 0, 0, NULL,
                         CreateTableDrivenPage,
                         sizeof(rgpComputerOSAttrMap)/sizeof(PATTR_MAP),
                         rgpComputerOSAttrMap};

//
// The Computer Delegation page
//
DSPAGE ComputerDelegationPage = { IDS_TITLE_DELEGATION, IDD_COMPUTER_DELEGATION, 0, 0, NULL,
                                  CreateComputerDelegationPage,
                                  0, NULL };
//
// The list of Computer pages.
//
PDSPAGE rgComputerPages[] = {{&ComputerGeneral}, {&ComputerOSPage}, {&MemberPage},
                             {&ComputerDelegationPage}};

//
// The Computer class description.
//
DSCLASSPAGES ComputerCls = {&CLSID_DsComputerPropPages, TEXT("Computer"),
                            sizeof(rgComputerPages)/sizeof(PDSPAGE),
                            rgComputerPages};

//+----------------------------------------------------------------------------
// Volume Object.
//-----------------------------------------------------------------------------

//
// Volume General page, UNC path.
//
ATTR_MAP VolumeUNC = {IDC_UNC_NAME_EDIT, FALSE, FALSE, 260,
                      {L"uNCName", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, VolumeUNCpath, NULL};
//
// Volume General page, Browse for UNC path button.
//
ATTR_MAP VolKeywords = {IDC_KEYWORDS_BTN, FALSE, TRUE, 256,
                        {L"keywords", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// The list of attributes on the Volume General page.
//
PATTR_MAP rgpVolumeGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
                                   {&VolumeUNC}, {&VolKeywords}
                                  };
//
// The Volume General page description.
//
DSPAGE VolumeGeneral = {IDS_TITLE_GENERAL, IDD_VOLUME, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpVolumeGenAttrMap)/sizeof(PATTR_MAP),
                        rgpVolumeGenAttrMap};
//
// The list of Volume pages.
//
PDSPAGE rgVolumePages[] = {{&VolumeGeneral}};

//
// The Volume class description.
//
DSCLASSPAGES VolumeCls = {&CLSID_DsVolumePropPages, TEXT("Volume"),
                          sizeof(rgVolumePages)/sizeof(PDSPAGE),
                          rgVolumePages};

//+----------------------------------------------------------------------------
// Subnet Object.
//-----------------------------------------------------------------------------

//
// Subnet General page, siteObject attribute
//
ATTR_MAP USiteTarget = {IDC_DS_SITE_IN_SUBNET, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                          {L"siteObject", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, DsQuerySite, NULL};
ATTR_MAP USubnetAddress = {IDC_SUBNET_ADDRESS, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                          {g_wzName, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, SubnetExtractAddress, NULL};
ATTR_MAP USubnetMask = {IDC_SUBNET_MASK, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                          {g_wzName, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, SubnetExtractMask, NULL};

//
// The list of attributes on the Subnet General page.
//
PATTR_MAP rgpSubnetGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                          ,{&USiteTarget}
                          ,{&USubnetAddress}
                          ,{&USubnetMask}
                          };

//
// The Subnet General page description.
//
DSPAGE SubnetGeneral = {IDS_TITLE_SUBNET, IDD_SUBNET_GENERAL, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpSubnetGenAttrMap)/sizeof(PATTR_MAP),
                        rgpSubnetGenAttrMap};
//
// The list of Subnet pages.
//
PDSPAGE rgSubnetPages[] = {{&SubnetGeneral}};

//
// The Subnet class description.
//
DSCLASSPAGES SubnetCls = {&CLSID_DsReplSubnetPropPages, TEXT("Subnet"),
                          sizeof(rgSubnetPages)/sizeof(PDSPAGE),
                          rgSubnetPages};

//+----------------------------------------------------------------------------
// Site Object.
//-----------------------------------------------------------------------------

ATTR_MAP USubnetList = {IDC_SUBNET_LIST, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                          {NULL, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, SiteExtractSubnetList, NULL};

//
// Schedule button (shared between several SITEREPL pages).
//
ATTR_MAP UScheduleBtn_11_Default = {IDC_SCHEDULE_BTN, FALSE, FALSE, SchedDlg_Connection,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeBtn_11_Default, NULL};
ATTR_MAP UScheduleBtn_FF_Default = {IDC_SCHEDULE_BTN, FALSE, FALSE, SchedDlg_Connection,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeBtn_FF_Default, NULL};
ATTR_MAP UReplicationScheduleBtn = {IDC_SCHEDULE_BTN, FALSE, FALSE, SchedDlg_Replication,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeBtn_FF_Default, NULL};
#ifdef CUSTOM_SCHEDULE
ATTR_MAP UScheduleCheckbox = {IDC_SCHEDULE_CHECKBOX, TRUE /* read-only */, FALSE, NULL,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeCheckbox, NULL};
#endif
//
// The list of attributes on the Site General page.
//
PATTR_MAP rgpSiteGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
    ,{&USubnetList}
    // ,{&UScheduleBtn}
};

//
// The Site General page description.
//
DSPAGE SiteGeneral = {IDS_TITLE_SITE, IDD_SITE_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpSiteGenAttrMap)/sizeof(PATTR_MAP),
                      rgpSiteGenAttrMap};

//
// The list of Site pages.
//
PDSPAGE rgSitePages[] = {{&SiteGeneral}};

//
// The Site class description.
//
DSCLASSPAGES SiteCls = {&CLSID_DsReplSitePropPages, TEXT("Site"),
                        sizeof(rgSitePages)/sizeof(PDSPAGE),
                        rgSitePages};

//+----------------------------------------------------------------------------
// DS Site Settings Object.
//-----------------------------------------------------------------------------

//
// Topology buttons (shares the "options" attribute).
//
ATTR_MAP USiteSettingsTopologyIcon = {IDC_EDIT1, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsTopologyText = {IDC_EDIT2, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsTopologyHelpId = {IDC_EDIT2, TRUE /* read-only */, FALSE,
                            HIDC_SITESETTINGS_INTRA_NO_AUTOGEN,
                            {NULL, ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            SetContextHelpIdAttrFn, NULL};
ATTR_MAP USiteSettingsSiteTopologyIcon = {IDC_EDIT3, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsSiteTopologyText = {IDC_EDIT4, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsSiteTopologyHelpId = {IDC_EDIT4, TRUE /* read-only */, FALSE,
                            HIDC_SITESETTINGS_INTER_NO_AUTOGEN,
                            {NULL, ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            SetContextHelpIdAttrFn, NULL};
//
// Change Server button
// note that IDC_SERVER_BTN does not actually exist in the dialog
//
ATTR_MAP UTopoGenerator = {IDC_SERVER_BTN, FALSE, FALSE, 0,
                          {L"intersiteTopologyGenerator", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          nTDSDSAChangeBtn, NULL};

//
// JonN 7/21/00 New Site Settings fields for GC-less logon
//
// Global Catalog bit in [options] attribute
ATTR_MAP UCacheMemb = {IDC_SITESETTINGS_CACHE_MEMB, FALSE, FALSE,
                          NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED,
                          {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                          NULL, 0}, FirstSharedBitField, NULL};
// Preferred site for GC-less logon
ATTR_MAP UGCSite = {IDC_SITESETTINGS_PREFERRED_SITE, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"msDS-Preferred-GC-Site", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                             NULL, 0}, DsQuerySite, NULL};

//
// The list of attributes on the DS Site Settings General page.
//
PATTR_MAP rgpDsSiteSettingsGenAttrMap[] = {{&GenIcon}, {&AttrName}
            ,{&Description}
            ,{&USiteSettingsTopologyIcon}
            ,{&USiteSettingsTopologyText}
            ,{&USiteSettingsTopologyHelpId}
            ,{&USiteSettingsSiteTopologyIcon}
            ,{&USiteSettingsSiteTopologyText}
            ,{&USiteSettingsSiteTopologyHelpId}
#ifdef CUSTOM_SCHEDULE
            ,{&UScheduleCheckbox}
#endif
            ,{&UScheduleBtn_11_Default}
            ,{&UTopoGenerator}
            ,{&UCacheMemb}
            ,{&UGCSite}
            };

//
// The DS Site Settings General page description.
//
DSPAGE DsSiteSettingsGeneral = {IDS_TITLE_DS_SITE_SETTINGS, IDD_DS_SITE_SETTINGS_GENERAL,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpDsSiteSettingsGenAttrMap)/sizeof(PATTR_MAP),
                            rgpDsSiteSettingsGenAttrMap};
//
// The list of DS Site Settings pages.
//
PDSPAGE rgDsSiteSettingsPages[] = {{&DsSiteSettingsGeneral}};

//
// The DS Site Settings class description.
//
DSCLASSPAGES DsSiteSettingsCls = {&CLSID_DsReplSiteSettingsPropPages, TEXT("NTDS-Site-Settings"),
                              sizeof(rgDsSiteSettingsPages)/sizeof(PDSPAGE),
                              rgDsSiteSettingsPages};

//+----------------------------------------------------------------------------
// Site License Settings Object.
//-----------------------------------------------------------------------------

//
// Change Server button
//
ATTR_MAP USiteServerBtn = {IDC_COMPUTER_BTN, FALSE, FALSE, 0,
                          {L"siteServer", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          ComputerChangeBtn, NULL};
//
// The list of attributes on the Site License Settings General page.
//
PATTR_MAP rgpDsSiteLicenseSettingsGenAttrMap[] = {{&GenIcon}, {&AttrName},
            {&USiteServerBtn},
            {&Description}};

//
// The Site License Settings General page description.
//
DSPAGE DsSiteLicenseSettingsGeneral = {IDS_TITLE_DS_SITE_LICENSE_SETTINGS,
                            IDD_DS_SITE_LICENSE_SETTINGS_GENERAL,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpDsSiteLicenseSettingsGenAttrMap)/sizeof(PATTR_MAP),
                            rgpDsSiteLicenseSettingsGenAttrMap};
//
// The list of DS Site Settings pages.
//
PDSPAGE rgDsSiteLicenseSettingsPages[] = {{&DsSiteLicenseSettingsGeneral}};

//
// The DS Site Settings class description.
//
DSCLASSPAGES DsSiteLicenseSettingsCls = {&CLSID_DsReplSiteLicenseSettingsPropPages, TEXT("Licensing-Site-Settings"),
                              sizeof(rgDsSiteLicenseSettingsPages)/sizeof(PDSPAGE),
                              rgDsSiteLicenseSettingsPages};

//+----------------------------------------------------------------------------
// NTDS-DSA Object.
//-----------------------------------------------------------------------------

//
// NTDS-DSA General page, Global Catalog bit in [options] attribute
//
ATTR_MAP UGlobalCatalog = {IDC_NTDSDSA_GLOBAL_CATALOG, FALSE, FALSE, 0x1,
                          {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                          NULL, 0}, FirstSharedBitField, NULL};
//
// NTDS-DSA General page, Query policy edit field
//
ATTR_MAP UQueryPolicy = {IDC_NTDSDSA_QUERY_POLICY, FALSE, FALSE, 3,
                          {L"queryPolicyObject", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, DsQueryPolicy, NULL};
//
// NTDS-DSA General page, Query policy edit field
//
ATTR_MAP UNTDSDSA_DNSAlias = {IDC_EDIT1, TRUE /* read-only */, FALSE, 0,
                          {L"objectGUID", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING,
                          NULL, 0}, NTDSDSA_DNSAlias, NULL};
//
// The list of attributes on the NTDS-DSA General page.
//
PATTR_MAP rgpNTDS_DSAGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
            ,{&UQueryPolicy}
            ,{&UGlobalCatalog}
            ,{&UNTDSDSA_DNSAlias}
            // ,{&UScheduleBtn_FF_Default}
            };

//
// The NTDS-DSA General page description.
//
DSPAGE NTDS_DSAGeneral = {IDS_TITLE_GENERAL, IDD_NTDSDSA_GENERAL,
                      0, 0, NULL, CreateTableDrivenPage,
                      sizeof(rgpNTDS_DSAGenAttrMap)/sizeof(PATTR_MAP),
                      rgpNTDS_DSAGenAttrMap};

//
// NTDS-DSA General page, Replicate From/To listviews
//
ATTR_MAP UReplicateFrom = {IDC_NTDSDSA_REPLICATE_FROM, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                           {NULL, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                           NULL, 0}, DsReplicateListbox, NULL};
ATTR_MAP UReplicateTo = {IDC_NTDSDSA_REPLICATE_TO, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                           {NULL, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                           NULL, 0}, DsReplicateListbox, (PVOID)1};

//
// The list of attributes on the NTDS-DSA Connections page.
//
PATTR_MAP rgpNTDS_DSAConnAttrMap[] = {{&UReplicateFrom},{&UReplicateTo}};

//
// The NTDS-DSA Connections page description.
//
DSPAGE NTDS_DSAConn = {IDS_TITLE_NTDSDSA_CONN, IDD_NTDSDSA_CONN,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpNTDS_DSAConnAttrMap)/sizeof(PATTR_MAP),
                            rgpNTDS_DSAConnAttrMap};
//
// The list of NTDS-DSA pages.
//
PDSPAGE rgNTDS_DSAPages[] = {{&NTDS_DSAGeneral},{&NTDS_DSAConn}};

//
// The NTDS-DSA class description.
//
DSCLASSPAGES NTDS_DSACls = {&CLSID_DsReplDSAPropPages, TEXT("NTDS-DSA"),
                        sizeof(rgNTDS_DSAPages)/sizeof(PDSPAGE),
                        rgNTDS_DSAPages};

//+----------------------------------------------------------------------------
// DS Server Object.
//-----------------------------------------------------------------------------

//
// Used by various pages which use duelling listboxes
//
ATTR_MAP DuellingAttr_Add = {IDC_DUELLING_RB_ADD, TRUE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_DN_STRING,
                          NULL, 0}, DuellingListboxButton, NULL};
ATTR_MAP DuellingAttr_Remove = {IDC_DUELLING_RB_REMOVE, TRUE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_DN_STRING,
                          NULL, 0}, DuellingListboxButton, NULL};

//
// DS Server General page, Bridgehead For listbox
//
ATTR_MAP UBridgeheadList_In = {IDC_DUELLING_LB_IN, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                               {L"bridgeheadTransportList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                                NULL, 0},
                               DsQueryBridgeheadList, NULL};
ATTR_MAP UBridgeheadList_Out = {IDC_DUELLING_LB_OUT, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                                {L"bridgeheadTransportList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                                 NULL, 0},
                                DuellingListbox, NULL};
//
// Server General page, Change Computer button
//
// JonN 4/17/01 275336
// DS Sites Snapin - dssite.msc - NTDS Settings object will never need to switch servers
// We leave this in place to populate the text fields, and disable the button itself.
ATTR_MAP UChangeComputer = {IDC_COMPUTER_BTN, FALSE, FALSE, 0,
                          {L"serverReference", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          ComputerChangeBtn, NULL};

//
// The list of attributes on the DS Server General page.
//
PATTR_MAP rgpDsServerGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
       ,{&UBridgeheadList_In}
       ,{&DuellingAttr_Add}
       ,{&DuellingAttr_Remove}
       ,{&UBridgeheadList_Out}
       ,{&UChangeComputer}
    // ,{&UScheduleBtn}
    };

//
// The DS Server General page description.
//
DSPAGE DsServerGeneral = {IDS_TITLE_DS_SERVER, IDD_DS_SERVER_GENERAL,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpDsServerGenAttrMap)/sizeof(PATTR_MAP),
                            rgpDsServerGenAttrMap};
//
// The list of DS Server pages.
//
PDSPAGE rgDsServerPages[] = {{&DsServerGeneral}};

//
// The DS Server class description.
//
DSCLASSPAGES DsServerCls = {&CLSID_DsReplServerPropPages, TEXT("Server"),
                              sizeof(rgDsServerPages)/sizeof(PDSPAGE),
                              rgDsServerPages};

//+----------------------------------------------------------------------------
// DS Connection Object.
//-----------------------------------------------------------------------------

//
// DS Connection General page, From Server edit field
//

//
// Change Server button
//
ATTR_MAP UFromServerBtn = {IDC_SERVER_BTN, FALSE, FALSE, 0,
                          {L"fromServer", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          nTDSDSAAndDomainChangeBtn, NULL};

ATTR_MAP UConnectionOptions = {0, FALSE, FALSE, 0,
                     {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                      NULL, 0}, nTDSConnectionOptions, NULL};

//
// DS Connection General page, siteObject attribute
//
// 01/28/98 JonN: Note that this is transportType rather than
//   overSiteConnector (as of the upcoming IDS)
//
ATTR_MAP UInterSiteTarget = {IDC_DS_INTERSITE_IN_CONNECTION, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"transportType", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                             NULL, 0}, DsQueryInterSiteTransport, NULL};

//
// The list of attributes on the DS Connection General page.
//
PATTR_MAP rgpDsConnectionGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
            ,{&UConnectionOptions}
            ,{&UInterSiteTarget}
#ifdef CUSTOM_SCHEDULE
            ,{&UScheduleCheckbox}
#endif
            ,{&UScheduleBtn_FF_Default}
            ,{&UFromServerBtn}
			};

//
// Note that this page is not in the main table-driven array; rather, it is substituted
// for DsConnectionGeneral when the parent is an NTFRS object.
// See siterepl.cxx for more details.
//
DSPAGE DsConnectionGeneral = {IDS_TITLE_DS_CONNECTION, IDD_DS_CONNECTION_GENERAL,
                      0, 0, NULL, NULL,
                      sizeof(rgpDsConnectionGenAttrMap)/sizeof(PATTR_MAP),
                      rgpDsConnectionGenAttrMap};

//
// Note that this page uses CreateDsOrFrsConnectionPage rather than
// CreateTableDrivenPage.  See siterepl.cxx for more details.
//

DSPAGE DsOrFrsConnectionGeneral = {0, 0,
                      0, 0, NULL, CreateDsOrFrsConnectionPage,
                      0,
                      NULL};

//
// The list of DS Connection pages.
//
PDSPAGE rgDsConnectionPages[] = {{&DsOrFrsConnectionGeneral}};

//
// The DS Connection class description.
//
DSCLASSPAGES DsConnectionCls = {&CLSID_DsReplConnectionPropPages, TEXT("NTDS-Connection"),
                        sizeof(rgDsConnectionPages)/sizeof(PDSPAGE),
                        rgDsConnectionPages};

//+----------------------------------------------------------------------------
// FRS Objects.
//-----------------------------------------------------------------------------

//
// FRS Root Path edit field
//
ATTR_MAP UFrsRootPath = {IDC_FRS_ROOT_PATH, TRUE /* read-only */,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSRootPath", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
ATTR_MAP UFrsStagingPath = {IDC_FRS_STAGING_PATH, TRUE /* read-only */,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSStagingPath", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
ATTR_MAP UFrsDirectoryFilter = {IDC_EDIT1, FALSE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSDirectoryFilter", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
ATTR_MAP UFrsFileFilter = {IDC_EDIT2, FALSE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSFileFilter", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
/*
ATTR_MAP UFrsPrimaryMember = {IDC_EDIT3, FALSE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSPrimaryMember", ADS_ATTR_UPDATE,
                          ADSTYPE_DN_STRING,
                          NULL, 0}, DsQueryFrsPrimaryMember};
*/
ATTR_MAP UFrsComputerBtn = {IDC_COMPUTER_BTN, TRUE /* read-only */, FALSE, 0,
                          {L"frsComputerReference", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          ComputerChangeBtn, NULL};
//
// Change Member button, any FRS-Member
//
ATTR_MAP UFromAnyMemberBtn = {IDC_SERVER_BTN, TRUE /* read-only */, FALSE, 0,
                          {L"fRSMemberReference", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          FRSAnyMemberChangeBtn, NULL};

PATTR_MAP rgpFrsReplicaSetAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
            {&UFrsDirectoryFilter},
            {&UFrsFileFilter},
//            {&UFrsPrimaryMember},
#ifdef CUSTOM_SCHEDULE
            {&UScheduleCheckbox},
#endif
            {&UReplicationScheduleBtn}};
PATTR_MAP rgpFrsMemberAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
            {&UFrsComputerBtn} };
PATTR_MAP rgpFrsSubscriberAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
			{&UFrsRootPath},
			{&UFrsStagingPath},
			{&UFromAnyMemberBtn}};
DSPAGE FrsReplicaSetPage = {IDS_TITLE_NTFRS_REPLICA_SET, IDD_NTFRS_REPLICA_SET_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpFrsReplicaSetAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsReplicaSetAttrMap};
DSPAGE FrsMemberPage = {IDS_TITLE_NTFRS_MEMBER, IDD_NTFRS_MEMBER_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpFrsMemberAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsMemberAttrMap};
DSPAGE FrsSubscriberPage = {IDS_TITLE_NTFRS_SUBSCRIBER, IDD_NTFRS_SUBSCRIBER_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpFrsSubscriberAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsSubscriberAttrMap};
PDSPAGE rgFrsReplicaSetPages[] = {{&FrsReplicaSetPage}};
PDSPAGE rgFrsMemberPages[] = {{&FrsMemberPage}};
PDSPAGE rgFrsSubscriberPages[] = {{&FrsSubscriberPage}};
DSCLASSPAGES FrsReplicaSetCls = {&CLSID_DsFrsReplicaSet, TEXT("NTFRS-Replica-Set"),
                        sizeof(rgFrsReplicaSetPages)/sizeof(PDSPAGE),
                        rgFrsReplicaSetPages};
DSCLASSPAGES FrsMemberCls = {&CLSID_DsFrsMember, TEXT("NTFRS-Member"),
                        sizeof(rgFrsMemberPages)/sizeof(PDSPAGE),
                        rgFrsMemberPages};
DSCLASSPAGES FrsSubscriberCls = {&CLSID_DsFrsSubscriber, TEXT("NTFRS-Subscriber"),
                        sizeof(rgFrsSubscriberPages)/sizeof(PDSPAGE),
                        rgFrsSubscriberPages};

//
// The FRS Connection General page description.
//
// Note that this page is not in the main table-driven array; rather, it is substituted
// for DsConnectionGeneral when the parent is an NTFRS object.
// See siterepl.cxx for more details.

//
// Change Member button, limited to members in this same replica
//
ATTR_MAP UFromMemberInReplicaBtn = {IDC_SERVER_BTN, FALSE, FALSE, 0,
                          {L"fromServer", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          FRSMemberInReplicaChangeBtn, NULL};
PATTR_MAP rgpFrsConnectionGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
        {&UFromMemberInReplicaBtn },
#ifdef CUSTOM_SCHEDULE
        {&UScheduleCheckbox},
#endif
        {&UReplicationScheduleBtn}};
// CODEWORK change this to reflect FRS-Connection specifics
DSPAGE FrsConnectionGeneral = {IDS_TITLE_FRS_CONNECTION, IDD_FRS_CONNECTION_GENERAL,
                      0, 0, NULL, NULL,
                      sizeof(rgpFrsConnectionGenAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsConnectionGenAttrMap};

//+----------------------------------------------------------------------------
// Container General Page.
//-----------------------------------------------------------------------------

//
// The list of attributes on the Container General page.
//
PATTR_MAP rgpContainerGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Container General page description.
//
DSPAGE ContainerGeneral = {IDS_TITLE_GENERAL, IDD_CONTAINER_GENERAL, 0, 0, NULL,
                           CreateTableDrivenPage,
                           sizeof(rgpContainerGenAttrMap)/sizeof(PATTR_MAP),
                           rgpContainerGenAttrMap};
//
// The list of Container pages.
//
PDSPAGE rgContainerPages[] = {{&ContainerGeneral}};

//
// The Container class description.
//
DSCLASSPAGES ContainerCls = {&CLSID_DsContainerGeneralPage, TEXT("Container"),
                             sizeof(rgContainerPages)/sizeof(PDSPAGE),
                             rgContainerPages};
//+----------------------------------------------------------------------------
// RPC Container General Page.
//-----------------------------------------------------------------------------

//
// RPC Container General page, Flags attribute
//
ATTR_MAP RpcFlags = {IDC_COMPAT_CHK, FALSE, FALSE, 0, {L"nameServiceFlags",
                     ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0}, IntegerAsBoolDefOn, NULL};
//
// The list of attributes on the Rpc General page.
//
PATTR_MAP rgpRpcGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&RpcFlags}};

//
// The Rpc General page description.
//
DSPAGE RpcGeneral = {IDS_TITLE_GENERAL, IDD_RPC_GEN, 0, 0, NULL,
                     CreateTableDrivenPage,
                     sizeof(rgpRpcGenAttrMap)/sizeof(PATTR_MAP),
                     rgpRpcGenAttrMap};
//
// The list of Rpc pages.
//
PDSPAGE rgRpcPages[] = {{&RpcGeneral}};

//
// The Rpc Container class description.
//
DSCLASSPAGES RpcCls = {&CLSID_DsRpcContainer, TEXT("Rpc Container"),
                       sizeof(rgRpcPages)/sizeof(PDSPAGE), rgRpcPages};

//+----------------------------------------------------------------------------
// FPO General Page
//-----------------------------------------------------------------------------

//
// Object Name: derived from SID.
//
ATTR_MAP FPOrealName = {IDC_CN, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                        {NULL, ADS_ATTR_UPDATE,
						 ADSTYPE_CASE_IGNORE_STRING, NULL, 0},
                        GetAcctName, NULL};
//
// The list of attributes on the FPO General page.
//
PATTR_MAP rgpFPOGenAttrMap[] = {{&GenIcon}, {&FPOrealName}, {&Description}};

//
// The FPO page description.
//
DSPAGE FPOGeneral = {IDS_TITLE_GENERAL, IDD_FPO_GENERAL, 0, 0, NULL,
                     CreateTableDrivenPage,
                     sizeof(rgpFPOGenAttrMap)/sizeof(PATTR_MAP),
                     rgpFPOGenAttrMap};
//
// The list of FPO pages.
//
PDSPAGE rgFPOPages[] = {{&FPOGeneral}, {&NonSecMemberPage}};

//
// The FPO class description.
//
DSCLASSPAGES FPOCls = {&CLSID_DsFSPOPropPages, TEXT("FPO"),
                       sizeof(rgFPOPages)/sizeof(PDSPAGE), rgFPOPages};

//+----------------------------------------------------------------------------
// Default General Page (for the default display specifier).
//-----------------------------------------------------------------------------

//
// The list of attributes on the Default General page.
//
PATTR_MAP rgpDefaultGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Default General page description.
//
DSPAGE DefaultGeneral = {IDS_TITLE_GENERAL, IDD_DEFAULT_GENERAL, 0, 0, NULL,
                         CreateTableDrivenPage,
                         sizeof(rgpDefaultGenAttrMap)/sizeof(PATTR_MAP),
                         rgpDefaultGenAttrMap};
//
// The list of Default pages.
//
PDSPAGE rgDefaultPages[] = {{&DefaultGeneral}};

//
// The Default class description.
//
DSCLASSPAGES DefaultCls = {&CLSID_DsDefaultGeneralPage, TEXT("Default"),
                           sizeof(rgDefaultPages)/sizeof(PDSPAGE),
                           rgDefaultPages};

//+----------------------------------------------------------------------------
// Default General Multi-select Page (for the default display specifier).
//-----------------------------------------------------------------------------

//
// The list of attributes on the Default General page.
//
PATTR_MAP rgpDefaultGenMultiAttrMap[] = {{&Description}};

//
// The Default General page description.
//
DSPAGE DefaultMultiGeneral = {IDS_TITLE_GENERAL, IDD_DEFAULT_MULTI_GENERAL, 0, 0, NULL,
                              CreateGenericMultiPage,
                              sizeof(rgpDefaultGenMultiAttrMap)/sizeof(PATTR_MAP),
                              rgpDefaultGenMultiAttrMap};
//
// The list of Default pages.
//
PDSPAGE rgDefaultMultiPages[] = {{&DefaultMultiGeneral}};

//
// The Default class description.
//
DSCLASSPAGES DefaultMultiCls = {&CLSID_DsDefaultMultiGeneralPage, TEXT("Default"),
                                sizeof(rgDefaultMultiPages)/sizeof(PDSPAGE),
                                rgDefaultMultiPages};

//----------------------------------------------
// Multi-select Address page, Address
//

//----------------------------------------------

//
// The list of attributes on the User General page.
//
PATTR_MAP rgpUGenAttrMap[] = {{&GenIcon}, {&Description},
                              {&UGOffice}, {&UGPhone}, {&UGOtherPhone},
                              {&UGEMail}, {&UGURL}, {&UGOtherURL},
                              {&UPhOtherFax}, {&UPhFax},};

//
// The User General page
//
DSPAGE UserMultiGeneral = {IDS_TITLE_GENERAL, IDD_MULTI_USER_GENERAL, 0, 0, NULL,
                           CreateMultiGeneralUserPage, sizeof(rgpUGenAttrMap)/sizeof(PATTR_MAP),
                           rgpUGenAttrMap};

//
// The User Account page description.
//
DSPAGE UserMultiAccount = {IDS_USER_TITLE_ACCT, IDD_MULTI_ACCOUNT, 0, 0, NULL,
                            CreateUserMultiAcctPage, 0, NULL};

//
// Address page description.
//
DSPAGE UserMultiAddress = {IDS_TITLE_ADDRESS, IDD_MULTI_USER_ADDRESS, 0, 0, NULL,
                            CreateMultiAddressUserPage,
                            sizeof(rgpUAddrAttrMap)/sizeof(PATTR_MAP),
                            rgpUAddrAttrMap};

//
// The Organization page description.
//
DSPAGE UserMultiOrg = {IDS_USER_TITLE_ORG, IDD_MULTI_USER_ORG, 0, 0, NULL,
                        CreateMultiOrganizationUserPage,
                        sizeof(rgpUOrgAttrMap)/sizeof(PATTR_MAP), rgpUOrgAttrMap};

//----------------------------------------------
// The User Profile page description.
//
DSPAGE UserMultiProfile = {IDS_USER_TITLE_PROFILE, IDD_MULTI_USER_PROFILE, 0, 0, NULL,
                           CreateMultiUsrProfilePage, 0, NULL};



PDSPAGE rgUserMultiPages[] = {{&UserMultiGeneral}, {&UserMultiAccount}, {&UserMultiAddress}, /*{&MultiPhoneNotes},*/
                              {&UserMultiProfile}, {&UserMultiOrg}};
//                        {{&UserGeneral}, {&UserAddress}, 
//                         {&UserProfile}, {&PhoneNotes}, {&FPNWPage},
//                         {&UserOrg}, {&PubCertPage}, {&MemberPage}};

//
// The User class description.
//
DSCLASSPAGES UserMultiCls = {&CLSID_DsUserMultiPropPages, TEXT("User"),
                              sizeof(rgUserMultiPages)/sizeof(PDSPAGE),
                              rgUserMultiPages};

//+----------------------------------------------------------------------------
// Inter-Site Transport Objects.
//-----------------------------------------------------------------------------

// CODEWORK this should support (lower priority) read-only Bridgehead-Transport-List-BL
ATTR_MAP UIntersiteIgnoreSchedules = {IDC_CHECK1, FALSE, FALSE,
                            NTDSTRANSPORT_OPT_IGNORE_SCHEDULES,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            FirstSharedBitField, NULL};
ATTR_MAP UIntersiteSitelinksBridged = {IDC_CHECK2, TRUE /* read-only */, FALSE,
                            ~((DWORD)NTDSTRANSPORT_OPT_BRIDGES_REQUIRED),
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            SubsequentSharedBitField, NULL};
PATTR_MAP rgpIntersiteGeneralAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                        , {&UIntersiteIgnoreSchedules}
                        , {&UIntersiteSitelinksBridged}
                        };
DSPAGE IntersiteGeneral = {IDS_TITLE_GENERAL, IDD_INTERSITE_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpIntersiteGeneralAttrMap)/sizeof(PATTR_MAP),
                      rgpIntersiteGeneralAttrMap};
PDSPAGE rgIntersiteGeneralPages[] = {{&IntersiteGeneral}};
DSCLASSPAGES IntersiteSettingsCls = {&CLSID_DsIntersitePropPages, TEXT("Inter-Site-Transport"),
                        sizeof(rgIntersiteGeneralPages)/sizeof(PDSPAGE),
                        rgIntersiteGeneralPages};


ATTR_MAP AttrSiteList_In= {IDC_DUELLING_LB_IN, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                           {L"siteList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                           DsQuerySiteList, NULL};
ATTR_MAP AttrSiteList_Out = {IDC_DUELLING_LB_OUT, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"siteList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                             DuellingListbox, NULL};
ATTR_MAP AttrCostEdit = {IDC_EDIT1, FALSE, FALSE, IDC_SPIN /* spinbutton ID */,
                          {L"cost", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          EditNumber, NULL};
ATTR_MAP AttrCostSpin = {IDC_SPIN, TRUE /* read-only */, FALSE, 0x7FFFFFFF,
                          {L"cost", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          SpinButton, (PVOID)1};
ATTR_MAP AttrReplIntervalEdit = {IDC_EDIT2, FALSE, FALSE, IDC_SPIN2 /* spinbutton ID */,
                          {L"replInterval", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          EditNumber, NULL};
ATTR_MAP AttrReplIntervalSpin = {IDC_SPIN2, TRUE /* read-only */, FALSE, 7*24*60,
                          {L"replInterval", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          SpinButton, (PVOID)15};
ATTR_MAP AttrReplIntervalIncrement = {IDC_SPIN2, TRUE /* read-only */, FALSE, 15,
                          {NULL, ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          SpinButtonExtendIncrement, NULL};
PATTR_MAP rgpSiteLinkAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                        , {&AttrSiteList_In}
                        , {&DuellingAttr_Add}
                        , {&DuellingAttr_Remove}
                        , {&AttrSiteList_Out}
                        , {&AttrCostEdit}
                        , {&AttrCostSpin}
                        , {&AttrReplIntervalEdit}
                        , {&AttrReplIntervalSpin}
                        , {&AttrReplIntervalIncrement}
#ifdef CUSTOM_SCHEDULE
                        , {&UScheduleCheckbox}
#endif
                        , {&UReplicationScheduleBtn}
                        };
DSPAGE DsSiteLinkGeneral = {IDS_TITLE_GENERAL, IDD_SITELINK_GENERAL,
                      0, 0, NULL, CreateTableDrivenPage,
                      sizeof(rgpSiteLinkAttrMap)/sizeof(PATTR_MAP),
                      rgpSiteLinkAttrMap};

ATTR_MAP AttrSiteLinkList_In= {IDC_DUELLING_LB_IN, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                               {L"siteLinkList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                                DsQuerySiteLinkList, NULL};
ATTR_MAP AttrSiteLinkList_Out = {IDC_DUELLING_LB_OUT, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                                 {L"siteLinkList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                                 DuellingListbox, NULL};
PATTR_MAP rgpSiteLinkBridgeAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                        , {&AttrSiteLinkList_In}
                        , {&DuellingAttr_Add}
                        , {&DuellingAttr_Remove}
                        , {&AttrSiteLinkList_Out}
                        };
DSPAGE DsSiteLinkBridgeGeneral = {IDS_TITLE_GENERAL, IDD_SITELINKBRIDGE_GENERAL,
                      0, 0, NULL, CreateTableDrivenPage,
                      sizeof(rgpSiteLinkBridgeAttrMap)/sizeof(PATTR_MAP), // temporary
                      rgpSiteLinkBridgeAttrMap};

PDSPAGE rgDsSiteLinkPages[] = {{&DsSiteLinkGeneral}};
PDSPAGE rgDsSiteLinkBridgePages[] = {{&DsSiteLinkBridgeGeneral}};

DSCLASSPAGES DsSiteLinkCls = {&CLSID_DsReplSiteLink, TEXT("Site-Link"),
                        sizeof(rgDsSiteLinkPages)/sizeof(PDSPAGE),
                        rgDsSiteLinkPages};
DSCLASSPAGES DsSiteLinkBridgeCls = {&CLSID_DsReplSiteLinkBridge, TEXT("Site-Link-Bridge"),
                        sizeof(rgDsSiteLinkBridgePages)/sizeof(PDSPAGE),
                        rgDsSiteLinkBridgePages};

//+----------------------------------------------------------------------------
// Object Page (Top properties).
//-----------------------------------------------------------------------------

//
// Object Path.
//
ATTR_MAP ObjectPath = {IDC_PATH_FIELD, TRUE, FALSE, 0,
                       {g_wzADsPath, ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ObjectPathField, NULL};
//
// Object class.
//
ATTR_MAP ObjectClass = {IDC_CLASS_STATIC, TRUE, FALSE, 0,
                        {g_wzClass, ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GetObjectClass, NULL};
//
// Timestamp Created.
//
ATTR_MAP TimeCreated = {IDC_CREATED_TIME_STATIC, TRUE, FALSE, 0,
                        {L"whenCreated", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GetObjectTimestamp, NULL};
//
// Timestamp Last Modified.
//
ATTR_MAP TimeModified = {IDC_MODIFIED_TIME_STATIC, TRUE, FALSE, 0,
                         {L"whenChanged", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GetObjectTimestamp, NULL};
//
// USN Created.
//
ATTR_MAP USNCreated = {IDC_USN_CREATED_STATIC, TRUE, FALSE, 0,
                       {L"uSNCreated", ADS_ATTR_UPDATE,
                        ADSTYPE_LARGE_INTEGER, NULL, 0}, NULL, NULL};
//
// USN Changed.
//
ATTR_MAP USNChanged = {IDC_USN_MODIFIED_STATIC, TRUE, FALSE, 0,
                       {L"uSNChanged", ADS_ATTR_UPDATE,
                        ADSTYPE_LARGE_INTEGER, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Top page.
//
PATTR_MAP rgpTopAttrMap[] = {{&ObjectPath}, {&ObjectClass}, {&TimeCreated},
                             {&TimeModified}, {&USNCreated}, {&USNChanged}};

//
// The Top page description.
//
DSPAGE TopPage = {IDS_OBJECT, IDD_OBJECT, DSPROVIDER_ADVANCED, 0, NULL,
                  CreateTableDrivenPage,
                  sizeof(rgpTopAttrMap)/sizeof(PATTR_MAP), rgpTopAttrMap};
//
// The list of Top pages.
//
PDSPAGE rgTopPages[] = {{&TopPage}};

//
// The Top class description.
//
DSCLASSPAGES TopCls = {&CLSID_DsTopPropPages, TEXT("Top"),
                       sizeof(rgTopPages)/sizeof(PDSPAGE),
                       rgTopPages};

//+----------------------------------------------------------------------------
// Printer Queue Object.
//-----------------------------------------------------------------------------

//
// PrintQueueName.
//
ATTR_MAP PrintQueueName = {IDC_CN, TRUE, FALSE,
                               1024, {L"printerName", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Description.
//
ATTR_MAP PrintQueueDesc = {IDC_DESC_EDIT, FALSE, FALSE,
                           1024, {L"description", ADS_ATTR_UPDATE,
                                  ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Location.
//
ATTR_MAP PrintQueueLocation = {IDC_LOCATION_EDIT, FALSE, FALSE,
                               1024, {L"location", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

//
// Model. 
//
ATTR_MAP PrintQueueModel = {IDC_MODEL_EDIT, FALSE, FALSE,
                               1024, {L"driverName", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

//
// color.
//
ATTR_MAP PrintQueueColor = {IDC_CHECK_COLOR, FALSE, FALSE,
                               1024, {L"printColor", ADS_ATTR_UPDATE,
                               ADSTYPE_BOOLEAN, NULL, 0}, NULL, NULL};

//
// staple.
//
ATTR_MAP PrintQueueStaple = {IDC_CHECK_STAPLE, FALSE, FALSE,
                               1024, {L"printStaplingSupported", ADS_ATTR_UPDATE,
                               ADSTYPE_BOOLEAN, NULL, 0}, NULL, NULL};

//
// Speed.
//
ATTR_MAP PrintQueueSpeed = {IDC_EDIT_SPEED, FALSE, FALSE,
                               10, {L"printRate", ADS_ATTR_UPDATE,
                               ADSTYPE_INTEGER, 0}, NULL, NULL};

//
// Resolution.
//
ATTR_MAP PrintQueueResolution = {IDC_EDIT_RESOLUTION, FALSE, FALSE,
                               10, {L"printMaxResolutionSupported", ADS_ATTR_UPDATE,
                               ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};

//
// Duplex.
//
ATTR_MAP PrintQueueDuplex = {IDC_CHECK_DOUBLE_SIDED, FALSE, FALSE,
                               1024, {L"printDuplexSupported", ADS_ATTR_UPDATE,
                               ADSTYPE_BOOLEAN, NULL, 0}, NULL, NULL};

//
// The list of attributes on the Printer Queue General page.
//
PATTR_MAP rgpPrintQGenAttrMap[] = {{&GenIcon}, {&PrintQueueName}, {&PrintQueueDesc},
                                   {&PrintQueueLocation}, {&PrintQueueModel},
                                   {&PrintQueueColor}, {&PrintQueueStaple},
                                   {&PrintQueueDuplex}, {&PrintQueueSpeed},
                                   {&PrintQueueResolution}};

//
// The Printer Queue General page description.
//
DSPAGE PrinterQueueGen = {IDS_TITLE_GENERAL, IDD_GENERAL_PRINTQ, 0, 0, NULL,
                          CreateTableDrivenPage,
                          sizeof(rgpPrintQGenAttrMap)/sizeof(PATTR_MAP),
                          rgpPrintQGenAttrMap};
//
// The list of Printer Queue pages.
//
PDSPAGE rgPrintQPages[] = {{&PrinterQueueGen}, {&ManagedByPage}};

//
// The DS Print Queue class description.
//
DSCLASSPAGES PrinterQCls = {&CLSID_DsPrinterPropPages, TEXT("Printer-Queue"),
                            sizeof(rgPrintQPages)/sizeof(PDSPAGE),
                            rgPrintQPages};

//+----------------------------------------------------------------------------
// The list of classes.
//-----------------------------------------------------------------------------

PDSCLASSPAGES rgClsPages[] = {
    &UserCls,
#ifdef INETORGPERSON
    &inetOrgPersonCls,
#endif
    &MemberCls,
    &ContactCls,
    &GroupCls,
    &OUCls,
    &ContainerCls,
    &DomainCls,
    &DomainPolicyCls,
    &LocalPolicyCls,
    &TrustedDomainCls,
    &ManagedByCls,
    &SiteCls,
    &DsSiteSettingsCls,
    &DsSiteLicenseSettingsCls,
    &DsServerCls,
    &NTDS_DSACls,
    &DsConnectionCls,
    &FrsReplicaSetCls,
    &FrsMemberCls,
    &FrsSubscriberCls,
    &IntersiteSettingsCls,
    &DsSiteLinkCls,
    &DsSiteLinkBridgeCls,
    &SubnetCls,
    &VolumeCls,
    &ComputerCls,
    &TopCls,
    &PrinterQCls,
    &RpcCls,
    &FPOCls,
    &DefaultCls,
    &DefaultMultiCls,
    &UserMultiCls,
};


//+----------------------------------------------------------------------------
// The global struct containing the list of classes.
//-----------------------------------------------------------------------------
RGDSPPCLASSES g_DsPPClasses = {sizeof(rgClsPages)/sizeof(PDSCLASSPAGES),
                               rgClsPages};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\routing.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       routing.cxx
//
//  Contents:   Domain trust support, forest trust name routing property page.
//
//  History:    20-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"
#include "routing.h"
#include <lmerr.h>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  CDsForestNameRoutingPage: Domain Trust Page object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member: CDsForestNameRoutingPage::CDsForestNameRoutingPage
//
//-----------------------------------------------------------------------------
CDsForestNameRoutingPage::CDsForestNameRoutingPage(HWND hParent) :
   _hParent(hParent),
   _hPage(NULL),
   _fInInit(FALSE),
   _fPageDirty(false),
   _nTrustDirection(0)
{
   TRACER(CDsForestNameRoutingPage,CDsForestNameRoutingPage);
#ifdef _DEBUG
   strcpy(szClass, "CDsForestNameRoutingPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsForestNameRoutingPage::~CDsForestNameRoutingPage
//
//-----------------------------------------------------------------------------
CDsForestNameRoutingPage::~CDsForestNameRoutingPage()
{
   TRACER(CDsForestNameRoutingPage,~CDsForestNameRoutingPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::Init
//
//  Synopsis:   Create the page.
//
//-----------------------------------------------------------------------------
HRESULT
CDsForestNameRoutingPage::Init(PCWSTR pwzDomainDnsName,
                               PCWSTR pwzTrustPartnerName,
                               PCWSTR pwzPartnerFlatName,
                               PCWSTR pwzDcName,
                               ULONG nTrustDirection,
                               BOOL fReadOnly)
{
   HRESULT hr = S_OK;

   _strDomainDnsName = pwzDomainDnsName;
   if (_strDomainDnsName.IsEmpty())
      return E_OUTOFMEMORY;
   _strTrustPartnerDnsName = pwzTrustPartnerName;
   if (_strTrustPartnerDnsName.IsEmpty())
      return E_OUTOFMEMORY;
   _strTrustPartnerFlatName = pwzPartnerFlatName;
   if (_strTrustPartnerFlatName.IsEmpty())
      return E_OUTOFMEMORY;
   _strUncDC = pwzDcName;
   if (_strUncDC.IsEmpty())
      return E_OUTOFMEMORY;

   _nTrustDirection = nTrustDirection;
   _fReadOnly = fReadOnly;

   CStrW strTitle;
   strTitle.LoadString(g_hInstance, IDS_ROUTING_PAGE_TITLE);
   if (strTitle.IsEmpty())
   {
      return E_OUTOFMEMORY;
   }

   PROPSHEETPAGE   psp;

   psp.dwSize      = sizeof(PROPSHEETPAGE);
   psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_FOREST_ROUTING);
   psp.pfnDlgProc  = (DLGPROC)StaticDlgProc;
   psp.pfnCallback = PageCallback;
   psp.pcRefParent = NULL; // do not set PSP_USEREFPARENT
   psp.lParam      = (LPARAM) this;
   psp.hInstance   = g_hInstance;
   psp.pszTitle    = strTitle;

   HPROPSHEETPAGE hpsp;

   hpsp = CreatePropertySheetPage(&psp);

   if (hpsp == NULL)
   {
       return HRESULT_FROM_WIN32(GetLastError());
   }

   // Send PSM_ADDPAGE
   //
   if (!PropSheet_AddPage(_hParent, hpsp))
   {
      return HRESULT_FROM_WIN32(GetLastError());
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::StaticDlgProc
//
//  Synopsis:   static dialog proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CDsForestNameRoutingPage::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   CDsForestNameRoutingPage * pPage = (CDsForestNameRoutingPage *)GetWindowLongPtr(hDlg, DWLP_USER);

   if (uMsg == WM_INITDIALOG)
   {
      LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

      pPage = (CDsForestNameRoutingPage *) ppsp->lParam;
      pPage->_hPage = hDlg;

      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);

      return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   if (pPage != NULL)
   {
      return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   LRESULT lr;

   switch (uMsg)
   {
   case WM_INITDIALOG:
      _fInInit = TRUE;
      lr = OnInitDialog(lParam);
      _fInInit = FALSE;
      return lr;

   case WM_NOTIFY:
      return OnNotify(wParam, lParam);

   case WM_HELP:
      return OnHelp((LPHELPINFO)lParam);

   case WM_COMMAND:
      if (_fInInit)
      {
         return TRUE;
      }
      return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                       GET_WM_COMMAND_HWND(wParam, lParam),
                       GET_WM_COMMAND_CMD(wParam, lParam)));
   case WM_DESTROY:
      return OnDestroy();

   default:
      return FALSE;
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnInitDialog(LPARAM)
{
   TRACER(CDsForestNameRoutingPage, OnInitDialog);

   // Set the list label, checking text length first. Use a two line label if
   // the text is too long for a single line.
   //

   FormatWindowText(GetDlgItem(_hPage, IDC_SUFFIXES_STATIC), _strTrustPartnerDnsName);

   UseOneOrTwoLine(_hPage, IDC_SUFFIXES_STATIC, IDC_SUFFIXES_STATIC_BIG);

   _TLNList.Init(_hPage, IDC_SUFFIXES_LIST);

   CheckForNameChanges();

   RefreshList();

   if (_fReadOnly)
   {
      CStrW strView;
      strView.LoadString(g_hInstance, IDS_VIEW);
      SetDlgItemText(_hPage, IDC_EDIT_BTN, strView);
   }

   EnableButtons();

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::CheckForNameChanges
//
//  Synopsis:   The new info is read from the trust partner.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::CheckForNameChanges(BOOL fReport)
{
   TRACE(CDsForestNameRoutingPage, CheckForNameChanges);

   PWSTR pwzServer = _strUncDC, pwzDomain = _strTrustPartnerDnsName;
   DWORD dwRet = NO_ERROR;
   PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
   BOOL fNewInfoRead = TRUE;
   CWaitCursor Wait;

   if (TRUST_DIRECTION_INBOUND == _nTrustDirection)
   {
      // If trust is inbound-only, query must be remoted to other domain.
      //
      dwRet = DsGetDcNameW(NULL, _strTrustPartnerDnsName, NULL, NULL,
                           DS_DS_FLAG, &pDCInfo);

      if (ERROR_SUCCESS != dwRet || !pDCInfo)
      {
         ErrMsgParam(IDS_ROUTING_ERR_NO_DC,
                     (LPARAM)_strTrustPartnerDnsName.GetBuffer(0),
                     _hPage);
         return;
      }

      pwzServer = pDCInfo->DomainControllerName;
      pwzDomain = NULL;
   }

   CPolicyHandle cPolicy(_strUncDC);

   dwRet = cPolicy.OpenWithPrompt(_LocalCreds, Wait,
                                  _strDomainDnsName, _hPage);
   if (NO_ERROR != dwRet)
   {
      SuperMsgBox(_hPage, IDS_RNSPAGE_ACCESS, IDS_DNT_MSG_TITLE, MB_OK | MB_ICONINFORMATION,
                  dwRet, NULL, 0, FALSE, __FILE__, __LINE__);
      EnableWindow(GetDlgItem(_hPage, IDC_SUFFIXES_LIST), FALSE);
      return;
   }

   // Read the FT name info from the trust partner to discover any changes.
   // If the trust partner is not available, then don't do the merge.
   //
   PLSA_FOREST_TRUST_INFORMATION pNewFTInfo = NULL;

   if (TRUST_DIRECTION_OUTBOUND & _nTrustDirection)
   {
      _LocalCreds.Impersonate();
   }

   dwRet = DsGetForestTrustInformationW(pwzServer,
                                        pwzDomain,
                                        0,
                                        &pNewFTInfo);
   _LocalCreds.Revert();

   if (ERROR_ACCESS_DENIED == dwRet &&
       TRUST_DIRECTION_INBOUND == _nTrustDirection)
   {
      // Prompt for creds for the other domain.
      //
      CCreds RemoteCreds;

      dwRet = RemoteCreds.PromptForCreds(_strTrustPartnerDnsName, _hPage);

      if (ERROR_CANCELLED == dwRet)
      {
         dwRet = ERROR_ACCESS_DENIED;
      }
      else
      {
         if (NO_ERROR == dwRet)
         {
            RemoteCreds.Impersonate();

            dwRet = DsGetForestTrustInformationW(pwzServer,
                                                 pwzDomain,
                                                 0,
                                                 &pNewFTInfo);
            RemoteCreds.Revert();
         }
      }
   }

   if (NO_ERROR != dwRet && fReport)
   {
      int nID = IDS_ERR_FT_CONTACT_DOMAIN;
      if (ERROR_NO_TRUST_SAM_ACCOUNT == dwRet ||
          ERROR_NO_SUCH_DOMAIN == dwRet)
      {
         nID = IDS_ERR_FT_TRUST_MISSING;
      }
      if (ERROR_INVALID_FUNCTION == dwRet)
      {
         nID = IDS_ERR_NOT_FORESTTRUST;
      }
      SuperMsgBox(_hPage, nID, IDS_DNT_MSG_TITLE, MB_OK | MB_ICONINFORMATION,
                  dwRet, NULL, 0, FALSE, __FILE__, __LINE__);
      fNewInfoRead = FALSE;
   }

   if (pDCInfo)
   {
      NetApiBufferFree(pDCInfo);
   }

   NTSTATUS status;
   LSA_UNICODE_STRING TrustPartner;
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL, pMergedFTInfo;

   RtlInitUnicodeString(&TrustPartner, _strTrustPartnerDnsName);

   // Read the local FT info to get the admin-disabled state.
   //
   status = LsaQueryForestTrustInformation(cPolicy,
                                           &TrustPartner,
                                           &pFTInfo);

   if (STATUS_NOT_FOUND == status)
   {
      DBG_OUT("No FTInfos found on the local TDO!\n");
      //
      // no FT info stored yet.
      //
      status = STATUS_SUCCESS;
      //
      // Set the page dirty bit so the user has a chance to save the FTInfo.
      //
      SetDirty();
   }

   CHECK_LSA_STATUS_REPORT(status, _hPage, return);

   if (fNewInfoRead && pNewFTInfo)
   {
      if (pFTInfo)
      {
         if (AnyForestNameChanges(pFTInfo, pNewFTInfo))
         {
            dspDebugOut((DEB_ITRACE, "Claimed forest names have changed, setting dirty state.\n"));
            SetDirty();
         }
         //
         // Merge the two.
         //
         dwRet = DsMergeForestTrustInformationW(_strTrustPartnerDnsName,
                                                pNewFTInfo,
                                                pFTInfo,
                                                &pMergedFTInfo);
         NetApiBufferFree(pNewFTInfo);

         CHECK_WIN32_REPORT(dwRet, _hPage, return);

         dspAssert(pMergedFTInfo);

         _FTInfo = pMergedFTInfo;

         LsaFreeMemory(pMergedFTInfo);
         pMergedFTInfo = NULL;
         LsaFreeMemory(pFTInfo);
         pFTInfo = NULL;
      }
      else
      {
         _FTInfo = pNewFTInfo;
         NetApiBufferFree(pNewFTInfo);
      }
   }
   else
   {
      if (pFTInfo)
      {
         _FTInfo = pFTInfo;
         LsaFreeMemory(pFTInfo);
         pFTInfo = NULL;
      }
      else
      {
         // This case is reached if the trust on the other side is of the
         // wrong type (external rather than forest) and the TDO on this
         // side has no forest trust information (which it wouldn't have
         // if the other side is incapable of supplying it). The error
         // message above for ERROR_INVALID_FUNCTION will have explained
         // the situation.
         //
         return;
      }
   }

   // Make a temp copy and clear the conflict bit before submitting to LSA.
   // This will return current conflict info.
   //
   CFTInfo TempFTInfo(_FTInfo);

   TempFTInfo.ClearAnyConflict();

   // Now check the data. On return from the call the pColInfo struct
   // will contain current collision data.
   //
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo;

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         TempFTInfo.GetFTInfo(),
                                         TRUE, // check only, don't write to TDO
                                         &pColInfo);

   CHECK_LSA_STATUS_REPORT(status, _hPage, return);

   _CollisionInfo = pColInfo;

   // Look for names that used to be or are now in conflict.
   //
   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      // Any names that used to be in conflict but aren't now are marked as
      // admin-disabled.
      //
      if (_FTInfo.IsConflictFlagSet(i))
      {
         if (!_CollisionInfo.IsInCollisionInfo(i))
         {
            _FTInfo.SetAdminDisable(i);
            _FTInfo.SetUsedToBeInConflict(i);
            continue;
         }
      }
      // If a name is in the collision info, then set the conflict flag.
      //
      if (_CollisionInfo.IsInCollisionInfo(i))
      {
         _FTInfo.SetConflictDisable(i);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::RefreshList
//
//  Synopsis:   Read the name suffixes and add them to the list.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::RefreshList(void)
{
   TRACER(CDsForestNameRoutingPage, RefreshList);
   CWaitCursor Wait;

   _TLNList.Clear();

   BOOL fCollision, fAdminDisabled, fNewDisabled;
   CStrW strName;

   dspDebugOut((DEB_ITRACE, "There are %d FTInfo records.\n", _FTInfo.GetCount()));

   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!_FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return;
      }

      if (type != ForestTrustTopLevelName)
      {
         // Only TLNs go into the list.
         //
         continue;
      }

      fCollision = fAdminDisabled = fNewDisabled = FALSE;

      _FTInfo.GetDnsName(i, strName);

      AddAsteriskPrefix(strName);

      if (LSA_TLN_DISABLED_CONFLICT & _FTInfo.GetFlags(i))
      {
         dspDebugOut((DEB_ITRACE, "Collision record found for %ws\n", strName.GetBuffer(0)));
         fCollision = TRUE;
      }
      if (LSA_TLN_DISABLED_NEW & _FTInfo.GetFlags(i))
      {
         fNewDisabled = TRUE;
      }
      if (LSA_TLN_DISABLED_ADMIN & _FTInfo.GetFlags(i))
      {
         fAdminDisabled = TRUE;
      }

      CStrW strEnabled, strCollisionName, strStatus;

      if (fAdminDisabled || fNewDisabled)
      {
         strEnabled.LoadString(g_hInstance, IDS_ROUTING_DISABLED);

         if (fAdminDisabled && _FTInfo.WasInConflict(i))
         {
            strStatus.LoadString(g_hInstance, IDS_STATUS_CONFLICT_GONE);
         }

         if (fNewDisabled)
         {
            strStatus.LoadString(g_hInstance, IDS_STATUS_NEW);
         }
      }
      else
      {
         // Find if there is a conflict record for this name.
         //
         if (_CollisionInfo.IsInCollisionInfo(i))
         {
            fCollision = TRUE;
            strEnabled.LoadString(g_hInstance, IDS_ROUTING_CONFLICT);
            _CollisionInfo.GetCollisionName(i, strCollisionName);
            strEnabled += strCollisionName;
         }

         if (!fCollision)
         {
            strEnabled.LoadString(g_hInstance, IDS_ROUTING_ENABLED);

            if (_FTInfo.AnyChildDisabled(i))
            {
               strStatus.LoadString(g_hInstance, IDS_STATUS_EXCEPTIONS);
            }
         }
      }

      _TLNList.AddItem(strName, i, strEnabled, strStatus);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::CheckDomainForConflict
//
//  Synopsis:  If a domain was disable and has been changed to enabled by the
//             user, check if the domain is in conflict. The only way to do
//             this is to submit the entire FTInfo to LSA.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::CheckDomainForConflict(CWaitCursor & Wait)
{
   TRACER(CDsForestNameRoutingPage,CheckDomainForConflict);
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo;
   NTSTATUS status;
   LSA_UNICODE_STRING TrustPartner;
   DWORD dwRet;
   CPolicyHandle cPolicy(_strUncDC);

   dwRet = cPolicy.OpenWithPrompt(_LocalCreds, Wait,
                                  _strDomainDnsName, _hPage);

   CHECK_WIN32_REPORT(dwRet, _hPage, return);

   RtlInitUnicodeString(&TrustPartner, _strTrustPartnerDnsName);

   CFTInfo TempFTInfo(_FTInfo);

   TempFTInfo.ClearAnyConflict();

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         TempFTInfo.GetFTInfo(),
                                         TRUE, // check only, don't write to TDO
                                         &pColInfo);

   CHECK_LSA_STATUS_REPORT(status, _hPage, return);

   // Save the collision info.
   //
   _CollisionInfo = pColInfo;

   // Look for names that are now in conflict.
   //
   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      // If a name is in the collision info but it is marked as enabled, then
      // set the conflict flag.
      //
      if (_CollisionInfo.IsInCollisionInfo(i))
      {
         if (_FTInfo.IsEnabled(i))
         {
            _FTInfo.SetConflictDisable(i);
            continue;
         }
      }
      // Any names that used to be in conflict but aren't now are marked as
      // admin-disabled.
      //
      if (_FTInfo.IsConflictFlagSet(i))
      {
         if (!_CollisionInfo.IsInCollisionInfo(i))
         {
            _FTInfo.SetAdminDisable(i);
            _FTInfo.SetUsedToBeInConflict(i);
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::EnableButtons
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::EnableButtons(void)
{
   TRACER(CDsForestNameRoutingPage, EnableButtons);
   BOOL fEnableEnable = TRUE, fEnableDisable = TRUE, fEnableEdit = TRUE;

   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      fEnableEnable = fEnableDisable = fEnableEdit = FALSE;
   }
   else
   {
      if (_fReadOnly)
      {
         fEnableEnable = fEnableDisable = FALSE;
      }
      else
      {
         // What is the state of the selected item.
         //
         ULONG i = _TLNList.GetFTInfoIndex(item);

         dspAssert(i < _FTInfo.GetCount());

         // Only TLNs show up in the list, so only need to check TLN flags.
         //
         if (LSA_TLN_DISABLED_NEW & _FTInfo.GetFlags(i))
         {
            fEnableDisable = FALSE;
         }
         else
         if (LSA_TLN_DISABLED_ADMIN & _FTInfo.GetFlags(i))
         {
            fEnableDisable = FALSE;
         }
         else
         if (LSA_TLN_DISABLED_CONFLICT & _FTInfo.GetFlags(i) ||
             _CollisionInfo.IsInCollisionInfo(i))
         {
            fEnableEnable = fEnableDisable = FALSE;
         }
         else
         {
            fEnableEnable = FALSE;
         }
      }
   }

   EnableWindow(GetDlgItem(_hPage, IDC_ENABLE_BTN), fEnableEnable);
   EnableWindow(GetDlgItem(_hPage, IDC_DISABLE_BTN), fEnableDisable);
   EnableWindow(GetDlgItem(_hPage, IDC_EDIT_BTN), fEnableEdit);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnApply(void)
{
   TRACE(CDsForestNameRoutingPage, OnApply);
   DWORD dwRet;
   LRESULT lResult = PSNRET_INVALID_NOCHANGEPAGE;

   // Write the new data to the TDO.
   //
   dwRet = WriteTDO();

   if (NO_ERROR == dwRet)
   {
      ClearDirty();
      lResult = PSNRET_NOERROR;
   }
   else
   {
      ReportError(dwRet, IDS_ERR_WRITE_FTI_TO_TDO, _hPage);
   }

   return lResult;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (_fInInit)
   {
       return 0;
   }
   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_ENABLE_BTN:
         OnEnableClick();
         break;

      case IDC_DISABLE_BTN:
         OnDisableClick();
         break;

      case IDC_EDIT_BTN:
         OnEditClick();
         break;
      }
   }
   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    dspDebugOut((DEB_USER6, "DsProp listview id %d code %d\n",
                 ((LPNMHDR)lParam)->code));
    HWND hList;
    LRESULT lResult;

    if (_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        EnableButtons();
        break;

    case NM_SETFOCUS:
        hList = GetDlgItem(_hPage, (int)((LPNMHDR)lParam)->idFrom);

        if (ListView_GetItemCount(hList))
        {
            int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

            if (item < 0)
            {
                // If nothing is selected, set the focus to the first item.
                //
                LV_ITEM lvi = {0};
                lvi.mask = LVIF_STATE;
                lvi.stateMask = LVIS_FOCUSED;
                lvi.state = LVIS_FOCUSED;
                ListView_SetItem(hList, &lvi);
            }
        }
        EnableButtons();
        break;

    case NM_KILLFOCUS:
        EnableButtons();
        break;

    case PSN_APPLY:
        lResult = PSNRET_NOERROR;
        if (IsDirty())
        {
            lResult = OnApply();
        }
        // Store the result into the dialog
        SetWindowLongPtr(_hPage, DWLP_MSGRESULT, (LONG_PTR)lResult);
        return lResult;
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnHelp(LPHELPINFO pHelpInfo)
{
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(_hPage, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnDestroy(void)
{
   // If an application processes this message, it should return zero.
   return 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::PageCallback
//
//  Synopsis:   Callback used to free the CDsForestNameRoutingPage object when the
//              property sheet has been destroyed.
//
//-----------------------------------------------------------------------------
UINT CALLBACK
CDsForestNameRoutingPage::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
   TRACE_FUNCTION(CDsForestNameRoutingPage::PageCallback);

   if (uMsg == PSPCB_RELEASE)
   {
      //
      // Determine instance that invoked this static function
      //
      CDsForestNameRoutingPage * pPage = (CDsForestNameRoutingPage *) ppsp->lParam;

      if (pPage->IsDirty())
      {
         // User never clicked Apply, so write name changes out now.
         //
         DWORD dwRet = pPage->WriteTDO();

         if (NO_ERROR != dwRet)
         {
            ReportError(dwRet, IDS_ERR_WRITE_FTI_TO_TDO, hDlg);
         }
      }

      delete pPage;

      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::OnEnableClick
//
//  Synopsis:  Enable the TLN. The change is not persisted until the user
//             Applies the page.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::OnEnableClick(void)
{
   TRACER(CDsForestNameRoutingPage,OnEnableClick);
   CWaitCursor Wait;

   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _TLNList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.ClearDisableFlags(i);

   SetDirty();
   CheckDomainForConflict(Wait);
   RefreshList();
   EnableButtons();
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::OnDisableClick
//
//  Synopsis:  Set the admin-disable flag on the selected TLN. The change is
//             not persisted until the user Applies the page.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::OnDisableClick(void)
{
   TRACER(CDsForestNameRoutingPage,OnDisableClick);
   CWaitCursor Wait;

   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _TLNList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.SetAdminDisable(i);

   SetDirty();
   CheckDomainForConflict(Wait);
   RefreshList();
   EnableButtons();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnEditClick
//
//  Synopsis:   The user wishes to change the state of names derived from the
//              selected TLN.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::OnEditClick(void)
{
   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _TLNList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   CEditTLNDialog EditDlg(_hPage, IDD_TLN_EDIT, _FTInfo, _CollisionInfo, this);

   INT_PTR nRet = EditDlg.DoModal(i);

   if (IDOK != nRet && IDCANCEL != nRet)
   {
      REPORT_ERROR((HRESULT)((nRet < 0) ? GetLastError() : nRet), _hPage);
   }

   if (IDOK == nRet)
   {
      CWaitCursor Wait;
      CheckDomainForConflict(Wait);
      RefreshList();
      EnableButtons();
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::WriteTDO
//
//  Synopsis:   Write the new data to the TDO.
//
//-----------------------------------------------------------------------------
DWORD
CDsForestNameRoutingPage::WriteTDO(void)
{
   TRACE(CDsForestNameRoutingPage,WriteTDO);
   NTSTATUS status;
   LSA_UNICODE_STRING TrustPartner;
   CPolicyHandle cPolicy(_strUncDC);
   CWaitCursor Wait;
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = _FTInfo.GetFTInfo();

   if (!pFTInfo)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   DWORD dwRet = cPolicy.OpenWithPrompt(_LocalCreds, Wait,
                                        _strDomainDnsName, _hPage);

   CHECK_WIN32(dwRet, return dwRet);

   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo;

   RtlInitUnicodeString(&TrustPartner, _strTrustPartnerDnsName);

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         pFTInfo,
                                         FALSE,
                                         &pColInfo);

   CHECK_LSA_STATUS(status, return LsaNtStatusToWinError(status));

   _CollisionInfo = pColInfo;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::AnyForestNameChanges
//
//  Synopsis:  Check to see if there are any differences between the two
//             sets of names. Local exception records are ignored.
//
//  Notes:     Should the NetBIOS domain names be compared? IOW, is there
//             any likelyhood of domains being able to change their NetBIOS
//             names in the future?
//-----------------------------------------------------------------------------
bool
CDsForestNameRoutingPage::AnyForestNameChanges(
                                 PLSA_FOREST_TRUST_INFORMATION pLocalFTInfo,
                                 PLSA_FOREST_TRUST_INFORMATION pRemoteFTInfo)
{
   ULONG ulNamesFound = 0;

   for (ULONG i = 0; i < pLocalFTInfo->RecordCount; i++)
   {
      CStrW strLocalName, strRemoteName;

      switch (pLocalFTInfo->Entries[i]->ForestTrustType)
      {
      case ForestTrustTopLevelNameEx:
         //
         // The remote names returned by DsGetForestTrustInformation will
         // never contain exception records.
         //
         continue;

      case ForestTrustTopLevelName:
         strLocalName = pLocalFTInfo->Entries[i]->ForestTrustData.TopLevelName;
         break;

      case ForestTrustDomainInfo:
         strLocalName = pLocalFTInfo->Entries[i]->ForestTrustData.DomainInfo.DnsName;
         break;

      default:
         dspAssert(FALSE);
         continue;
      }

      bool fFound = false;

      if (strLocalName.IsEmpty())
      {
         dspAssert(FALSE);
         continue;
      }

      for (ULONG j = 0; j < pRemoteFTInfo->RecordCount; j++)
      {
         if (pRemoteFTInfo->Entries[j]->ForestTrustType !=
             pLocalFTInfo->Entries[i]->ForestTrustType)
         {
            continue;
         }

         strRemoteName = (ForestTrustTopLevelName == pRemoteFTInfo->Entries[j]->ForestTrustType) ?
                           pRemoteFTInfo->Entries[j]->ForestTrustData.TopLevelName : 
                           pRemoteFTInfo->Entries[j]->ForestTrustData.DomainInfo.DnsName;

         if (strRemoteName.IsEmpty())
         {
            dspAssert(FALSE);
            continue;
         }

         if (strLocalName == strRemoteName)
         {
            fFound = true;
            ulNamesFound++;
            break;
         }
      }

      if (!fFound)
      {
         return true;
      }
   }

   if (ulNamesFound < pRemoteFTInfo->RecordCount)
   {
      // There are more remote names than local names.
      //
      return true;
   }

   return false;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\listview.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      listview.h
//
//  Contents:  classes for listview controls.
//
//  Classes:   CListViewBase, CTLNList, CSuffixesList
//
//  History:   01-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef LISTVIEW_H_GUARD
#define LISTVIEW_H_GUARD

//+----------------------------------------------------------------------------
//
//  Class:     CListViewBase
//
//  Purpose:   Base class for list view controls.
//
//-----------------------------------------------------------------------------
class CListViewBase
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CListViewBase(void);
   virtual ~CListViewBase(void) {};

   void  SetStyles(DWORD dwStyles, DWORD dwExtStyles);

   virtual void AddColumn(int textID, int cx, int nID);

   virtual void Init(HWND hParent, int nControlID) = 0;
   virtual void Clear(void);

protected:
   HWND     _hParent;
   HWND     _hList;
   int      _nID;
};

//+----------------------------------------------------------------------------
//
//  Class:     CTLNList
//
//  Purpose:   TLN list on the Name Suffix Routing property page.
//
//-----------------------------------------------------------------------------
class CTLNList : public CListViewBase
{
public:

   CTLNList(void);
   virtual ~CTLNList(void) {};

   void  Init(HWND hParent, int nControlID);
   void  AddItem(PCWSTR pwzName, ULONG i, PCWSTR pwzEnabled, PCWSTR pwzStatus);
   //BOOL  RmItem(LV_ITEM * pItem);
   int   GetSelection(void);
   ULONG GetFTInfoIndex(int iSel);
   //void  SetSelection(int nItem);
   void  Clear(void);

private:
   static const int IDX_SUFFIXNAME_COL = 0;
   static const int IDX_ROUTINGENABLED_COL = 1;
   static const int IDX_STATUS_COL = 2;

   int   _nItem;
};

//+----------------------------------------------------------------------------
//
//  Class:     CSuffixesList
//
//  Purpose:   TLN subnames edit dialog list.
//
//-----------------------------------------------------------------------------
class CSuffixesList : public CListViewBase
{
public:

   CSuffixesList(void);
   virtual ~CSuffixesList(void) {};

   void  Init(HWND hParent, int nControlID);
   void  AddItem(PCWSTR pwzName, ULONG i, TLN_EDIT_STATUS Status);
   void  UpdateItemStatus(int item, TLN_EDIT_STATUS Status);
   int   GetSelection(void) {return ListView_GetNextItem(_hList, -1, LVNI_ALL | LVIS_SELECTED);};
   ULONG GetFTInfoIndex(int iSel);
   //void  SetSelection(int nItem);

private:
   static const int IDX_NAME_COL = 0;
   static const int IDX_STATUS_COL = 1;

   int   _nItem;
};

#endif // LISTVIEW_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\membship.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       membship.cxx
//
//  Contents:   Membership page for showing the groups to which an object has
//              membership (a.k.a. reverse membeship).
//
//  History:    27-July-98 EricB copied from user.cxx.
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#include "user.h"
#include "group.h"
#include "qrybase.h"

void ReportNoGroupAccess(PTSTR ptzCanName, HWND hPage);

static const PWSTR g_wzMembership = L"memberOf"; // ADSTYPE_DN_STRING Multi-valued
static const PWSTR g_wzPrimaryGroup = L"primaryGroupID"; // ADSTYPE_INTEGER

//+----------------------------------------------------------------------------
//
//  Member:     CDsMembershipPage::CDsMembershipPage
//
//-----------------------------------------------------------------------------
CDsMembershipPage::CDsMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags,
                                     BOOL fSecPrinciple) :
    m_pList(NULL),
    m_pwzObjDomain(NULL),
    m_bstrDomPath(NULL),
    m_pObjSID(NULL),
    m_pPriGrpLI(NULL),
    m_dwOriginalPriGroup(0),
    m_fSecPrinciple(fSecPrinciple),
    m_fMixed(TRUE),
    m_dwGrpType(0),
    m_fPriGrpWritable(FALSE),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsMembershipPage,CDsMembershipPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsMembershipPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMembershipPage::~CDsMembershipPage
//
//-----------------------------------------------------------------------------
CDsMembershipPage::~CDsMembershipPage()
{
  TRACE(CDsMembershipPage,~CDsMembershipPage);
  DO_DEL(m_pList);
  DO_DEL(m_pwzObjDomain);
  if (m_bstrDomPath)
  {
    SysFreeString(m_bstrDomPath);
  }
  DO_DEL(m_pObjSID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMembershipPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                     PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                     DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                     HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateMembershipPage);

    CDsMembershipPage * pPageObj = new CDsMembershipPage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
    

}

//+----------------------------------------------------------------------------
//
//  Function:   CreateNonSecMembershipPage
//
//  Synopsis:   Creates an instance of a reverse membership page for non-
//              security-principles (like Contact).
//
//-----------------------------------------------------------------------------
HRESULT
CreateNonSecMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                           PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                           DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                           HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateNonSecMembershipPage);

    CDsMembershipPage * pPageObj = new CDsMembershipPage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags,
                                                         FALSE);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMembershipPage::OnInitDialog(LPARAM)
{
    TRACE(CDsMembershipPage,OnInitDialog);
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO spAttrs;
    PWSTR rgpwzAttrNames[] = {g_wzObjectSID, g_wzPrimaryGroup};
    DWORD cAttrs = 0, i;
    CWaitCursor WaitCursor;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    if (_wcsicmp(GetObjClass(), g_wzGroup) == 0)
    {
        GetGroupType(this, &m_dwGrpType);
        GetDomainMode(this, &m_fMixed);

        if (m_dwGrpType & (GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_UNIVERSAL_GROUP))
        {
            // If a Global or Universal group, it can be a member of an
            // external, uplevel domain, for which we need the SID.
            //
            cAttrs = 1;
        }
    }

    if (m_fSecPrinciple)
    {
        cAttrs = 2;
    }

    //
    // Initialize the membership list.
    //
    m_pList = new CDsMembershipList(m_hPage, IDC_MEMBER_LIST);

    CHECK_NULL_REPORT(m_pList, m_hPage, return S_OK);

    hr = m_pList->Init();

    CHECK_HRESULT(hr, return S_OK);

    if (cAttrs)
    {
        //
        // Get the SID and perhaps the Primary Group attribute values.
        //
        hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, cAttrs, &spAttrs, &cAttrs);

        if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
        {
            return S_OK;
        }

        for (i = 0; i < cAttrs; i++)
        {
            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzPrimaryGroup) == 0)
            {
                m_dwOriginalPriGroup = spAttrs[i].pADsValues->Integer;

                continue;
            }

            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzObjectSID) == 0)
            {
                m_pObjSID = new BYTE[spAttrs[i].pADsValues->OctetString.dwLength];

                CHECK_NULL_REPORT(m_pObjSID, m_hPage, return S_OK);

                memcpy(m_pObjSID, spAttrs[i].pADsValues->OctetString.lpValue,
                       spAttrs[i].pADsValues->OctetString.dwLength);
            }
        }
    }

    if (m_fSecPrinciple)
    {
        m_fPriGrpWritable = CheckIfWritable(g_wzPrimaryGroup);

        PWSTR pwzPath;

        hr = GetDomainScope(this, &m_bstrDomPath);

        CHECK_HRESULT(hr, return S_OK);
        dspDebugOut((DEB_ITRACE, "Object's domain: %ws\n", m_bstrDomPath));

        if (m_dwOriginalPriGroup)
        {
            PTSTR ptzName, ptzCanEx;
            PWSTR pwzCanEx, pwzCleanDN;

            hr = ConvertRIDtoName(m_dwOriginalPriGroup, &ptzName, &pwzPath);

            if (hr == S_FALSE)
            {
                // No group found, must have been deleted.
                //
                m_dwOriginalPriGroup = 0;
                goto SetBtns;
            }
            CHECK_HRESULT(hr, return S_OK);

            SetDlgItemText(m_hPage, IDC_PRI_GRP_STATIC, ptzName);
        
            hr = SkipPrefix(pwzPath, &pwzCleanDN);

            delete pwzPath;
            CHECK_HRESULT_REPORT(hr, m_hPage, return S_OK);

            hr = CrackName(pwzCleanDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_hPage);

            CHECK_HRESULT(hr, delete pwzCleanDN; return S_OK);

            if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
            {
                delete pwzCleanDN;
                LocalFreeStringW(&pwzCanEx);
                hr = E_OUTOFMEMORY;
                REPORT_ERROR(hr, m_hPage);
                return S_OK;
            }
            LocalFreeStringW(&pwzCanEx);

            CMemberListItem * pListItem;

            pListItem = new CMemberListItem;

            CHECK_NULL_REPORT(pListItem, m_hPage, return S_OK);

            pListItem->m_pwzDN = pwzCleanDN;
            pListItem->m_fIsPrimary = TRUE;
            pListItem->m_ptzName = ptzCanEx;
            pListItem->m_fIsAlreadyMember = TRUE;

            hr = m_pList->InsertIntoList(ptzCanEx, pListItem);

            if (FAILED(hr))
            {
                delete pListItem;
                delete ptzCanEx;
                return S_OK;
            }

            m_pPriGrpLI = pListItem;
        }
        if (!m_fPriGrpWritable)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);
        }
    }
    else
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_LABEL), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GROUP_WARN_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_DIVIDING_LINE), SW_HIDE);
        if (_wcsicmp(GetObjClass(), g_wzGroup) == 0)
        {
            ShowWindow(GetDlgItem(m_hPage, IDC_GROUP_NOTE_STATIC), SW_SHOW);

            if ((m_dwGrpType & GROUP_TYPE_BUILTIN_LOCAL_GROUP) ||
                (m_dwGrpType & GROUP_TYPE_RESOURCE_GROUP))
            {
                if (m_dwGrpType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                    // Since builtin groups cannot be added to other groups,
                    // disable the add button and add a note to that effect.
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BTN), FALSE);
                }

                PTSTR ptz;

                if (!LoadStringToTchar((m_dwGrpType & GROUP_TYPE_BUILTIN_LOCAL_GROUP) ?
                                       IDS_BUILTIN_NO_NEST : IDS_LOCAL_GROUP_ONLY,
                                       &ptz))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                    return S_OK;
                }

                SetDlgItemText(m_hPage, IDC_GROUP_NOTE_STATIC, ptz);

                delete ptz;
            }
        }
    }

SetBtns:
    EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);

    hr = FillMembershipList();

    //Set the focus on first item in the list
    ListView_SetItemState(GetDlgItem(m_hPage, IDC_MEMBER_LIST), 0,
                          LVIS_SELECTED,LVIS_SELECTED);


    CHECK_HRESULT(hr, return S_OK);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnApply(void)
{
    TRACE(CDsMembershipPage,OnApply);
    HRESULT hr = S_OK;
    IDirectoryObject * pIADObj = NULL;
    IADsGroup * pIADGroup = NULL;
    IUnknown * pUnknown;
    ADSVALUE PriGrpValue = {ADSTYPE_INTEGER, 0};
    PADSVALUE pPriGrpValues = &PriGrpValue;
    ADS_ATTR_INFO PriGrpInfo = {g_wzPrimaryGroup, ADS_ATTR_UPDATE,
                                ADSTYPE_INTEGER, pPriGrpValues, 1};
    ADSVALUE MemberValue = {ADSTYPE_DN_STRING, NULL};
    PADSVALUE pMemberValues = &MemberValue;
    ADS_ATTR_INFO MemberInfo = {g_wzMemberAttr, ADS_ATTR_APPEND,
                                ADSTYPE_DN_STRING, pMemberValues, 1};
    PADS_ATTR_INFO pAttr = &MemberInfo;
    DWORD cModified;
    BOOL fBindFailed;
    CWaitCursor WaitCursor;

    //
    // Read the list of groups and do additions. Note that additions must be
    // done before setting primary which in turn must be done before deletions.
    //
    int i = 0, cGroups = m_pList->GetCount();
    CMemberListItem * pItem, * pPriGrp = NULL;
    CSmartWStr csCleanObjName;
    CStrW strSIDname, strNT4name;

    hr = SkipPrefix(m_pwszObjPathName, &csCleanObjName);

    CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

    if (cGroups > 0)
    {
        while (i < cGroups)
        {
            if (FAILED(m_pList->GetItem(i, &pItem)))
            {
                dspAssert(FALSE && "List Error");
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
            if (!pItem)
            {
                dspAssert(pItem);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (pItem->m_fIsPrimary)
            {
                pPriGrp = pItem;
            }

            if (pItem->m_fIsAlreadyMember)
            {
                i++;
                continue;
            }

            dspAssert(pItem->m_pwzDN);

            hr = BindToGroup(pItem, TRUE, &pUnknown, &fBindFailed);

            if (fBindFailed)
            {
                // Error not reported in BindToGroup.
                //
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_hPage);
                    m_pList->RemoveListItem(i);
                    cGroups--;
                    hr = S_OK;
                    continue;
                }
                if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr ||
                    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
                {
                    dspDebugOut((DEB_ERROR, "group open failed with error 0x%x\n", hr));
                    ReportNoGroupAccess(pItem->m_ptzName, m_hPage);
                    m_pList->RemoveListItem(i);
                    cGroups--;
                    hr = S_OK;
                    continue;
                }
                REPORT_ERROR(hr, m_hPage);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (FAILED(hr))
            {
                // Error was reported in BindToGroup.
                //
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == pItem->m_ulScopeType)
            {
                if (strNT4name.IsEmpty())
                {
                    // Convert this group's name to NT4 style and then do the
                    // add using the WINNT provider.
                    //
                    PWSTR pwzGrpNT4name;

                    hr = CrackName(csCleanObjName, &pwzGrpNT4name, GET_OBJ_NT4_NAME, m_hPage);

                    CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                    // Make the NT path an ADSI path. The path cracker doesn't
                    // work for WINNT provider paths.
                    //
                    PWSTR pwzSlash = wcschr(pwzGrpNT4name, L'\\');

                    if (pwzSlash)
                    {
                        *pwzSlash = L'/';
                    }

                    strNT4name = g_wzWINNTPrefix;
                    strNT4name += pwzGrpNT4name;

                    LocalFreeStringW(&pwzGrpNT4name);
                }

                dspDebugOut((DEB_ITRACE, "Adding this group as %ws\n", const_cast<LPWSTR>((LPCWSTR)strNT4name)));

                pIADGroup = (IADsGroup *)pUnknown;

                hr = pIADGroup->Add(const_cast<LPWSTR>((LPCWSTR)strNT4name));

                DO_RELEASE(pIADGroup);
            }
            else
            {
                if (DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN == pItem->m_ulScopeType)
                {
                    // Convert this group's SID to string form.
                    //
                    if (strSIDname.IsEmpty())
                    {
                        dspAssert(m_pObjSID);
                        if (!m_pObjSID)
                        {
                            continue;
                        }

                        ConvertSidToPath(m_pObjSID, strSIDname);
                    }

                    MemberValue.DNString = const_cast<LPWSTR>((LPCWSTR)strSIDname);
                }
                else
                {
                    MemberValue.DNString = csCleanObjName;
                }

                dspDebugOut((DEB_ITRACE, "Adding this group as %ws\n", MemberValue.DNString));

                pIADObj = (IDirectoryObject *)pUnknown;

                hr = pIADObj->SetObjectAttributes(pAttr, 1, &cModified);

                DO_RELEASE(pIADObj);
            }

            if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr ||
                HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                dspDebugOut((DEB_ERROR, "group add failed with error 0x%x\n", hr));
                ReportNoGroupAccess(pItem->m_ptzName, m_hPage);
                m_pList->RemoveListItem(i);
                cGroups--;
                hr = S_OK;
                continue;
            }
            if (!CheckGroupUpdate(hr, m_hPage))
            {
                m_pList->RemoveListItem(i);
                cGroups--;
                continue;
            }

            pItem->m_fIsAlreadyMember = TRUE;

            i++;
        }
    }

    //
    // Set the primary group.
    //
    if (pPriGrp)
    {
        Smart_PADS_ATTR_INFO spAttrs;
        PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
        DWORD cAttrs = 0;
        PSID pGroupSID = NULL;
        PUCHAR saCount;
        PULONG pGroupRID;

        if (!pPriGrp->IsSidSet())
        {
            CStrW strADsPath;

            hr = AddLDAPPrefix(pPriGrp->m_pwzDN, strADsPath);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            hr = ADsOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), NULL,
                               NULL, ADS_SECURE_AUTHENTICATION,
                               IID_IDirectoryObject, (PVOID *)&pIADObj);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            hr = pIADObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

            DO_RELEASE(pIADObj);
            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            dspAssert(spAttrs);

            pGroupSID = spAttrs->pADsValues->OctetString.lpValue;

            if (!IsValidSid(pGroupSID))
            {
                REPORT_ERROR(E_FAIL, m_hPage);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (!pPriGrp->SetSid(pGroupSID))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
        }
        else
        {
            pGroupSID = pPriGrp->GetSid();
        }

        // find RID part of SID
        //
        saCount = GetSidSubAuthorityCount(pGroupSID);
        pGroupRID = GetSidSubAuthority(pGroupSID, (ULONG)*saCount - 1);

        //        if ((m_dwOriginalPriGroup != *pGroupRID) && m_fPriGrpWritable)
        if (m_fPriGrpWritable)
        {
            PriGrpValue.Integer = *pGroupRID;

            pAttr = &PriGrpInfo;

            //
            // Write the changed primary group.
            //
            hr = m_pDsObj->SetObjectAttributes(pAttr, 1, &cModified);

            if (!CheckGroupUpdate(hr, m_hPage))
            {
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);
        }
    }

    //
    // Do the removals.
    //
    CMemberListItem * pDelItem = m_DelList.RemoveFirstItem();

    while (pDelItem)
    {
        PWSTR pwzItem = NULL;

        hr = BindToGroup(pDelItem, FALSE, (IUnknown **)&pIADGroup, &fBindFailed);

        if (fBindFailed)
        {
            WaitCursor.SetOld();
            //
            // Error not reported in BindToGroup.
            //
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_hPage);
                delete pDelItem;
                pDelItem = m_DelList.RemoveFirstItem();
                hr = S_OK;
                continue;
            }
            REPORT_ERROR(hr, m_hPage);
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

        if (FAILED(hr))
        {
            WaitCursor.SetOld();
            //
            // Error was reported in BindToGroup.
            //
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

        CStrW strADPath;

        if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == pDelItem->m_ulScopeType)
        {
            if (strNT4name.IsEmpty())
            {
                // Convert this group's name to NT4 style and then do the
                // remove using the WINNT provider.
                //
                PWSTR pwzGrpNT4name;

                hr = CrackName(csCleanObjName, &pwzGrpNT4name, GET_OBJ_NT4_NAME, m_hPage);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                // Make the NT path an ADSI path. The path cracker doesn't
                // work for WINNT provider paths.
                //
                PWSTR pwzSlash = wcschr(pwzGrpNT4name, L'\\');

                if (pwzSlash)
                {
                    *pwzSlash = L'/';
                }

                strNT4name = g_wzWINNTPrefix;
                strNT4name += pwzGrpNT4name;

                LocalFreeStringW(&pwzGrpNT4name);
            }

            pwzItem = const_cast<LPWSTR>((LPCWSTR)strNT4name);
        }
        else
        {
            if (DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN == pDelItem->m_ulScopeType)
            {
                // Find the FPO DN for this group.
                //
                CComBSTR cbstrDomain;
                CStrW strFPO, strDC;

                hr = GetObjectsDomain(this, pDelItem->m_pwzDN, &cbstrDomain);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                dspAssert(m_pObjSID);

                hr = FindFPO(m_pObjSID, cbstrDomain, strFPO);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                hr = GetLdapServerName(pIADGroup, strDC);

                strADPath = g_wzLDAPPrefix;
                strADPath += strDC;
                strADPath += L"/";
                strADPath += strFPO;

                pwzItem = const_cast<LPWSTR>((LPCWSTR)strADPath);
            }
            else
            {
                pwzItem = m_pwszObjPathName;
            }
        }

        dspDebugOut((DEB_ITRACE, "Removing member: %S from group %S\n",
                     pwzItem, pDelItem->m_pwzDN));

        hr = pIADGroup->Remove(pwzItem);

        DO_RELEASE(pIADGroup);
        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            WaitCursor.SetOld();
            ReportNoGroupAccess(pDelItem->m_ptzName, m_hPage);
        }
        else
        {
            CheckGroupUpdate(hr, m_hPage, FALSE, pDelItem->m_pwzDN);
        }
        hr = S_OK;

        delete pDelItem;

        pDelItem = m_DelList.RemoveFirstItem();
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify == BN_CLICKED)
    {
        if (id == IDC_ADD_BTN)
        {
            InvokeGroupQuery();
        }
        if (id == IDC_RM_GRP_BTN)
        {
            RemoveMember();
        }
        if (id == IDC_PRI_GRP_BTN)
        {
            SetPrimaryGroup();
        }
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnNotify
//
//  Synopsis:   Handles list notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), TRUE);
        if (m_fPriGrpWritable && m_pList->GetSelectedCount() == 1)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN),
                         SelectionCanBePrimaryGroup());
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN),
                         FALSE);
        }

        break;

    case NM_DBLCLK:
        //
        // Display properties for the selected item. First, find out
        // which item is selected.
        //
        CMemberListItem * pItem;

        if (!m_pList->GetCurListItem(NULL, NULL, &pItem))
        {
            break;
        }

        dspAssert(pItem);

        if (pItem->m_ulScopeType & DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN)
        {
          //
          // We cannot show the properties for downlevel users
          //
          // Put a useful message up
          PTSTR ptzTitle, ptzMsg;
          if (!LoadStringToTchar(IDS_MSG_NO_DOWNLEVEL_PROPERTIES, &ptzMsg))
          {
            break;
          }
          if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
          {
            break;
          }
          MessageBox(m_hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
          delete[] ptzTitle;
          delete[] ptzMsg;

          break;
        }
        PostPropSheet(pItem->m_pwzDN, this);
        break;
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnDestroy(void)
{
    if (m_pList)
    {
        m_pList->ClearList();
    }

    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::FillMembershipList
//
//  Synopsis:   Read the membership attribute and fill the list view control.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::FillMembershipList(void)
{
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD i, cAttrs = 0;
    WCHAR wzMembershipAttr[MAX_PATH] = L"memberOf;range=0-*";
    const WCHAR wcSep = L'-';
    const WCHAR wcEnd = L'*';
    const WCHAR wzFormat[] = L"memberOf;range=%ld-*";
    BOOL fMoreRemain = FALSE;
    PWSTR rgpwzAttrNames[] = {wzMembershipAttr};
    //
    // Read the membership list from the object. First read the attribute off
    // of the actual object which will give all memberships in the object's
    // domain (including local groups which are not replicated to the GC).
    //
    do
    {
      hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

      if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
      {
          return hr;
      }

      if (cAttrs > 0 && spAttrs != NULL)
      {
        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            hr = m_pList->InsertIntoNewList(spAttrs->pADsValues[i].CaseIgnoreString);

            CHECK_HRESULT(hr, break);
        }
        //
        // Check to see if there is more data. If the last char of the
        // attribute name string is an asterisk, then we have everything.
        //
        size_t cchEnd = wcslen(spAttrs->pszAttrName);

        fMoreRemain = spAttrs->pszAttrName[cchEnd - 1] != wcEnd;

        if (fMoreRemain)
        {
            PWSTR pwz = wcsrchr(spAttrs->pszAttrName, wcSep);
            if (!pwz)
            {
                dspAssert(FALSE && spAttrs->pszAttrName);
                fMoreRemain = FALSE;
            }
            else
            {
                pwz++; // move past the hyphen to the range end value.
                dspAssert(*pwz);
                long lEnd = _wtol(pwz);
                lEnd++; // start with the next value.
                wsprintfW(wzMembershipAttr, wzFormat, lEnd);
                dspDebugOut((DEB_ITRACE,
                             "Range returned is %ws, now asking for %ws\n",
                             spAttrs->pszAttrName, wzMembershipAttr));
            }
        }
      }
    } while (fMoreRemain);

    if (m_pList->GetCount() < 1)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), FALSE);
    }

    //
    // If a group, but not a local group, then bind to the GC copy of the
    // object in order to obtain the universal group memberships outside of the
    // object's domain (and discard duplicates from the object's domain).
    //
    if (_wcsicmp(GetObjClass(), g_wzGroup) == 0 &&
        !(m_dwGrpType & GROUP_TYPE_RESOURCE_GROUP))
    {
        CComPtr <IDirectoryObject> spGcObj;
        spAttrs.Empty();

        hr = BindToGCcopyOfObj(this, m_pwszObjPathName, &spGcObj);

        if (SUCCEEDED(hr))
        {
            hr = spGcObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);
        }
        else
        {
            switch (hr)
            {
            case HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND):
            case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
                MsgBox(IDS_MEMBERSHIP_OBJ_NOT_IN_GC, m_hPage);
                return S_OK;

            case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
                MsgBox(IDS_NO_GC_FOR_MEMBERSHIP, m_hPage);
                return S_OK;

            default:
                {
                DWORD dwErr;
                WCHAR wszErrBuf[MAX_PATH+1];
                WCHAR wszNameBuf[MAX_PATH+1];

                ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

                if (SEC_E_LOGON_DENIED == dwErr)
                {
                    MsgBox(IDS_NO_ACCESS_GC_FOR_MEMBERSHIP, m_hPage);
                    return S_OK;
                }
                else
                {
                    if (dwErr)
                    {
                        dspDebugOut((DEB_ERROR,
                                     "Extended Error 0x%x: %ws %ws <%s @line %d>.\n",
                                     dwErr, wszErrBuf, wszNameBuf, __FILE__, __LINE__));
                        ReportError(dwErr, IDS_ADS_ERROR_FORMAT, m_hPage);
                    }
                    else
                    {
                        dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n",
                                     hr, __FILE__, __LINE__));
                        ReportError(hr, IDS_ADS_ERROR_FORMAT, m_hPage);
                    }
                }
                return hr;
                }
            }
        }

        if (cAttrs == 0 || spAttrs == NULL)
        {
            return S_OK;
        }

        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            hr = m_pList->MergeIntoList(spAttrs->pADsValues[i].CaseIgnoreString);

            CHECK_HRESULT(hr, break);
        }
    }

    if (m_pList->GetCount() < 1)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), FALSE);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::InvokeGroupQuery
//
//  Synopsis:   Bring up the query dialog to search for groups.
//
//-----------------------------------------------------------------------------
void CDsMembershipPage::InvokeGroupQuery(void)
{
  HRESULT hr;
  CSmartWStr swzCleanDN;
  UINT i;
  CComBSTR cbstrDomain;
  CWaitCursor WaitCursor;

  hr = GetDomainScope(this, &cbstrDomain);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  IDsObjectPicker * pObjSel;
  BOOL fIsObjSelInited;

  hr = GetObjSel(&pObjSel, &fIsObjSelInited);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  if (!fIsObjSelInited)
  {
    CStrW strDC;
    hr = GetLdapServerName(m_pDsObj, strDC);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);
    dspDebugOut((DEB_ITRACE, "ObjSel targetted to %ws\n", (LPCWSTR)strDC));

    DSOP_SCOPE_INIT_INFO rgScopes[5];
    DSOP_INIT_INFO InitInfo;

    ZeroMemory(rgScopes, sizeof(rgScopes));
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    // The first scope is the local domain.
    //
    rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
    rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;
    rgScopes[0].pwzDcName = strDC;

    // The second scope is the local forest.
    //
    rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    rgScopes[1].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    // The third scope is the GC.
    //
    rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[2].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    rgScopes[2].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    // The fourth scope is uplevel external trusted domains.
    //
    rgScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
    rgScopes[3].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    // The fifth scope is downlevel external trusted domains.
    //
    rgScopes[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[4].flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
    rgScopes[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    if ((_wcsicmp(GetObjClass(), g_wzContact) == 0) ||
        (_wcsicmp(GetObjClass(), g_wzUser) == 0) ||
        (_wcsicmp(GetObjClass(), g_wzComputer) == 0)
#ifdef INETORGPERSON
        || (_wcsicmp(GetObjClass(), g_wzInetOrgPerson) == 0)
#endif
        )
    {
        // The membership list for non-groups only shows group
        // memberships from the object's local domain. Thus, we
        // only show the local domain scope in the object picker.
        //
        InitInfo.cDsScopeInfos = 1;
        rgScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
            DSOP_FILTER_GLOBAL_GROUPS_DL       |
            DSOP_FILTER_GLOBAL_GROUPS_SE       |
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
            DSOP_FILTER_BUILTIN_GROUPS;
        rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
            DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }
    else if (_wcsicmp(GetObjClass(), g_wzFPO) == 0)
    {
        // FPOs can only be members of local groups.
        //
        InitInfo.cDsScopeInfos = 1;
        rgScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
            DSOP_FILTER_BUILTIN_GROUPS;
        //rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
        //    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }
    else if (_wcsicmp(GetObjClass(), g_wzGroup) == 0)
    {
        // The membership list for groups only shows group memberships
        // from the object's local domain and from universal groups in
        // the forest. However, we show all permissible scopes in the
        // object picker.
        //
        switch (m_dwGrpType & (~GROUP_TYPE_SECURITY_ENABLED))
        {
        case GROUP_TYPE_ACCOUNT_GROUP: // Global group
            rgScopes[0].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                DSOP_FILTER_GLOBAL_GROUPS_DL       |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
                DSOP_FILTER_GLOBAL_GROUPS_SE;
            if (!m_fMixed)
            {
                rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
                    DSOP_FILTER_GLOBAL_GROUPS_SE |
                    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
                rgScopes[1].FilterFlags.Uplevel.flNativeModeOnly =
                rgScopes[2].FilterFlags.Uplevel.flNativeModeOnly =
                    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
            }
            rgScopes[3].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            if (m_dwGrpType & GROUP_TYPE_SECURITY_ENABLED)
            {
                rgScopes[4].FilterFlags.flDownlevel =
                    DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;
                InitInfo.cDsScopeInfos = 5; // all trusted domains.
            }
            else
            {                               // no downlevel domains for
                InitInfo.cDsScopeInfos = 4; // global distribution groups.
            }
            break;

        case GROUP_TYPE_RESOURCE_GROUP: // Local group.
            InitInfo.cDsScopeInfos = 1; // Only the local domain scope.
            rgScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL;
            rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
            break;

        case GROUP_TYPE_UNIVERSAL_GROUP:
            InitInfo.cDsScopeInfos = 4; // No downlevel external domains.
            rgScopes[0].FilterFlags.Uplevel.flBothModes =
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            if (!m_fMixed)
            {
                rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
                rgScopes[1].FilterFlags.Uplevel.flNativeModeOnly =
                rgScopes[2].FilterFlags.Uplevel.flNativeModeOnly =
                    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
            }
            rgScopes[3].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            break;
        }
    }
    else
    {
      // any other object class

      // set all the scopes to get all we can
      InitInfo.cDsScopeInfos = 5; 

      rgScopes[0].FilterFlags.Uplevel.flBothModes =
      rgScopes[1].FilterFlags.Uplevel.flBothModes =
      rgScopes[2].FilterFlags.Uplevel.flBothModes =
      rgScopes[3].FilterFlags.Uplevel.flBothModes =
      rgScopes[4].FilterFlags.Uplevel.flBothModes =
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW  |
          DSOP_FILTER_BUILTIN_GROUPS         |
          DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
          DSOP_FILTER_UNIVERSAL_GROUPS_SE    |
          DSOP_FILTER_GLOBAL_GROUPS_DL       |
          DSOP_FILTER_GLOBAL_GROUPS_SE       |
          DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
          DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    }

    InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
    InitInfo.aDsScopeInfos = rgScopes;
    InitInfo.pwzTargetComputer = strDC;
    InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

    hr = pObjSel->Initialize(&InitInfo);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    ObjSelInited();
  }

  IDataObject * pdoSelections = NULL;

  hr = pObjSel->InvokeDialog(m_hPage, &pdoSelections);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  if (hr == S_FALSE || !pdoSelections)
  {
    return;
  }

  CSmartWStr swzCleanGroup;
  CStr strWinNtName;
  FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

  hr = pdoSelections->GetData(&fmte, &medium);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

  if (!pSelList)
  {
    goto ExitCleanup;
  }

  WaitCursor.SetWait();

  // See if this object is a group. If so, don't allow it to be added to
  // itself.
  //
  if (_wcsicmp(m_pwszObjClass, g_wzGroup) == 0)
  {
    // Clean the group name so it can be compared with those returned by the
    // user's selection.
    //
    hr = SkipPrefix(m_pwszObjPathName, &swzCleanGroup);

    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);
  }

  for (i = 0 ; i < pSelList->cItems; i++)
  {
      if (!pSelList->aDsSelection[i].pwzADsPath) continue;

      BOOL fExternal = FALSE;

      //
      // See if the group is from an external domain and flag it if so.
      //
      if (pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
      {
          fExternal = TRUE;
      }

      if (pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN)
      {
          fExternal = TRUE;
          hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &swzCleanDN, FALSE);
      }
      else
      {
          hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &swzCleanDN);
      }

      CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

      if ((BOOL)swzCleanGroup)
      {
          // See if the user is trying to add the group to itself.
          //
          if (_wcsicmp(swzCleanDN, swzCleanGroup) == 0)
          {
              if (pSelList->cItems == 1)
              {
                  ErrMsg(IDS_ERROR_GRP_SELF, m_hPage);
                  goto ExitCleanup;
              }
              continue;
          }
      }
      //
      // Check if the item is in the delete list, if so remove it.
      //
      CMemberListItem * pItem;

      pItem = m_DelList.FindItemRemove(swzCleanDN);

      if (pItem)
      {
          hr = m_pList->InsertIntoList(pItem);
      }
      else
      {
          if (fExternal)
          {
              hr = m_pList->InsertExternalIntoList(swzCleanDN,
                                                   pSelList->aDsSelection[i].flScopeType);
          }
          else
          {
              hr = m_pList->InsertIntoList(swzCleanDN);
          }
      }

      if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
      {
          continue;
      }
      CHECK_HRESULT(hr, goto ExitCleanup);
  }

  SetDirty();
ExitCleanup:
  GlobalUnlock(medium.hGlobal);
  ReleaseStgMedium(&medium);
  pdoSelections->Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::RemoveMember
//
//  Synopsis:   Remove the user from the currently selected group.
//
//-----------------------------------------------------------------------------
void
CDsMembershipPage::RemoveMember(void)
{
    if (!m_pList)
    {
        return;
    }
    int* pIndex;
    CMemberListItem ** ppItem;
    int nSelected = 0;

    //
    // Compose the confirmation message and post it.
    //
    PTSTR ptzMsg = NULL, ptzUserName = NULL;

    if (!UnicodeToTchar(m_pwszRDName, &ptzUserName))
    {
        return;
    }

    TCHAR szMsgFormat[160];
    if (!LoadStringReport(IDS_RM_USR_FROM_GRP, szMsgFormat, 160, m_hPage))
    {
        delete ptzUserName;
        return;
    }

    size_t len = _tcslen(szMsgFormat) + _tcslen(ptzUserName);

    ptzMsg = new TCHAR[len + 1];
    CHECK_NULL_REPORT(ptzMsg, m_hPage, delete ptzUserName; return;);
    wsprintf(ptzMsg, szMsgFormat, ptzUserName);

    DO_DEL(ptzUserName);

    TCHAR szTitle[80];
    if (!LoadStringReport(IDS_RM_USR_TITLE, szTitle, 80, m_hPage))
    {
        delete[] ptzMsg;
        return;
    }

    LONG iRet;
    iRet = MessageBox(m_hPage, ptzMsg, szTitle, MB_YESNO | MB_ICONWARNING|MB_DEFBUTTON2);
    if (ptzMsg)
    {
       delete[] ptzMsg;
       ptzMsg = 0;
    }

    if (iRet == IDNO)
    {
        //
        // The user declined, so go home.
        //
        return;
    }

    CWaitCursor cWait;
    
    if (!m_pList->GetCurListItems(&pIndex, NULL, &ppItem, &nSelected))
    {
        return;
    }

    for (int idx = 0; idx < nSelected; idx++)
    {
      if (!ppItem[idx])
      {
          delete[] pIndex;
          delete[] ppItem;
          return;
      }

      if (ppItem[idx]->IsPrimary())
      {
          ErrMsg(IDS_RM_PRI_GRP, m_hPage);
          continue;
      }

      //
      // Put the item into the delete list and remove it from the list box.
      //
      if (!m_DelList.AddItem(ppItem[idx]))
      {
          REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
          delete[] pIndex;
          delete[] ppItem;
          return;
      }

      m_pList->RemoveListItem(pIndex[idx]);

      for (int idx2 = idx; idx2 < nSelected; idx2++)
      {
        if (pIndex[idx2] > pIndex[idx])
        {
          pIndex[idx2]--;
        }
      }

      SetDirty();
    }
    //
    // Disable the Remove button, since nothing in the list box should have
    // the selection at this point.
    //
    //Since Remove Button has focus now, set focus to add button
    //before disabling
    SetFocus(GetDlgItem(m_hPage,IDC_ADD_BTN));
    EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), FALSE);

    delete[] pIndex;
    delete[] ppItem;

}


//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::SelectionCanBePrimaryGroup
//
//  Synopsis:   Evaluate the current selection and return true if
//              is a candidate for primary group (i.e. is it in the
//              same domain as the user object and is a security-enabled
//              account (global) or universal type?)
//
//-----------------------------------------------------------------------------
BOOL
CDsMembershipPage::SelectionCanBePrimaryGroup(void)
{
    if (!m_pObjSID || !m_pList)
    {
        return FALSE;
    }
    HRESULT hr;
    Smart_PADS_ATTR_INFO spAttrs;
    PWSTR rgpwzAttrNames[] = {g_wzGroupType, g_wzObjectSID};
    DWORD cAttrs = 0;
    PSID pGroupSID = NULL;
    CComPtr <IDirectoryObject> pGroup;

    CMemberListItem * pItem;

    if (!m_pList->GetCurListItem(NULL, NULL, &pItem))
    {
        return FALSE;
    }

    if (!pItem)
    {
        REPORT_ERROR(E_FAIL, m_hPage);
        return FALSE;
    }

    if (pItem->IsPrimary())
    {
        // Item already primary group.
        //
        return FALSE;
    }

    if (!pItem->IsSidSet() || !pItem->IsCanBePrimarySet())
    {
        CStrW strADsPath;
        //
        // If either is unset, get both. Note that this is checked here (on
        // demand, so to speak) rather than at list filling time because to
        // have to bind to each group member at that point would significantly
        // slow list filling.
        //
        hr = AddLDAPPrefix(pItem->m_pwzDN, strADsPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE);

        hr = ADsOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), NULL, NULL,
                           ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject,
                           (PVOID *)&pGroup);

        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_hPage);
            return FALSE;
        }
        if (hr == 0x80070051)
        {
            // On subsequent network failures, ADSI returns this error code which
            // is not documented anywhere. I'll turn it into a documented error
            // code which happens to be the code returned on the first failure.
            //
            hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
        }
        if (hr == HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP))
        {
            ErrMsg(IDS_ERRMSG_NO_DC_RESPONSE, m_hPage);
            return FALSE;
        }
        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE);

        hr = pGroup->GetObjectAttributes(rgpwzAttrNames, 2, &spAttrs, &cAttrs);

        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE);

        dspAssert(cAttrs == 2 && spAttrs && spAttrs[0].pADsValues && spAttrs[1].pADsValues);

        for (DWORD i = 0; i < 2; i++)
        {
            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzGroupType) == 0)
            {
                if ((spAttrs[i].pADsValues->Integer & GROUP_TYPE_SECURITY_ENABLED) &&
                    (spAttrs[i].pADsValues->Integer & (GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_UNIVERSAL_GROUP)))
                {
                    pItem->SetCanBePrimary(TRUE);
                }
                else
                {
                    pItem->SetCanBePrimary(FALSE);
                }
                continue;
            }
            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzObjectSID) == 0)
            {
                pGroupSID = spAttrs[i].pADsValues->OctetString.lpValue;

                if (!IsValidSid(pGroupSID))
                {
                    REPORT_ERROR(E_FAIL, m_hPage);
                    return FALSE;
                }

                if (!pItem->SetSid(pGroupSID))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                    return FALSE;
                }
                continue;
            }
        }
    }
    else
    {
        pGroupSID = pItem->GetSid();
    }

    return(EqualPrefixSid(pGroupSID, m_pObjSID) && pItem->CanBePrimary());
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::SetPrimaryGroup
//
//  Synopsis:   Designate currently selected group as the primary.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::SetPrimaryGroup(void)
{
    HRESULT hr;
    IDirectoryObject * pGroup = NULL;
    Smart_PADS_ATTR_INFO spAttrs;
    PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
    DWORD cAttrs = 0;
    PSID pGroupSID = NULL;

    CMemberListItem* pItem = NULL;
    CSmartPtr <TCHAR> sptzName;

    if (!m_pList->GetCurListItem(NULL, &sptzName, &pItem))
    {
        return E_FAIL;
    }

    if (!pItem)
    {
        REPORT_ERROR(E_FAIL, m_hPage);
        return E_FAIL;
    }

    if (pItem->IsPrimary())
    {
        // It is already set, nothing to do.
        //
        return S_OK;
    }

    if (!pItem->IsSidSet())
    {
        CStrW strADsPath;

        hr = AddLDAPPrefix(pItem->m_pwzDN, strADsPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE;);

        hr = ADsOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), NULL, NULL,
                           ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject,
                           (PVOID *)&pGroup);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = pGroup->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);
        DO_RELEASE(pGroup);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        pGroupSID = spAttrs->pADsValues->OctetString.lpValue;

        if (!IsValidSid(pGroupSID))
        {
            REPORT_ERROR(E_FAIL, m_hPage);
            return E_FAIL;
        }

        if (!pItem->SetSid(pGroupSID))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        pGroupSID = pItem->GetSid();
    }

    if (m_pPriGrpLI)
    {
        m_pPriGrpLI->m_fIsPrimary = FALSE;
    }

    pItem->m_fIsPrimary = TRUE;

    m_pPriGrpLI = pItem;

    // Update the text field that displays the prim. group.
    //
    SetDlgItemText(m_hPage, IDC_PRI_GRP_STATIC, sptzName);

    SetDirty();

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::ConvertRIDtoName
//
//  Synopsis:   Convert the RID to the object DN.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::ConvertRIDtoName(DWORD priGroupRID, PTSTR * pptzName,
                                    PWSTR * ppwzDN)
{
    if (!m_pObjSID)
    {
        return E_FAIL;
    }
    HRESULT hr = S_OK;
    UCHAR * psaCount, i;
    PSID pSID = NULL;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD rgRid[8];

    psaCount = GetSidSubAuthorityCount(m_pObjSID);

    if (psaCount == NULL)
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    dspAssert(*psaCount <= 8);
    if (*psaCount > 8)
    {
        return E_FAIL;
    }

    for (i = 0; i < (*psaCount - 1); i++)
    {
        PDWORD pRid = GetSidSubAuthority(m_pObjSID, (DWORD)i);
        if (pRid == NULL)
        {
            REPORT_ERROR(GetLastError(), m_hPage);
            return HRESULT_FROM_WIN32(GetLastError());
        }
        rgRid[i] = *pRid;
    }

    rgRid[*psaCount - 1] = priGroupRID;

    for (i = *psaCount; i < 8; i++)
    {
        rgRid[i] = 0;
    }

    psia = GetSidIdentifierAuthority(m_pObjSID);

    if (psia == NULL)
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                                  rgRid[2], rgRid[3], rgRid[4],
                                  rgRid[5], rgRid[6], rgRid[7], &pSID))
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    PWSTR rgpwzAttrNames[] = {g_wzName, g_wzADsPath};
    const WCHAR wzSearchFormat[] = L"(&(objectCategory=group)(objectSid=%s))";
    PWSTR pwzSID;
    CStr strSearchFilter;

    hr = ADsEncodeBinaryData((PBYTE)pSID, GetLengthSid(pSID), &pwzSID);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    strSearchFilter.Format(wzSearchFormat, pwzSID);

    FreeADsMem(pwzSID);

    CDSSearch Search;
    hr = Search.Init(m_bstrDomPath);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr;);

    Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strSearchFilter));

    Search.SetAttributeList(rgpwzAttrNames, 2);
    Search.SetSearchScope(ADS_SCOPE_SUBTREE);

    hr = Search.DoQuery();

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        return hr;
    }

    hr = Search.GetNextRow();

    if (hr == S_ADS_NOMORE_ROWS)
    {
        // No object has a matching RID, the primary group must have been
        // deleted. Return S_FALSE to denote this condition.
        //
        hr = S_FALSE;
        return hr;
    }
    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
    PWSTR pwzPriGroupPath;
    PTSTR ptzPriGroupName;
    ADS_SEARCH_COLUMN Column;

    hr = Search.GetColumn(g_wzADsPath, &Column);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    if (!AllocWStr(Column.pADsValues->CaseIgnoreString, &pwzPriGroupPath))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        Search.FreeColumn(&Column);
        return hr;
    }

    Search.FreeColumn(&Column);

    hr = Search.GetColumn(g_wzName, &Column);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    if (!UnicodeToTchar(Column.pADsValues->CaseIgnoreString, &ptzPriGroupName))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        Search.FreeColumn(&Column);
        return hr;
    }

    Search.FreeColumn(&Column);

    *pptzName = ptzPriGroupName;
    *ppwzDN = pwzPriGroupPath;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::BindToGroup
//
//  Synopsis:   Derive the correct name and then bind to the group for the
//              add or remove operation.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::BindToGroup(CMemberListItem * pItem,
                               BOOL fAdd,
                               IUnknown ** ppUnk,
                               PBOOL pfBindFailed)
{
    HRESULT hr;
    CStrW strOtherGrpPath;
    CComPtr<IADsPathname> spPathCracker;

    *pfBindFailed = FALSE;

    hr = GetADsPathname(spPathCracker);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == pItem->m_ulScopeType)
    {
        PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
        DWORD dwErr;

        hr = spPathCracker->Set(L"WinNT",ADS_SETTYPE_PROVIDER);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->Set(pItem->m_pwzDN, ADS_SETTYPE_DN);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
#ifdef _DEBUG
        long nElem;
        hr = spPathCracker->GetNumElements(&nElem);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        dspAssert(2 == nElem);
#endif // _DEBUG
        CComBSTR bstrObject;

        hr = spPathCracker->GetElement(0, &bstrObject);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->RemoveLeafElement();

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        CComBSTR bstrDomain;

        hr = spPathCracker->GetElement(0, &bstrDomain);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        dwErr = DsGetDcNameW(NULL, bstrDomain, NULL, NULL, DS_RETURN_FLAT_NAME,
                             &pDCInfo);

        CHECK_WIN32_REPORT(dwErr, m_hPage, return hr);

        hr = spPathCracker->AddLeafElement(pDCInfo->DomainControllerName + 2);

        NetApiBufferFree(pDCInfo);
        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->AddLeafElement(bstrObject);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        CComBSTR bstrPath;

        hr = spPathCracker->Retrieve(ADS_FORMAT_WINDOWS, &bstrPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        strOtherGrpPath = bstrPath;
        strOtherGrpPath += L",";        // Appending the object class
        strOtherGrpPath += g_wzGroup;   // speeds things up

        hr = ADsGetObject(const_cast<PWSTR>((LPCWSTR)strOtherGrpPath),
                          IID_IADsGroup, (PVOID *)ppUnk);
    }
    else if (DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN == pItem->m_ulScopeType)
    {
        PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
        DWORD dwErr = 0;
        PWSTR pwzDomain;

        hr = spPathCracker->Set(L"LDAP",ADS_SETTYPE_PROVIDER);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = CrackName(pItem->m_pwzDN, &pwzDomain, GET_DNS_DOMAIN_NAME, m_hPage);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        dwErr = DsGetDcNameW(NULL, pwzDomain, NULL, NULL, DS_RETURN_DNS_NAME,
                             &pDCInfo);

        LocalFreeStringW(&pwzDomain);
        CHECK_WIN32_REPORT(dwErr, m_hPage, return hr);

        CHECK_NULL_REPORT(pDCInfo->DomainControllerName, m_hPage, return E_FAIL);

        dspDebugOut((DEB_ITRACE, "Setting group path servername: %S\n",
                     pDCInfo->DomainControllerName + 2));
        hr = spPathCracker->Set(pDCInfo->DomainControllerName + 2, ADS_SETTYPE_SERVER);

        NetApiBufferFree(pDCInfo);
        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->Set(pItem->m_pwzDN, ADS_SETTYPE_DN);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        CComBSTR bstrPath;

        hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        dspDebugOut((DEB_ITRACE, "Opening external group: %S\n",
                     bstrPath));
        hr = ADsOpenObject(bstrPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                           (fAdd) ? IID_IDirectoryObject : IID_IADsGroup,
                           (PVOID *)ppUnk);
    }
    else
    {
        hr = AddLDAPPrefix(pItem->m_pwzDN, strOtherGrpPath, TRUE);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = ADsOpenObject(const_cast<PWSTR>((LPCWSTR)strOtherGrpPath),
                           NULL, NULL, ADS_SECURE_AUTHENTICATION,
                           (fAdd) ? IID_IDirectoryObject : IID_IADsGroup,
                           (PVOID *)ppUnk);
    }

    if (FAILED(hr))
    {
        // If here, the failure is from ADsOpenObject.
        //
        *pfBindFailed = TRUE;
        return hr;
    }

    dspDebugOut((DEB_ITRACE, "Adding this group to group %ws\n", strOtherGrpPath));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportNoGroupAccess
//
//  Synopsis:   Posts the access-denied error message.
//
//-----------------------------------------------------------------------------
void
ReportNoGroupAccess(PTSTR ptzCanName, HWND hPage)
{
    PTSTR ptzTitle, ptzFormat, ptzMsg, ptzReturn;
    CStr csName = ptzCanName;

    if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
    {
        goto FatalError;
    }
    if (!LoadStringToTchar(IDS_ERRMSG_NO_GROUP_ACCESS, &ptzFormat))
    {
        delete ptzTitle;
        goto FatalError;
    }

    ptzReturn = _tcschr(csName, TEXT('\n'));

    if (ptzReturn) *ptzReturn = TEXT('/');

    ptzMsg = new TCHAR[lstrlen(ptzCanName) + lstrlen(ptzFormat) + 1];

    CHECK_NULL_REPORT(ptzMsg, hPage, return);

    wsprintf(ptzMsg, ptzFormat, csName);

    MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);

    delete ptzFormat;
    delete ptzTitle;
    delete[] ptzMsg;

    return;

FatalError:
    MessageBoxA(hPage, "A Fatal Error has occured!", "Active Directory Error",
                MB_OK | MB_ICONEXCLAMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\schedule.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       schedule.cxx
//
//  Contents:   Schedule Page functionality.
//
//  History:    27-Aug-98 JonN split schedule.cxx from siterepl.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "siterepl.h"
#include "user.h" // DllScheduleDialog

#ifdef DSADMIN
extern "C"
{
#include <schedule.h>
}

//
// The schedule block has been redefined to have 1 byte for every hour.
// CODEWORK These should be defined in SCHEDULE.H.  JonN 2/9/98
//
#define INTERVAL_MASK       0x0F
#define RESERVED            0xF0
#define FIRST_15_MINUTES    0x01
#define SECOND_15_MINUTES   0x02
#define THIRD_15_MINUTES    0x04
#define FOURTH_15_MINUTES   0x08


// The dialog has one bit per hour, the DS schedule has one byte per hour
#ifdef OLD_SCHED_BLOCK
const int cbDSScheduleArrayLength = (cbScheduleArrayLength * 4);
#else
const int cbDSScheduleArrayLength = (24*7);
#endif

inline ULONG HeadersSizeNum(ULONG NumberOfSchedules)
{
    return sizeof(SCHEDULE) + ((NumberOfSchedules)-1)*sizeof(SCHEDULE_HEADER);
}

inline ULONG HeadersSize(SCHEDULE* psched)
{
    return HeadersSizeNum(psched->NumberOfSchedules);
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateScheduleBlock
//
//  Synopsis:   This function assumes that the SCHEDULE block has already been
//              validated by ValidateScheduleAttribute.  If a valid
//              interval schedule is found in the SCHEDULE block is it returned
//              in *ppDSSchedule.
//
//-----------------------------------------------------------------------------

BOOL ValidateScheduleBlock( PSCHEDULE pScheduleBlock, PBYTE* ppDSSchedule )
{
    ASSERT( ppDSSchedule == NULL || *ppDSSchedule == NULL );

    BOOL fFoundInterval  = FALSE;
    BOOL fFoundBandwidth = FALSE;
    BOOL fFoundPriority  = FALSE;
    DWORD iSched;
    for (iSched = 0; iSched < pScheduleBlock->NumberOfSchedules; iSched++)
    {
        PSCHEDULE_HEADER pHeader = &(pScheduleBlock->Schedules[iSched]);
        ULONG ulMinimumBlockSize = 0;
        switch (pHeader->Type)
        {
        case SCHEDULE_INTERVAL:
            if (fFoundInterval)
                return FALSE; // two interval blocks
            fFoundInterval = TRUE;
            ulMinimumBlockSize = cbDSScheduleArrayLength;
            if (NULL != ppDSSchedule)
                *ppDSSchedule = ((PBYTE)pScheduleBlock) + pHeader->Offset;
            break;
        case SCHEDULE_BANDWIDTH:
            if (fFoundBandwidth)
                return FALSE; // two bandwidth blocks
            fFoundBandwidth = TRUE;
            break;
        case SCHEDULE_PRIORITY:
            if (fFoundPriority)
                return FALSE; // two priority blocks
            fFoundPriority = TRUE;
            break;
        default:
            // some other, currently unknown type, just let it go
            break;
        }
        if (   pHeader->Offset + ulMinimumBlockSize > pScheduleBlock->Size
            || pHeader->Offset < HeadersSize(pScheduleBlock) )
        {
            // does not fit in schedule block
            return FALSE;
        }
        if (    iSched < pScheduleBlock->NumberOfSchedules-1 &&
                pHeader->Offset + ulMinimumBlockSize > pScheduleBlock->Schedules[iSched+1].Offset )
            return FALSE; // collides with next item
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateScheduleAttribute
//
//  Synopsis:   If a valid SCHEDULE is found is it returned in *ppScheduleBlock.
//
//-----------------------------------------------------------------------------

// This returns TRUE iff the schedule block appears to be valid, regardless of
// whether it contains a schedule
BOOL ValidateScheduleAttribute(
        PADS_ATTR_INFO pAttrInfo,
        PSCHEDULE* ppScheduleBlock,
        PBYTE* ppDSSchedule )
{
    // CODEWORK should NULL==pAttrInfo return FALSE?
    if (NULL == pAttrInfo ||
        IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
        1 != pAttrInfo->dwNumValues ||
        NULL == pAttrInfo->pADsValues ||
        IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
        ADSTYPE_OCTET_STRING != pAttrInfo->pADsValues[0].dwType )
    {
        return FALSE; // attribute is invalid or of wrong type
    }
    DWORD dwAttrLength = pAttrInfo->pADsValues[0].OctetString.dwLength;
    if (dwAttrLength < HeadersSizeNum(0))
        return FALSE; // attribute is too small to contain even skeleton SCHEDULE
    PSCHEDULE pScheduleBlock = reinterpret_cast<PSCHEDULE>
                            (pAttrInfo->pADsValues[0].OctetString.lpValue);
    if (NULL == pScheduleBlock || IsBadReadPtr(pScheduleBlock, dwAttrLength))
        return FALSE; // schedule data is missing
    if (dwAttrLength < pScheduleBlock->Size || 0x10000 < pScheduleBlock->Size)
        return FALSE; // Schedule internal size marker is too large
    if (pScheduleBlock->Size < HeadersSize(pScheduleBlock))
        return FALSE; // schedule is too small to contain even schedule headers
    if (NULL != ppScheduleBlock)
        *ppScheduleBlock = pScheduleBlock;
    return ValidateScheduleBlock( pScheduleBlock, ppDSSchedule );
}


//+----------------------------------------------------------------------------
//
//  Function:   TranslateScheduleBlockToHours, MergeHoursIntoScheduleBlock
//
//  Synopsis:   The schedule control only handles 24x7 bits, whereas the schedules
//              understood by the DS are 24*7 bytes (one byte per hour).
//              We can't display that large a schedule block, so instead we
//              turn on the hour if any of the 15-minute units are on,
//              and we turn on all of the 15-minute units if the hour is on.
//              These APIs allocate a new block of memory if needed,
//              using LocalAlloc.
//
//-----------------------------------------------------------------------------

bool ReadHourInDSScheduleBlock( BYTE* pDSSchedule, int nHour )
{
#ifdef OLD_SCHED_BLOCK
    return (0 != (pDSSchedule[nHour/2] & (0xf<<(4*(nHour%2)))));
#else
    return (0 != (pDSSchedule[nHour] & INTERVAL_MASK));
#endif
}

void SetHourInDSScheduleBlock( BYTE* pDSSchedule, int nHour, BYTE mask )
{
#ifdef OLD_SCHED_BLOCK
    if (fSet)
        pDSSchedule[nHour/2] |= (0xf<<(4*(nHour%2)));
    else
        pDSSchedule[nHour/2] &= ~(0xf<<(4*(nHour%2)));
#else
    pDSSchedule[nHour] &= RESERVED;    // clear out the side of interest to us
    pDSSchedule[nHour] |= mask;        // put in the new settings
#endif
}


// allocates a new hours block
BYTE* TranslateScheduleBlockToHours( PSCHEDULE pSchedule )
{
    if (NULL == pSchedule)
        return NULL;
    BYTE* pDSSchedule = NULL;
    if ( !ValidateScheduleBlock( pSchedule, &pDSSchedule ) || NULL == pDSSchedule )
        return NULL; // not currently defined

    // we found a schedule already defined
    BYTE* pHours = (BYTE*) LocalAlloc (LMEM_ZEROINIT, SCHEDULE_DATA_ENTRIES);
    ASSERT( NULL != pHours );
#if (24*7) != SCHEDULE_DATA_ENTRIES
#error
#endif
    if ( pHours )
    {
        for (INT nHour = 0; nHour < SCHEDULE_DATA_ENTRIES; nHour++)
        {
            pHours[nHour] = pDSSchedule[nHour]; // TODO: Is OLD_SCHED_BLOCK ever defined?
        }
    }

    return pHours;
}

PSCHEDULE NewScheduleBlock(
    PSCHEDULE pCopyScheduleBlock,
    bool fAddIntervalSchedule,
    BYTE byteNewScheduleDefault )
{
    UINT cbBytes = (NULL == pCopyScheduleBlock)
        ? (HeadersSizeNum(0)) : pCopyScheduleBlock->Size;
    if (fAddIntervalSchedule)
        cbBytes += (sizeof(SCHEDULE_HEADER) + cbDSScheduleArrayLength);
    PSCHEDULE pNewScheduleBlock = (PSCHEDULE)
        LocalAlloc( LMEM_ZEROINIT, cbBytes );
    ASSERT(NULL != pNewScheduleBlock);
    if ( pNewScheduleBlock )
    {
        if (NULL == pCopyScheduleBlock)
        {
            // create completely new schedule block
            if (fAddIntervalSchedule)
            {
                pNewScheduleBlock->Size = cbBytes;
                pNewScheduleBlock->NumberOfSchedules = 1;
                pNewScheduleBlock->Schedules[0].Type = SCHEDULE_INTERVAL;
                pNewScheduleBlock->Schedules[0].Offset = HeadersSizeNum(1);
                memset( ((BYTE*)pNewScheduleBlock)+pNewScheduleBlock->Schedules[0].Offset,
                         byteNewScheduleDefault,
                         cbDSScheduleArrayLength );
            }
            else
            {
                pNewScheduleBlock->NumberOfSchedules = 0;
            }
        }
        else if (!fAddIntervalSchedule)
        {
            // create exact copy of existing schedule block
            memcpy( pNewScheduleBlock,
                    pCopyScheduleBlock,
                    pCopyScheduleBlock->Size );
        }
        else
        {
            // create copy of existing schedule block with one added SCHEDULE_INTERVAL

            // copy existing SCHEDULE and SCHEDULE_BLOCKs
            memcpy( pNewScheduleBlock,
                    pCopyScheduleBlock,
                    HeadersSize(pCopyScheduleBlock)
                  );
            pNewScheduleBlock->Size = cbBytes;

            // change offsets for current data to add one more SCHEDULE_HEADER
            ULONG iSched;
            for (iSched = 0; iSched < pCopyScheduleBlock->NumberOfSchedules; iSched++)
            {
                pNewScheduleBlock->Schedules[iSched].Offset += sizeof(SCHEDULE_HEADER);
            }

            // add one more SCHEDULE_HEADER, put new data at end of new block
            pNewScheduleBlock->NumberOfSchedules += 1;
            pNewScheduleBlock->Schedules[pNewScheduleBlock->NumberOfSchedules-1].Type
                = SCHEDULE_INTERVAL;
            pNewScheduleBlock->Schedules[pNewScheduleBlock->NumberOfSchedules-1].Offset
                = pNewScheduleBlock->Size - cbDSScheduleArrayLength;

            // copy existing data
            memcpy( ((PBYTE)pNewScheduleBlock) + HeadersSize(pNewScheduleBlock),
                    ((PBYTE)pCopyScheduleBlock) + HeadersSize(pCopyScheduleBlock),
                    (pCopyScheduleBlock->Size - HeadersSize(pCopyScheduleBlock))
                  );

            // turn on all intervals
            memset( ((BYTE*)pNewScheduleBlock) + pNewScheduleBlock->Schedules[
                                pNewScheduleBlock->NumberOfSchedules-1].Offset,
                     INTERVAL_MASK,
                     cbDSScheduleArrayLength );
        }
    }

    return pNewScheduleBlock;
}

// allocates a new schedule block
PSCHEDULE MergeHoursIntoScheduleBlock(
    PSCHEDULE pOldScheduleBlock,
    BYTE* pHoursArray,
    BYTE byteNewScheduleDefault )
{
    ASSERT( pHoursArray != NULL );
    PSCHEDULE pNewScheduleBlock = NULL;
    PBYTE pOldDSSchedule = NULL;
    if (   NULL == pOldScheduleBlock
        || !ValidateScheduleBlock( pOldScheduleBlock, &pOldDSSchedule ) )
    {
        pNewScheduleBlock = NewScheduleBlock( NULL, true, byteNewScheduleDefault );
    }
    else if ( NULL == pOldDSSchedule )
    {
        pNewScheduleBlock = NewScheduleBlock( pOldScheduleBlock, true, byteNewScheduleDefault );
    }
    else
    {
        pNewScheduleBlock = NewScheduleBlock( pOldScheduleBlock, false, byteNewScheduleDefault );
    }
    ASSERT( NULL != pNewScheduleBlock );
    if ( !pNewScheduleBlock )
        return 0;

    PBYTE pNewDSSchedule = NULL;
    if (   (!ValidateScheduleBlock( pNewScheduleBlock, &pNewDSSchedule ))
        || (NULL == pNewDSSchedule) )
    {
        ASSERT( FALSE );
        if (NULL != pNewScheduleBlock)
            LocalFree( pNewScheduleBlock );
        return NULL;
    }

#if (24*7) != (SCHEDULE_DATA_ENTRIES)
#error
#endif
    for (INT nHour = 0; nHour < SCHEDULE_DATA_ENTRIES; nHour++)
    {
        SetHourInDSScheduleBlock( pNewDSSchedule, nHour, pHoursArray[nHour]);
    }

    return pNewScheduleBlock;
}



//+----------------------------------------------------------------------------
//
//  Function:   ScheduleChangeBtn
//
//  Synopsis:   Handles the schedule Change button.
//
//  JonN 4/26/00
//  22835: DCR: SITEREPL needs a way to delete custom schedules on nTDSConnection objects.
//
//-----------------------------------------------------------------------------
HRESULT
ScheduleChangeBtnBase(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp, BYTE byteNewScheduleDefault)
{
    TRACE_FUNCTION(ScheduleChangeBtn);

    switch (DlgOp)
    {
    case fObjChanged:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
          PVOID pVoid = reinterpret_cast<PVOID>(pAttrData->pVoid);
          if (pVoid != NULL)
          {
            LocalFree( pVoid );
            pAttrData->pVoid = NULL;
          }
        }
        // fall through
    case fInit:
        {
            ASSERT(NULL != pAttrData && NULL == pAttrData->pVoid);
            PSCHEDULE pScheduleBlock = NULL;
            PBYTE pDSSchedule = NULL;
            if ( ValidateScheduleAttribute( pAttrInfo, &pScheduleBlock, &pDSSchedule ) )
            {
                pAttrData->pVoid = reinterpret_cast<LPARAM>(LocalAlloc(0, pScheduleBlock->Size));
                CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
                // Copy the data into the variable
                memcpy(OUT reinterpret_cast<PVOID>(pAttrData->pVoid),
                       IN  pScheduleBlock,
                       pScheduleBlock->Size);
            }
            else
            {
                // set new schedule to default
                pAttrData->pVoid = reinterpret_cast<LPARAM>(NewScheduleBlock( NULL, TRUE, byteNewScheduleDefault ));
            }

#ifdef CUSTOM_SCHEDULE
            // JonN 4/26/00: if the schedule is not set, clear the checkbox
            if (NULL == pDSSchedule) {
                EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
            } else {
                CheckDlgButton(pPage->GetHWnd(), IDC_SCHEDULE_CHECKBOX, BST_CHECKED);
            }
#endif

            // JonN 7/2/99: disable if attribute not writable
            if ( pAttrMap &&
                 (pAttrMap->fIsReadOnly || !PATTR_DATA_IS_WRITABLE(pAttrData)) )
            {
#ifdef CUSTOM_SCHEDULE
                EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_SCHEDULE_CHECKBOX), FALSE);
#endif
                LPWSTR pszMsg = NULL;
                if ( !LoadStringToTchar (IDS_VIEW_SCHEDULE, &pszMsg) )
                {
                    REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                    return E_OUTOFMEMORY;
                }
                HWND hwndCtrl = ::GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID);
                ASSERT( NULL != hwndCtrl );
                Static_SetText( hwndCtrl, pszMsg );
                delete [] pszMsg;
            }
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        // JonN 4/26/00 22835: clear schedule if checkbox unchecked
        // CODEWORK I still don't completely differentiate between
        // CODEWORK "NULL attribute" and "attribute present but no schedule".
        ASSERT( pAttrInfo != NULL );
        if (   NULL == pAttrData
            || NULL == pAttrData->pVoid
#ifdef CUSTOM_SCHEDULE
            || IsDlgButtonChecked(pPage->GetHWnd(), IDC_SCHEDULE_CHECKBOX) != BST_CHECKED
#endif
           )
        {
            // If the Schedule attribute was not set and the user hasn't
            // changed it from the default, then there is no need to write
            // anything.
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->OctetString.dwLength = ((PSCHEDULE)(pAttrData->pVoid))->Size;
            pADsValue->OctetString.lpValue = reinterpret_cast<BYTE*>(pAttrData->pVoid);
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            LPCWSTR pszRDN = pPage->GetObjRDName(); // CODEWORK JonN 4/30/01 334382
            BYTE* pHoursArray = TranslateScheduleBlockToHours( (PSCHEDULE)pAttrData->pVoid );
            if ( pHoursArray )
            {
                HRESULT hr = DllScheduleDialog(pPage->GetHWnd(),
                                               &pHoursArray,
                                               (NULL != pszRDN)
                                                   ? IDS_s_SCHEDULE_FOR
                                                   : IDS_SCHEDULE,
                                               pszRDN,
                                               pPage->GetObjClass (),
                                               (((pAttrMap && (pAttrMap->fIsReadOnly))
    			    // JonN 7/2/99: disable if attribute not writable
                                               || (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData)))
                                                   ? SCHED_FLAG_READ_ONLY : 0 ),
                                               ((pAttrMap)
                                                 ? (ScheduleDialogType)(pAttrMap->nSizeLimit)
                                                 : SchedDlg_Logon)
                                               );
                if ( S_OK == hr
                    && !IsBadReadPtr(pHoursArray, SCHEDULE_DATA_ENTRIES) )
                {
                    PSCHEDULE pNewSchedule = MergeHoursIntoScheduleBlock(
                                reinterpret_cast<PSCHEDULE>(pAttrData->pVoid), pHoursArray, byteNewScheduleDefault );

                    //
                    // JonN 4/30/01 340777
                    // Change confirmation msg appears though
                    // no change was made to a Connection object
                    //
                    bool fChangedSchedule = (NULL == pAttrData->pVoid)
                                         != (NULL == pNewSchedule);
                    if (!fChangedSchedule && NULL != pNewSchedule)
                    {
                        fChangedSchedule =
                            IsBadReadPtr((void*)pAttrData->pVoid, SCHEDULE_DATA_ENTRIES)
                         || 0 != memcmp((PSCHEDULE)pAttrData->pVoid,
                                        pNewSchedule,
                                        SCHEDULE_DATA_ENTRIES);
                    }
                    if (fChangedSchedule)
                    {
                        PVOID pVoid = reinterpret_cast<PVOID>(pAttrData->pVoid);
                        if (pVoid != NULL)
                        {
                            LocalFree( pVoid );
                        }
                        pAttrData->pVoid = reinterpret_cast<LPARAM>(pNewSchedule);
                        pPage->SetDirty();
                        PATTR_DATA_SET_DIRTY(pAttrData);
                    }
                }
                LocalFree( pHoursArray );
            }
        }
        break;

    case fOnDestroy:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
          PVOID pVoid = reinterpret_cast<PVOID>(pAttrData->pVoid);
          if (pVoid != NULL)
          {
            LocalFree( pVoid );
          }
          pAttrData->pVoid = NULL;
        }

        break;
    }

    return S_OK;
}

// exactly once per hour, this is the meaning of attribute not set
HRESULT
ScheduleChangeBtn_11_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp )
{
    return ScheduleChangeBtnBase( pPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        0x11 );
}

// turn on all intervals, this is the meaning of attribute not set
HRESULT
ScheduleChangeBtn_FF_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp )
{
    return ScheduleChangeBtnBase( pPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        0xFF );
}

#ifdef CUSTOM_SCHEDULE
HRESULT
ScheduleChangeCheckbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
                  DLG_OP DlgOp )
{
    if (fOnCommand == DlgOp && BN_CLICKED == lParam)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_SCHEDULE_BTN),
                     IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID));
        ((CDsTableDrivenPage*)pPage)->SetNamedAttrDirty(pAttrMap->AttrInfo.pszAttrName);
    }
    return S_OK;
}
#endif

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\scopedelegation.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ScopeDelegation.h
//
//  Contents:   Delegation page declarations
//
//  Classes:    
//
//  History:    06-April-2001 JeffJon created
//
//-----------------------------------------------------------------------------

#ifndef __SCOPEDELEGATION_H_
#define __SCOPEDELEGATION_H_

#include "pch.h"
#include "proppage.h"

#include <list>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:      CServiceAllowedToDelegate
//
//  Purpose:    Holds the data for each line in the Service to be delegate list
//
//-----------------------------------------------------------------------------
class CServiceAllowedToDelegate
{
public:
    
   // Constructor

   CServiceAllowedToDelegate() {}

   // Destructor

   ~CServiceAllowedToDelegate() {}

   // Copy and assignment will be allowed

   CServiceAllowedToDelegate(const CServiceAllowedToDelegate& ref);
   
   // operators

   const CServiceAllowedToDelegate& 
   operator=(const CServiceAllowedToDelegate&);

   void 
   Assign(const CServiceAllowedToDelegate& ref);

   bool
   operator==(const CServiceAllowedToDelegate& rhs) const;


   // Initializer

   HRESULT Initialize(PCWSTR pszADSIValue);

   // Accessors

   PCWSTR GetColumn(int column) const;
   PCWSTR GetADSIValue() const { return m_strADSIValue; }

   void SetServiceType(PCWSTR pszServiceType);

private:

   CStr m_strADSIValue;
   CStr m_strServiceType;
   CStr m_strUserOrComputer;
   CStr m_strPort;
   CStr m_strServiceName;
   CStr m_strRealm;
};

typedef std::list<CStr*> CStrList;

//+----------------------------------------------------------------------------
//
//  Class:      CFreebieService
//
//  Purpose:    Contains a mapping from aliased SPNs to the service name
//              which they are aliasing
//
//-----------------------------------------------------------------------------
class CFreebieService
{
public:

   // Constructor

   CFreebieService(PCWSTR pszAlias) : m_strAlias(pszAlias) {}

   // Desctructor

   ~CFreebieService() 
   { 
      for (CStrList::iterator itr = m_FreebiesList.begin();
           itr != m_FreebiesList.end();
           ++itr)
      {
         delete *itr;
      }
   }


   const CStrList&
   GetFreebies() { return m_FreebiesList; }

   void
   AddFreebie(PCWSTR pszFreebie) 
   { 
      CStr* pcstrAlias = new CStr(pszFreebie);
      if (pcstrAlias)
      {
         m_FreebiesList.push_back(pcstrAlias);
      }
   }

   PCWSTR
   GetAlias() { return m_strAlias; }

private:

   CStr m_strAlias;
   CStrList m_FreebiesList;
};

typedef std::list<CFreebieService*> FreebiesContainer;
typedef std::list<CServiceAllowedToDelegate*> AllowedServicesContainer;


class CSPNListView
{
public:

   // Constructor
   
   CSPNListView() : m_hWnd(0) {}

   // Desctructor

   ~CSPNListView();

   HRESULT 
   Initialize(HWND hwnd);

   const AllowedServicesContainer&
   GetSelectedServices() { return m_SelectedServices; }

   const AllowedServicesContainer&
   GetUnSelectedServices() { return m_UnSelectedServices; }

   const AllowedServicesContainer&
   GetAllServices() { return m_AllServices; }

   HWND
   GetHwnd() const { return m_hWnd; }

   UINT
   GetSelectedCount() const { return ListView_GetSelectedCount(m_hWnd); }

   void
   ClearSelectedServices();

   void
   ClearAll();

   void
   SelectAll();

   CServiceAllowedToDelegate* 
   FindService(CServiceAllowedToDelegate* pService);

   int 
   AddService(CServiceAllowedToDelegate* pService, bool selected = false);

   void
   AddServices(const AllowedServicesContainer& servicesToAdd, bool selected = false);

   void
   RemoveSelectedServices();

   void
   SetContainersFromSelection();

private:

   void
   ClearUnSelectedServices();

   HWND m_hWnd;

  // The dialog caller must clean up this container
  // and anything it contains

  AllowedServicesContainer m_SelectedServices;

  // The contents of these containers will be maintained
  // by this class

  AllowedServicesContainer m_UnSelectedServices;
  AllowedServicesContainer m_AllServices;
};

typedef enum
{
   SCOPE_DELEGATION_COMPUTER,
   SCOPE_DELEGATION_USER
} SCOPE_DELEGATION_TYPE;

HRESULT CreateUserDelegationPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                 DWORD, CDSBasePathsInfo* pBasePathsInfo,
                                 HPROPSHEETPAGE *);

HRESULT CreateComputerDelegationPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                     DWORD, CDSBasePathsInfo* pBasePathsInfo,
                                     HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsScopeDelegationPage
//
//  Purpose:    property page object class for the computer and user delegaion page.
//
//-----------------------------------------------------------------------------
class CDsScopeDelegationPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsScopeDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                           DWORD dwFlags, SCOPE_DELEGATION_TYPE scopeDelegationType);
    ~CDsScopeDelegationPage(void);

    //
    //  Instance specific wind proc
    //
    virtual LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	 LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);

    void OnUpdateRadioSelection();
    void OnAddServices();
    void OnRemoveServices();
    void GetFreebiesList();
    void InitializeListColumns();
    void SetPageTextForType();
    void LoadDataFromObject();
    void SetUIFromData();
    void ResetUIFromData();
    void AddServicesToListViewFromData();

    HWND m_hList;
    SCOPE_DELEGATION_TYPE m_scopeDelegationType;

    BOOL m_fUACWritable;
    BOOL m_fA2D2Writable;

    DWORD m_oldUserAccountControl;
    DWORD m_newUserAccountControl;
    bool  m_bA2D2Dirty;

    CSPNListView m_ServicesList;
    FreebiesContainer m_FreebiesList;
};


//+----------------------------------------------------------------------------
//
//  Class:      CSelectServicesDialog
//
//  Purpose:    Dialog box that allows the admin to select services from
//              users or computers
//
//-----------------------------------------------------------------------------
class CSelectServicesDialog : public ICustomizeDsBrowser
{
public:
  CSelectServicesDialog(PCWSTR pszDC, HWND hParent, const FreebiesContainer& freebies);

  ~CSelectServicesDialog() {}

   //
   // IUknown methods
   //
   STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
   STDMETHOD_(ULONG, AddRef)(void);
   STDMETHOD_(ULONG, Release)(void);

   //
   // ICustomizeDsBrowser methods 
   //
   STDMETHOD(Initialize)(THIS_
                       HWND         hwnd,
                       PCDSOP_INIT_INFO pInitInfo,
                       IBindHelper *pBindHelper) { return S_OK; }

   STDMETHOD(GetQueryInfoByScope)(THIS_
             IDsObjectPickerScope *pDsScope,
             PDSQUERYINFO *ppdsqi);

   STDMETHOD(AddObjects)(THIS_
             IDsObjectPickerScope *pDsScope,
             IDataObject **ppdo) { return E_NOTIMPL; }

   STDMETHOD(ApproveObjects)(THIS_
             IDsObjectPickerScope*,
             IDataObject*,
             PBOOL);

   STDMETHOD(PrefixSearch)(THIS_
             IDsObjectPickerScope *pDsScope,
             PCWSTR pwzSearchFor,
             IDataObject **pdo) { return E_NOTIMPL; }

   STDMETHOD_(PSID, LookupDownlevelName)(THIS_
              PCWSTR) { return NULL; }


  static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  virtual int 
  DoModal();
  
  virtual BOOL 
  OnInitDialog(HWND hDlg);
  
  virtual void 
  OnClose(int result);
  
  virtual void 
  OnOK();
  
  virtual void 
  ListItemClick(LPNMHDR pnmh);
  
  void 
  OnSelectAll();
  
  void 
  OnGetNewProvider();
  
  void 
  ProcessResults(IDataObject* pdoSelections);

  const AllowedServicesContainer& 
  GetSelectedServices() { return m_ServicesList.GetSelectedServices(); }

  void
  ClearSelectedServices() { m_ServicesList.ClearSelectedServices(); }

  HWND             m_hWnd;

private:
  HWND             m_hParent;

  CSPNListView m_ServicesList;
  const FreebiesContainer& m_FreebiesList;

  CStr m_strDC;

  // Reference counting
  ULONG m_uRefs;
};


#endif // DSADMIN

#endif // __SCOPEDELEGATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\siterepl.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       siterepl.cxx
//
//  Contents:   Site and Replication object functionality.
//
//  History:    16-Sep-97 JonN templated from computer.h
//              06-Nov-97 JonN new SCHEDULE structure
//              27-Aug-98 JonN split schedule.cxx from siterepl.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "siterepl.h"

#ifdef DSADMIN

#include "qrybase.h" // CDSSearch
#include "pcrack.h"  // CPathCracker


//+----------------------------------------------------------------------------
//
//  Function:   ServerChangeBtn and ComputerChangeBtn
//
//  Synopsis:   Handle the Change Server and Change Computer buttons.
//
//  Change Server requires IDC_SERVER_EDIT and IDC_SITE_EDIT.
//
//  Change Computer requires IDC_COMPUTER_EDIT and IDC_DOMAIN_EDIT.
//
//-----------------------------------------------------------------------------

#define BREAK_IF_FAIL if ( FAILED(hr) ) { ASSERT(FALSE); break; }
#define RETURN_IF_FAIL if ( FAILED(hr) ) { ASSERT(FALSE); return hr; }


//
// JonN 3/8/99: check for LostAndFound[Config]
// only sets *pfIsLostAndFound to true, never to false
//
HRESULT IsLostAndFound( IN HWND hwnd, IN LPWSTR pwszDN, OUT bool* pfIsLostAndFound )
{
    PWSTR pwszCanonicalName;
    HRESULT hr = CrackName( pwszDN, &pwszCanonicalName, GET_OBJ_CAN_NAME, hwnd );
    RETURN_IF_FAIL;
    LPTSTR pszCanonicalNameWithoutDomain = wcschr( pwszCanonicalName, L'/' );
    if (pszCanonicalNameWithoutDomain)
    {
        pszCanonicalNameWithoutDomain++;
        if ( !_wcsnicmp( pszCanonicalNameWithoutDomain,
                         L"LostAndFound/", 13 ) )
            *pfIsLostAndFound = true;
        else if ( !_wcsnicmp( pszCanonicalNameWithoutDomain,
                              L"Configuration/LostAndFoundConfig/", 33 ) )
            *pfIsLostAndFound = true;
    }
    LocalFreeStringW(&pwszCanonicalName);
    return S_OK;
}

HRESULT ExtractRDNs(
    IN LPWSTR pwszDN,
    IN long lnElementIndex1,
    OUT BSTR* pbstrRDN1,
    IN long lnElementIndex2 = 0,
    OUT BSTR* pbstrRDN2 = NULL );

HRESULT ExtractRDNs(
    IN LPWSTR pwszDN,
    IN long lnElementIndex1,
    OUT BSTR* pbstrRDN1,
    IN long lnElementIndex2,
    OUT BSTR* pbstrRDN2 )
{
    CPathCracker pathcracker;
    HRESULT hr = pathcracker.Set( pwszDN, ADS_SETTYPE_DN );
    RETURN_IF_FAIL;
    hr = pathcracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    RETURN_IF_FAIL;
    // CODEWORK escaped mode off?
    if (NULL != pbstrRDN1)
    {
        hr = pathcracker.GetElement( lnElementIndex1, pbstrRDN1 );
        RETURN_IF_FAIL;
    }
    if (NULL != pbstrRDN2)
    {
        hr = pathcracker.GetElement( lnElementIndex2, pbstrRDN2 );
        RETURN_IF_FAIL;
    }

    return S_OK;
}

HRESULT ExtractComputerAndDomainName(
    IN LPWSTR pwszDN,
    OUT BSTR* pbstrComputerName,
    OUT BSTR* pbstrDomainName,
    IN HWND hwndDlg )
{
    *pbstrComputerName = NULL;
    *pbstrDomainName = NULL;
    if ( NULL == pwszDN || L'\0' == *pwszDN )
        return S_OK;

    HRESULT hr = ExtractRDNs( pwszDN, 0, pbstrComputerName );
    RETURN_IF_FAIL;
    PWSTR pwszDomainName = NULL;
    hr = CrackName( pwszDN, &pwszDomainName, GET_DNS_DOMAIN_NAME, hwndDlg );
    RETURN_IF_FAIL;
    *pbstrDomainName = ::SysAllocString( pwszDomainName );
    ASSERT( NULL != *pbstrDomainName );
    LocalFreeStringW(&pwszDomainName);

    return S_OK;
}

typedef struct _EXTRACT_TWO_PARAM
{
    int nIDDlgItem1;
    long lnElementIndex1;
    int nIDDlgItem2;
    long lnElementIndex2;
} EXTRACT_TWO_PARAM, *PEXTRACT_TWO_PARAM;

void DisplayTwoFields(
    IN CDsPropPageBase * pPage,
    IN const EXTRACT_TWO_PARAM* pe2,
    bool fInvalid,
    bool fMultivalued,
    IN LPWSTR pwszField1 = NULL,
    IN LPWSTR pwszField2 = NULL );

void DisplayTwoFields(
    IN CDsPropPageBase * pPage,
    IN const EXTRACT_TWO_PARAM* pe2,
    bool fInvalid,
    bool fMultivalued,
    IN LPWSTR pwszField1,
    IN LPWSTR pwszField2 )
{
    if (NULL == pPage || NULL == pe2)
    {
        ASSERT(FALSE);
        return;
    }

    LPWSTR pszMsg = NULL;
    if (fInvalid || fMultivalued)
    {
        if ( !LoadStringToTchar (
                (fMultivalued) ? IDS_MULTIVALUED : IDS_INVALID,
                &pszMsg) )
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return;
        }
        pwszField1 = pszMsg;
        pwszField2 = pszMsg;
    }

    if (0 != pe2->nIDDlgItem1)
    {
        SetDlgItemText( pPage->GetHWnd(), pe2->nIDDlgItem1, pwszField1 );
    }
    if (0 != pe2->nIDDlgItem2)
    {
        SetDlgItemText( pPage->GetHWnd(), pe2->nIDDlgItem2, pwszField2 );
    }

    if ( NULL != pszMsg )
        delete [] pszMsg;
}

HRESULT UpdateComputerAndDomainFields(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    IN PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued)
{
    PEXTRACT_TWO_PARAM pe2 = reinterpret_cast<PEXTRACT_TWO_PARAM>(pvDNUpdateParam);
    if (fInvalid || fMultivalued)
    {
        DisplayTwoFields( pPage, pe2, fInvalid, fMultivalued );
        return S_OK;
    }
    CComBSTR sbstrComputerName;
    CComBSTR sbstrDomainName;
    HRESULT hr = ExtractComputerAndDomainName(
        pwszDN, &sbstrComputerName, &sbstrDomainName, pPage->GetHWnd() );
    RETURN_IF_FAIL;
    DisplayTwoFields( pPage, pe2, false, false, sbstrComputerName, sbstrDomainName );
    return hr;
}


HRESULT UpdateConfigurationRDNFields(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    IN PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued)
{
    PEXTRACT_TWO_PARAM pe2 = reinterpret_cast<PEXTRACT_TWO_PARAM>(pvDNUpdateParam);
    if (fInvalid || fMultivalued)
    {
        DisplayTwoFields( pPage, pe2, fInvalid, fMultivalued );
        return S_OK;
    }

    CComBSTR sbstrRDN1;
    CComBSTR sbstrRDN2;
    if (NULL != pwszDN)
    {
        HRESULT hr = ExtractRDNs( pwszDN,
                                  pe2->lnElementIndex1,
                                  (0 == pe2->nIDDlgItem1) ? NULL : &sbstrRDN1,
                                  pe2->lnElementIndex2,
                                  (0 == pe2->nIDDlgItem2) ? NULL : &sbstrRDN2 );
        RETURN_IF_FAIL;
    }

    DisplayTwoFields( pPage, pe2, false, false, sbstrRDN1, sbstrRDN2 );

    return S_OK;
}

HRESULT UpdateNamingContextFields(
    IN CDsPropPageBase* pPropPage, IN LPWSTR pwszFromServer, bool fInvalid );

HRESULT UpdateNTDSDSAAndDomainFields(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    IN PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued)
{
    HRESULT hr = UpdateConfigurationRDNFields( pPage,
                                               pwszDN,
                                               pvDNUpdateParam,
                                               fInvalid,
                                               fMultivalued);
    if ( SUCCEEDED(hr) )
        hr = UpdateNamingContextFields( pPage, pwszDN, fInvalid || fMultivalued );
    return hr;
}

HRESULT DoPickComputer( IN CDsPropPageBase * pPage, OUT BSTR* pbstrADsPath, PVOID )
{
    return DSPROP_PickComputer( pPage->GetHWnd(), pPage->GetObjPathName(), pbstrADsPath );
}

HRESULT DoPickNTDSDSA( IN CDsPropPageBase * pPage, OUT BSTR* pbstrADsPath, PVOID )
{
    // We extract the path to the Sites container from the path to
    // this object
    ASSERT( NULL != pPage );
    CComBSTR sbstr;
    HRESULT hr = DSPROP_TweakADsPath( pPage->GetObjPathName(), 5, NULL, &sbstr );
    RETURN_IF_FAIL;
    return DSPROP_PickNTDSDSA( pPage->GetHWnd(), sbstr, pbstrADsPath );
}

HRESULT DoPickFrsMember( IN CDsPropPageBase * pPage, OUT BSTR* pbstrADsPath, PVOID pvDNChangeParam )
{
    LPWSTR lpszObjPathName = reinterpret_cast<LPWSTR>(pvDNChangeParam);
    ASSERT( NULL != pPage );
    HRESULT hr = S_OK;

    CComBSTR sbstr = lpszObjPathName;
    if (NULL != lpszObjPathName)
    {
       // remove the two leaf elements from the path
        hr = DSPROP_RemoveX500LeafElements( 2, &sbstr );
        RETURN_IF_FAIL;
    }

    return DSPROP_DSQuery(
        pPage->GetHWnd(),
        sbstr,
        const_cast<CLSID*>(&CLSID_DsFindFrsMembers),
        pbstrADsPath );
}

typedef HRESULT (*PFN_DNUpdate)(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued);
typedef HRESULT (*PFN_DNChange)(
    IN CDsPropPageBase * pPage,
    OUT BSTR* pbstrADsPath,
    PVOID pvDNChangeParam);

HRESULT
DNChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp,
                  PFN_DNUpdate pfnDNUpdate, PVOID pvDNUpdateParam,
                  PFN_DNChange pfnDNChange, PVOID pvDNChangeParam)
{
    TRACE_FUNCTION(DNChangeBtn);

    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fObjChanged:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
            SysFreeString( (ADS_DN_STRING)pAttrData->pVoid );
            pAttrData->pVoid = NULL;
        }
        // fall through
    case fInit:
    {
        // JonN 7/2/99: disable if attribute not writable
        if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);

        bool fInvalid = false;
        bool fMultivalued = false;
        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) )
        {
            // attribute is not set
        }
        else
        if (1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_DN_STRING != pAttrInfo->pADsValues[0].dwType )
        {
            if (2 <= pAttrInfo->dwNumValues)
                fMultivalued = true; // attribute is multivalued
            if (1 <= pAttrInfo->dwNumValues)
                fInvalid = true; // attribute is multivalued or of wrong type
        }
        else
        if ( FAILED( hr = IsLostAndFound( pPage->GetHWnd(),
                                          pAttrInfo->pADsValues[0].DNString,
                                          &fInvalid ) ) )
        {
            break;
        }
        else
        if ( !fInvalid )
        {
            pAttrData->pVoid = reinterpret_cast<LPARAM>(SysAllocString( pAttrInfo->pADsValues[0].DNString ));
            CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
        }
        ASSERT( NULL != pfnDNUpdate );
        hr = (*pfnDNUpdate)( pPage,
                             (ADS_DN_STRING)pAttrData->pVoid,
                             pvDNUpdateParam,
                             fInvalid,
                             fMultivalued );
        if ( FAILED(hr) )
            break; // no assertion
    }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        ASSERT( pAttrInfo != NULL );
        if (NULL == pAttrData || NULL == pAttrData->pVoid)
        {
            // If the DN attribute was not set and the user hasn't
            // changed it from the default, then there is no need to write
            // anything.
            //
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
            pADsValue->dwType = pAttrInfo->dwADsType;
            PWSTR pwsz = NULL;
            if ( !AllocWStr( reinterpret_cast<ADS_DN_STRING>(pAttrData->pVoid), &pwsz ) )
            {
                delete pADsValue; // JonN 03/07/00: PREFIX 49354
                hr = E_OUTOFMEMORY;
                break;
            }
            pADsValue->DNString = pwsz;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CComBSTR sbstrTargetPath;
            ASSERT( NULL != pfnDNChange );
            hr = (*pfnDNChange)( pPage, &sbstrTargetPath, pvDNChangeParam );
            if (S_FALSE == hr)
                break;

            CPathCracker pathcracker;
            hr = pathcracker.Set( sbstrTargetPath, ADS_SETTYPE_FULL );
            RETURN_IF_FAIL;
            sbstrTargetPath.Empty();
            hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrTargetPath );
            RETURN_IF_FAIL;

            if ( NULL != pAttrData && NULL != pAttrData->pVoid )
            {
                SysFreeString( (ADS_DN_STRING)pAttrData->pVoid );
            }
            pAttrData->pVoid = reinterpret_cast<LPARAM>(sbstrTargetPath.Detach());
            ASSERT( NULL != pfnDNUpdate );
            bool fInvalid = false;
            hr = IsLostAndFound( pPage->GetHWnd(),
                                 (ADS_DN_STRING)pAttrData->pVoid,
                                 &fInvalid );
            RETURN_IF_FAIL;
            hr = (*pfnDNUpdate)( pPage,
                                 (ADS_DN_STRING)pAttrData->pVoid,
                                 pvDNUpdateParam,
                                 fInvalid,
                                 false );
            BREAK_IF_FAIL;
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fOnDestroy:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
            SysFreeString( (ADS_DN_STRING)pAttrData->pVoid );
            pAttrData->pVoid = NULL;
        }

        break;
    }

    return hr;
}


const EXTRACT_TWO_PARAM g_e2pNTDSDSA = {
    IDC_SERVER_EDIT,
    1,
    IDC_SITE_EDIT,
    3
};

const EXTRACT_TWO_PARAM g_e2pNTFRSMemberInReplica = {
    IDC_SERVER_EDIT,
    0,
    0,
    0
};
const EXTRACT_TWO_PARAM g_e2pNTFRSMemberAny = {
    IDC_SERVER_EDIT,
    0,
    IDC_SITE_EDIT,
    1
};

const EXTRACT_TWO_PARAM g_e2pComputer = {
    IDC_COMPUTER_EDIT,
    0,
    IDC_DOMAIN_EDIT,
    0
};

HRESULT
nTDSDSAChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateConfigurationRDNFields, (PVOID)(&g_e2pNTDSDSA),
        DoPickNTDSDSA, NULL );
}

HRESULT
nTDSDSAAndDomainChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateNTDSDSAAndDomainFields, (PVOID)(&g_e2pNTDSDSA),
        DoPickNTDSDSA, NULL );
}

HRESULT
FRSMemberInReplicaChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateConfigurationRDNFields, (PVOID)(&g_e2pNTFRSMemberInReplica),
        DoPickFrsMember, (PVOID)pPage->GetObjPathName() );
}

HRESULT
FRSAnyMemberChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateConfigurationRDNFields, (PVOID)(&g_e2pNTFRSMemberAny),
        DoPickFrsMember, NULL );
}

HRESULT
ComputerChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateComputerAndDomainFields, (PVOID)(&g_e2pComputer),
        DoPickComputer, NULL );
}

HRESULT HrBuildADsValueArray(
    OUT PADSVALUE* ppADsValue,
    IN CStrListItem* pList,
    IN int nItems
    )
{
    HRESULT hr = S_OK;
    *ppADsValue = new ADSVALUE[nItems];
    CHECK_NULL(*ppADsValue, return E_OUTOFMEMORY);
    CStrListItem* pItem = pList;
    for (int i = 0; i < nItems; i++, pItem = pItem->pnext)
    {
        if (NULL == pItem)
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
        (*ppADsValue)[i].dwType = ADSTYPE_DN_STRING;
        if ( !AllocWStr(
            const_cast<LPTSTR>((LPCTSTR)pItem->str),
            &((*ppADsValue)[i].DNString) ) )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    ASSERT( NULL == pItem );
    return hr;
}


/*
JonN 04/04/00
90719: S&S UI should add/remove individual values from multi-valued attributes

We prepend the character 'I' or 'O' to each ItemData, corresponding to
whether the item started in the IN or OUT listbox.  Later, at fApply time,
we only add or remove values, rather than resetting the attribute.
*/
typedef enum _WHICHLB
{
    WHICHLB_IN = 0,
    WHICHLB_OUT,
    WHICHLB_NONE
} WHICHLB;

int AddItemToListbox(
    IN HWND hwnd,
    IN LPCTSTR lpszDN,
    IN WHICHLB whichlb = WHICHLB_NONE,
    OUT int* piIndex = NULL );

int AddItemToListbox(
    IN HWND hwnd,
    IN LPCTSTR lpszDN,
    IN WHICHLB whichlb,
    OUT int* piIndex )
{
    CComBSTR sbstrRDN;
    HRESULT hr = DSPROP_RetrieveRDN( lpszDN, &sbstrRDN );
    RETURN_IF_FAIL;
    int iIndex = ListBox_AddString( hwnd, sbstrRDN );
    if ( 0 > iIndex )
    {
        hr = E_FAIL;
        RETURN_IF_FAIL;
    }
    ASSERT( !!sbstrRDN );
    BSTR bstr = NULL;
    if (WHICHLB_NONE != whichlb)
    {
        bstr = ::SysAllocStringLen( NULL, static_cast<UINT>(1+wcslen(lpszDN) ));
        bstr[0] = (WHICHLB_IN == whichlb) ? TEXT('I') : TEXT('O');
        wcscpy( bstr+1, lpszDN );
    } else {
        bstr = ::SysAllocString( lpszDN );
    }
    int iRetval = ListBox_SetItemData(
        hwnd,
        iIndex,
        bstr ); // now don't free this
    ASSERT( LB_ERR != iRetval );
    if (piIndex != NULL)
        *piIndex = iIndex;
    return S_OK;
}

HRESULT AddItemsToListbox(
    IN HWND hwnd,
    IN PADS_ATTR_INFO pAttrInfo,
    IN WHICHLB whichlb = WHICHLB_NONE
    );

HRESULT AddItemsToListbox(
    IN HWND hwnd,
    IN PADS_ATTR_INFO pAttrInfo,
    IN WHICHLB whichlb
    )
{
    ASSERT( NULL != hwnd );

    if (NULL == pAttrInfo)
        return S_OK;

    HRESULT hr = S_OK;
    for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
    {
        ASSERT( ADSTYPE_DN_STRING == pAttrInfo->pADsValues[i].dwType );
        hr = AddItemToListbox( hwnd, pAttrInfo->pADsValues[i].DNString, whichlb );
        RETURN_IF_FAIL;
    }
    DSPROP_HScrollStringListbox( hwnd );
    return hr;
}

// release itemdata associated with listbox items
// caller should call DSPROP_HScrollStringListbox if listbox is not being released
void DSPROP_Duelling_ClearListbox( HWND hwndListbox )
{
    ASSERT( NULL != hwndListbox );
    while (0 < ListBox_GetCount( hwndListbox ))
    {
        BSTR bstrFirstItem = (BSTR)ListBox_GetItemData( hwndListbox, 0 );
        if (NULL != bstrFirstItem)
            ::SysFreeString( bstrFirstItem );
        int iRetval = ListBox_DeleteString( hwndListbox, 0 );
        ASSERT( LB_ERR != iRetval );
    }
}

HRESULT HrGetItemsFromListbox(
    IN HWND hwnd,
    OUT CStrListItem** pplistDNs,
    OUT int& cDNs,
    IN WHICHLB whichlbFilter = WHICHLB_NONE );

// only retrieve entries from specified LB if any
HRESULT HrGetItemsFromListbox(
    IN HWND hwnd,
    OUT CStrListItem** pplistDNs,
    OUT int& cDNs,
    IN WHICHLB whichlbFilter )
{
    ASSERT( NULL != hwnd && NULL != pplistDNs && NULL == *pplistDNs );

    cDNs = 0;
    int cItems = ListBox_GetCount( hwnd );
    if (cItems < 0)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    // build list of DNs of selected items
    for (int i = cItems-1; i >= 0; i--)
    {
        BSTR bstrDN = (BSTR)ListBox_GetItemData( hwnd, i );
        ASSERT( NULL != bstrDN );

        if (WHICHLB_IN == whichlbFilter)
        {
            if (L'I' != bstrDN[0])
                continue;
        } else if (WHICHLB_OUT == whichlbFilter) {
            if (L'O' != bstrDN[0])
                continue;
        }
        bstrDN++;
        cDNs++;

        CStrListItem* pNewItem = new CStrListItem;
        if (NULL == pNewItem)
        {
            ASSERT(FALSE);
            return E_OUTOFMEMORY;
        }
        pNewItem->str = bstrDN;
        pNewItem->pnext = *pplistDNs;
        *pplistDNs = pNewItem;
    }
    return S_OK;
}

void MarkItemsFromListbox(
    IN HWND hwnd,
    IN WHICHLB whichlbFilter )
{
    ASSERT( NULL != hwnd );

    int cItems = ListBox_GetCount( hwnd );
    if (cItems < 0)
    {
        ASSERT(FALSE);
        return;
    }

    for (int i = cItems-1; i >= 0; i--)
    {
        BSTR bstrDN = (BSTR)ListBox_GetItemData( hwnd, i );
        if ( NULL != bstrDN && L'\0' != bstrDN[0] )
        {
            bstrDN[0] = (WHICHLB_IN == whichlbFilter)
                ? TEXT('I')
                : TEXT('O');
        } else {
            ASSERT(FALSE);
        }
    }
}

void MoveSelectedItems( IN HWND hwndFrom, IN HWND hwndTo )
{
    ASSERT( NULL != hwndFrom && NULL != hwndTo );

    // get list of indexes to selected items
    int cSelectedItems = ListBox_GetSelCount( hwndFrom );
    if (cSelectedItems <= 0)
        return;
    int* pSelectedItems = new int[cSelectedItems];
    if (!pSelectedItems)
    {
      ASSERT(FALSE);
      return;
    }

    int nRetval = ListBox_GetSelItems( hwndFrom, cSelectedItems, pSelectedItems );
    if ( nRetval != cSelectedItems )
    {
        delete[] pSelectedItems;
        pSelectedItems = 0;
        ASSERT(FALSE);
        return;
    }

    // move items from one listbox to another
    for (int iIndexIntoSelectedItemArray = cSelectedItems-1;
         iIndexIntoSelectedItemArray >= 0;
         iIndexIntoSelectedItemArray--)
    {
        int iSelectedItem = pSelectedItems[iIndexIntoSelectedItemArray];
        BSTR bstrItem = (BSTR)ListBox_GetItemData( hwndFrom, iSelectedItem );
        ASSERT( NULL != bstrItem );
        int iNewIndex = 0;
        HRESULT hr = AddItemToListbox( hwndTo, bstrItem, WHICHLB_NONE, &iNewIndex );
        ASSERT( SUCCEEDED(hr) );
        nRetval = ListBox_SelItemRange( hwndTo, true, iNewIndex, iNewIndex );
        ASSERT( LB_ERR != nRetval );
        nRetval = ListBox_DeleteString( hwndFrom, iSelectedItem );
        ASSERT( LB_ERR != nRetval );
    }
    DSPROP_HScrollStringListbox( hwndFrom );
    DSPROP_HScrollStringListbox( hwndTo );

    delete[] pSelectedItems;
    pSelectedItems = 0;
}

// enable/disable Add and Remove buttons
void DSPROP_Duelling_UpdateButtons( HWND hwndDlg, int nAnyCtrlid )
{
    int nOutCtrlid = nAnyCtrlid - (nAnyCtrlid%4);
    HWND hwndOutListbox   = ::GetDlgItem(hwndDlg,nOutCtrlid  );
    HWND hwndAddButton    = ::GetDlgItem(hwndDlg,nOutCtrlid+1);
    HWND hwndRemoveButton = ::GetDlgItem(hwndDlg,nOutCtrlid+2);
    HWND hwndInListbox    = ::GetDlgItem(hwndDlg,nOutCtrlid+3);
    ASSERT( NULL != hwndOutListbox
         && NULL != hwndAddButton
         && NULL != hwndRemoveButton
         && NULL != hwndInListbox );
    int cSelectedItemsOut = ListBox_GetSelCount( hwndOutListbox );
    int cSelectedItemsIn  = ListBox_GetSelCount( hwndInListbox );
    (void) ::EnableWindow( hwndAddButton,    (cSelectedItemsOut > 0) );
    (void) ::EnableWindow( hwndRemoveButton, (cSelectedItemsIn  > 0) );
}

bool FIsInDNList(
    IN LPCWSTR lpcszDN,
    IN PADS_ATTR_INFO pAttrInfo
    )
{
    ASSERT( NULL != lpcszDN && NULL != pAttrInfo );
    for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
    {
        ASSERT( ADSTYPE_DN_STRING == pAttrInfo->pADsValues[i].dwType );
        if ( !lstrcmpi( lpcszDN, pAttrInfo->pADsValues[i].DNString ) )
        {
            return true;
        }
    }
    return false;
}


bool DSPROP_BSTR_BLOCK__SetCount( DSPROP_BSTR_BLOCK& block, int cItems )
{
    ASSERT( 0 <= cItems );
    if ( NULL != block.m_abstrItems )
    {
        for (int iItem = 0; iItem < block.QueryCount(); iItem++)
        {
            if ( NULL != block[iItem] )
                ::SysFreeString( block[iItem] );
        }
        ::SysFreeString( (BSTR)(block.m_abstrItems) );
        block.m_abstrItems = NULL;
    }
    block.m_cItems = 0;
    if ( 0 < cItems )
    {
        block.m_abstrItems =
            (BSTR*)::SysAllocStringByteLen( NULL, cItems * sizeof(BSTR) );
        if ( NULL == block.m_abstrItems )
            return false;
        ::ZeroMemory( block.m_abstrItems, cItems * sizeof(BSTR) );
        block.m_cItems = cItems;
    }
    return true;
}

BSTR& DSPROP_BSTR_BLOCK__Reference( DSPROP_BSTR_BLOCK& block, int iItem )
{
    ASSERT( 0 <= iItem && block.QueryCount() > iItem );
    return block.m_abstrItems[iItem];
}


// Enumerate the items of class lpcwszTargetDesiredClass in container
// lpcwszADsPathDirectory, except for those in pAttrInfoExclusions.
HRESULT DSPROP_ShallowSearch2(
    IN OUT DSPROP_BSTR_BLOCK* pbstrblock,
    IN LPCTSTR lpcwszADsPathDirectory,
    IN LPCTSTR lpcwszFilterString,
    IN PADS_ATTR_INFO pAttrInfoExclusions
    )
{
    ASSERT( NULL != pbstrblock );
    HRESULT hr = S_OK;
    CStrListItem* pstrlist = NULL;
    // now add all of the objects of the specified class
    // in the specified container
    CDSSearch Search;
    Search.Init(lpcwszADsPathDirectory);
    Search.SetFilterString(const_cast<LPWSTR>(lpcwszFilterString));
    LPWSTR pAttrs[1] = {L"distinguishedName"};
    Search.SetAttributeList(pAttrs, 1);
    Search.SetSearchScope(ADS_SCOPE_ONELEVEL);
    hr = Search.DoQuery();
    while (SUCCEEDED(hr)) {
        hr = Search.GetNextRow();
        if (S_ADS_NOMORE_ROWS == hr)
        {
            hr = S_OK;
            break;
        }
        BREAK_IF_FAIL;

        ADS_SEARCH_COLUMN DistinguishedNameColumn;
        ::ZeroMemory( &DistinguishedNameColumn, sizeof(DistinguishedNameColumn) );
        hr = Search.GetColumn (pAttrs[0], &DistinguishedNameColumn);
        BREAK_IF_FAIL;
        ASSERT( ADSTYPE_DN_STRING == DistinguishedNameColumn.pADsValues->dwType );

        // if the current value has already been added to the In listbox,
        // don't add it to the Out listbox
        if (    NULL == pAttrInfoExclusions
            || !FIsInDNList( DistinguishedNameColumn.pADsValues->DNString, pAttrInfoExclusions ) )
        {
            CStrListAdd(&pstrlist, DistinguishedNameColumn.pADsValues->DNString);
        }
        Search.FreeColumn (&DistinguishedNameColumn);
    }

    // transfer CStrList to DSPROP_BSTR_BLOCK -- could be in own routine
    int cItems = CountCStrList( &pstrlist );
    if ( 0 < cItems )
    {
        if ( !pbstrblock->SetCount( cItems ) )
            hr = STATUS_NO_MEMORY;
        else
        {
            int iItem = 0;
        	for (CStrListItem* pList = pstrlist;
                 NULL != pList;
                 pList = pList->pnext, iItem++)
    	    {
                if ( !pbstrblock->Set( const_cast<LPTSTR>((LPCTSTR)(pList->str)), iItem ) )
                {
                    hr = STATUS_NO_MEMORY;
                    break;
                }
            }
	    }
    }
    FreeCStrList( &pstrlist );
    return hr;
}

HRESULT DSPROP_ShallowSearch(
    IN OUT DSPROP_BSTR_BLOCK* pbstrblock,
    IN LPCTSTR lpcwszADsPathDirectory,
    IN LPCTSTR lpcwszTargetDesiredClass,
    IN PADS_ATTR_INFO pAttrInfoExclusions
    )
{
    CStr strFilterString;
    strFilterString.Format(L"(&(objectClass=%s))", lpcwszTargetDesiredClass);
    return DSPROP_ShallowSearch2( pbstrblock,
                                  lpcwszADsPathDirectory,
                                  strFilterString,
                                  pAttrInfoExclusions );
}


//
// JonN 4/8/99: add code to enable horizontal scrolling where appropriate
//
HRESULT DSPROP_HScrollStringListbox(
    HWND hwndListbox
    )
{
    HRESULT hr = S_OK;
    LONG cxLongestTextExtent = 0L;

    // get a DC for the listbox
    HDC hdc = ::GetDC( hwndListbox );
    if ( NULL == hdc )
    {
        ASSERT(FALSE);
        return HRESULT_FROM_WIN32( ::GetLastError() );
    }
    // now don't return before releasing it

    CStrListItem* pList = NULL;
    SIZE sizeTextExtent;
    ::ZeroMemory( &sizeTextExtent, sizeof(sizeTextExtent) );
    do { // false loop

        int cDNs = 0;
        hr = HrGetItemsFromListbox( hwndListbox, &pList, cDNs );
        BREAK_IF_FAIL;
        // don't return before releasing this

        // determine the longest text extent of the strings in the listbox
        for (CStrListItem* pItem = pList; pItem != NULL; pItem = pItem->pnext)
        {
            LPTSTR ptzText = const_cast<LPTSTR>((LPCTSTR)pItem->str);
            CComBSTR sbstrRDN;
            hr = DSPROP_RetrieveRDN( ptzText, &sbstrRDN );
            BREAK_IF_FAIL;
            if ( !::GetTextExtentPoint32( hdc,
                                          sbstrRDN,
                                          sbstrRDN.Length(),
                                          &sizeTextExtent ) )
            {
                hr = HRESULT_FROM_WIN32( ::GetLastError() );
                BREAK_IF_FAIL; // don't return without releasing hdc
            }
            if ( sizeTextExtent.cx > cxLongestTextExtent )
                cxLongestTextExtent = sizeTextExtent.cx;
        }

    } while (false); // false loop
    (void) ::ReleaseDC( hwndListbox, hdc );
    if (NULL != pList)
        FreeCStrList( &pList );

    // set the horizontal scroll bar
    // don't bother with GetSystemMetrics(SM_CXHSCROLL) or listbox width
    ListBox_SetHorizontalExtent( hwndListbox, cxLongestTextExtent );

    return hr;
}


HRESULT DSPROP_Duelling_Populate2(
    IN HWND hwndListbox,
    IN const DSPROP_BSTR_BLOCK& bstrblock,
    IN WHICHLB whichlb
    )
{
    HRESULT hr = S_OK;
    for (int iItem = 0; iItem < bstrblock.QueryCount(); iItem++)
    {
        ASSERT( NULL != bstrblock[iItem] );
        hr = AddItemToListbox( hwndListbox, bstrblock[iItem], whichlb );
        BREAK_IF_FAIL;
    }
    DSPROP_HScrollStringListbox( hwndListbox );
    return hr;
}


// Enumerate the items of class lpcwszTargetDesiredClass in container
// lpcwszADsPathDirectory.  Add them to the specified listbox, except for
// those in pAttrInfoExclusions.
HRESULT DSPROP_Duelling_Populate(
    IN HWND hwndListbox,
    IN const DSPROP_BSTR_BLOCK& bstrblock
    )
{
    return DSPROP_Duelling_Populate2( hwndListbox, bstrblock, WHICHLB_NONE );
}


//
// These attribute functions is meant to handle four controls on the same page,
// where their attribute IDs are in sequence from
// ctrlidOut    (where ctrlidOut%4 = 0)
// ctrlidAdd    = ctrlidOut+1
// ctrlidRemove = ctrlidOut+2
// ctrlidIn     = ctrlidOut+3
//
inline bool IsOutListbox(  int ctrlid) { return (0 == (ctrlid%4)); }
inline bool IsAddButton(   int ctrlid) { return (1 == (ctrlid%4)); }
inline bool IsRemoveButton(int ctrlid) { return (2 == (ctrlid%4)); }
inline bool IsInListbox(   int ctrlid) { return (3 == (ctrlid%4)); }
inline bool IsListbox(     int ctrlid)
    { return IsOutListbox(ctrlid) || IsInListbox(ctrlid); }
inline bool IsButton(      int ctrlid)
    { return IsAddButton(ctrlid) || IsRemoveButton(ctrlid); }

void
DSPROP_Duelling_ButtonClick(
		HWND hwndDlg,
		int nButtonCtrlid
		)
{
    ASSERT( IsButton(nButtonCtrlid) );
    int ctrlidFrom = (IsAddButton(nButtonCtrlid))
        ? nButtonCtrlid - 1
        : nButtonCtrlid + 1;
    int ctrlidTo   = (IsAddButton(nButtonCtrlid))
        ? nButtonCtrlid + 2
        : nButtonCtrlid - 2;
    HWND hwndTo = ::GetDlgItem(hwndDlg,ctrlidTo);
    HWND hwndFrom = ::GetDlgItem(hwndDlg,ctrlidFrom);
    ASSERT( NULL != hwndTo && NULL != ctrlidFrom );
    MoveSelectedItems( hwndFrom, hwndTo );
    DSPROP_Duelling_UpdateButtons( hwndDlg, nButtonCtrlid );

    // set focus to hwndTo
    (void) ::SendMessage( hwndDlg, WM_NEXTDLGCTL, (WPARAM)hwndTo, 1L );
}

HRESULT
DuellingListboxButton(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
    LPARAM lParam, PATTR_DATA, DLG_OP DlgOp
    )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fOnCommand:
        if ( BN_CLICKED == lParam )
        {
            DSPROP_Duelling_ButtonClick( pPropPage->GetHWnd(),
                                         pAttrMap->nCtrlID );
            pPropPage->SetDirty();

            PATTR_DATA_SET_DIRTY(((PATTR_DATA)((CDsTableDrivenPage *)pPropPage)->m_pData));
        }
        break;
    }

    return hr;
}

// also called by DuellingInListbox
HRESULT
DuellingListbox(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp
    )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fOnCommand:
        DBG_OUT("DuellingListbox: fOnCommand");
        ASSERT( IsListbox(pAttrMap->nCtrlID) );
        // JonN 7/2/99: disable Add and Remove if attribute not writable
        if ( LBN_SELCHANGE == lParam
          && !(pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData)) )
            DSPROP_Duelling_UpdateButtons( pPropPage->GetHWnd(), pAttrMap->nCtrlID );
        break;

    case fOnDestroy:
        DBG_OUT("DuellingListbox: fOnDestroy");
        ASSERT( IsListbox(pAttrMap->nCtrlID) );
        DSPROP_Duelling_ClearListbox(
            ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID) );
    }

    return hr;
}

HRESULT
DuellingInListbox(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp,
    int iTargetLevelsUp, PWCHAR* ppwszTargetLevelsBack,
    PWCHAR pwszTargetClass,
    int nMinimumRDNs = 0,       // What is the minimum allowed number of references?
    int idsNotEnoughRDNs = 0    // What message to display if there are not enough
    );


HRESULT
DuellingInListbox(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp,
    int iTargetLevelsUp, PWCHAR* ppwszTargetLevelsBack,
    PWCHAR pwszTargetClass,
    int nMinimumRDNs,
    int idsNotEnoughRDNs
    )
{
    HRESULT hr = S_OK;
    CStrListItem* pList = NULL;
    switch (DlgOp)
    {
    case fInit:
    case fObjChanged:
        ASSERT( IsInListbox(pAttrMap->nCtrlID) );
        DBG_OUT("DuellingInListbox: fInit or fObjChanged");
        {
            //
            // Fill in the initial value of the In listbox
            // note that pAttrInfo could be NULL
            //
            HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
            ASSERT( NULL != hwndCtrl );
            hr = AddItemsToListbox( hwndCtrl, pAttrInfo, WHICHLB_IN );
            BREAK_IF_FAIL;

            //
            // Fill in the initial value of the Out listbox
            //
            hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID-3);
            ASSERT( NULL != hwndCtrl );
            CComBSTR sbstrRDN;
            hr = DSPROP_TweakADsPath(
                pPropPage->GetObjPathName(),
                iTargetLevelsUp,
                ppwszTargetLevelsBack,
                &sbstrRDN );
            BREAK_IF_FAIL;
            DSPROP_BSTR_BLOCK bstrblock;
            hr = DSPROP_ShallowSearch(
                &bstrblock, 
                sbstrRDN,
                pwszTargetClass,
                pAttrInfo );
            if (FAILED(hr)) break;
            hr = DSPROP_Duelling_Populate2(
                hwndCtrl,
                bstrblock,
                WHICHLB_OUT );
            BREAK_IF_FAIL;
            //
            // Save the pAttrData pointer so that the button proc can set the
            // dirty state.
            //
            ((CDsTableDrivenPage *)pPropPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);

            // JonN 7/2/99: disable Add and Remove if attribute not writable
            if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            {
                for (int i = 1; i <= 2; i++)
                    EnableWindow(GetDlgItem(pPropPage->GetHWnd(), pAttrMap->nCtrlID-i), FALSE);
            }
            break;

        }
        break;

    case fApply:
        DBG_OUT("DuellingInListbox: fApply");
        ASSERT( IsInListbox(pAttrMap->nCtrlID) );
        if (PATTR_DATA_IS_DIRTY(pAttrData))
        {
            //
            // Display an error message if the attribute is not pointing to
            // at least the minimum number of target objects, except when it is
            // pointing to all of the possible choices.
            //
            HWND hwndCtrlIn = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
            HWND hwndCtrlOut = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID-3);
            ASSERT( NULL != hwndCtrlIn && NULL != hwndCtrlOut );
            int cItems = ListBox_GetCount( hwndCtrlIn );
            int cItemsOut = ListBox_GetCount( hwndCtrlOut );
            if (0 > cItems || 0 > cItemsOut)
            {
                ASSERT(FALSE);
                return E_FAIL;
            }
            if ( nMinimumRDNs > cItems && 0 != cItemsOut )
            {
                (void) SuperMsgBox(
                    pPropPage->GetHWnd (),
                    idsNotEnoughRDNs,
                    0,
                    MB_ICONWARNING,
                    0,
                    NULL, 0,
                    FALSE, __FILE__, __LINE__);

                return E_FAIL; // TableDriven will not display an error box
            }

            int cDNs = 0;
            hr = HrGetItemsFromListbox( hwndCtrlIn, &pList, cDNs, WHICHLB_OUT );
            BREAK_IF_FAIL;
            if (0 < cDNs)
            {
                hr = HrBuildADsValueArray( &(pAttrInfo->pADsValues), pList, cDNs );
                BREAK_IF_FAIL;
                pAttrInfo->dwNumValues = cDNs;
                pAttrInfo->dwControlCode = ADS_ATTR_APPEND;
                ASSERT( NULL != pPropPage->m_pDsObj );
                DWORD dwDummy = 0;
                hr = pPropPage->m_pDsObj->SetObjectAttributes(pAttrInfo,1,&dwDummy);
                if (FAILED(hr)) break;
                MarkItemsFromListbox( hwndCtrlIn, WHICHLB_IN );
                FreeCStrList( &pList );
                HelperDeleteADsValues( pAttrInfo );
            }

            hr = HrGetItemsFromListbox( hwndCtrlOut, &pList, cDNs, WHICHLB_IN );
            BREAK_IF_FAIL;
            if (0 < cDNs)
            {
                hr = HrBuildADsValueArray( &(pAttrInfo->pADsValues), pList, cDNs );
                BREAK_IF_FAIL;
                pAttrInfo->dwNumValues = cDNs;
                pAttrInfo->dwControlCode = ADS_ATTR_DELETE;
                ASSERT( NULL != pPropPage->m_pDsObj );
                DWORD dwDummy = 0;
                hr = pPropPage->m_pDsObj->SetObjectAttributes(pAttrInfo,1,&dwDummy);
                if (FAILED(hr)) break;
                MarkItemsFromListbox( hwndCtrlOut, WHICHLB_OUT );
                FreeCStrList( &pList );
                HelperDeleteADsValues( pAttrInfo );
            }
            return ADM_S_SKIP;
        }
        else
        {
            return ADM_S_SKIP;
        }
        break;

    case fOnCommand:
    case fOnDestroy:
        return DuellingListbox( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp );
    }

    //
    // JonN 5/7/01 386954
    // dssite.msc: Moving server object after opening properties page
    // breaks OK and Apply buttons
    //
    // We were just failing to display anything on these errors
    //
    (void) CHECK_ADS_HR(&hr, pPropPage->GetHWnd());

    if (NULL != pList)
        FreeCStrList( &pList );

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   DsQuerySiteList
//
//  Synopsis:  Handles multi-valued DN pointer from Site-Link to Site objects
//
//-----------------------------------------------------------------------------
HRESULT
DsQuerySiteList(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    return DuellingInListbox(
        pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        3, NULL, L"site", 2, IDS_SITELINK_NEEDS_TWO_SITES );
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQuerySiteLinkList
//
//  Synopsis:  Handles multi-valued DN pointer from Site-Link-Bridge to Site-Link objects
//
//-----------------------------------------------------------------------------
HRESULT
DsQuerySiteLinkList(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    return DuellingInListbox(
        pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        1, NULL, L"siteLink", 2, IDS_SITELINKBRIDGE_NEEDS_TWO_SITELINKS );
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQueryBridgeheadList
//
//  Synopsis:  Handles multi-valued DN pointer from NTDS-DSA to Inter-Site-Transport objects
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryBridgeheadList(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    static WCHAR* apwszLevelsBack[2] = {
        L"CN=Inter-Site Transports",
        (WCHAR*)NULL };
    return DuellingInListbox(
        pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        3, apwszLevelsBack, L"interSiteTransport" );
}


//+----------------------------------------------------------------------------
//
//  Function:   GetReplicatedDomainInfo
//
//  Synopsis:  Returns information about the domains stored by this replica
//
//-----------------------------------------------------------------------------
HRESULT
GetReplicatedDomainInfo(
    IN LPWSTR pwszADsPathDC,
    IN HWND   hwndDlg,
    OUT CStrListItem** pplistMasterDNSDomains,
    OUT bool* pfGlobalCatalog )
{
    ASSERT(   NULL != pwszADsPathDC
           && NULL != pplistMasterDNSDomains
           && NULL == *pplistMasterDNSDomains
           && NULL != pfGlobalCatalog );
    CComPtr<IDirectoryObject> spIDirectoryObject;
    HRESULT hr = ADsOpenObject(
        pwszADsPathDC,
        NULL, NULL, ADS_SECURE_AUTHENTICATION,
        IID_IDirectoryObject,
        (PVOID *)&spIDirectoryObject);
    if ( FAILED(hr) )
        return hr; // no assertion
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD cAttrs = 0;

    //
    // read list of master NCs
    //
    PWSTR rgpwszNCAttrNames[] = {g_wzHasMasterNCs};
    hr = spIDirectoryObject->GetObjectAttributes(
        rgpwszNCAttrNames, 1, &spAttrs, &cAttrs);
    if ( FAILED(hr) )
        return hr; // no assertion
    if (   !spAttrs
        || 1 != cAttrs
        || lstrcmpi( g_wzHasMasterNCs, spAttrs[0].pszAttrName )
        || 0 >= spAttrs[0].dwNumValues
        || ADSTYPE_DN_STRING != spAttrs[0].dwADsType
        || NULL == spAttrs[0].pADsValues
       )
    {
        return E_FAIL; // no assertion
    }
    for (DWORD i = 0; i < spAttrs[0].dwNumValues; i++)
    {
        ASSERT( NULL != spAttrs[0].pADsValues[i].DNString );
        CPathCracker pathcracker;
        hr = pathcracker.Set(
            spAttrs[0].pADsValues[i].DNString, ADS_SETTYPE_DN );
        RETURN_IF_FAIL;
        CComBSTR sbstr;
        hr = pathcracker.GetElement( 0L, &sbstr );
        RETURN_IF_FAIL;
        ASSERT( !!sbstr );
        if ( !sbstr || _wcsnicmp( L"DC=", sbstr, 3 ) )
            continue; // not a domain naming context

        PWSTR pwszDomainName = NULL;
        hr = CrackName( spAttrs[0].pADsValues[i].DNString,
                        &pwszDomainName,
                        GET_DNS_DOMAIN_NAME,
                        hwndDlg );
        RETURN_IF_FAIL;
        CStrListAdd( pplistMasterDNSDomains, pwszDomainName );
        LocalFreeStringW(&pwszDomainName);
    }

    //
    // read Global Catalog flag
    //
    spAttrs.Empty();
    cAttrs = 0;
    PWSTR rgpwszOptionsAttrNames[] = {L"options"};
    hr = spIDirectoryObject->GetObjectAttributes(
        rgpwszOptionsAttrNames, 1, &spAttrs, &cAttrs);
    RETURN_IF_FAIL;
    if (   !spAttrs
        || 1 != cAttrs
        || lstrcmpi( L"options", spAttrs[0].pszAttrName )
        || 1 != spAttrs[0].dwNumValues
        || NULL == spAttrs[0].pADsValues
        || ADSTYPE_INTEGER != spAttrs[0].dwADsType
       )
    {
        *pfGlobalCatalog = false;
    }
    else
    {
        *pfGlobalCatalog = !!(0x1 & spAttrs[0].pADsValues[0].Integer);
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   UpdateNamingContextFields
//
//  Synopsis:   Retrieves the names of the naming contexts common between the two
//              DCs linked by a connection, and saves this in two dialog controls
//
//-----------------------------------------------------------------------------
HRESULT
UpdateNamingContextFields(
    IN CDsPropPageBase* pPropPage, IN LPWSTR pwszFromServer, bool fInvalid )
{
    HRESULT hr = S_OK;
    DBG_OUT("UpdateNamingContextFields");

    // if a particular string should be displayed instead of a domain
    // name, it will be stored here
    int idsDisplayString = 0;

    // these are the actual messages to put in the readonly edit fields
    CStr strDomains;
    CStr strPartialDomains;

    CStrListItem* plistTargetDomains = NULL;
    CStrListItem* plistSourceDomains = NULL;
    bool fTargetIsGC = false;
    bool fSourceIsGC = false;

    do { // false loop

        if ( fInvalid )
        {
            idsDisplayString = IDS_INVALID;
            break;
        }
        else if ( NULL == pwszFromServer )
        {
            idsDisplayString = IDS_SHAREDNC_NO_FROM_SERVER;
            break;
        }

        // get path to target DC
        ASSERT( NULL != pPropPage->GetObjPathName() );
        CComBSTR sbstrTargetDC = pPropPage->GetObjPathName();
        ASSERT( !!sbstrTargetDC );
        hr = DSPROP_RemoveX500LeafElements( 1, &sbstrTargetDC );
        BREAK_IF_FAIL;

        // get path to source DC by combining the DN from the fromServer attribute
        // with the rest of the ADsPath from pPropPage->GetObjPathName()
        CPathCracker pathcracker;
        hr = pathcracker.Set( pPropPage->GetObjPathName(), ADS_SETTYPE_FULL );
        BREAK_IF_FAIL;
        hr = pathcracker.Set( pwszFromServer, ADS_SETTYPE_DN );
        BREAK_IF_FAIL;
        CComBSTR sbstrSourceDC;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500, &sbstrSourceDC );
        BREAK_IF_FAIL;

        CComBSTR sbstrTargetMasterDNSDomain;
        hr = GetReplicatedDomainInfo(
            sbstrTargetDC,
            pPropPage->GetHWnd(),
            &plistTargetDomains,
            &fTargetIsGC );
        if ( FAILED(hr) )
            break; // no assertion
        CComBSTR sbstrSourceMasterDNSDomain;
        hr = GetReplicatedDomainInfo(
            sbstrSourceDC,
            pPropPage->GetHWnd(),
            &plistSourceDomains,
            &fSourceIsGC );
        if ( FAILED(hr) )
            break; // no assertion

        // Determine which domains are replicated and partially replicated
        for ( CStrListItem* plistSource = plistSourceDomains;
              NULL != plistSource;
              plistSource = plistSource->pnext
            )
        {
            bool fSharedMasterDomain = CStrListContains(
                &plistTargetDomains,
                plistSource->str );
            if (fSharedMasterDomain)
            {
                if ( !strDomains.IsEmpty() )
                    strDomains += L", ";
                strDomains += plistSource->str;
            }
            else if (fTargetIsGC)
            {
                if ( !strPartialDomains.IsEmpty() )
                    strPartialDomains += L", ";
                strPartialDomains += plistSource->str;
            }
        }

        if ( strDomains.IsEmpty() )
        {
            idsDisplayString = IDS_SHAREDNC_NONE;
            break;
        }

    } while (false); // false loop

    FreeCStrList( &plistTargetDomains );
    FreeCStrList( &plistSourceDomains );

    //
    // Fill in the readonly edit fields
    //
    if ( FAILED(hr) )
    {
        PTSTR ptzMsg = NULL;
        LoadErrorMessage( hr, IDS_ADS_ERROR_FORMAT, &ptzMsg );
        strDomains = ptzMsg;
        strPartialDomains.Empty();
        delete ptzMsg;
    }
    else if (0 != idsDisplayString)
    {
        LPWSTR pszMsg = NULL;
        if ( !LoadStringToTchar (idsDisplayString, &pszMsg) )
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPropPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        strDomains = pszMsg;
        if (IDS_SHAREDNC_NONE != idsDisplayString)
            strPartialDomains.Empty();
        delete [] pszMsg;
    }
    else if (fTargetIsGC && fSourceIsGC)
    {
        // if both replicas are GCs then all other domains are replicated,
        // say so explicitly rather than listing them
        LPWSTR pszMsg = NULL;
        if ( !LoadStringToTchar (IDS_SHAREDNC_BOTH_GCS, &pszMsg) )
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPropPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        strPartialDomains = pszMsg;
        delete [] pszMsg;
    }

    // now we can finally write this to the dialog
    HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),IDC_EDIT1);
    ASSERT( NULL != hwndCtrl );
    Edit_SetText( hwndCtrl, strDomains );
    hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),IDC_EDIT2);
    ASSERT( NULL != hwndCtrl );
    Edit_SetText( hwndCtrl, strPartialDomains );

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   CreateDsOrFrsConnectionPage
//
//  Synopsis:   Creates an instance of a page window for an NTDS-Connection object.
//              This object has two different pages depending on whether its parent
//              is an NTDS-DSA or an NTFRS-Member.
//
//-----------------------------------------------------------------------------

extern DSPAGE DsConnectionGeneral;
extern DSPAGE FrsConnectionGeneral;

HRESULT
CreateDsOrFrsConnectionPage(PDSPAGE, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                      HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateNTDSConnectionPage);

    // generate path to parent
    CComBSTR sbstr = pwzADsPath;
    HRESULT hr = DSPROP_RemoveX500LeafElements( 1, &sbstr );
    RETURN_IF_FAIL;

    // open parent and get its classname
    {
        CComPtr<IADs> spIADsParent;
        hr = ADsOpenObject( sbstr, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                            IID_IADs, (PVOID*)&spIADsParent );
        RETURN_IF_FAIL;
        sbstr.Empty();
        hr = spIADsParent->get_Class( &sbstr );
        RETURN_IF_FAIL;
    }

    // determine whether parent is an FRS object
    bool fParentIsFrs = false;
    hr = DSPROP_IsFrsObject( sbstr, &fParentIsFrs );
    RETURN_IF_FAIL;

    // now create the page
    return CreateTableDrivenPage(
        (fParentIsFrs) ? (&FrsConnectionGeneral) : (&DsConnectionGeneral),
        pDataObj,
        pwzADsPath,
        pwzClass,
        hNotifyObj,
        dwFlags,
        pBasePathsInfo,
        phPage );
}


// Bit flags for options attribute on NTDS-Connection objects.
// CODEWORK these are defined in ds\src\inc\ntdsa.h
#define NTDSCONN_OPT_IS_GENERATED       ( 1 << 0 )  /* object generated by DS, not admin */

HRESULT
nTDSConnectionOptions(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA pAttrData,
             DLG_OP DlgOp)
{
  switch (DlgOp)
  {
  case fInit:
    if ( 1 == pAttrInfo->dwNumValues
      && NULL != pAttrInfo->pADsValues 
      && ADSTYPE_INTEGER == pAttrInfo->pADsValues[0].dwType
      && NTDSCONN_OPT_IS_GENERATED & pAttrInfo->pADsValues[0].Integer)
    {
      LPWSTR pszMsg = NULL;
      if ( LoadStringToTchar (IDS_CONNECTION_KCC_GENERATED, &pszMsg) )
      {
        SetDlgItemText( pPage->GetHWnd(), IDC_CN, pszMsg );
      }
      if ( pszMsg )
        delete [] pszMsg;

//
// 146897: RC2SS: Site&Rep:  Change Schedule on Connection does not make it Admin Controlled
//
// If this is a KCC-generated function, we set this attribute to "dirty" but not
// the page.  If some other attrfn sets the page dirty, ask the user whether he/she
// wants to save changes and mark the connection as no longer KCC-generated.
// Note that this is marked dirty even if the attribute is not writable.
//
// JonN 7/6/99
//
      PATTR_DATA_SET_DIRTY(pAttrData);
    }

    // remember attribute value in case this flag must be cleared
    if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
    {
      ASSERT( NULL != pAttrInfo->pADsValues && ADSTYPE_INTEGER == pAttrInfo->dwADsType );
      pAttrData->pVoid = static_cast<LPARAM>(pAttrInfo->pADsValues->Integer);
    }
    else
    {
      pAttrData->pVoid = NULL;
    }
    break;

  case fApply:
    {
      ASSERT( pPage->IsDirty() );

      if (!PATTR_DATA_IS_DIRTY(pAttrData))
      {
        return ADM_S_SKIP;
      }

      int nResponse = SuperMsgBox(pPage->GetHWnd(),
                                  (PATTR_DATA_IS_WRITABLE(pAttrData))
                                    ? IDS_CONNECTION_WARNING_MARK
                                    : IDS_CONNECTION_WARNING_CANNOT_MARK,
                                  0,
                                  MB_YESNO | MB_ICONEXCLAMATION,
                                  0,
                                  NULL, 0,
                                  FALSE, __FILE__, __LINE__);
      if (IDYES != nResponse)
        return E_FAIL; // cancel apply/OK action
      else if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        return ADM_S_SKIP; // continue but skip the options attribute

      PADSVALUE pADsValue;
      pADsValue = new ADSVALUE;
      CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
      pAttrInfo->pADsValues = pADsValue;
      pAttrInfo->dwNumValues = 1;
      pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
      ASSERT( ADSTYPE_INTEGER == pAttrInfo->dwADsType );
      pADsValue->dwType = pAttrInfo->dwADsType;
      pADsValue->Integer =
          ((ADS_INTEGER)((DWORD_PTR)pAttrData->pVoid)) & ~NTDSCONN_OPT_IS_GENERATED;
    }
    break;
  }

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   EditNumber
//
//  Synopsis:   General-purpose attribute function for ES_NUMBER edit controls with
//              associated spin button.  This must always be accompanied by
//              a "msctls_updown32" control with the SpinButton attribute function.
//              Set ATTR_MAP.pData to the controlID of the associated spin button.

//
//-----------------------------------------------------------------------------
HRESULT
EditNumber(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fInit:
        // JonN 7/2/99: disable if attribute not writable
        if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            EnableWindow(GetDlgItem(pPropPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);

        // setting value handled by the accompanying SpinButton

        break;

    case fApply:
        DBG_OUT("EditNumber: fApply");
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        if ( NULL == pPropPage || NULL == pAttrMap || NULL == pAttrInfo )
        {
            ASSERT(FALSE);
            break;
        }
        {
            BOOL fError = FALSE;
            ADS_INTEGER initialvalue = (ADS_INTEGER)::SendDlgItemMessage(
                    pPropPage->GetHWnd(),
                    pAttrMap->nSizeLimit, // ID of associated spin button
                    UDM_GETPOS32, 0, (LPARAM)&fError);
            //
            // JonN 12/7/99 434967:
            // UI writes bad value to the DS if replinterval
            // on the sitelink is less than 15 min (DSLAB)
            //
            if ( fError )
            {
                // set focus to proper control
                HWND hwndThis = ::GetDlgItem(
                    pPropPage->GetHWnd(),
                    pAttrMap->nCtrlID);
                ASSERT( NULL != hwndThis );
                (void) ::SendMessage(
                    pPropPage->GetHWnd(),
                    WM_NEXTDLGCTL,
                    (WPARAM)hwndThis,
                    1L );
                // display error message
                INT iLow = 0, iHigh = 0;
                (void) ::SendDlgItemMessage(
                    pPropPage->GetHWnd(),
                    pAttrMap->nSizeLimit, // ID of associated spin button
                    UDM_GETRANGE32, (WPARAM)&iLow, (LPARAM)&iHigh);
                PVOID pvArgs[2] = {
                    reinterpret_cast<PVOID>((unsigned __int64)((UINT)iLow)),
                    reinterpret_cast<PVOID>((unsigned __int64)((UINT)iHigh)) };
                (void) SuperMsgBox(
                    pPropPage->GetHWnd (),
                    IDS_OUT_OF_RANGE,
                    0,
                    MB_ICONWARNING,
                    0,
                    pvArgs, 2,
                    FALSE, __FILE__, __LINE__);
                hr = E_FAIL;
                break;
            }
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->Integer = initialvalue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPropPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   SpinButton
//
//  Synopsis:   General-purpose READONLY attribute function for spin buttons
//              accompaying EditNumber edit controls.  If you wish to limit
//              the spinbutton range, set ATTR_MAP.nSizeLimit to the high end
//              of the range and ATTR_MAP.pData to the low end of the range.
//
//-----------------------------------------------------------------------------
HRESULT
SpinButton(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fInit:
        DBG_OUT("SpinButton: fInit");
        if (NULL == pAttrMap ||
            NULL == pPropPage )
        {
            ASSERT(FALSE);
            break; // attribute is invalid or of wrong type
        }
        if (0 != pAttrMap->nSizeLimit)
        {
            ::SendDlgItemMessage( pPropPage->GetHWnd(),
                                  pAttrMap->nCtrlID,
                                  UDM_SETRANGE32,
                                  (WPARAM)pAttrMap->pData,
                                  (LPARAM)pAttrMap->nSizeLimit);
        }

        // JonN 7/2/99: disable if attribute not writable
        if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            EnableWindow(GetDlgItem(pPropPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);

        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
            1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_INTEGER != pAttrInfo->pADsValues[0].dwType )
        {
            break; // attribute is invalid or of wrong type
        }
        ::SendDlgItemMessage( pPropPage->GetHWnd(),
                              pAttrMap->nCtrlID,
                              UDM_SETPOS32,
                              0,
                              pAttrInfo->pADsValues[0].Integer );
        break;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   SpinButtonExtendIncrement
//
//  Synopsis:   Special-purpose attribute function for spin buttons to change
//              accelerator increment.  Use this as READONLY for controls which
//              already have a SpinButton attribute function.  Set ATTR_MAP.pData
//              to the integer multiple, e.g. 15 to move in increments of 15.
//
//-----------------------------------------------------------------------------
HRESULT
SpinButtonExtendIncrement(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
    LPARAM, PATTR_DATA, DLG_OP DlgOp )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fInit:
        DBG_OUT("SpinButtonExtendIncrement: fInit");
        if (NULL == pAttrMap ||
            NULL == pPropPage )
        {
            ASSERT(FALSE);
            break; // attribute is invalid or of wrong type
        }
        if (0 >= pAttrMap->nSizeLimit)
        {
            ASSERT(FALSE);
            break; // invalid increment
        }
        {
            LRESULT nAccels =
                ::SendDlgItemMessage( pPropPage->GetHWnd(),
                                      pAttrMap->nCtrlID,
                                      UDM_GETACCEL,
                                      (WPARAM)0,
                                      (LPARAM)NULL);

            if (nAccels == 0)
            {
              ASSERT( 0L <= nAccels );
              break;
            }

            LPUDACCEL aAccels = new UDACCEL[nAccels];
            if (!aAccels)
            {
              ASSERT(aAccels);
              break;
            }

            LRESULT nAccelsRetrieved =
                ::SendDlgItemMessage( pPropPage->GetHWnd(),
                                      pAttrMap->nCtrlID,
                                      UDM_GETACCEL,
                                      (WPARAM)nAccels,
                                      (LPARAM)aAccels);
            ASSERT( nAccelsRetrieved == nAccels );

            DWORD dwAccelMultiplier = pAttrMap->nSizeLimit;
            ASSERT( 0 < dwAccelMultiplier );
            for (LRESULT iAccel = 0; iAccel < nAccels; iAccel++)
            {
#define MAX_ACCEL_INTERVAL 10000
                if (aAccels[iAccel].nInc <= (MAX_ACCEL_INTERVAL/dwAccelMultiplier) )
                    aAccels[iAccel].nInc *= dwAccelMultiplier;
                else
                    aAccels[iAccel].nInc = MAX_ACCEL_INTERVAL;
            }
            BOOL fSuccess =
                (BOOL)::SendDlgItemMessage( pPropPage->GetHWnd(),
                                            pAttrMap->nCtrlID,
                                            UDM_SETACCEL,
                                            (WPARAM)nAccels,
                                            (LPARAM)aAccels);
            ASSERT( fSuccess );
            if (aAccels)
            {
              delete[] aAccels;
              aAccels = 0;
            }
        }

        break;
    }

    return hr;
}


int GetOctet( LPTSTR* ppszAddress )
{
    if ( NULL == ppszAddress || NULL == *ppszAddress )
    {
        ASSERT(FALSE);
        return 0;
    }
    LPTSTR pszOctet = *ppszAddress;
    LPTSTR pszDot = _tcschr(pszOctet, TEXT('.'));
    if (NULL != pszDot)
    {
        *pszDot = TEXT('\0');
        *ppszAddress = pszDot+1;
    }
    return _wtoi(pszOctet);
}

int GetMask( int* piCount )
{
    if ( NULL == piCount || 0 > *piCount || 32 < *piCount )
    {
        ASSERT(FALSE);
        return 0;
    }
    int iMask = 0xff;
    int iShiftCount = (8 - min(8, *piCount));
    iMask = iMask << iShiftCount;
    iMask = iMask & 0xff;
    *piCount = max( 0, (*piCount)-8 );
    return iMask;
}

HRESULT ExtractSubnetAddressAndMask(
    IN  LPCTSTR strSubnetName,
    OUT LPARAM* pdwAddress,
    OUT LPARAM* pdwMask )
{
  CComBSTR sbstrTemp = strSubnetName;
  LPTSTR pszAddress = sbstrTemp;

  if (pszAddress != NULL )
  {
    LPTSTR pszCount = _tcschr(pszAddress, TEXT('/'));
    if (NULL == pszCount)
        return S_OK; // bad subnet name
    *pszCount = TEXT('\0');
    pszCount++;

    if (NULL != pdwAddress)
    {
      int Octet1 = GetOctet( &pszAddress );
      int Octet2 = GetOctet( &pszAddress );
      int Octet3 = GetOctet( &pszAddress );
      int Octet4 = GetOctet( &pszAddress );
      *pdwAddress = MAKEIPADDRESS(Octet1,Octet2,Octet3,Octet4);
    }
    if (NULL != pdwMask)
    {
      int iCount = _wtoi( pszCount );
      int Octet1 = GetMask( &iCount );
      int Octet2 = GetMask( &iCount );
      int Octet3 = GetMask( &iCount );
      int Octet4 = GetMask( &iCount );
      *pdwMask = MAKEIPADDRESS(Octet1,Octet2,Octet3,Octet4);
    }
  }
  return S_OK;
}

HRESULT
SubnetExtractAddress(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit == DlgOp)
    {
        HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
        ASSERT( NULL != hwnd );
        (void) ::EnableWindow( hwnd, FALSE );
        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
            1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_CASE_IGNORE_STRING != pAttrInfo->pADsValues[0].dwType )
        {
            // attribute is invalid or of wrong type
        }
        else
        {
            LPARAM dwAddress = 0;
            ExtractSubnetAddressAndMask(
                pAttrInfo->pADsValues[0].CaseIgnoreString,
                &dwAddress,
                NULL );
            (void) ::SendMessage( hwnd, IPM_SETADDRESS, 0, dwAddress );
        }
    }
    return S_OK;
}

HRESULT
SubnetExtractMask(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit == DlgOp)
    {
        HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
        ASSERT( NULL != hwnd );
        (void) ::EnableWindow( hwnd, FALSE );
        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
            1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_CASE_IGNORE_STRING != pAttrInfo->pADsValues[0].dwType )
        {
            // attribute is invalid or of wrong type
        }
        else
        {
            LPARAM dwMask = 0;
            ExtractSubnetAddressAndMask(
                pAttrInfo->pADsValues[0].CaseIgnoreString,
                NULL,
                &dwMask );
            (void) ::SendMessage( hwnd, IPM_SETADDRESS, 0, dwMask );
        }
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   SiteExtractSubnetList
//
//  Synopsis:   Handle the Subnets listview in Site Properties
//
//  The HIMAGELIST should be destroyed automatically since I did not define
//  LVS_SHAREIMAGELIST.
//
//  History:
//  02/29/00    JonN        created
//
//-----------------------------------------------------------------------------

HRESULT
SiteExtractSubnetList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp)
        return S_OK;

    // add column to listview
    HWND hList = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
    ASSERT( NULL != hList );
    ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);
    RECT rect;
    ::ZeroMemory( &rect, sizeof(rect) );
    if ( !GetClientRect(hList, &rect) )
    {
        ASSERT(FALSE);
        return S_OK;
    }
    LV_COLUMN lvc;
    ::ZeroMemory( &lvc, sizeof(lvc) );
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right;
    lvc.iSubItem = 0;
    if (-1 == ListView_InsertColumn(hList, 0, &lvc) )
    {
        ASSERT(FALSE);
        return S_OK;
    }

    // add subnet icon to listview
    HIMAGELIST hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);
    HICON hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, L"subnet", 16, 16);
    int iIcon = -1;
    if (NULL != hImageList && NULL != hIcon)
    {
        iIcon = ImageList_AddIcon(hImageList, hIcon);
        if (-1 != iIcon)
        {
            if (NULL != ListView_SetImageList( hList, hImageList, LVSIL_SMALL ))
            {
                ASSERT(FALSE);
            }
        }
    }

    if (NULL != hIcon && 0 == DestroyIcon(hIcon))
    {
        ASSERT(FALSE);
    }

    // generate path to subnetsContainer
    const LPWSTR lpszObjPathName = pPage->GetObjPathName();
    if ( NULL == lpszObjPathName )
    {
        ASSERT(FALSE);
        return S_OK;
    }
    CPathCracker pathcracker;
    HRESULT hr = pathcracker.Set( lpszObjPathName, ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    CComBSTR sbstrSiteX500DN;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrSiteX500DN );
    RETURN_IF_FAIL;
    hr = pathcracker.RemoveLeafElement();
    RETURN_IF_FAIL;
    hr = pathcracker.AddLeafElement( L"CN=Subnets" );
    RETURN_IF_FAIL;
    CComBSTR sbstr;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500, &sbstr );
    RETURN_IF_FAIL;

    // build search filter
    CStr strFilterString;
    strFilterString.Format(L"(&(objectClass=subnet)(siteObject=%s))", sbstrSiteX500DN);

    // read list of subnets
    DSPROP_BSTR_BLOCK bstrblock;
    hr = DSPROP_ShallowSearch2(
        &bstrblock, 
        sbstr,
        strFilterString,
        pAttrInfo );
    RETURN_IF_FAIL;
    hr = pathcracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    RETURN_IF_FAIL;
    // CODEWORK escaped mode off?  Would that affect Set?

    // add subnets to list
    LVITEM lvitem;
    ::ZeroMemory( &lvitem, sizeof(lvitem) );
    lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvitem.iImage = iIcon;
    for (int i = 0; i < bstrblock.QueryCount(); i++)
    {
        hr = pathcracker.Set( bstrblock[i], ADS_SETTYPE_DN );
        RETURN_IF_FAIL;
        hr = pathcracker.GetElement( 0, &sbstr );
        RETURN_IF_FAIL;
        lvitem.pszText = sbstr;
        if (-1 == ListView_InsertItem( hList, &lvitem ))
        {
            ASSERT(FALSE);
        }
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   DsReplicateListbox
//
//  Synopsis:   Populate the listviews in the NTDS-DSA Connections page
//
//  CODEWORK    It would be nice if we could display failures to set up the
//              listbox or read its contents.  Sortable columns would also
//              be nice.
//
//  History:
//  04/20/00    JonN        created
//
//-----------------------------------------------------------------------------

bool PrepReplicateListbox(
    IN  HWND hwnd,
    OUT int& refIcon)
{
    if ( NULL == hwnd )
    {
        ASSERT(FALSE);
        return false;
    }
    ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

    // add columns
    RECT rect;
    ::ZeroMemory( &rect, sizeof(rect) );
    if ( !GetClientRect(hwnd, &rect) )
    {
        ASSERT(FALSE);
        return false;
    }

    // reserve horizontal space for the vertical scrollbar
    int cxScrollbar = ::GetSystemMetrics( SM_CXVSCROLL );
    if (rect.right > 3*cxScrollbar)
        rect.right -= cxScrollbar;

    LV_COLUMN lvc;
    ::ZeroMemory( &lvc, sizeof(lvc) );
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right/2;
    CStrW strColTitle;
    strColTitle.LoadString( g_hInstance, IDS_COL_TITLE_OBJNAME );
    lvc.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strColTitle));
    if ( -1 == ListView_InsertColumn(hwnd, 0, &lvc) )
    {
        ASSERT(FALSE);
    }
    lvc.cx = rect.right - lvc.cx;
    strColTitle.LoadString( g_hInstance, IDS_TITLE_SITE );
    lvc.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strColTitle));
    if ( -1 == ListView_InsertColumn(hwnd, 1, &lvc) )
    {
        ASSERT(FALSE);
    }

    // add NTDSDSA icon
    HIMAGELIST hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);
    HICON hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, L"nTDSDSA", 16, 16);
    if (NULL != hImageList && NULL != hIcon)
    {
        refIcon = ImageList_AddIcon(hImageList, hIcon);
        if (-1 != refIcon)
        {
            if (NULL != ListView_SetImageList( hwnd, hImageList, LVSIL_SMALL ))
            {
                ASSERT(FALSE);
            }
        }
    }

    if (NULL != hIcon && 0 == DestroyIcon(hIcon))
    {
        ASSERT(FALSE);
    }

    return true;
}

HRESULT
DsReplicateListbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp)
        return S_OK;

    HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
    int iIcon = -1;
    if ( NULL == hwnd || !PrepReplicateListbox( hwnd, iIcon ) )
    {
        return S_OK;
    }

    LVITEM lvitem;
    ::ZeroMemory( &lvitem, sizeof(lvitem) );
    lvitem.mask = LVIF_IMAGE | LVIF_TEXT;
    lvitem.iImage = iIcon;

    // prepare search parameters
    // fReplicateFrom : shallow search under nTDSDSA for all connection objects
    // !fReplicateFrom: deep search under sitesContainer for connection objects
    //                  pointing to nTDSDSA
    bool fReplicateFrom = (NULL == pAttrMap->pData);
    CComBSTR sbstrSearchPath = pPage->GetObjPathName();
    CStr strFilterString = L"(&(objectClass=nTDSConnection))";
    if (!fReplicateFrom) // ReplicateTo listbox
    {
        // search the subtree from the Sites container
        CPathCracker pathcracker;
        HRESULT hr = pathcracker.Set( pPage->GetObjPathName(),
                                      ADS_SETTYPE_FULL );
        RETURN_IF_FAIL;
        CComBSTR sbstrFromServerDN;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrFromServerDN );
        RETURN_IF_FAIL;
        for (int i = 0; i < 4; i++)
        {
            hr = pathcracker.RemoveLeafElement();
            RETURN_IF_FAIL;
        }
        sbstrSearchPath.Empty();
        hr = pathcracker.Retrieve( ADS_FORMAT_X500, &sbstrSearchPath );
        RETURN_IF_FAIL;

        // find only connections which point to this nTDSDSA
        strFilterString.Format(
            L"(&(objectClass=nTDSConnection)(fromServer=%s))",
            sbstrFromServerDN);

    }
    CDSSearch Search;
    Search.Init(sbstrSearchPath);
    Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strFilterString));
    Search.SetSearchScope( (fReplicateFrom) ? ADS_SCOPE_ONELEVEL : ADS_SCOPE_SUBTREE );
    LPWSTR pAttrs[1] = {(fReplicateFrom) ? L"fromServer" : L"distinguishedName"};
    Search.SetAttributeList(pAttrs, 1);
    HRESULT hr = Search.DoQuery();
    while (SUCCEEDED(hr)) {
        hr = Search.GetNextRow();
        if (S_ADS_NOMORE_ROWS == hr)
        {
            hr = S_OK;
            break;
        }
        BREAK_IF_FAIL;

        ADS_SEARCH_COLUMN col;
        ::ZeroMemory( &col, sizeof(col) );
        hr = Search.GetColumn (pAttrs[0], &col);
        BREAK_IF_FAIL;
        ASSERT( ADSTYPE_DN_STRING == col.pADsValues->dwType );

        CPathCracker pathcracker;
        hr = pathcracker.Set( col.pADsValues->DNString,
                                 ADS_SETTYPE_DN );
        Search.FreeColumn (&col);
        BREAK_IF_FAIL;
        hr = pathcracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_IF_FAIL;
        // JonN 6/22/00
        hr = pathcracker.put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
        BREAK_IF_FAIL;
        CComBSTR sbstrName;
        hr = pathcracker.GetElement( (fReplicateFrom) ? 1 : 2, &sbstrName );
        BREAK_IF_FAIL;
        CComBSTR sbstrSite;
        hr = pathcracker.GetElement( (fReplicateFrom) ? 3 : 4, &sbstrSite );
        BREAK_IF_FAIL;

        lvitem.iItem = ListView_GetItemCount(hwnd);
        lvitem.pszText = sbstrName;
        int iItem = ListView_InsertItem( hwnd, &lvitem );
        if (-1 == iItem)
        {
            ASSERT(FALSE);
            break;
        }
        ListView_SetItemText( hwnd, iItem, 0, sbstrName );
        ListView_SetItemText( hwnd, iItem, 1, sbstrSite );
    }

    // select first item if any
    if (0 < ListView_GetItemCount( hwnd ))
    {
        ListView_SetItemState( hwnd, 0, LVIS_SELECTED, 0xFF );
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   NTDSDSA_DNSAlias
//
//  Synopsis:   Populate DNS Alias in the NTDS-DSA General page
//
//  History:
//  04/26/00    JonN        created
//
//-----------------------------------------------------------------------------

HRESULT
NTDSDSA_DNSAlias(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp)
        return S_OK;

    if (   NULL == pAttrInfo
        || 1 != pAttrInfo->dwNumValues
        || NULL == pAttrInfo->pADsValues
        || pAttrInfo->pADsValues[0].dwType != ADSTYPE_OCTET_STRING
        || sizeof(GUID) != pAttrInfo->pADsValues[0].OctetString.dwLength
        || NULL == pAttrInfo->pADsValues[0].OctetString.lpValue
       )
    {
        ASSERT(FALSE);
        return S_OK;
    }

    LPOLESTR lpolestr = NULL;
    GUID* pguidObjID = (GUID*)pAttrInfo->pADsValues[0].OctetString.lpValue;
    HRESULT hr = ::StringFromIID( *pguidObjID, &lpolestr );
    if (FAILED(hr) || NULL == lpolestr || !(*lpolestr))
    {
        ASSERT(FALSE);
        return S_OK;
    }

    // remove leading ('{') and trailing ('}') characters
    lpolestr[wcslen(lpolestr)-1] = _T('\0');
    CStr str = lpolestr+1;
    CoTaskMemFree(lpolestr);

    // extract the domain name from the path to this object
    CPathCracker pathcracker;
    hr = pathcracker.Set( pPage->GetObjPathName(), ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    CComBSTR sbstrDN;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrDN );
    RETURN_IF_FAIL;
    PWSTR pwszDomainName = NULL;
    hr = CrackName( sbstrDN,
                    &pwszDomainName,
                    GET_DNS_DOMAIN_NAME,
                    pPage->GetHWnd() );
    RETURN_IF_FAIL;

    // construct the DNS alias
    str += _T("._msdcs.");
    str += pwszDomainName;
    LocalFreeStringW(&pwszDomainName);

    SetDlgItemText( pPage->GetHWnd(), pAttrMap->nCtrlID, str );

	return S_OK;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\scopedelegation.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       ScopeDelegation.cxx
//
//  Contents:   CDsScopeDelegationPage, the class that implements the Delegation
//              property page for user and computer object
//              
//
//  History:    06-April-2001 JeffJon created
//
//-----------------------------------------------------------------------------

#include "pch.h"

#include "ScopeDelegation.h"
#include "pcrack.h"

extern "C"
{
   #include <ntdsapip.h>   // DsCrackSpn3W
}
#include <dnsapi.h>

#ifdef DSADMIN

// This filter will be passed to Object Picker to search for all users and computers that
// have a value for the servicePrincipalName

static PCWSTR g_pszOPSPNFilter = 
   L"(&(servicePrincipalName=*)(|(samAccountType=805306368)(samAccountType=805306369)))";


// Index for each column in list

static const int IDX_SERVICE_TYPE_COLUMN = 0;
static const int IDX_USER_OR_COMPUTER_COLUMN = 1;
static const int IDX_PORT_COLUMN = 2;
static const int IDX_SERVICE_NAME_COLUMN = 3;
static const int IDX_DOMAIN_COLUMN = 4;

// Default width for each column in list

static const int SERVICE_TYPE_COLWIDTH = 80;
static const int USER_OR_COMPUTER_COLWIDTH = 120;
static const int PORT_COLWIDTH = 35;
static const int SERVICE_NAME_COLWIDTH = 80;
static const int DOMAIN_COLWIDTH = 80;


//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::CServiceAllowedToDelegate
//
//  Synopsis:   Copy constructor
//
//-----------------------------------------------------------------------------
CServiceAllowedToDelegate::CServiceAllowedToDelegate(const CServiceAllowedToDelegate& ref)
{
   if (this == &ref)
   {
      dspAssert(this != &ref);
      return;
   }

   Assign(ref);
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::operator=
//
//  Synopsis:   Assignment operator
//
//-----------------------------------------------------------------------------
const CServiceAllowedToDelegate& 
CServiceAllowedToDelegate::operator=(const CServiceAllowedToDelegate& ref)
{
   if (this == &ref)
   {
      dspAssert(this != &ref);
      return *this;
   }

   Assign(ref);
   return *this;
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::Assign
//
//  Synopsis:   Actually does the assignment for the operator= 
//              and copy constructor
//
//-----------------------------------------------------------------------------
void CServiceAllowedToDelegate::Assign(const CServiceAllowedToDelegate& ref)
{
   m_strADSIValue = ref.m_strADSIValue;
   m_strServiceType = ref.m_strServiceType;
   m_strUserOrComputer = ref.m_strUserOrComputer;
   m_strPort = ref.m_strPort;
   m_strServiceName = ref.m_strServiceName;
   m_strRealm = ref.m_strRealm;
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::Initialize
//
//  Synopsis:   Initializes the CServiceAllowedToDelegate object with the value
//              from the msDS-AllowedToDelegateTo attribute
//
//-----------------------------------------------------------------------------

HRESULT CServiceAllowedToDelegate::Initialize(PCWSTR pszADSIValue)
{
   HRESULT hr = S_OK;

   dspAssert(pszADSIValue);

   m_strADSIValue = pszADSIValue;
   
   WCHAR pszHostName[DNS_MAX_NAME_LENGTH + 1];
   WCHAR pszInstanceName[DNS_MAX_NAME_LENGTH + 1];
   WCHAR pszDomainName[DNS_MAX_NAME_LENGTH + 1];
   WCHAR pszRealmName[DNS_MAX_NAME_LENGTH + 1];

   ZeroMemory(pszHostName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));
   ZeroMemory(pszInstanceName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));
   ZeroMemory(pszDomainName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));
   ZeroMemory(pszRealmName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));

   DWORD dwHostNameCount = DNS_MAX_NAME_LENGTH + 1;
   DWORD dwInstanceNameCount = DNS_MAX_NAME_LENGTH + 1;
   DWORD dwDomainNameCount = DNS_MAX_NAME_LENGTH + 1;
   DWORD dwRealmNameCount = DNS_MAX_NAME_LENGTH + 1;
   USHORT portNumber = 0;

   DWORD result = DsCrackSpn3W(m_strADSIValue,
                               m_strADSIValue.GetLength(),
                               &dwHostNameCount,
                               pszHostName,
                               &dwInstanceNameCount,
                               pszInstanceName,
                               &portNumber,
                               &dwDomainNameCount,
                               pszDomainName,
                               &dwRealmNameCount,
                               pszRealmName);

   if (ERROR_SUCCESS == result)
   {
      m_strServiceType = pszHostName;
      m_strUserOrComputer = pszInstanceName;
      m_strServiceName = pszDomainName;
      m_strRealm = pszRealmName;

      if (0 != portNumber)
      {
         m_strPort.Format(L"%d", portNumber);
      }
   }
   else
   {
      hr = HRESULT_FROM_WIN32(result);
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::operator==
//
//  Synopsis:   Checks for equality of the SPN by the following rules
//                1. By full ADSI value
//                2. If ALL of the following are true
//                     a. Service type are equal
//                     b. User/Computer name are equal or derivates
//                        of each other (i.e. DNS name and Netbios name for
//                        the same computer)
//
//-----------------------------------------------------------------------------
bool
CServiceAllowedToDelegate::operator==(const CServiceAllowedToDelegate& rhs) const
{
   bool result = false;

   do
   {
      if (_wcsicmp(m_strADSIValue, rhs.m_strADSIValue) == 0)
      {
         result = true;
         break;
      }

      if (_wcsicmp(m_strServiceType, rhs.m_strServiceType) != 0)
      {
         // Service types are not the same so they couldn't be equal

         result = false;
         break;
      }

      // if ports are not equal or realms are not equal, then the SPNs
      // are not equal

      if (_wcsicmp(m_strPort, rhs.m_strPort) != 0 ||
          _wcsicmp(m_strRealm, rhs.m_strRealm) != 0)
      {
         result = false;
         break;
      }

      if (_wcsicmp(m_strUserOrComputer, rhs.m_strUserOrComputer) == 0)
      {
         result = true;
         break;
      }

      // Now we have to check derivations of the computer/user names

      WCHAR szComputerNameThis[MAX_COMPUTERNAME_LENGTH + 1];
      ZeroMemory(szComputerNameThis, sizeof(WCHAR) * (MAX_COMPUTERNAME_LENGTH + 1));

      WCHAR szComputerNameRHS[MAX_COMPUTERNAME_LENGTH + 1];
      ZeroMemory(szComputerNameRHS, sizeof(WCHAR) * (MAX_COMPUTERNAME_LENGTH + 1));

      DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
      BOOL bComputerNameThis = DnsHostnameToComputerName(m_strUserOrComputer, 
                                                         szComputerNameThis,
                                                         &dwSize);
      dwSize = MAX_COMPUTERNAME_LENGTH + 1;
      BOOL bComputerNameRHS = DnsHostnameToComputerName(rhs.m_strUserOrComputer,
                                                        szComputerNameRHS,
                                                        &dwSize);

      if (bComputerNameThis)
      {
         // Compare this services NetBIOS name to the others name as given by the SPN

         if (_wcsicmp(szComputerNameThis, rhs.m_strUserOrComputer) == 0)
         {
            result = true;
            break;
         }

         // Compare this services NetBIOS name to the NetBIOS name of the other service

         if (bComputerNameRHS &&
             _wcsicmp(szComputerNameThis, szComputerNameRHS) == 0)
         {
            result = true;
            break;
         }
      }

      // Compare the name given in the SPN for this service with the NetBios name of
      // the other service

      if (bComputerNameRHS &&
          _wcsicmp(m_strUserOrComputer, szComputerNameRHS) == 0)
      {
         result = true;
         break;
      }

   } while (false);

   return result;
}
//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::GetColumn
//
//  Synopsis:   Returns a string that will be placed in the specified column
//              in the list
//
//-----------------------------------------------------------------------------
PCWSTR CServiceAllowedToDelegate::GetColumn(int column) const
{
   if (IDX_SERVICE_TYPE_COLUMN == column)
   {
      return m_strServiceType;
   }
   
   if (IDX_USER_OR_COMPUTER_COLUMN == column)
   {
      return m_strUserOrComputer;
   }

   if (IDX_PORT_COLUMN == column)
   {
      return m_strPort;
   }

   if (IDX_SERVICE_NAME_COLUMN == column)
   {
      return m_strServiceName;
   }

   if (IDX_DOMAIN_COLUMN == column)
   {
      return m_strRealm;
   }

   return L"";
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::SetServiceType
//
//  Synopsis:   Changes the service type and recreates the m_strADSIValue
//              to match
//
//-----------------------------------------------------------------------------
void CServiceAllowedToDelegate::SetServiceType(PCWSTR pszServiceType)
{
   if (!pszServiceType)
   {
      dspAssert(pszServiceType);
      return;
   }

   // Pull off everything before the first / and replace it with the new value

   int iFind = m_strADSIValue.Find(L'/');
   if (iFind != -1)
   {
      CStr strTemp = m_strADSIValue.Right(m_strADSIValue.GetLength() - iFind);
      m_strADSIValue = pszServiceType;
      m_strADSIValue += strTemp;
   }

   // Also replace the old service type with the new one

   m_strServiceType = pszServiceType;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNListView::~CSPNListView
//
//-----------------------------------------------------------------------------
CSPNListView::~CSPNListView()
{
   ClearUnSelectedServices();
   m_AllServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::Initialize
//
//  Synopsis:   Initializes the list view by adding columns etc.
//
//-----------------------------------------------------------------------------
HRESULT CSPNListView::Initialize(HWND hwnd)
{
   if (!hwnd ||
       !IsWindow(hwnd))
   {
      dspAssert(hwnd);
      dspAssert(IsWindow(hwnd));

      return E_INVALIDARG;
   }

   HRESULT hr = S_OK;
   m_hWnd = hwnd;

   ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

   //
   // Set the column headings.
   //
   PTSTR ptsz = 0;

   if (!LoadStringToTchar(IDS_SERVICE_TYPE_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   LV_COLUMN lvc = {0};
   lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   lvc.fmt = LVCFMT_LEFT;
   lvc.cx = SERVICE_TYPE_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_SERVICE_TYPE_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_SERVICE_TYPE_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_USER_OR_COMPUTER_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   lvc.cx = USER_OR_COMPUTER_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_USER_OR_COMPUTER_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_USER_OR_COMPUTER_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_PORT_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   lvc.cx = PORT_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_PORT_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_PORT_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_SERVICE_NAME_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   // Service Name

   lvc.cx = SERVICE_NAME_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_SERVICE_NAME_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_SERVICE_NAME_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_DOMAIN_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   // Realm

   lvc.cx = DOMAIN_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_DOMAIN_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_DOMAIN_COLUMN, &lvc);

   delete[] ptsz;

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::ClearSelectedServices
//
//  Synopsis:   Clears all the values out of the selected services list
//
//-----------------------------------------------------------------------------
void CSPNListView::ClearSelectedServices()
{
   for (AllowedServicesContainer::iterator itr = m_SelectedServices.begin();
        itr != m_SelectedServices.end();
        ++itr)
   {
      m_AllServices.remove(*itr);
      delete *itr;
   }

   m_SelectedServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::ClearUnSelectedServices
//
//  Synopsis:   Clears all the values out of the unselected services list
//
//-----------------------------------------------------------------------------
void CSPNListView::ClearUnSelectedServices()
{
   for (AllowedServicesContainer::iterator itr = m_UnSelectedServices.begin();
        itr != m_UnSelectedServices.end();
        ++itr)
   {
      m_AllServices.remove(*itr);
      delete *itr;
   }

   m_UnSelectedServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::ClearAll
//
//  Synopsis:   Clears all the values out of the list view and from the containers
//
//-----------------------------------------------------------------------------
void CSPNListView::ClearAll()
{
   ListView_DeleteAllItems(m_hWnd);

   for (AllowedServicesContainer::iterator itr = m_AllServices.begin();
        itr != m_AllServices.end();
        ++itr)
   {
      delete *itr;
   }

   m_AllServices.clear();
   m_SelectedServices.clear();
   m_UnSelectedServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNListView::SelectAll
//
//  Synopsis:   Selects all the items in the list and then forces a redraw
//
//-----------------------------------------------------------------------------
void CSPNListView::SelectAll()
{
   LRESULT lCount = SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0);

   LVITEM lvi;
   ZeroMemory(&lvi, sizeof(LVITEM));

   lvi.mask = LVIF_STATE;
   lvi.stateMask = LVIS_SELECTED;
   lvi.state = LVIS_SELECTED;

   LRESULT lSuccess = SendMessage(m_hWnd, LVM_SETITEMSTATE, (WPARAM)-1, (LPARAM)&lvi);
   dspAssert(lSuccess);

   SetFocus(m_hWnd);
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::FindService
//
//  Synopsis:   Looks for a specific service in the current list.  It compares
//
//
//-----------------------------------------------------------------------------
CServiceAllowedToDelegate* 
CSPNListView::FindService(CServiceAllowedToDelegate* pService)
{
   if (!pService)
   {
      dspAssert(pService);
      return 0;
   }

   CServiceAllowedToDelegate* result = 0;

   for (AllowedServicesContainer::iterator itr = m_AllServices.begin();
        itr != m_AllServices.end();
        ++itr)
   {
      if (*itr == pService)
      {
         result = *itr;
         break;
      }
   }
   return result;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::AddService
//
//  Synopsis:   Adds a service to the list view and the internal data containers
//              Returns the new index of the item added
//
//-----------------------------------------------------------------------------
int CSPNListView::AddService(CServiceAllowedToDelegate* pService, bool selected)
{
   if (!pService)
   {
      dspAssert(pService);
      return -1;
   }

   int NewIndex = -1;

   if (!FindService(pService))
   {
      // Add the value to the list

      LV_ITEM lvi = {0};
      lvi.mask = LVIF_TEXT | LVIF_PARAM;
      lvi.iSubItem = IDX_SERVICE_TYPE_COLUMN;

      lvi.lParam = (LPARAM)pService;
      lvi.pszText = (PWSTR)(PCWSTR)pService->GetColumn(IDX_SERVICE_TYPE_COLUMN);

      // Insert at the end of the list
      lvi.iItem = ListView_GetItemCount(m_hWnd) + 1;

      if (selected)
      {
         lvi.mask |= LVIF_STATE;
         lvi.stateMask = LVIS_SELECTED;
         lvi.state = LVIS_SELECTED;
      }

      //
      // Insert the new item
      //
      NewIndex = ListView_InsertItem(m_hWnd, &lvi);
      dspAssert(NewIndex != -1);
      if (NewIndex == -1)
      {
         return NewIndex;
      }

      // Add each additional column

      for (int column = IDX_USER_OR_COMPUTER_COLUMN; column <= IDX_DOMAIN_COLUMN; ++column)
      {
         ListView_SetItemText(m_hWnd, NewIndex, column, (PWSTR)pService->GetColumn(column));
      }

      m_AllServices.push_back(pService);
   
      if (selected)
      {
         m_SelectedServices.push_back(pService);
      }
      else
      {
         m_UnSelectedServices.push_back(pService);
      }
   }
   return NewIndex;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::AddServices
//
//  Synopsis:   Adds a list of services to the list view 
//              and the internal data containers
//
//-----------------------------------------------------------------------------
void CSPNListView::AddServices(const AllowedServicesContainer& servicesToAdd, bool selected)
{
   for (AllowedServicesContainer::iterator itr = servicesToAdd.begin();
        itr != servicesToAdd.end();
        ++itr)
   {
      AddService(*itr, selected); 
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::RemoveSelectedServices
//
//  Synopsis:   Removes the selected services from the list and the containers
//
//-----------------------------------------------------------------------------
void CSPNListView::RemoveSelectedServices()
{
   // Loop through the selected items in the list
   int nSelectedItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
   int nFirstSelection = nSelectedItem;

   while (nSelectedItem != -1)
   {
      // Extract the pointer from the LPARAM

      LVITEM lvi = {0};
      lvi.iItem = nSelectedItem;
      lvi.mask = LVIF_PARAM;

      if (ListView_GetItem(m_hWnd, &lvi))
      {
         // Add the item to the selected services container
         CServiceAllowedToDelegate* pService = reinterpret_cast<CServiceAllowedToDelegate*>(lvi.lParam);
         if (pService)
         {
            // remove it from the services container
            m_AllServices.remove(pService);
            m_UnSelectedServices.remove(pService);
            m_SelectedServices.remove(pService);
            delete pService;

            // remove it from the UI
            ListView_DeleteItem(m_hWnd, nSelectedItem);
         }
         else
         {
            // There should be no reason to have an LPARAM that isn't
            // a CServiceAllowedToDelegate
            dspAssert(pService);
         }
      }

      // Always start at the beginning since we are removing.  That will guarantee
      // that we get everything

      nSelectedItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
   }

   // Now select the item that replaced the first selected item in the list

   LVITEM lvi;
   ZeroMemory(&lvi, sizeof(LVITEM));

   lvi.mask = LVIF_STATE;
   lvi.stateMask = LVIS_SELECTED;
   lvi.state = LVIS_SELECTED;

   ListView_SetItemState(m_hWnd, nFirstSelection, LVIS_SELECTED, LVIS_SELECTED);
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::SetContainersFromSelection
//
//  Synopsis:   Reads the selection from the list and rearranges the internal
//              containers as necessary.
//
//-----------------------------------------------------------------------------
void CSPNListView::SetContainersFromSelection()
{
   // Clear out the selected container
   m_SelectedServices.clear();

   // Loop through the selected items in the list
   int nSelectedItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
   while (nSelectedItem != -1)
   {
      // Extract the pointer from the LPARAM

      LVITEM lvi = {0};
      lvi.iItem = nSelectedItem;
      lvi.mask = LVIF_PARAM;

      if (ListView_GetItem(m_hWnd, &lvi))
      {
         // Add the item to the selected services container
         CServiceAllowedToDelegate* pService = reinterpret_cast<CServiceAllowedToDelegate*>(lvi.lParam);
         if (pService)
         {
            // Remove the service from the unselected container
            m_UnSelectedServices.remove(pService);

            // Add the service to the selected services container
            m_SelectedServices.push_back(pService);
         }
         else
         {
            dspAssert(pService);
         }
      }

      nSelectedItem = ListView_GetNextItem(m_hWnd, nSelectedItem, LVNI_SELECTED);
   }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsScopeDelegationPage::CDsScopeDelegationPage
//
//-----------------------------------------------------------------------------
CDsScopeDelegationPage::CDsScopeDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                               HWND hNotifyObj, DWORD dwFlags,
                                               SCOPE_DELEGATION_TYPE scopeDelegationType) :
    m_hList(0),
    m_scopeDelegationType(scopeDelegationType),
    m_fUACWritable(FALSE),
    m_fA2D2Writable(FALSE),
    m_oldUserAccountControl(0),
    m_newUserAccountControl(0),
    m_bA2D2Dirty(false),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsScopeDelegationPage,CDsScopeDelegationPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsScopeDelegationPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsScopeDelegationPage::~CDsScopeDelegationPage
//
//-----------------------------------------------------------------------------
CDsScopeDelegationPage::~CDsScopeDelegationPage()
{
  TRACE(CDsScopeDelegationPage,~CDsScopeDelegationPage);

  for (FreebiesContainer::iterator itr = m_FreebiesList.begin();
       itr != m_FreebiesList.end();
       ++itr)
  {
     delete *itr;
  }
}

//+----------------------------------------------------------------------------
//
//  Function:   UserAccountContainsSPNs
//
//  Synopsis:   Queries the DS to see if the user account contains any SPNs
//
//-----------------------------------------------------------------------------
bool UserAccountContainsSPNs(PCWSTR pwzADsPath)
{
   TRACE_FUNCTION(UserAccountContainsSPNs);

   bool result = false;

   do
   {
      if (!pwzADsPath)
      {
         ASSERT(pwzADsPath);
         result = false;
         break;
      }

      CComPtr<IDirectoryObject> spObject;
      HRESULT hr = ADsOpenObject(pwzADsPath,
                                 NULL,
                                 NULL,
                                 ADS_SECURE_AUTHENTICATION,
                                 IID_IDirectoryObject,
                                 (void**)&spObject);
      if (FAILED(hr))
      {
         break;
      }

      PWSTR ppszAttrs[] = { g_wzSPN };
      PADS_ATTR_INFO pAttrInfo = 0;
      DWORD dwNumAttrs = 0;

      hr = spObject->GetObjectAttributes(ppszAttrs,
                                         1,
                                         &pAttrInfo,
                                         &dwNumAttrs);
      if (FAILED(hr) || !dwNumAttrs)
      {
         break;
      }

      FreeADsMem(pAttrInfo);
      result = true;

   } while (false);

   return result;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserDelegationPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateUserDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                         PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                         CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateUserDelegationPage);

    // This page will only be added if the domain version is Whistler or greater
    // and the user account contains SPNs
    // NOTE : default to not showing the page unless we can prove this is a
    //        a Whislter or greater domain

    HRESULT hr = S_OK;

    if (pBasePathsInfo && 
        pBasePathsInfo->GetDomainBehaviorVersion() >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS &&
        UserAccountContainsSPNs(pwzADsPath))
    {
       CDsScopeDelegationPage * pPageObj = new CDsScopeDelegationPage(pDsPage, pDataObj,
                                                                      hNotifyObj, dwFlags,
                                                                      SCOPE_DELEGATION_USER);
       CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

       pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

       hr = pPageObj->CreatePage(phPage);
    }
    else
    {
       // Don't show the page

       hr = S_FALSE;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateComputerDelegationPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateComputerDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                             PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                             CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateComputerDelegationPage);

    // This page will only be added if the domain version is Whistler or greater
    // NOTE : default to not showing the page unless we can prove this is a
    //        a Whislter or greater domain

    HRESULT hr = S_OK;

    if (pBasePathsInfo && pBasePathsInfo->GetDomainBehaviorVersion() >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
    {
       CDsScopeDelegationPage * pPageObj = new CDsScopeDelegationPage(pDsPage, pDataObj,
                                                                      hNotifyObj, dwFlags,
                                                                      SCOPE_DELEGATION_COMPUTER);
       CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

       pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

       hr = pPageObj->CreatePage(phPage);
    }
    else
    {
       // Don't show the page

       hr = S_FALSE;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsScopeDelegationPage::OnInitDialog(LPARAM)
{
    TRACE(CDsScopeDelegationPage,OnInitDialog);

    HRESULT hr = S_OK;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    m_fUACWritable = CheckIfWritable(g_wzUserAccountControl);
    m_fA2D2Writable = CheckIfWritable(g_wzA2D2);
    m_fUACWritable = TRUE;
    m_fA2D2Writable = TRUE;

    // Get Freebies list

    GetFreebiesList();

    // Remove button should be disabled until something is selected
    // in the list
    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);

    SetPageTextForType();
    m_ServicesList.Initialize(GetDlgItem(m_hPage, IDC_SERVICES_LIST));

    LoadDataFromObject();
    SetUIFromData();

    OnUpdateRadioSelection();

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::GetFreebiesList
//
//  Synopsis:   Reads the freebies list from the following DS container
//              CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration...
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::GetFreebiesList()
{
   // Make sure the list is clear

   m_FreebiesList.clear();

   PWSTR pszDSPath = 0;
   PADS_ATTR_INFO pAttrInfo = 0;

   do
   {
      // Compose the path to the DS node in the config container

      CStr configDN = GetBasePathsInfo()->GetConfigNamingContext();
      CStr directoryServiceDN = L"CN=Directory Service,CN=Windows NT,CN=Services,";
      directoryServiceDN += configDN;

      GetBasePathsInfo()->ComposeADsIPath(&pszDSPath, directoryServiceDN);
      if (!pszDSPath)
      {
         break;
      }

      CComPtr<IDirectoryObject> spDirObject;
      HRESULT hr = ADsOpenObject(pszDSPath,
                                 NULL,
                                 NULL,
                                 ADS_SECURE_AUTHENTICATION,
                                 IID_IDirectoryObject,
                                 (void**)&spDirObject);
      if (FAILED(hr))
      {
         break;
      }

      DWORD dwNumAttributes = 1;
      PWSTR ppszAttributes[] = { g_wzSPNMappings };
      DWORD dwReturned = 0;

      hr = spDirObject->GetObjectAttributes(ppszAttributes,
                                            dwNumAttributes,
                                            &pAttrInfo,
                                            &dwReturned);
      if (FAILED(hr) ||
          !pAttrInfo ||
          !dwReturned)
      {
         break;
      }

      // Add the values to the freebies list
      dspAssert(_wcsicmp(pAttrInfo->pszAttrName, g_wzSPNMappings) == 0);
      
      for (DWORD idx = 0; idx < pAttrInfo->dwNumValues; ++idx)
      {
         // Value should be in the form service=alias,alias,alias,...
         // so break it apart

         CStr value = pAttrInfo->pADsValues[idx].CaseIgnoreString;
         int iFind = value.Find(L'=');
         if (iFind != -1)
         {
            CStr temp = value.Left(iFind);
            CFreebieService* pFreebieService = new CFreebieService(temp);
            if (!pFreebieService)
            {
               break;
            }

            CStr remaining = value;
            do
            {
               remaining = remaining.Right(remaining.GetLength() - iFind - 1);
               iFind = remaining.Find(L',');
               if (iFind != -1)
               {
                  temp = remaining.Left(iFind);
                  pFreebieService->AddFreebie(temp);
               }

               if (iFind == -1 &&
                   remaining.GetLength())
               {
                  pFreebieService->AddFreebie(remaining);
               }
            } while (iFind != -1);

            m_FreebiesList.push_back(pFreebieService);
         }
      }

   } while (false);

   if (pszDSPath)
   {
      delete[] pszDSPath;
   }

   if (pAttrInfo)
   {
      FreeADsMem(pAttrInfo);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::LoadDataFromObject
//
//  Synopsis:   Reads the userAccountControl and A2D2 from the object
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::LoadDataFromObject()
{
   HRESULT hr = S_OK;
   PADS_ATTR_INFO pAttrs = 0;

   do
   {
      PWSTR rgpwzAttrNames[] = { g_wzUserAccountControl, g_wzA2D2 };

      DWORD cAttrs = 0;

      hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames,
                                         ARRAYLENGTH(rgpwzAttrNames),
                                         &pAttrs, 
                                         &cAttrs);
      if (!CHECK_ADS_HR(&hr, GetHWnd()))
      {
         break;
      }

      if (!cAttrs ||
          !pAttrs)
      {
         break;
      }

      for (DWORD idx = 0; idx < cAttrs; idx++)
      {
         dspAssert(pAttrs[idx].dwNumValues);
         dspAssert(pAttrs[idx].pADsValues);

         if (_wcsicmp(pAttrs[idx].pszAttrName, g_wzUserAccountControl) == 0)
         {
            m_oldUserAccountControl = pAttrs[idx].pADsValues->Integer;
            m_newUserAccountControl = m_oldUserAccountControl;
            continue;
         }

         if (_wcsicmp(pAttrs[idx].pszAttrName, g_wzA2D2) == 0)
         {
            // Create a service object for each entry

            for (DWORD valueIdx = 0; valueIdx < pAttrs[idx].dwNumValues; ++valueIdx)
            {
               CServiceAllowedToDelegate* pService = new CServiceAllowedToDelegate();
               if (pService)
               {
                  // Initialize the entry with the value from A2D2

                  hr = pService->Initialize(pAttrs[idx].pADsValues[valueIdx].CaseIgnoreString);
                  if (SUCCEEDED(hr))
                  {
                     // Add the new value to the container

                     m_ServicesList.AddService(pService);
                  }
                  else
                  {
                     // Note: this means that entries that are not the proper format will
                     //       not be added to the list and no error will be given.

                     dspAssert(SUCCEEDED(hr));
                  }
               }
            }

         }
      }

   } while (false);

   if (pAttrs)
   {
      FreeADsMem(pAttrs);
   }
}
   
//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::SetUIFromData
//
//  Synopsis:   Sets the UI controls based on the data read from the object
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::SetUIFromData()
{
   bool bTrustForDelegation = (m_oldUserAccountControl & UF_TRUSTED_FOR_DELEGATION) != 0;
   bool bAnyProtocol = (m_oldUserAccountControl & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) != 0;

   const AllowedServicesContainer& A2D2Values = m_ServicesList.GetAllServices();

   if (!bTrustForDelegation &&
       A2D2Values.size() == 0)
   {
      SendDlgItemMessage(m_hPage, IDC_NO_TRUST_RADIO, BM_SETCHECK, BST_CHECKED, 0);
   }
   else if (bTrustForDelegation &&
            A2D2Values.size() == 0)
   {
      SendDlgItemMessage(m_hPage, IDC_ANY_SERVICE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
   }
   else
   {
      SendDlgItemMessage(m_hPage, IDC_SPECIFIED_SERVICES_RADIO, BM_SETCHECK, BST_CHECKED, 0);
   }

   if (bAnyProtocol)
   {
     SendDlgItemMessage(m_hPage, IDC_ANY_RADIO, BM_SETCHECK, BST_CHECKED, 0);
   }
   else
   {
     SendDlgItemMessage(m_hPage, IDC_KERBEROS_ONLY_RADIO, BM_SETCHECK, BST_CHECKED, 0);
   }

}


//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::SetPageTextForType
//
//  Synopsis:   Alters the page text for the type of object (user or computer)
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::SetPageTextForType()
{
   // Computer is the default and is embedded in the page resource so the only
   // modifications needed are for user

   if (m_scopeDelegationType == SCOPE_DELEGATION_USER)
   {
      CStr szNoTrustRadio;
      szNoTrustRadio.LoadString(g_hInstance, IDS_NO_TRUST_USER_RADIO);
      SetDlgItemText(m_hPage, IDC_NO_TRUST_RADIO, szNoTrustRadio);

      CStr szAnyServiceRadio;
      szAnyServiceRadio.LoadString(g_hInstance, IDS_ANY_SERVICE_USER_RADIO);
      SetDlgItemText(m_hPage, IDC_ANY_SERVICE_RADIO, szAnyServiceRadio);

      CStr szSpecifiedServiceRadio;
      szSpecifiedServiceRadio.LoadString(g_hInstance, IDS_SPECIFIED_SERVICES_USER_RADIO);
      SetDlgItemText(m_hPage, IDC_SPECIFIED_SERVICES_RADIO, szSpecifiedServiceRadio);
      
   }
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnUpdateRadioSelection
//
//  Synopsis:   Enable/Disable some controls based on the radio selection
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::OnUpdateRadioSelection()
{
   TRACE(CDsScopeDelegationPage,OnUpdateRadioSelection);

   if (m_fA2D2Writable && m_fUACWritable)
   {
      if (BST_CHECKED == SendDlgItemMessage(m_hPage, 
                                            IDC_SPECIFIED_SERVICES_RADIO,
                                            BM_GETCHECK,
                                            0,
                                            0))
      {
         // Enable the services specific controls

         EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), TRUE);

         UINT nSelectedCount = m_ServicesList.GetSelectedCount();
         if (nSelectedCount > 0)
         {
            EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), TRUE);
         }
         else
         {
            EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
         }
      }
      else
      {
         // Disable the services specific controls

         EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
      }
   }
   else if (!m_fA2D2Writable && m_fUACWritable)
   {
      // Disable the services specific controls

      EnableWindow(GetDlgItem(m_hPage, IDC_NO_TRUST_RADIO), TRUE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ANY_SERVICE_RADIO), TRUE);
      EnableWindow(GetDlgItem(m_hPage, IDC_SPECIFIED_SERVICES_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
   }
   else
   {
      // User does not have rights to write either the userAccountControl or 
      // msDS-AllowedToDelegateTo attribute

      EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnApply(void)
{
   TRACE(CDsScopeDelegationPage,OnApply);

   ADSVALUE ADsValueAcctCtrl = {ADSTYPE_INTEGER, 0};
   ADS_ATTR_INFO AttrInfoAcctCtrl = {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                     ADSTYPE_INTEGER, &ADsValueAcctCtrl, 1};

   ADS_ATTR_INFO AttrInfoA2D2 = {g_wzA2D2, ADS_ATTR_UPDATE,
                                 ADSTYPE_CASE_IGNORE_STRING, 0, 0};

   ADS_ATTR_INFO AttrsToSet[2];
   DWORD dwAttrsToSetCount = 0;

   const AllowedServicesContainer& newA2D2Values = m_ServicesList.GetAllServices();

   if (BST_CHECKED == SendDlgItemMessage(m_hPage, 
                                         IDC_NO_TRUST_RADIO,
                                         BM_GETCHECK,
                                         0,
                                         0))
   {
      // Remove the trusted for delegation bit

      m_newUserAccountControl &= ~(UF_TRUSTED_FOR_DELEGATION);
      if (m_newUserAccountControl != m_oldUserAccountControl)
      {
         AttrsToSet[dwAttrsToSetCount] = AttrInfoAcctCtrl;
         ADsValueAcctCtrl.Integer = m_newUserAccountControl;

         ++dwAttrsToSetCount;
      }

      if (m_bA2D2Dirty || newA2D2Values.size())
      {
         // Must clear the value for msDS-AllowedToDelegateTo

         AttrInfoA2D2.dwControlCode = ADS_ATTR_CLEAR;
         AttrsToSet[dwAttrsToSetCount] = AttrInfoA2D2;
         ++dwAttrsToSetCount;
      }

      // Clear out the listview too since there will be no values after this

      m_ServicesList.ClearAll();
   }
   else if (BST_CHECKED == SendDlgItemMessage(m_hPage,
                                              IDC_ANY_SERVICE_RADIO,
                                              BM_GETCHECK,
                                              0,
                                              0))
   {
      // Set the trusted for delegation bit

      m_newUserAccountControl |= UF_TRUSTED_FOR_DELEGATION;
      if (m_newUserAccountControl != m_oldUserAccountControl)
      {
         AttrsToSet[dwAttrsToSetCount] = AttrInfoAcctCtrl;
         ADsValueAcctCtrl.Integer = m_newUserAccountControl;

         ++dwAttrsToSetCount;
      }

      if (m_bA2D2Dirty || newA2D2Values.size())
      {
         // Must clear the value for msDS-AllowedToDelegateTo

         AttrInfoA2D2.dwControlCode = ADS_ATTR_CLEAR;
         AttrsToSet[dwAttrsToSetCount] = AttrInfoA2D2;
         ++dwAttrsToSetCount;
      }

      // Clear out the listview too since there will be no values after this

      m_ServicesList.ClearAll();
   }
   else
   {
      // Before doing anything, make sure the user added at least one SPN
      // to the list
      if (newA2D2Values.size() == 0)
      {
         ReportError(S_OK, IDS_ERROR_MUST_HAVE_SPN, m_hPage);
         return PSNRET_INVALID_NOCHANGEPAGE;
      }

      // Remove the trusted for delegation bit

      m_newUserAccountControl &= ~(UF_TRUSTED_FOR_DELEGATION);

      if (BST_CHECKED == SendDlgItemMessage(m_hPage,
                                            IDC_KERBEROS_ONLY_RADIO,
                                            BM_GETCHECK,
                                            0,
                                            0))
      {
         m_newUserAccountControl &= ~(UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION);
      }
      else
      {
         m_newUserAccountControl |= UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
      }

      if (m_newUserAccountControl != m_oldUserAccountControl)
      {
         AttrsToSet[dwAttrsToSetCount] = AttrInfoAcctCtrl;
         ADsValueAcctCtrl.Integer = m_newUserAccountControl;

         ++dwAttrsToSetCount;
      }

      if (m_bA2D2Dirty)
      {
         // Set the values for msDS-AllowedToDelegateTo

         AttrInfoA2D2.dwNumValues = static_cast<DWORD>(newA2D2Values.size());
         AttrInfoA2D2.pADsValues = new ADSVALUE[newA2D2Values.size()];
         if (AttrInfoA2D2.pADsValues)
         {

            DWORD dwValueCount = 0;
            for (AllowedServicesContainer::iterator itr = newA2D2Values.begin();
                 itr != newA2D2Values.end();
                 ++itr)
            {
               AttrInfoA2D2.pADsValues[dwValueCount].dwType = ADSTYPE_CASE_IGNORE_STRING;
               AttrInfoA2D2.pADsValues[dwValueCount].CaseIgnoreString = (PWSTR)(*itr)->GetADSIValue();
               ++dwValueCount;
            }

            dspAssert(dwValueCount == AttrInfoA2D2.dwNumValues);

            AttrsToSet[dwAttrsToSetCount] = AttrInfoA2D2;
            ++dwAttrsToSetCount;
         }
         else
         {
            dspAssert(AttrInfoA2D2.pADsValues);
         }
      }
   }

   if (dwAttrsToSetCount)
   {
      DWORD dwNumModified = 0;
      HRESULT hr = m_pDsObj->SetObjectAttributes(AttrsToSet,
                                                 dwAttrsToSetCount,
                                                 &dwNumModified);
      // Cleanup

      if (AttrInfoA2D2.pADsValues)
      {
         delete[] AttrInfoA2D2.pADsValues;
      }

      // Report any errors

      if (FAILED(hr))
      {
         ReportError(hr, IDS_ADS_ERROR_FORMAT, m_hPage);

         return PSNRET_INVALID_NOCHANGEPAGE;
      }

      dspAssert(dwNumModified == dwAttrsToSetCount);
   }

   return PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    if (BN_CLICKED == codeNotify)
    {
       switch (id)
       {
       case IDC_NO_TRUST_RADIO:
       case IDC_ANY_SERVICE_RADIO:
       case IDC_SPECIFIED_SERVICES_RADIO:
          OnUpdateRadioSelection();
          SetDirty();
          break;

       case IDC_KERBEROS_ONLY_RADIO:
       case IDC_ANY_RADIO:
          SetDirty();
          break;

       case IDC_ADD_BUTTON:
          OnAddServices();
          break;

       case IDC_REMOVE_BUTTON:
          OnRemoveServices();
          break;
       }
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnRemoveServices
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::OnRemoveServices()
{
   m_ServicesList.RemoveSelectedServices();
   m_bA2D2Dirty = true;
   SetDirty();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnAddServices
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::OnAddServices()
{
   CPathCracker pathcracker;
   HRESULT hr = pathcracker.Set(GetObjPathName(), ADS_SETTYPE_FULL);
   if (SUCCEEDED(hr))
   {
      CComBSTR sbstrServer;
      hr = pathcracker.Retrieve(ADS_FORMAT_SERVER, &sbstrServer);
      if (SUCCEEDED(hr))
      {
         CSelectServicesDialog dlg(sbstrServer, m_hPage, m_FreebiesList);

         if (IDOK == dlg.DoModal())
         {
            // m_A2D2Container has taken over ownership of the
            // selected services from the dialog and will cleanup
            // during destruction

            m_ServicesList.AddServices(dlg.GetSelectedServices(), true);
            m_bA2D2Dirty = true;
            SetDirty();
         }
         else
         {
            // Have to clean up data from selected services container

            dlg.ClearSelectedServices();
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
   int idCtrl = (int)wParam;
   LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
   if (idCtrl == IDC_SERVICES_LIST)
   {
      switch (pnmh->code)
      {
         case LVN_ITEMCHANGED:
         case NM_CLICK:
            {
               UINT nSelectedCount = m_ServicesList.GetSelectedCount();
               if (nSelectedCount > 0)
               {
                  EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), TRUE);
               }
               else
               {
                  EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
               }
            }
            break;
         default:
            break;
      }
   }
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnDestroy(void)
{
    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}



//+----------------------------------------------------------------------------
//
//  Method:     CSelectServicesDialog::CSelectServicesDialog
//
//  Synopsis:   Dialog that allows user to select services from users or computers
//
//-----------------------------------------------------------------------------
CSelectServicesDialog::CSelectServicesDialog(PCWSTR pszDC, 
                                             HWND hParent, 
                                             const FreebiesContainer& freebies)
  : m_hWnd(NULL),
    m_strDC(pszDC),
    m_FreebiesList(freebies),
    m_hParent(hParent)
{

}
    
//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::StaticDlgProc
//
//  Synopsis:   The static dialog proc for displaying errors for multi-select pages
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK CSelectServicesDialog::StaticDlgProc(HWND hDlg, 
                                                        UINT uMsg, 
                                                        WPARAM wParam,
                                                        LPARAM lParam)
{
  CSelectServicesDialog* dlg = NULL;

  UINT code;
  UINT id;
  switch (uMsg)
  {
    case WM_INITDIALOG:
      dlg = reinterpret_cast<CSelectServicesDialog*>(lParam);
      dspAssert(dlg != NULL);
      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)dlg);
      SetForegroundWindow(hDlg);
      return dlg->OnInitDialog(hDlg);

    case WM_COMMAND:
      code = GET_WM_COMMAND_CMD(wParam, lParam);
      id   = GET_WM_COMMAND_ID(wParam, lParam);

      dlg = reinterpret_cast<CSelectServicesDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));

      if (dlg)
      {
         switch (id)
         {
           case IDOK:
             if (code == BN_CLICKED)
             {
               dlg->OnOK();
               dlg->OnClose(IDOK);
             }
             break;

           case IDCANCEL:
             if (code == BN_CLICKED)
             {
               dlg->OnClose(IDCANCEL);
             }
             break;

           case IDC_USERS_COMPUTERS_BUTTON:
             dlg->OnGetNewProvider();
             break;

           case IDC_SELECT_ALL_BUTTON:
             dlg->OnSelectAll();
             break;
         }
      }
      break;

    case WM_NOTIFY:
      {
        dlg = reinterpret_cast<CSelectServicesDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));

        if (dlg)
        {
           int idCtrl = (int)wParam;
           LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
           if (idCtrl == IDC_SERVICES_LIST)
           {
             switch (pnmh->code)
             {
               case LVN_ITEMCHANGED:
               case NM_CLICK:
                 {
                   dlg->ListItemClick(pnmh);
                 }
                 break;
               default:
                 break;
             }
           }
        }
        break;
      }

    case WM_HELP:
      {
        LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
        if (!pHelpInfo || pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
        {
          return 0;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
      }
  }
  return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::Init
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
BOOL CSelectServicesDialog::OnInitDialog(HWND hDlg)
{
  m_hWnd = hDlg;

  HRESULT hr = m_ServicesList.Initialize(GetDlgItem(m_hWnd, IDC_SERVICES_LIST));

  return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::ListItemClick
//
//  Synopsis:   Enables/Disables the OK button when an item is selected
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::ListItemClick(LPNMHDR)
{
  UINT nSelectedCount = m_ServicesList.GetSelectedCount();
  if (nSelectedCount > 0)
  {
    EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
  }
  else
  {
    EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnGetNewProvider
//
//  Synopsis:   Uses object picker to select users or computers that contain
//              SPNs
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnGetNewProvider()
{
   BOOL fIsObjSelInited = FALSE;
   CComPtr<IDsObjectPicker> spObjSel;

   HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IDsObjectPicker, (PVOID *)&spObjSel);
   if (FAILED(hr))
   {
      REPORT_ERROR(hr, m_hWnd);
      return;
   }

   // Use object picker to select a new user or computer

   DSOP_SCOPE_INIT_INFO rgScopes[3];
   DSOP_INIT_INFO InitInfo;

   ZeroMemory(rgScopes, sizeof(rgScopes));
   ZeroMemory(&InitInfo, sizeof(InitInfo));

   // The first scope is the local domain. 

   rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
   rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;

   rgScopes[0].pwzDcName = m_strDC;
   rgScopes[0].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

   // The second scope is the local forest.
   //
   rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   rgScopes[1].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
   rgScopes[1].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

   // The third scope is the GC.
   //
   rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[2].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
   rgScopes[2].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
   rgScopes[2].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

/* Can't use the DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN because it implies direct
   trust as well as forest trust.  If the trust is a direct trust and we pick an
   SPN from the trusted domain there is very little chance the KDC will be able
   to resolve it.  We need a forest specific flag from Object Picker

   // The fourth scope is uplevel external trusted domains.
   //
   rgScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
   rgScopes[3].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
   rgScopes[3].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
*/

   InitInfo.cDsScopeInfos = 3;
   InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
   InitInfo.aDsScopeInfos = rgScopes;
   InitInfo.pwzTargetComputer = m_strDC;
   InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
   InitInfo.cAttributesToFetch = 1;
   LPCWSTR rgAttrNames[] = {g_wzSPN};
   InitInfo.apwzAttributeNames = rgAttrNames;

   hr = spObjSel->Initialize(&InitInfo);
   CHECK_HRESULT_REPORT(hr, m_hWnd, return);


   CComPtr<IDataObject> pdoSelections;

   CComPtr<IDsObjectPickerEx> spObjPickerEx;
   hr = spObjSel->QueryInterface(IID_IDsObjectPickerEx, (void**)&spObjPickerEx);
   CHECK_HRESULT_REPORT(hr, m_hWnd, return);

   hr = spObjPickerEx->InvokeDialogEx(m_hWnd, this, &pdoSelections);

   CHECK_HRESULT_REPORT(hr, m_hWnd, return);

   if (hr == S_FALSE || !pdoSelections)
   {
      return;
   }

   ProcessResults(pdoSelections);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::ProcessResults
//
//  Synopsis:   Set the data from the results returned from Object Picker
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::ProcessResults(IDataObject* pdoSelections)
{
   if (!pdoSelections)
   {
      ASSERT(pdoSelections);
      return;
   }

   m_ServicesList.ClearAll();

   FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

   HRESULT hr = pdoSelections->GetData(&fmte, &medium);

   CHECK_HRESULT_REPORT(hr, m_hWnd, return);

   PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

   if (!pSelList)
   {
      return;
   }

   bool bAtLeastOneObjectHasSPN = false;
   for (DWORD idx = 0; idx < pSelList->cItems; ++idx)
   {
      // Unpack each set of SPN values
      if (pSelList->aDsSelection[idx].pvarFetchedAttributes[0].vt != (VT_ARRAY | VT_VARIANT))
      {
         continue;
      }

      // Unpack the safe array and create a CServiceAllowedToDelegate for each SPN

      SAFEARRAY* psa = V_ARRAY(&(pSelList->aDsSelection[idx].pvarFetchedAttributes[0]));

      do
      {
         ASSERT(psa);
         ASSERT(psa != (SAFEARRAY*)-1);

         if (!psa || psa == (SAFEARRAY*)-1)
         {
            break;
         }

         if (::SafeArrayGetDim(psa) != 1)
         {
            break;
         }

         VARTYPE vt = VT_EMPTY;
         hr = ::SafeArrayGetVartype(psa, &vt);
         if (FAILED(hr) || vt != VT_VARIANT)
         {
            break;
         }

         long lower = 0;
         long upper = 0;
     
         hr = ::SafeArrayGetLBound(psa, 1, &lower);
         if (FAILED(hr))
         {
            break;
         }

         hr = ::SafeArrayGetUBound(psa, 1, &upper);
         if (FAILED(hr))
         {
            break;
         }
      
         for (long i = lower; i <= upper; ++i)
         {
            CComVariant item;
            hr = ::SafeArrayGetElement(psa, &i, &item);
            if (FAILED(hr))
            {
               continue;
            }

            if (item.vt == VT_BSTR &&
                item.bstrVal)
            {
               CServiceAllowedToDelegate* pService = new CServiceAllowedToDelegate();
               if (!pService)
               {
                  continue;
               }
               
               hr = pService->Initialize(item.bstrVal);
               if (SUCCEEDED(hr))
               {
                  for (FreebiesContainer::iterator itr = m_FreebiesList.begin();
                       itr != m_FreebiesList.end();
                       ++itr)
                  {
                     bool bAddExpanded = false;

                     if (_wcsicmp(pService->GetColumn(0), (*itr)->GetAlias()) == 0)
                     {
                        // We have to expand out the HOST SPN to all the freebies

                        const CStrList& aliasServiceNames = (*itr)->GetFreebies();
                        for (CStrList::iterator freebie = aliasServiceNames.begin();
                             freebie != aliasServiceNames.end();
                             ++freebie)
                        {
                           // First make a copy of the Host service entry

                           CServiceAllowedToDelegate* pFreebieService = 
                              new CServiceAllowedToDelegate(*pService);
                           if (!pFreebieService)
                           {
                              break;
                           }

                           // Now replace the service type with the freebie

                           pFreebieService->SetServiceType(*(*freebie));
                           m_ServicesList.AddService(pFreebieService);
                           bAddExpanded = true;
                           bAtLeastOneObjectHasSPN = true;
                        }
                     }

                     if (bAddExpanded)
                     {
                        // We were able to add a freebie so delete the host entry

                        delete pService;
                        pService = 0;
                     }
                     else
                     {
                        // We were not able to add a freebie so add the host entry instead

                        m_ServicesList.AddService(pService);
                        bAtLeastOneObjectHasSPN = true;
                     }
                  }
               }
               else
               {
                  m_ServicesList.AddService(pService);
                  bAtLeastOneObjectHasSPN = true;
               }
            }
         }
      } while (false);

   } // for loop

   if (!bAtLeastOneObjectHasSPN)
   {
      ReportError(S_OK, IDC_NO_OBJECT_WITH_SPN, m_hWnd);
   }
}


//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnSelectAll
//
//  Synopsis:   Selects all the items in the list and then forces a redraw
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnSelectAll()
{
   m_ServicesList.SelectAll();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnOK
//
//  Synopsis:   Puts all selected services in the selected services container
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnOK()
{
   // Use this time to rebuild the internal containers such that the selections
   // are represented correctly. 

   m_ServicesList.SetContainersFromSelection();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnClose
//
//  Synopsis:   Closes the modal dialog
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnClose(int result)
{
  EndDialog(m_hWnd, result);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::DoModal
//
//  Synopsis:   Displays the modal dialog
//
//-----------------------------------------------------------------------------
int CSelectServicesDialog::DoModal()
{
  dspAssert(IsWindow(m_hParent));
  return (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SELECT_SERVICES_DIALOG),
                             m_hParent, (DLGPROC)StaticDlgProc, (LPARAM)this);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSelectServicesDialog::GetQueryInfoByScope
//
//  Synopsis:   Called by the Object Picker UI to get a specialized query filter
//
//-----------------------------------------------------------------------------
HRESULT CSelectServicesDialog::GetQueryInfoByScope(IDsObjectPickerScope*,
                                                   PDSQUERYINFO *ppdsqi) 
{ 
   HRESULT hr = S_OK;

   PDSQUERYINFO pQueryInfo = (PDSQUERYINFO)CoTaskMemAlloc(sizeof(DSQUERYINFO));
   if (pQueryInfo)
   {
      ::ZeroMemory(pQueryInfo, sizeof(DSQUERYINFO));
      pQueryInfo->cbSize = sizeof(DSQUERYINFO);
      pQueryInfo->pwzLdapQuery = (PWSTR) CoTaskMemAlloc(sizeof(WCHAR) *
                                     (wcslen(g_pszOPSPNFilter) + 1));
      if (pQueryInfo->pwzLdapQuery)
      {
         wcscpy((PWSTR)pQueryInfo->pwzLdapQuery, g_pszOPSPNFilter);
      }
      else
      {
         hr = E_OUTOFMEMORY;
         CoTaskMemFree(pQueryInfo);
      }
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSelectServicesDialog::ApproveObjects
//
//  Synopsis:   Called by the Object Picker UI to approve objects that were
//              found by the supplied query filter
//
//-----------------------------------------------------------------------------
HRESULT CSelectServicesDialog::ApproveObjects(IDsObjectPickerScope* pScope,
                                              IDataObject* pDataObject,
                                              PBOOL bApprovalArray)
{
   HRESULT hrRet = S_OK;
   HRESULT hr = S_OK;

   FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

   hr = pDataObject->GetData(&fmte, &medium);

   CHECK_HRESULT(hr, return hr);

   PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

   if (!pSelList)
   {
      return E_INVALIDARG;
   }

   for (DWORD idx = 0; idx < pSelList->cItems; ++idx)
   {
      // We will default to letting the object pass since we will only
      // show SPNs that actually exist in the UI.  
      bApprovalArray[idx] = TRUE;

      PWSTR pwzADsPath = pSelList->aDsSelection[idx].pwzADsPath;

      if (pwzADsPath)
      {
         CComPtr<IADs> spIADs;
         hr = ADsOpenObject(pwzADsPath,
                            NULL,
                            NULL,
                            ADS_SECURE_AUTHENTICATION,
                            IID_IADs,
                            (void**)&spIADs);
         if (FAILED(hr))
         {
            continue;
         }

         CComVariant var;
         hr = spIADs->Get(g_wzSPN, &var);
         if (hr == E_ADS_PROPERTY_NOT_FOUND)
         {
            bApprovalArray[idx] = FALSE;
            hrRet = S_FALSE;
            continue;
         }

         if (FAILED(hr))
         {
            continue;
         }

         if (var.vt == VT_EMPTY)
         {
            bApprovalArray[idx] = FALSE;
            hrRet = S_FALSE;
            continue;
         }

         if (var.vt == (VT_ARRAY | VT_VARIANT))
         {
            // Unpack the safe array and validate the data

            SAFEARRAY* psa = V_ARRAY(&var);

            if (!psa || 
                psa == (SAFEARRAY*)-1 ||
                ::SafeArrayGetDim(psa) != 1)
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            VARTYPE vt = VT_EMPTY;
            hr = ::SafeArrayGetVartype(psa, &vt);
            if (FAILED(hr) || vt != VT_VARIANT)
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            long lower = 0;
            long upper = 0;
  
            hr = ::SafeArrayGetLBound(psa, 1, &lower);
            if (FAILED(hr))
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            hr = ::SafeArrayGetUBound(psa, 1, &upper);
            if (FAILED(hr))
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            if (lower >= upper)
            {
               // No values!!!
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }
         }
      }
   }
   return hrRet;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSelectServicesDialog::QueryInterface(REFIID riid, void ** ppvObject)
{
  TRACE2(CSelectServicesDialog,QueryInterface);
  if (IID_ICustomizeDsBrowser == riid)
  {
    *ppvObject = (ICustomizeDsBrowser*)this;
  }
  AddRef();
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSelectServicesDialog::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsGrpMembersPage::AddRef refcount going in %d\n", m_uRefs));
    
    return ++m_uRefs;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSelectServicesDialog::Release(void)
{
  dspDebugOut((DEB_USER2, "CSelectServicesDialog::Release ref count going in %d\n", m_uRefs));
  return --m_uRefs;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\routing.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       routing.h
//
//  Contents:   AD cross-forest trust name editing pages.
//
//  Classes:    CDsForestNameRoutingPage, CEditTLNDialog, CExcludeTLNDialog
//
//  History:    29-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef ROUTING_H_GUARD
#define ROUTING_H_GUARD

#include "dlgbase.h"
#include "ftinfo.h"
#include "listview.h"

//+----------------------------------------------------------------------------
//
//  Class:      CDsForestNameRoutingPage
//
//  Purpose:    Property page object class for the forest trust name routing page.
//
//-----------------------------------------------------------------------------
class CDsForestNameRoutingPage
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CDsForestNameRoutingPage(HWND hParent);
   ~CDsForestNameRoutingPage(void);

   //
   //  Static WndProc to be passed to CreateWindow
   //
   static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam);
   //
   //  Instance specific wind proc
   //
   LRESULT  DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
   LRESULT  OnInitDialog(LPARAM lParam);
   LRESULT  OnApply(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   LRESULT  OnNotify(WPARAM wParam, LPARAM lParam);
   LRESULT  OnHelp(LPHELPINFO pHelpInfo);
   LRESULT  OnDestroy(void);
   static   UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);
   void     RefreshList(void);
   void     CheckDomainForConflict(CWaitCursor & Wait);
   void     EnableButtons(void);
   void     OnEnableClick(void);
   void     OnDisableClick(void);
   void     OnEditClick(void);
   void     SetDirty(void) {
               _fPageDirty = true;
               PropSheet_Changed(GetParent(_hPage), _hPage);
               EnableWindow(GetDlgItem(GetParent(_hPage), IDCANCEL), TRUE);
            };
   bool     IsDirty(void) {return _fPageDirty;};
   void     ClearDirty(void) {_fPageDirty = false;};

public:
   HRESULT  Init(PCWSTR pwzDomainDnsName, PCWSTR pwzTrustPartnerName,
                 PCWSTR pwzPartnerFlatName, PCWSTR pwzDcName,
                 ULONG nTrustDirection, BOOL fReadOnly);
   void     CheckForNameChanges(BOOL fReport = TRUE);
   CFTInfo & GetFTInfo(void) {return _FTInfo;};
   CFTCollisionInfo & GetCollisionInfo(void) {return _CollisionInfo;};
   PCWSTR   GetTrustPartnerDnsName(void) const {return _strTrustPartnerDnsName;};
   PCWSTR   GetTrustPartnerFlatName(void) const {return _strTrustPartnerFlatName;};
   DWORD    WriteTDO(void);
   BOOL     IsReadOnly(void) {return _fReadOnly;};
   bool     AnyForestNameChanges(PLSA_FOREST_TRUST_INFORMATION pLocalFTInfo,
                                 PLSA_FOREST_TRUST_INFORMATION pRemoteFTInfo);

   //
   //  Data members
   //
private:
   CStrW             _strDomainDnsName;
   CStrW             _strTrustPartnerDnsName;
   CStrW             _strTrustPartnerFlatName;
   CStrW             _strUncDC;
   HWND              _hParent;
   HWND              _hPage;
   BOOL              _fInInit;
   BOOL              _fReadOnly;
   bool              _fPageDirty;
   ULONG             _nTrustDirection;
   CTLNList          _TLNList;
   CFTInfo           _FTInfo;
   CFTCollisionInfo  _CollisionInfo;
   CCreds            _LocalCreds;

   // not implemented to disallow copying.
   CDsForestNameRoutingPage(const CDsForestNameRoutingPage&);
   const CDsForestNameRoutingPage& operator=(const CDsForestNameRoutingPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CEditTLNDialog
//
//  Purpose:    Change the settings of names derived from TLNs.
//
//-----------------------------------------------------------------------------
class CEditTLNDialog : public CModalDialog
{
public:
   CEditTLNDialog(HWND hParent, int nTemplateID, CFTInfo & FTInfo,
                  CFTCollisionInfo & ColInfo,
                  CDsForestNameRoutingPage * pRoutingPage);
   ~CEditTLNDialog(void) {};

   INT_PTR  DoModal(ULONG iSel);

private:
   LRESULT  OnInitDialog(LPARAM lParam);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   LRESULT  OnNotify(WPARAM wParam, LPARAM lParam);
   LRESULT  OnHelp(LPHELPINFO pHelpInfo);
   void     OnAddExclusion(void);
   void     OnRemoveExclusion(void);
   void     OnEnableName(void);
   void     OnDisableName(void);
   void     OnSave(void);
   void     OnOK(void);
   void     EnableExRmButton(void);
   void     EnableSuffixListButtons(void);
   void     FillSuffixList(void);

   CSuffixesList        _SuffixList;
   CFTInfo            & _FTInfo;
   CFTCollisionInfo   & _CollisionInfo;
   ULONG                _iSel;
   bool                 _fIsDirty;
   CDsForestNameRoutingPage * _pRoutingPage;

public:
   ULONG    GetTlnSelectionIndex(void) {return _iSel;};
   void     SetNewExclusionIndex(ULONG index) {_iNewExclusion = index;};

   ULONG                _iNewExclusion;

private:
   // not implemented to disallow copying.
   CEditTLNDialog(const CEditTLNDialog&);
   const CEditTLNDialog& operator=(const CEditTLNDialog&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CExcludeTLNDialog
//
//  Purpose:    Add TLN exclusion records.
//
//-----------------------------------------------------------------------------
class CExcludeTLNDialog : public CModalDialog
{
   friend CEditTLNDialog;
public:
   CExcludeTLNDialog(HWND hParent, int nTemplateID, CFTInfo & FTInfo,
                     CEditTLNDialog * pEditDlg);
   ~CExcludeTLNDialog(void) {};

private:
   LRESULT OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnOK(void);
   LRESULT OnHelp(LPHELPINFO pHelpInfo);

   CEditTLNDialog  * _pEditDlg;
   CFTInfo &         _FTInfo;

   // not implemented to disallow copying.
   CExcludeTLNDialog(const CExcludeTLNDialog&);
   const CExcludeTLNDialog& operator=(const CExcludeTLNDialog&);
};

#endif // ROUTING_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\subclass.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       subclass.h
//
//  Contents:   Control subclassing support.
//
//  Classes:    ControlSubclasser, MultiLineEditBoxThatForwardsEnterKey.
//
//  History:    28-Nov-00 EricB created in collaboration with SBurns.
//
//-----------------------------------------------------------------------------

#ifndef SUBCLASS_H_GUARD
#define SUBCLASS_H_GUARD

//+----------------------------------------------------------------------------
//
//  Class:     ControlSubclasser
//
//  Purpose:   Class for hooking the window proc of a control.
//
//-----------------------------------------------------------------------------
class ControlSubclasser
{
protected:

   ControlSubclasser();

   // reverses the subclassing by calling UnhookWindowProc.

   virtual
   ~ControlSubclasser();

   // Hooks the window proc of the supplied window so that all future messages
   // are routed to the OnMessage method.  The OnInit of the parent dialog
   // where the control resides is a good place to call this method.
   //
   // The hook requires that that the GWLP_USERDATA portion of the window
   // be overwritten with the this pointer to this instance.  If you need
   // that data, then you could derive a class from this one, and add
   // members for your extra data.
   //
   // Your overrided Init method must call this base method.
   //
   // control - in, handle to the control to be hooked.

   virtual
   HRESULT
   Init(HWND editControl);

   // Invoked upon receipt of any window message.  The default implementation
   // calls the control's original window procedure.  When you derive a new
   // class from this one, be sure to call this base class method from your
   // derived method for any messages your derived method doesn't handle.
   //
   // message - in, the message code passed to the dialog window.
   //
   // wparam - in, the WPARAM parameter accompanying the message.
   //
   // lparam - in, the LPARAM parameter accompanying the message.

   virtual
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   // the handle to the subclassed control.  Only valid after Init has
   // been called.

   HWND hwnd;

private:

   // restore the original window proc to the window

   void
   UnhookWindowProc();

   // a static Windows Proc that acts as a dispatcher to the non-static
   // OnMessage method.

   static
   LRESULT CALLBACK
   WindowProc(
      HWND   window,
      UINT   message,
      WPARAM wParam,
      LPARAM lParam);

   // not implemented: no copying allowed

   ControlSubclasser(const ControlSubclasser&);
   const ControlSubclasser& operator=(const ControlSubclasser&);

   WNDPROC originalWindowProc;
};

//+----------------------------------------------------------------------------
//
//  Class:     MultiLineEditBoxThatForwardsEnterKey
//
//  Purpose:   Class for hooking the window proc of a multi-line edit control
//             to cause it to forward enter keypresses to its parent window as
//             WM_COMMAND messages.
//
//-----------------------------------------------------------------------------
class MultiLineEditBoxThatForwardsEnterKey : public ControlSubclasser
{
public:

   static const WORD FORWARDED_ENTER = 1010;

   MultiLineEditBoxThatForwardsEnterKey();

   virtual
   ~MultiLineEditBoxThatForwardsEnterKey();

   // subclasses the edit control
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we assert and throw rotten eggs.

   HRESULT
   Init(HWND editControl);

   // Invoked upon receipt of any window message.
   //
   // message - in, the message code passed to the dialog window.
   //
   // wparam - in, the WPARAM parameter accompanying the message.
   //
   // lparam - in, the LPARAM parameter accompanying the message.

   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

private:

   // not implemented: no copying allowed

   MultiLineEditBoxThatForwardsEnterKey(const MultiLineEditBoxThatForwardsEnterKey&);
   const MultiLineEditBoxThatForwardsEnterKey&
      operator=(const MultiLineEditBoxThatForwardsEnterKey&);
};

#endif SUBCLASS_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\siterepl.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       siterepl.h
//
//  Contents:   Site and Replication object property pages header
//
//  History:    16-Sep-97 JonN templated from computer.h
//
//-----------------------------------------------------------------------------

#ifndef _SITEREPL_H_
#define _SITEREPL_H_


HRESULT
ScheduleChangeBtn_11_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
ScheduleChangeBtn_FF_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
#ifdef CUSTOM_SCHEDULE
HRESULT
ScheduleChangeCheckbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
#endif
//
// nTDSDSAAndDomainChangeBtn also updates the Replicated Domain readonly edit field in IDC_EDIT1
//
HRESULT
nTDSDSAChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
nTDSDSAAndDomainChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
FRSMemberInReplicaChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
FRSAnyMemberChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
ComputerChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
nTDSConnectionOptions(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
SiteExtractSubnetList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);

HRESULT
CreateDsOrFrsConnectionPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                      HPROPSHEETPAGE * phPage);

#endif // _SITEREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\subclass.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Domains and Trust
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       subclass.cxx
//
//  Contents:   Control subclassing support
//
//  History:    28-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "subclass.h"

//+----------------------------------------------------------------------------
//
//  Class:     ControlSubclasser
//
//  Purpose:   Class for hooking the window proc of a control.
//
//-----------------------------------------------------------------------------
ControlSubclasser::ControlSubclasser() :
   hwnd(0),
   originalWindowProc(0)
{
   TRACE(ControlSubclasser,ControlSubclasser);
}

ControlSubclasser::~ControlSubclasser()
{
   TRACE(ControlSubclasser,~ControlSubclasser);

   UnhookWindowProc();
}

HRESULT
ControlSubclasser::Init(HWND control)
{
   TRACE(ControlSubclasser,Init);
   dspAssert(IsWindow(control));

   // hwnd should not be set, nor originalWindowProc.  If they are, then
   // Init has been called already.

   dspAssert(!hwnd);
   dspAssert(!originalWindowProc);

   hwnd = control;

   // save our this pointer so we can find ourselves again when messages
   // are sent to the window.

   SetWindowLongPtr(hwnd,
                    GWLP_USERDATA,
                    reinterpret_cast<LONG_PTR>(this));

   // hook the windows procedure.

   LONG_PTR ptr = GetWindowLongPtr(hwnd, GWLP_WNDPROC);

   CHECK_NULL(ptr, return E_OUTOFMEMORY);

   originalWindowProc = reinterpret_cast<WNDPROC>(ptr);

   if (!originalWindowProc)
   {
      dspDebugOut((DEB_ERROR, "unable to hook winproc"));

      hwnd = 0;
      return E_FAIL;
   }

   SetWindowLongPtr(hwnd,
                    GWLP_WNDPROC,
                    reinterpret_cast<LONG_PTR>(ControlSubclasser::WindowProc));

   return S_OK;
}

void
ControlSubclasser::UnhookWindowProc()
{
   TRACE(ControlSubclasser,UnhookWindowProc);

   if (IsWindow(hwnd) && originalWindowProc)
   {
      // unhook the window proc

      SetWindowLongPtr(hwnd,
                       GWLP_WNDPROC,
                       reinterpret_cast<LONG_PTR>(originalWindowProc));
   }
}

LRESULT
ControlSubclasser::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // TRACE(ControlSubclasser,OnMessage);

   switch (message)
   {
      case WM_DESTROY:
      {
         UnhookWindowProc();
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return ::CallWindowProc(originalWindowProc, hwnd, message, wparam, lparam);
}

LRESULT
CALLBACK
ControlSubclasser::WindowProc(HWND   window,
                              UINT   message,
                              WPARAM wparam,
                              LPARAM lparam)
{
   // TRACE(ControlSubclasser,WindowProc)

   LRESULT result = 0;

   LONG_PTR ptr = GetWindowLongPtr(window, GWLP_USERDATA);

   if (ptr)
   {
      ControlSubclasser* that =
         reinterpret_cast<ControlSubclasser*>(ptr);

      dspAssert(that);

      result = that->OnMessage(message, wparam, lparam);
   }
   else
   {
      dspAssert(false);
   }

   return result;
}

//+----------------------------------------------------------------------------
//
//  Class:     MultiLineEditBoxThatForwardsEnterKey
//
//-----------------------------------------------------------------------------

MultiLineEditBoxThatForwardsEnterKey::MultiLineEditBoxThatForwardsEnterKey()
{
   TRACE(MultiLineEditBoxThatForwardsEnterKey,MultiLineEditBoxThatForwardsEnterKey);
}

MultiLineEditBoxThatForwardsEnterKey::~MultiLineEditBoxThatForwardsEnterKey()
{
   TRACE(MultiLineEditBoxThatForwardsEnterKey,~MultiLineEditBoxThatForwardsEnterKey);
}

HRESULT
MultiLineEditBoxThatForwardsEnterKey::Init(HWND editControl)
{
   TRACE(MultiLineEditBoxThatForwardsEnterKey,Init);

   HRESULT hr = ControlSubclasser::Init(editControl);

   return hr;
}

LRESULT
MultiLineEditBoxThatForwardsEnterKey::OnMessage(
   UINT   message,
   WPARAM wparam,
   LPARAM lparam)
{
   // TRACE(MultiLineEditBoxThatForwardsEnterKey,OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {
          switch (wparam)
         {
            case VK_RETURN:
            {
               // Send the parent window a WM_COMMAND message with
               // FORWARDED_ENTER as the notification code.

               SendMessage(GetParent(hwnd),
                           WM_COMMAND,
                           MAKELONG(GetDlgCtrlID(hwnd), FORWARDED_ENTER),
                           reinterpret_cast<LPARAM>(hwnd));
               break;
            }

            default:
            {
               // do nothing

               break;
            }
         }

         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\tdoprop.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       tdoprop.cxx
//
//  Contents:   TDO trust page
//
//  History:    16-Nov-00 EricB split from trust.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "routing.h"
#include "trustwiz.h"
#include <lmerr.h>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Trusted-Domain object General page
//
//-----------------------------------------------------------------------------

PWSTR g_pwzErr = L"<error, no value!>";

//+----------------------------------------------------------------------------
//
//  Member: CDsTrustedDomainPage::CDsTrustedDomainPage
//
//-----------------------------------------------------------------------------
CDsTrustedDomainPage::CDsTrustedDomainPage() :
    m_ulTrustType(0),
    m_ulTrustAttrs(0),
    m_nTrustDirection(0),
    m_nRelationship(TRUST_REL_UNKNOWN),
    m_pwzTrustedDomDnsName(NULL),
    m_pwzTrustedDomFlatName(NULL),
    _pForestNamePage(NULL)
{
    TRACE(CDsTrustedDomainPage,CDsTrustedDomainPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsTrustedDomainPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsTrustedDomainPage::~CDsTrustedDomainPage
//
//-----------------------------------------------------------------------------
CDsTrustedDomainPage::~CDsTrustedDomainPage()
{
    TRACE(CDsTrustedDomainPage,~CDsTrustedDomainPage);
    DO_DEL(m_pwzTrustedDomDnsName);
    DO_DEL(m_pwzTrustedDomFlatName);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::Initialize
//
//  Synopsis:   Initialialization done at WM_INITDIALOG time.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::Initialize(CDsPropPageBase * pPage)
{
   TRACER(CDsTrustedDomainPage,Initialize);
   HRESULT hr = CTrustPropPageBase::Initialize(pPage);

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::ForestTrustPage
//
//  Synopsis:   If forest trust, create the forest trust name routing page.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::ForestTrustPage(BOOL fReadOnly)
{
   TRACER(CDsTrustedDomainPage,ForestTrustPage);

   if (IsForestTrust())
   {
      // Create the name routing page.
      //
      _pForestNamePage = new CDsForestNameRoutingPage(GetParent(m_pPage->GetHWnd()));

      CHECK_NULL(_pForestNamePage, return E_OUTOFMEMORY);

      return _pForestNamePage->Init(GetDnsDomainName(), GetTrustPartnerDnsName(),
                                    GetTrustPartnerFlatName(),
                                    GetDomainDcName(), m_nTrustDirection,
                                    fReadOnly);
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::SetFlatName
//
//-----------------------------------------------------------------------------
BOOL
CDsTrustedDomainPage::SetFlatName(PWSTR pwzFlatName)
{
    return AllocWStr(pwzFlatName, &m_pwzTrustedDomFlatName);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::SetDnsName
//
//-----------------------------------------------------------------------------
BOOL
CDsTrustedDomainPage::SetDnsName(PWSTR pwzDnsName)
{
    return AllocWStr(pwzDnsName, &m_pwzTrustedDomDnsName);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::TrustType
//
//  Synopsis:   Save the value and return the string name for the type of trust
//              and the state of transitivity.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::TrustType(int nType, CStrW& strType)
{
    strType = g_pwzErr;
    m_ulTrustType = (ULONG)nType;

    if (!GetTrustPartnerFlatName())
    {
        return E_OUTOFMEMORY;
    }

    for (ULONG i = 0; i < m_cTrusts; i++)
    {
        if (_wcsicmp(m_rgTrustList[i].strFlatName, GetTrustPartnerFlatName()) == 0)
        {
            m_nRelationship = m_rgTrustList[i].nRelationship;
            break;
        }
    }

    int idRel;
    //
    // Get the relationship string.
    //
    switch (m_nRelationship)
    {
    case TRUST_REL_PARENT:
        idRel = IDS_REL_PARENT;
        break;

    case TRUST_REL_CHILD:
        idRel = IDS_REL_CHILD;
        break;

    case TRUST_REL_ROOT:
        idRel = IDS_REL_TREE_ROOT;
        break;

    case TRUST_REL_CROSSLINK:
        idRel = IDS_REL_CROSSLINK;
        break;

    case TRUST_REL_EXTERNAL:
        idRel = IDS_REL_EXTERNAL;
        break;

    case TRUST_REL_FOREST:
        idRel = IDS_REL_FOREST;
        break;

    case TRUST_REL_INDIRECT:
        idRel = IDS_REL_INDIRECT;
        break;

    case TRUST_REL_MIT:
        idRel = IDS_REL_MIT;
        break;

    case TRUST_REL_DCE:
        idRel = IDS_REL_DCE;
        break;

    default:
        idRel = IDS_REL_UNKNOWN;
        break;
    }

    strType.LoadString(g_hInstance, idRel);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::TrustDirection
//
//  Synopsis:   Return the string for the direction of trust.
//
//-----------------------------------------------------------------------------
void
CDsTrustedDomainPage::TrustDirection(int nDirection, CStrW& strDirection)
{
    m_nTrustDirection = nDirection;
    int idDir;

    switch (m_nTrustDirection)
    {
    case TRUST_DIRECTION_INBOUND:
        idDir = (m_nRelationship == TRUST_REL_CROSSLINK) ?
                IDS_TRUST_DIR_INBOUND_SHORTCUT : IDS_TRUST_DIR_INBOUND;
        break;

    case TRUST_DIRECTION_OUTBOUND:
        idDir = (m_nRelationship == TRUST_REL_CROSSLINK) ?
                IDS_TRUST_DIR_OUTBOUND_SHORTCUT : IDS_TRUST_DIR_OUTBOUND;
        break;

    case TRUST_DIRECTION_BIDIRECTIONAL:
        idDir = IDS_TRUST_DIR_BIDI;
        break;

    default:
        idDir = IDS_TRUST_DISABLED;
        break;
    }
    strDirection.LoadString(g_hInstance, idDir);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::SetTransitive
//
//  Synopsis:   Turn transitivity on or off.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::SetTransitive(BOOL fTransitive)
{
    DWORD Win32Err;
    NTSTATUS Status;
    PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
    PLSA_UNICODE_STRING pName;
    LSA_UNICODE_STRING Name;
    CWaitCursor Wait;

    CPolicyHandle cPolicy(GetDomainDcName());

    Win32Err = cPolicy.OpenWithPrompt(_Creds._LocalCreds, Wait,
                                      GetDnsDomainName(), m_pPage->GetHWnd());

    if (ERROR_CANCELLED == Win32Err)
    {
        // don't report error if user canceled.
        //
        return ADM_S_SKIP;
    }

    if (ERROR_ACCESS_DENIED == Win32Err)
    {
       // the user entered creds are no good.
       _Creds._LocalCreds.Clear();
    }

    CHECK_WIN32(Win32Err, return HRESULT_FROM_WIN32(Win32Err));

    RtlInitUnicodeString(&Name, GetTrustPartnerDnsName());
    pName = &Name;

    Status = LsaQueryTrustedDomainInfoByName(cPolicy,
                                             pName,
                                             TrustedDomainInformationEx,
                                             (PVOID *)&pTDIx);

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, return HRESULT_FROM_WIN32(Win32Err));

    if (fTransitive)
    {
        pTDIx->TrustAttributes &= ~(TRUST_ATTRIBUTE_NON_TRANSITIVE);
    }
    else
    {
        pTDIx->TrustAttributes |= TRUST_ATTRIBUTE_NON_TRANSITIVE;
    }

    Status = LsaSetTrustedDomainInfoByName(cPolicy,
                                           pName,
                                           TrustedDomainInformationEx,
                                           pTDIx);
    LsaFreeMemory(pTDIx);
    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, return HRESULT_FROM_WIN32(Win32Err));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CurDomainText
//
//  Synopsis:   Puts the name of the current domain in the corresponding text
//              box.
//
//  Warning:    This must be the first attr function called as it allocates
//              the class object. It also reads the trusted-domain flat-name
//              attribute.
//
//-----------------------------------------------------------------------------
HRESULT
CurDomainText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (DlgOp == fOnCallbackRelease)
    {
        DO_DEL(pTDPage);
        return S_OK;
    }
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    HRESULT hr;

    pTDPage = new CDsTrustedDomainPage;

    CHECK_NULL_REPORT(pTDPage, pPage->GetHWnd(), return E_OUTOFMEMORY);

    hr = pTDPage->Initialize(pPage);

    CHECK_HRESULT(hr, return hr);

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pTDPage->GetDnsDomainName());

    reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData = reinterpret_cast<LPARAM>(pTDPage);

    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        if (!pTDPage->SetFlatName(pAttrInfo->pADsValues->CaseIgnoreString))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   PeerDomain
//
//  Synopsis:   Fills in the peer domain name, which is the DNS name of the
//              domain represented by the trusted-domain object. The
//              attribute is trustPartner.
//
//-----------------------------------------------------------------------------
HRESULT
PeerDomain(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    PWSTR pwzTrustedDomDnsName = g_pwzErr;
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pwzTrustedDomDnsName = pAttrInfo->pADsValues->CaseIgnoreString;

        if (!pTDPage->SetDnsName(pwzTrustedDomDnsName))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwzTrustedDomDnsName);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustType
//
//  Synopsis:   Fills in the trust type value. Also fills in the transitivity
//              value. If MIT trust, handles the apply for the transitivity.
//
//  Notes:      This attr function reads and stores the trust-type value
//              which is then used by the TransitiveTextOrButton function.
//              Therefore, this function must be called first.
//
//-----------------------------------------------------------------------------
HRESULT
TrustType(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
          PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
          DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    CStrW strType = g_pwzErr, strTrans = g_pwzErr;
    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pTDPage->TrustType(pAttrInfo->pADsValues->Integer, strType);

        if (pTDPage->IsParentChild())
        {
            CStrW strLabelFormat, strLabel;
    
            strLabelFormat.LoadString(g_hInstance, IDS_TRUSTDOM_LABEL_FORMAT);

            strLabel.Format(strLabelFormat, strType);
    
            SetDlgItemText(pPage->GetHWnd(), IDC_PEER_LABEL, strLabel);

            strType.LoadString(g_hInstance, IDS_TRUST_PARENTCHILD);
        }
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, strType);

    if (pTDPage->CantVerify())
    {
        ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_VERIFY_STATIC), SW_HIDE);
        HWND hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRUST_RESET_BTN);
        ShowWindow(hCtrl, SW_HIDE);
        EnableWindow(hCtrl, FALSE);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TransitiveTextOrButton
//
//  Synopsis:   Handle processing for the transitivity text box/yes-radio
//              button.
//
//-----------------------------------------------------------------------------
HRESULT
TransitiveTextOrButton(CDsPropPageBase * pPage, PATTR_MAP,
                       PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                       DLG_OP DlgOp)
{
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    switch (DlgOp)
    {
    case fInit:
        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            pTDPage->SetTrustAttrs(pAttrInfo->pADsValues->Integer);

            if (pTDPage->IsMIT())
            {
                // If it is an MIT trust then show the yes/no radio buttons
                // rather than the read-only edit control.
                //
                ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_TRANS_STATIC), SW_HIDE);
                ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_TRUST_TRANS_EDIT), SW_HIDE);

                HWND hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRANS_GROUPBOX);
                ShowWindow(hCtrl, SW_SHOW);
                hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRANS_YES_RADIO);
                ShowWindow(hCtrl, SW_SHOW);
                EnableWindow(hCtrl, TRUE);
                hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRANS_NO_RADIO);
                ShowWindow(hCtrl, SW_SHOW);
                EnableWindow(hCtrl, TRUE);
                CheckDlgButton(pPage->GetHWnd(),
                               pTDPage->IsNonTransitive() ? IDC_TRANS_NO_RADIO : IDC_TRANS_YES_RADIO,
                               BST_CHECKED);
            }
            else
            {
                CStrW strTrans;
                int idTrans = IDS_TRUST_TRANSITIVE;

                if (pTDPage->IsForestTrust())
                {
                   idTrans = IDS_TRUST_FOREST_TRANSITIVE;
                }
                else
                {
                   if (pTDPage->IsNonTransitive())
                   {
                       idTrans = IDS_TRUST_NON_TRANSITIVE;
                   }
                }
                strTrans.LoadString(g_hInstance, idTrans);

                SetDlgItemText(pPage->GetHWnd(), IDC_TRUST_TRANS_EDIT, strTrans);
            }
        }
        break;

    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            if (pTDPage->IsMIT())
            {
                DBG_OUT("TrustTransYes BN_CLICKED\n");
                pPage->SetDirty();
            }
        }
        break;

    case fApply:
        dspAssert(pTDPage->IsMIT());
        HRESULT hr;

        hr = pTDPage->SetTransitive(IsDlgButtonChecked(pPage->GetHWnd(), IDC_TRANS_YES_RADIO));

        if (FAILED(hr))
        {
            // Restore the old state.
            //
            if (IsDlgButtonChecked(pPage->GetHWnd(), IDC_TRANS_YES_RADIO))
            {
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_NO_RADIO, BST_CHECKED);
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_YES_RADIO, BST_UNCHECKED);
            }
            else
            {
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_YES_RADIO, BST_CHECKED);
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_NO_RADIO, BST_UNCHECKED);
            }

            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
            {
                ReportError(hr, IDS_ERR_CHANGE_TRANSITIVITY, pPage->GetHWnd());
            }
        }
        
        return ADM_S_SKIP;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustTransNo
//
//  Synopsis:   Handle processing for the transitivity No radiobutton.
//
//-----------------------------------------------------------------------------
HRESULT
TrustTransNo(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
             DLG_OP DlgOp)
{
    switch (DlgOp)
    {
    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            DBG_OUT("TrustTransNo BN_CLICKED\n");
            pPage->SetDirty();
        }
        break;

    case fApply:
        return ADM_S_SKIP;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustDirection
//
//  Synopsis:   Direction-of-trust value.
//
//-----------------------------------------------------------------------------
HRESULT
TrustDirection(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
               DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    CStrW strDirection;
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pTDPage->TrustDirection(pAttrInfo->pADsValues->Integer, strDirection);
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, strDirection);

    return pTDPage->ForestTrustPage(pPage->IsReadOnly());
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustVerifyBtn
//
//  Synopsis:   If the button is pressed, force new passwords into the trust
//              relationship.
//
//-----------------------------------------------------------------------------
HRESULT
TrustVerifyBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the parent page is canceled during initialization.
        //
        if (DlgOp == fInit)
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        return S_OK;
    }

    if (DlgOp == fInit && pPage->IsReadOnly())
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        return S_OK;
    }

    if (DlgOp != fOnCommand)
    {
        return S_OK;
    }

    if (IDYES != pTDPage->OnVerifyTrustBtn())
    {
        return S_OK;
    }

    HRESULT hr = pTDPage->ResetTrust();

    if (SUCCEEDED(hr))
    {
        MsgBox(IDS_TRUST_RESET_DONE, pPage->GetHWnd());
    }
    else
    {
        // Don't post error message for ERROR_CANCELLED.
        //
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
        {
            ReportError(hr, IDS_ERROR_TRUST_RESET, pPage->GetHWnd());
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   SaveFTInfoBtn
//
//  Synopsis:   If the button is pressed, prompt the user for a file name and
//              then save the FTInfo as a text file.
//
//-----------------------------------------------------------------------------
HRESULT
SaveFTInfoBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp)
{
   if (!pPage)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   CDsTrustedDomainPage * pTDPage = 
      reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

   if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
   {
      // This can happen if the parent page is canceled during initialization.
      //
      return S_OK;
   }

   if (DlgOp == fInit && pTDPage->IsForestTrust())
   {
      // Show the Save-Names button & label
      //
      ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_SAVE_FOREST_NAMES_STATIC), SW_SHOW);
      HWND hBtn = GetDlgItem(pPage->GetHWnd(), IDC_SAVE_FOREST_NAMES_BTN);
      ShowWindow(hBtn, SW_SHOW);
      EnableWindow(hBtn, pPage->IsReadOnly() ? FALSE : TRUE);
      return S_OK;
   }

   if (DlgOp == fOnCommand)
   {
      pTDPage->OnSaveFTInfoBtn();
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::OnVerifyTrustBtn
//
//  Synopsis:   Check the status of the trust link.
//
//  Returns:    IDYES - the trust verification failed and the user choose Yes
//                      to repair the trust.
//              IDNO  - don't repair the trust either because it verified OK
//                      or the user choose not to repair it.
//
//-----------------------------------------------------------------------------
int
CDsTrustedDomainPage::OnVerifyTrustBtn(void)
{
    TRACE(CDsTrustedDomainPage, OnVerifyTrustBtn);
    TD_DOM_INFO Remote = {0};
    int nResponse = IDNO;
    HRESULT hr;
    BOOL fFailed = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    CWaitCursor Wait;

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
       // See if the user has admin privileges. If not, get the creds.
       //
       CPolicyHandle cPolicy(GetDomainDcName());

       dwErr = cPolicy.OpenWithPrompt(_Creds._LocalCreds, Wait,
                                      GetDnsDomainName(), m_pPage->GetHWnd());
       if (ERROR_CANCELLED == dwErr)
       {
           return IDNO;
       }

       if (ERROR_SUCCESS != dwErr)
       {
           Wait.SetOld();
           if (ERROR_NO_SUCH_DOMAIN == dwErr)
           {
               ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetDnsDomainName(),
                           m_pPage->GetHWnd());
           }
           else
           {
               PCWSTR pwzDomainName = GetDnsDomainName();
               SuperMsgBox(m_pPage->GetHWnd(), IDS_VERIFY_BAD_CREDS, 0, MB_OK |
                           MB_ICONEXCLAMATION, dwErr, (PVOID *)&pwzDomainName, 1,
                           FALSE, __FILE__, __LINE__);
               _Creds._LocalCreds.Clear();
           }
           return IDNO;
       }

       cPolicy.Close();
    }

    Wait.SetWait();

    Remote.ulTrustType = m_ulTrustType; // set the trust type, so that Getinfo.. 
                                        // knows what to do

    hr = GetInfoForRemoteDomain(GetTrustPartnerDnsName(), &Remote, _Creds,
                                m_pPage->GetHWnd());
    if (Remote.Policy)
    {
        LsaClose(Remote.Policy);
        Remote.Policy = NULL;
    }

    if (FAILED(hr))
    {
        Wait.SetOld();
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) == hr)
        {
            ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetTrustPartnerDnsName(),
                        m_pPage->GetHWnd());
        }
        else
        {
            PWSTR * ppwzDomainName = &m_pwzTrustedDomDnsName;
            SuperMsgBox(m_pPage->GetHWnd(), IDS_TRUST_BAD_DOMAIN, 0, MB_OK |
                        MB_ICONEXCLAMATION, hr, (PVOID *)ppwzDomainName, 1,
                        FALSE, __FILE__, __LINE__);
        }
        return IDNO;
    }

    Wait.SetWait();

    PCWSTR pwzRemoteDomainName, pwzLocalDomainName;
    DWORD dwVerifyFlags = 0;

    if (TRUST_TYPE_DOWNLEVEL == Remote.ulTrustType)
    {
        pwzRemoteDomainName = Remote.pDownlevelDomainInfo->Name.Buffer;
        pwzLocalDomainName = GetDomainFlatName();
        dwVerifyFlags |= DS_TRUST_VERIFY_DOWNLEVEL;
    }
    else
    {
        pwzRemoteDomainName = Remote.pDnsDomainInfo->DnsDomainName.Buffer;
        pwzLocalDomainName = GetDnsDomainName();
    }

    PWSTR pwzRemoteDcUsed = NULL;
    CStrW strMsg;

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        dwErr = VerifyTrustOneDirection(GetDomainDcName(),
                                        GetDnsDomainName(),
                                        pwzRemoteDomainName,
                                        &pwzRemoteDcUsed,
                                        _Creds._LocalCreds,
                                        Wait,
                                        strMsg,
                                        dwVerifyFlags);
        _Creds.Revert();

        if (ERROR_SUCCESS == dwErr)
        {
           strMsg.LoadString(g_hInstance, IDS_VERIFY_OUTBOUND);
           strMsg += g_wzCRLF;
           strMsg += g_wzCRLF;
        }
        else
        {
            if (ERROR_CANCELLED == dwErr || ERROR_LOGON_FAILURE == dwErr)
            {
               Wait.SetOld();
               goto ExitCleanup;
            }
            //
            // Set boolean to later prompt for repair.
            //
            fFailed = TRUE;
            //
            // try inbound even if outbound failed.
        }
    }

    DWORD dwErr2;
    dwErr2 = 0;
    bool fInboundSkipped = false;

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        if (!_Creds._RemoteCreds.IsSet())
        {
           // If we don't have credentials for the trusting domain, ask the
           // user if they want to verify the inbound direction and get
           // creds if they answer yes.
           //
           CVerifyInboundDlg VerifyInboundDlg(m_pPage->GetHWnd(),
                                              _Creds._RemoteCreds,
                                              GetTrustPartnerDnsName());

           nResponse = (int)VerifyInboundDlg.DoModal();
        }
        else
        {
           // Since we have creds, just do the verify.
           //
           nResponse = IDYES;
        }

        if (IDYES == nResponse)
        {
           Wait.SetWait();

           if (!pwzRemoteDcUsed)
           {
              pwzRemoteDcUsed = Remote.pwzUncDcName;
           }

           // First, check to see if the creds are valid.
           //
           _Creds._RemoteCreds.Impersonate();

           CPolicyHandle cPolicy(pwzRemoteDcUsed);

           dwErr2 = cPolicy.OpenReqAdmin();

           if (ERROR_SUCCESS != dwErr2)
           {
              Wait.SetOld();
              if (ERROR_NO_SUCH_DOMAIN == dwErr)
              {
                 ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetDnsDomainName(),
                             m_pPage->GetHWnd());
                 _Creds._RemoteCreds.Revert();
              }
              else
              {
                 PCWSTR pwzDomainName = GetTrustPartnerDnsName();
                 SuperMsgBox(m_pPage->GetHWnd(), IDS_VERIFY_BAD_CREDS, 0,
                             MB_OK | MB_ICONEXCLAMATION, dwErr2,
                             (PVOID *)&pwzDomainName, 1,
                             FALSE, __FILE__, __LINE__);
                 _Creds._RemoteCreds.Clear(); // does a revert.
              }
              return IDNO;
           }
           cPolicy.Close();

           // Now do the verification.
           //
           dwErr2 = VerifyTrustOneDirection(pwzRemoteDcUsed,
                                            pwzRemoteDomainName,
                                            pwzLocalDomainName,
                                            NULL,
                                            _Creds._RemoteCreds,
                                            Wait,
                                            strMsg,
                                            dwVerifyFlags);
           _Creds.Revert();

           if (ERROR_SUCCESS == dwErr2)
           {
              CStrW strOK;
              strOK.LoadString(g_hInstance, IDS_VERIFY_INBOUND);
              strMsg += strOK;
              strMsg += g_wzCRLF;
              strMsg += g_wzCRLF;
           }
           else
           {
               Wait.SetOld();
               if (ERROR_CANCELLED == dwErr2 || ERROR_LOGON_FAILURE == dwErr2)
               {
                   dwErr = ERROR_CANCELLED;
                   goto ExitCleanup;
               }
               fFailed = TRUE;
           }
        }
        else
        {
           fInboundSkipped = true;
        }
    }

    DO_DEL(pwzRemoteDcUsed);
    Wait.SetOld();

    if (fFailed)
    {
       if (TRUST_TYPE_DOWNLEVEL == Remote.ulTrustType)
       {
          PCWSTR rgpwzDomainNames[] = {GetDnsDomainName(), GetTrustPartnerDnsName()};

          SuperMsgBox(m_pPage->GetHWnd(), IDS_VERIFY_DOWNLEVEL_TRUST_NOGOOD, 0,
                      MB_OK | MB_ICONEXCLAMATION, (dwErr) ? dwErr : dwErr2,
                      (PVOID *)rgpwzDomainNames, 2, FALSE, __FILE__, __LINE__);

          nResponse = IDNO;
       }
       else
       {
          CVerifyResultsQueryResetDlg ResultsQueryResetDlg(m_pPage->GetHWnd(),
                                                           strMsg,
                                                           _Creds._RemoteCreds,
                                                           GetTrustPartnerDnsName());

          nResponse = (int)ResultsQueryResetDlg.DoModal();
       }
    }
    else
    {
       if (TRUST_DIRECTION_INBOUND == m_nTrustDirection && fInboundSkipped)
       {
          // Nothing tested, return.
          //
          FreeDomainInfo(&Remote);
          return IDNO;
       }

       // If here, then the trust verified OK.
       //
       MsgBox(fInboundSkipped ? 
                 IDS_OUTBOUND_TRUST_VERIFY_DONE : IDS_TRUST_VERIFY_DONE,
              m_pPage->GetHWnd());
      
       nResponse = IDNO;
    }

ExitCleanup:

    if (ERROR_CANCELLED == dwErr || ERROR_LOGON_FAILURE == dwErr)
    {
        // The user was prompted for credentials and either canceled or
        // gave invalid creds.
        //
        SuperMsgBox(m_pPage->GetHWnd(),
                    IDS_CANCEL_CANT_VERIFY, 0,
                    MB_OK | MB_ICONEXCLAMATION,
                    0, NULL, 0,
                    FALSE, __FILE__, __LINE__);
    }

    FreeDomainInfo(&Remote);
    return nResponse;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyInboundDlg::OnInitDialog
//
//-----------------------------------------------------------------------------
LRESULT
CVerifyInboundDlg::OnInitDialog(LPARAM lParam)
{
   FormatWindowText(GetDlgItem(_hDlg, _nMsgID), _pwzTrustingDomain);
   CheckDlgButton(_hDlg, IDC_NO_RADIO, BST_CHECKED);
   EnableWindow(GetDlgItem(_hDlg, IDC_CREDMAN), FALSE);

   if (_Creds.IsSet())
   {
      // Don't need to get them again.
      //
      ShowWindow(GetDlgItem(_hDlg, IDC_CREDMAN), SW_HIDE);
      ShowWindow(GetDlgItem(_hDlg, IDC_CRED_PROMPT), SW_HIDE);
   }
   else
   {
      SendDlgItemMessage(_hDlg, IDC_CREDMAN, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
      SendDlgItemMessage(_hDlg, IDC_CREDMAN, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyInboundDlg
//
//-----------------------------------------------------------------------------
LRESULT
CVerifyInboundDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   BOOL fNameEntered;

   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_YES_RADIO:
         if (!_Creds.IsSet())
         {
            fNameEntered = SendDlgItemMessage(_hDlg, IDC_CREDMAN,
                                              CRM_GETUSERNAMELENGTH,
                                              0, 0) > 0;

            EnableWindow(GetDlgItem(_hDlg, IDOK), fNameEntered);
            EnableWindow(GetDlgItem(_hDlg, IDC_CREDMAN), TRUE);
         }
         break;

      case IDC_NO_RADIO:
         EnableWindow(GetDlgItem(_hDlg, IDOK), TRUE);
         if (!_Creds.IsSet())
         {
            EnableWindow(GetDlgItem(_hDlg, IDC_CREDMAN), FALSE);
         }
         break;

      case IDOK:
         if (IsDlgButtonChecked(_hDlg, IDC_YES_RADIO))
         {
            if (!_Creds.IsSet())
            {
               WCHAR wzName[CREDUI_MAX_USERNAME_LENGTH+1] = {0},
                     wzPw[CREDUI_MAX_PASSWORD_LENGTH+1] = {0};

               Credential_GetUserName(GetDlgItem(_hDlg, IDC_CREDMAN), wzName,
                                      CREDUI_MAX_USERNAME_LENGTH);

               Credential_GetPassword(GetDlgItem(_hDlg, IDC_CREDMAN), wzPw,
                                      CREDUI_MAX_PASSWORD_LENGTH);

               DWORD dwErr = _Creds.SetUserAndPW(wzName, wzPw);

               CHECK_WIN32_REPORT(dwErr, _hDlg, ;);
            }
            EndDialog(_hDlg, IDYES);
         }
         else
         {
            EndDialog(_hDlg, IDNO);
         }
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      default:
         dspAssert(FALSE);
         break;
      }

      return 0;
   }

   if (IDC_CREDMAN == id && CRN_USERNAMECHANGE == codeNotify)
   {
      fNameEntered = SendDlgItemMessage(_hDlg, IDC_CREDMAN,
                                        CRM_GETUSERNAMELENGTH,
                                        0, 0) > 0;

      EnableWindow(GetDlgItem(_hDlg, IDOK), fNameEntered);
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyInboundDlg::OnHelp
//
//-----------------------------------------------------------------------------
LRESULT
CVerifyInboundDlg::OnHelp(LPHELPINFO pHelpInfo)
{
   dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

   if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
   {
      return 0;
   }
   WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyResultsQueryResetDlg::OnInitDialog
//
//-----------------------------------------------------------------------------
LRESULT
CVerifyResultsQueryResetDlg::OnInitDialog(LPARAM lParam)
{

   SetDlgItemText(_hDlg, IDC_VERIFY_FAILURES, _strResults);

   SetFocus(GetDlgItem(_hDlg, IDC_NO_RADIO));

   CVerifyInboundDlg::OnInitDialog(lParam);

   return 1; // this causes the base class to return FALSE so the focus will
}            // remain on the No button.

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::ResetTrust
//
//  Synopsis:   Resets the trust passwords. A new password is allocated for
//              each direction-pair and then assigned.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::ResetTrust(void)
{
    TRACE(CDsTrustedDomainPage, ResetTrust);
    CWaitCursor Wait;
    TD_DOM_INFO Remote;
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status = ERROR_SUCCESS;
    CStrW strUncPDC, strMsg;

    RtlZeroMemory(&Remote, sizeof(TD_DOM_INFO));

    HRESULT hr = GetPDC(strUncPDC);

    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) == hr)
        {
            ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetDomainFlatName(),
                        m_pPage->GetHWnd());
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // don't report error again.
        }
        else
        {
            dspDebugOut((DEB_ERROR,
                         "**** ERROR RETURN <%s @line %d> -> %08lx\n",
                         __FILE__, __LINE__, hr));
        }
        return hr;
    }

    CPolicyHandle cPolicy(strUncPDC);

    dwErr = cPolicy.OpenWithPrompt(_Creds._LocalCreds, Wait,
                                   GetDnsDomainName(), m_pPage->GetHWnd());

    CHECK_WIN32(dwErr, return HRESULT_FROM_WIN32(dwErr));

    Wait.SetWait();

    hr = GetInfoForRemoteDomain(GetTrustPartnerDnsName(), &Remote, _Creds,
                                m_pPage->GetHWnd(),
                                DS_TRUST_INFO_GET_PDC | DS_TRUST_INFO_ALL_ACCESS);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) == hr)
        {
            Wait.SetOld();
            ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetTrustPartnerDnsName(),
                        m_pPage->GetHWnd());
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // don't report error again.
        }
        return hr;
    }

    Wait.SetWait();

    PTRUSTED_DOMAIN_FULL_INFORMATION pOldLocalTDFInfo = NULL,
                                     pOldRemoteTDFInfo = NULL;

    _Creds._LocalCreds.Impersonate();

    Status = LsaQueryTrustedDomainInfo(cPolicy,
                                       Remote.pDnsDomainInfo->Sid,
                                       TrustedDomainFullInformation,
                                       (PVOID *)&pOldLocalTDFInfo);
    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    PPOLICY_PRIMARY_DOMAIN_INFO pDomInfo;

    Status = LsaQueryInformationPolicy(cPolicy,
                                       PolicyPrimaryDomainInformation,
                                       (PVOID *)&pDomInfo);

    _Creds._LocalCreds.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    _Creds._RemoteCreds.Impersonate();

    Status = LsaQueryTrustedDomainInfo(Remote.Policy,
                                       pDomInfo->Sid,
                                       TrustedDomainFullInformation,
                                       (PVOID *)&pOldRemoteTDFInfo);
    _Creds._RemoteCreds.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    LsaFreeMemory(pDomInfo);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    TRUSTED_DOMAIN_FULL_INFORMATION NewLocalTDFInfo, NewRemoteTDFInfo;
    LSA_AUTH_INFORMATION InNewAuthInfo;
    WCHAR wzInPw[MAX_COMPUTERNAME_LENGTH], wzOutPw[MAX_COMPUTERNAME_LENGTH];
    ULONG Length, i;
    LARGE_INTEGER ft;

    GetSystemTimeAsFileTime((PFILETIME)&ft);

    ZeroMemory(&NewLocalTDFInfo, sizeof(TRUSTED_DOMAIN_FULL_INFORMATION));
    ZeroMemory(&NewRemoteTDFInfo, sizeof(TRUSTED_DOMAIN_FULL_INFORMATION));

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        //
        // Build a random password
        //
        HCRYPTPROV  hCryptProv;

        _Creds._LocalCreds.Impersonate();

        BOOL fStatus = CryptAcquireContext(&hCryptProv,
                                           NULL,
                                           NULL,           // Default provider
                                           PROV_RSA_FULL,  // Default's type
                                           0);

        if (fStatus)
        {
            fStatus = CryptGenRandom(hCryptProv,
                                     sizeof(wzInPw),
                                     (PUCHAR)wzInPw);
            
            CryptReleaseContext(hCryptProv, 0);
        }

        _Creds._LocalCreds.Revert();

        if (!fStatus)
        {
            dwErr = GetLastError();
            dspDebugOut((DEB_ITRACE, "Crypto function returned error 0x%08x\n", dwErr));
            return dwErr;
        }

        // Terminate the password
        Length = ARRAYLENGTH(wzInPw);
        Length--;
        wzInPw[Length] = L'\0';
        // Make sure there aren't any NULL's in the password
        for (i = 0; i < Length; i++)
        {
            if (wzInPw[i] == L'\0')
            {
                // arbitrary letter
                wzInPw[i] = L'c';
            }
        }
        //
        // Set the current password data.
        //
        InNewAuthInfo.LastUpdateTime = ft;
        InNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        InNewAuthInfo.AuthInfoLength = Length * sizeof(WCHAR);
        InNewAuthInfo.AuthInfo = (PUCHAR)wzInPw;

        NewLocalTDFInfo.AuthInformation.IncomingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.IncomingAuthenticationInformation = &InNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;

        NewRemoteTDFInfo.AuthInformation.OutgoingAuthInfos = 1;
        NewRemoteTDFInfo.AuthInformation.OutgoingAuthenticationInformation = &InNewAuthInfo;
        NewRemoteTDFInfo.AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        NewRemoteTDFInfo.Information = pOldRemoteTDFInfo->Information;
    }

    LSA_AUTH_INFORMATION OutNewAuthInfo;

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        //
        // Get another password.
        //
        //
        // Build a random password
        //
        HCRYPTPROV  hCryptProv;

        _Creds._LocalCreds.Impersonate();

        BOOL fStatus = CryptAcquireContext(&hCryptProv,
                                           NULL,
                                           NULL,           // Default provider
                                           PROV_RSA_FULL,  // Default's type
                                           0);

        if (fStatus)
        {
            fStatus = CryptGenRandom(hCryptProv,
                                     sizeof(wzOutPw),
                                     (PUCHAR)wzOutPw);
            
            CryptReleaseContext(hCryptProv, 0);
        }

        _Creds._LocalCreds.Revert();

        if (!fStatus)
        {
            dwErr = GetLastError();
            dspDebugOut((DEB_ITRACE, "Crypto function returned error 0x%08x\n", dwErr));
            return dwErr;
        }

        Length = ARRAYLENGTH(wzOutPw);
        Length--;
        wzOutPw[Length] = L'\0';
        for (i = 0; i < Length; i++)
        {
            if (wzOutPw[i] == L'\0')
            {
                wzOutPw[i] = L'd';
            }
        }

        //
        // Set the new password data.
        //
        OutNewAuthInfo.LastUpdateTime = ft;
        OutNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        OutNewAuthInfo.AuthInfoLength = Length * sizeof(WCHAR);
        OutNewAuthInfo.AuthInfo = (PUCHAR)wzOutPw;

        NewLocalTDFInfo.AuthInformation.OutgoingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.OutgoingAuthenticationInformation = &OutNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;

        NewRemoteTDFInfo.AuthInformation.IncomingAuthInfos = 1;
        NewRemoteTDFInfo.AuthInformation.IncomingAuthenticationInformation = &OutNewAuthInfo;
        NewRemoteTDFInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        NewRemoteTDFInfo.Information = pOldRemoteTDFInfo->Information;
    }

    // Save changes.
    //
    _Creds._LocalCreds.Impersonate();

    Status = LsaSetTrustedDomainInfoByName(cPolicy,
                                           &Remote.pDnsDomainInfo->DnsDomainName,
                                           TrustedDomainFullInformation,
                                           &NewLocalTDFInfo);
    _Creds._LocalCreds.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);
    UNICODE_STRING Server;
    RtlInitUnicodeString(&Server, GetDnsDomainName());

    _Creds._RemoteCreds.Impersonate();

    Status = LsaSetTrustedDomainInfoByName(Remote.Policy,
                                           &Server,
                                           TrustedDomainFullInformation,
                                           &NewRemoteTDFInfo);
    _Creds._RemoteCreds.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    //
    // Verify the repaired trust. Setting DS_TRUST_VERIFY_NEW_TRUST because we
    // want to force a reset of the secure channel.
    //
    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        dwErr = VerifyTrustOneDirection(Remote.pwzUncDcName,
                                        Remote.pDnsDomainInfo->DnsDomainName.Buffer,
                                        GetDnsDomainName(),
                                        NULL,
                                        _Creds._RemoteCreds,
                                        Wait,
                                        strMsg,
                                        DS_TRUST_VERIFY_NEW_TRUST);
        switch (dwErr)
        {
        case ERROR_ACCESS_DENIED:
            ErrMsg(IDS_ERR_TRUST_RESET_NOACCESS, m_pPage->GetHWnd());
            dwErr = ERROR_CANCELLED; // don't report error again.
            // fall through.
        case ERROR_CANCELLED:
            goto ExitCleanup;

        case ERROR_SUCCESS:
            break;

        default:
            goto ExitCleanup;
        }
    }

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        dwErr = VerifyTrustOneDirection(strUncPDC,
                                        GetDnsDomainName(),
                                        Remote.pDnsDomainInfo->DnsDomainName.Buffer,
                                        NULL,
                                        _Creds._LocalCreds,
                                        Wait,
                                        strMsg,
                                        DS_TRUST_VERIFY_NEW_TRUST);
        switch (dwErr)
        {
        case ERROR_ACCESS_DENIED:
            ErrMsg(IDS_ERR_TRUST_RESET_NOACCESS, m_pPage->GetHWnd());
            dwErr = ERROR_CANCELLED; // don't report error again.
            // fall through.
        case ERROR_CANCELLED:
            goto ExitCleanup;

        case ERROR_SUCCESS:
            break;

        default:
            goto ExitCleanup;
        }
    }

ExitCleanup:
    _Creds.Revert();
    if (pOldLocalTDFInfo)
        LsaFreeMemory(pOldLocalTDFInfo);
    if (pOldRemoteTDFInfo)
        LsaFreeMemory(pOldRemoteTDFInfo);
    FreeDomainInfo(&Remote);
    return HRESULT_FROM_WIN32(dwErr);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::OnSaveFTInfoBtn
//
//  Synopsis:   Save the FTInfo to a text file after prompting for a name.
//
//-----------------------------------------------------------------------------
void
CDsTrustedDomainPage::OnSaveFTInfoBtn(void)
{
   CFTInfo & FTInfo = _pForestNamePage->GetFTInfo();

   if (!FTInfo.GetCount())
   {
      _pForestNamePage->CheckForNameChanges();

      if (!FTInfo.GetCount())
      {
         ERR_MSG(IDS_NO_FTINFO, m_pPage->GetHWnd());
         return;
      }
   }

   CFTCollisionInfo & ColInfo = _pForestNamePage->GetCollisionInfo();

   SaveFTInfoAs(m_pPage->GetHWnd(),
                GetTrustPartnerFlatName(),
                GetTrustPartnerDnsName(),
                FTInfo, ColInfo);
}

//+----------------------------------------------------------------------------
#if DBG == 1 // TRUSTBREAK
HRESULT
TrustBreakBtn(CDsPropPageBase * pPage, PATTR_MAP,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    // Set the 0x10000000 bit to get the trust break button
    //
    if (DlgOp == fInit && DsPropInfoLevel & DEB_USER13)
    {
        HWND hBtn = GetDlgItem(pPage->GetHWnd(), IDC_BUTTON1);
        ShowWindow(hBtn, SW_SHOW);
        EnableWindow(hBtn, TRUE);
        return S_OK;
    }

    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (DlgOp != fOnCommand)
    {
        return S_OK;
    }

    pTDPage->BreakTrust();

    return S_OK;
}

VOID
CDsTrustedDomainPage::BreakTrust(void)
{
    TRACE(CDsTrustedDomainPage, BreakTrust);
    CWaitCursor Wait;
    TD_DOM_INFO Remote;
    DWORD dwErr;
    NTSTATUS Status = ERROR_SUCCESS;
    CStrW strUncPDC, strMsg;

    RtlZeroMemory(&Remote, sizeof(TD_DOM_INFO));

    HRESULT hr = GetPDC(strUncPDC);

    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) == hr)
        {
            ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)(PWSTR)m_strDomainFlatName,
                        m_pPage->GetHWnd());
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // don't report error again.
        }
        else
        {
            dspDebugOut((DEB_ERROR,
                         "**** ERROR RETURN <%s @line %d> -> %08lx\n",
                         __FILE__, __LINE__, hr));
        }
        return;
    }

    CPolicyHandle cPolicy(strUncPDC);

    dwErr = cPolicy.OpenWithPrompt(_Creds._LocalCreds, Wait,
                                   GetDnsDomainName(), m_pPage->GetHWnd());

    if (ERROR_SUCCESS != dwErr)
    {
        return;
    }

    hr = GetInfoForRemoteDomain(GetTrustPartnerDnsName(), &Remote, _Creds,
                                m_pPage->GetHWnd(),
                                DS_TRUST_INFO_GET_PDC | DS_TRUST_INFO_ALL_ACCESS);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) == hr)
        {
            ErrMsgParam(IDS_ERR_DOMAIN_NOT_FOUND, (LPARAM)GetTrustPartnerDnsName(),
                        m_pPage->GetHWnd());
        }
        else
        {
            CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), ;);
        }
        return;
    }

    PCWSTR pwzRemoteDomainName, pwzLocalDomainName, pwzLocalDcName;
    PUNICODE_STRING pRemoteName;

    if (TRUST_TYPE_DOWNLEVEL == Remote.ulTrustType)
    {
        pwzRemoteDomainName = Remote.pDownlevelDomainInfo->Name.Buffer;
        pRemoteName = &Remote.pDownlevelDomainInfo->Name;
        pwzLocalDomainName = GetDomainFlatName();
        pwzLocalDcName = NULL;
    }
    else
    {
        pwzRemoteDomainName = Remote.pDnsDomainInfo->DnsDomainName.Buffer;
        pRemoteName = &Remote.pDnsDomainInfo->DnsDomainName;
        pwzLocalDomainName = GetDnsDomainName();
        pwzLocalDcName = strUncPDC;
    }

    dspDebugOut((DEB_ITRACE, "Reading Trusted Domain Full Info for %ws\n",
                 pwzRemoteDomainName));
    Wait.SetWait();
    PTRUSTED_DOMAIN_FULL_INFORMATION pOldLocalTDFInfo = NULL;

    Status = LsaQueryTrustedDomainInfoByName(cPolicy,
                                             pRemoteName,
                                             TrustedDomainFullInformation,
                                             (PVOID *)&pOldLocalTDFInfo);

    CHECK_LSA_STATUS_REPORT(Status, m_pPage->GetHWnd(), goto ExitCleanup);

    TRUSTED_DOMAIN_FULL_INFORMATION NewLocalTDFInfo;
    LSA_AUTH_INFORMATION InNewAuthInfo;
    WCHAR wzInPw[MAX_COMPUTERNAME_LENGTH], wzOutPw[MAX_COMPUTERNAME_LENGTH];
    ULONG Length, i;

    ZeroMemory(&NewLocalTDFInfo, sizeof(TRUSTED_DOMAIN_FULL_INFORMATION));

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        // Build a random password
        //
        //
        // Build a random password
        //
        HCRYPTPROV  hCryptProv;

        BOOL fStatus = CryptAcquireContext(&hCryptProv,
                                           NULL,
                                           NULL,           // Default provider
                                           PROV_RSA_FULL,  // Default's type
                                           0);

        if (fStatus)
        {
            fStatus = CryptGenRandom(hCryptProv,
                                     sizeof(wzInPw),
                                     (PUCHAR)wzInPw);
            
            CryptReleaseContext(hCryptProv, 0);
        }

#if DBG == 1
        if (!fStatus)
        {
            // If false then we just get random stack noise.
            //
            dwErr = GetLastError();
            dspDebugOut((DEB_ITRACE, "Crypto function returned error 0x%08x\n", dwErr));
        }
#endif

        // Terminate the password
        Length = ARRAYLENGTH(wzInPw);
        Length--;
        wzInPw[Length] = L'\0';
        // Make sure there aren't any NULL's in the password
        for (i = 0; i < Length; i++)
        {
            if (wzInPw[i] == L'\0')
            {
                // arbitrary letter
                wzInPw[i] = L'c';
            }
        }
        //
        // Set the current password data.
        //
        GetSystemTimeAsFileTime((PFILETIME)&InNewAuthInfo.LastUpdateTime);

        InNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        InNewAuthInfo.AuthInfoLength = Length * sizeof(WCHAR);
        InNewAuthInfo.AuthInfo = (PUCHAR)wzInPw;

        NewLocalTDFInfo.AuthInformation.IncomingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.IncomingAuthenticationInformation = &InNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;
    }

    LSA_AUTH_INFORMATION OutNewAuthInfo;

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        // Get another password.
        //
        //
        // Build a random password
        //
        HCRYPTPROV  hCryptProv;

        BOOL fStatus = CryptAcquireContext(&hCryptProv,
                                           NULL,
                                           NULL,           // Default provider
                                           PROV_RSA_FULL,  // Default's type
                                           0);

        if (fStatus)
        {
            fStatus = CryptGenRandom(hCryptProv,
                                     sizeof(wzOutPw),
                                     (PUCHAR)wzOutPw);
            
            CryptReleaseContext(hCryptProv, 0);
        }

#if DBG == 1
        if (!fStatus)
        {
            // If false then we just get random stack noise.
            //
            dwErr = GetLastError();
            dspDebugOut((DEB_ITRACE, "Crypto function returned error 0x%08x\n", dwErr));
        }
#endif

        Length = ARRAYLENGTH(wzOutPw);
        Length--;
        wzOutPw[Length] = L'\0';
        for (i = 0; i < Length; i++)
        {
            if (wzOutPw[i] == L'\0')
            {
                wzOutPw[i] = L'd';
            }
        }

        //
        // Set the new password data.
        //
        GetSystemTimeAsFileTime((PFILETIME)&OutNewAuthInfo.LastUpdateTime);

        OutNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        OutNewAuthInfo.AuthInfoLength = Length * sizeof(WCHAR);
        OutNewAuthInfo.AuthInfo = (PUCHAR)wzOutPw;

        NewLocalTDFInfo.AuthInformation.OutgoingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.OutgoingAuthenticationInformation = &OutNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;
    }

    dspDebugOut((DEB_ITRACE, "Writing new trust password(s) for %ws\n",
                 pwzRemoteDomainName));
    // Save changes.
    //
    Status = LsaSetTrustedDomainInfoByName(cPolicy,
                                           pRemoteName,
                                           TrustedDomainFullInformation,
                                           &NewLocalTDFInfo);
    CHECK_LSA_STATUS_REPORT(Status, m_pPage->GetHWnd(), goto ExitCleanup);
    dspDebugOut((DEB_ITRACE, "Trust password(s) successfully changed for %ws\n",
                 pwzRemoteDomainName));

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        VerifyTrustOneDirection(Remote.pwzUncDcName,
                                pwzRemoteDomainName,
                                pwzLocalDomainName,
                                NULL,
                                _Creds._RemoteCreds,
                                Wait,
                                strMsg);
    }

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        VerifyTrustOneDirection(strUncPDC,
                                GetDnsDomainName(),
                                pwzRemoteDomainName,
                                NULL,
                                _Creds._LocalCreds,
                                Wait,
                                strMsg);
    }

ExitCleanup:
    if (pOldLocalTDFInfo)
        LsaFreeMemory(pOldLocalTDFInfo);
    FreeDomainInfo(&Remote);
}
#endif // DBG == 1 TRUSTBREAK

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\trust.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.cxx
//
//  Contents:   Domain trust support
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"
#include "domain.h"
#include <lmerr.h>
#include "BehaviorVersion.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  CDsDomainTrustsPage: Domain Trust Page object
//
//-----------------------------------------------------------------------------

#define IDX_TRUST_FLAT_NAME 0
#define IDX_TRUST_ATTR_ATTR 1
#define IDX_TRUST_DIR_ATTR  2
#define IDX_TRUST_TYPE_ATTR 3
#define IDX_TRUST_PARTNER   4
#define NUM_TRUST_ATTR      5

//+----------------------------------------------------------------------------
//
//  Member: CTrustPropPageBase::CTrustPropPageBase
//
//-----------------------------------------------------------------------------
CTrustPropPageBase::CTrustPropPageBase() :
    m_rgTrustList(NULL),
    m_cTrusts(0),
    m_iDomain((ULONG)(-1)),
    m_fIsForestRoot(FALSE),
    m_fIsInitialized(FALSE)
{
    TRACE(CTrustPropPageBase,CTrustPropPageBase);
#ifdef _DEBUG
    strcpy(szClass, "CTrustPropPageBase");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrustPropPageBase::~CTrustPropPageBase
//
//-----------------------------------------------------------------------------
CTrustPropPageBase::~CTrustPropPageBase()
{
    TRACE(CTrustPropPageBase,~CTrustPropPageBase);

    FreeTrustData();
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::Initialize
//
//  Synopsis:   Do initialialization common to all subclasses.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPropPageBase::Initialize(CDsPropPageBase * pPage)
{
   TRACE(CTrustPropPageBase, Initialize);
   HRESULT hr = S_OK;

   CWaitCursor Wait;

   m_pPage = pPage;

   //
   // Get the DC name.
   //
   CStrW strServer;

   hr = GetLdapServerName(m_pPage->m_pDsObj, strServer);

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);

   m_strUncDC = L"\\\\";
   m_strUncDC += strServer;

   //
   // Get the domain name in various formats.
   //
   CPolicyHandle cPolicy(GetDomainDcName());
   CCredMgr Creds;

   DWORD dwErr = cPolicy.OpenWithAnonymous(Creds); // Open without modify privilege.

   CHECK_WIN32_REPORT(dwErr, m_pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr));

   NTSTATUS Status = STATUS_SUCCESS;
   PPOLICY_DNS_DOMAIN_INFO pDomInfo = NULL;

   Status = LsaQueryInformationPolicy(cPolicy,
                                      PolicyDnsDomainInformation,
                                      (PVOID *)&pDomInfo);

   dwErr = LsaNtStatusToWinError(Status);

   CHECK_WIN32_REPORT(dwErr, m_pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr));

   dspAssert(pDomInfo);

   m_strDomainFlatName = pDomInfo->Name.Buffer;

   m_strDomainDnsName = pDomInfo->DnsDomainName.Buffer;

   m_strForestName = pDomInfo->DnsForestName.Buffer;

   m_fIsForestRoot = _wcsicmp(m_strDomainDnsName, pDomInfo->DnsForestName.Buffer) == 0;

   LsaFreeMemory(pDomInfo);

   hr = QueryTrusts();

   if (SUCCEEDED(hr))
   {
      m_fIsInitialized = TRUE;
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::QueryTrusts
//
//  Synopsis:   Enumerate the trusts.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPropPageBase::QueryTrusts(void)
{
    TRACE(CTrustPropPageBase,QueryTrusts);
    HRESULT hr = S_OK;
    CStrW strServer;
    PDS_DOMAIN_TRUSTSW rgTrusts = NULL;
    DWORD dwRet = 0;
    ULONG cTrusts = 0, i = 0, j = 0;

    hr = GetLdapServerName(m_pPage->m_pDsObj, strServer);

    CHECK_HRESULT(hr, return hr);

    dspDebugOut((DEB_ITRACE, "Reading trusts from server: %ws\n", strServer));

    // All forest domains must be enumerated in order to get the local domain,
    // which is the primary domain wrt trust.
    //
    dwRet = DsEnumerateDomainTrusts(strServer,
                                    DS_DOMAIN_IN_FOREST |
                                    DS_DOMAIN_DIRECT_OUTBOUND | 
                                    DS_DOMAIN_DIRECT_INBOUND,
                                    &rgTrusts,
                                    &cTrusts);

    CHECK_WIN32_REPORT(dwRet, m_pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwRet));

    if (!cTrusts) return S_OK;

    dspAssert(rgTrusts);

    // First, get a count of directly trusted domains (+ local domain) so
    // that the correct array size is allocated.
    //
    for (i = 0; i < cTrusts; i++)
    {
        if (rgTrusts[i].Flags & (DS_DOMAIN_PRIMARY | 
                                 DS_DOMAIN_DIRECT_OUTBOUND | 
                                 DS_DOMAIN_DIRECT_INBOUND))
        {
            j++;
        }
    }

    dspDebugOut((DEB_ITRACE, "Total domains: %d, directly trusted: %d\n", cTrusts, j));

    m_cTrusts = j;

    m_rgTrustList = new CEnumDomainTrustItem[m_cTrusts];

    CHECK_NULL_REPORT(m_rgTrustList, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

    // Now copy the trust data.
    //
    for (i = 0, j = 0; i < cTrusts; i++)
    {
        if (!(rgTrusts[i].Flags & (DS_DOMAIN_PRIMARY | 
                                   DS_DOMAIN_DIRECT_OUTBOUND | 
                                   DS_DOMAIN_DIRECT_INBOUND)))
        {
            // Not interested in indirectly trusted domains.
            //
            continue;
        }
        //
        // Copy the trust data
        //
        m_rgTrustList[j].ulFlags = rgTrusts[i].Flags;
        m_rgTrustList[j].ulTrustAttrs = rgTrusts[i].TrustAttributes;
        m_rgTrustList[j].ulTrustType = rgTrusts[i].TrustType;
        m_rgTrustList[j].ulOriginalIndex = i;
        m_rgTrustList[j].ulParentIndex = rgTrusts[i].ParentIndex;
        m_rgTrustList[j].strDNSname = rgTrusts[i].DnsDomainName;
        m_rgTrustList[j].strFlatName = rgTrusts[i].NetbiosDomainName;

        if (rgTrusts[i].Flags & DS_DOMAIN_PRIMARY)
        {
            // This is the local domain.
            //
            dspAssert(_wcsicmp(GetDomainFlatName(), rgTrusts[i].NetbiosDomainName) == 0);

            m_iDomain = j;

            if (!(rgTrusts[i].Flags & DS_DOMAIN_TREE_ROOT))
            {
                // If not the root, then it has a parent.
                //
                dspAssert(rgTrusts[i].ParentIndex < m_cTrusts);

                m_strDomainParent = rgTrusts[rgTrusts[i].ParentIndex].DnsDomainName;
            }

            m_rgTrustList[j].nRelationship = TRUST_REL_SELF;
        }

        j++;
    }

    // Finally, set relationship value.
    //
    for (i = 0; i < m_cTrusts; i++)
    {
        if (i == m_iDomain)
        {
            // local domain already done.
            //
            continue;
        }

        if (!m_strDomainParent.IsEmpty() && _wcsicmp(m_strDomainParent, m_rgTrustList[i].strDNSname) == 0)
        {
            // This is the parent domain.
            //
            m_rgTrustList[i].nRelationship = TRUST_REL_PARENT;

            continue;
        }

        if (m_rgTrustList[i].ulFlags & DS_DOMAIN_IN_FOREST)
        {
            if (m_rgTrustList[i].ulParentIndex == m_rgTrustList[m_iDomain].ulOriginalIndex)
            {
                m_rgTrustList[i].nRelationship = TRUST_REL_CHILD;
            }
            else if (m_rgTrustList[i].ulFlags & DS_DOMAIN_TREE_ROOT &&
                     m_rgTrustList[m_iDomain].ulFlags & DS_DOMAIN_TREE_ROOT)
            {
                // If the local domain is a tree root, and the current domain
                // is a tree root, then it is a tree root relationship.
                //
                m_rgTrustList[i].nRelationship = TRUST_REL_ROOT;
            }
            else
            {
                // Otherwise it is a crosslink
                //
                m_rgTrustList[i].nRelationship = TRUST_REL_CROSSLINK;
            }

            continue;
        }

        // Only external trust now left.
        //
        switch (m_rgTrustList[i].ulTrustType)
        {
        case TRUST_TYPE_MIT:
            m_rgTrustList[i].nRelationship = TRUST_REL_MIT;
            break;

        case TRUST_TYPE_DCE:
            m_rgTrustList[i].nRelationship = TRUST_REL_DCE;
            break;

        default:
            dspDebugOut((DEB_ITRACE, "Unknown trust type %d\n", m_rgTrustList[i].ulTrustType));
            // fall through to external
        case TRUST_TYPE_DOWNLEVEL:
        case TRUST_TYPE_UPLEVEL:
            if (m_rgTrustList[i].ulTrustAttrs & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
            {
               m_rgTrustList[i].nRelationship = TRUST_REL_FOREST;
            }
            else
            {
               m_rgTrustList[i].nRelationship = TRUST_REL_EXTERNAL;
            }
        }
    }

    NetApiBufferFree(rgTrusts);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::FreeTrustData
//
//  Synopsis:   Frees the trust data.
//
//-----------------------------------------------------------------------------
void
CTrustPropPageBase::FreeTrustData(void)
{
    if (!m_rgTrustList) return;

    delete [] m_rgTrustList;

    m_rgTrustList = NULL;

    m_cTrusts = 0;
    m_iDomain = (ULONG)(-1);

    m_strDomainParent.Empty();

    return;
}

//+----------------------------------------------------------------------------
//
//  Member: CDsDomainTrustsPage::CDsDomainTrustsPage
//
//-----------------------------------------------------------------------------
CDsDomainTrustsPage::CDsDomainTrustsPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) :
   m_CtrlId(0),
   m_fIsAllWhistler(FALSE),
   m_fSetAllWhistler(FALSE),
   CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsDomainTrustsPage,CDsDomainTrustsPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsDomainTrustsPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsDomainTrustsPage::~CDsDomainTrustsPage
//
//-----------------------------------------------------------------------------
CDsDomainTrustsPage::~CDsDomainTrustsPage()
{
    TRACE(CDsDomainTrustsPage,~CDsDomainTrustsPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateDomTrustPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateDomTrustPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                   PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                   DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                   HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateDomTrustPage);

    CDsDomainTrustsPage * pPageObj = new CDsDomainTrustsPage(pDsPage, pDataObj,
                                                             hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsDomainTrustsPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_ADSPROP_NOTIFY_CHANGE:
       {
        CWaitCursor Wait;
        ClearUILists();
        FreeTrustData();
        QueryTrusts();
        RefreshLists();
       }
        return TRUE;

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsDomainTrustsPage::OnInitDialog(LPARAM)
{
    TRACE(CDsDomainTrustsPage, OnInitDialog);
    HRESULT hr;

    hr = Initialize(this);

    CHECK_HRESULT(hr, return hr);

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    //
    // Initialize the list view controls.
    //
    HWND hTrustedList = GetDlgItem(m_hPage, IDC_TRUSTED_LIST);
    HWND hTrustingList = GetDlgItem(m_hPage, IDC_TRUSTING_LIST);

    ListView_SetExtendedListViewStyle(hTrustedList, LVS_EX_FULLROWSELECT |
                                                    LVS_EX_LABELTIP);
    ListView_SetExtendedListViewStyle(hTrustingList, LVS_EX_FULLROWSELECT |
                                                     LVS_EX_LABELTIP);
    //
    // Set the column headings.
    //
    PTSTR ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_DOMAIN, &ptsz))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }

    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 134;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_DOMNAME_COL;

    ListView_InsertColumn(hTrustedList, IDX_DOMNAME_COL, &lvc);
    ListView_InsertColumn(hTrustingList, IDX_DOMNAME_COL, &lvc);

    delete ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_RELATION, &ptsz))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }

    lvc.cx = 70;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_RELATION_COL;

    ListView_InsertColumn(hTrustedList, IDX_RELATION_COL, &lvc);
    ListView_InsertColumn(hTrustingList, IDX_RELATION_COL, &lvc);

    delete ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_TRANSITIVE, &ptsz))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }

    lvc.cx = 65;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_TRANSITIVE_COL;

    ListView_InsertColumn(hTrustedList, IDX_TRANSITIVE_COL, &lvc);
    ListView_InsertColumn(hTrustingList, IDX_TRANSITIVE_COL, &lvc);

    delete ptsz;

    RefreshLists();

    EnableButtons(IDC_TRUSTED_LIST, FALSE);
    EnableButtons(IDC_TRUSTING_LIST, FALSE);
    if (m_fReadOnly)
    {
       EnableWindow(GetDlgItem(m_hPage, IDC_ADD_TRUST_BTN), FALSE);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsDomainTrustsPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (m_fInInit)
   {
       return 0;
   }
   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_ADD_TRUST_BTN:
         OnAddTrustClick();
         break;

      case IDC_REMOVE_TRUSTED_BTN:
         OnRemoveTrustClick(IDC_TRUSTED_LIST);
         break;

      case IDC_VIEW_TRUSTED_BTN:
         OnViewTrustClick(IDC_TRUSTED_LIST);
         break;

      case IDC_REMOVE_TRUSTING_BTN:
         OnRemoveTrustClick(IDC_TRUSTING_LIST);
         break;

      case IDC_VIEW_TRUSTING_BTN:
         OnViewTrustClick(IDC_TRUSTING_LIST);
         break;
      }
   }
   return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsDomainTrustsPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    dspDebugOut((DEB_USER6, "DsProp listview id %d code %d\n",
                 ((LPNMHDR)lParam)->code));

    if (m_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        EnableButtons(((LPNMHDR)lParam)->idFrom, TRUE);
        break;

    case NM_SETFOCUS:
        {
           HWND hList = GetDlgItem(m_hPage, (int)((LPNMHDR)lParam)->idFrom);

           if (ListView_GetItemCount(hList))
           {
              int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

              if (item < 0)
              {
                 // If nothing is selected, set the focus to the first item.
                 //
                 LV_ITEM lvi = {0};
                 lvi.mask = LVIF_STATE;
                 lvi.stateMask = LVIS_FOCUSED;
                 lvi.state = LVIS_FOCUSED;
                 ListView_SetItem(hList, &lvi);
              }
           }
        }
        EnableButtons(((LPNMHDR)lParam)->idFrom, TRUE);
        break;

    case NM_KILLFOCUS:
        EnableButtons(((LPNMHDR)lParam)->idFrom, TRUE);
        break;
#ifdef NOTYET
        DEFAULT_UNREACHABLE
#endif
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsDomainTrustsPage::IsAllWhistler
//
//  Synopsis:  Call GetEnterpriseVer to check the msDS-Behavior-Version
//             attribute of the Partitions container. If the value exists
//             and is greater or equal to 1, then the function returns
//             TRUE. The value is cached for subsequent calls.
//
//-----------------------------------------------------------------------------
BOOL
CDsDomainTrustsPage::IsAllWhistler(void)
{
   TRACE(CDsDomainTrustsPage,IsAllWhistler)

   if (m_fSetAllWhistler)
   {
      return m_fIsAllWhistler;
   }

   m_fIsAllWhistler = FALSE;

   // skip leading backslashes on DC name.
   HRESULT hr = GetEnterpriseVer(GetDomainDcName() + 2, &m_fIsAllWhistler);

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return FALSE);

   m_fSetAllWhistler = TRUE;

   return m_fIsAllWhistler;
}

//+----------------------------------------------------------------------------
//
//  Function:  GetEnterpriseVer
//
//  Synopsis:  Checks the msDS-Behavior-Version attribute of the Partitions
//             container. If the value exists and is greater or equal to 1,
//             then the parameter boolean is set to TRUE.
//
// TODO: move to CDSBasePathsInfo and return a version number rather than the bool
//-----------------------------------------------------------------------------
HRESULT
GetEnterpriseVer(PCWSTR pwzDC, BOOL * pfAllWhistler)
{
   dspDebugOut((DEB_ITRACE, "GetEnterpriseVer checking %ws\n", pwzDC));
   dspAssert(pwzDC && *pwzDC != L'\\');

#if defined(XFOREST_TEST_REG_CHECK)
   // Test switch. In the registry key:
#define XFOREST_SWITCH_PATH   L"SYSTEM\\CurrentControlSet\\Control\\Lsa"
   // look for the REG_DWORD value:
#define XFOREST_SWITCH_VALUE  L"EnableXForest"
   // if present, the check for the V_forest value in AD is skipped.

   HKEY hKeyMachine = NULL;
   LONG lRet = 0;
   CStrW strUncDC;
   strUncDC = L"\\\\";
   strUncDC += pwzDC;
   PWSTR pwz = wcschr(const_cast<PWSTR>(strUncDC.GetBuffer(0)), L'.');
   if (pwz)
   {
      *pwz = L'\0';
   }
   lRet = RegConnectRegistry(strUncDC, HKEY_LOCAL_MACHINE, &hKeyMachine);
   if (lRet == ERROR_SUCCESS)
   {
      HKEY hKey;
      lRet = RegOpenKeyEx(hKeyMachine, XFOREST_SWITCH_PATH, 0, KEY_READ, &hKey);
      RegCloseKey(hKeyMachine);
      if (lRet == ERROR_SUCCESS)
      {
         DWORD dwSize = sizeof(ULONG), dwValue;
         if (RegQueryValueEx(hKey, XFOREST_SWITCH_VALUE, NULL, NULL,
                             (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
         {
            if (1 == dwValue)
            {
               dspDebugOut((DEB_ITRACE, "EnableXForest value of 1 found, skipping AD check.\n"));
               *pfAllWhistler = TRUE;
            }
            RegCloseKey(hKey);
            return S_OK;
         }
         RegCloseKey(hKey);
      }
   }
   else
   {
      dspDebugOut((DEB_ITRACE, "RegConnectRegistry failed with error %d (0x%x)\n", lRet, lRet));
   }
#endif // XFOREST_TEST_REG_CHECK

   //
   // Look in the AD for the V_forest value.
   //

   CDSBasePathsInfo cBase;

   HRESULT hr = cBase.InitFromName(pwzDC);

   CHECK_HRESULT(hr, return hr);

   CStrW strPath = cBase.GetConfigNamingContext();

   CComPtr<IADsPathname> spADsPath;

   hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                         IID_IADsPathname, (PVOID *)&spADsPath);

   CHECK_HRESULT(hr, return hr);

   hr = spADsPath->Set(strPath, ADS_SETTYPE_DN);

   CHECK_HRESULT(hr, return hr);

   hr = spADsPath->SetDisplayType(ADS_DISPLAY_FULL);

   CHECK_HRESULT(hr, return hr);

   hr = spADsPath->AddLeafElement(g_wzPartitionsContainer);

   CHECK_HRESULT(hr, return hr);

   CComBSTR bstrPartitions;

   hr = spADsPath->Retrieve(ADS_FORMAT_X500, &bstrPartitions);

   CHECK_HRESULT(hr, return hr);

   dspDebugOut((DEB_ITRACE, "Binding to %ws\n", bstrPartitions));

   CComPtr<IADs> spPartitions;

   hr = ADsOpenObject(bstrPartitions, NULL, NULL, 0, IID_IADs, (PVOID *)&spPartitions);

   CHECK_HRESULT(hr, return hr);

   CComVariant var;

   hr = spPartitions->Get(g_wzBehaviorVersion, &var);

   if (E_ADS_PROPERTY_NOT_FOUND == hr)
   {
      // Win2K will return property-not-found.
      //
      hr = S_OK;

      *pfAllWhistler = FALSE;
   }
   else
   {
      CHECK_HRESULT(hr, return hr);

      *pfAllWhistler = var.iVal >= FOREST_VER_XP;
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnAddTrustClick
//
//  Synopsis:   Posts the Add-Trust Wizard.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::OnAddTrustClick(void)
{
   TRACER(CDsDomainTrustsPage, OnAddTrustClick);

   //
   // Launch the New Trust Wizard.
   //

   CNewTrustWizard Wiz(this);

   HRESULT hr = Wiz.CreatePages();

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), /*delete pWiz;*/ return);

   hr = Wiz.LaunchModalWiz();

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), /*delete pWiz;*/ return);

   hr = Wiz.GetCreationResult();

   if (SUCCEEDED(hr))
   {
      CWaitCursor Wait;
      ClearUILists();
      FreeTrustData();
      QueryTrusts();
      RefreshLists();
   }

   if (Wiz.Trust.AreThereCollisions())
   {
      // If there are name collisions, ask if the user wants to save the
      // forest trust naming info to a file.
      //
      CStrW strTitle, strMsg;

      strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
      strMsg.FormatMessage(g_hInstance, IDS_COLLISIONS_MSG, Wiz.OtherDomain.GetDnsName());

      int nRet = MessageBox(GetHWnd(), strMsg, strTitle, MB_YESNO);

      if (IDYES == nRet)
      {
         SaveFTInfoAs(GetHWnd(),
                      Wiz.OtherDomain.GetFlatName(),
                      Wiz.OtherDomain.GetDnsName(),
                      Wiz.Trust.ReturnFTInfo(),
                      Wiz.Trust.ReturnCollisionInfo());
      }
   }

   return;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnRemoveTrustClick
//
//  Synopsis:   Remove the direction of trust indicated by the current list
//              selection.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::OnRemoveTrustClick(int id)
{
    TRACE(CDsDomainTrustsPage, OnRemoveTrustClick);
    HRESULT hr;
    int iRet;

    //
    // Determine which list item was selected for deletion.
    //
    HWND hList = GetDlgItem(m_hPage, id);

    int i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);

    if (i < 0)
    {
        dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
        return;
    }

    WCHAR wzTrustedDomain[MAX_PATH + 1];

    ListView_GetItemText(hList, i, 0, wzTrustedDomain, MAX_PATH);

    dspAssert(wcslen(wzTrustedDomain) > 0);

    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = i;
    lvi.iSubItem = IDX_DOMNAME_COL;

    if (!ListView_GetItem(hList, &lvi))
    {
        dspAssert(FALSE);
        return;
    }
    PCEnumDomainTrustItem pTrust = (PCEnumDomainTrustItem)lvi.lParam;
    dspAssert(pTrust);

    //
    // Post a confirmation query.
    //
    CStr strTitle, strMsg, strFormat;

    if (!strTitle.LoadString(g_hInstance, IDS_MSG_TITLE))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return;
    }
    if (!strFormat.LoadString(g_hInstance, IDS_MSG_REMOVE_CONFIRM))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return;
    }

    strMsg.Format(strFormat, wzTrustedDomain, wzTrustedDomain);

    iRet = MessageBox(m_hPage, strMsg, strTitle, MB_YESNO | MB_ICONWARNING);

    if (iRet != IDYES)
    {
        return;
    }

    //
    // Remove the trust.
    //
    TD_DOM_INFO Remote;
    CWaitCursor Wait;

    RtlZeroMemory(&Remote, sizeof(TD_DOM_INFO));

    CPolicyHandle cPolicy(GetDomainDcName());
    CCredMgr Creds;

    DWORD dwErr = cPolicy.OpenWithPrompt(Creds._LocalCreds, Wait,
                                         GetDnsDomainName(), m_hPage);

    if (ERROR_CANCELLED == dwErr)
    {
        // don't report error if user canceled.
        //
        return;
    }

    CHECK_WIN32_REPORT(dwErr, m_hPage, return);

    if (pTrust->nRelationship == TRUST_REL_MIT)
    {
        if (!AllocWStr(wzTrustedDomain, &Remote.pwzDomainName))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return;
        }
        Remote.ulTrustType = TRUST_TYPE_MIT;
    }
    else
    {
        hr = GetInfoForRemoteDomain(wzTrustedDomain, &Remote, Creds, m_hPage);

        if (FAILED(hr))
        {
            switch (hr)
            {
            case HRESULT_FROM_WIN32(STATUS_ACCESS_DENIED):
            case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
                ErrMsgParam(IDS_ERRMSG_NO_ACCESS, (LPARAM)wzTrustedDomain, m_hPage);
                break;

            case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
            case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):
            case HRESULT_FROM_WIN32(RPC_S_INVALID_NET_ADDR):
            case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
            case HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE):
                //
                // Remote domain not found. Ask user if the trust should be
                // forcibly removed from this domain.
                //
                if (!AllocWStr(wzTrustedDomain, &Remote.pwzDomainName))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                    return;
                }
                Remote.ulTrustType = TRUST_TYPE_NO_DC;

                hr = QueryDeleteTrust(cPolicy, &Remote, Creds._LocalCreds);

                if (hr == S_OK)
                {
                    Wait.SetWait();
                    ClearUILists();
                    FreeTrustData();
                    QueryTrusts();
                    RefreshLists();
                    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_TRUSTED_BTN), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_VIEW_TRUSTED_BTN), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_TRUSTING_BTN), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_VIEW_TRUSTING_BTN), FALSE);
                    SetFocus(GetDlgItem(m_hPage, IDC_ADD_TRUST_BTN));
                }
                break;

            default:
                CHECK_HRESULT_REPORT(hr, m_hPage, ;);
            }

            return;
        }
    }

    NTSTATUS Status;

    if ((pTrust->ulFlags & DS_DOMAIN_DIRECT_OUTBOUND) &&
        (pTrust->ulFlags & DS_DOMAIN_DIRECT_INBOUND))
    {
        // Remove the trust in one direction only.
        //
        Status = RemoveTrustDirection(cPolicy, &Remote,
                                      (id == IDC_TRUSTED_LIST) ? 
                                        REMOVE_TRUST_OUTBOUND :
                                        REMOVE_TRUST_INBOUND,
                                      Creds._LocalCreds);
    }
    else
    {
        // Remove all trust.
        //
        Creds._LocalCreds.Impersonate();

        Status = DeleteTrust(cPolicy, &Remote);

        Creds._LocalCreds.Revert();
    }

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        Status == STATUS_NO_SUCH_DOMAIN)
    {
        Status = 0;
        //
        // Remote domain does not know about the trust (i.e. remote domain
        // was clean-reinstalled without having trust re-established) or the
        // remote domain no longer exists.
        // Ask user if the remnants of the trust should be removed on this
        // side.
        //
        DO_DEL(Remote.pwzDomainName);
        if (!AllocWStr(wzTrustedDomain, &Remote.pwzDomainName))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            FreeDomainInfo(&Remote);
            return;
        }
        Remote.ulTrustType = TRUST_TYPE_NO_DC;

        hr = QueryDeleteTrust(cPolicy, &Remote, Creds._LocalCreds);

        CHECK_HRESULT(hr, Status = STATUS_UNSUCCESSFUL)
    }
    else
    {
        CHECK_LSA_STATUS_REPORT(Status, GetHWnd(), ;);
    }

    FreeDomainInfo(&Remote);

    if (NT_SUCCESS(Status))
    {
        Wait.SetWait();
        ClearUILists();
        FreeTrustData();
        QueryTrusts();
        RefreshLists();
        if (IDC_TRUSTED_LIST == id)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_TRUSTED_BTN), FALSE);
            EnableWindow(GetDlgItem(m_hPage, IDC_VIEW_TRUSTED_BTN), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_TRUSTING_BTN), FALSE);
            EnableWindow(GetDlgItem(m_hPage, IDC_VIEW_TRUSTING_BTN), FALSE);
        }
        SetFocus(GetDlgItem(m_hPage, IDC_ADD_TRUST_BTN));
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnViewTrustClick
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::OnViewTrustClick(int id)
{
    TRACE(CDsDomainTrustsPage, OnViewTrustClick);
    HWND hList = GetDlgItem(m_hPage, id);

    int i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);

    if (i < 0)
    {
        dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
        return;
    }

    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = i;
    lvi.iSubItem = IDX_DOMNAME_COL;
    if (!ListView_GetItem(hList, &lvi))
    {
        dspAssert(FALSE);
        return;
    }
    PCEnumDomainTrustItem pTrust = (PCEnumDomainTrustItem)lvi.lParam;
    dspAssert(pTrust);

    if (pTrust->strTDOpath.IsEmpty())
    {
        // Search for the TDO that represents this trust.
        //
        HRESULT hr;
        //
        // Compose the path to the System container where the Trusted-Domain
        // objects can be found.
        //
        CComPtr<IADsPathname> spADsPath;

        WCHAR wzSys[] = L"cn=system";
        CComBSTR cbstrSysPath;
        CStrW strADsPath;
        hr = GetADsPathname(spADsPath);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spADsPath->Set(m_pwszObjPathName, ADS_SETTYPE_FULL);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spADsPath->AddLeafElement(wzSys);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spADsPath->Retrieve(ADS_FORMAT_X500, &cbstrSysPath);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        CComPtr <IDirectorySearch> spDsSearch;
        ADS_SEARCH_HANDLE hSrch = NULL;
        PWSTR pwzAttrs[] = {g_wzADsPath};
        PCWSTR pwzDnsName = GetDnsDomainName();

        hr = ADsOpenObject(cbstrSysPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                           IID_IDirectorySearch, (PVOID *)&spDsSearch);

        if (HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE) == hr)
        {
            SuperMsgBox(m_pPage->GetHWnd(),
                        IDS_TRUST_BROKEN, 0,
                        MB_OK | MB_ICONEXCLAMATION,
                        0, (PVOID *)&pwzDnsName, 1,
                        FALSE, __FILE__, __LINE__);
            return;
        }
        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        ADS_SEARCHPREF_INFO SearchPref;
        SearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        SearchPref.vValue.Integer = ADS_SCOPE_ONELEVEL;
        SearchPref.vValue.dwType = ADSTYPE_INTEGER;

        hr = spDsSearch->SetSearchPreference(&SearchPref, 1);

        CHECK_HRESULT_REPORT(hr, m_hPage, return);

        CStrW cstrFilter;

        cstrFilter.Format(L"(&(objectCategory=trustedDomain)(flatName=%s))", pTrust->strFlatName);

        //
        // Search for the matching trustedDomain object.
        //
        hr = spDsSearch->ExecuteSearch(cstrFilter,
                                       pwzAttrs, 1, &hSrch);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spDsSearch->GetNextRow(hSrch);

        if (hr == S_ADS_NOMORE_ROWS)
        {
            dspDebugOut((DEB_ITRACE, "DsProp: GetNextRow returned S_ADS_NOMORE_ROWS.\n"));
            CStr strMessage, strFormat;

            strFormat.LoadString(g_hInstance, IDS_TDO_NOT_FOUND);

            strMessage.Format(strFormat, pTrust->strFlatName);

            ReportErrorWorker(m_hPage, (LPTSTR)(LPCTSTR)strMessage);
            return;
        }

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        ADS_SEARCH_COLUMN Column;
        PWSTR pwzTrustObj = NULL;
        //
        // Get the full path name of the Trusted-Domain object.
        //
        hr = spDsSearch->GetColumn(hSrch, g_wzADsPath, &Column);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = SkipPrefix(Column.pADsValues->CaseIgnoreString, &pwzTrustObj);

        spDsSearch->FreeColumn(&Column);
        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        // Store the result.
        //
        pTrust->strTDOpath = pwzTrustObj;

        DO_DEL(pwzTrustObj);
    }

    PostPropSheet(pTrust->strTDOpath, this, m_fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::EnableButtons
//
//  Synopsis:   Enable/disable the buttons depending on the selection in the
//              corresponding list.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::EnableButtons(UINT_PTR id, BOOL fEnable)
{
    TRACE(CDsDomainTrustsPage, EnableButtons);
    BOOL fEnableViewEdit = FALSE, fEnableRemove = FALSE;
    int iViewEdit = IDC_VIEW_TRUSTED_BTN, iRemove = IDC_REMOVE_TRUSTED_BTN;

    if (id == IDC_TRUSTING_LIST)
    {
        iViewEdit = IDC_VIEW_TRUSTING_BTN;
        iRemove = IDC_REMOVE_TRUSTING_BTN;
    }
    if (fEnable)
    {
        //
        // Find out which item is selected and then get is relationship type.
        //
        HWND hList = GetDlgItem(m_hPage, (int)id);

        int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

        if (item < 0)
        {
            // disable the remove and edit controls.
            //
            fEnableViewEdit = fEnableRemove = FALSE;
        }
        else
        {
            LV_ITEM lvi;
            lvi.mask = LVIF_PARAM;
            lvi.iItem = item;
            lvi.iSubItem = IDX_DOMNAME_COL;
            if (!ListView_GetItem(hList, &lvi))
            {
                dspAssert(FALSE);
                return;
            }
            PCEnumDomainTrustItem pTrust = (PCEnumDomainTrustItem)lvi.lParam;
            dspAssert(pTrust);
            if ((pTrust->nRelationship == TRUST_REL_PARENT) ||
                (pTrust->nRelationship == TRUST_REL_CHILD)  ||
                (pTrust->nRelationship == TRUST_REL_ROOT))
            {
                fEnableRemove = FALSE;
            }
            else
            {
                fEnableRemove = TRUE;
            }
            fEnableViewEdit = TRUE;
        }
        if (m_fReadOnly)
        {
           fEnableRemove = FALSE;
        }
    }

    EnableWindow(GetDlgItem(m_hPage, iViewEdit), fEnableViewEdit);
    EnableWindow(GetDlgItem(m_hPage, iRemove), fEnableRemove);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::RefreshLists
//
//  Synopsis:   Enumerate the Trusted-Domain objects and populate the UI lists.
//
//-----------------------------------------------------------------------------
HRESULT
CDsDomainTrustsPage::RefreshLists(void)
{
    HRESULT hr = S_OK;
    int nInItem = 0, nOutItem = 0;
    HWND hTrustedList = GetDlgItem(m_hPage, IDC_TRUSTED_LIST);
    HWND hTrustingList = GetDlgItem(m_hPage, IDC_TRUSTING_LIST);
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iSubItem = IDX_DOMNAME_COL;

    for (ULONG i = 0; i < m_cTrusts; i++)
    {
        int idRel;
        int idTrans = IDS_YES;
        CStrW strRel, strTrans;
        //
        // Get the relationship string.
        //
        switch (m_rgTrustList[i].nRelationship)
        {
        case TRUST_REL_SELF:
            // Don't put the local domain in the list.
            //
            continue;

        case TRUST_REL_PARENT:
            idRel = IDS_REL_PARENT;
            break;

        case TRUST_REL_CHILD:
            idRel = IDS_REL_CHILD;
            break;

        case TRUST_REL_ROOT:
            idRel = IDS_REL_TREE_ROOT;
            break;

        case TRUST_REL_CROSSLINK:
            idRel = IDS_REL_CROSSLINK;
            break;

        case TRUST_REL_EXTERNAL:
            idRel = IDS_REL_EXTERNAL;
            idTrans = IDS_NO;
            break;

        case TRUST_REL_FOREST:
            idRel = IDS_REL_FOREST;
            break;

        case TRUST_REL_INDIRECT:
            idRel = IDS_REL_INDIRECT;
            break;

        case TRUST_REL_MIT:
            idRel = IDS_REL_MIT;
            break;

        case TRUST_REL_DCE:
            idRel = IDS_REL_DCE;
            break;

        default:
            idRel = IDS_REL_UNKNOWN;
            break;
        }
        if (!strRel.LoadString(g_hInstance, idRel))
        {
            REPORT_ERROR(GetLastError(), GetHWnd());
            hr = E_OUTOFMEMORY;
            break;
        }

        if (m_rgTrustList[i].ulTrustAttrs & TRUST_ATTRIBUTE_NON_TRANSITIVE)
        {
            idTrans = IDS_NO;
        }
        if (!strTrans.LoadString(g_hInstance, idTrans))
        {
            REPORT_ERROR(GetLastError(), GetHWnd());
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Insert into the list control.
        //
        lvi.pszText = (m_rgTrustList[i].strDNSname.IsEmpty()) ?
                         const_cast<PWSTR>((LPCWSTR)m_rgTrustList[i].strFlatName) :
                         const_cast<PWSTR>((LPCWSTR)m_rgTrustList[i].strDNSname);
        lvi.lParam = (LPARAM)&m_rgTrustList[i];

        int iItem;

        if (m_rgTrustList[i].ulFlags & DS_DOMAIN_DIRECT_OUTBOUND)
        {
            lvi.iItem = nInItem;
            iItem = ListView_InsertItem(hTrustedList, &lvi);
            ListView_SetItemText(hTrustedList, iItem, IDX_RELATION_COL,
                                 const_cast<PWSTR>((LPCWSTR)strRel));
            ListView_SetItemText(hTrustedList, iItem, IDX_TRANSITIVE_COL,
                                 const_cast<PWSTR>((LPCWSTR)strTrans));
            nInItem++;
        }

        if (m_rgTrustList[i].ulFlags & DS_DOMAIN_DIRECT_INBOUND)
        {
            lvi.iItem = nOutItem;
            iItem = ListView_InsertItem(hTrustingList, &lvi);
            ListView_SetItemText(hTrustingList, iItem, IDX_RELATION_COL,
                                 const_cast<PWSTR>((LPCWSTR)strRel));
            ListView_SetItemText(hTrustingList, iItem, IDX_TRANSITIVE_COL,
                                 const_cast<PWSTR>((LPCWSTR)strTrans));
            nOutItem++;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::ClearUILists
//
//  Synopsis:   Empty the lists.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::ClearUILists(void)
{
    ListView_DeleteAllItems(GetDlgItem(m_hPage, IDC_TRUSTED_LIST));
    ListView_DeleteAllItems(GetDlgItem(m_hPage, IDC_TRUSTING_LIST));
}

//+----------------------------------------------------------------------------
//
//  Method:     CPolicyHandle::Open
//
//  Synopsis:   Do an LsaOpenPolicy to get a policy handle.
//
//  Arguments:  [fModify] - defaults to TRUE. If TRUE, the open is asking
//              for trust creation/modification privilege, so admin privilege
//              is required of the caller in that case.
//
//-----------------------------------------------------------------------------
DWORD
CPolicyHandle::Open(BOOL fModify)
{
   TRACE(CPolicyHandle, Open);
   NTSTATUS Status = STATUS_SUCCESS;
   UNICODE_STRING Server;
   OBJECT_ATTRIBUTES ObjectAttributes;

   if (m_strUncDc.IsEmpty())
   {
      return ERROR_INVALID_PARAMETER;
   }

   RtlInitUnicodeString(&Server, m_strUncDc);
   RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

   ACCESS_MASK mask = POLICY_VIEW_LOCAL_INFORMATION;

   if (fModify)
   {
      mask |= POLICY_CREATE_SECRET | POLICY_TRUST_ADMIN;
   }

   Status = LsaOpenPolicy(&Server,
                          &ObjectAttributes,
                          mask,
                          &m_hPolicy);

   if (!NT_SUCCESS(Status))
   {
      dspDebugOut((DEB_ITRACE, "CPolicyHandle::Open: LsaOpenPolicy failed with error 0x%x\n",
                   Status));
      return LsaNtStatusToWinError(Status);
   }

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CPolicyHandle::OpenWithPrompt
//
//  Synopsis:  Do an LsaOpenPolicy to get a policy handle. If the first
//             attempt returns access-denied and the credentials have not been
//             gathered yet, prompt for credentials.
//
//  Returns:   HRESULT_FROM_WIN32(ERROR_CANCELLED) if the user cancels the
//             prompt for creds, success or errors otherwise.
//
//  Note:      Always requests create/modify privileges.
//
//-----------------------------------------------------------------------------
DWORD
CPolicyHandle::OpenWithPrompt(CCreds & Creds, CWaitCursor & Wait,
                              PCWSTR pwzDomain, HWND hWnd)
{
   DWORD dwErr = OpenReqAdmin();

   if (ERROR_ACCESS_DENIED == dwErr)
   {
      if (Creds.IsSet())
      {
         dwErr = ERROR_SUCCESS;
      }
      else
      {
         Wait.SetOld();
         dwErr = Creds.PromptForCreds(pwzDomain, hWnd);
         Wait.SetWait();
      }

      if (ERROR_SUCCESS == dwErr)
      {
         dwErr = Creds.Impersonate();

         if (ERROR_SUCCESS == dwErr)
         {
            dwErr = OpenReqAdmin();
         }

         Creds.Revert();
      }
   }

   return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CPolicyHandle::OpenWithAnonymous
//
//  Synopsis:  Do an LsaOpenPolicy to get a policy handle. If the first
//             attempt returns access-denied, use the null token.
//
//-----------------------------------------------------------------------------
DWORD
CPolicyHandle::OpenWithAnonymous(CCredMgr & Creds)
{
   DWORD dwErr = Open(FALSE);

   if (ERROR_ACCESS_DENIED == dwErr)
   {
      dwErr = Creds.ImpersonateAnonymous();

      if (ERROR_SUCCESS == dwErr)
      {
         dwErr = Open(FALSE);

         Creds.Revert();
      }
   }

   return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::GetPDC
//
//  Synopsis:   Get the PDC for the local domain. The local domain is assumed
//              to always be an NT5 domain.
//
//  Note:       Errors are not reported in this routine; they are passed back
//              to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPropPageBase::GetPDC(CStrW& strUncPDC)
{
   DWORD dwErr;
   PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;

   dwErr = DsGetDcNameW(NULL, GetDnsDomainName(), NULL, NULL, 
                        DS_PDC_REQUIRED, &pDCInfo);

   if (dwErr != ERROR_SUCCESS)
   {
      dspDebugOut((DEB_ERROR, "DsGetDcName failed with error 0x%08x\n",
                   dwErr));
      return HRESULT_FROM_WIN32(dwErr);
   }

   strUncPDC = pDCInfo->DomainControllerName;

   NetApiBufferFree(pDCInfo);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::GetInfoForRemoteDomain
//
//  Synopsis:   Get the trust information for the remote domain.
//
//  Note:       Errors are not reported in this routine; they are passed back
//              to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPropPageBase::GetInfoForRemoteDomain(PCWSTR pwzDomainName,
                                           PTD_DOM_INFO pInfo,
                                           CCredMgr & Creds,
                                           HWND hWnd,
                                           DWORD dwFlags)
{
    TRACE(CTrustPropPageBase, GetInfoForRemoteDomain);
    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    DWORD dwErr = NO_ERROR;
    UNICODE_STRING Server = {0};
    OBJECT_ATTRIBUTES ObjectAttributes = {0};
    PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
    ULONG ulDcFlags = DS_WRITABLE_REQUIRED;

    dspAssert(pwzDomainName && pInfo);

    if (dwFlags & DS_TRUST_INFO_GET_PDC)
    {
        ulDcFlags = DS_PDC_REQUIRED;
    }

    ACCESS_MASK mask = POLICY_VIEW_LOCAL_INFORMATION;

    if (DS_TRUST_INFO_ALL_ACCESS & dwFlags)
    {
        // POLICY_CREATE_SECRET causes LsaOpenPolicy to do an access check for
        // admin privilege.
        //
        mask |= POLICY_CREATE_SECRET;
    }

    // First, get a DC name.
    //
    dwErr = DsGetDcNameW(NULL, (LPCWSTR)pwzDomainName, NULL, NULL, 
                         ulDcFlags, &pDCInfo);

    if (dwErr != ERROR_SUCCESS)
    {
        dspDebugOut((DEB_ERROR, "DsGetDcName failed with error 0x%08x\n",
                     dwErr));
        return HRESULT_FROM_WIN32(dwErr);
    }

    if (!AllocWStr(pDCInfo->DomainControllerName, &pInfo->pwzUncDcName))
    {
        hr = E_OUTOFMEMORY;
        goto ExitCleanup;
    }

    RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    RtlInitUnicodeString(&Server, pDCInfo->DomainControllerName);

    //
    // Get an LSA policy handle (the RPC binding handle).
    //
    Status = LsaOpenPolicy(&Server,
                           &ObjectAttributes,
                           mask,
                           &pInfo->Policy);

    if (STATUS_ACCESS_DENIED == Status)
    {
       if (!(DS_TRUST_INFO_ALL_ACCESS & dwFlags))
       {
          // Try the null token for access.
          //
          dwErr = Creds.ImpersonateAnonymous();

          CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));

          Status = LsaOpenPolicy(&Server,
                                 &ObjectAttributes,
                                 mask,
                                 &pInfo->Policy);

          Creds.Revert();
       }

       if (STATUS_ACCESS_DENIED == Status)
       {
          // Must have restrict anonymous set or requesting admin access.
          //
          if (!Creds._RemoteCreds.IsSet())
          {
             // Try prompting for creds.
             //
             dwErr = Creds._RemoteCreds.PromptForCreds(pwzDomainName, hWnd);

             if (ERROR_CANCELLED == dwErr)
             {
                return ERROR_CANCELLED;
             }

             CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));
          }

          Creds._RemoteCreds.Impersonate();

          Status = LsaOpenPolicy(&Server,
                                 &ObjectAttributes,
                                 mask,
                                 &pInfo->Policy);
          Creds.Revert();
       }
    }

    if (!NT_SUCCESS(Status))
    {
        // DsGetDcName can continue to return a DC name while the property
        // page is open even if the DC has become unavailable.
        // LsaOpenPolicy will then return the error RPC_S_INVALID_NET_ADDR.
        //
        dspDebugOut((DEB_ITRACE,
                     "GetInfoForRemoteDomain: LsaOpenPolicy failed, error 0x%08x\n",
                     Status));
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
        goto ExitCleanup;
    }

    //
    // Now read the domain info.
    //
    Status = LsaQueryInformationPolicy(pInfo->Policy,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&(pInfo->pDnsDomainInfo));
    
    if (Status == RPC_S_PROCNUM_OUT_OF_RANGE ||
        Status == RPC_NT_PROCNUM_OUT_OF_RANGE ||
        pInfo->ulTrustType == TRUST_TYPE_DOWNLEVEL)
    {
      // This is a downlevel DC.
      //
      Status = LsaQueryInformationPolicy(pInfo->Policy,
                                         PolicyPrimaryDomainInformation,
                                         (PVOID *)&(pInfo->pDownlevelDomainInfo));
      pInfo->ulTrustType = TRUST_TYPE_DOWNLEVEL;
      dspDebugOut((DEB_ITRACE, "Downlevel domain: %ws\n", pwzDomainName));
    }
    else
    {
      pInfo->ulTrustType = TRUST_TYPE_UPLEVEL;
    }
      
    if (!NT_SUCCESS(Status))
    {
      dspDebugOut((DEB_ERROR,
                   "GetInfoForRemoteDomain: LsaQueryInformationPolicy failed, error 0x%08x\n",
                   Status));
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
    }

ExitCleanup:

    NetApiBufferFree(pDCInfo);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrustDirection
//
//-----------------------------------------------------------------------------
NTSTATUS
RemoveTrustDirection(LSA_HANDLE hPolicy, PTD_DOM_INFO pRemote, TRUST_OP Op,
                     CCreds & LocalCreds)
{
    TRACE_FUNCTION(RemoveTrustDirection);
    NTSTATUS Status = STATUS_SUCCESS;
    PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;
    PLSA_UNICODE_STRING pName = NULL;
    LSA_UNICODE_STRING Name = {0};

    switch (pRemote->ulTrustType)
    {
    case TRUST_TYPE_UPLEVEL:
        pName = &pRemote->pDnsDomainInfo->DnsDomainName;
        break;

    case TRUST_TYPE_DOWNLEVEL:
        dspAssert(pRemote->pDownlevelDomainInfo);
        pName = &pRemote->pDownlevelDomainInfo->Name;
        break;

    case TRUST_TYPE_MIT:
        RtlInitUnicodeString(&Name, pRemote->pwzDomainName);
        pName = &Name;
        break;

    default:
        dspAssert(FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    LocalCreds.Impersonate();

    Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                             pName,
                                             TrustedDomainFullInformation,
                                             (PVOID *)&pFullInfo);

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status &&
        TRUST_TYPE_UPLEVEL == pRemote->ulTrustType)
    {
        // Now try by flat name; can get here if a downlevel domain
        // is upgraded to NT5. The name used above was the DNS name
        // but the TDO would be named after the flat name.
        //
        dspDebugOut((DEB_ITRACE, "LsaQueryTDIBN: DNS name failed, trying flat name\n"));

        pName = &pRemote->pDnsDomainInfo->Name;

        Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                                 pName,
                                                 TrustedDomainFullInformation,
                                                 (PVOID *)&pFullInfo);
    }
    CHECK_LSA_STATUS(Status, LocalCreds.Revert(); return Status);

    switch (Op)
    {
    case REMOVE_TRUST_INBOUND:
        if (pFullInfo->AuthInformation.IncomingAuthInfos > 0)
        {
            pFullInfo->AuthInformation.IncomingAuthInfos = 0;
            pFullInfo->AuthInformation.IncomingAuthenticationInformation = NULL;
            pFullInfo->AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        }
        pFullInfo->Information.TrustDirection = TRUST_DIRECTION_OUTBOUND;
        break;

    case REMOVE_TRUST_OUTBOUND:
        if (pFullInfo->AuthInformation.OutgoingAuthInfos > 0)
        {
            pFullInfo->AuthInformation.OutgoingAuthInfos = 0;
            pFullInfo->AuthInformation.OutgoingAuthenticationInformation = NULL;
            pFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        }
        pFullInfo->Information.TrustDirection = TRUST_DIRECTION_INBOUND;
        break;
    }

    Status = LsaSetTrustedDomainInfoByName(hPolicy,
                                           pName,
                                           TrustedDomainFullInformation,
                                           pFullInfo);
    LocalCreds.Revert();

    LsaFreeMemory(pFullInfo);

    CHECK_LSA_STATUS(Status, ;);

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteTrust
//
//  Synopsis:   Use the LSA API to delete the trust relationship/object.
//
//-----------------------------------------------------------------------------
NTSTATUS
DeleteTrust(LSA_HANDLE hPolicy, PTD_DOM_INFO pRemote)
{
   NTSTATUS Status = STATUS_SUCCESS;
   LSA_HANDLE hTrustedDomain = NULL;
   PLSA_UNICODE_STRING pName = NULL;
   LSA_UNICODE_STRING Name = {0};

   switch (pRemote->ulTrustType)
   {
   case TRUST_TYPE_UPLEVEL:
      pName = &pRemote->pDnsDomainInfo->Name;
      break;

   case TRUST_TYPE_DOWNLEVEL:
      dspAssert(pRemote->pDownlevelDomainInfo);
      pName = &pRemote->pDownlevelDomainInfo->Name;
      break;

   case TRUST_TYPE_MIT:
   case TRUST_TYPE_NO_DC:
      RtlInitUnicodeString(&Name, pRemote->pwzDomainName);
      pName = &Name;
      break;

   default:
      dspAssert(FALSE);
      return STATUS_INVALID_PARAMETER;
   }

   Status = LsaOpenTrustedDomainByName(hPolicy,
                                       pName,
                                       TRUSTED_ALL_ACCESS,
                                       &hTrustedDomain);

   if (STATUS_OBJECT_NAME_NOT_FOUND == Status &&
       TRUST_TYPE_UPLEVEL == pRemote->ulTrustType)
   {
      // Now try by flat name; can get here if a downlevel domain
      // is upgraded to NT5. The name used above was the DNS name
      // but the TDO would be named after the flat name.
      //
      dspDebugOut((DEB_ITRACE, "LsaOpenTDBN: DNS name failed, trying flat name\n"));

      pName = &pRemote->pDnsDomainInfo->Name;

      Status = LsaOpenTrustedDomainByName(hPolicy,
                                          pName,
                                          TRUSTED_ALL_ACCESS,
                                          &hTrustedDomain);
   }

   if (NT_SUCCESS(Status))
   {
      dspAssert(hTrustedDomain);

      Status = LsaDelete(hTrustedDomain);

#if DBG == 1
      if (!NT_SUCCESS(Status))
      {
         dspDebugOut((DEB_ERROR, "LsaDelete failed with error 0x%08x\n",
                      Status));
      }
#endif

      LsaClose(hTrustedDomain);
   }

   return Status;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::QueryDeleteTrust
//
//  Synopsis:   When all else fails, directly delete the trust object. This is
//              necessary when the other domain no longer exists.
//
//-----------------------------------------------------------------------------
HRESULT
CDsDomainTrustsPage::QueryDeleteTrust(LSA_HANDLE hPolicy,
                                      PTD_DOM_INFO pRemote,
                                      CCreds & Creds)
{
    int iRet = 0;
    CStrW strTitle, strMsg, strFormat;

    if (!strTitle.LoadString(g_hInstance, IDS_MSG_TITLE))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }
    if (!strFormat.LoadString(g_hInstance, IDS_MSG_FORCE_REMOVE_CONFIRM))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }

    strMsg.Format(strFormat, pRemote->pwzDomainName);

    iRet = MessageBox(GetHWnd(), strMsg, strTitle, MB_YESNO | MB_ICONWARNING);

    if (iRet != IDYES)
    {
        return S_FALSE;
    }

    Creds.Impersonate();

    NTSTATUS Status = DeleteTrust(hPolicy, pRemote);

    Creds.Revert();

    CHECK_LSA_STATUS_REPORT(Status, GetHWnd(), return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status)));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeDomainInfo
//
//  Synopsis:   Release the previously aquired resources.
//
//-----------------------------------------------------------------------------
VOID
FreeDomainInfo(PTD_DOM_INFO pInfo)
{
    TRACE_FUNCTION(FreeDomainInfo);
    if (pInfo->pDnsDomainInfo)
    {
        LsaFreeMemory(pInfo->pDnsDomainInfo);
        pInfo->pDnsDomainInfo = NULL;
    }
    if (pInfo->pDownlevelDomainInfo)
    {
        LsaFreeMemory(pInfo->pDownlevelDomainInfo);
        pInfo->pDownlevelDomainInfo = NULL;
    }
    if (pInfo->Policy)
    {
        LsaClose(pInfo->Policy);
        pInfo->Policy = NULL;
    }
    if (pInfo->pwzUncDcName)
    {
        delete pInfo->pwzUncDcName;
        pInfo->pwzUncDcName = NULL;
    }
    if (pInfo->pwzDomainName)
    {
        delete pInfo->pwzDomainName;
        pInfo->pwzDomainName = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::VerifyTrustOneDirection
//
//  Synopsis:   Netlogon is called to query/reset the secure channel and the
//              result of that is returned.
//
//  Arguments:  [pwzTrustingDcName] - the DC on which to run the netlogon query.
//              [pwzTrustingDomName] - the outbound domain, needed only if
//                                    DS_TRUST_VERIFY_PROMPT_FOR_CREDS is set.
//              [pwzTrustedDomName] - the trusted (inbound) domain.
//              [ppwzTrustedDcUsed] - if non-NULL, returns the name of the DC
//                                    to which the secure channel is connected.
//              [Creds] - credential object to do impersonation for authorization.
//              [Wait] - wait cursor object.
//              [strMsg] - the results go here.
//              [dwFlags] - bit flags, can be a combination of the following:
//                          DS_TRUST_VERIFY_PROMPT_FOR_CREDS, prompt for
//                          creds if the query returns access denied.
//                          DS_TRUST_VERIFY_NEW_TRUST, don't show error here
//                          or attempt a reset if the query fails.
//                          Defaults to zero (no flags set).
//
// Returns:     ERROR_SUCCESS or error code.
//
// Notes:       An SC query is first done to see what netlogon thinks is the
//              current state of the trust. If OK, the query returns the DC to
//              which the secure channel is made. This same DC is then used as
//              the target of the reset. Since the query is cached info, it
//              may be stale; hence the reset. The reset is targetted to the
//              same DC so that the trust topology is not perturbed.
//
//-----------------------------------------------------------------------------
DWORD
CTrustPropPageBase::VerifyTrustOneDirection(PCWSTR pwzTrustingDcName,
                                            PCWSTR pwzTrustingDomName,
                                            PCWSTR pwzTrustedDomName,
                                            PWSTR * ppwzTrustedDcUsed,
                                            CCreds & Creds,
                                            CWaitCursor & Wait,
                                            CStrW & strMsg,
                                            DWORD dwFlags)
{
    TRACE(CTrustPropPageBase, VerifyTrustOneDirection);
    NET_API_STATUS NetStatus = NO_ERROR, ResetStatus = NO_ERROR;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
    BOOL fRetry = FALSE;
    BOOL fPromptForCreds = dwFlags & DS_TRUST_VERIFY_PROMPT_FOR_CREDS;
    DWORD dwRet = NO_ERROR;
    PDS_DOMAIN_TRUSTS rgDomains = NULL;
    ULONG DomainCount = 0;
    PWSTR pwzTrustedDcUsed = NULL;

    if (!pwzTrustingDcName || !pwzTrustingDomName || !pwzTrustedDomName)
    {
       dspAssert(FALSE);
       return ERROR_INVALID_PARAMETER;
    }

    // DsEnumerateDomainTrusts will block if there is a NetLogon trust
    // update in progress. Call it to insure that our trust changes are
    // known by NetLogon before we do the query/reset.
    //
    dwRet = DsEnumerateDomainTrusts(const_cast<PWSTR>(pwzTrustingDcName),
                                    DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAIN_DIRECT_INBOUND,
                                    &rgDomains, &DomainCount);
    if (ERROR_SUCCESS == dwRet)
    {
        NetApiBufferFree(rgDomains);
    }
    else
    {
        dspDebugOut((DEB_ERROR,
                     "**** DsEnumerateDomainTrusts ERROR <%s @line %d> -> %d\n",
                     __FILE__, __LINE__, dwRet));
    }

    DWORD dwFcn = (dwFlags & DS_TRUST_VERIFY_NEW_TRUST) ?
                     NETLOGON_CONTROL_REDISCOVER : NETLOGON_CONTROL_TC_VERIFY;
    //
    // Unless this is a new trust, first try a verify to see if netlogon thinks
    // the trust is OK. If the verify succeeds, it will return the name of the
    // DC to which the SC is connected.
    //
    do {
        fRetry = FALSE;
        Wait.SetWait();

        NetStatus = I_NetLogonControl2(pwzTrustingDcName,
                                       dwFcn,
                                       2,
                                       (LPBYTE)&pwzTrustedDomName,
                                       (LPBYTE *)&NetlogonInfo2);

        if (NERR_Success == NetStatus)
        {
            if (NETLOGON_CONTROL_TC_VERIFY == dwFcn)
            {
               if (NETLOGON_VERIFY_STATUS_RETURNED & NetlogonInfo2->netlog2_flags)
               {
                  // The status of the verification is in the
                  // netlog2_pdc_connection_status field.
                  //
                  NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;

                  dspDebugOut((DEB_ITRACE,
                              "NetLogon SC verify for %ws on DC %ws gives verify status %d to DC %ws\n\n",
                               pwzTrustedDomName, pwzTrustingDcName, NetStatus,
                               NetlogonInfo2->netlog2_trusted_dc_name));
               }
               else
               {
                  NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

                  dspDebugOut((DEB_ITRACE,
                              "NetLogon SC verify for %ws on pre-2474 DC %ws gives conection status %d to DC %ws\n\n",
                               pwzTrustedDomName, pwzTrustingDcName, NetStatus,
                               NetlogonInfo2->netlog2_trusted_dc_name));
               }
            }
            else
            {
               NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

               dspDebugOut((DEB_ITRACE,
                            "NetLogon SC reset for %ws on DC %ws gives status %d to DC %ws\n\n",
                            pwzTrustedDomName, pwzTrustingDcName, NetStatus,
                            NetlogonInfo2->netlog2_trusted_dc_name));
            }

            if (NERR_Success == NetStatus &&
                !(dwFlags & (DS_TRUST_VERIFY_DOWNLEVEL | DS_TRUST_VERIFY_NEW_TRUST)))
            {
                if (!AllocWStr(NetlogonInfo2->netlog2_trusted_dc_name, &pwzTrustedDcUsed))
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            NetApiBufferFree(NetlogonInfo2);
        }
        else
        {
            dspDebugOut((DEB_ITRACE,
                         (dwFlags & DS_TRUST_VERIFY_NEW_TRUST) ?
                         "NetLogon SC Reset for %ws on DC %ws returns error 0x%x\n\n" :
                         "NetLogon SC Verify for %ws on DC %ws returns error 0x%x\n\n",
                         pwzTrustedDomName, pwzTrustingDcName, NetStatus));

            if (ERROR_ACCESS_DENIED == NetStatus)
            {
                if (!Creds.IsSet() && fPromptForCreds)
                {
                    if (Creds.PromptForCreds(pwzTrustingDomName, m_pPage->GetHWnd()))
                    {
                        return ERROR_CANCELLED;
                    }
                }

                dwRet = Creds.Impersonate();

                if (ERROR_SUCCESS == dwRet)
                {
                    fRetry = TRUE;
                }
                else
                {
                    return dwRet;
                }
                fPromptForCreds = FALSE; // Only prompt once for creds.
            }
            if (ERROR_NOT_SUPPORTED == NetStatus)
            {
               // Must be remoted to a Win2k DC that doesn't support SC verify.
               //
               dwFcn = NETLOGON_CONTROL_TC_QUERY;
               fRetry = TRUE;
            }
        }
    } while (fRetry);

    if (dwFlags & DS_TRUST_VERIFY_NEW_TRUST)
    {
        // If this is a newly repaired trust, return back to ResetTrust so
        // that it can display the appropriate message.
        //
        Creds.Revert();
        return NetStatus;
    }

    if (NERR_Success != NetStatus && ERROR_NO_LOGON_SERVERS != NetStatus)
    {
        // The SC verify on DC of domain x to domain y failed with error z,
        // an SC reset will now be attempted.
        // Ignore ERROR_NO_LOGON_SERVERS because that is often due to the SC
        // just not being set up yet.
        //
        PCWSTR rgwzArgs[] = {pwzTrustingDcName, pwzTrustingDomName, pwzTrustedDomName};
        PWSTR pwzMsg;

        DspFormatMessage(IDS_SC_QUERY_FAILED, NetStatus, (PVOID *)rgwzArgs, 3,
                         FALSE, &pwzMsg);

        if (pwzMsg)
        {
            strMsg += pwzMsg;
            strMsg += g_wzCRLF;

            LocalFree(pwzMsg);
        }
    }

    PWSTR pwzTrusted = NULL;

    if (pwzTrustedDcUsed)
    {
        // Form the name "domain\DC" to pass to I_NetLogonControl2.
        //
        pwzTrusted = new WCHAR[wcslen(pwzTrustedDomName) +
                                wcslen(pwzTrustedDcUsed) + 3];

        CHECK_NULL(pwzTrusted, return ERROR_NOT_ENOUGH_MEMORY);

        DWORD dwSkip = 0;
        if (L'\\' == pwzTrustedDcUsed[1])
        {
            // skip leading forward slashes if found.
            //
            dwSkip = 2;
        }

        wcscpy(pwzTrusted, pwzTrustedDomName);
        wcscat(pwzTrusted, L"\\");
        wcscat(pwzTrusted, pwzTrustedDcUsed + dwSkip);
    }
    else
    {
        pwzTrusted = const_cast<PWSTR>(pwzTrustedDomName);
    }

    do {
        fRetry = FALSE;
        Wait.SetWait();

        ResetStatus = I_NetLogonControl2(pwzTrustingDcName,
                                         NETLOGON_CONTROL_REDISCOVER,
                                         2,
                                         (LPBYTE)&pwzTrusted,
                                         (LPBYTE *)&NetlogonInfo2);

        if (NERR_Success == ResetStatus)
        {
            ResetStatus = NetlogonInfo2->netlog2_tc_connection_status;

            dspDebugOut((DEB_ITRACE,
                         "NetLogon SC Reset for %ws on DC %ws gives status %d\n\n",
                         pwzTrusted, pwzTrustingDcName, ResetStatus));

            NetApiBufferFree(NetlogonInfo2);
        }
        else
        {
            dspDebugOut((DEB_ITRACE,
                         "NetLogon SC reset for %ws on DC %ws returns error 0x%x\n\n",
                         pwzTrusted, pwzTrustingDcName, ResetStatus));

            if ((ERROR_ACCESS_DENIED == ResetStatus) &&
                (NERR_Success == NetStatus))
            {
                if (!Creds.IsSet() && fPromptForCreds)
                {
                   // If the SC verify was successful but the reset gives access
                   // denied, then ask for creds if not already connected.
                   //
                   if (Creds.PromptForCreds(pwzTrustingDomName,
                                            m_pPage->GetHWnd()) != IDYES)
                   {
                      return ERROR_CANCELLED;
                   }
                }

                dwRet = Creds.Impersonate();

                if (ERROR_SUCCESS == dwRet)
                {
                    fRetry = TRUE;
                }
                else
                {
                    if (pwzTrustedDcUsed)
                    {
                        delete [] pwzTrusted;
                    }
                    return dwRet;
                }
                fPromptForCreds = FALSE; // Only prompt once for creds.
            }
        }
    
        NetStatus = ResetStatus;

    } while (fRetry);

    Creds.Revert();

    if (NERR_Success != NetStatus)
    {
        // The SC reset on DC of domain x to domain y failed with error z,
        //
        PCWSTR rgwzArgs[] = {pwzTrustingDcName, pwzTrustingDomName, pwzTrustedDomName};
        PWSTR pwzMsg;

        DspFormatMessage(IDS_SC_RESET_FAILED, NetStatus, (PVOID *)rgwzArgs, 3,
                         FALSE, &pwzMsg);

        if (pwzMsg)
        {
            strMsg += pwzMsg;
            strMsg += g_wzCRLF;

            LocalFree(pwzMsg);
        }
    }

    if (pwzTrustedDcUsed)
    {
        delete [] pwzTrusted;
    }
    if (ppwzTrustedDcUsed)
    {
        *ppwzTrustedDcUsed = pwzTrustedDcUsed;
    }
    else
    {
        DO_DEL(pwzTrustedDcUsed);
    }
    return NetStatus;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\trustwiz2.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Domains and Trust
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       trustwiz2.cxx
//
//  Contents:   More Domain trust creation wizard.
//
//  History:    28-Sept-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"
#include <lmerr.h>
#include <crypt.h>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Method:    CallMember::Invoke subclasses
//
//-----------------------------------------------------------------------------
HRESULT
CallPolicyRead::Invoke(void)
{
   TRACER(CallPolicyRead,Invoke);
   HRESULT hr;

   hr = _pWiz->RetryCollectInfo();

   _pWiz->CredMgr.Revert();

   return hr;
}

HRESULT
CallTrustExistCheck::Invoke(void)
{
   TRACER(CallTrustExistCheck,Invoke);
   HRESULT hr;

   hr = _pWiz->RetryContinueCollectInfo();

   _pWiz->CredMgr.Revert();

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::Impersonate
//
//-----------------------------------------------------------------------------
DWORD
CCreds::Impersonate(void)
{
   TRACER(CCreds,Impersonate);
   if (!_fSet)
   {
      return NO_ERROR;
   }
   if (_strUser.IsEmpty())
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   DWORD dwErr = NO_ERROR;

   if (!_hToken)
   {
      // The PW is encrypted, decrypt it before using it.
      WCHAR wzPw[CREDUI_MAX_PASSWORD_LENGTH+1] = {0};
      RtlCopyMemory(wzPw, _strPW, _cbPW);
      RtlDecryptMemory(wzPw, _cbPW, 0);

      if (!LogonUser(_strUser, 
                     _strDomain,
                     wzPw,
                     LOGON32_LOGON_NEW_CREDENTIALS,
                     LOGON32_PROVIDER_WINNT50,
                     &_hToken))
      {
         dwErr = GetLastError();
         dspDebugOut((DEB_ITRACE, "LogonUser failed with error %d on user name %ws\n",
                      dwErr, _strUser.GetBuffer(0)));
         return dwErr;
      }
      RtlZeroMemory(wzPw, _cbPW);

      // Because the login uses the LOGON32_LOGON_NEW_CREDENTIALS flag, no
      // attempt is made to use the credentials until a remote resource is
      // accessed. Thus, we don't yet know if the user entered credentials are
      // valid at this point.
   }

   if (!ImpersonateLoggedOnUser(_hToken))
   {
      dwErr = GetLastError();
      dspDebugOut((DEB_ITRACE, "ImpersonateLoggedOnUser failed with error %d on user name %ws\n",
                   dwErr, _strUser.GetBuffer(0)));
      return dwErr;
   }

   _fImpersonating = TRUE;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::Revert
//
//-----------------------------------------------------------------------------
void
CCreds::Revert()
{
   if (_fImpersonating)
   {
      TRACER(CCreds,Revert);
      BOOL f = RevertToSelf();
      dspAssert(f);
      _fImpersonating = FALSE;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::Clear
//
//-----------------------------------------------------------------------------
void
CCreds::Clear(void)
{
   Revert();
   _strUser.Empty();
   _strPW.Empty();
   if (_hToken)
   {
      CloseHandle(_hToken);
      _hToken = NULL;
   }
   _fSet = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::SetUserAndPW
//
//-----------------------------------------------------------------------------
DWORD
CCreds::SetUserAndPW(PCWSTR pwzUser, PCWSTR pwzPW, PCWSTR pwzDomain)
{
   DWORD dwErr = NO_ERROR;
   WCHAR wzName[CRED_MAX_USERNAME_LENGTH+1] = {0}, 
         wzDomain[CRED_MAX_USERNAME_LENGTH+1] = {0},
         wzPw[CREDUI_MAX_PASSWORD_LENGTH+1+4] = {0}; // add 4 so that the PW size can be rounded up to 8 byte boundary.

   dwErr = CredUIParseUserName(pwzUser, wzName, CRED_MAX_USERNAME_LENGTH,
                               wzDomain, CRED_MAX_USERNAME_LENGTH);

   if (NO_ERROR == dwErr)
   {
      _strUser = wzName;
      _strDomain = wzDomain;
   }
   else
   {
      if (ERROR_INVALID_PARAMETER == dwErr ||
          ERROR_INVALID_ACCOUNT_NAME == dwErr)
      {
         // CredUIParseUserName returns this error if the user entered name
         // does not include a domain. Default to the target domain.
         //
         _strUser = pwzUser;

         if (pwzDomain)
         {
            _strDomain = pwzDomain;
         }
      }
      else
      {
         dspDebugOut((DEB_ITRACE, "CredUIParseUserName failed with error %d\n", dwErr));
         return dwErr;
      }
   }

   // Encrypt the PW, rounding up buffer size to 8 byte boundary. The
   // RtlEncryptMemory function encrypts in place, so copy to a buffer that is
   // large enough for the round-up. The buffer is null-initialized, so it is
   // guaranteed to be null terminated after the copy.
   //
   wcsncpy(wzPw, pwzPW, CREDUI_MAX_PASSWORD_LENGTH);

   _cbPW = static_cast<ULONG>(wcslen(wzPw) * sizeof(WCHAR));
   ULONG roundup = 8 - (_cbPW % 8);
   if (roundup < 8)
   {
      _cbPW += roundup;
   }
   NTSTATUS status = RtlEncryptMemory(wzPw, _cbPW, 0);
   dspDebugOut((DEB_ITRACE, "CCreds::SetUserAndPW: RtlEncryptMemory returned status 0x%x\n", status));
   _strPW.GetBufferSetLength(_cbPW + 2); // make sure there is room for a null after the encrypted PW.
   _strPW = wzPw;

   _fSet = TRUE;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CCreds::PromptForCreds
//
//  Synopsis:   Post a login dialog.
//
//-----------------------------------------------------------------------------
int
CCreds::PromptForCreds(PCWSTR pwzDomain, HWND hParent)
{
   TRACE3(CCreds, PromptForCreds);

   if (pwzDomain)
   {
      _strDomain = pwzDomain;
   }

   int nRet = (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_CRED_ENTRY),
                                  hParent, (DLGPROC)CredPromptProc, (LPARAM)this);
   if (-1 == nRet)
   {
      REPORT_ERROR(GetLastError(), hParent);
      return GetLastError();
   }

   return nRet;
}

//+----------------------------------------------------------------------------
//
//  Function:   CredPromptProc
//
//  Synopsis:   Trust credentials dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CredPromptProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   int code;
   CCreds * pCreds = (CCreds*)GetWindowLongPtr(hDlg, DWLP_USER);

   switch (uMsg)
   {
   case WM_INITDIALOG:
      SetWindowLongPtr(hDlg, DWLP_USER, lParam);
      pCreds = (CCreds *)lParam;
      dspAssert(pCreds);
      EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
      SendDlgItemMessage(hDlg, IDC_CREDMAN, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
      SendDlgItemMessage(hDlg, IDC_CREDMAN, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);
      WCHAR wzMsg[MAX_PATH+1];
      PWSTR pwzMsgFmt;
      if (!LoadStringToTchar(IDS_TRUST_LOGON_MSG, &pwzMsgFmt))
      {
         REPORT_ERROR(E_OUTOFMEMORY, hDlg);
         return FALSE;
      }
      swprintf(wzMsg, pwzMsgFmt, pCreds->_strDomain);
      SetDlgItemText(hDlg, IDC_MSG, wzMsg);
      delete pwzMsgFmt;
      return TRUE;

   case WM_COMMAND:
      code = GET_WM_COMMAND_CMD(wParam, lParam);
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         if (code == BN_CLICKED)
         {
            DWORD dwErr;
            dspAssert(pCreds);
            WCHAR wzName[CREDUI_MAX_USERNAME_LENGTH+1] = {0},
                  wzPw[CREDUI_MAX_PASSWORD_LENGTH+1] = {0};

            Credential_GetUserName(GetDlgItem(hDlg, IDC_CREDMAN), wzName,
                                   CREDUI_MAX_USERNAME_LENGTH);

            Credential_GetPassword(GetDlgItem(hDlg, IDC_CREDMAN), wzPw,
                                   CREDUI_MAX_PASSWORD_LENGTH);

            dwErr = pCreds->SetUserAndPW(wzName, wzPw);

            CHECK_WIN32_REPORT(dwErr, hDlg, ;);

            EndDialog(hDlg, dwErr);
         }
         break;

      case IDCANCEL:
         if (code == BN_CLICKED)
         {
            EndDialog(hDlg, ERROR_CANCELLED);
         }
         break;

      case IDC_CREDMAN:
         if (CRN_USERNAMECHANGE == code)
         {
            BOOL fNameEntered = SendDlgItemMessage(hDlg, IDC_CREDMAN,
                                                   CRM_GETUSERNAMELENGTH,
                                                   0, 0) > 0;

            EnableWindow(GetDlgItem(hDlg, IDOK), fNameEntered);
         }
         break;
      }
      break;

   default:
      return(FALSE);
   }

   return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::GetPrompt
//
//-----------------------------------------------------------------------------
PCWSTR
CCredMgr::GetPrompt()
{
   _strPrompt.LoadString(g_hInstance, _fRemote ? 
                                         _fAdmin ? IDS_CRED_ADMIN_OTHER_PROMPT :
                                                   IDS_CRED_USER_OTHER_PROMPT :
                                      IDS_CRED_ADMIN_LOCAL_PROMPT);
   return _strPrompt;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::GetDomainPrompt
//
//-----------------------------------------------------------------------------
PCWSTR
CCredMgr::GetDomainPrompt(void)
{
   CStrW strFormat;

   strFormat.LoadString(g_hInstance, _fRemote ? IDS_CRED_OTHER_DOMAIN :
                                                IDS_CRED_LOCAL_DOMAIN);
   _strDomainPrompt.Format(strFormat, _strDomain);

   return _strDomainPrompt;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::GetSubTitle
//
//-----------------------------------------------------------------------------
PCWSTR
CCredMgr::GetSubTitle(void)
{
   _strSubTitle.LoadString(g_hInstance, _fRemote ?
                                          _fAdmin ? IDS_TW_CREDS_SUBTITLE_OTHER :
                                                    IDS_TW_CREDS_SUBTITLE_OTHER_NONADMIN :
                                          IDS_TW_CREDS_SUBTITLE_LOCAL);
   return _strSubTitle;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::SetNextFcn
//
//-----------------------------------------------------------------------------
BOOL
CCredMgr::SetNextFcn(CallMember * pNext)
{
   if (!pNext)
   {
      return FALSE;
   }

   if (_pNextFcn)
   {
      delete _pNextFcn;
   }

   _pNextFcn = pNext;

   _fNewCall = TRUE;

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::InvokeNext
//
//-----------------------------------------------------------------------------
int
CCredMgr::InvokeNext(void)
{
   dspAssert(_pNextFcn);
   return _pNextFcn->Invoke();
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::SaveCreds
//
//-----------------------------------------------------------------------------
DWORD
CCredMgr::SaveCreds(HWND hWndCredCtrl)
{
   TRACER(CCredMgr,SaveCreds);
   WCHAR wzName[CREDUI_MAX_USERNAME_LENGTH+1] = {0},
         wzPw[CREDUI_MAX_PASSWORD_LENGTH+1] = {0};

   Credential_GetUserName(hWndCredCtrl, wzName, CREDUI_MAX_USERNAME_LENGTH);

   Credential_GetPassword(hWndCredCtrl, wzPw, CREDUI_MAX_PASSWORD_LENGTH);

   if (_fRemote)
   {
      return _RemoteCreds.SetUserAndPW(wzName, wzPw, _strDomain);
   }
   else
   {
      return _LocalCreds.SetUserAndPW(wzName, wzPw, _strDomain);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::Impersonate
//
//-----------------------------------------------------------------------------
DWORD
CCredMgr::Impersonate(void)
{
   TRACER(CCredMgr,Impersonate);
   if (_fRemote)
   {
      return _RemoteCreds.Impersonate();
   }
   else
   {
      return _LocalCreds.Impersonate();
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::ImpersonateAnonymous
//
//-----------------------------------------------------------------------------
DWORD
CCredMgr::ImpersonateAnonymous(void)
{
   TRACER(CCredMgr,ImpersonateAnonymous);
   DWORD dwErr = NO_ERROR;
   HANDLE hThread = NULL;

   hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());

   if (!hThread)
   {
      dwErr = GetLastError();
      dspDebugOut((DEB_ITRACE, "OpenThread failed with error %d\n", dwErr));
      return dwErr;
   }

   if (!ImpersonateAnonymousToken(hThread))
   {
      CloseHandle(hThread);
      dwErr = GetLastError();
      dspDebugOut((DEB_ITRACE, "ImpersonateAnonymousToken failed with error %d\n", dwErr));
      return dwErr;
   }

   CloseHandle(hThread);

   _fImpersonatingAnonymous = TRUE;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::Revert
//
//-----------------------------------------------------------------------------
void
CCredMgr::Revert(void)
{
   if (_fImpersonatingAnonymous)
   {
      TRACER(CCredMgr,Revert);
      RevertToSelf();
      _fImpersonatingAnonymous = FALSE;
   }
   else
   {
      _LocalCreds.Revert();
      _RemoteCreds.Revert();
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::RetryCollectInfo
//
//  Synopsis:  Called after LsaOpenPolicy failed with access-denied and then
//             obtaining credentials to the remote domain.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::RetryCollectInfo(void)
{
   HRESULT hr = S_OK;
   CWaitCursor Wait;

   hr = OtherDomain.OpenLsaPolicy(CredMgr);

   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      WizError.SetErrorString2Hr(hr);
      _hr = hr;
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   int nRet = GetDomainInfo();

   if (nRet)
   {
      // nRet will be non-zero if an error occured.
      //
      return nRet;
   }

   return ContinueCollectInfo();
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::RetryContinueCollectInfo
//
//  Synopsis:  Called after TrustExistCheck got access-denied and then
//             obtaining credentials to the local domain.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::RetryContinueCollectInfo(void)
{
   TRACER(CNewTrustWizard,RetryContinueCollectInfo);

   return ContinueCollectInfo(FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CollectInfo
//
//  Synopsis:  Attempt to contact the domains and collect the domain/trust info.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::CollectInfo(void)
{
   TRACER(CNewTrustWizard,CollectInfo);
   CStrW strFmt, strErr;
   CWaitCursor Wait;
   int nRet = 0;

   HRESULT hr = OtherDomain.DiscoverDC();

   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      WizError.SetErrorString2Hr(hr);
      _hr = hr;
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   if (OtherDomain.IsFound())
   {
      hr = OtherDomain.OpenLsaPolicy(CredMgr);

      if (FAILED(hr))
      {
         CredMgr.Revert();
         switch (hr)
         {
         case HRESULT_FROM_WIN32(STATUS_ACCESS_DENIED):
         case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            //
            // Normally an anonymous token is good enough to read the domain
            // policy. However, if restrict anonymous is set, then real domain
            // creds are needed. That must be the case if we are here.
            // Go to the credentials page. If the creds are good, then
            // call RetryCollectInfo() which will call GetDomainInfo
            //
            CredMgr.DoRemote();
            CredMgr.SetAdmin(FALSE);
            CredMgr.SetDomain(OtherDomain.GetUserEnteredName());
            if (!CredMgr.SetNextFcn(new CallPolicyRead(this)))
            {
               WizError.SetErrorString2Hr(E_OUTOFMEMORY);
               _hr = E_OUTOFMEMORY;
               return IDD_TRUSTWIZ_FAILURE_PAGE;
            }
            return IDD_TRUSTWIZ_CREDS_PAGE;

         default:
            CHECK_HRESULT(hr, ;);
            WizError.SetErrorString2Hr(hr);
            _hr = hr;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      nRet = GetDomainInfo();

      if (nRet)
      {
         // nRet will be non-zero if an error occured.
         //
         return nRet;
      }
   }

   return ContinueCollectInfo();
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::ContinueCollectInfo
//
//  Synopsis:  Continues CollectInfo. Determines which pages to branch to
//             next based on the collected info.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::ContinueCollectInfo(BOOL fPrompt)
{
   CWaitCursor Wait;

   // Set the trust type value.
   //
   if (OtherDomain.IsFound())
   {
      if (OtherDomain.IsUplevel())
      {
         // First, make sure the user isn't trying to create trust to the same
         // domain.
         //
         if (_wcsicmp(TrustPage()->GetDnsDomainName(), OtherDomain.GetDnsName()) == 0)
         {
            WizError.SetErrorString1(IDS_TWERR_NOT_TO_SELF1);
            WizError.SetErrorString2(IDS_TWERR_NOT_TO_SELF2);
            _hr = E_FAIL;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }

         // TRUST_TYPE_UPLEVEL
         //
         Trust.SetTrustTypeUplevel();
      }
      else
      {
         // TRUST_TYPE_DOWNLEVEL
         //
         Trust.SetTrustTypeDownlevel();
      }
   }
   else
   {
      // Only Realm trust is possible
      //
      // TRUST_TYPE_MIT
      //
      Trust.SetTrustTypeRealm();
   }

   // See if the trust is external. It is external if the other domain is
   // downlevel or if they are not in the same forest.
   //
   Trust.SetExternal(!(OtherDomain.IsUplevel() &&
                       (_wcsicmp(OtherDomain.GetForestName(), TrustPage()->GetForestName()) == 0)
                      )
                    );

   // Look for an existing trust and if found save the state.
   //
   int nRet = TrustExistCheck(fPrompt);

   if (nRet)
   {
      // nRet will be non-zero if creds are needed or an error occured.
      //
      return nRet;
   }

   if (Trust.Exists())
   {
      // If an existing two-way trust, then nothing to do, otherwise a
      // one-way trust can be made bi-di.
      //
      if (Trust.GetTrustDirection() == TRUST_DIRECTION_BIDIRECTIONAL)
      {
         // Nothing to do, bail.
         //
         WizError.SetErrorString1((Trust.GetTrustType() == TRUST_TYPE_MIT) ?
                                  IDS_TWERR_REALM_ALREADY_EXISTS : IDS_TWERR_ALREADY_EXISTS);
         WizError.SetErrorString2((Trust.GetTrustType() == TRUST_TYPE_MIT) ?
                                  IDS_TWERR_REALM_CANT_CHANGE : IDS_TWERR_CANT_CHANGE);
         _hr = E_FAIL;
         return IDD_TRUSTWIZ_ALREADY_EXISTS_PAGE;
      }
      else
      {
         return IDD_TRUSTWIZ_BIDI_PAGE;
      }
   }

   if (OtherDomain.IsFound())
   {
      // If the local domain qualifies for cross-forest trust and the other
      // domain is external and root, then prompt for trust type.
      //
      if (_pTrustPage->QualifiesForestTrust() && Trust.IsExternal())
      {
         // Check if the other domain is the enterprise root.
         //
         int nRet = OtherDomainForestRootCheck();

         if (nRet)
         {
            // An error occurred.
            //
            return nRet;
         }

         if (OtherDomainIsForestRoot())
         {
            return IDD_TRUSTWIZ_EXTERN_OR_FOREST_PAGE;
         }
      }

      // New external or shortcut trust.
      //
      return IDD_TRUSTWIZ_DIRECTION_PAGE;
   }

   // Other domain not found, ask if user wants Realm trust.
   //
   return IDD_TRUSTWIZ_WIN_OR_MIT_PAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::GetDomainInfo
//
//  Synopsis:  Read the naming info from the remote domain.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::GetDomainInfo(void)
{
   TRACER(CNewTrustWizard,GetDomainInfo);
   HRESULT hr = S_OK;

   // Read the LSA domain policy naming info for the other domain (flat and DNS
   // names, SID, up/downlevel, forest root).
   //
   hr = OtherDomain.ReadDomainInfo();

   CredMgr.Revert();

   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      WizError.SetErrorString2Hr(hr);
      _hr = hr;
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::OtherDomainForestRootCheck
//
//  Synopsis:  See if this domain is the enterprise root.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::OtherDomainForestRootCheck(void)
{
   HRESULT hr = S_OK;

   hr = OtherDomain.IsForestRoot(&_fIsForestRoot);

   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      WizError.SetErrorString2Hr(hr);
      _hr = hr;
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CreateOrUpdateTrust
//
//  Synopsis:  When called, enough information has been gathered to create
//             the trust. All of this info is in the Trust member object.
//             Go ahead and create the trust.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::CreateOrUpdateTrust(void)
{
   TRACER(CNewTrustWizard, CreateOrUpdateTrust);
   HRESULT hr = S_OK;
   DWORD dwErr = NO_ERROR;

   if (CredMgr.IsLocalSet())
   {
      dwErr = CredMgr.ImpersonateLocal();

      if (ERROR_SUCCESS != dwErr)
      {
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   CPolicyHandle cPolicy(TrustPage()->GetDomainDcName());

   dwErr = cPolicy.OpenReqAdmin();

   if (ERROR_SUCCESS != dwErr)
   {
      dspDebugOut((DEB_ITRACE, "LsaOpenPolicy returned 0x%x\n", dwErr));
      WizError.SetErrorString2Hr(dwErr);
      _hr = HRESULT_FROM_WIN32(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   if (Trust.Exists())
   {
      // This is a modify rather than create operation.
      //
      dwErr = Trust.DoModify(cPolicy, OtherDomain);

      CredMgr.Revert();

      if (ERROR_ALREADY_EXISTS == dwErr)
      {
         WizError.SetErrorString1(IDS_TWERR_ALREADY_EXISTS);
         WizError.SetErrorString2(IDS_TWERR_CANT_CHANGE);
         _hr = E_FAIL;
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      if (ERROR_SUCCESS != dwErr)
      {
         // TODO: better error reporting
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }
   else
   {
      // Create a new trust.
      //

      dwErr = Trust.DoCreate(cPolicy, OtherDomain);

      CredMgr.Revert();

      if (ERROR_SUCCESS != dwErr)
      {
         // TODO: better error reporting
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   if (Trust.GetTrustType() == TRUST_TYPE_MIT)
   {
      // If Realm, go to trust OK page.
      //
      return IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
   }

   return IDD_TRUSTWIZ_STATUS_PAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::TrustExistCheck
//
//  Synopsis:  Look for an existing trust and if found save the state.
//
//  Returns:   Zero for success or a page ID if creds are needed or an error
//             occured.
//-----------------------------------------------------------------------------
int
CNewTrustWizard::TrustExistCheck(BOOL fPrompt)
{
   TRACER(CNewTrustWizard,TrustExistCheck);
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD dwErr = NO_ERROR;
   PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;

   CPolicyHandle cPolicy(TrustPage()->GetDomainDcName());

   dwErr = cPolicy.OpenReqAdmin();

   if (ERROR_SUCCESS != dwErr)
   {
      if ((STATUS_ACCESS_DENIED == dwErr || ERROR_ACCESS_DENIED == dwErr) &&
          fPrompt)
      {
         // send prompt message to creds page. If the creds are good then
         // call TrustExistCheck().
         //
         CredMgr.DoRemote(FALSE);
         CredMgr.SetAdmin();
         CredMgr.SetDomain(TrustPage()->GetDnsDomainName());
         if (!CredMgr.SetNextFcn(new CallTrustExistCheck(this)))
         {
            WizError.SetErrorString2Hr(E_OUTOFMEMORY);
            _hr = E_OUTOFMEMORY;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
         return IDD_TRUSTWIZ_CREDS_PAGE;
      }
      else
      {
         dspDebugOut((DEB_ITRACE, "LsaOpenPolicy returned 0x%x\n", dwErr));
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   Status = Trust.Query(cPolicy, OtherDomain, NULL, &pFullInfo);

   if (STATUS_SUCCESS == Status)
   {
      dspAssert(pFullInfo);

      if (pFullInfo->Information.TrustType != Trust.GetTrustType())
      {
         // The current domain state is not the same as that stored on the TDO.
         //
         UINT nID1 = IDS_WZERR_TYPE_UNEXPECTED, nID2 = IDS_WZERR_TYPE_DELETE;
         CStrW strErr, strFormat;
         switch (pFullInfo->Information.TrustType)
         {
         case TRUST_TYPE_MIT:
            //
            // The domain was contacted and is a Windows domain, yet the TDO
            // thinks it is an MIT trust.
            //
            nID1 = IDS_WZERR_TYPE_MIT;
            break;

         case TRUST_TYPE_DOWNLEVEL:
         case TRUST_TYPE_UPLEVEL:
            if (Trust.GetTrustType() == TRUST_TYPE_MIT)
            {
               //
               // The domain cannot be contacted, yet the TDO says it is a
               // Windows trust.
               //
               nID1 = IDS_WZERR_TYPE_WIN;
               nID2 = IDS_WZERR_TYPE_NOT_FOUND;
            }
            break;
         }

         strFormat.LoadString(g_hInstance, nID1);
         strErr.Format(strFormat, OtherDomain.GetUserEnteredName());
         WizError.SetErrorString1(strErr);
         WizError.SetErrorString2(IDS_WZERR_TYPE_DELETE);
         _hr = E_FAIL;
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      Trust.SetExists();
      Trust.SetTrustDirection(pFullInfo->Information.TrustDirection);
      Trust.SetTrustAttr(pFullInfo->Information.TrustAttributes);
      LsaFreeMemory(pFullInfo);
   }
   else
   {
      // If the object isn't found, then a trust doesn't already exist. That
      // isn't an error. The CTrust::_fExists property is initilized to be
      // FALSE. If some other status is returned, then that is an error.
      //
      if (STATUS_OBJECT_NAME_NOT_FOUND != Status)
      {
         dspDebugOut((DEB_ITRACE, "LsaQueryTDIBN returned 0x%x\n", Status));
         WizError.SetErrorString2Hr(LsaNtStatusToWinError(dwErr));
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::VerifyOutboundTrust
//
//  Synopsis:  Verify the outbound trust.
//
//  Returns:   Zero for success or a page ID if an error occured.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::VerifyOutboundTrust(void)
{
   TRACER(CNewTrustWizard,VerifyOutboundTrust);
   DWORD dwRet = NO_ERROR;

   dspAssert(Trust.GetTrustDirection() & TRUST_DIRECTION_OUTBOUND);

   if (CredMgr.IsLocalSet())
   {
      dwRet = CredMgr.ImpersonateLocal();

      if (ERROR_SUCCESS != dwRet)
      {
         WizError.SetErrorString1(IDS_ERR_CANT_VERIFY_CREDS);
         WizError.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      // Because the login uses the LOGON32_LOGON_NEW_CREDENTIALS flag, no
      // attempt is made to use the credentials until a remote resource is
      // accessed. Thus, we don't yet know if the user entered credentials are
      // valid at this point. Use LsaOpenPolicy to do a quick check.
      //
      CPolicyHandle Policy(TrustPage()->GetDomainDcName());

      dwRet = Policy.OpenReqAdmin();

      if (ERROR_SUCCESS != dwRet)
      {
         WizError.SetErrorString1(IDS_ERR_CANT_VERIFY_CREDS);
         WizError.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      Policy.Close();
   }

   VerifyTrust.VerifyOutbound(TrustPage()->GetDomainDcName(),
                              OtherDomain.GetDnsName());
   CredMgr.Revert();

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::VerifyInboundTrust
//
//  Synopsis:  Verify the inbound trust.
//
//  Returns:   Zero for success or a page ID if an error occured.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::VerifyInboundTrust(void)
{
   TRACER(CNewTrustWizard,VerifyInboundTrust);
   DWORD dwRet = NO_ERROR;

   dspAssert(Trust.GetTrustDirection() & TRUST_DIRECTION_INBOUND);

   if (CredMgr.IsRemoteSet())
   {
      dwRet = CredMgr.ImpersonateRemote();

      if (ERROR_SUCCESS != dwRet)
      {
         WizError.SetErrorString1(IDS_ERR_CANT_VERIFY_CREDS);
         WizError.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      CPolicyHandle Policy(OtherDomain.GetUncDcName());

      dwRet = Policy.OpenReqAdmin();

      if (ERROR_SUCCESS != dwRet)
      {
         WizError.SetErrorString1(IDS_ERR_CANT_VERIFY_CREDS);
         WizError.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      Policy.Close();
   }

   VerifyTrust.VerifyInbound(OtherDomain.GetDcName(),
                             TrustPage()->GetDnsDomainName());
   CredMgr.Revert();

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::Verify
//
//  Synopsis:  Verify the trust and record the results.
//
//-----------------------------------------------------------------------------
DWORD
CVerifyTrust::Verify(PCWSTR pwzDC, PCWSTR pwzDomain, BOOL fInbound)
{
   TRACER(CVerifyTrust,Verify);
   dspDebugOut((DEB_ITRACE, "Verifying %ws on %ws to %ws\n",
                fInbound ? L"inbound" : L"outbound", pwzDC, pwzDomain));
   DWORD dwRet = NO_ERROR;
   NET_API_STATUS NetStatus = NO_ERROR;
   BOOL fVerifySupported = TRUE;
   PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
   PDS_DOMAIN_TRUSTS rgDomains = NULL;
   ULONG DomainCount = 0;

   dspAssert(pwzDC && pwzDomain);

   // DsEnumerateDomainTrusts will block if there is a NetLogon trust
   // update in progress. Call it to insure that our trust changes are
   // known by NetLogon before we do the query/reset.
   //
   dwRet = DsEnumerateDomainTrusts(const_cast<PWSTR>(pwzDC),
                                   DS_DOMAIN_IN_FOREST | DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAIN_DIRECT_INBOUND,
                                   &rgDomains, &DomainCount);
   if (ERROR_SUCCESS == dwRet)
   {
      NetApiBufferFree(rgDomains);
   }
   else
   {
      dspDebugOut((DEB_ERROR,
                   "**** DsEnumerateDomainTrusts ERROR <%s @line %d> -> %d\n",
                   __FILE__, __LINE__, dwRet));
   }

   if (fInbound)
   {
      _fInboundVerified = TRUE;
   }
   else
   {
      _fOutboundVerified = TRUE;
   }

   // First try a non-destructive trust password verification.
   //
   NetStatus = I_NetLogonControl2(pwzDC,
                                  NETLOGON_CONTROL_TC_VERIFY,
                                  2,
                                  (LPBYTE)&pwzDomain,
                                  (LPBYTE *)&NetlogonInfo2);

   if (NERR_Success == NetStatus)
   {
      dspAssert(NetlogonInfo2);

      if (NETLOGON_VERIFY_STATUS_RETURNED & NetlogonInfo2->netlog2_flags)
      {
         // The status of the verification is in the
         // netlog2_pdc_connection_status field.
         //
         NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;

         dspDebugOut((DEB_ITRACE,
                      "NetLogon SC verify for %ws on DC %ws gives verify status %d to DC %ws\n\n",
                      pwzDomain, pwzDC, NetStatus,
                      NetlogonInfo2->netlog2_trusted_dc_name));
      }
      else
      {
         NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

         dspDebugOut((DEB_ITRACE,
                      "NetLogon SC verify for %ws on pre-2474 DC %ws gives conection status %d to DC %ws\n\n",
                      pwzDomain, pwzDC, NetStatus,
                      NetlogonInfo2->netlog2_trusted_dc_name));
      }

      NetApiBufferFree(NetlogonInfo2);
   }
   else
   {
      if (ERROR_INVALID_LEVEL == NetStatus ||
          ERROR_NOT_SUPPORTED == NetStatus ||
          RPC_S_PROCNUM_OUT_OF_RANGE == NetStatus ||
          RPC_NT_PROCNUM_OUT_OF_RANGE == NetStatus)
      {
         TRACE(L"NETLOGON_CONTROL_TC_VERIFY is not supported on %s\n", pwzDC);
         fVerifySupported = FALSE;
      }
      else
      {
         dspDebugOut((DEB_ITRACE,
                      "NetLogon SC Verify for %ws on DC %ws returns error 0x%x\n\n",
                      pwzDomain, pwzDC, NetStatus));
      }
   }

   CStrW strResult;
   PWSTR pwzErr = NULL;

   if (NERR_Success == NetStatus)
   {
      strResult.LoadString(g_hInstance,
                           fInbound ? IDS_TRUST_VERIFY_INBOUND : IDS_TRUST_VERIFY_OUTBOUND);
      AppendResultString(strResult, fInbound);
      return NO_ERROR;
   }
   else
   {
      if (fVerifySupported)
      {
         // Ignore ERROR_NO_LOGON_SERVERS because that is often due to the SC
         // just not being set up yet.
         //
         if (ERROR_NO_LOGON_SERVERS == NetStatus)
         {
            strResult.LoadString(g_hInstance, IDS_VERIFY_TCV_LOGSRV);
            AppendResultString(strResult, fInbound);
            AppendResultString(g_wzCRLF, fInbound);
         }
         else
         {
            // LoadErrorMessage calls FormatMessage for a message from the
            // system and places a crlf at the end of the string,
            // so don't place another afterwards.
            LoadErrorMessage(NetStatus, 0, &pwzErr);
            dspAssert(pwzErr);
            if (!pwzErr)
            {
               pwzErr = L"";
            }
            strResult.FormatMessage(g_hInstance, IDS_VERIFY_TCV_FAILED, NetStatus, pwzErr);
            delete [] pwzErr;
            pwzErr = NULL;
            AppendResultString(strResult, fInbound);
         }
      }
      else
      {
         strResult.LoadString(g_hInstance, IDS_VERIFY_TCV_NSUPP);
         AppendResultString(strResult, fInbound);
         AppendResultString(g_wzCRLF, fInbound);
      }
      strResult.LoadString(g_hInstance, IDS_VERIFY_DOING_RESET);
      AppendResultString(strResult, fInbound);
   }

   // Now try a secure channel reset.
   //
   NetStatus = I_NetLogonControl2(pwzDC,
                                  NETLOGON_CONTROL_REDISCOVER,
                                  2,
                                  (LPBYTE)&pwzDomain,
                                  (LPBYTE *)&NetlogonInfo2);

   if (NERR_Success == NetStatus)
   {
      dspAssert(NetlogonInfo2);

      NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

      dspDebugOut((DEB_ITRACE,
                   "NetLogon SC reset for %ws on DC %ws gives status %d to DC %ws\n\n",
                   pwzDomain, pwzDC, NetStatus,
                   NetlogonInfo2->netlog2_trusted_dc_name));

      NetApiBufferFree(NetlogonInfo2);
   }
   else
   {
      dspDebugOut((DEB_ITRACE,
                   "NetLogon SC reset for %ws on DC %ws returns error 0x%x\n\n",
                   pwzDomain, pwzDC, NetStatus));
   }

   AppendResultString(g_wzCRLF, fInbound);

   if (NERR_Success == NetStatus)
   {
      strResult.LoadString(g_hInstance,
                           fInbound ? IDS_TRUST_VERIFY_INBOUND : IDS_TRUST_VERIFY_OUTBOUND);
      return NO_ERROR;
   }
   else
   {
      LoadErrorMessage(NetStatus, 0, &pwzErr);
      dspAssert(pwzErr);
      if (!pwzErr)
      {
         pwzErr = L"";
      }
      strResult.FormatMessage(g_hInstance, IDS_VERIFY_RESET_FAILED, NetStatus, pwzErr);
      delete [] pwzErr;
   }
   AppendResultString(strResult, fInbound);

   SetResult(NetStatus, fInbound);

   return NetStatus;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::ClearResults
//
//-----------------------------------------------------------------------------
void
CVerifyTrust::ClearResults(void)
{
   TRACER(CVerifyTrust,ClearResults);
   _strInboundResult.Empty();
   _strOutboundResult.Empty();
   _dwInboundResult = _dwOutboundResult = 0;
   _fInboundVerified = _fOutboundVerified = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::Query
//
//  Synopsis:  Read the TDO.
//
//-----------------------------------------------------------------------------
NTSTATUS
CTrust::Query(LSA_HANDLE hPolicy,
              CRemoteDomain & OtherDomain,
              PLSA_UNICODE_STRING pName, // optional, can be NULL
              PTRUSTED_DOMAIN_FULL_INFORMATION * ppFullInfo)
{
   NTSTATUS Status = STATUS_SUCCESS;
   LSA_UNICODE_STRING Name = {0};

   if (!pName)
   {
      pName = &Name;
   }

   if (_strTrustPartnerName.IsEmpty())
   {
      switch (GetTrustType())
      {
      case TRUST_TYPE_UPLEVEL:
         _strTrustPartnerName = IsUpdated() ? OtherDomain.GetFlatName() :
                                              OtherDomain.GetDnsName();
         break;

      case TRUST_TYPE_DOWNLEVEL:
         _strTrustPartnerName = OtherDomain.GetFlatName();
         break;

      case TRUST_TYPE_MIT:
         _strTrustPartnerName = OtherDomain.GetUserEnteredName();
         break;

      default:
         dspAssert(FALSE);
         return STATUS_INVALID_PARAMETER;
      }
   }

   RtlInitUnicodeString(pName, _strTrustPartnerName);

   Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                            pName,
                                            TrustedDomainFullInformation,
                                            (PVOID *)ppFullInfo);

   if (STATUS_OBJECT_NAME_NOT_FOUND == Status && !IsUpdated() &&
       TRUST_TYPE_UPLEVEL == GetTrustType())
   {
      // If we haven't tried the flat name yet, try it now; can get here if a
      // downlevel domain is upgraded to NT5. The name used the first time
      // that Query is called would be the DNS name but the TDO would be
      // named after the flat name.
      //
      dspDebugOut((DEB_ITRACE, "LsaQueryTDIBN: DNS name failed, trying flat name\n"));

      RtlInitUnicodeString(pName, OtherDomain.GetFlatName());

      Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                               pName,
                                               TrustedDomainFullInformation,
                                               (PVOID *)ppFullInfo);
      if (STATUS_SUCCESS == Status)
      {
         // Remember the fact that the flat name had to be used.
         //
         SetUpdated();
      }
   }

   return Status;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::DoCreate
//
//  Synopsis:  Create the trust based on the settings in the CTrust object.
//
//-----------------------------------------------------------------------------
DWORD
CTrust::DoCreate(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain)
{
   TRACER(CTrust, DoCreate);
   NTSTATUS Status = STATUS_SUCCESS;
   TRUSTED_DOMAIN_INFORMATION_EX tdix = {0};
   LSA_AUTH_INFORMATION AuthData = {0};
   TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx = {0};

   RtlZeroMemory(&AuthData, sizeof(LSA_AUTH_INFORMATION));
   RtlZeroMemory(&AuthInfoEx, sizeof(TRUSTED_DOMAIN_AUTH_INFORMATION));

   GetSystemTimeAsFileTime((PFILETIME)&AuthData.LastUpdateTime);

   AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
   AuthData.AuthInfoLength = static_cast<ULONG>(wcslen(GetTrustPW()) * sizeof(WCHAR));
   AuthData.AuthInfo = (PUCHAR)GetTrustPW();


   if (GetNewTrustDirection() & TRUST_DIRECTION_INBOUND)
   {
      AuthInfoEx.IncomingAuthInfos = 1;
      AuthInfoEx.IncomingAuthenticationInformation = &AuthData;
      AuthInfoEx.IncomingPreviousAuthenticationInformation = NULL;
   }

   if (GetNewTrustDirection() & TRUST_DIRECTION_OUTBOUND)
   {
      AuthInfoEx.OutgoingAuthInfos = 1;
      AuthInfoEx.OutgoingAuthenticationInformation = &AuthData;
      AuthInfoEx.OutgoingPreviousAuthenticationInformation = NULL;
   }

   tdix.TrustAttributes = GetNewTrustAttr();

   switch (GetTrustType())
   {
   case TRUST_TYPE_UPLEVEL:
      RtlInitUnicodeString(&tdix.Name, OtherDomain.GetDnsName());
      RtlInitUnicodeString(&tdix.FlatName, OtherDomain.GetFlatName());
      tdix.Sid = OtherDomain.GetSid();
      tdix.TrustType = TRUST_TYPE_UPLEVEL;
      SetTrustPartnerName(OtherDomain.GetDnsName());
      break;

   case TRUST_TYPE_DOWNLEVEL:
      RtlInitUnicodeString(&tdix.Name, OtherDomain.GetFlatName());
      RtlInitUnicodeString(&tdix.FlatName, OtherDomain.GetFlatName());
      tdix.Sid = OtherDomain.GetSid();
      tdix.TrustType = TRUST_TYPE_DOWNLEVEL;
      SetTrustPartnerName(OtherDomain.GetFlatName());
      break;

   case TRUST_TYPE_MIT:
      RtlInitUnicodeString(&tdix.Name, OtherDomain.GetUserEnteredName());
      RtlInitUnicodeString(&tdix.FlatName, OtherDomain.GetUserEnteredName());
      tdix.Sid = NULL;
      tdix.TrustType = TRUST_TYPE_MIT;
      tdix.TrustAttributes = TRUST_ATTRIBUTE_NON_TRANSITIVE;
      SetTrustPartnerName(OtherDomain.GetUserEnteredName());
      break;

   default:
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }
   tdix.TrustDirection = GetNewTrustDirection();

   LSA_HANDLE hTrustedDomain;

   Status = LsaCreateTrustedDomainEx(hPolicy,
                                     &tdix,
                                     &AuthInfoEx,
                                     TRUSTED_SET_AUTH | TRUSTED_SET_POSIX,
                                     &hTrustedDomain);
   if (NT_SUCCESS(Status))
   {
      LsaClose(hTrustedDomain);
      SetTrustDirection(GetNewTrustDirection());
      SetTrustAttr(GetNewTrustAttr());
   }
   else
   {
      dspDebugOut((DEB_ITRACE, "LsaCreateTrustedDomainEx failed with error 0x%x\n",
                   Status));
   }

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::DoModify
//
//  Synopsis:  Modify the trust based on the settings in the CTrust object.
//
//-----------------------------------------------------------------------------
DWORD
CTrust::DoModify(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain)
{
   TRACER(CTrust, DoModify);

   ULONG ulNewDir = GetTrustDirection() ^ GetNewTrustDirection();
   BOOL fSetAttr = GetTrustAttr() != GetNewTrustAttr();

   if (!ulNewDir & !fSetAttr)
   {
      // Nothing to do.
      //
      return ERROR_ALREADY_EXISTS;
   }

   NTSTATUS Status = STATUS_SUCCESS;
   PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;
   LSA_UNICODE_STRING Name = {0};

   Status = Query(hPolicy, OtherDomain, &Name, &pFullInfo);

   if (STATUS_SUCCESS != Status)
   {
      dspDebugOut((DEB_ITRACE, "Trust.Query returned 0x%x\n", Status));
      return LsaNtStatusToWinError(Status);
   }

   dspAssert(pFullInfo);

   LSA_AUTH_INFORMATION AuthData = {0};
   BOOL fSidSet = FALSE;

   if (ulNewDir)
   {
      GetSystemTimeAsFileTime((PFILETIME)&AuthData.LastUpdateTime);

      AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
      AuthData.AuthInfoLength = static_cast<ULONG>(GetTrustPWlen() * sizeof(WCHAR));
      AuthData.AuthInfo = (PUCHAR)GetTrustPW();

      if (TRUST_DIRECTION_INBOUND == ulNewDir)
      {
         // Adding Inbound.
         //
         pFullInfo->AuthInformation.IncomingAuthInfos = 1;
         pFullInfo->AuthInformation.IncomingAuthenticationInformation = &AuthData;
         pFullInfo->AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
      }
      else
      {
         // Adding outbound.
         //
         pFullInfo->AuthInformation.OutgoingAuthInfos = 1;
         pFullInfo->AuthInformation.OutgoingAuthenticationInformation = &AuthData;
         pFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
      }
      pFullInfo->Information.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
      //
      // Check for a NULL domain SID. The SID can be NULL if the inbound
      // trust was created when the domain was NT4. MIT trusts don't have a SID.
      //
      if (!pFullInfo->Information.Sid && (TRUST_TYPE_MIT != GetTrustType()))
      {
         pFullInfo->Information.Sid = OtherDomain.GetSid();
         fSidSet = TRUE;
      }
   }

   if (fSetAttr)
   {
      pFullInfo->Information.TrustAttributes = GetNewTrustAttr();
   }

   Status = LsaSetTrustedDomainInfoByName(hPolicy,
                                          &Name,
                                          TrustedDomainFullInformation,
                                          pFullInfo);
   if (fSidSet)
   {
      // the SID memory is owned by OtherDomain, so don't free it here.
      //
      pFullInfo->Information.Sid = NULL;
   }
   LsaFreeMemory(pFullInfo);

   if (NT_SUCCESS(Status))
   {
      SetTrustDirection(GetNewTrustDirection());
      SetTrustAttr(GetNewTrustAttr());
   }

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::SetMakeXForest
//
//-----------------------------------------------------------------------------
void
CTrust::SetMakeXForest(void)
{
   if (!_dwNewAttr)
   {
      _dwNewAttr = _dwAttr;
   }
   _dwNewAttr |= TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::SetTrustAttr
//
//-----------------------------------------------------------------------------
void
CTrust::SetTrustAttr(DWORD attr)
{
   TRACER(CTrust,SetTrustAttr);

   _dwAttr = _dwNewAttr = attr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::IsXForest
//
//-----------------------------------------------------------------------------
BOOL
CTrust::IsXForest(void)
{
   return _dwAttr & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ||
          _dwNewAttr & TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::Clear
//
//-----------------------------------------------------------------------------
void
CTrust::Clear(void)
{
   _strTrustPartnerName.Empty();
   _strTrustPW.Empty();
   _dwType = 0;
   _dwDirection = 0;
   _dwNewDirection = 0;
   _dwAttr = 0;
   _dwNewAttr = 0;
   _fExists = FALSE;
   _fUpdatedFromNT4 = FALSE;
   _fExternal = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::ReadFTInfo
//
//  Synopsis:  Read the forest trust name suffixes claimed by the trust
//             partner.
//
//  Arguments: [pwzLocalDC] - the name of the local DC.
//             [pwzOtherDC] - the DC of the trust partner.
//             [CredMgr]    - credentials obtained earlier.
//             [WizErr]     - reference to the error object.
//             [fCredErr]   - if true, then the return value is a page ID.
//
//  Returns:   Page ID or error code depending on the value of fCredErr.
//
//-----------------------------------------------------------------------------
DWORD
CTrust::ReadFTInfo(PCWSTR pwzLocalDC, PCWSTR pwzOtherDC, CCredMgr & CredMgr,
                   CWizError & WizErr, bool & fCredErr)
{
   TRACER(CTrust,ReadFTInfo);
   DWORD dwRet = NO_ERROR;

   if (!IsXForest() || _strTrustPartnerName.IsEmpty() || !pwzLocalDC ||
       !pwzOtherDC)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   PLSA_FOREST_TRUST_INFORMATION pNewFTInfo = NULL;

   if (GetNewTrustDirection() == TRUST_DIRECTION_INBOUND)
   {
      // Inbound-only trust must have the name fetch remoted to the other
      // domain.
      //
      if (CredMgr.IsRemoteSet())
      {
         dwRet = CredMgr.ImpersonateRemote();

         if (ERROR_SUCCESS != dwRet)
         {
            fCredErr = true;
            WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
            WizErr.SetErrorString2Hr(dwRet);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      dwRet = DsGetForestTrustInformationW(pwzOtherDC,
                                           NULL,
                                           0,
                                           &pNewFTInfo);
      CredMgr.Revert();

      if (NO_ERROR != dwRet)
      {
         return dwRet;
      }

      dspAssert(pNewFTInfo);

      // Read the locally known names and then merge them with the names
      // discovered from the other domain.
      //
      NTSTATUS status = STATUS_SUCCESS;
      LSA_UNICODE_STRING TrustPartner = {0};
      PLSA_FOREST_TRUST_INFORMATION pKnownFTInfo = NULL, pMergedFTInfo = NULL;

      RtlInitUnicodeString(&TrustPartner, _strTrustPartnerName);

      if (CredMgr.IsLocalSet())
      {
         dwRet = CredMgr.ImpersonateLocal();

         if (ERROR_SUCCESS != dwRet)
         {
            NetApiBufferFree(pNewFTInfo);
            fCredErr = true;
            WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
            WizErr.SetErrorString2Hr(dwRet);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      CPolicyHandle cPolicy(pwzLocalDC);

      dwRet = cPolicy.OpenNoAdmin();

      dspAssert(!dwRet);

      status = LsaQueryForestTrustInformation(cPolicy,
                                              &TrustPartner,
                                              &pKnownFTInfo);
      if (STATUS_NOT_FOUND == status)
      {
         // no FT info stored yet, which is the expected state for a new trust.
         //
         status = STATUS_SUCCESS;
      }

      if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
      {
         NetApiBufferFree(pNewFTInfo);
         CredMgr.Revert();
         return dwRet;
      }

      if (pKnownFTInfo && pKnownFTInfo->RecordCount)
      {
         // Merge the two.
         //
         dwRet = DsMergeForestTrustInformationW(_strTrustPartnerName,
                                                pNewFTInfo,
                                                pKnownFTInfo,
                                                &pMergedFTInfo);
         NetApiBufferFree(pNewFTInfo);

         CHECK_WIN32(dwRet, return dwRet);

         dspAssert(pMergedFTInfo);

         _FTInfo = pMergedFTInfo;

         LsaFreeMemory(pKnownFTInfo);
         LsaFreeMemory(pMergedFTInfo);
      }
      else
      {
         _FTInfo = pNewFTInfo;

         NetApiBufferFree(pNewFTInfo);
      }

      // Now write the data. On return from the call the pColInfo struct
      // will contain current collision data.
      //
      PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

      status = LsaSetForestTrustInformation(cPolicy,
                                            &TrustPartner,
                                            _FTInfo.GetFTInfo(),
                                            FALSE,
                                            &pColInfo);
      CredMgr.Revert();

      if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
      {
         return dwRet;
      }

      _CollisionInfo = pColInfo;

      return NO_ERROR;
   }

   // Outbound or bi-di trust, call DsGetForestTrustInfo locally.
   //
   if (CredMgr.IsLocalSet())
   {
      dwRet = CredMgr.ImpersonateLocal();

      if (ERROR_SUCCESS != dwRet)
      {
         fCredErr = true;
         WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
         WizErr.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   dwRet = DsGetForestTrustInformationW(pwzLocalDC,
                                        _strTrustPartnerName,
                                        DS_GFTI_UPDATE_TDO,
                                        &pNewFTInfo);
   CredMgr.Revert();

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   _FTInfo = pNewFTInfo;

   NetApiBufferFree(pNewFTInfo);

   return dwRet;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::WriteFTInfo
//
//-----------------------------------------------------------------------------
DWORD
CTrust::WriteFTInfo(PCWSTR pwzLocalDC)
{
   TRACER(CTrust,WriteFTInfo);
   DWORD dwRet;

   if (!IsXForest() || _strTrustPartnerName.IsEmpty() || !_FTInfo.GetCount() ||
       !pwzLocalDC)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING Name = {0};
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

   RtlInitUnicodeString(&Name, _strTrustPartnerName);

   CPolicyHandle cPolicy(pwzLocalDC);

   dwRet = cPolicy.OpenReqAdmin();

   dspAssert(!dwRet);

   status = LsaSetForestTrustInformation(cPolicy,
                                         &Name,
                                         _FTInfo.GetFTInfo(),
                                         TRUE,
                                         &pColInfo);
   if (STATUS_SUCCESS != status)
   {
      return LsaNtStatusToWinError(status);
   }

   if (pColInfo && pColInfo->RecordCount)
   {
      PLSA_FOREST_TRUST_COLLISION_RECORD pRec = NULL;
      PLSA_FOREST_TRUST_RECORD pFTRec = NULL;

      for (UINT i = 0; i < pColInfo->RecordCount; i++)
      {
         pRec = pColInfo->Entries[i];
         pFTRec = _FTInfo.GetFTInfo()->Entries[pRec->Index];

         dspDebugOut((DEB_ITRACE, "Collision on record %d, type %d, flags 0x%x, name %ws\n",
                      pRec->Index, pRec->Type, pRec->Flags, pRec->Name.Buffer));

         switch (pFTRec->ForestTrustType)
         {
         case ForestTrustTopLevelName:
         case ForestTrustTopLevelNameEx:
            dspDebugOut((DEB_ITRACE, "Referenced FTInfo: %ws, type: TLN\n",
                         pFTRec->ForestTrustData.TopLevelName.Buffer));
            pFTRec->Flags = pRec->Flags;
            break;

         case ForestTrustDomainInfo:
            dspDebugOut((DEB_ITRACE, "Referenced FTInfo: %ws, type: Domain\n",
                         pFTRec->ForestTrustData.DomainInfo.DnsName.Buffer));
            pFTRec->Flags = pRec->Flags;
            break;

         default:
            break;
         }
      }
      LsaFreeMemory(pColInfo);
   }

   status = LsaSetForestTrustInformation(cPolicy,
                                         &Name,
                                         _FTInfo.GetFTInfo(),
                                         FALSE,
                                         &pColInfo);
   if (STATUS_SUCCESS != status)
   {
      return LsaNtStatusToWinError(status);
   }

   _CollisionInfo = pColInfo;

#if DBG == 1
   if (pColInfo && pColInfo->RecordCount)
   {
      PLSA_FOREST_TRUST_COLLISION_RECORD pRec;

      for (UINT i = 0; i < pColInfo->RecordCount; i++)
      {
         pRec = pColInfo->Entries[i];

         dspDebugOut((DEB_ITRACE, "Collision on record %d, type %d, flags 0x%x, name %ws\n",
                      pRec->Index, pRec->Type, pRec->Flags, pRec->Name.Buffer));
      }
   }
#endif

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::AreThereCollisions
//
//-----------------------------------------------------------------------------
BOOL
CTrust::AreThereCollisions(void)
{
   if (_CollisionInfo.IsInConflict() || _FTInfo.IsInConflict())
   {
      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::GetTrustDirStrID
//
//-----------------------------------------------------------------------------
int
CTrust::GetTrustDirStrID(DWORD dwDir)
{
   switch (dwDir)
   {
   case TRUST_DIRECTION_INBOUND:
      return IDS_TRUST_DIR_INBOUND_SHORTCUT;

   case TRUST_DIRECTION_OUTBOUND:
      return IDS_TRUST_DIR_OUTBOUND_SHORTCUT;

   case TRUST_DIRECTION_BIDIRECTIONAL:
      return IDS_TRUST_DIR_BIDI;

   default:
      return IDS_TRUST_DISABLED;
   }
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\tlnedit.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       tlnedit.cxx
//
//  Contents:   Forest trust TLN edit dialogs.
//
//  History:    20-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include <dnsapi.h>
#include "proppage.h"
#include "trust.h"
#include "listview.h"
#include "routing.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:     CEditTLNDialog
//
//  Purpose:   Change the settings of names derived from TLNs.
//
//-----------------------------------------------------------------------------
CEditTLNDialog::CEditTLNDialog(HWND hParent, int nTemplateID,
                               CFTInfo & FTInfo,
                               CFTCollisionInfo & ColInfo,
                               CDsForestNameRoutingPage * pRoutingPage) :
   _pRoutingPage(pRoutingPage),
   _FTInfo(FTInfo),
   _CollisionInfo(ColInfo),
   _iSel(0),
   _iNewExclusion(0),
   _fIsDirty(false),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CEditTLNDialog,CEditTLNDialog);
#ifdef _DEBUG
    strcpy(szClass, "CEditTLNDialog");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::DoModal
//
//  Synopsis:   Launch the popup.
//
//-----------------------------------------------------------------------------
INT_PTR
CEditTLNDialog::DoModal(ULONG iSel)
{
   _iSel = iSel;

   return CModalDialog::DoModal();
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnInitDialog
//
//  Synopsis:   Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnInitDialog(LPARAM lParam)
{
   TRACE(CEditTLNDialog,OnInitDialog);

   if (_pRoutingPage->IsReadOnly())
   {
      EnableWindow(GetDlgItem(_hDlg, IDC_ADD_EXCLUSION_BTN), FALSE);
   }

   _SuffixList.Init(_hDlg, IDC_SUFFIXES_LIST);

   dspAssert(_iSel < _FTInfo.GetCount());

#if DBG
   LSA_FOREST_TRUST_RECORD_TYPE type;
   dspAssert(_FTInfo.GetType(_iSel, type) && type == ForestTrustTopLevelName);
#endif

   CStrW strValue;

   _FTInfo.GetDnsName(_iSel, strValue);

   FormatWindowText(_hDlg, strValue);

   //Test the dynamic label code by forcing a really long name.
   //strValue += L".foo.bar.really.longdnsnames.com";
   
   FormatWindowText(GetDlgItem(_hDlg, IDC_EXCLUDE_LABEL), strValue);
   UseOneOrTwoLine(_hDlg, IDC_EXCLUDE_LABEL, IDC_EXCLUDE_LABEL_LARGE);
   
   FormatWindowText(GetDlgItem(_hDlg, IDC_SUFFIXES_LABEL), strValue);
   UseOneOrTwoLine(_hDlg, IDC_SUFFIXES_LABEL, IDC_SUFFIX_LABEL_LARGE);

   // Fill the excluded names list.
   //
   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      if (_FTInfo.IsChildDomain(_iSel, i))
      {
         if (_FTInfo.IsTlnExclusion(i) &&
             FT_EXTRA_INFO::STATUS::Enabled == _FTInfo.GetExtraStatus(i))
         {
            if (!_FTInfo.GetDnsName(i, strValue))
            {
               dspAssert(FALSE);
               continue;
            }

            AddAsteriskPrefix(strValue);

            SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_ADDSTRING, 0,
                               (LPARAM)strValue.GetBuffer(0));
         }
      }
   }

   FillSuffixList();

   EnableExRmButton();
   EnableSuffixListButtons();

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::FillSuffixList
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::FillSuffixList(void)
{
   // Fill the TLN subname list with the domain that matches the selected TLN
   // and all of its children. However, if a domain is disabled, then its
   // children are not shown. A domain is disabled by creating an exclusion
   // record with the same name. Disabled domains have a "*." prepended.
   //
   CStrW strName;

   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      if (_FTInfo.IsChildDomain(_iSel, i) && !_FTInfo.IsTlnExclusion(i))
      {
         if (!_FTInfo.GetDnsName(i, strName))
         {
            dspAssert(FALSE);
            continue;
         }

         TLN_EDIT_STATUS Status;

         switch (_FTInfo.GetExtraStatus(i))
         {
         case FT_EXTRA_INFO::STATUS::DisabledViaMatchingTLNEx:
            AddAsteriskPrefix(strName);
            Status = Disabled;
            _SuffixList.AddItem(strName, i, Status);
            break;

         case FT_EXTRA_INFO::STATUS::DisabledViaParentMatchingTLNEx:
            continue;

         default:
            if (!_FTInfo.GetTlnEditStatus(i, Status))
            {
               dspAssert(FALSE);
               continue;
            }
            _SuffixList.AddItem(strName, i, Status);
            break;
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_ADD_EXCLUSION_BTN:
         OnAddExclusion();
         break;

      case IDC_REMOVE_EXCLUSION_BTN:
         OnRemoveExclusion();
         break;

      case IDC_ENABLE_BTN:
         OnEnableName();
         break;

      case IDC_DISABLE_BTN:
         OnDisableName();
         break;

      case IDC_SAVE_FOREST_NAMES_BTN:
         OnSave();
         break;

      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      default:
         dspAssert(FALSE);
         break;
      }

      return 0;
   }

   if (IDC_EXCLUDE_LIST == id && (LBN_SELCHANGE == codeNotify ||
        LBN_SETFOCUS == codeNotify || LBN_KILLFOCUS == codeNotify))
   {
      EnableExRmButton();
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnNotify(WPARAM wParam, LPARAM lParam)
{
    HWND hList;

    if (_fInInit)
    {
        return 0;
    }

    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_GETINFOTIP:
       NMLVGETINFOTIP * pInfoTip;
       pInfoTip = (LPNMLVGETINFOTIP)lParam;
       dspDebugOut((DEB_ITRACE, "Got LVN_GETINFOTIP, pszText is %ws\n", pInfoTip->pszText));
       break;

    case LVN_ITEMCHANGED:
        EnableSuffixListButtons();
        break;

    case NM_SETFOCUS:
        hList = GetDlgItem(_hDlg, (int)((LPNMHDR)lParam)->idFrom);

        if (ListView_GetItemCount(hList))
        {
            int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

            if (item < 0)
            {
                // If nothing is selected, set the focus to the first item.
                //
                LV_ITEM lvi = {0};
                lvi.mask = LVIF_STATE;
                lvi.stateMask = LVIS_FOCUSED;
                lvi.state = LVIS_FOCUSED;
                ListView_SetItem(hList, &lvi);
            }
        }
        EnableSuffixListButtons();
        break;

    case NM_KILLFOCUS:
        EnableSuffixListButtons();
        break;
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnHelp(LPHELPINFO pHelpInfo)
{
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnAddExclusion
//
//  Synopsis:  Post the Add-Exclusions dialog.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnAddExclusion(void)
{
   TRACE(CEditTLNDialog,OnAddExclusion);

   CExcludeTLNDialog ExcludeDlg(_hDlg, IDD_TLN_EXCLUDE, _FTInfo, this);

   INT_PTR nRet = ExcludeDlg.DoModal();

   CStrW strName;

   switch (nRet)
   {
   case IDOK:
      // Add the new exclusion to the list.
      dspAssert(_iNewExclusion);

      if (!_FTInfo.GetDnsName(_iNewExclusion, strName))
      {
         dspAssert(FALSE);
         return;
      }

      AddAsteriskPrefix(strName);

      SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_ADDSTRING, 0,
                         (LPARAM)strName.GetBuffer(0));
      _fIsDirty = true;
      break;
      
   case IDCANCEL:
      break;

   default:
      REPORT_ERROR((HRESULT)((nRet < 0) ? GetLastError() : nRet), _hDlg);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnRemoveExclusion
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnRemoveExclusion(void)
{
   TRACE(CEditTLNDialog,OnRemoveExclusion);

   int iSel = (int)SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETCURSEL, 0, 0);

   if (iSel < 0)
   {
      return;
   }

   CStrW strName;

   int nLen = (int)SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETTEXTLEN, (WPARAM)iSel, 0);

   strName.GetBufferSetLength(nLen + 1);

   SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETTEXT, (WPARAM)iSel, (LPARAM)strName.GetBuffer(0));

   RemoveAsteriskPrefix(strName);

   ULONG index;

   if (!_FTInfo.GetIndex(strName, index))
   {
      dspAssert(FALSE);
      return;
   }

   if (!_FTInfo.RemoveExclusion(index))
   {
      dspAssert(FALSE);
      return;
   }

   SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_DELETESTRING, (WPARAM)iSel, 0);

   _fIsDirty = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnEnableName
//
//  Synopsis:  Save the names.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnEnableName(void)
{
   TRACE(CEditTLNDialog,OnEnableName);

   int item = _SuffixList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _SuffixList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.EnableDomain(i);

   _SuffixList.Clear();
   FillSuffixList();

   EnableSuffixListButtons();

   _fIsDirty = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnDisableName
//
//  Synopsis:  Save the names.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnDisableName(void)
{
   TRACE(CEditTLNDialog,OnDisableName);

   int item = _SuffixList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _SuffixList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.DisableDomain(i);

   _SuffixList.Clear();
   FillSuffixList();

   EnableSuffixListButtons();

   _fIsDirty = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnSave
//
//  Synopsis:  Save the names.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnSave(void)
{
   TRACE(CEditTLNDialog,OnSave);

   SaveFTInfoAs(_hDlg,
                _pRoutingPage->GetTrustPartnerFlatName(),
                _pRoutingPage->GetTrustPartnerDnsName(),
                _FTInfo,
                _CollisionInfo);
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnOK
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnOK(void)
{
   TRACE(CEditTLNDialog,OnOK);

   if (_fIsDirty)
   {
      // Write out changes.
      //
      DWORD dwErr = _pRoutingPage->WriteTDO();

      if (NO_ERROR != dwErr)
      {
         ReportError(dwErr, IDS_ERR_WRITE_FTI_TO_TDO, _hDlg);
      }

      _fIsDirty = false;
   }

   EndDialog(_hDlg, IDOK);
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::EnableExRmButton
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::EnableExRmButton(void)
{
   TRACE(CEditTLNDialog,EnableExRmButton);
   bool fEnableRemove = false;

   int iSel = (int)SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETCURSEL, 0, 0);

   if (iSel >= 0 && !_pRoutingPage->IsReadOnly())
   {
      fEnableRemove = true;
   }

   EnableWindow(GetDlgItem(_hDlg, IDC_REMOVE_EXCLUSION_BTN), fEnableRemove);
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::EnableSuffixListButtons
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::EnableSuffixListButtons(void)
{
   TRACE(CEditTLNDialog,EnableSuffixListButtons);

   bool fActivateEnable = false, fActivateDisable = false;

   int item = _SuffixList.GetSelection();

   if (item >= 0 && !_pRoutingPage->IsReadOnly())
   {
      ULONG i = _SuffixList.GetFTInfoIndex(item);

      dspAssert(i < _FTInfo.GetCount());

      if (_FTInfo.IsEnabled(i))
      {
         fActivateDisable = true;
      }
      else
      {
         fActivateEnable = true;
      }
   }

   EnableWindow(GetDlgItem(_hDlg, IDC_ENABLE_BTN), fActivateEnable);
   EnableWindow(GetDlgItem(_hDlg, IDC_DISABLE_BTN), fActivateDisable);
}




//+----------------------------------------------------------------------------
//
//  Class:     CExcludeTLNDialog
//
//  Purpose:   Add TLN exclusion records.
//
//-----------------------------------------------------------------------------
CExcludeTLNDialog::CExcludeTLNDialog(HWND hParent, int nTemplateID,
                                     CFTInfo & FTInfo,
                                     CEditTLNDialog * pEditDlg) :
   _pEditDlg(pEditDlg),
   _FTInfo(FTInfo),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CExcludeTLNDialog,CExcludeTLNDialog);
#ifdef _DEBUG
    strcpy(szClass, "CExcludeTLNDialog");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnInitDialog
//
//  Synopsis:   Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CExcludeTLNDialog::OnInitDialog(LPARAM lParam)
{
   TRACE(CExcludeTLNDialog,OnInitDialog);

   SendDlgItemMessage(_hDlg, IDC_EXCLUSION_EDIT, EM_LIMITTEXT, MAX_PATH, 0);

   EnableWindow(GetDlgItem(_hDlg, IDOK), false);

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CExcludeTLNDialog::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   switch (codeNotify)
   {
   case EN_CHANGE:
      if (IDC_EXCLUSION_EDIT == id)
      {
         bool fHasChars = 0 != SendDlgItemMessage(_hDlg,
                                                  IDC_EXCLUSION_EDIT,
                                                  WM_GETTEXTLENGTH,
                                                  0, 0);

         EnableWindow(GetDlgItem(_hDlg, IDOK), fHasChars);
      }
      break;

   case BN_CLICKED:
      switch (id)
      {
      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnOK
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CExcludeTLNDialog::OnOK(void)
{
   CStrW strExclusion;
   int nLen;

   nLen = GetWindowTextLength(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT)) + 1;

   strExclusion.GetBufferSetLength(nLen);

   GetDlgItemText(_hDlg, IDC_EXCLUSION_EDIT, strExclusion, nLen);

   RemoveAsteriskPrefix(strExclusion);

   // Is this name subordinate to the TLN. If not, then report error.
   //
   if (!_FTInfo.IsChildName(_pEditDlg->GetTlnSelectionIndex(), strExclusion))
   {
      CStrW strTLN;
      _FTInfo.GetDnsName(_pEditDlg->GetTlnSelectionIndex(), strTLN);
      SuperMsgBox(_hDlg,
                  IDS_ERR_EXCLUSION_NOT_CHILD,
                  IDS_DNT_MSG_TITLE,
                  MB_OK | MB_ICONEXCLAMATION,
                  0,
                  (PVOID *)&strTLN,
                  1,
                  FALSE, __FILE__, __LINE__);
      SetFocus(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT));
      return;
   }

   // Does this name already exist in the FTInfo? If so, report error.
   //
   ULONG index;

   if (_FTInfo.GetIndex(strExclusion, index))
   {
      ErrMsg(IDS_ERR_EXCLUSION_EXISTS, _hDlg);
      SetFocus(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT));
      return;
   }

   // Is the name subordinate to an existing exclusion. If so, report error.
   //
   if (_FTInfo.IsNameTLNExChild(strExclusion))
   {
      ErrMsg(IDS_ERR_EXCLUSION_CHILD, _hDlg);
      SetFocus(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT));
      return;
   }

   if (!_FTInfo.AddNewExclusion(strExclusion, index))
   {
      ReportError(E_OUTOFMEMORY, 0, _hDlg);
      EndDialog(_hDlg, E_OUTOFMEMORY);
      return;
   }

   //
   // Send the index of the new exclusion record back to the TLN edit dialog
   // so it can be added to the list.
   //
   _pEditDlg->SetNewExclusionIndex(index);

   EndDialog(_hDlg, IDOK);
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CExcludeTLNDialog::OnHelp(LPHELPINFO pHelpInfo)
{
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

    return 0;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\trustwiz.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Domains and Trust
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       trustwiz.cxx
//
//  Contents:   Domain trust creation wizard.
//
//  History:    04-Aug-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "dlgbase.h"
#include "trust.h"
#include "trustwiz.h"
#include "chklist.h"
#include <lmerr.h>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CNewTrustWizard
//
//  Purpose:   New trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

CNewTrustWizard::CNewTrustWizard(CDsDomainTrustsPage * pTrustPage) :
   _hTitleFont(NULL),
   _pTrustPage(pTrustPage),
   _fBacktracking(FALSE),
   _fHaveBacktracked(FALSE),
   _fIsForestRoot(false),
   _hr(S_OK),
   _fHelpInited(false),
   _dwHelpCookie(0)
{
   MakeBigFont();
}

CNewTrustWizard::~CNewTrustWizard()
{
   for (PAGELIST::iterator i = _PageList.begin(); i != _PageList.end(); ++i)
   {
      delete *i;
   }
   if (_fHelpInited)
   {
      HtmlHelp(NULL, NULL, HH_UNINITIALIZE, _dwHelpCookie);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::AddPage
//
//  Synopsis:  Add a page to the wizard. 
//
//-----------------------------------------------------------------------------
BOOL
CNewTrustWizard::AddPage(CTrustWizPageBase * pPage)
{
   if (pPage)
   {
      _PageList.push_back(pPage);
   }
   else
   {
      return FALSE;
   }
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CreatePages
//
//  Synopsis:  Create the pages of the wizard. 
//
//-----------------------------------------------------------------------------
HRESULT
CNewTrustWizard::CreatePages(void)
{
   TRACER(CNewTrustWizard,CreatePages);

   // Intro page must be first!
   if (!AddPage(new CTrustWizIntroPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizNamePage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizPwMatchPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizCredPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizMitOrWinPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizTransitivityPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizExternOrForestPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizDirectionPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizBiDiPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizSelectionsPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizStatusPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizVerifyOutboundPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizVerifyInboundPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizSuffixesPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizDoneOKPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizDoneVerErrPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizFailurePage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizAlreadyExistsPage(this))) return E_OUTOFMEMORY;

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::LaunchModalWiz
//
//  Synopsis:  Create the wizard.
//
//-----------------------------------------------------------------------------
HRESULT
CNewTrustWizard::LaunchModalWiz(void)
{
   TRACER(CNewTrustWizard,LaunchModalWiz);

   size_t nPages = _PageList.size();
   HPROPSHEETPAGE * rgHPSP = new HPROPSHEETPAGE[nPages];
   CHECK_NULL(rgHPSP, return E_OUTOFMEMORY);
   memset(rgHPSP, 0, sizeof(HPROPSHEETPAGE) * nPages);

   BOOL fDeletePages = FALSE;
   int j = 0;
   for (PAGELIST::iterator i = _PageList.begin(); i != _PageList.end(); ++i, ++j)
   {
      if ((rgHPSP[j] = (*i)->Create()) == NULL)
      {
         fDeletePages = TRUE;
      }
   }

   PROPSHEETHEADER psh = {0};
   HRESULT hr = S_OK;

   psh.dwSize     = sizeof(PROPSHEETHEADER);
   psh.dwFlags    = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
   psh.hwndParent = _pTrustPage->m_pPage->GetHWnd();
   psh.hInstance  = g_hInstance;
   psh.nPages     = static_cast<UINT>(nPages);
   psh.phpage     = rgHPSP;

   HDC hDC = GetDC(NULL);
   BOOL fHiRes = GetDeviceCaps(hDC, BITSPIXEL) >= 8;
   ReleaseDC(NULL, hDC);

   psh.pszbmWatermark = fHiRes ? MAKEINTRESOURCE(IDB_TW_WATER256) :
                                 MAKEINTRESOURCE(IDB_TW_WATER16);
   psh.pszbmHeader    = fHiRes ? MAKEINTRESOURCE(IDB_TW_BANNER256) :
                                 MAKEINTRESOURCE(IDB_TW_BANNER16);
   if (PropertySheet(&psh) < 0)
   {
      dspDebugOut((DEB_ITRACE, "PropertySheet returned failure\n"));
      hr = HRESULT_FROM_WIN32(GetLastError());
      fDeletePages = TRUE;
   }

   if (fDeletePages)
   {
      // Couldn't create all of the pages or the wizard, so clean up.
      //
      for (size_t i = 0; i < nPages; i++)
      {
         if (rgHPSP[i])
         {
            DestroyPropertySheetPage(rgHPSP[i]);
         }
      }
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::MakeBigFont
//
//  Synopsis:  Create the font for the title of the intro and completion pages.
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::MakeBigFont(void)
{
   NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	LOGFONT TitleLogFont = ncm.lfMessageFont;
	TitleLogFont.lfWeight = FW_BOLD;
	lstrcpy(TitleLogFont.lfFaceName, TEXT("Verdana Bold"));

	HDC hdc = GetDC(NULL);
	INT FontSize = 12;
	TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
	_hTitleFont = CreateFontIndirect(&TitleLogFont);
	ReleaseDC(NULL, hdc);
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::SetNextPageID
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::SetNextPageID(CTrustWizPageBase * pPage, int iNextPageID)
{
   if (iNextPageID != -1)
   {
      dspAssert(pPage);

      if (pPage)
      {
         _PageIdStack.push(pPage->GetDlgResID());
      }
   }

   _fBacktracking = false;
   SetWindowLongPtr(pPage->GetPageHwnd(), DWLP_MSGRESULT, iNextPageID);
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::BackTrack
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::BackTrack(HWND hPage)
{
   int topPage = -1;

   _fHaveBacktracked = _fBacktracking = true;

   dspAssert(_PageIdStack.size());

   if (_PageIdStack.size())
   {
      topPage = _PageIdStack.top();

      dspAssert(topPage > 0);

      _PageIdStack.pop();
   }

   SetWindowLongPtr(hPage, DWLP_MSGRESULT, static_cast<LONG_PTR>(topPage));
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::GetPage
//
//  Synopsis:  Find the page that has this dialog resource ID and return the
//             page object pointer.
//
//-----------------------------------------------------------------------------
CTrustWizPageBase *
CNewTrustWizard::GetPage(unsigned uDlgResId)
{
   for (PAGELIST::iterator i= _PageList.begin(); i != _PageList.end(); ++i)
   {
      if ((*i)->GetDlgResID() == uDlgResId)
      {
         return *i;
      }
   }

   return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::ShowStatus
//
//  Synopsis:  Place the details of the trust into the edit control.
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::ShowStatus(CStrW & strMsg, bool fNewTrust)
{
   CStrW strItem;

   if (fNewTrust)
   {
      // Intro string.
      //
      strMsg.LoadString(g_hInstance,
                        (VerifyTrust.IsVerified()) ? IDS_TW_VERIFIED_OK : IDS_TW_CREATED_OK);
      strMsg += g_wzCRLF;
   }

   // Trust partner name.
   //
   strItem.LoadString(g_hInstance, IDS_TW_SPECIFIED_DOMAIN);
   strItem += OtherDomain.GetUserEnteredName();

   strMsg += strItem;
   int nTransID = Trust.IsExternal() ? IDS_WZ_TRANS_NO : IDS_WZ_TRANS_YES;

   DWORD dwAttr = fNewTrust ? Trust.GetNewTrustAttr() : Trust.GetTrustAttr();

   if (TRUST_TYPE_MIT == Trust.GetTrustType())
   {
      strMsg += g_wzCRLF;
      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, IDS_TW_TRUST_TYPE_PREFIX);
      strMsg += strItem;
      strItem.LoadString(g_hInstance, IDS_REL_MIT);
      strMsg += strItem;
      nTransID = (dwAttr & TRUST_ATTRIBUTE_NON_TRANSITIVE) ?
                     IDS_WZ_TRANS_NO : IDS_WZ_TRANS_YES;
   }

   // Direction
   //
   strMsg += g_wzCRLF;
   strMsg += g_wzCRLF;
   strItem.LoadString(g_hInstance, IDS_TW_DIRECTION_PREFIX);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   strItem.LoadString(g_hInstance,
                      Trust.GetTrustDirStrID(fNewTrust ?
                                             Trust.GetNewTrustDirection() :
                                             Trust.GetTrustDirection()));
   strMsg += strItem;

   // Trust Attributes
   if (dwAttr & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
   {
      strMsg += g_wzCRLF;
      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, IDS_TW_ATTR_XFOREST);
      strMsg += strItem;
      nTransID = IDS_WZ_TRANS_YES;
   }

   // Transitivity:
   // external is always non-transitive, cross-forest and intra-forest always
   // transitive, and realm (MIT) can be either.
   //
   strMsg += g_wzCRLF;
   strMsg += g_wzCRLF;
   strItem.LoadString(g_hInstance, nTransID);
   strMsg += strItem;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::InitHelp
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::InitHelp(void)
{
   if (!_fHelpInited)
   {
      dspDebugOut((DEB_TRACE, "Initializing HtmlHelp\n"));
      HtmlHelp(NULL, NULL, HH_INITIALIZE, (DWORD_PTR)&_dwHelpCookie);
      _fHelpInited = true;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CWizError::SetErrorString2Hr
//
//  Synopsis:  Formats an error message for the error page and puts it in the
//             second page string/edit control. nID defaults to zero to use a
//             generic formatting string.
//
//-----------------------------------------------------------------------------
void
CWizError::SetErrorString2Hr(HRESULT hr, int nID)
{
   PWSTR pwz = NULL;
   if (!nID)
   {
      nID = IDS_FMT_STRING_ERROR_MSG;
   }
   LoadErrorMessage(hr, nID, &pwz);
   if (!pwz)
   {
      nID = IDS_FMT_STRING_ERROR_MSG;
      return;
   }
   size_t cch = wcslen(pwz);
   if (2 > cch)
   {
      delete [] pwz;
      pwz = L"memory allocation failure";
   }
   else
   {
      if (L'\r' == pwz[cch - 3])
      {
         // Remove the trailing CR/LF.
         //
         pwz[cch - 3] = L'\'';
         pwz[cch - 2] = L'\0';
      }
   }
   _strError2 = pwz;
   delete [] pwz;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizPageBase
//
//  Purpose:   Common base class for wizard pages.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

CTrustWizPageBase::CTrustWizPageBase(CNewTrustWizard * pWiz,
                                     UINT uDlgID,
                                     UINT uTitleID,
                                     UINT uSubTitleID,
                                     BOOL fExteriorPage) :
   _hPage(NULL),
   _uDlgID(uDlgID),
   _uTitleID(uTitleID),
   _uSubTitleID(uSubTitleID),
   _fExteriorPage(fExteriorPage),
   _pWiz(pWiz),
   _dwWizButtons(PSWIZB_BACK),
   _fInInit(FALSE)
{
}

CTrustWizPageBase::~CTrustWizPageBase()
{
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::Create
//
//  Synopsis:  Create a wizard page. 
//
//-----------------------------------------------------------------------------
HPROPSHEETPAGE
CTrustWizPageBase::Create(void)
{
   PROPSHEETPAGE psp = {0};

   psp.dwSize      = sizeof(PROPSHEETPAGE);
   psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE; // | PSP_USECALLBACK;
   if (_fExteriorPage)
   {
      psp.dwFlags |= PSP_HIDEHEADER;
   }
   else
   {
      psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
      psp.pszHeaderTitle    = MAKEINTRESOURCE(_uTitleID);
      psp.pszHeaderSubTitle = MAKEINTRESOURCE(_uSubTitleID);
   }
   psp.pszTitle    = MAKEINTRESOURCE(IDS_TW_TITLE);
   psp.pszTemplate = MAKEINTRESOURCE(_uDlgID);
   psp.pfnDlgProc  = (DLGPROC)CTrustWizPageBase::StaticDlgProc;
   psp.lParam      = reinterpret_cast<LPARAM>(this);
   psp.hInstance   = g_hInstance;

   HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);

   if (!hpsp)
   {
      dspDebugOut((DEB_ITRACE, "Failed to create page with template ID of %d\n",
                   _uDlgID));
      return NULL;
   }

   return hpsp;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::StaticDlgProc
//
//  Synopsis:  static dialog proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CTrustWizPageBase::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTrustWizPageBase * pPage = (CTrustWizPageBase *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pPage = (CTrustWizPageBase *) ppsp->lParam;
        pPage->_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);
    }

    if (NULL != pPage) // && (SUCCEEDED(pPage->_hrInit)))
    {
        return pPage->PageProc(hDlg, uMsg, wParam, lParam);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::PageProc
//
//  Synopsis:  Instance-specific page window procedure. 
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizPageBase::PageProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   BOOL fRet;

   switch (uMsg)
   {
   case WM_INITDIALOG:
      _fInInit = TRUE;
      fRet = OnInitDialog(lParam);
      _fInInit = FALSE;
      return fRet;

   case WM_COMMAND:
      if (_fInInit)
      {
         return TRUE;
      }
      return OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                       GET_WM_COMMAND_HWND(wParam, lParam),
                       GET_WM_COMMAND_CMD(wParam, lParam));

   case WM_NOTIFY:
      {
         NMHDR * pNmHdr = reinterpret_cast<NMHDR *>(lParam);

         switch (pNmHdr->code)
         {
         case PSN_SETACTIVE:
            OnSetActive();
            break;

         case PSN_WIZBACK:
            OnWizBack();
            // to change default page order, call SetWindowLong the DWL_MSGRESULT value
            // set to the new page's dialog box resource ID and return TRUE.
            break;

         case PSN_WIZNEXT:
            OnWizNext();
            // to change default page order, call SetWindowLong the DWL_MSGRESULT value
            // set to the new page's dialog box resource ID and return TRUE.
            break;

         case PSN_WIZFINISH: // Finish button pressed.
            OnWizFinish();
            break;

         case PSN_RESET:     // Cancel button pressed.
            // can be ignored unless cleanup is needed.
            dspDebugOut((DEB_ITRACE, "WM_NOTIFY code = PSN_RESET\n"));
            OnWizReset();
            break;
         }
      }
      return TRUE;

   case WM_DESTROY:
      // Cleanup goes here...
      OnDestroy();
      return TRUE;

   default:
      break;
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::OnWizBack
//
//-----------------------------------------------------------------------------
void
CTrustWizPageBase::OnWizBack(void)
{
   Wiz()->BackTrack(_hPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::OnWizNext
//
//-----------------------------------------------------------------------------
void
CTrustWizPageBase::OnWizNext(void)
{
   Wiz()->SetNextPageID(this, Validate());
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::ShowHelp
//
//-----------------------------------------------------------------------------
void
CTrustWizPageBase::ShowHelp(PCWSTR pwzHelpFile)
{
   TRACER(CTrustWizPageBase,ShowHelp);
   CStrW strHelpPath;

   PWSTR pwz = strHelpPath.GetBufferSetLength(MAX_PATH + MAX_PATH);

   GetWindowsDirectory(pwz, MAX_PATH + MAX_PATH);

   if (strHelpPath.IsEmpty())
   {
      dspAssert(false);
      return;
   }

   strHelpPath.GetBufferSetLength((int)wcslen(pwz));

   HWND hHelp;

   Wiz()->InitHelp();

   strHelpPath += L"\\help\\";

   strHelpPath += pwzHelpFile;

   dspDebugOut((DEB_ITRACE, "Help topic is: %ws\n", strHelpPath.GetBuffer(0)));

   hHelp =
   HtmlHelp(_hPage,
            strHelpPath,
            HH_DISPLAY_TOPIC,
            NULL);

   if (!hHelp)
   {
      dspDebugOut((DEB_TRACE, "HtmlHelp returns %d\n", GetLastError()));
   }
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizIntroPage
//
//  Purpose:   Intro page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizIntroPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizIntroPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizIntroPage,OnInitDialog);

   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_TITLE);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizIntroPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizIntroPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (IDC_HELP_BTN == id && BN_CLICKED == codeNotify)
   {
      ShowHelp(L"ADConcepts.chm::/ADHelpNewTrustIntro.htm");
      return true;
   }
   return false;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizNamePage
//
//  Purpose:   Name and pw page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizNamePage::CTrustWizNamePage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_NAME_PAGE, IDS_TW_NAME_TITLE,
                     IDS_TW_NAME_SUBTITLE)
{
   TRACER(CTrustWizNamePage,CTrustWizNamePage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizNamePage::OnInitDialog(LPARAM lParam)
{
   SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT, EM_LIMITTEXT, MAX_PATH, 0);
   SendDlgItemMessage(_hPage, IDC_PW1_EDIT, EM_LIMITTEXT, MAX_PATH, 0);
   SendDlgItemMessage(_hPage, IDC_PW2_EDIT, EM_LIMITTEXT, MAX_PATH, 0);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizNamePage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (IDC_DOMAIN_EDIT == id && EN_CHANGE == codeNotify)
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizNamePage::OnSetActive(void)
{
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizNamePage::Validate(void)
{
   TRACER(CTrustWizNamePage,Validate);
   WCHAR wzRemoteDomain[MAX_PATH + 1];
   WCHAR wzPW[MAX_PATH + 1] = TEXT(""), wzPW2[MAX_PATH + 1];
   UINT cchPW1, cchPW2;
   CWaitCursor Wait;

   Trust().Clear();

   //
   // Read the name of the remote domain.
   //
   GetDlgItemText(_hPage, IDC_DOMAIN_EDIT, wzRemoteDomain, MAX_PATH);

   //
   // Save the Name.
   //

   OtherDomain().SetUserEnteredName(wzRemoteDomain);

   //
   // Read the passwords and verify that they match. If they don't match,
   // go to the reenter-passwords page.
   //

   cchPW1 = GetDlgItemText(_hPage, IDC_PW1_EDIT, wzPW, MAX_PATH);

   cchPW2 = GetDlgItemText(_hPage, IDC_PW2_EDIT, wzPW2, MAX_PATH);

   if (cchPW1 == 0 || cchPW2 == 0)
   {
      if (cchPW1 != cchPW2)
      {
         return IDD_TRUSTWIZ_PW_MATCH_PAGE;
      }
   }
   else
   {
      if (wcscmp(wzPW, wzPW2) != 0)
      {
         return IDD_TRUSTWIZ_PW_MATCH_PAGE;
      }
   }

   //
   // Save the PW.
   //

   Trust().SetTrustPW(wzPW);

   // 
   // Contact the domain, read its naming info, and continue with the trust
   // creation/modification.
   //

   return Wiz()->CollectInfo();
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizPwMatchPage
//
//  Purpose:   Trust passwords entered don't match page for trust wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizPwMatchPage::CTrustWizPwMatchPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_PW_MATCH_PAGE, IDS_TW_PWMATCH_TITLE,
                     IDS_TW_PWMATCH_SUBTITLE)
{
   TRACER(CTrustWizPwMatchPage, CTrustWizPwMatchPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizPwMatchPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizPwMatchPage, OnInitDialog)
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizPwMatchPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if ((IDC_PW1_EDIT == id || IDC_PW2_EDIT == id) &&
       EN_CHANGE == codeNotify)
   {
      BOOL fPW1Entered = SendDlgItemMessage(_hPage, IDC_PW1_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      BOOL fPW2Entered = SendDlgItemMessage(_hPage, IDC_PW2_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fPW1Entered && fPW2Entered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizPwMatchPage::OnSetActive(void)
{
   TRACER(CTrustWizPwMatchPage, OnSetActive)
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizPwMatchPage::Validate(void)
{
   WCHAR wzPW[MAX_PATH + 1] = TEXT(""), wzPW2[MAX_PATH + 1];
   UINT cchPW1, cchPW2;

   //
   // Read the passwords and verify that they match.
   //

   cchPW1 = GetDlgItemText(_hPage, IDC_PW1_EDIT, wzPW, MAX_PATH);

   cchPW2 = GetDlgItemText(_hPage, IDC_PW2_EDIT, wzPW2, MAX_PATH);

   if (cchPW1 == 0 || cchPW2 == 0)
   {
      if (cchPW1 != cchPW2)
      {
         SetFocus(GetDlgItem(_hPage, IDC_PW1_EDIT));
         return -1;
      }
   }
   else
   {
      if (wcscmp(wzPW, wzPW2) != 0)
      {
         SetFocus(GetDlgItem(_hPage, IDC_PW1_EDIT));
         return -1;
      }
   }

   //
   // Save the PW.
   //

   Trust().SetTrustPW(wzPW);

   //
   // Update the edit controls on the name page in case the user backtracks
   // to there.
   //

   CTrustWizPageBase * pPage = Wiz()->GetPage(IDD_TRUSTWIZ_NAME_PAGE);

   dspAssert(pPage);

   HWND hNamePage = pPage->GetPageHwnd();

   SetDlgItemText(hNamePage, IDC_PW1_EDIT, wzPW);
   SetDlgItemText(hNamePage, IDC_PW2_EDIT, wzPW);

   // 
   // Contact the domain and read its naming info.
   //

   return Wiz()->CollectInfo();
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizCredPage
//
//  Purpose:   Credentials specification page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizCredPage::CTrustWizCredPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_CREDS_PAGE, IDS_TW_CREDS_TITLE,
                     IDS_TW_CREDS_SUBTITLE_OTHER)
{
   TRACER(CTrustWizCredPage, CTrustWizCredPage);
   CredUIInitControls();
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizCredPage::OnInitDialog(LPARAM lParam)
{
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);

   SetText();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::SetText
//
//-----------------------------------------------------------------------------
void
CTrustWizCredPage::SetText(void)
{
   PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                               PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_CREDS_PAGE),
                               CredMgr().GetSubTitle());

   SetDlgItemText(GetPageHwnd(), IDC_TW_CREDS_PROMPT, CredMgr().GetPrompt());

   SetDlgItemText(GetPageHwnd(), IDC_CRED_DOMAIN, CredMgr().GetDomainPrompt());

   const WCHAR wzEmpty[] = L"";
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETUSERNAME, 0, (LPARAM)wzEmpty);
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETPASSWORD, 0, (LPARAM)wzEmpty);

   CredMgr().ClearNewCall();

   return;
}


//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizCredPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   // don't enable the Next button unless there is text in the user name field
   //
   if (IDC_CREDMAN == id && CRN_USERNAMECHANGE == codeNotify)
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_CREDMAN,
                                             CRM_GETUSERNAMELENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizCredPage::OnSetActive(void)
{
   if (CredMgr().IsNewCall())
   {
      SetText();
   }

   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizCredPage::Validate(void)
{
   DWORD dwErr = CredMgr().SaveCreds(GetDlgItem(GetPageHwnd(), IDC_CREDMAN));

   if (ERROR_SUCCESS != dwErr)
   {
      Wiz()->SetCreationResult(HRESULT_FROM_WIN32(dwErr));
      WizErr().SetErrorString2Hr(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   // If successfull, go to the next function.

   dwErr = CredMgr().Impersonate();

   if (ERROR_SUCCESS != dwErr)
   {
      Wiz()->SetCreationResult(HRESULT_FROM_WIN32(dwErr));
      WizErr().SetErrorString2Hr(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   // Because the login uses the LOGON32_LOGON_NEW_CREDENTIALS flag, no
   // attempt is made to use the credentials until a remote resource is
   // accessed. Thus, we don't yet know if the user entered credentials are
   // valid at this point. Use LsaOpenPolicy to do a quick check.
   //
   PCWSTR pwzDC = CredMgr().IsRemote() ? OtherDomain().GetUncDcName() :
                                         TrustPage()->GetDomainDcName();
   CPolicyHandle Policy(pwzDC);

   dwErr = Policy.OpenReqAdmin();

   if (ERROR_SUCCESS != dwErr)
   {
      Wiz()->SetCreationResult(HRESULT_FROM_WIN32(dwErr));
      WizErr().SetErrorString2Hr(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   return CredMgr().InvokeNext();
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizMitOrWinPage
//
//  Purpose:   Domain not found, query for Non-Windows trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizMitOrWinPage::CTrustWizMitOrWinPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_WIN_OR_MIT_PAGE, IDS_TW_TYPE_TITLE,
                     IDS_TW_WINORMIT_SUBTITLE)
{
   TRACER(CTrustWizMitOrWinPage, CTrustWizMitOrWinPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizMitOrWinPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizMitOrWinPage, OnInitDialog);
   CStrW strFormat, strLabel;

   strFormat.LoadString(g_hInstance, IDS_TW_WIN_RADIO_LABEL);

   strLabel.Format(strFormat, OtherDomain().GetUserEnteredName());

   SetDlgItemText(_hPage, IDC_WIN_TRUST_RADIO, strLabel);
   SetDlgItemText(_hPage, IDC_DOMAIN_EDIT, OtherDomain().GetUserEnteredName());

   CheckDlgButton(_hPage, IDC_MIT_TRUST_RADIO, BST_CHECKED);

   SetFocus(GetDlgItem(_hPage, IDC_MIT_TRUST_RADIO));

   EnableWindow(GetDlgItem(_hPage, IDC_DOMAIN_EDIT), FALSE);

   return FALSE; // focus is set explicitly here.
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizMitOrWinPage::OnSetActive(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_WIN_TRUST_RADIO))
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

   }
   else
   {
      _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   }

   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

   // If the user backtracked, the user-entered domain name could have changed.
   //
   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();

      CStrW strFormat, strLabel;

      strFormat.LoadString(g_hInstance, IDS_TW_WIN_RADIO_LABEL);

      strLabel.Format(strFormat, OtherDomain().GetUserEnteredName());

      SetDlgItemText(_hPage, IDC_WIN_TRUST_RADIO, strLabel);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizMitOrWinPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   BOOL fCheckEdit = FALSE, fRet = FALSE;

   if (IDC_DOMAIN_EDIT == id && EN_CHANGE == codeNotify)
   {
      fCheckEdit = TRUE;
   }

   if ((IDC_WIN_TRUST_RADIO == id || IDC_MIT_TRUST_RADIO == id)
       && BN_CLICKED == codeNotify)
   {
      fCheckEdit = IsDlgButtonChecked(_hPage, IDC_WIN_TRUST_RADIO);

      EnableWindow(GetDlgItem(_hPage, IDC_DOMAIN_EDIT), fCheckEdit);

      if (!fCheckEdit)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;

         PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
      }

      fRet = TRUE;
   }

   if (fCheckEdit)
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      fRet = TRUE;
   }

   return fRet;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizMitOrWinPage::Validate(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_MIT_TRUST_RADIO))
   {
      Trust().SetTrustTypeRealm();

      return IDD_TRUSTWIZ_TRANSITIVITY_PAGE;
   }
   else
   {
      WCHAR wzRemoteDomain[MAX_PATH + 1];
      CWaitCursor Wait;

      Trust().Clear();

      GetDlgItemText(_hPage, IDC_DOMAIN_EDIT, wzRemoteDomain, MAX_PATH);

      OtherDomain().SetUserEnteredName(wzRemoteDomain);

      int iNextPage = Wiz()->CollectInfo();

      if (IDD_TRUSTWIZ_WIN_OR_MIT_PAGE == iNextPage)
      {
         // Only one chance to re-enter a domain name. Go to failure page.
         //
         Wiz()->SetCreationResult(E_FAIL);
         WizErr().SetErrorString1(IDS_ERR_DOMAIN_NOT_FOUND1);
         WizErr().SetErrorString2(IDS_ERR_DOMAIN_NOT_FOUND2);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      return iNextPage;
   }
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizTransitivityPage
//
//  Purpose:   Realm transitivity page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizTransitivityPage::CTrustWizTransitivityPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_TRANSITIVITY_PAGE, IDS_TW_TRANS_TITLE,
                     IDS_TW_TRANS_SUBTITLE)
{
   TRACER(CTrustWizTransitivityPage, CTrustWizTransitivityPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizTransitivityPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizTransitivityPage, OnInitDialog);
   CheckDlgButton(_hPage, IDC_TRANS_NO_RADIO, BST_CHECKED);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizTransitivityPage::OnSetActive(void)
{
   _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizTransitivityPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (IDC_HELP_BTN == id && BN_CLICKED == codeNotify)
   {
      ShowHelp(L"ADConcepts.chm::/ADHelpTransitivityOfTrust.htm");
      return true;
   }
   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizTransitivityPage::Validate(void)
{
   Trust().SetNewTrustAttr(IsDlgButtonChecked(_hPage, IDC_TRANS_NO_RADIO) ?
                           TRUST_ATTRIBUTE_NON_TRANSITIVE : 0);

   return IDD_TRUSTWIZ_DIRECTION_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizExternOrForestPage
//
//  Purpose:   Domain not found, re-enter name trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizExternOrForestPage::CTrustWizExternOrForestPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_EXTERN_OR_FOREST_PAGE, IDS_TW_TYPE_TITLE,
                     IDW_TW_EXORFOR_SUBTITLE)
{
   TRACER(CTrustWizExternOrForestPage, CTrustWizExternOrForestPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizExternOrForestPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizExternOrForestPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizExternOrForestPage, OnInitDialog);
   CheckDlgButton(_hPage, IDC_EXTERNAL_RADIO, BST_CHECKED);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizExternOrForestPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizExternOrForestPage::OnSetActive(void)
{
   _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizExternOrForestPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizExternOrForestPage::Validate(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_FOREST_RADIO))
   {
      Trust().SetMakeXForest();
   }
   return IDD_TRUSTWIZ_DIRECTION_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizDirectionPage
//
//  Purpose:   Trust direction trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizDirectionPage::CTrustWizDirectionPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_DIRECTION_PAGE, IDS_TW_DIRECTION_TITLE,
                     IDS_TW_DIRECTION_SUBTITLE)
{
   TRACER(CTrustWizDirectionPage, CTrustWizDirectionPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDirectionPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizDirectionPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizDirectionPage, OnInitDialog);

   CheckDlgButton(_hPage, IDC_TW_BIDI_RADIO, BST_CHECKED);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDirectionPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizDirectionPage::OnSetActive(void)
{
   _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDirectionPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizDirectionPage::Validate(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_TW_BIDI_RADIO))
   {
      Trust().SetNewTrustDirection(TRUST_DIRECTION_BIDIRECTIONAL);
   }
   else
   {
      if (IsDlgButtonChecked(_hPage, IDC_TW_OUTBOUND_RADIO))
      {
         Trust().SetNewTrustDirection(TRUST_DIRECTION_OUTBOUND);
      }
      else
      {
         Trust().SetNewTrustDirection(TRUST_DIRECTION_INBOUND);
      }
   }
   return IDD_TRUSTWIZ_SELECTIONS;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizBiDiPage
//
//  Purpose:   Ask to make a one way trust bidi trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizBiDiPage::CTrustWizBiDiPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_BIDI_PAGE, IDS_TW_BIDI_TITLE,
                     IDS_TW_BIDI_SUBTITLE)
{
   TRACER(CTrustWizBiDiPage, CTrustWizBiDiPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizBiDiPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizBiDiPage, OnInitDialog);

   // Set appropriate subtitle.
   //
   SetSubtitle();

   CheckDlgButton(_hPage, IDC_NO_RADIO, BST_CHECKED);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::SetSubtitle
//
//-----------------------------------------------------------------------------
void
CTrustWizBiDiPage::SetSubtitle(void)
{
   CStrW strTitle;

   if (TRUST_TYPE_MIT == Trust().GetTrustType())
   {
      strTitle.LoadString(g_hInstance, IDS_TW_BIDI_SUBTITLE_REALM);
      PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_BIDI_PAGE),
                                  strTitle.GetBuffer(0));
   }

   if (Trust().GetTrustAttr() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
   {
      strTitle.LoadString(g_hInstance, IDS_TW_BIDI_SUBTITLE_FOREST);
      PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_BIDI_PAGE),
                                  strTitle.GetBuffer(0));
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizBiDiPage::OnSetActive(void)
{
   // If the user backtracked, the trust type could have changed.
   //
   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();

      SetSubtitle();
   }

   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_BACK | PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizBiDiPage::Validate(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
   {
      Trust().SetNewTrustDirection(TRUST_DIRECTION_BIDIRECTIONAL);
      return IDD_TRUSTWIZ_SELECTIONS;
   }
   WizErr().SetErrorString1(IDS_TWERR_ALREADY_EXISTS);
   WizErr().SetErrorString2(IDS_TWERR_NO_CHANGES);
   Wiz()->SetCreationResult(E_FAIL);
   return IDD_TRUSTWIZ_FAILURE_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizSelectionsPage
//
//  Purpose:   Show the settings that will be used for the trust.
//             When called, enough information has been gathered to create
//             the trust. All of this info is in the Trust member object.
//             Display the info to the user via the Selections page and ask
//             implicitly for confirmation by requiring that the Next button
//             be pressed to have the trust created.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizSelectionsPage::CTrustWizSelectionsPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_SELECTIONS, IDS_TW_SELECTIONS_TITLE,
                     IDS_TW_SELECTIONS_SUBTITLE)
{
   TRACER(CTrustWizSelectionsPage, CTrustWizSelectionsPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizSelectionsPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizSelectionsPage, OnInitDialog);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   SetSelections();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::SetSelections
//
//-----------------------------------------------------------------------------
void
CTrustWizSelectionsPage::SetSelections(void)
{
   CStrW strMsg, strItem;

   strMsg.LoadString(g_hInstance, IDS_TW_THIS_DOMAIN);
   strMsg += TrustPage()->m_strDomainDnsName;

   strItem.LoadString(g_hInstance, IDS_TW_SPECIFIED_DOMAIN);
   strItem += OtherDomain().GetUserEnteredName();

   strMsg += g_wzCRLF;
   strMsg += strItem;

   if (TRUST_TYPE_MIT == Trust().GetTrustType())
   {
      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, IDS_TW_TRUST_TYPE_PREFIX);
      strMsg += strItem;
      strItem.LoadString(g_hInstance, IDS_REL_MIT);
      strMsg += strItem;

      strItem.LoadString(g_hInstance,
                         (Trust().GetNewTrustAttr() & TRUST_ATTRIBUTE_NON_TRANSITIVE) ?
                         IDS_WZ_TRANS_NO : IDS_WZ_TRANS_YES);
      strMsg += g_wzCRLF;
      strMsg += strItem;
   }

   if (Trust().Exists())
   {
      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, IDS_TW_SELECTION_EXISTS);
      strMsg += g_wzCRLF;
      strMsg += strItem;

      strItem.LoadString(g_hInstance, IDS_TW_DIRECTION_PREFIX);
      strMsg += g_wzCRLF;
      strMsg += strItem;
      strMsg += g_wzCRLF;

      strItem.LoadString(g_hInstance,
                         Trust().GetTrustDirStrID(Trust().GetTrustDirection()));
      strMsg += strItem;

      if (Trust().GetTrustAttr() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
      {
         strItem.LoadString(g_hInstance, IDS_TW_ATTR_XFOREST);
         strMsg += g_wzCRLF;
         strMsg += strItem;
      }

      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, IDS_TW_SEL_ACTION);
      strMsg += g_wzCRLF;
      strMsg += strItem;
   }
   
   // Trust Attributes:
   if (Trust().GetNewTrustAttr() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
   {
      strItem.LoadString(g_hInstance, IDS_TW_ATTR_XFOREST);
      strMsg += g_wzCRLF;
      strMsg += strItem;
   }

   strItem.LoadString(g_hInstance, IDS_TW_DIRECTION_PREFIX);
   strMsg += g_wzCRLF;
   strMsg += strItem;
   strMsg += g_wzCRLF;

   strItem.LoadString(g_hInstance,
                      Trust().GetTrustDirStrID(Trust().GetNewTrustDirection()));
   strMsg += strItem;

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizSelectionsPage::OnSetActive(void)
{
   // If the user backtracked, the trust settings could have changed.
   //
   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();

      SetSelections();
   }

   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_BACK | PSWIZB_NEXT);
   _fSelNeedsRemoving = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizSelectionsPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizSelectionsPage::Validate(void)
{
   // Now create/modify the trust.
   //

   int nNextPage;

   CWaitCursor Wait;
   CStrW strMsg;
   strMsg.LoadString(g_hInstance, IDS_WZ_PROGRESS_MSG);
   SetDlgItemText(_hPage, IDC_WZ_PROGRESS_MSG, strMsg);

   nNextPage = Wiz()->CreateOrUpdateTrust();

   return nNextPage;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizVerifyOutboundPage
//
//  Purpose:   Ask to confirm the new outbound trust.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizVerifyOutboundPage::CTrustWizVerifyOutboundPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_VERIFY_OUTBOUND_PAGE,
                     IDS_TW_VERIFY_OUTBOUND_TITLE,
                     IDS_TW_VERIFY_SUBTITLE)
{
   TRACER(CTrustWizVerifyOutboundPage, CTrustWizVerifyOutboundPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizVerifyOutboundPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizVerifyOutboundPage, OnInitDialog);
   CWaitCursor Wait;

   CheckDlgButton(_hPage, IDC_NO_RADIO, BST_CHECKED);

   _dwWizButtons = PSWIZB_NEXT;

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizVerifyOutboundPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizVerifyOutboundPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if ((IDC_YES_RADIO == id || IDC_NO_RADIO == id) && BN_CLICKED == codeNotify)
   {
      if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
      {
         ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_SHOW);
      }
      else
      {
         ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_HIDE);
      }
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizVerifyOutboundPage::Validate(void)
{
   CWaitCursor Wait;
   DWORD dwErr;
   int nRet = 0;

   if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
   {
      nRet = Wiz()->VerifyOutboundTrust();

      if (nRet)
      {
         return nRet;
      }

      if (Trust().GetNewTrustDirection() & TRUST_DIRECTION_INBOUND)
      {
         // Now do the inbound side.
         //
         return IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE;
      }

      if (!VerifyTrust().IsVerifiedOK())
      {
         return IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE;
      }

      if (Trust().IsXForest())
      {
         bool fCredErr = false;

         dwErr = Trust().ReadFTInfo(TrustPage()->GetDomainDcName(),
                                    OtherDomain().GetDcName(),
                                    CredMgr(), WizErr(), fCredErr);

         if (NO_ERROR != dwErr)
         {
            if (fCredErr)
            {
               // If fCredErr is true, then the return code is the error page
               // ID and the error strings have already been set.
               //
               return dwErr;
            }
            else
            {
               REPORT_ERROR_FORMAT(dwErr, IDS_ERR_READ_FTINFO, _hPage);
            }
         }

         if (Trust().ReturnFTInfo().GetCount())
         {
            // There are multiple name suffixes if the FTInfo value is non-NULL.
            //
            return IDD_TRUSTWIZ_SUFFIX_PAGE;
         }
      }
   }

   return (Trust().GetNewTrustDirection() & TRUST_DIRECTION_INBOUND) ?
            IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE : IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizVerifyInboundPage
//
//  Purpose:   Ask to confirm the new inbound trust.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizVerifyInboundPage::CTrustWizVerifyInboundPage(CNewTrustWizard * pWiz) :
   _fNeedCreds(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE,
                     IDS_TW_VERIFY_INBOUND_TITLE,
                     IDS_TW_VERIFY_SUBTITLE)
{
   TRACER(CTrustWizVerifyInboundPage, CTrustWizVerifyInboundPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizVerifyInboundPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizVerifyInboundPage, OnInitDialog);
   CWaitCursor Wait;

   CheckDlgButton(_hPage, IDC_NO_RADIO, BST_CHECKED);

   _dwWizButtons = PSWIZB_NEXT;

   // Determine if creds are needed. If local creds had been required, the
   // user would have been prompted to supply them before the trust was created.
   // Thus this check is for remote access.
   //
   // The check for inbound trust is remoted to the other domain. See
   // if we have access by trying to open the remote LSA.
   //
   CPolicyHandle Pol(OtherDomain().GetUncDcName());

   DWORD dwRet = Pol.OpenReqAdmin();

   if (ERROR_ACCESS_DENIED == dwRet)
   {
      if (CredMgr().IsRemoteSet())
      {
         dwRet = CredMgr().ImpersonateRemote();

         if (NO_ERROR == dwRet)
         {
            dwRet = Pol.OpenReqAdmin();

            if (ERROR_ACCESS_DENIED == dwRet)
            {
               // Creds aren't good enough, need to get them.
               //
               _fNeedCreds = TRUE;
            }
         }
      }
      else
      {
         _fNeedCreds = TRUE;
      }
   }

   if (_fNeedCreds)
   {
      HWND hPrompt = GetDlgItem(_hPage, IDC_TW_CREDS_PROMPT);
      FormatWindowText(hPrompt, OtherDomain().GetUserEnteredName());
      ShowWindow(hPrompt, SW_SHOW);
      EnableWindow(hPrompt, FALSE);
      HWND hCred = GetDlgItem(_hPage, IDC_CREDMAN);
      SendMessage(hCred, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
      SendMessage(hCred, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);
      ShowWindow(hCred, SW_SHOW);
      EnableWindow(hCred, FALSE);
   }
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizVerifyInboundPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizVerifyInboundPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (!_fNeedCreds)
   {
      return TRUE;
   }

   BOOL fCheckName = FALSE, fSetWizButtons = FALSE;

   if ((IDC_YES_RADIO == id || IDC_NO_RADIO == id) && BN_CLICKED == codeNotify)
   {
      fSetWizButtons = TRUE;

      if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
      {
         EnableWindow(GetDlgItem(_hPage, IDC_TW_CREDS_PROMPT), TRUE);
         EnableWindow(GetDlgItem(_hPage, IDC_CREDMAN), TRUE);

         fCheckName = TRUE;
      }
      else
      {
         EnableWindow(GetDlgItem(_hPage, IDC_TW_CREDS_PROMPT), FALSE);
         EnableWindow(GetDlgItem(_hPage, IDC_CREDMAN), FALSE);

         _dwWizButtons = PSWIZB_NEXT;
      }
   }

   if (IDC_CREDMAN == id && CRN_USERNAMECHANGE == codeNotify)
   {
      fCheckName = TRUE;
      fSetWizButtons = TRUE;
   }

   if (fCheckName)
   {
      if (SendDlgItemMessage(_hPage, IDC_CREDMAN,
                             CRM_GETUSERNAMELENGTH, 0, 0) > 0)
      {
         _dwWizButtons = PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = 0;
      }
   }

   if (fSetWizButtons)
   {
      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizVerifyInboundPage::Validate(void)
{
   CWaitCursor Wait;
   DWORD dwErr;
   int nRet = 0;

   if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
   {
      if (_fNeedCreds)
      {
         CredMgr().DoRemote();
         CredMgr().SetDomain(OtherDomain().GetUserEnteredName());

         dwErr = CredMgr().SaveCreds(GetDlgItem(GetPageHwnd(), IDC_CREDMAN));

         if (ERROR_SUCCESS != dwErr)
         {
            WizErr().SetErrorString1(IDS_ERR_CANT_VERIFY_CREDS);
            WizErr().SetErrorString2Hr(dwErr);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      nRet = Wiz()->VerifyInboundTrust();

      if (nRet)
      {
         return nRet;
      }

      if (!VerifyTrust().IsVerifiedOK())
      {
         return IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE;
      }

      if (Trust().IsXForest())
      {
         bool fCredErr = false;

         dwErr = Trust().ReadFTInfo(TrustPage()->GetDomainDcName(),
                                    OtherDomain().GetDcName(),
                                    CredMgr(), WizErr(), fCredErr);

         if (NO_ERROR != dwErr)
         {
            if (fCredErr)
            {
               // If fCredErr is true, then the return code is the error page
               // ID and the error strings have already been set.
               //
               return dwErr;
            }
            else
            {
               REPORT_ERROR_FORMAT(dwErr, IDS_ERR_READ_FTINFO, _hPage);
            }
         }

         if (Trust().ReturnFTInfo().GetCount())
         {
            // There are multiple name suffixes if the FTInfo value is non-NULL.
            //
            return IDD_TRUSTWIZ_SUFFIX_PAGE;
         }
      }
   }

   return IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizStatusPage
//
//  Purpose:   Forest trust has been created and verified, show the status.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizStatusPage::CTrustWizStatusPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_STATUS_PAGE, IDS_TW_STATUS_TITLE,
                     IDS_TW_STATUS_SUBTITLE)
{
   TRACER(CTrustWizStatusPage, CTrustWizStatusPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizStatusPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   CStrW strMsg;

   Wiz()->ShowStatus(strMsg);

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizStatusPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizStatusPage::OnSetActive(void)
{
   _fSelNeedsRemoving = TRUE;

   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizStatusPage::Validate(void)
{
   return (Trust().GetNewTrustDirection() & TRUST_DIRECTION_OUTBOUND) ?
         IDD_TRUSTWIZ_VERIFY_OUTBOUND_PAGE : IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizSuffixesPage
//
//  Purpose:   Forest name suffixes page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizSuffixesPage::CTrustWizSuffixesPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_SUFFIX_PAGE, IDS_TW_SUFFIX_TITLE,
                     IDS_TW_SUFFIX_SUBTITLE)
{
   TRACER(CTrustWizSuffixesPage, CTrustWizSuffixesPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSuffixesPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizSuffixesPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   FormatWindowText(GetDlgItem(_hPage, IDC_TW_SUFFIX_LABEL),
                    OtherDomain().GetDnsName());

   CFTInfo & FTInfo = Trust().ReturnFTInfo();

   if (!FTInfo.GetCount())
   {
      return TRUE;
   }

   HWND hChkList = GetDlgItem(_hPage, IDC_CHECK_LIST);

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return FALSE;
      }

      if (ForestTrustTopLevelName == type)
      {
         if (!FTInfo.IsConflictFlagSet(i))
         {
            CStrW strMsg;

            FTInfo.GetDnsName(i, strMsg);

            // Add a check item using the FTInfo array index as the item ID.
            // This array will not change between here and the validate
            // routine below so the indices will remain valid.
            //
            SendMessage(hChkList, CLM_ADDITEM, (WPARAM)strMsg.GetBuffer(0), i);

            // Check the check box as if the item is enabled. If the user
            // leaves it checked, it will be enabled during Validation.
            //
            CheckList_SetLParamCheck(hChkList, i, CLST_CHECKED);
         }
      }
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSuffixesPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizSuffixesPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   if (IDC_HELP_BTN == id && BN_CLICKED == codeNotify)
   {
      ShowHelp(L"ADConcepts.chm::/ADHelpRoutedNameSufx.htm");
      return true;
   }
   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSuffixesPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizSuffixesPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSuffixesPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizSuffixesPage::Validate(void)
{
   CFTInfo & FTInfo = Trust().ReturnFTInfo();

   if (!FTInfo.GetCount())
   {
      WizErr().SetErrorString1(IDS_TWERR_LOGIC);
      WizErr().SetErrorString2(IDS_TWERR_CREATED_NO_NAMES);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   HWND hChkList = GetDlgItem(_hPage, IDC_CHECK_LIST);
   BOOL fChanged = FALSE;

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return FALSE;
      }

      if (ForestTrustTopLevelName == type)
      {
         if (!FTInfo.IsConflictFlagSet(i))
         {
            // clear the disabled-new flag.
            //
            FTInfo.ClearDisableFlags(i);

            fChanged = TRUE;

            if (!CheckList_GetLParamCheck(hChkList, i))
            {
               // If not checked, make it an admin disable.
               //
               FTInfo.SetAdminDisable(i);
            }
         }
      }
   }

   if (fChanged)
   {
      DWORD dwRet;

      if (CredMgr().IsLocalSet())
      {
         dwRet = CredMgr().ImpersonateLocal();

         if (ERROR_SUCCESS != dwRet)
         {
            WizErr().SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
            WizErr().SetErrorString2Hr(dwRet);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      dwRet = Trust().WriteFTInfo(TrustPage()->GetDomainDcName());

      CredMgr().Revert();

      if (NO_ERROR != dwRet)
      {
         WizErr().SetErrorString1(IDS_ERR_CANT_SAVE);
         WizErr().SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }
   return IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizDoneOKPage
//
//  Purpose:   Completion page when there are no errors.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizDoneOKPage::CTrustWizDoneOKPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_COMPLETE_OK_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizDoneOKPage, CTrustWizDoneOKPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneOKPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizDoneOKPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   CStrW strMsg;

   Wiz()->ShowStatus(strMsg);

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   if (VerifyTrust().IsVerified())
   {
      // Trust was verified OK, so no need for the other-side warning.
      //
      ShowWindow(GetDlgItem(_hPage, IDC_WARNING_ICON), SW_HIDE);
      ShowWindow(GetDlgItem(_hPage, IDC_WARN_CREATE_STATIC), SW_HIDE);
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneOKPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizDoneOKPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneOKPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizDoneOKPage::OnSetActive(void)
{
   _fSelNeedsRemoving = TRUE;

   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizDoneVerErrPage
//
//  Purpose:   Completion page for when the verification fails.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizDoneVerErrPage::CTrustWizDoneVerErrPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizDoneVerErrPage, CTrustWizDoneVerErrPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneVerErrPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizDoneVerErrPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   CStrW strMsg, strItem;

   if (VerifyTrust().IsInboundVerified())
   {
      if (NO_ERROR != VerifyTrust().GetInboundResult())
      {
         strMsg.LoadString(g_hInstance, IDS_TW_VERIFY_ERR_INBOUND);
         strMsg += g_wzCRLF;
      }

      strMsg += VerifyTrust().GetInboundResultString();

      if (VerifyTrust().IsOutboundVerified())
      {
         strMsg += g_wzCRLF;
      }
   }

   if (VerifyTrust().IsOutboundVerified())
   {
      if (NO_ERROR != VerifyTrust().GetOutboundResult())
      {
         strItem.LoadString(g_hInstance, IDS_TW_VERIFY_ERR_OUTBOUND);
         strMsg += strItem;
         strMsg += g_wzCRLF;
      }

      strMsg += VerifyTrust().GetOutboundResultString();;
   }

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneVerErrPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizDoneVerErrPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneVerErrPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizDoneVerErrPage::OnSetActive(void)
{
   _fSelNeedsRemoving = TRUE;

   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizFailurePage
//
//  Purpose:   Failure page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizFailurePage::CTrustWizFailurePage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_FAILURE_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizFailurePage, CTrustWizFailurePage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizFailurePage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizFailurePage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_CANNOT_CONTINUE);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   if (!WizErr().GetErrorString1().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT1, WizErr().GetErrorString1());
   }
   if (!WizErr().GetErrorString2().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT2, WizErr().GetErrorString2());
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizFailurePage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizFailurePage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizAlreadyExistsPage
//
//  Purpose:   Trust already exists page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizAlreadyExistsPage::CTrustWizAlreadyExistsPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_ALREADY_EXISTS_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizAlreadyExistsPage, CTrustWizAlreadyExistsPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizAlreadyExistsPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizAlreadyExistsPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_CANNOT_CONTINUE);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   CStrW strMsg;

   Wiz()->ShowStatus(strMsg, false);

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   if (!WizErr().GetErrorString1().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT1, WizErr().GetErrorString1());
   }
   if (!WizErr().GetErrorString2().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT2, WizErr().GetErrorString2());
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizAlreadyExistsPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizAlreadyExistsPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
   _fSelNeedsRemoving = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizAlreadyExistsPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizAlreadyExistsPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CRemoteDomain
//
//  Purpose:   Obtains information about a trust partner domain.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CRemoteDomain::CRemoteDomain() :
   _fNotFound(FALSE),
   _fIsForestRoot(FALSE),
   _fUplevel(TRUE),
   _hPolicy(NULL),
   _pSid(NULL)
{
}

CRemoteDomain::~CRemoteDomain()
{
   if (_hPolicy)
   {
      LsaClose(_hPolicy);
   }
   if (_pSid)
   {
      delete [] _pSid;
   }
}

//+----------------------------------------------------------------------------
//
// Method:     CRemoteDomain::DiscoverDC
//
// Synopsis:   Get a DC for the remote domain.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CRemoteDomain::DiscoverDC(BOOL fPdcRequired)
{
   TRACE(CRemoteDomain, DiscoverDC);
   PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
   ULONG ulDcFlags = DS_WRITABLE_REQUIRED;
   DWORD dwErr;

   if (_strUserEnteredName.IsEmpty())
   {
      dspAssert(FALSE && "_strUserEnteredName is empty!");
      return E_FAIL;
   }

   if (fPdcRequired)
   {
       ulDcFlags = DS_PDC_REQUIRED;
   }

   // First, get a DC name.
   //
   dwErr = DsGetDcNameW(NULL, _strUserEnteredName, NULL, NULL, ulDcFlags, &pDCInfo);

   if (dwErr != ERROR_SUCCESS)
   {
      dspDebugOut((DEB_ERROR, "DsGetDcName failed with error 0x%08x\n", dwErr));

      if ((ERROR_NO_SUCH_DOMAIN == dwErr) ||
          (ERROR_NETWORK_UNREACHABLE == dwErr) ||
          (ERROR_BAD_NETPATH == dwErr))
      {
         _fNotFound = TRUE;
         return S_OK;
      }
      else
      {
         return HRESULT_FROM_WIN32(dwErr);
      }
   }

   _strUncDC = pDCInfo->DomainControllerName;

   dspDebugOut((DEB_ITRACE, "DC: %ws\n", (LPCWSTR)_strUncDC));

   if (_strUncDC.IsEmpty())
   {
      NetApiBufferFree(pDCInfo);
      return E_OUTOFMEMORY;
   }

   _fNotFound = FALSE;

   NetApiBufferFree(pDCInfo);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
// Method:     CRemoteDomain::OpenLsaPolicy
//
// Synopsis:   Get an LSA Policy handle for the remote domain.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CRemoteDomain::OpenLsaPolicy(CCredMgr & CredMgr, BOOL fAllAccess)
{
   TRACE(CRemoteDomain, OpenLsaPolicy);
   DWORD dwErr;
   NTSTATUS Status = STATUS_SUCCESS;
   UNICODE_STRING Server;
   OBJECT_ATTRIBUTES ObjectAttributes;
   ACCESS_MASK AccessDesired = POLICY_VIEW_LOCAL_INFORMATION;

   if (_strUncDC.IsEmpty())
   {
      dspAssert(FALSE && "DC not set!");
      return E_FAIL;
   }

   RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

   RtlInitUnicodeString(&Server, _strUncDC);

   if (fAllAccess)
   {
      AccessDesired |= POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET;
   }

   Status = LsaOpenPolicy(&Server,
                          &ObjectAttributes,
                          AccessDesired,
                          &_hPolicy);

   if (STATUS_ACCESS_DENIED == Status && !fAllAccess)
   {
      // Not asking for all access, so use an anonymous token and try again.
      //
      dwErr = CredMgr.ImpersonateAnonymous();
                                
      if (dwErr != ERROR_SUCCESS)
      {
         dspDebugOut((DEB_ERROR,
                      "CRemoteDomain::OpenLsaPolicy: unable to impersonate anonymous, error %d\n",
                      dwErr));
         return HRESULT_FROM_WIN32(dwErr);
      }

      Status = LsaOpenPolicy(&Server,
                             &ObjectAttributes,
                             AccessDesired,
                             &_hPolicy);
   }

   if (!NT_SUCCESS(Status))
   {
      dspDebugOut((DEB_ERROR,
                   "CRemoteDomain::GetInfo: LsaOpenPolicy failed, error 0x%08x\n",
                   Status));
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
// Method:     CRemoteDomain::ReadDomainInfo
//
// Synopsis:   Get the domain information for the remote domain.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CRemoteDomain::ReadDomainInfo(void)
{
   TRACE(CRemoteDomain, ReadDomainInfo);
   NTSTATUS Status = STATUS_SUCCESS;
   PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo = NULL;

   if (!_hPolicy)
   {
      dspAssert(FALSE && "_hPolicy not set!");
      return E_FAIL;
   }

   Status = LsaQueryInformationPolicy(_hPolicy,
                                      PolicyDnsDomainInformation,
                                      (PVOID *)&pDnsDomainInfo);
   
   if (Status == RPC_S_PROCNUM_OUT_OF_RANGE ||
       Status == RPC_NT_PROCNUM_OUT_OF_RANGE)
   {
      // This is a downlevel DC.
      //
      PPOLICY_PRIMARY_DOMAIN_INFO pDownlevelDomainInfo;

      Status = LsaQueryInformationPolicy(_hPolicy,
                                         PolicyPrimaryDomainInformation,
                                         (PVOID *)&pDownlevelDomainInfo);
      if (!NT_SUCCESS(Status))
      {
         dspDebugOut((DEB_ERROR,
                      "CRemoteDomain::GetInfo: LsaQueryInformationPolicy for downlevel domain failed, error 0x%08x\n",
                      Status));
         return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
      }

      dspAssert(pDownlevelDomainInfo);

      _fUplevel = FALSE; // TRUST_TYPE_DOWNLEVEL;

      _strDomainFlatName = _strDomainDnsName = pDownlevelDomainInfo->Name.Buffer;
      SetSid(pDownlevelDomainInfo->Sid);
      dspDebugOut((DEB_ITRACE, "Downlevel domain: %ws\n", _strDomainFlatName));
   }
   else
   {
      // TRUST_TYPE_UPLEVEL
      dspAssert(pDnsDomainInfo);

      _strDomainDnsName = pDnsDomainInfo->DnsDomainName.Buffer;
      _strDomainFlatName = pDnsDomainInfo->Name.Buffer;
      SetSid(pDnsDomainInfo->Sid);
      dspDebugOut((DEB_ITRACE, "DNS name: %ws, flat name: %ws\n", (LPCWSTR)_strDomainDnsName, (LPCWSTR)_strDomainFlatName));
      _strForestName = pDnsDomainInfo->DnsForestName.Buffer;
      _fIsForestRoot = _wcsicmp(_strDomainDnsName, pDnsDomainInfo->DnsForestName.Buffer) == 0;
   }

   if (!NT_SUCCESS(Status))
   {
      dspDebugOut((DEB_ERROR,
                   "CRemoteDomain::GetInfo: LsaQueryInformationPolicy failed, error 0x%08x\n",
                   Status));
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
// Method:     CRemoteDomain::IsForestRoot
//
// Synopsis:   Get the forest information for the remote domain to find out if
//             the remote domain is the forest root.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CRemoteDomain::IsForestRoot(bool * pfRoot)
{
   TRACER(CRemoteDomain,IsForestRoot);

   if (_strDomainDnsName.IsEmpty())
   {
      dspAssert(FALSE && "No DNS domain name!");
      *pfRoot = false;
      return E_FAIL;
   }

   if (!_fIsForestRoot)
   {
      // If not the forest root, return false.
      //
      dspDebugOut((DEB_ITRACE, "\tnot forest root.\n"));
      *pfRoot = false;
      return S_OK;
   }

   *pfRoot = true;

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CRemoteDomain::SetSid
//
//-----------------------------------------------------------------------------
BOOL
CRemoteDomain::SetSid(PSID pSid)
{
   if (_pSid)
   {
      delete [] _pSid;
      _pSid = NULL;
   }
   int cb = GetLengthSid(pSid);
   dspAssert(cb);
   _pSid = new BYTE[cb];
   CHECK_NULL(_pSid, return FALSE);
   memcpy(_pSid, pSid, cb);
   return TRUE;
}

//LSA_HANDLE
//CRemoteDomain::OpenLsaPolicy(void)
//{
//}

void
CRemoteDomain::CloseLsaPolicy(void)
{
   if (_hPolicy)
   {
      LsaClose(_hPolicy);
      _hPolicy = NULL;
   }
}

void
CRemoteDomain::Clear(void)
{
   _strUserEnteredName.Empty();
   _strDomainFlatName.Empty();
   _strDomainDnsName.Empty();
   _strUncDC.Empty();
   _fNotFound = FALSE;
   _fIsForestRoot = FALSE;
   _fUplevel = TRUE;
   CloseLsaPolicy();
   if (_pSid)
   {
      delete [] _pSid;
      _pSid = NULL;
   }
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\trust.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.h
//
//  Contents:   DS domain trust page and Trusted-Domain object header
//
//  Classes:    CTrustPropPageBase, CDsDomainTrustsPage, CDsTrustedDomainPage
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __TRUST_H__
#define __TRUST_H__

#include "dlgbase.h"

#define XFOREST_TEST_REG_CHECK

extern "C" {

//taken from netlibnt.h; resides in netapi32.dll

NTSTATUS NetpApiStatusToNtStatus(NET_API_STATUS NetStatus);

}

const WCHAR DSPROP_DC_ADMIN_SHARE[] = L"\\IPC$";

typedef struct _TD_DOM_INFO {
    LSA_HANDLE Policy;
    PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO pDownlevelDomainInfo;
    PWSTR pwzUncDcName;
    PWSTR pwzDomainName; // used for an MIT trusted domain or an orphaned trust.
    ULONG ulTrustType;
} TD_DOM_INFO, *PTD_DOM_INFO;

typedef enum {
    TRUST_REL_ROOT,
    TRUST_REL_PARENT,
    TRUST_REL_CHILD,
    TRUST_REL_CROSSLINK,
    TRUST_REL_EXTERNAL,
    TRUST_REL_FOREST,
    TRUST_REL_INDIRECT,
    TRUST_REL_SELF,
    TRUST_REL_MIT,
    TRUST_REL_DCE,
    TRUST_REL_UNKNOWN
} TRUST_RELATION;

typedef enum _TLN_EDIT_STATUS {
   Enabled,
   Enabled_Exceptions,
   Disabled,
   Disabled_Exceptions
} TLN_EDIT_STATUS;

#define TRUST_TYPE_NO_DC    0xffffffff

//+----------------------------------------------------------------------------
//
//  Class:      CEnumDomainTrustItem
//
//  Purpose:    Holds information about a trust returned by the trust
//              enumeration.
//
//-----------------------------------------------------------------------------
class CEnumDomainTrustItem
{
public:
    CEnumDomainTrustItem() : ulFlags(0), ulTrustType(0), ulTrustAttrs(0),
                     ulParentIndex((ULONG)(-1)), ulOriginalIndex((ULONG)(-1)),
                     nRelationship(TRUST_REL_UNKNOWN) {};

    ~CEnumDomainTrustItem() {};

    ULONG               ulFlags;
    ULONG               ulTrustType;
    ULONG               ulTrustAttrs;
    ULONG               ulParentIndex;
    ULONG               ulOriginalIndex;
    TRUST_RELATION      nRelationship;
    CStrW               strTDOpath;
    CStrW               strDNSname;
    CStrW               strFlatName;
};

typedef CEnumDomainTrustItem * PCEnumDomainTrustItem;

typedef enum {
    REMOVE_TRUST_INBOUND,
    REMOVE_TRUST_OUTBOUND
} TRUST_OP;

const int IDX_DOMNAME_COL = 0;
const int IDX_RELATION_COL = 1;
const int IDX_TRANSITIVE_COL = 2;
const int IDX_ROUTING_COL = 3;

HRESULT
CreateDomTrustPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                   PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                   DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                   HPROPSHEETPAGE * phPage);

INT_PTR CALLBACK CredPromptProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

class CNewTrustWizard;

//+----------------------------------------------------------------------------
//
//  Class:     CallMember and its derivatives
//
//  Purpose:   Allows a page to indicate what the next step of the creation
//             process should be. It is an abstraction of the process of passing
//             a function pointer.
//
//-----------------------------------------------------------------------------
class CallMember
{
public:
   CallMember(CNewTrustWizard * pWiz) {_pWiz = pWiz;};
   virtual ~CallMember() {};

   virtual HRESULT Invoke(void) = 0;

protected:
   CNewTrustWizard * _pWiz;
};

//+----------------------------------------------------------------------------
//
//  Class:     CCreds
//
//  Purpose:   Stores credentials and does the needed impersonation/reverting.
//
//-----------------------------------------------------------------------------
class CCreds
{
   friend INT_PTR CALLBACK CredPromptProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
public:
   CCreds(void) : _cbPW(0), _fImpersonating(FALSE), _hToken(NULL), _fSet(FALSE) {};
   ~CCreds(void) {Revert(); Clear();};

   int   PromptForCreds(PCWSTR pwzDomain, HWND hParent);
   DWORD SetUserAndPW(PCWSTR pwzUser, PCWSTR pwzPW, PCWSTR pwzDomain = NULL);
   void  Clear(void);
   DWORD Impersonate(void);
   void  Revert(void);
   BOOL  IsSet(void) {return _fSet;};

private:
   CStrW    _strUser;
   CStrW    _strDomain;
   CStrW    _strPW;
   ULONG    _cbPW;
   HANDLE   _hToken;
   BOOL     _fImpersonating;
   BOOL     _fSet;

   // not implemented to disallow copying.
   CCreds(const CCreds&);
   const CCreds& operator=(const CCreds&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CCredMgr
//
//  Purpose:   Manages the credentials for both the local domain and the
//             remote domain. 
//             Allows a page to set information about the impersonation that is
//             needed and where to go after it is successfully made.
//
//  Options:   - local or other domain prompt
//             - domain name in prompt
//             - user or admin creds prompt
//             - next function/page
//
//-----------------------------------------------------------------------------
class CCredMgr
{
public:
   CCredMgr() : _fRemote(TRUE), _fAdmin(TRUE), _fImpersonatingAnonymous(FALSE),
                _pNextFcn(NULL), _fNewCall(FALSE) {};
   ~CCredMgr() {if (_pNextFcn) delete _pNextFcn;};

   void   DoRemote(BOOL fRemote = TRUE) {_fRemote = fRemote;};
   BOOL   IsRemote(void) {return _fRemote;};
   void   SetAdmin(BOOL fAdmin = TRUE) {_fAdmin = fAdmin;};
   void   SetDomain(LPCWSTR pwzDomain) {_strDomain = pwzDomain;};
   BOOL   SetNextFcn(CallMember * pNext);
   PCWSTR GetPrompt(void);
   PCWSTR GetDomainPrompt(void);
   PCWSTR GetSubTitle(void);
   int    InvokeNext(void);
   DWORD  SaveCreds(HWND hWndCredCtrl);
   DWORD  Impersonate(void);
   DWORD  ImpersonateLocal(void) {return _LocalCreds.Impersonate();};
   DWORD  ImpersonateRemote(void) {return _RemoteCreds.Impersonate();};
   DWORD  ImpersonateAnonymous(void);
   BOOL   IsLocalSet(void) {return _LocalCreds.IsSet();};
   BOOL   IsRemoteSet(void) {return _RemoteCreds.IsSet();};
   void   Revert(void);
   BOOL   IsNewCall(void) {return _fNewCall;};
   void   ClearNewCall(void) {_fNewCall = FALSE;};

   CCreds         _LocalCreds;
   CCreds         _RemoteCreds;

protected:
   CStrW          _strDomain;
   CStrW          _strSubTitle;
   CStrW          _strPrompt;
   CStrW          _strDomainPrompt;
   BOOL           _fRemote;
   BOOL           _fAdmin;
   BOOL           _fImpersonatingAnonymous;
   CallMember   * _pNextFcn;
   BOOL           _fNewCall;

   // not implemented to disallow copying.
   CCredMgr(const CCredMgr&);
   const CCredMgr& operator=(const CCredMgr&);
};

#define DS_TRUST_VERIFY_NEW_TRUST           1
#define DS_TRUST_VERIFY_PROMPT_FOR_CREDS    2
#define DS_TRUST_VERIFY_DOWNLEVEL           4

#define DS_TRUST_INFO_GET_PDC               1
#define DS_TRUST_INFO_ALL_ACCESS            2

//+----------------------------------------------------------------------------
//
//  Class:      CTrustPropPageBase
//
//  Purpose:    Base class for displaying/manipulating trust relationships.
//
//-----------------------------------------------------------------------------
class CTrustPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CTrustPropPageBase();
    virtual ~CTrustPropPageBase(void);

    PCWSTR  GetDnsDomainName(void) const {return m_strDomainDnsName;};
    PCWSTR  GetDomainFlatName(void) const {return m_strDomainFlatName;};
    PCWSTR  GetForestName(void) const {return m_strForestName;};
    PCWSTR  GetDomainDcName(void) const {return m_strUncDC;};

protected:
    virtual HRESULT Initialize(CDsPropPageBase * pPage);
    HRESULT QueryTrusts(void);
    void    FreeTrustData(void);
    HRESULT GetPDC(CStrW& strUncPDC);
    HRESULT GetInfoForRemoteDomain(PCWSTR DomainName, PTD_DOM_INFO Info,
                                   CCredMgr & Creds, HWND hWnd,
                                   DWORD dwFlags = 0);
    DWORD   VerifyTrustOneDirection(PCWSTR pwzTrustingDcName,
                                    PCWSTR pwzTrustingDomName,
                                    PCWSTR pwzTrustedDomName,
                                    PWSTR * ppwzTrustedDcUsed,
                                    CCreds & Creds,
                                    CWaitCursor & Wait,
                                    CStrW & strMsg,
                                    DWORD dwFlags = 0);
    //
    //  Data members
    //
   CDsPropPageBase * m_pPage;
   CStrW             m_strDomainParent;
   ULONG             m_cTrusts;
   ULONG             m_iDomain;
   CEnumDomainTrustItem * m_rgTrustList;

public:
   BOOL    IsForestRoot(void) {dspAssert(m_fIsInitialized);
                               return m_fIsForestRoot;};

   CStrW             m_strDomainFlatName;
   CStrW             m_strDomainDnsName;
   CStrW             m_strForestName;
   CStrW             m_strUncDC;

private:
   BOOL              m_fIsForestRoot;
   BOOL              m_fIsInitialized;
};

class CNewTrustWizard; // forward declaration

//+----------------------------------------------------------------------------
//
//  Class:      CDsDomainTrustsPage
//
//  Purpose:    Property page object class for the domain trusts page.
//
//-----------------------------------------------------------------------------
class CDsDomainTrustsPage : public CTrustPropPageBase, public CDsPropPageBase
{
friend CNewTrustWizard;

public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsDomainTrustsPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                       DWORD dwFlags);
    ~CDsDomainTrustsPage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnApply(void) {return PSNRET_NOERROR;};

    static INT_PTR CALLBACK AddTrustProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam);
    void    OnAddTrustClick(void);
    void    OnRemoveTrustClick(int id);
    void    OnViewTrustClick(int id);
    void    EnableButtons(UINT_PTR id, BOOL fEnable);
    HRESULT RefreshLists(void);
    void    ClearUILists(void);
    HRESULT QueryDeleteTrust(LSA_HANDLE hPolicy, PTD_DOM_INFO Remote,
                             CCreds & LocalCreds);
    BOOL    IsAllWhistler(void);

    //
    //  Data members
    //
public:
    BOOL    QualifiesForestTrust(void) {return IsForestRoot() && IsAllWhistler();};
    int     m_CtrlId;

private:
    BOOL          m_fSetAllWhistler;
    BOOL          m_fIsAllWhistler;

   // not implemented to disallow copying.
   CDsDomainTrustsPage(const CDsDomainTrustsPage&);
   const CDsDomainTrustsPage& operator=(const CDsDomainTrustsPage&);
};

VOID FreeDomainInfo(PTD_DOM_INFO Info);

NTSTATUS RemoveTrustDirection(LSA_HANDLE hPolicy, PTD_DOM_INFO Remote,
                              TRUST_OP Op, CCreds & LocalCreds);

NTSTATUS DeleteTrust(LSA_HANDLE hPolicy, PTD_DOM_INFO Remote);

class CDsForestNameRoutingPage;

//+----------------------------------------------------------------------------
//
//  Class:      CDsTrustedDomainPage
//
//  Purpose:    Class for the Trusted-Domain object general page.
//
//-----------------------------------------------------------------------------
class CDsTrustedDomainPage : public CTrustPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsTrustedDomainPage(void);
    ~CDsTrustedDomainPage(void);

    inline  HRESULT Initialize(CDsPropPageBase * pPage);
    HRESULT ForestTrustPage(BOOL fReadOnly);
    PCWSTR  GetTrustPartnerDnsName(void) const {return m_pwzTrustedDomDnsName;};
    PCWSTR  GetTrustPartnerFlatName(void) const {return m_pwzTrustedDomFlatName;};
    HRESULT TrustType(int nType, CStrW& strType);
    TRUST_RELATION TrustRelation(void) {return m_nRelationship;};
    BOOL    IsParentChild(void) {return m_nRelationship == TRUST_REL_PARENT ||
                                        m_nRelationship == TRUST_REL_CHILD;};
    void    SetTrustAttrs(ULONG ulTrustAttrs) {m_ulTrustAttrs = ulTrustAttrs;};
    BOOL    SetFlatName(PWSTR pwzFlatName);
    BOOL    SetDnsName(PWSTR pwzDnsName);
    void    TrustDirection(int nDirection, CStrW& strDirection);
    int     OnVerifyTrustBtn(void);
    void    OnSaveFTInfoBtn(void);
    BOOL    CantVerify(void) {return TRUST_REL_DCE == m_nRelationship ||
                                     TRUST_REL_MIT == m_nRelationship;};
    BOOL    IsMIT(void) {return TRUST_REL_MIT == m_nRelationship;};
    BOOL    IsNonTransitive(void)
                        {return TRUST_REL_EXTERNAL == m_nRelationship ||
                                m_ulTrustAttrs & TRUST_ATTRIBUTE_NON_TRANSITIVE;};
    HRESULT SetTransitive(BOOL fTransitive);
    BOOL    IsForestTrust(void) {return TRUST_REL_FOREST == m_nRelationship;};
    HRESULT ResetTrust(void);
#if DBG == 1 // TRUSTBREAK
    VOID    BreakTrust(void);
#endif

private:
    TRUST_RELATION      m_nRelationship;
    ULONG               m_ulTrustType;
    ULONG               m_ulTrustAttrs;
    ULONG               m_nTrustDirection;
    PWSTR               m_pwzTrustedDomFlatName;
    PWSTR               m_pwzTrustedDomDnsName;
    CDsForestNameRoutingPage * _pForestNamePage;
    CCredMgr            _Creds;

   // not implemented to disallow copying.
   CDsTrustedDomainPage(const CDsTrustedDomainPage&);
   const CDsTrustedDomainPage& operator=(const CDsTrustedDomainPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CVerifyInboundDlg
//
//  Purpose:   Dialog box to ask if the user wants to verify the inbound trust.
//
//-----------------------------------------------------------------------------
class CVerifyInboundDlg : public CModalDialog
{
public:
   CVerifyInboundDlg(HWND hParent,
                     CCreds & Creds,
                     PCWSTR pwzTrustingDomain) :
            _Creds(Creds),
            _pwzTrustingDomain(pwzTrustingDomain),
            _nMsgID(IDC_MSG),
            CModalDialog(hParent, IDD_VERIFY_INBOUND) {};
   ~CVerifyInboundDlg(void) {};

protected:
   CVerifyInboundDlg(HWND hParent,
                     CCreds & Creds,
                     PCWSTR pwzTrustingDomain,
                     int nMsgID,
                     int nTemplate) :
            _Creds(Creds),
            _pwzTrustingDomain(pwzTrustingDomain),
            _nMsgID(nMsgID),
            CModalDialog(hParent, nTemplate) {};

   LRESULT OnInitDialog(LPARAM lParam);

   CCreds & _Creds;
   PCWSTR   _pwzTrustingDomain;
   int      _nMsgID;

private:
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   LRESULT OnHelp(LPHELPINFO pHelpInfo);

   // not implemented to disallow copying.
   CVerifyInboundDlg(const CVerifyInboundDlg&);
   const CVerifyInboundDlg& operator=(const CVerifyInboundDlg&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CVerifyResultsQueryResetDlg
//
//  Purpose:   Dialog box to present the verification failures and to prompt if
//             a password reset should be attempted.
//
//-----------------------------------------------------------------------------
class CVerifyResultsQueryResetDlg : public CVerifyInboundDlg
{
public:
   CVerifyResultsQueryResetDlg(HWND hParent,
                               CStrW & strResults,
                               CCreds & Creds,
                               PCWSTR pwzTrustingDomain) :
            _strResults(strResults),
            CVerifyInboundDlg(hParent, Creds, pwzTrustingDomain,
                              IDC_CRED_PROMPT, IDD_TRUST_RESET) {};
   ~CVerifyResultsQueryResetDlg(void) {};

private:
   LRESULT OnInitDialog(LPARAM lParam);

   CStrW  & _strResults;

   // not implemented to disallow copying.
   CVerifyResultsQueryResetDlg(const CVerifyResultsQueryResetDlg&);
   const CVerifyResultsQueryResetDlg& operator=(const CVerifyResultsQueryResetDlg&);
};

//
// Attr functions for the trusted-domain General page.
//
HRESULT
CurDomainText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp);
HRESULT
PeerDomain(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);
HRESULT
TrustType(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
          PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
          DLG_OP DlgOp);
HRESULT
TrustDirection(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);
HRESULT
TransitiveTextOrButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                       PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                       DLG_OP DlgOp);
HRESULT
TrustTransNo(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
TrustVerifyBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);
HRESULT
SaveFTInfoBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp);

#if DBG == 1 // TRUSTBREAK
HRESULT
TrustBreakBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);
#endif

//+----------------------------------------------------------------------------
//
//  Class:      CPolicyHandle
//
//  Purpose:    Class to manage a domain's LSA policy handle.
//
//  Notes:      The applicable DC name is passed in on the ctor.
//
//-----------------------------------------------------------------------------
class CPolicyHandle
{
public:
   CPolicyHandle(PCWSTR pwzDc) : m_hPolicy(NULL) { m_strUncDc = pwzDc; };
   ~CPolicyHandle() { if (m_hPolicy) LsaClose(m_hPolicy); };

   DWORD OpenNoAdmin(void) {return Open(FALSE);};
   DWORD OpenReqAdmin(void) {return Open();};
   DWORD OpenWithPrompt(CCreds & Creds, CWaitCursor & Wait,
                        PCWSTR pwzDomain, HWND hWnd);
   DWORD OpenWithAnonymous(CCredMgr & Creds);
   LSA_HANDLE Get(void) {return m_hPolicy;}
   LSA_HANDLE operator=(const CPolicyHandle& src) {return src.m_hPolicy;}
   void  Close(void) {if (m_hPolicy) LsaClose(m_hPolicy); m_hPolicy = NULL;};
   operator LSA_HANDLE () {return m_hPolicy;}

private:
   DWORD Open(BOOL fModify = TRUE);

   LSA_HANDLE m_hPolicy;
   CStrW m_strUncDc;
};

//+----------------------------------------------------------------------------
//
//  Function:  GetEnterpriseVer
//
//  Synopsis:  Checks the msDS-Behavior-Version attribute of the Partitions
//             container. If the value exists and is greater or equal to 2,
//             then the parameter boolean is set to TRUE.
//
//-----------------------------------------------------------------------------
HRESULT
GetEnterpriseVer(PCWSTR pwzDC, BOOL * pfAllWhistler);

#endif // __TRUST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\uacct.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       uacct.cxx
//
//  Contents:   CDsUserAcctPage, the class that implements the user object
//              Accounts property page, and
//              CDsUsrProfilePage for the user profile page.
//
//  History:    10-April-97 EricB created
//              11-Nov-97   EricB split profile out of account page.
//
//-----------------------------------------------------------------------------

#include "pch.h"

#include "uacct.h"
#include "proppage.h"
#include "user.h"
#include "chklist.h"
#include "icanon.h" // I_NetPathType
#include <ntsam.h>
#include <aclapi.h>
//#include <aclapip.h>
#include <seopaque.h>   // in private\inc: RtlObjectAceSid().
#include <lmerr.h>
#include <time.h>

#ifdef DSADMIN

extern ATTR_MAP LogonWkstaBtn = {IDC_LOGON_TO_BTN, FALSE, FALSE, 16,
                                  {wzUserWksta, ADS_ATTR_UPDATE,
                                   ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

extern const GUID GUID_CONTROL_UserChangePassword =
   { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};

/////////////////////////////////////////////////////////////////////
//  DllScheduleDialog()
//
//  Wrapper to call the function LogonScheduleDialog() &
//  ConnectionScheduleDialog ().
//  The wrapper will load the library loghours.dll, export
//  the function LogonScheduleDialog() or
//  ConnectionScheduleDialog () and free the library.
//
//  INTERFACE NOTES
//  This routine has EXACTLY the same interface notes
//  as LogonScheduleDialog() & ConnectionScheduleDialog ().
//
//  The function launches either ConnectionScheduleDialog () or LogonScheduleDialog ()
//  depending on the ID of the title passed in.
//
//  HISTORY
//  21-Jul-97   t-danm      Creation.
//  3-4-98		bryanwal	Modification to launch different dialogs.
//
HRESULT
DllScheduleDialog(
    HWND hwndParent,
    BYTE ** pprgbData,
    int idsTitle,
    LPCTSTR pszName,
    LPCTSTR,
    DWORD dwFlags,
    ScheduleDialogType dlgtype )
{
  ASSERT(::IsWindow(hwndParent));
  static const TCHAR szLibrary[] = _T("LogHours.dll");        // Not subject to localization

  HINSTANCE hInstance = 0;
  {
    CWaitCursor wait;
    // Load the library
    hInstance =::LoadLibrary(szLibrary);
  }

  if (hInstance == NULL)
  {
   TRACE0("Unable to load LogHours.dll.\n");
   return E_UNEXPECTED;
  }
  HRESULT hr = E_UNEXPECTED;
  typedef HRESULT (*PFnUiScheduleDialog)(HWND hwndParent, BYTE ** pprgbData, LPCTSTR pszTitle, DWORD dwFlags);
  PFnUiScheduleDialog pfn;
  switch (dlgtype)
  {
  case SchedDlg_Connection:
  pfn = (PFnUiScheduleDialog)::GetProcAddress( hInstance, "ConnectionScheduleDialogEx" );
  break;
  case SchedDlg_Replication:
  pfn = (PFnUiScheduleDialog)::GetProcAddress( hInstance, "ReplicationScheduleDialogEx" );
  break;
  case SchedDlg_Logon:
  pfn = (PFnUiScheduleDialog)::GetProcAddress( hInstance, "LogonScheduleDialogEx" );
  break;
  default:
  ASSERT (0);
  return E_FAIL;
  }
  if (pfn != NULL)
  {
    // load the dialog title
    PTSTR ptz = NULL;
    if (!LoadStringToTchar(idsTitle, &ptz))
    {
      REPORT_ERROR(E_OUTOFMEMORY, hwndParent);
      (void)::FreeLibrary(hInstance);
      return E_OUTOFMEMORY;
    }
    ASSERT( NULL != ptz );
    if (NULL == pszName)
    {
      hr = pfn(hwndParent, IN OUT pprgbData, ptz, dwFlags);
    }
    else
    {
      LPTSTR ptsz2 = NULL;
      if (!FormatMessage(
             FORMAT_MESSAGE_ALLOCATE_BUFFER |
               FORMAT_MESSAGE_ARGUMENT_ARRAY |
               FORMAT_MESSAGE_FROM_STRING,
               ptz,
               0,
               0,
               reinterpret_cast<LPTSTR>(&ptsz2),
               0,
               (va_list*)(&pszName)) )
      {
         ASSERT(FALSE);
      }
      hr = pfn(hwndParent, IN OUT pprgbData, ptsz2, dwFlags);
      LocalFree( ptsz2 );
    }

    delete ptz;
  }
  else
  {
    TRACE0("Unable to find proc address for UiScheduleDialog.\n");
  }
  (void)::FreeLibrary(hInstance);
  if (hr == S_OK)
  {
   // User clicked on OK button

  }
  return hr;
} // DllScheduleDialog()


/////////////////////////////////////////////////////////////////////
//  FIsValidUncPath()
//
//  Return TRUE if a UNC path is valid, otherwise return FALSE.
//
//  HISTORY
//  18-Aug-97   t-danm      Creation.
//
BOOL
FIsValidUncPath(
    LPCTSTR pszPath,    // IN: Path to validate
    UINT uFlags)        // IN: Validation flags
{
  ASSERT(pszPath != NULL);

  if (pszPath[0] == _T('\0'))
  {
    // Empty path
    if (uFlags & VUP_mskfAllowEmptyPath)
        return TRUE;
    return FALSE;
  }

  DWORD dwPathType = 0;
  DWORD dwErr = ::I_NetPathType(0, IN const_cast<TCHAR *>(pszPath), OUT &dwPathType, 0);
  if (dwErr != ERROR_SUCCESS) 
  {
    return FALSE;
  }
  if (uFlags & VUP_mskfAllowUNCPath) 
  {
    if (dwPathType & ITYPE_UNC) 
    {
      return TRUE;
    }
  } 
  else 
  {
    if (dwPathType & ITYPE_ABSOLUTE) 
    {
      return TRUE;
    }
  }
  return FALSE;
} // FIsValidUncPath()


/////////////////////////////////////////////////////////////////////
//  DSPROP_IsValidUNCPath()
//
//  Exported (UNICODE ONLY) entry point to call FIsValidUncPath()
//  for use in DS Admin
//
BOOL DSPROP_IsValidUNCPath(LPCWSTR lpszPath)
{
  if (lpszPath == NULL)
    return FALSE;
  return FIsValidUncPath(lpszPath, VUP_mskfAllowUNCPath);
}


//+----------------------------------------------------------------------------
//
//  Member:     CDsUserAcctPage::CDsUserAcctPage
//
//-----------------------------------------------------------------------------
CDsUserAcctPage::CDsUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                 HWND hNotifyObj, DWORD dwFlags) :
    m_dwUsrAcctCtrl(0),
    m_pargbLogonHours(NULL),
    m_pwzUPN(NULL),
    m_pwzSAMname(NULL),
    m_cchSAMnameCtrl(0),
    m_pSelfSid(NULL),
    m_pWorldSid(NULL),
    m_pWkstaDlg(NULL),
    m_fOrigCantChangePW(FALSE),
    m_fOrigSelfAllowChangePW(FALSE),
    m_fOrigWorldAllowChangePW(FALSE),
    m_fUACWritable(FALSE),
    m_fUPNWritable(FALSE),
    m_fSAMNameWritable(FALSE),
    m_fPwdLastSetWritable(FALSE),
    m_fAcctExpiresWritable(FALSE),
    m_fLoginHoursWritable(FALSE),
    m_fUserWkstaWritable(FALSE),
    m_fLockoutTimeWritable(FALSE),
    m_fNTSDWritable(FALSE),
    m_fSAMNameChanged(FALSE),
    m_fAcctCtrlChanged(FALSE),
    m_fAcctExpiresChanged(FALSE),
    m_fLogonHoursChanged(FALSE),
    m_fIsAdmin(FALSE),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsUserAcctPage,CDsUserAcctPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsUserAcctPage");
#endif
    m_PwdLastSet.HighPart = m_PwdLastSet.LowPart = 0;
    m_LockoutTime.HighPart = m_LockoutTime.LowPart = 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserAcctPage::~CDsUserAcctPage
//
//-----------------------------------------------------------------------------
CDsUserAcctPage::~CDsUserAcctPage()
{
  TRACE(CDsUserAcctPage,~CDsUserAcctPage);
  if (m_pargbLogonHours != NULL)
  {
    LocalFree(m_pargbLogonHours);
  }
  DO_DEL(m_pwzUPN);
  DO_DEL(m_pwzSAMname);
  if (m_pSelfSid)
  {
    FreeSid(m_pSelfSid);
  }
  if (m_pWorldSid)
  {
    FreeSid(m_pWorldSid);
  }
  DO_DEL(m_pWkstaDlg);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserAcctPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                   PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                   CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateUserAcctPage);

    CDsUserAcctPage * pPageObj = new CDsUserAcctPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsUserAcctPage::OnInitDialog(LPARAM)
{
    TRACE(CDsUserAcctPage,OnInitDialog);
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO pAttrs;
    DWORD i, cAttrs = 0, iLogonWksta, iUPN, iSAM, iLoghrs, iUAC, iLastSet,
          iExpires, iSid, iLockout, iUACComputed;
    PWSTR pwz = NULL, pwzDomain = NULL;
    CWaitCursor wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    //
    // Set edit control length limit.
    //
    SendDlgItemMessage(m_hPage, IDC_NT4_NAME_EDIT, EM_LIMITTEXT,
                       MAX_SAM_NAME_LEN, 0);
    //
    // Add the check boxes to the scrolling checkbox list.
    //
    TCHAR tzList[161];
    HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);

    // The fields that are added are dependent on the domain behavior version
    // Do not add IDS_DELEGATION_OK for Whistler or greater domains.  This
    // will be handled by the delegation page

    UINT* pIDS = 0;
    UINT arrayCount = 0;
    if (GetBasePathsInfo()->GetDomainBehaviorVersion() >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
    {
       // Whistler domain version

       static UINT rgIDSWhistler[] = {IDS_MUST_CHANGE_PW, IDS_CANT_CHANGE_PW, IDS_NO_PW_EXPIRE,
                                      IDS_CLEAR_TEXT_PW, IDS_ACCT_DISABLED, IDS_SMARTCARD_REQ,
                                      IDS_NOT_DELEGATED, IDS_DES_KEY_ONLY,
                                      IDS_DONT_REQ_PREAUTH};
       pIDS = rgIDSWhistler;
       arrayCount = ARRAYLENGTH(rgIDSWhistler);
    }
    else
    {
       // Windows 2000 domain version

       static UINT rgIDSW2K[] = {IDS_MUST_CHANGE_PW, IDS_CANT_CHANGE_PW, IDS_NO_PW_EXPIRE,
                                 IDS_CLEAR_TEXT_PW, IDS_ACCT_DISABLED, IDS_SMARTCARD_REQ,
                                 IDS_DELEGATION_OK, IDS_NOT_DELEGATED, IDS_DES_KEY_ONLY,
                                 IDS_DONT_REQ_PREAUTH};
       pIDS = rgIDSW2K;
       arrayCount = ARRAYLENGTH(rgIDSW2K);
    }

    for (i = 0; i < arrayCount; i++)
    {
        LOAD_STRING(pIDS[i], tzList, 160, return E_OUTOFMEMORY);
        SendMessage(hChkList, CLM_ADDITEM, (WPARAM)tzList, pIDS[i]);
    }

    //
    // Check which attributes are writable.
    //
    m_fUACWritable = CheckIfWritable(g_wzUserAccountControl);
    m_fUPNWritable = CheckIfWritable(wzUPN);
    m_fSAMNameWritable = CheckIfWritable(wzSAMname);
    m_fPwdLastSetWritable = CheckIfWritable(wzPwdLastSet);
    m_fAcctExpiresWritable = CheckIfWritable(wzAcctExpires);
    m_fLoginHoursWritable = CheckIfWritable(wzLogonHours);
    m_fUserWkstaWritable = CheckIfWritable(wzUserWksta);
    m_fLockoutTimeWritable = CheckIfWritable(wzLockoutTime);
    m_fNTSDWritable = CheckIfWritable(wzSecDescriptor);

    //
    // Get the attribute values.
    //
    PWSTR rgpwzAttrNames[] = {g_wzUserAccountControl, wzUserAccountControlComputed,
                              wzUPN, wzSAMname, wzPwdLastSet,
                              wzAcctExpires, wzLogonHours, wzUserWksta,
                              wzLockoutTime, g_wzObjectSID};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames,
                                       ARRAYLENGTH(rgpwzAttrNames),
                                       &pAttrs, &cAttrs);
    if (!CHECK_ADS_HR(&hr, GetHWnd()))
    {
        return hr;
    }

    CSmartWStr spwzUserDN;

    hr = SkipPrefix(GetObjPathName(), &spwzUserDN);
    CHECK_HRESULT(hr, return hr);

    iLogonWksta = iUPN = iSAM = iLoghrs = iUAC = iLastSet = iExpires = iSid = iLockout = iUACComputed = cAttrs; // set to a flag value.
    //
    // Locate the returned values.
    //
    for (i = 0; i < cAttrs; i++)
    {
        dspAssert(pAttrs[i].dwNumValues);
        dspAssert(pAttrs[i].pADsValues);

        if (_wcsicmp(pAttrs[i].pszAttrName, wzUPN) == 0)
        {
            iUPN = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzSAMname) == 0)
        {
            iSAM = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzPwdLastSet) == 0)
        {
            iLastSet = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzUserAccountControl) == 0)
        {
            iUAC = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzUserAccountControlComputed) == 0)
        {
            iUACComputed = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzAcctExpires) == 0)
        {
            iExpires = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzLogonHours) == 0)
        {
            iLoghrs = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzUserWksta) == 0)
        {
            iLogonWksta = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzObjectSID) == 0)
        {
            iSid = i;
            continue;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, wzLockoutTime) == 0)
        {
            iLockout = i;
            continue;
        }
    }

    HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);
    int idRadioButton = IDC_ACCT_NEVER_EXPIRES_RADIO;

    //
    // User Principle Name.
    //
    PWSTR pwzUsrSuffix = NULL;

    if (iUPN < cAttrs)
    {
        dspAssert(pAttrs[iUPN].pADsValues->CaseIgnoreString);
        //
        // Search for the last at-sign in case there is more than one.
        // If found, put the preceeding characters in the first edit
        // control and use the remainder to match on the suffix combo box.
        // Otherwise, put everything in the first.
        //
        if (!AllocWStr(pAttrs[iUPN].pADsValues->CaseIgnoreString, &m_pwzUPN))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return E_OUTOFMEMORY;
        }

        pwzUsrSuffix = wcsrchr(pAttrs[iUPN].pADsValues->CaseIgnoreString, L'@');

        if (pwzUsrSuffix)
        {
            *pwzUsrSuffix = L'\0';

            SetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT,
                           pAttrs[iUPN].pADsValues->CaseIgnoreString);

            *pwzUsrSuffix = L'@';
        }
        else
        {
            SetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT, m_pwzUPN);
        }
    }

    FillSuffixCombo(pwzUsrSuffix);

    //
    // SAM account name - put the downlevel domain name in the first
    // field and the SAM name in the second.
    //
    if (iSAM < cAttrs)
    {
        dspAssert(pAttrs[iSAM].pADsValues->CaseIgnoreString);

        if (!AllocWStr(pAttrs[iSAM].pADsValues->CaseIgnoreString, &m_pwzSAMname))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return E_OUTOFMEMORY;
        }

        SetDlgItemText(m_hPage, IDC_NT4_NAME_EDIT, m_pwzSAMname);

        m_cchSAMnameCtrl = wcslen(m_pwzSAMname);
    }

    hr = CrackName(spwzUserDN, &pwzDomain, GET_NT4_DOMAIN_NAME, m_hPage);

    if (FAILED(hr))
    {
        ERR_MSG(IDS_UACCT_NO_DOMAIN, m_hPage);
        SetDlgItemText(m_hPage, IDC_NT4_DOMAIN, L"");
    }
    else
    {
        pwz = new WCHAR[wcslen(pwzDomain) + 2];
        CHECK_NULL_REPORT(pwz, m_hPage, return E_OUTOFMEMORY);

        wcscpy(pwz, pwzDomain);
        wcscat(pwz, L"\\");

        SetDlgItemText(m_hPage, IDC_NT4_DOMAIN, pwz);

        if (pwz)
        {
           delete[] pwz;
           pwz = 0;
        }
        LocalFreeStringW(&pwzDomain);
    }

    //
    // Object SID. Extract the RID and check if this is a well-known security
    // principle that requires special processing.
    //
    if (iSid < cAttrs)
    {
        if (!IsValidSid(pAttrs[iSid].pADsValues->OctetString.lpValue))
        {
            ErrMsg(IDS_INVALID_SID, m_hPage);
        }
        else
        {
            PSID pSid = pAttrs[iSid].pADsValues->OctetString.lpValue;

            // find RID part of SID
            //
            PUCHAR saCount = GetSidSubAuthorityCount(pSid);
            PULONG pRid = GetSidSubAuthority(pSid, (ULONG)*saCount - 1);

            dspAssert(pRid);

            if ((*pRid == DOMAIN_USER_RID_ADMIN) ||
                (*pRid == DOMAIN_USER_RID_KRBTGT))
            {
                m_fIsAdmin = TRUE;
                //
                // Disable those operations not allowed on these accounts.
                //
                EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), FALSE);
                m_fUACWritable = FALSE;
                m_fLoginHoursWritable = FALSE;
                m_fUserWkstaWritable = FALSE;
                if (*pRid == DOMAIN_USER_RID_KRBTGT)
                {
                    m_fSAMNameWritable = FALSE;
                }
            }
        }
    }

    //
    // User Account Control flags. This is a required attribute but may not
    // be readable due to the objects ACLs and the user's token privileges.
    //
    if (iUAC < cAttrs)
    {
        BOOL fCheckedState = CLST_CHECKED;

        if (!m_fUACWritable)
        {
            fCheckedState = CLST_CHECKDISABLED;
        }

        m_dwUsrAcctCtrl = pAttrs[iUAC].pADsValues->Integer;

        if (m_dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_ACCOUNTDISABLE)
        {
            CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED)
        {
            CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_SMARTCARD_REQUIRED)
        {
            CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, CLST_DISABLED);
        }

        // The delegation checkbox is only available for pre-Whistler domains

        if (GetBasePathsInfo()->GetDomainBehaviorVersion() < DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
        {
           if (m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
           {
               CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, fCheckedState);
           }
           else if (!m_fUACWritable)
           {
               CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_DISABLED);
           }
        }

        if (m_dwUsrAcctCtrl & UF_NOT_DELEGATED)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_USE_DES_KEY_ONLY)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_DONT_REQUIRE_PREAUTH)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, CLST_DISABLED);
        }
    }
    else if (!m_fUACWritable)
    {
        CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, CLST_DISABLED);
    }

    if (iUACComputed != cAttrs)
    {
        if (pAttrs[iUACComputed].pADsValues->Integer & UF_LOCKOUT)
        {
            CheckDlgButton(m_hPage, IDC_ACCT_LOCKOUT_CHK, BST_CHECKED);
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
        }
    }
    else
    {
        if (iLockout < cAttrs) 
        {
            m_LockoutTime.HighPart = pAttrs[iLockout].pADsValues->LargeInteger.HighPart;
            m_LockoutTime.LowPart = pAttrs[iLockout].pADsValues->LargeInteger.LowPart;
            if ((m_LockoutTime.HighPart != 0) ||
                (m_LockoutTime.LowPart != 0))
            {
                CheckDlgButton(m_hPage, IDC_ACCT_LOCKOUT_CHK, BST_CHECKED);
            }
            else
            {
                EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
            }
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
        }
    }

    //
    // Account Expires.
    //
    SYSTEMTIME st,stGMT;
    BOOL fSetDefaultExpiration = FALSE;

    if (iExpires < cAttrs)
    {
        dspDebugOut((DEB_ITRACE, "Account-Expires (raw):   0x%x,%08x\n",
                     pAttrs[iExpires].pADsValues->LargeInteger.HighPart,
                     pAttrs[iExpires].pADsValues->LargeInteger.LowPart));
        ADS_LARGE_INTEGER liADsExpiresDate = pAttrs[iExpires].pADsValues->LargeInteger;

        // Zero, -1, and the third constant are all flags meaning account
        // never expires.
        //
        if (!(liADsExpiresDate.QuadPart == 0 ||
              liADsExpiresDate.QuadPart == -1 ||
              liADsExpiresDate.QuadPart == 0x7FFFFFFFFFFFFFFF))
        {
            FILETIME ftGMT;     // GMT filetime
            FILETIME ftLocal;   // Local filetime

            //Get Local Time in SYSTEMTIME format
            ftGMT.dwLowDateTime = liADsExpiresDate.LowPart;
            ftGMT.dwHighDateTime = liADsExpiresDate.HighPart;
            FileTimeToSystemTime(&ftGMT, &stGMT);
            SystemTimeToTzSpecificLocalTime(NULL, &stGMT,&st);

            //For Display Purpose reduce one day
            SystemTimeToFileTime(&st, &ftLocal );
            liADsExpiresDate.LowPart = ftLocal.dwLowDateTime;
            liADsExpiresDate.HighPart = ftLocal.dwHighDateTime;
            liADsExpiresDate.QuadPart -= DSPROP_FILETIMES_PER_DAY;
            ftLocal.dwLowDateTime = liADsExpiresDate.LowPart;
            ftLocal.dwHighDateTime = liADsExpiresDate.HighPart;
            FileTimeToSystemTime(&ftLocal, &st);


            idRadioButton = IDC_ACCT_EXPIRES_ON_RADIO;
        }
        else
        {
            fSetDefaultExpiration = TRUE;
        }
    }
    else
    {
        fSetDefaultExpiration = TRUE;
    }

    if (fSetDefaultExpiration)
    {
        LARGE_INTEGER li;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, (LPFILETIME)&li);
        //
        // The default account expiration time is 30 days from today.
        //
        li.QuadPart += DSPROP_FILETIMES_PER_MONTH;
        FILETIME ft;
        // Convert the GMT time to Local time
        FileTimeToLocalFileTime((LPFILETIME)&li, &ft);
        FileTimeToSystemTime(&ft, &st);
    }

    // Initialize datepicker to expiration date
    BOOL bRet = DateTime_SetSystemtime(hctlDateTime, GDT_VALID, &st);
    CheckDlgButton(m_hPage, idRadioButton, BST_CHECKED);
    EnableWindow(hctlDateTime, idRadioButton == IDC_ACCT_EXPIRES_ON_RADIO);

    //
    // Logon Workstations.
    //
    m_pWkstaDlg = new CLogonWkstaDlg(this);

    CHECK_NULL_REPORT(m_pWkstaDlg, m_hPage, return E_OUTOFMEMORY);

    if (iLogonWksta < cAttrs)
    {
        // User-Workstations is a comma-separated list of workstation names.
        // It is a single-valued attribute. We are using the Multi-valued
        // attribute edit dialog for updating this attribue but by setting the
        // last parameter to TRUE it will accept the the comma list.
        //
        hr = m_pWkstaDlg->Init(&LogonWkstaBtn, &pAttrs[iLogonWksta],
                               CheckIfWritable(wzUserWksta),
                               MAX_LOGON_WKSTAS, TRUE);
    }
    else
    {
        hr = m_pWkstaDlg->Init(&LogonWkstaBtn, NULL,
                               CheckIfWritable(wzUserWksta),
                               MAX_LOGON_WKSTAS, TRUE);
    }
    CHECK_HRESULT(hr, return hr);

    //
    // Logon Hours.
    //
    if (iLoghrs < cAttrs)
    {
        const ADS_OCTET_STRING * pOctetString = &pAttrs[iLoghrs].pADsValues->OctetString;

        if (pOctetString->dwLength == cbLogonHoursArrayLength)
        {
            ASSERT(m_pargbLogonHours == NULL && "Memory Leak");
            m_pargbLogonHours = (BYTE *)LocalAlloc(0, cbLogonHoursArrayLength); // Allocate 21 bytes
            if (m_pargbLogonHours != NULL)
            {
                // Copy the data into the variable
                memcpy(m_pargbLogonHours, pOctetString->lpValue, cbLogonHoursArrayLength);
            }
        }
        else
        {
            dspDebugOut((DEB_ERROR, "Illegal length for logonHours attribute. cbExpected=%d, cbReturned=%d.\n",
                        cbLogonHoursArrayLength, pOctetString->dwLength));
        }
    }

    //
    // User Can't change password.
    //
    // Allocate Self and World (Everyone) SIDs.
    //
    {
        SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                                 WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
        if (!AllocateAndInitializeSid(&NtAuth,
                                      1,
                                      SECURITY_PRINCIPAL_SELF_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &m_pSelfSid))
        {
            DBG_OUT("AllocateAndInitializeSid failed!");
            ReportError(GetLastError(), 0, m_hPage);
            return HRESULT_FROM_WIN32(GetLastError());
        }
        if (!AllocateAndInitializeSid(&WorldAuth,
                                      1,
                                      SECURITY_WORLD_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &m_pWorldSid))
        {
            DBG_OUT("AllocateAndInitializeSid failed!");
            ReportError(GetLastError(), 0, m_hPage);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Look for a change-pw deny ACE.
    //
    DWORD dwErr;
    CSimpleSecurityDescriptorHolder SDHolder;
    PACL pAcl = NULL;

    dwErr = GetNamedSecurityInfo(GetObjPathName(),
                                 SE_DS_OBJECT_ALL,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 &pAcl,
                                 NULL,
                                 &(SDHolder.m_pSD));
    switch (dwErr)
    {
    case ERROR_ACCESS_DENIED:
        //
        // If the user lacks read-access, then LDAP returns LDAP_NO_SUCH_ATTRIBUTE
        // to GetNamedSecurityInfo who then calls LdapMapErrorToWin32 which
        // returns ERROR_INVALID_PARAMETER!
        //
    case ERROR_INVALID_PARAMETER:
    case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
        dspDebugOut((DEB_ITRACE, "GetNamedSecurityInfo returned ERROR_ACCESS_DENIED...\n"));
        m_fNTSDWritable = FALSE;
        m_fOrigCantChangePW = FALSE;
        break;

    default:
        CHECK_WIN32_REPORT(dwErr, m_hPage, return HRESULT_FROM_WIN32(dwErr));
    }

    ULONG ulCount, j;
    PEXPLICIT_ACCESS rgEntries;

    dwErr = GetExplicitEntriesFromAcl(pAcl, &ulCount, &rgEntries);


    CHECK_WIN32_REPORT(dwErr, m_hPage, return HRESULT_FROM_WIN32(dwErr));

    for (j = 0; j < ulCount; j++)
    {
      if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
          (rgEntries[j].grfAccessMode == DENY_ACCESS))
      {
        OBJECTS_AND_SID * pObjectsAndSid;
        pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

        if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                        GUID_CONTROL_UserChangePassword) &&
            (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
             EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
        {
          m_fOrigCantChangePW = TRUE;
        }
      }
      else if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
               (rgEntries[j].grfAccessMode == GRANT_ACCESS))
      {
        OBJECTS_AND_SID* pObjectsAndSid;
        pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

        if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                        GUID_CONTROL_UserChangePassword))
        {
          if (EqualSid(pObjectsAndSid->pSid, m_pSelfSid))
          {
            m_fOrigSelfAllowChangePW = TRUE;
          }
          else if (EqualSid(pObjectsAndSid->pSid, m_pWorldSid))
          {
            m_fOrigWorldAllowChangePW = TRUE;
          }
        }
      }
    }

    if (ulCount)
    {
        LocalFree(rgEntries);
    }

    if (m_fOrigCantChangePW)
    {
        CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW,
                                 (!m_fNTSDWritable) ? CLST_CHECKDISABLED :
                                                      CLST_CHECKED);
    }
    else if (!m_fNTSDWritable)
    {
        CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, CLST_DISABLED);
    }

    //
    // User Must Change Password. This is flagged by a zero Last-Changed-PW
    // attribute value. This value is ignored if the Password-never-expires
    // bit is set in user account control.
    //
    if (iLastSet < cAttrs)
    {
        m_PwdLastSet.HighPart = pAttrs[iLastSet].pADsValues->LargeInteger.HighPart;
        m_PwdLastSet.LowPart = pAttrs[iLastSet].pADsValues->LargeInteger.LowPart;
        if ((pAttrs[iLastSet].pADsValues->LargeInteger.HighPart == 0) &&
            (pAttrs[iLastSet].pADsValues->LargeInteger.LowPart == 0) &&
            !(m_dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD))
        {
            CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW,
                                     (!m_fPwdLastSetWritable) ? CLST_CHECKDISABLED :
                                                                CLST_CHECKED);
        }
        else if (!m_fPwdLastSetWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, CLST_DISABLED);
        }
    }
    else if (!m_fPwdLastSetWritable)
    {
        CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, CLST_DISABLED);
    }

    //
    // Disable those controls that aren't writable.
    //
    if (!m_fUPNWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_NT5_NAME_EDIT), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_UPN_SUFFIX_COMBO), FALSE);
    }
    if (!m_fSAMNameWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_NT4_NAME_EDIT), FALSE);
    }
    if (!m_fAcctExpiresWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), FALSE);
    }
    if (!m_fLockoutTimeWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnApply(void)
{
    TRACE(CDsUserAcctPage,OnApply);
    HRESULT hr = S_OK;
    BOOL fWritePwdLastSet = FALSE;
    BOOL fUPNchanged = FALSE;
    int cchName, cchDomain;

    ADSVALUE ADsValueUPN = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoUPN = {wzUPN, ADS_ATTR_UPDATE,
                                 ADSTYPE_CASE_IGNORE_STRING, &ADsValueUPN, 1};
    ADSVALUE ADsValueSAMname = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoSAMname = {wzSAMname, ADS_ATTR_UPDATE,
                                     ADSTYPE_CASE_IGNORE_STRING, &ADsValueSAMname, 1};
    ADSVALUE ADsValueAcctCtrl = {ADSTYPE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoAcctCtrl = {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                      ADSTYPE_INTEGER, &ADsValueAcctCtrl, 1};
    ADSVALUE ADsValueAcctExpires = {ADSTYPE_LARGE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoAcctExpires = {wzAcctExpires, ADS_ATTR_UPDATE,
                                         ADSTYPE_LARGE_INTEGER,
                                         &ADsValueAcctExpires, 1};
    ADSVALUE ADsValuePwdLastSet = {ADSTYPE_LARGE_INTEGER, NULL};
    ADS_ATTR_INFO AttrInfoPwdLastSet = {wzPwdLastSet, ADS_ATTR_UPDATE,
                                       ADSTYPE_LARGE_INTEGER,
                                       &ADsValuePwdLastSet, 1};
    ADSVALUE ADsValueLogonHours = {ADSTYPE_OCTET_STRING, NULL};
    ADS_ATTR_INFO AttrInfoLogonHours = {wzLogonHours, ADS_ATTR_UPDATE,
                                        ADSTYPE_OCTET_STRING,
                                        &ADsValueLogonHours, 1};
    ADS_ATTR_INFO AttrInfoLogonWksta = {wzUserWksta, ADS_ATTR_UPDATE,
                                        ADSTYPE_CASE_IGNORE_STRING,
                                        NULL, 1};
    ADSVALUE ADsValueLockoutTime = {ADSTYPE_LARGE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoLockoutTime = {wzLockoutTime, ADS_ATTR_UPDATE,
                                         ADSTYPE_LARGE_INTEGER,
                                         &ADsValueLockoutTime, 1};
    // Array of attributes to write
    ADS_ATTR_INFO rgAttrs[9];
    DWORD cAttrs = 0;  // Number of attributes to write

    //
    // User Principle Name - concatonate the values from the name edit and
    // suffix combo controls. If the result differs from the saved value, then
    // update the attribute. If no value in the edit control, skip checking the
    // combobox as it is irrelevant.
    //
    CStr csUPN, csUPNSuffix;
    if (m_fUPNWritable)
    {
        cchName = (int)SendDlgItemMessage(m_hPage, IDC_NT5_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);
        if (cchName)
        {
            csUPN.GetBufferSetLength(cchName);
            CHECK_NULL_REPORT((LPCWSTR)csUPN, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            GetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT, (LPWSTR)(LPCWSTR)csUPN, cchName + 1);

            int iLenPreTrim = csUPN.GetLength();

            csUPN.TrimLeft();
            csUPN.TrimRight();

            //
            // Now check for illegal characters
            //
            bool bUPNChanged = false;
            int iFind = csUPN.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
            if (iFind != -1 && !csUPN.IsEmpty())
            {
              PVOID apv[1] = {(LPWSTR)(LPCWSTR)csUPN};
              if (IDYES == SuperMsgBox(m_hPage,
                                       IDS_LOGINNAME_ILLEGAL, 
                                       0, 
                                       MB_YESNO | MB_ICONWARNING,
                                       S_OK, 
                                       apv, 
                                       1,
                                       FALSE, 
                                       __FILE__, 
                                       __LINE__))
              {
                while (iFind != -1)
                {
                  csUPN.SetAt(iFind, L'_');
                  iFind = csUPN.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
                  bUPNChanged = true;
                }
              }
              else
              {
                //
                // Set the focus to the edit box and select the text
                //
                SetFocus(GetDlgItem(m_hPage, IDC_NT5_NAME_EDIT));
                SendDlgItemMessage(m_hPage, IDC_NT5_NAME_EDIT, EM_SETSEL, 0, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;
              }
            }

            if (bUPNChanged || iLenPreTrim != csUPN.GetLength())
            {
                // the length is different, it must have been trimmed. Write
                // trimmed value back to the control.
                //
                SetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT, const_cast<PWSTR>((LPCWSTR)csUPN));
            }

            int iCurSuffix;
            iCurSuffix = (int)SendDlgItemMessage(m_hPage, IDC_UPN_SUFFIX_COMBO, CB_GETCURSEL, 0, 0);
            if (iCurSuffix != CB_ERR)
            {
                cchDomain = (int)SendDlgItemMessage(m_hPage, IDC_UPN_SUFFIX_COMBO,
                                               CB_GETLBTEXTLEN, iCurSuffix, 0);
                csUPNSuffix.GetBufferSetLength(cchDomain);
                CHECK_NULL_REPORT((LPCWSTR)csUPNSuffix, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                SendDlgItemMessage(m_hPage, IDC_UPN_SUFFIX_COMBO, CB_GETLBTEXT,
                                   iCurSuffix, (LPARAM)(LPCWSTR)csUPNSuffix);
                csUPN += csUPNSuffix;
            }


        }

        if (m_pwzUPN)
        {
            if (csUPN.IsEmpty())
            {
                fUPNchanged = TRUE;
            }
            else
            {
                if (_wcsicmp(csUPN, m_pwzUPN) != 0)
                {
                    fUPNchanged = TRUE;
                }
            }
        }
        else
        {
            if (!csUPN.IsEmpty())
            {
                fUPNchanged = TRUE;
            }
        }
    }

    //
    // SAM account name. This is a required attribute, so it can't be empty.
    //
    if (!m_cchSAMnameCtrl)
    {
        ErrMsg(IDS_EMPTY_SAM_NAME, m_hPage);
        SetFocus(GetDlgItem(m_hPage, IDC_NT4_NAME_EDIT));
        return PSNRET_INVALID_NOCHANGEPAGE;
    }
    CStr csNewSamName;
    csNewSamName.GetBufferSetLength(static_cast<int>(m_cchSAMnameCtrl));
    CHECK_NULL_REPORT((LPCWSTR)csNewSamName, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

    GetDlgItemText(m_hPage, IDC_NT4_NAME_EDIT, (PWSTR)(LPCWSTR)csNewSamName,
                   static_cast<int>(m_cchSAMnameCtrl + 1));

    int iLenBeforeTrim = csNewSamName.GetLength();

    csNewSamName.TrimLeft();
    csNewSamName.TrimRight();

    //
    // Now check for illegal characters
    //
    bool bSAMChanged = false;
    int iFind = csNewSamName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS_WITH_AT);
    if (iFind != -1 && !csNewSamName.IsEmpty())
    {
      PVOID apv[1] = {(LPWSTR)(LPCWSTR)csNewSamName};
      if (IDYES == SuperMsgBox(m_hPage,
                               IDS_SAMNAME_ILLEGAL, 
                               0, 
                               MB_YESNO | MB_ICONWARNING,
                               S_OK, 
                               apv, 
                               1,
                               FALSE, 
                               __FILE__, 
                               __LINE__))
      {
        while (iFind != -1)
        {
          csNewSamName.SetAt(iFind, L'_');
          iFind = csNewSamName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS_WITH_AT);
          bSAMChanged = true;
        }
      }
      else
      {
        //
        // Set the focus to the edit box and select the text
        //
        SetFocus(GetDlgItem(m_hPage, IDC_NT4_NAME_EDIT));
        SendDlgItemMessage(m_hPage, IDC_NT4_NAME_EDIT, EM_SETSEL, 0, -1);
        return PSNRET_INVALID_NOCHANGEPAGE;
      }
    }

    if (bSAMChanged || iLenBeforeTrim != csNewSamName.GetLength())
    {
        //
        // Since we modified the name set it back into the control
        //
        SetDlgItemText(m_hPage, IDC_NT4_NAME_EDIT, const_cast<PWSTR>((LPCWSTR)csNewSamName));
    }

    dspAssert(m_pwzSAMname);

    if (m_pwzSAMname && (wcscmp(m_pwzSAMname, csNewSamName) != 0))
    {
        m_fSAMNameChanged = TRUE;
    }

    if(m_fLockoutTimeWritable)
    {
        if (!IsDlgButtonChecked(m_hPage, IDC_ACCT_LOCKOUT_CHK) &&
            ((m_LockoutTime.HighPart != 0) || (m_LockoutTime.LowPart != 0)))
        {
            ADsValueLockoutTime.LargeInteger.LowPart = 0;
            ADsValueLockoutTime.LargeInteger.HighPart = 0;
            rgAttrs[cAttrs++] = AttrInfoLockoutTime;
        }
    }

    BOOL fDelegationChanged = FALSE;
    HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);
    //
    // User-Account-Control check boxes.
    //
    if (m_fUACWritable && m_fAcctCtrlChanged)
    {
        if (CheckList_GetLParamCheck(hChkList, IDS_NO_PW_EXPIRE))
        {
            m_dwUsrAcctCtrl |= UF_DONT_EXPIRE_PASSWD;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_DONT_EXPIRE_PASSWD);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_ACCT_DISABLED))
        {
            m_dwUsrAcctCtrl |= UF_ACCOUNTDISABLE;
        }
        else
       {
            m_dwUsrAcctCtrl &= ~(UF_ACCOUNTDISABLE);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW))
        {
            m_dwUsrAcctCtrl |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_SMARTCARD_REQ))
        {
            m_dwUsrAcctCtrl |= UF_SMARTCARD_REQUIRED;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_SMARTCARD_REQUIRED);
        }

        // The delegation checkbox is only available for pre-Whistler domains

        if (GetBasePathsInfo()->GetDomainBehaviorVersion() < DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
        {
           if (CheckList_GetLParamCheck(hChkList, IDS_DELEGATION_OK))
           {
               if (!(m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION))
               {
                   m_dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
                   fDelegationChanged = TRUE;
               }
           }
           else
           {
               if (m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
               {
                   m_dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
                   fDelegationChanged = TRUE;
               }
           }
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_NOT_DELEGATED))
        {
            m_dwUsrAcctCtrl |= UF_NOT_DELEGATED;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_NOT_DELEGATED);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_DES_KEY_ONLY))
        {
            m_dwUsrAcctCtrl |= UF_USE_DES_KEY_ONLY;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_USE_DES_KEY_ONLY);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH))
        {
            m_dwUsrAcctCtrl |= UF_DONT_REQUIRE_PREAUTH;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_DONT_REQUIRE_PREAUTH);
        }

        ADsValueAcctCtrl.Integer = m_dwUsrAcctCtrl;
        rgAttrs[cAttrs++] = AttrInfoAcctCtrl;
    }

    //
    // Account Expires
    //
    if (m_fAcctExpiresWritable && m_fAcctExpiresChanged)
    {
        ADsValueAcctExpires.LargeInteger.LowPart = 0;
        ADsValueAcctExpires.LargeInteger.HighPart = 0;
        if (IsDlgButtonChecked(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO) == BST_CHECKED)
        {
            // Get the expire date from the control
            HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);
            SYSTEMTIME st;   // Local time in a human-readable format
            LRESULT lResult = DateTime_GetSystemtime(hctlDateTime, &st);
            dspAssert(lResult == GDT_VALID); // The control should always have a valid time
            // Zero the time part of the struct.
            st.wHour = st.wMinute = st.wSecond = st.wMilliseconds = 0;
            FILETIME ftLocal;   // Local filetime
            FILETIME ftGMT;     // GMT filetime
            // Convert the human-readable time to a cryptic local filetime format
            SystemTimeToFileTime(&st, &ftLocal);
            //
            // Add a day since it expires at the beginning of the next day.
            //
            ADS_LARGE_INTEGER liADsExpiresDate;
            liADsExpiresDate.LowPart = ftLocal.dwLowDateTime;
            liADsExpiresDate.HighPart = ftLocal.dwHighDateTime;
            liADsExpiresDate.QuadPart += DSPROP_FILETIMES_PER_DAY;
            ftLocal.dwLowDateTime = liADsExpiresDate.LowPart;
            ftLocal.dwHighDateTime = liADsExpiresDate.HighPart;

            FileTimeToSystemTime(&ftLocal,&st);
            //Convert time to UTC time
            SYSTEMTIME stGMT;
            TzSpecificLocalTimeToSystemTime(NULL,&st,&stGMT);
            SystemTimeToFileTime(&stGMT,&ftGMT);

            // Store the GMT time into the ADs value
            //
            ADsValueAcctExpires.LargeInteger.LowPart = ftGMT.dwLowDateTime;
            ADsValueAcctExpires.LargeInteger.HighPart = ftGMT.dwHighDateTime;
            dspDebugOut((DEB_ITRACE, "Setting Account-Expires to 0x%x,%08x\n",
                         ADsValueAcctExpires.LargeInteger.HighPart,
                         ADsValueAcctExpires.LargeInteger.LowPart));
        }
        rgAttrs[cAttrs++] = AttrInfoAcctExpires;
    }

    //
    // Validate and save UPN.
    //
    if (fUPNchanged)
    {
        if (csUPN.IsEmpty())
        {
            // clear the attribute.
            //
            AttrInfoUPN.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoUPN.dwNumValues = 0;
        }
        else
        {
            // Validate the new UPN by checking for uniqueness. That is,
            // search the GC.
            //
            CComPtr <IDirectorySearch> spDsSearch;
            CSmartWStr cswzCleanObj;
            PWSTR pwzDnsDom;

            hr = SkipPrefix(GetObjPathName(), &cswzCleanObj);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            //
            // To bind to a GC, you need to supply the domain name rather than the
            // server path because the current DC may not be hosting a GC.
            //
            hr = CrackName(cswzCleanObj, &pwzDnsDom, GET_DNS_DOMAIN_NAME, m_hPage);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            hr = DSPROP_GetGCSearchOnDomain(pwzDnsDom,
                                            IID_IDirectorySearch,
                                            (PVOID*)&spDsSearch);
            LocalFreeStringW(&pwzDnsDom);
            if (S_OK != hr)
            {
                if (S_FALSE == hr ||
                    HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) == hr)
                {
                    // GC not found, warn and skip uniqueness test
                    ErrMsg( IDS_WARN_UPN_NO_GC_FOUND, m_hPage );
                }
                else
                {
                    SuperMsgBox(GetHWnd(), 
                                IDS_WARN_UPN_GC_FOUND_ERROR, 
                                0, 
                                MB_OK |MB_ICONERROR, 
                                hr, 
                                NULL, 
                                0,
                                FALSE, 
                                __FILE__, 
                                __LINE__);
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
            }
            else
            {
                WCHAR wzSearchFormat[] = L"(userPrincipalName=%s)";

                CStr csFilter;
                csFilter.Format(wzSearchFormat, csUPN);

                ADS_SEARCH_HANDLE hSrch = NULL;
                PWSTR pwzAttrName[] = {g_wzADsPath};

                hr = spDsSearch->ExecuteSearch((PWSTR)(LPCWSTR)csFilter,
                                               pwzAttrName, 1, &hSrch);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                hr = spDsSearch->GetNextRow(hSrch);

                if (hSrch)
                {
                    spDsSearch->CloseSearchHandle(hSrch);
                }

                if (hr == S_OK)
                {
                    // If the search succeeded, then the UPN is not unique.
                    //
                    ErrMsg(IDS_ERR_UPN_NONUNIQUE, m_hPage);
                    SetFocus(GetDlgItem(m_hPage, IDC_NT5_NAME_EDIT));
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
                else
                {
                    // S_ADS_NOMORE_ROWS means no match, thus user's UPN is
                    // unique.
                    //
                    if (hr != S_ADS_NOMORE_ROWS)
                    {
                        SuperMsgBox(m_hPage, IDS_ERR_FINDING_UPN, 0,
                                    MB_ICONEXCLAMATION | MB_OK, hr, NULL, 0,
                                    TRUE, __FILE__, __LINE__);
                    }
                }
            }

            // It passed the uniqueness test, so prepare to save it.
            //
            ADsValueUPN.CaseIgnoreString = (PWSTR)(LPCWSTR)csUPN;
        }
        rgAttrs[cAttrs++] = AttrInfoUPN;
    }

    if (m_fSAMNameChanged)
    {
        ADsValueSAMname.CaseIgnoreString = (PWSTR)(LPCWSTR)csNewSamName;
        rgAttrs[cAttrs++] = AttrInfoSAMname;
    }

    if (m_pargbLogonHours != NULL && m_fLoginHoursWritable && m_fLogonHoursChanged)
    {
        ADsValueLogonHours.OctetString.dwLength = cbLogonHoursArrayLength;
        ADsValueLogonHours.OctetString.lpValue = m_pargbLogonHours;
        ASSERT(cAttrs < ARRAYLENGTH(rgAttrs));
        rgAttrs[cAttrs++] = AttrInfoLogonHours;
    }

    //
    // Get PW check box values.
    //
    BOOL fMustChangePW = CheckList_GetLParamCheck(hChkList, IDS_MUST_CHANGE_PW) == TRUE;

    BOOL fNewCantChangePW = CheckList_GetLParamCheck(hChkList, IDS_CANT_CHANGE_PW) == TRUE;

    //
    // Enforce PW combination rules.
    //
    if (fMustChangePW && fNewCantChangePW)
    {
        ErrMsg(IDS_ERR_BOTH_PW_BTNS, m_hPage);
        CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, FALSE, 1);
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    if ((m_dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD) && fMustChangePW)
    {
        ErrMsg(IDS_PASSWORD_MUTEX, m_hPage);
        CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 1);
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    //
    // User-must-change-PW.
    //
    if (m_fPwdLastSetWritable)
    {
        if (fMustChangePW)
        {
            if ((m_PwdLastSet.HighPart != 0) || (m_PwdLastSet.LowPart != 0))
            {
                ADsValuePwdLastSet.LargeInteger.LowPart = 0;
                ADsValuePwdLastSet.LargeInteger.HighPart = 0;
                fWritePwdLastSet = TRUE;
            }
        }
        else
        {
            if ((m_PwdLastSet.HighPart == 0) && (m_PwdLastSet.LowPart == 0))
            {
                ADsValuePwdLastSet.LargeInteger.LowPart = 0xffffffff;
                ADsValuePwdLastSet.LargeInteger.HighPart = 0xffffffff;
                fWritePwdLastSet = TRUE;
            }
        }
        if (fWritePwdLastSet)
        {
            AttrInfoPwdLastSet.dwNumValues = 1;
            ASSERT(cAttrs < ARRAYLENGTH(rgAttrs));
            rgAttrs[cAttrs++] = AttrInfoPwdLastSet;
        }
    }

    //
    // Logon Workstations.
    //
    if (m_pWkstaDlg && m_pWkstaDlg->IsDirty())
    {
        dspAssert(m_fUserWkstaWritable);

        hr = m_pWkstaDlg->Write(&AttrInfoLogonWksta);

        CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

        rgAttrs[cAttrs++] = AttrInfoLogonWksta;
    }

    if (!cAttrs)
    {
        return PSNRET_NOERROR;
    }

    DWORD cModified;

    //
    // Write the changes.
    //
    hr = m_pDsObj->SetObjectAttributes(rgAttrs, cAttrs, &cModified);

    if (AttrInfoLogonWksta.pADsValues)
    {
        DO_DEL(AttrInfoLogonWksta.pADsValues->CaseIgnoreString);
        delete AttrInfoLogonWksta.pADsValues;
    }
    if (FAILED(hr))
    {
        DWORD dwErr;
        WCHAR wszErrBuf[MAX_PATH+1];
        WCHAR wszNameBuf[MAX_PATH+1];
        ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

        if (dwErr)
        {
            dspDebugOut((DEB_ERROR,
                         "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                         wszErrBuf, wszNameBuf, __FILE__, __LINE__));

            if ((ERROR_PRIVILEGE_NOT_HELD == dwErr) && fDelegationChanged)
            {
               // The delegation checkbox is only available for pre-Whistler domains

               if (GetBasePathsInfo()->GetDomainBehaviorVersion() < DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS)
               {
                  // Whoda thunk that a single bit in UAC has an access check on
                  // it. Do special case error checking and reporting for the
                  // delegate bit.
                  //
                  if (m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
                  {
                     m_dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
                     CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_UNCHECKED);
                  }
                  else
                  {
                     m_dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
                     CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_CHECKED);
                  }
                  ErrMsg(IDS_ERR_CANT_DELEGATE, m_hPage);
               }
            }
            else
            {
                ReportError(dwErr, IDS_ADS_ERROR_FORMAT, m_hPage);
            }
        }
        else
        {
            dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", hr, __FILE__, __LINE__));
            ReportError(hr, IDS_ADS_ERROR_FORMAT, m_hPage);
        }
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    //
    // We must reset the member variables for user must change password
    // if the value was changed or else the apply on works an odd number
    // of times for one instance of the property page
    //
    if (m_fPwdLastSetWritable)
    {
        if (fMustChangePW)
        {
            m_PwdLastSet.HighPart = 0;
            m_PwdLastSet.LowPart = 0;
        }
        else
        {
            if ((m_PwdLastSet.HighPart == 0) && (m_PwdLastSet.LowPart == 0))
            {
                m_PwdLastSet.HighPart = 0xffffffff;
                m_PwdLastSet.LowPart = 0xffffffff;
            }
        }
    }

    if (fUPNchanged)
    {
        DO_DEL(m_pwzUPN);

        if (csUPN)
        {
            if (!AllocWStr((PWSTR)(LPCWSTR)csUPN, &m_pwzUPN))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            }
        }
    }

    //
    // User-can't change password
    //
    if ((fNewCantChangePW != m_fOrigCantChangePW) && m_fNTSDWritable)
    {
        CSimpleSecurityDescriptorHolder SDHolder;
        PACL pDacl = NULL;
        CSimpleAclHolder NewDacl;

        CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

        DWORD dwErr = GetNamedSecurityInfo(GetObjPathName(),
                                           SE_DS_OBJECT_ALL,
                                           DACL_SECURITY_INFORMATION,
                                           NULL,
                                           NULL,
                                           &pDacl,
                                           NULL,
                                           &(SDHolder.m_pSD));

        dspAssert(IsValidAcl(pDacl));
        CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

        if (fNewCantChangePW)
        {
            // Revoke the user's change password right by writing DENY ACEs.
            // Note that this can be an inherited right (which is the default
            // case), so attempting to remove GRANT ACEs is not sufficient.
            //
            OBJECTS_AND_SID rgObjectsAndSid[2] = {0};
            PEXPLICIT_ACCESS rgEntries, rgNewEntries;
            ULONG ulCount, ulNewCount = 0, j;

            dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);
            CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            
            //+2 for two deny entries
            rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, sizeof(EXPLICIT_ACCESS)*(ulCount + 2));
            CHECK_NULL_REPORT(rgNewEntries, m_hPage, LocalFree(rgEntries); return PSNRET_INVALID_NOCHANGEPAGE);

            //Remove allow ace from it if present
            for (j = 0; j < ulCount; j++)
            {
                BOOL fAllowAceFound = FALSE;

                if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                    (rgEntries[j].grfAccessMode == GRANT_ACCESS))
                {
                  OBJECTS_AND_SID * pObjectsAndSid;
                  pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

                  if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                                  GUID_CONTROL_UserChangePassword) &&
                      (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                       EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
                  {
                    fAllowAceFound = TRUE;
                  }
                }

                if (!fAllowAceFound)
                {
                  rgNewEntries[ulNewCount] = rgEntries[j];
                  ulNewCount++;
                }
            }            


            // initialize the new entries (DENY ACE's)
            //
            rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulNewCount].grfAccessMode = DENY_ACCESS;
            rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;
            // build the trustee structs for change password
            //
            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                          &(rgObjectsAndSid[0]),
                                          const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          m_pSelfSid);
            ulNewCount++;

            rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulNewCount].grfAccessMode = DENY_ACCESS;
            rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

            // build the trustee structs for change password
            //
            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                          &(rgObjectsAndSid[1]),
                                          const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          m_pWorldSid);
            ulNewCount++;



            // add the entries to the ACL
            //
            DBG_OUT("calling SetEntriesInAcl()");

            dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, NULL, &(NewDacl.m_pAcl));
            dspAssert(IsValidAcl(NewDacl.m_pAcl));
            LocalFree(rgNewEntries);
            LocalFree(rgEntries);
        }
        else
        {
            // Restore the user's change password right by removing any DENY ACEs.
            // If the GRANT ACEs are not present then we will add them back.
            // Bug #435315
            //
            ULONG ulCount, ulNewCount = 0, j;
            PEXPLICIT_ACCESS rgEntries, rgNewEntries;

            dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);

            CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            if (!ulCount)
            {
                CHECK_WIN32_REPORT(ERROR_INVALID_SECURITY_DESCR, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            }

            rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, (ulCount+2) * sizeof(EXPLICIT_ACCESS));

            CHECK_NULL_REPORT(rgNewEntries, m_hPage, LocalFree(rgEntries); return PSNRET_INVALID_NOCHANGEPAGE);
            memset(rgNewEntries, 0, (ulCount+2) * sizeof(EXPLICIT_ACCESS));

            for (j = 0; j < ulCount; j++)
            {
                BOOL fDenyAceFound = FALSE;

                if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                    (rgEntries[j].grfAccessMode == DENY_ACCESS))
                {
                  OBJECTS_AND_SID * pObjectsAndSid;
                  pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

                  if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                                  GUID_CONTROL_UserChangePassword) &&
                      (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                       EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
                  {
                    fDenyAceFound = TRUE;
                  }
                }

                if (!fDenyAceFound)
                {
                  rgNewEntries[ulNewCount] = rgEntries[j];
                  ulNewCount++;
                }
            }

            if (!m_fOrigSelfAllowChangePW)
            {
              OBJECTS_AND_SID rgObjectsAndSid = {0};
              rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
              rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
              rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

              BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                            &(rgObjectsAndSid),
                                            const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                            NULL, // inherit guid
                                            m_pSelfSid);
              ulNewCount++;
            }

            if (!m_fOrigWorldAllowChangePW)
            {
              OBJECTS_AND_SID rgObjectsAndSid = {0};
              rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
              rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
              rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

              BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                            &(rgObjectsAndSid),
                                            const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                            NULL, // inherit guid
                                            m_pWorldSid);
              ulNewCount++;
            }

            ACL EmptyAcl;
            InitializeAcl(&EmptyAcl, sizeof(ACL), ACL_REVISION_DS);

            // Create a new ACL without the DENY entries.
            //
            DBG_OUT("calling SetEntriesInAcl()");

            dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, NULL, &(NewDacl.m_pAcl));

            dspAssert(IsValidAcl(NewDacl.m_pAcl));
            LocalFree(rgEntries);
            LocalFree(rgNewEntries);
        }

        CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

        dwErr = SetNamedSecurityInfo(GetObjPathName(),
                                     SE_DS_OBJECT_ALL,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     NULL,
                                     NewDacl.m_pAcl,
                                     NULL);

        CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

        m_fOrigCantChangePW = fNewCantChangePW;
    }

    if (m_fSAMNameChanged)
    {
        DO_DEL(m_pwzSAMname);
        if (!TcharToUnicode((PWSTR)(LPCWSTR)csNewSamName, &m_pwzSAMname))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        }
    }

    if (SUCCEEDED(hr))
    {
        m_fSAMNameChanged = FALSE;
        m_fAcctCtrlChanged = FALSE;
        m_fAcctExpiresChanged = FALSE;
        m_fLogonHoursChanged = FALSE;

        if (m_pWkstaDlg && m_pWkstaDlg->IsDirty())
        {
            m_pWkstaDlg->ClearDirty();
        }
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    switch (id)
    {
    case IDC_ACCT_LOCKOUT_CHK:
        if (codeNotify == BN_CLICKED && m_cchSAMnameCtrl)
        {
            m_fAcctCtrlChanged = TRUE;
            SetDirty();
        }
        break;

    case IDC_NT5_NAME_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
        }
        break;

    case IDC_UPN_SUFFIX_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetDirty();
        }
        break;

    case IDC_NT4_NAME_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            m_cchSAMnameCtrl = (int)SendDlgItemMessage(m_hPage, IDC_NT4_NAME_EDIT,
                                                  WM_GETTEXTLENGTH, 0, 0);
            if (m_cchSAMnameCtrl == 0)
            {
                // SAM account name is a required property, so disable the
                // apply button if blank.
                //
                dspDebugOut((DEB_ITRACE, "no characters, disabling Apply.\n"));
                PropSheet_UnChanged(GetParent(m_hPage), m_hPage);
                m_fPageDirty = FALSE;
                m_fSAMNameChanged = FALSE;
            }
            else
            {
                m_fSAMNameChanged = TRUE;
                SetDirty();
            }
        }
        break;

    case IDC_LOGON_HOURS_BTN:
        if (codeNotify == BN_CLICKED)
        {
            if (m_fIsAdmin)
            {
                MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_HOURS, m_hPage);
                break;
            }

            LPCWSTR pszRDN = GetObjRDName();
            if (!m_fLoginHoursWritable)
            {
                MsgBox2(IDS_CANT_WRITE, IDS_LOGON_HOURS, m_hPage);
            }
            HRESULT hr = DllScheduleDialog(m_hPage,
                                           &m_pargbLogonHours,
                                           (NULL != pszRDN)
                                               ? IDS_s_LOGON_HOURS_FOR
                                               : IDS_LOGON_HOURS,
                                           pszRDN );
            if (hr == S_OK && m_cchSAMnameCtrl && m_fLoginHoursWritable)
            {
                m_fLogonHoursChanged = TRUE;
                SetDirty();
            }
        }
        break;

    case IDC_LOGON_TO_BTN:
        if (codeNotify == BN_CLICKED)
        {
            if (m_fIsAdmin)
            {
                MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_WKSTA, m_hPage);
                break;
            }
            if (m_pWkstaDlg && (m_pWkstaDlg->Edit() == IDOK))
            {
                if (m_pWkstaDlg->IsDirty())
                {
                    SetDirty();
                }
            }
        }
        break;

    case IDC_ACCT_NEVER_EXPIRES_RADIO:
    case IDC_ACCT_EXPIRES_ON_RADIO:
        if (codeNotify == BN_CLICKED && m_cchSAMnameCtrl)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), id == IDC_ACCT_EXPIRES_ON_RADIO);
            m_fAcctExpiresChanged = TRUE;
            SetDirty();
        }
        return 1;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    NMHDR * pNmHdr = (NMHDR *)lParam;
    int codeNotify = pNmHdr->code;
    switch (wParam)
    {
    case IDC_CHECK_LIST:
        if (codeNotify == CLN_CLICK && m_cchSAMnameCtrl)
        {
            m_fAcctCtrlChanged = TRUE;
            SetDirty();
        }
        break;

    case IDC_ACCT_EXPIRES:
        dspDebugOut((DEB_ITRACE,
                     "OnNotify, id = IDC_ACCT_EXPIRES, code = 0x%x\n",
                     codeNotify));
        if (codeNotify == DTN_DATETIMECHANGE)
        {
            m_fAcctExpiresChanged = TRUE;
            SetDirty();
        }
        break;
    }
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnDestroy(void)
{
    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserAcctPage::FillSuffixCombo
//
//  Synopsis:   Put the UPN suffixes into the combo box.
//
//-----------------------------------------------------------------------------
BOOL
CDsUserAcctPage::FillSuffixCombo(LPWSTR pwzUPNdomain)
{
    HRESULT hr;
    int iCurSuffix = -1;
    PWSTR pwzDomain;
    DWORD cAttrs, i;
    CComPtr <IDirectoryObject> spOU;
    CComPtr <IADs> spIADs;
    Smart_PADS_ATTR_INFO spAttrs;

    //
    // See if there is a UPN Suffixes attribute set on the containing OU and
    // use that if found.
    //

    CComBSTR sbParentPath;

    hr = m_pDsObj->QueryInterface(IID_IADs, (PVOID *)&spIADs);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spIADs->get_Parent(&sbParentPath);
    
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = ADsOpenObject(sbParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (void **)&spOU);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    PWSTR rgAttrs[] = {L"uPNSuffixes"};

    hr = spOU->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
        return FALSE;
    }

    if (cAttrs)
    {
        dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            CStr csSuffix = L"@";
            csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

            int pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                              CB_ADDSTRING, 0,
                                              (LPARAM)(LPCTSTR)csSuffix);

            if (pwzUPNdomain && !wcscmp(csSuffix, pwzUPNdomain))
            {
                iCurSuffix = pos;
            }
        }

        if (iCurSuffix == -1 && pwzUPNdomain)
        {
            // User's UPN suffix does not match any of the defaults, so put
            // the user's into the combobox and select it.
            //
            iCurSuffix = (int)SendDlgItemMessage(GetHWnd(),
                                                 IDC_UPN_SUFFIX_COMBO,
                                                 CB_ADDSTRING, 0,
                                                 (LPARAM)pwzUPNdomain);
        }

        SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                           (iCurSuffix > -1) ? iCurSuffix : 0, 0);
        return TRUE;
    }

    //
    // No UPN suffixes on the OU, get those for the domain.
    //

    // Get the name of the user's domain.
    //
    CSmartWStr spwzUserDN;

    hr = SkipPrefix(GetObjPathName(), &spwzUserDN);

    CHECK_HRESULT(hr, return FALSE);

    CStrW strServer;

    hr = GetLdapServerName(m_pDsObj, strServer);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    // Get the name of the root domain.
    //
    CComPtr <IDsBrowseDomainTree> spDsDomains;

    hr = CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          (LPVOID*)&spDsDomains);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spDsDomains->SetComputer(strServer, NULL, NULL);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    int pos;
    CStr csRootDomain = L"@";
    PDOMAIN_TREE pDomTree = NULL;

    hr = spDsDomains->GetDomains(&pDomTree, 0);

    CHECK_HRESULT(hr,;);

    hr = CrackName(spwzUserDN, &pwzDomain, GET_DNS_DOMAIN_NAME, GetHWnd());

    CHECK_HRESULT(hr, return FALSE);

    if (pDomTree)
    {
        for (UINT index = 0; index < pDomTree->dwCount; index++)
        {
            if (pDomTree->aDomains[index].pszTrustParent == NULL)
            {
                // Add the root domain only if it is a substring of the current
                // domain.
                //
                size_t cchRoot = wcslen(pDomTree->aDomains[index].pszName);
                PWSTR pRoot = pwzDomain + wcslen(pwzDomain) - cchRoot;

                if (!_wcsicmp(pRoot, pDomTree->aDomains[index].pszName))
                {
                    csRootDomain += pDomTree->aDomains[index].pszName;

                    pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                                  CB_ADDSTRING, 0,
                                                  (LPARAM)(LPCTSTR)csRootDomain);

                    if (pwzUPNdomain && !_wcsicmp(csRootDomain, pwzUPNdomain))
                    {
                        iCurSuffix = pos;
                    }
                    break;
                }
            }
        }

        spDsDomains->FreeDomains(&pDomTree);
    }

    // If the local domain is not the root, add it as well.
    //
    CStr csLocalDomain = L"@";
    csLocalDomain += pwzDomain;

    LocalFreeStringW(&pwzDomain);

    if (_wcsicmp(csRootDomain, csLocalDomain))
    {
        pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                      CB_ADDSTRING, 0,
                                      (LPARAM)(LPCTSTR)csLocalDomain);

        if (pwzUPNdomain && !_wcsicmp(csLocalDomain, pwzUPNdomain))
        {
            iCurSuffix = pos;
        }
    }

    // Get UPN suffixes
    //
    CComBSTR bstrPartitions;
    //
    // get config path from main object
    //
    CComPtr<IADsPathname> spPathCracker;
    CDSBasePathsInfo CPaths;
    PWSTR pwzConfigPath;
    PDSDISPLAYSPECOPTIONS pDsDispSpecOptions;
    STGMEDIUM ObjMedium = {TYMED_NULL};
    FORMATETC fmte = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1,
                      TYMED_HGLOBAL};

    hr = m_pWPTDataObj->GetData(&fmte, &ObjMedium);

    if (RPC_E_SERVER_DIED_DNE == hr)
    {
        hr = CPaths.InitFromName(strServer);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

        pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();
    }
    else
    {
        CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

        pDsDispSpecOptions = (PDSDISPLAYSPECOPTIONS)ObjMedium.hGlobal;

        if (pDsDispSpecOptions->offsetServerConfigPath)
        {
            pwzConfigPath = (PWSTR)ByteOffset(pDsDispSpecOptions,
                                              pDsDispSpecOptions->offsetServerConfigPath);
        }
        else
        {
            hr = CPaths.InitFromName(strServer);

            CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

            pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();
        }
    }
    dspDebugOut((DEB_USER1, "Config path: %ws\n", pwzConfigPath));

    hr = GetADsPathname(spPathCracker);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

    hr = spPathCracker->Set(pwzConfigPath, ADS_SETTYPE_FULL);

    ReleaseStgMedium(&ObjMedium);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spPathCracker->AddLeafElement(g_wzPartitionsContainer);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);
    dspDebugOut((DEB_ITRACE, "Config path: %ws\n", bstrPartitions));

    CComPtr <IDirectoryObject> spPartitions;

    hr = ADsOpenObject(bstrPartitions, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                       IID_IDirectoryObject, (void **)&spPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    spAttrs.Empty();

    hr = spPartitions->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
        return FALSE;
    }

    if (cAttrs)
    {
        dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            CStr csSuffix = L"@";
            csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

            int suffixPos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                              CB_ADDSTRING, 0,
                                              (LPARAM)(LPCTSTR)csSuffix);

            if (pwzUPNdomain && !wcscmp(csSuffix, pwzUPNdomain))
            {
                iCurSuffix = suffixPos;
            }
        }
    }

    if (iCurSuffix == -1 && pwzUPNdomain)
    {
        // User's UPN suffix does not match any of the defaults, so put
        // the user's into the combobox and select it.
        //
        iCurSuffix = (int)SendDlgItemMessage(GetHWnd(),
                                             IDC_UPN_SUFFIX_COMBO,
                                             CB_ADDSTRING, 0,
                                             (LPARAM)pwzUPNdomain);
    }

    SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                       (iCurSuffix > -1) ? iCurSuffix : 0, 0);
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CDsUsrProfilePage::CDsUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsUsrProfilePage::CDsUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags) :
    m_ptszLocalHomeDir(NULL),
    m_ptszRemoteHomeDir(NULL),
    m_pwzSamName(NULL),
    m_nDrive(COMBO_Z_DRIVE),
    m_idHomeDirRadio(IDC_LOCAL_PATH_RADIO),
    m_fProfilePathWritable(FALSE),
    m_fScriptPathWritable(FALSE),
    m_fHomeDirWritable(FALSE),
    m_fHomeDriveWritable(FALSE),
    m_fProfilePathChanged(FALSE),
    m_fLogonScriptChanged(FALSE),
    m_fHomeDirChanged(FALSE),
    m_fHomeDriveChanged(FALSE),
    m_fSharedDirChanged(FALSE),
    m_pObjSID(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsUsrProfilePage,CDsUsrProfilePage);
#ifdef _DEBUG
    strcpy(szClass, "CDsUsrProfilePage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUsrProfilePage::~CDsUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsUsrProfilePage::~CDsUsrProfilePage()
{
    TRACE(CDsUsrProfilePage,~CDsUsrProfilePage);
    if (m_ptszLocalHomeDir)
    {
        delete m_ptszLocalHomeDir;
    }
    if (m_ptszRemoteHomeDir)
    {
        delete m_ptszRemoteHomeDir;
    }
    if (m_pwzSamName)
    {
        delete m_pwzSamName;
    }
    DO_DEL(m_pObjSID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUsrProfilePage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                     PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                     CDSBasePathsInfo* pBasePathsInfo, HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateUsrProfilePage);

    CDsUsrProfilePage * pPageObj = new CDsUsrProfilePage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsUsrProfilePage::OnInitDialog(LPARAM)
{
    TRACE(CDsUsrProfilePage,OnInitDialog);
    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD i, iHomeDir, iHomeDrive, cAttrs = 0;
    LPTSTR ptz;
    CWaitCursor wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    m_fProfilePathWritable  = CheckIfWritable(wzProfilePath);
    m_fScriptPathWritable   = CheckIfWritable(wzScriptPath);
    m_fHomeDirWritable      = CheckIfWritable(wzHomeDir);
    m_fHomeDriveWritable    = CheckIfWritable(wzHomeDrive);

    LPWSTR rgpwzAttrNames[] = {wzProfilePath, wzScriptPath, wzHomeDir,
                               wzHomeDrive, wzSAMname, g_wzObjectSID};
    //
    // Set edit control length limits.
    //
    SendDlgItemMessage(m_hPage, IDC_PROFILE_PATH_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    SendDlgItemMessage(m_hPage, IDC_LOGON_SCRIPT_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    SendDlgItemMessage(m_hPage, IDC_CONNECT_TO_PATH_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    //
    // Get the attribute values.
    //
    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames,
                                       ARRAYLENGTH(rgpwzAttrNames),
                                       &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
        return hr;
    }

    //
    // cAttrs + 1 is a flag value to indicate "not found".
    //
    iHomeDir = iHomeDrive = cAttrs + 1;

    //
    // Set the corresponding controls to the values found.
    //
    for (i = 0; i < cAttrs; i++)
    {
        dspAssert(pAttrs[i].dwNumValues);
        dspAssert(pAttrs[i].pADsValues);

        if (_wcsicmp(pAttrs[i].pszAttrName, wzProfilePath) == 0)
        {
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }

            SetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, ptz);

            delete ptz;

            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzScriptPath) == 0)
        {
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }

            SetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, ptz);

            delete ptz;

            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzHomeDir) == 0)
        {
            iHomeDir = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzHomeDrive) == 0)
        {
            iHomeDrive = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzSAMname) == 0)
        {
            if (!AllocWStr(pAttrs[i].pADsValues->CaseIgnoreString, &m_pwzSamName))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }
            continue;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzObjectSID) == 0)
        {
            if (IsValidSid(pAttrs[i].pADsValues->OctetString.lpValue))
            {
                m_pObjSID = new BYTE[pAttrs[i].pADsValues->OctetString.dwLength];

                CHECK_NULL_REPORT(m_pObjSID, m_hPage, return S_OK);

                memcpy(m_pObjSID, pAttrs[i].pADsValues->OctetString.lpValue,
                       pAttrs[i].pADsValues->OctetString.dwLength);
            }
        }
    }


    if (m_fHomeDirWritable && (m_pObjSID == NULL))
    {
        //
        // could write dir, but cannot read SID
        //
        m_fHomeDirWritable = FALSE;

        //
        // put up a warning
        //
        PWSTR pwzUserName = GetObjRDName();
        SuperMsgBox(GetHWnd(), IDS_CANT_READ_HOME_DIR_SID, 0, MB_OK |
            MB_ICONEXCLAMATION, hr, (PVOID *)&pwzUserName, 1,
            FALSE, __FILE__, __LINE__);
    }

    //
    // Fill the home drive combobox.
    //
    TCHAR szDrive[3];
    _tcscpy(szDrive, TEXT("C:"));
    for (i = 0; i <= COMBO_Z_DRIVE; i++)
    {
        szDrive[0]++;
        SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_ADDSTRING, 0,
                           (LPARAM)szDrive);
    }

    //
    // If there is a home directory set, display it.
    //
    if (iHomeDir < (cAttrs + 1))
    {
        if (!UnicodeToTchar(pAttrs[iHomeDir].pADsValues->CaseIgnoreString,
                            &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            goto ExitCleanup;
        }

        if (iHomeDrive < (cAttrs + 1))
        {
            // A home drive value implies "connect to"; choose the
            // corresponding combobox item.
            //
            dspDebugOut((DEB_ITRACE, "Home-Drive: %S\n",
                         pAttrs[iHomeDrive].pADsValues->CaseIgnoreString));

            m_idHomeDirRadio = IDC_CONNECT_TO_RADIO;

            m_ptszRemoteHomeDir = ptz;

            if (!UnicodeToTchar(pAttrs[iHomeDrive].pADsValues->CaseIgnoreString,
                                &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }

            m_nDrive = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO,
                                               CB_FINDSTRING, 0,(LPARAM)ptz);

            delete ptz;

            dspAssert(m_nDrive >= 0);

            SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                               (WPARAM)m_nDrive, 0);
            //
            // Now set the radio button and edit control.
            //
            SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                           m_ptszRemoteHomeDir);
            CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_CHECKED);

            //
            // Enable the associated controls
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), TRUE);
            EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), TRUE);
            EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), TRUE);

            //
            // Disable the local path edit box
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
        }
        else
        {
            m_idHomeDirRadio = IDC_LOCAL_PATH_RADIO;

            m_ptszLocalHomeDir = ptz;

            SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                               (WPARAM)-1, 0);
            SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, m_ptszLocalHomeDir);
            CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

            //
            // Enable the associated controls
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

            //
            // Disable to connect to controls
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
            EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
            EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
        }
    }
    else
    {
        m_idHomeDirRadio = IDC_LOCAL_PATH_RADIO;

        CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

        //
        // Enable the associated controls
        //
        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

        //
        // Disable to connect to controls
        //
        EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
    }

    if (!m_fProfilePathWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_PROFILE_PATH_EDIT), FALSE);
    }
    if (!m_fScriptPathWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_SCRIPT_EDIT), FALSE);
    }
    if (!m_fHomeDirWritable || !m_fHomeDriveWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_RADIO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_RADIO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
    }

ExitCleanup:

    if (pAttrs)
    {
        FreeADsMem(pAttrs);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnApply(void)
{
    TRACE(CDsUsrProfilePage,OnApply);
    HRESULT hr = S_OK;

    ADSVALUE ADsValueProfilePath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoProfilePath = {wzProfilePath, ADS_ATTR_UPDATE,
                                         ADSTYPE_CASE_IGNORE_STRING,
                                         &ADsValueProfilePath, 1};
    ADSVALUE ADsValueScriptPath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoScriptPath = {wzScriptPath, ADS_ATTR_UPDATE,
                                        ADSTYPE_CASE_IGNORE_STRING,
                                        &ADsValueScriptPath, 1};
    ADSVALUE ADsValueHomeDir = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoHomeDir = {wzHomeDir, ADS_ATTR_UPDATE,
                                     ADSTYPE_CASE_IGNORE_STRING,
                                     &ADsValueHomeDir};
    ADSVALUE ADsValueHomeDrive = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoHomeDrive = {wzHomeDrive, ADS_ATTR_UPDATE,
                                       ADSTYPE_CASE_IGNORE_STRING,
                                       &ADsValueHomeDrive};
    // Array of attributes to write
    ADS_ATTR_INFO rgAttrs[4];
    DWORD cAttrs = 0;
    TCHAR tsz[MAX_PATH+MAX_PATH+1];
    PTSTR ptsz;
    PWSTR pwzValue;

    //
    // Profile Path
    //

    if (m_fProfilePathWritable && m_fProfilePathChanged)
    {
        if (GetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, tsz,
                           MAX_PATH+MAX_PATH+1) == 0)
        {
            // An empty control means remove the attribute value from the object.
            //
            AttrInfoProfilePath.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoProfilePath.dwNumValues = 0;
            AttrInfoProfilePath.pADsValues = NULL;
        }
        else
        {
            if (!TcharToUnicode(tsz, &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
            }
            BOOL fExpanded;
            if (!ExpandUsername(pwzValue, fExpanded))
            {
                goto Cleanup;
            }
            if (fExpanded)
            {
                if (!UnicodeToTchar(pwzValue, &ptsz))
                {
                    CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                }
                SetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, ptsz);
                delete [] ptsz;
            }
            ADsValueProfilePath.CaseIgnoreString = pwzValue;
        }
        rgAttrs[cAttrs++] = AttrInfoProfilePath;
    }

    //
    // Logon Script
    //
    if (m_fScriptPathWritable && m_fLogonScriptChanged)
    {
        if (GetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, tsz,
                           MAX_PATH+MAX_PATH) == 0)
        {
            // An empty control means remove the attribute value from the object.
            //
            AttrInfoScriptPath.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoScriptPath.dwNumValues = 0;
            AttrInfoScriptPath.pADsValues = NULL;
        }
        else
        {
            if (!TcharToUnicode(tsz, &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
            }
            ADsValueScriptPath.CaseIgnoreString = pwzValue;
        }
        rgAttrs[cAttrs++] = AttrInfoScriptPath;
    }

    //
    // Home Directory, Drive.
    //
    int nDirCtrl;
    if (m_fHomeDirWritable && m_fHomeDriveWritable &&
        (m_fHomeDirChanged || m_fHomeDriveChanged))
    {
        LONG iSel;
        if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
        {
            nDirCtrl = IDC_LOCAL_PATH_EDIT;

            AttrInfoHomeDrive.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoHomeDrive.dwNumValues = 0;
            AttrInfoHomeDrive.pADsValues = NULL;
            rgAttrs[cAttrs++] = AttrInfoHomeDrive;
        }
        else
        {
            nDirCtrl = IDC_CONNECT_TO_PATH_EDIT;

            iSel = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_GETCURSEL, 0, 0);

            dspAssert(iSel >= 0);

            if (iSel >= 0)
            {
                GetDlgItemText(m_hPage, IDC_DRIVES_COMBO, tsz, MAX_PATH+MAX_PATH);
            }
            else
            {
                _tcscpy(tsz, TEXT("Z:"));
            }

            if (!TcharToUnicode(tsz, &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
            }

            AttrInfoHomeDrive.dwControlCode = ADS_ATTR_UPDATE;
            AttrInfoHomeDrive.dwNumValues = 1;
            AttrInfoHomeDrive.pADsValues = &ADsValueHomeDrive;
            ADsValueHomeDrive.CaseIgnoreString = pwzValue;
            rgAttrs[cAttrs++] = AttrInfoHomeDrive;
        }

        int cch;
        cch = GetDlgItemText(m_hPage, nDirCtrl, tsz, MAX_PATH+MAX_PATH);

        if (!FIsValidUncPath(tsz, (nDirCtrl == IDC_LOCAL_PATH_EDIT) ? VUP_mskfAllowEmptyPath : VUP_mskfAllowUNCPath))
        {
            ErrMsg((nDirCtrl == IDC_LOCAL_PATH_EDIT) ? IDS_ERRMSG_INVALID_PATH : IDS_ERRMSG_INVALID_UNC_PATH, m_hPage);
            SetFocus(GetDlgItem(m_hPage, nDirCtrl));
            hr = E_INVALIDARG;  // Path is not valid
            goto Cleanup;
        }

        if (cch == 0)
        {
            // An empty control means remove the attribute value from the object.
            //
            AttrInfoHomeDir.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoHomeDir.dwNumValues = 0;
            AttrInfoHomeDir.pADsValues = NULL;
        }
        else
        {
            if (!TcharToUnicode(tsz, &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
            }
            BOOL fExpanded;
            if (!ExpandUsername(pwzValue, fExpanded))
            {
                goto Cleanup;
            }
            if (fExpanded)
            {
                if (!UnicodeToTchar(pwzValue, &ptsz))
                {
                    CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                }
                SetDlgItemText(m_hPage, nDirCtrl, ptsz);
                if (nDirCtrl == IDC_LOCAL_PATH_EDIT)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        delete [] m_ptszLocalHomeDir;
                    }
                    m_ptszLocalHomeDir = new TCHAR[_tcslen(ptsz) + 1];
                    CHECK_NULL_REPORT(m_ptszLocalHomeDir, m_hPage, hr = E_OUTOFMEMORY; goto Cleanup);
                    _tcscpy(m_ptszLocalHomeDir, ptsz);
                }
                else
                {
                    if (m_ptszRemoteHomeDir)
                    {
                        delete [] m_ptszRemoteHomeDir;
                    }
                    m_ptszRemoteHomeDir = new TCHAR[_tcslen(ptsz) + 1];
                    CHECK_NULL_REPORT(m_ptszRemoteHomeDir, m_hPage, hr = E_OUTOFMEMORY; goto Cleanup);
                    _tcscpy(m_ptszRemoteHomeDir, ptsz);
                }
                delete [] ptsz;
            }

            AttrInfoHomeDir.dwControlCode = ADS_ATTR_UPDATE;
            AttrInfoHomeDir.dwNumValues = 1;
            AttrInfoHomeDir.pADsValues = &ADsValueHomeDir;
            ADsValueHomeDir.CaseIgnoreString = pwzValue;
        }
        rgAttrs[cAttrs++] = AttrInfoHomeDir;

        if (nDirCtrl == IDC_CONNECT_TO_PATH_EDIT)
        {
            dspAssert(m_pObjSID != NULL);
            // attempt to create the directory.
            //
            DWORD dwErr = 
                DSPROP_CreateHomeDirectory(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
            if (dwErr != 0)
            {
                switch (dwErr)
                {
                case ERROR_ALREADY_EXISTS:
                    {
                        //
                        // Report a warning and give the user full control
                        // of the directory
                        //
                        PVOID apv[1] = { (PVOID)ADsValueHomeDir.CaseIgnoreString };
                        SuperMsgBox(GetHWnd(),
                                        IDS_USER_GIVEN_FULL_CONTROL, 
                                        0, 
                                        MB_OK | MB_ICONEXCLAMATION,
                                        hr, 
                                        apv, 
                                        1,
                                        FALSE, 
                                        __FILE__, 
                                        __LINE__);

                        dwErr = ERROR_SUCCESS;
                        dwErr = AddFullControlForUser(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
                    }
                    break;

                case ERROR_PATH_NOT_FOUND:
                case ERROR_BAD_NETPATH:
                case ERROR_LOGON_FAILURE:
                case ERROR_NOT_AUTHENTICATED:
                case ERROR_INVALID_PASSWORD:
                case ERROR_PASSWORD_EXPIRED:
                case ERROR_ACCOUNT_DISABLED:
                case ERROR_ACCOUNT_LOCKED_OUT:
                case ERROR_ACCESS_DENIED:
                    {
                        //
                        // Report a warning but continue
                        //
                        PWSTR* ppwzHomeDirName = &(ADsValueHomeDir.CaseIgnoreString);
                        SuperMsgBox(GetHWnd(),
                            (ERROR_ALREADY_EXISTS == dwErr) ?
                            IDS_HOME_DIR_EXISTS : 
                            (ERROR_PATH_NOT_FOUND == dwErr) ?
                            IDS_HOME_DIR_CREATE_FAILED :
                            IDS_HOME_DIR_CREATE_NO_ACCESS,
                            0, MB_OK | MB_ICONEXCLAMATION,
                            hr, (PVOID *)ppwzHomeDirName, 1,
                            FALSE, __FILE__, __LINE__);
                    }
                    break;

                default:
                    REPORT_ERROR_FORMAT(dwErr, IDS_ERR_CREATE_DIR, m_hPage);
                    SetFocus(GetDlgItem(m_hPage, nDirCtrl));
                    hr = E_INVALIDARG;  // Path is not valid
                    goto Cleanup;
                }
            }
        }
    }

    dspAssert(cAttrs > 0);

    DWORD cModified;

    //
    // Write the changes
    //
    hr = m_pDsObj->SetObjectAttributes(rgAttrs, cAttrs, &cModified);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        goto Cleanup;
    }

    m_fProfilePathChanged = FALSE;
    m_fLogonScriptChanged = FALSE;
    m_fHomeDirChanged = FALSE;
    m_fHomeDriveChanged = FALSE;
    m_fSharedDirChanged = FALSE;

Cleanup:

    if (ADsValueProfilePath.CaseIgnoreString)
    {
        delete ADsValueProfilePath.CaseIgnoreString;
    }
    if (ADsValueScriptPath.CaseIgnoreString)
    {
        delete ADsValueScriptPath.CaseIgnoreString;
    }
    if (ADsValueHomeDir.CaseIgnoreString)
    {
        delete ADsValueHomeDir.CaseIgnoreString;
    }
    if (ADsValueHomeDrive.CaseIgnoreString)
    {
        delete ADsValueHomeDrive.CaseIgnoreString;
    }
    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::ExpandUsername
//
//  Synopsis:   If the %username% token is found in the string, substitute
//              the SAM account name.
//
//-----------------------------------------------------------------------------
BOOL
CDsUsrProfilePage::ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded)
{
    dspAssert(pwzValue);

    CStrW strUserToken;

    strUserToken.LoadString(g_hInstance, IDS_PROFILE_USER_TOKEN);

    unsigned int TokenLength = strUserToken.GetLength();

    if (!TokenLength)
    {
        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
    }

    PWSTR pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

    if (pwzTokenStart)
    {
        if (!m_pwzSamName)
        {
            ErrMsgParam(IDS_NO_SAMNAME_FOR_PROFILE, (LPARAM)(LPCWSTR)strUserToken, GetHWnd());
            return FALSE;
        }
        if ((wcslen(pwzTokenStart) >= TokenLength) &&
            (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0))
        {
            fExpanded = TRUE;
        }
        else
        {
            fExpanded = FALSE;
            return TRUE;
        }
    }
    else
    {
        fExpanded = FALSE;
        return TRUE;
    }

    CStrW strValue, strAfterToken;

    while (pwzTokenStart)
    {
        *pwzTokenStart = L'\0';

        strValue = pwzValue;

        if ((L'\0' != *pwzValue) && !strValue.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

        strAfterToken = pwzAfterToken;

        if ((L'\0' != *pwzAfterToken) && !strAfterToken.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        delete pwzValue;

        strValue += m_pwzSamName;

        if (!strValue.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        strValue += strAfterToken;

        if (!strValue.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        if (!AllocWStr((PWSTR)(LPCWSTR)strValue, &pwzValue))
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

        if (!(pwzTokenStart &&
              (wcslen(pwzTokenStart) >= TokenLength) &&
              (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0)))
        {
            return TRUE;
        }
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:     DSPROP_CreateHomeDirectory
//
//  Synopsis:   Create the user's home directory.
//
//  Notes:      It calls the CreateDirectory() OS API with the
//              security descriptor with 2 ACEs, 
//              granting GENERIC_ALL access to the Administrators builtin group 
//              and to the user.
//
//-----------------------------------------------------------------------------



class CSidHolder
{
public:
  CSidHolder()
  {
    m_pSID = NULL;
  }
  ~CSidHolder()
  {
    if (m_pSID != NULL)
      ::FreeSid(m_pSID);
  }

  PSID m_pSID;
};


DWORD 
DSPROP_CreateHomeDirectory(IN PSID pUserSid, IN LPCWSTR lpszPathName)
{
    DWORD dwErr = 0;


    // build a SID for domain administrators
    CSidHolder sidAdmins;

    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(&NtAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID, 
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &(sidAdmins.m_pSID)))
    {
        dwErr = GetLastError();
        DBG_OUT("AllocateAndInitializeSid failed!");
        return dwErr;
    }


    // build a DACL
    CSimpleAclHolder Dacl;

    static const int nAceCount = 2;
    PSID pAceSid[nAceCount];

    pAceSid[0] = pUserSid;
    pAceSid[1] = sidAdmins.m_pSID;

    EXPLICIT_ACCESS rgAccessEntry[nAceCount] = {0};

    for (int i = 0 ; i < nAceCount; i++) 
    {
        rgAccessEntry[i].grfAccessPermissions = GENERIC_ALL;
        rgAccessEntry[i].grfAccessMode = GRANT_ACCESS;
        rgAccessEntry[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

        // build the trustee structs 
        //
        BuildTrusteeWithSid(&(rgAccessEntry[i].Trustee), pAceSid[i]);
    }

    // add the entries to the ACL
    //
    DBG_OUT("calling SetEntriesInAcl()");

    dwErr = SetEntriesInAcl(nAceCount, rgAccessEntry, NULL, &(Dacl.m_pAcl));
    if (dwErr != 0)
    {
        DBG_OUT("SetEntriesInAcl() failed");
        return dwErr;
    }

    // build a security descriptor and initialize it
    // in absolute format
    SECURITY_DESCRIPTOR securityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = &securityDescriptor;

    DBG_OUT("calling InitializeSecurityDescriptor()");
    if (!InitializeSecurityDescriptor(pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
    {
        dwErr = GetLastError();
        DBG_OUT("InitializeSecurityDescriptor() failed");
        return dwErr;
    }


    // add DACL to security descriptor (must be in absolute format)
    DBG_OUT("calling SetSecurityDescriptorDacl()");
    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                   TRUE, // bDaclPresent
                                   Dacl.m_pAcl,
                                   FALSE // bDaclDefaulted
                                   ))
    {
        dwErr = GetLastError();
        DBG_OUT("SetSecurityDescriptorDacl() failed");
        return dwErr;
    }


    // set the owner of the directory
    if (!SetSecurityDescriptorOwner(pSecurityDescriptor,
                                    pUserSid, 
                                   FALSE // bOwnerDefaulted
                                   ))
    {
        dwErr = GetLastError();
        DBG_OUT("SetSecurityDescriptorOwner() failed");
        return dwErr;
    }

    dspAssert(IsValidSecurityDescriptor(pSecurityDescriptor));

    // build a SECURITY_ATTRIBUTES struct as argument for
    // CreateDirectory()
    SECURITY_ATTRIBUTES securityAttributes;
    securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;
    securityAttributes.bInheritHandle = FALSE;

    // finally make the call
    DBG_OUT("calling CreateDirectory()");
    if (!CreateDirectory(lpszPathName, &securityAttributes))
    {
        dwErr = GetLastError();
        DBG_OUT("CreateDirectory() failed");
        return dwErr;
    }

    return 0;
}

DWORD 
AddFullControlForUser(IN PSID pUserSid, IN LPCWSTR lpszPathName)
{
    DWORD dwErr = 0;
    // DACL
    PACL pOldDacl = NULL;
    PACL pNewDacl = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;


    EXPLICIT_ACCESS rgAccessEntry;

    rgAccessEntry.grfAccessPermissions = GENERIC_ALL;
    rgAccessEntry.grfAccessMode = GRANT_ACCESS;
    rgAccessEntry.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        
    // build the trustee structs 
    //
    BuildTrusteeWithSid(&(rgAccessEntry.Trustee), pUserSid);

    //Read Exisiting Security Descriptor

    dwErr = GetNamedSecurityInfo((LPWSTR)lpszPathName,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 &pOldDacl,
                                 NULL,
                                 &pSD);

    if( dwErr != ERROR_SUCCESS )
    {
        DBG_OUT("GetNamedSecurityInfo() failed");
        goto CLEAN_RETURN;
    }

    //Build the New Acl to set
    DBG_OUT("calling SetEntriesInAcl()");
    dwErr = SetEntriesInAcl(1, &rgAccessEntry,pOldDacl,&pNewDacl);
    if( dwErr != ERROR_SUCCESS )
    {
        DBG_OUT("SetEntriesInAcl() failed");
        goto CLEAN_RETURN;
    }


    DBG_OUT("calling SetNamedSecurityInfo()");
    dwErr = SetNamedSecurityInfo((LPWSTR)lpszPathName, 
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 pNewDacl,
                                 NULL);
    {
        DBG_OUT("SetNamedSecurityInfo failed");
        goto CLEAN_RETURN;
    }
CLEAN_RETURN:
    if(pSD)
        LocalFree(pSD);
    if(pNewDacl)
        LocalFree(pNewDacl);

    return dwErr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    TCHAR tsz[MAX_PATH+MAX_PATH+1];
    int idNewHomeDirRadio = -1;

    switch (id)
    {
    case IDC_LOCAL_PATH_EDIT:
        if (codeNotify == EN_KILLFOCUS)
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszLocalHomeDir)
                {
                    delete m_ptszLocalHomeDir;
                    m_ptszLocalHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszLocalHomeDir || _tcscmp(tsz, m_ptszLocalHomeDir))
                {
                    if (m_ptszLocalHomeDir)
                    {
                        delete m_ptszLocalHomeDir;
                    }

                    m_ptszLocalHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszLocalHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszLocalHomeDir, tsz);
                }
            }
            break;
        }
        // fall through
    case IDC_CONNECT_TO_PATH_EDIT:
    case IDC_DRIVES_COMBO:
        if ((codeNotify == EN_KILLFOCUS) || (codeNotify == CBN_KILLFOCUS))
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszRemoteHomeDir)
                {
                    delete m_ptszRemoteHomeDir;
                    m_ptszRemoteHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszRemoteHomeDir || _tcscmp(tsz, m_ptszRemoteHomeDir))
                {
                    if (m_ptszRemoteHomeDir)
                    {
                        delete m_ptszRemoteHomeDir;
                    }

                    m_ptszRemoteHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszRemoteHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszRemoteHomeDir, tsz);
                }
            }
            break;
        }

        if ((codeNotify == EN_SETFOCUS) || (codeNotify == CBN_SETFOCUS))
        {
            // Toggle the radio buttons if needed.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (IsDlgButtonChecked(m_hPage, IDC_CONNECT_TO_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_LOCAL_PATH_RADIO;

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_UNCHECKED);
                }
            }
            else
            {
                if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_CONNECT_TO_RADIO;

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_UNCHECKED);
                }
            }
            //
            // Restore the incoming edit control and clear the other if needed.
            // Also set or clear the drives combo as appropiate.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (idNewHomeDirRadio == IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);
                }
            }
            else
            {
                if (idNewHomeDirRadio == IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);
                }
            }
            if (idNewHomeDirRadio != -1)
            {
                m_idHomeDirRadio = idNewHomeDirRadio;
            }
            break;
        }

        if (id == IDC_DRIVES_COMBO && codeNotify == CBN_SELCHANGE)
        {
            m_nDrive = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO,
                                               CB_GETCURSEL, 0, 0);
            SetDirty();
            m_fHomeDriveChanged = TRUE;
            break;
        }
        if ((id == IDC_LOCAL_PATH_EDIT || IDC_CONNECT_TO_PATH_EDIT == id)
            && codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fHomeDirChanged = TRUE;
        }
        break;

    case IDC_PROFILE_PATH_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fProfilePathChanged = TRUE;
        }
        break;

    case IDC_LOGON_SCRIPT_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fLogonScriptChanged = TRUE;
        }
        break;

    case IDC_LOCAL_PATH_RADIO:
    case IDC_CONNECT_TO_RADIO:
        if (codeNotify == BN_CLICKED)
        {
            if (id == IDC_LOCAL_PATH_RADIO)
            {
                if (m_idHomeDirRadio != IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);
                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
                }
            }
            else
            {
                if (m_idHomeDirRadio != IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);

                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
                }
            }
            if (m_idHomeDirRadio != id)
            {
                m_idHomeDirRadio = id;
                SetDirty();
                m_fHomeDriveChanged = TRUE;
                m_fHomeDirChanged = TRUE;
            }
        }
        return 1;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnDestroy(void)
{
    if (m_ptszLocalHomeDir)
    {
        delete m_ptszLocalHomeDir;
        m_ptszLocalHomeDir = NULL;
    }
    if (m_ptszRemoteHomeDir)
    {
        delete m_ptszRemoteHomeDir;
        m_ptszRemoteHomeDir = NULL;
    }
    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Class:      CLogonWkstaDlg
//
//  Purpose:    Update the logon workstations attribute. This is a dialog
//              that hosts the CMultiStringAttr class.
//
//-----------------------------------------------------------------------------
CLogonWkstaDlg::CLogonWkstaDlg(CDsPropPageBase * pPage) :
    m_pPage(pPage),
    m_MSA(pPage),
    m_fAllWkstas(TRUE),
    m_fOrigAllWkstas(TRUE),
    m_fFirstUp(TRUE)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr name.
//              [pAttrInfo]  - place to store the values.
//              [fWritable]  - is the attribute writable.
//              [nLimit]     - the max number of values (zero means no limit).
//              [fCommaList] - if TRUE, pAttrInfo is a single-valued, comma
//                             delimited list.
//-----------------------------------------------------------------------------
HRESULT
CLogonWkstaDlg::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                     BOOL fWritable, int nLimit, BOOL fCommaList)
{
    return m_MSA.Init(pAttrMap, pAttrInfo, fWritable, nLimit, fCommaList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT CLogonWkstaDlg::Write(PADS_ATTR_INFO pAttrInfo)
{
    if (m_fAllWkstas)
    {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        return S_OK;
    }
    return m_MSA.Write(pAttrInfo);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::Edit
//
//  Synopsis:   Post the edit dialog.
//
//-----------------------------------------------------------------------------
int
CLogonWkstaDlg::Edit(void)
{
    return (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_LOGON_WKSTA),
                          m_pPage->GetHWnd(), (DLGPROC)StaticDlgProc, (LPARAM)this);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::IsDirty
//
//  Synopsis:   Has anything changed.
//
//-----------------------------------------------------------------------------
BOOL
CLogonWkstaDlg::IsDirty(void)
{
    if (m_fAllWkstas)
    {
        return !m_fOrigAllWkstas;
    }
    else
    {
        return m_MSA.IsDirty();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::ClearDirty
//
//  Synopsis:   Clear dirty state.
//
//-----------------------------------------------------------------------------
void
CLogonWkstaDlg::ClearDirty(void)
{
    m_fOrigAllWkstas = m_fAllWkstas;
    m_MSA.ClearDirty();
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::StaticDlgProc
//
//  Synopsis:   The static dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CLogonWkstaDlg::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    CLogonWkstaDlg * pMSAD = (CLogonWkstaDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pMSAD = (CLogonWkstaDlg *)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMSAD);
    }

    if (pMSAD)
    {
        return pMSAD->MultiValDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::MultiValDlgProc
//
//  Synopsis:   The instancce dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
BOOL CALLBACK
CLogonWkstaDlg::MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CLogonWkstaDlg * pMSAD = (CLogonWkstaDlg *)GetWindowLongPtr(hDlg, DWLP_USER);
    CMultiStringAttr * pMSA = &pMSAD->m_MSA;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        if (m_fFirstUp)
        {
            m_fAllWkstas = !pMSA->HasValues();
            m_fFirstUp = FALSE;
        }
        m_fOrigAllWkstas = m_fAllWkstas;
        if (m_fAllWkstas)
        {
            CheckDlgButton(hDlg, IDC_ANY_WKSTA_RADIO, BST_CHECKED);
            if (!pMSA->IsWritable())
            {
                EnableWindow(GetDlgItem(hDlg, IDC_SPECIFIC_WKSTAS_RADIO), FALSE);
            }
            pMSA->EnableControls(hDlg, FALSE);
        }
        else
        {
            CheckDlgButton(hDlg, IDC_SPECIFIC_WKSTAS_RADIO, BST_CHECKED);
            if (!pMSA->IsWritable())
            {
                EnableWindow(GetDlgItem(hDlg, IDC_ANY_WKSTA_RADIO), FALSE);
            }
        }
        return pMSA->DoDlgInit(hDlg);

    case WM_COMMAND:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        int id, code;
        id = GET_WM_COMMAND_ID(wParam, lParam);
        code = GET_WM_COMMAND_CMD(wParam, lParam);

        if ((id == IDC_SPECIFIC_WKSTAS_RADIO) || (id == IDC_ANY_WKSTA_RADIO))
        {
            if (code == BN_CLICKED)
            {
                m_fAllWkstas = id == IDC_ANY_WKSTA_RADIO;
                pMSA->EnableControls(hDlg, !m_fAllWkstas);
            }
        }
        else
        {
            int ret = pMSA->DoCommand(hDlg, id, code);
            if (ret == IDCANCEL)
            {
                m_fAllWkstas = m_fOrigAllWkstas;
            }
            return ret;
        }
        break;

    case WM_NOTIFY:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoNotify(hDlg, (NMHDR *)lParam);

    case WM_HELP:
        LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
        dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                     pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
        if (pHelpInfo->iCtrlId < 1)
        {
            return 0;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
    }

    return 0;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\trustwiz.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       trustwiz.h
//
//  Contents:   AD domain trust creation wizard classes and definition.
//
//  Classes:    CNewTrustWizard, CTrustWizPageBase, wizard pages classes.
//
//  History:    04-Aug-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef TRUSTWIZ_H_GUARD
#define TRUSTWIZ_H_GUARD

#include <list>
#include <stack>
#include "subclass.h"
#include "ftinfo.h"

// forward declarations:
class CCredMgr;
class CDsDomainTrustsPage;
class CNewTrustWizard;
class CTrustWizPageBase;
class CTrustWizCredPage;

//+----------------------------------------------------------------------------
//
//  Class:     CallMember and its derivatives
//
//  Purpose:   Allows a page to indicate what the next step of the creation
//             process should be. It is an abstraction of the process of passing
//             a function pointer.
//
//-----------------------------------------------------------------------------
class CallPolicyRead : public CallMember
{
public:
   CallPolicyRead(CNewTrustWizard * pWiz) : CallMember(pWiz) {};
   ~CallPolicyRead() {};

   HRESULT Invoke(void);
};

class CallTrustExistCheck : public CallMember
{
public:
   CallTrustExistCheck(CNewTrustWizard * pWiz) : CallMember(pWiz) {};
   ~CallTrustExistCheck() {};

   HRESULT Invoke(void);
};

//+----------------------------------------------------------------------------
//
//  Class:     CWizError
//
//  Purpose:   Gathers error information that will be displayed by the wizard
//             error page.
//
//-----------------------------------------------------------------------------
class CWizError
{
public:
   CWizError() {};
   ~CWizError() {};

   void              SetErrorString1(LPCWSTR pwz) {_strError1 = pwz;};
   void              SetErrorString1(int nID) {_strError1.LoadString(g_hInstance, nID);};
   void              SetErrorString2(LPCWSTR pwz) {_strError2 = pwz;};
   void              SetErrorString2(int nID) {_strError2.LoadString(g_hInstance, nID);};
   void              SetErrorString2Hr(HRESULT hr, int nID = 0);
   CStrW &           GetErrorString1(void) {return _strError1;};
   CStrW &           GetErrorString2(void) {return _strError2;};

private:
   CStrW             _strError1;
   CStrW             _strError2;

   // not implemented to disallow copying.
   CWizError(const CWizError&);
   const CWizError& operator=(const CWizError&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CRemoteDomain
//
//  Purpose:    Obtains information about a trust partner domain.
//
//-----------------------------------------------------------------------------
class CRemoteDomain
{
public:
   CRemoteDomain();
   ~CRemoteDomain();

   HRESULT DiscoverDC(BOOL fPdcRequired = FALSE);
   HRESULT OpenLsaPolicy(CCredMgr & CredMgr, BOOL fAllAccess = FALSE);
   HRESULT ReadDomainInfo(void);
   HRESULT IsForestRoot(bool * pfRoot);
   void CloseLsaPolicy(void);
   void SetUserEnteredName(LPCWSTR pwzDomain) {Clear(); _strUserEnteredName = pwzDomain;};
   PCWSTR GetUserEnteredName(void) const {return _strUserEnteredName;};
   BOOL SetSid(PSID pSid);
   const PSID GetSid(void) const {return _pSid;};
   PCWSTR GetDnsName(void) const {return _strDomainDnsName;};
   PCWSTR GetFlatName(void) const {return _strDomainFlatName;};
   PCWSTR GetForestName(void) const {return _strForestName;};
   PCWSTR GetUncDcName(void) const {return _strUncDC;};
   PCWSTR GetDcName(void) {return _strUncDC.GetBuffer(0) + 2;};
   const LSA_HANDLE GetLsaPolicy(void) const {return _hPolicy;};
   BOOL IsFound(void) {return !_fNotFound;};
   BOOL IsForestRoot(void) {return _fIsForestRoot;};
   BOOL IsUplevel(void) {return _fUplevel;};

private:

   void Clear(void);

   CStrW          _strUserEnteredName;
   CStrW          _strDomainFlatName;
   CStrW          _strDomainDnsName;
   CStrW          _strForestName;
   CStrW          _strUncDC;
   BOOL           _fNotFound;
   BOOL           _fIsForestRoot;
   BOOL           _fUplevel;
   LSA_HANDLE     _hPolicy;
   PSID           _pSid;

   // not implemented to disallow copying.
   CRemoteDomain(const CRemoteDomain&);
   const CRemoteDomain& operator=(const CRemoteDomain&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrust
//
//  Purpose:   A trust is represented in the AD by a Trusted-Domain object.
//             This class encapsulates the operations and properties of a
//             pending or existing trust.
//
//-----------------------------------------------------------------------------
class CTrust
{
public:
   CTrust() : _dwType(0), _dwDirection(0), _dwNewDirection(0), _dwAttr(0),
              _dwNewAttr(0), _fExists(FALSE), _fUpdatedFromNT4(FALSE),
              _fExternal(FALSE) {};
   ~CTrust() {};

   // methods
   NTSTATUS Query(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain,
                  PLSA_UNICODE_STRING pName,
                  PTRUSTED_DOMAIN_FULL_INFORMATION * ppFullInfo);
   DWORD    DoCreate(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain);
   DWORD    DoModify(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain);
   DWORD    ReadFTInfo(PCWSTR pwzLocalDC, PCWSTR pwzOtherDC,
                       CCredMgr & CredMgr, CWizError & WizErr, bool & fCredErr);
   DWORD    WriteFTInfo(PCWSTR pwzLocalDC);
   CFTInfo & ReturnFTInfo(void) {return _FTInfo;};
   CFTCollisionInfo & ReturnCollisionInfo(void) {return _CollisionInfo;};
   BOOL     AreThereCollisions(void);
   void     Clear(void);

   // property access routines.
   void     SetTrustPW(LPCWSTR pwzPW) {_strTrustPW = pwzPW;};
   PCWSTR   GetTrustPW(void) const {return _strTrustPW;};
   size_t   GetTrustPWlen(void) {return _strTrustPW.GetLength();};
   void     SetTrustType(DWORD type) {_dwType = type;};
   void     SetTrustTypeUplevel(void) {_dwType = TRUST_TYPE_UPLEVEL;};
   void     SetTrustTypeDownlevel(void) {_dwType = TRUST_TYPE_DOWNLEVEL;};
   void     SetTrustTypeRealm(void) {_dwType = TRUST_TYPE_MIT;};
   DWORD    GetTrustType(void) {return _dwType;}
   void     SetTrustDirection(DWORD dir) {_dwDirection = dir;};
   DWORD    GetTrustDirection(void) {return _dwDirection;};
   int      GetTrustDirStrID(DWORD dwDir);
   void     SetNewTrustDirection(DWORD dir) {_dwNewDirection = dir;};
   DWORD    GetNewTrustDirection(void) {return _dwNewDirection;};
   void     SetTrustAttr(DWORD attr);
   DWORD    GetTrustAttr(void) {return _dwAttr;};
   void     SetNewTrustAttr(DWORD attr) {_dwNewAttr = attr;};
   DWORD    GetNewTrustAttr(void) {return _dwNewAttr;};
   void     SetTrustPartnerName(PCWSTR pwzName) {_strTrustPartnerName = pwzName;};
   PCWSTR   GetTrustpartnerName(void) const {return _strTrustPartnerName;};
   void     SetExists(void) {_fExists = TRUE;};
   BOOL     Exists(void) {return _fExists;};
   void     SetUpdated(void) {_fUpdatedFromNT4 = TRUE;};
   BOOL     IsUpdated(void) {return _fUpdatedFromNT4;};
   void     SetExternal(BOOL x) {_fExternal = x;};
   BOOL     IsExternal(void) {return _fExternal;};
   void     SetMakeXForest(void);
   BOOL     IsXForest(void);

private:
   CStrW          _strTrustPartnerName;
   CStrW          _strTrustPW;
   DWORD          _dwType;
   DWORD          _dwDirection;
   DWORD          _dwNewDirection;
   DWORD          _dwAttr;
   DWORD          _dwNewAttr;
   BOOL           _fExists;
   BOOL           _fUpdatedFromNT4;
   BOOL           _fExternal;
   CFTInfo           _FTInfo;
   CFTCollisionInfo  _CollisionInfo;

   // not implemented to disallow copying.
   CTrust(const CTrust&);
   const CTrust& operator=(const CTrust&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CVerifyTrust
//
//  Purpose:    Verifies a trust and stores the results.
//
//-----------------------------------------------------------------------------
class CVerifyTrust
{
public:
   CVerifyTrust() : _dwInboundResult(0), _dwOutboundResult(0),
                    _fInboundVerified(FALSE), _fOutboundVerified(FALSE) {};
   ~CVerifyTrust() {};

   DWORD    VerifyInbound(PCWSTR pwzRemoteDC, PCWSTR pwzLocalDomain) {return Verify(pwzRemoteDC, pwzLocalDomain, TRUE);};
   DWORD    VerifyOutbound(PCWSTR pwzLocalDC, PCWSTR pwzRemoteDomain) {return Verify(pwzLocalDC, pwzRemoteDomain, FALSE);};
   DWORD    GetInboundResult(void) {return _dwInboundResult;};
   DWORD    GetOutboundResult(void) {return _dwOutboundResult;};
   PCWSTR   GetInboundResultString(void) const {return _strInboundResult;};
   PCWSTR   GetOutboundResultString(void) const {return _strOutboundResult;};
   BOOL     IsInboundVerified(void) {return _fInboundVerified;};
   BOOL     IsOutboundVerified(void) {return _fOutboundVerified;};
   BOOL     IsVerified(void) {return _fInboundVerified || _fOutboundVerified;};
   BOOL     IsVerifiedOK(void) {return (NO_ERROR == _dwInboundResult) && (NO_ERROR == _dwOutboundResult);};
   void     ClearResults(void);

private:
   DWORD    Verify(PCWSTR pwzDC, PCWSTR pwzDomain, BOOL fInbound);
   void     SetResult(DWORD dwRes, BOOL fInbound) {if (fInbound) _dwInboundResult = dwRes; else _dwOutboundResult = dwRes;};
   void     AppendResultString(PCWSTR pwzRes, BOOL fInbound) {if (fInbound) _strInboundResult += pwzRes; else _strOutboundResult += pwzRes;};
   void     SetInboundResult(DWORD dwRes) {_dwInboundResult = dwRes;};
   void     AppendInboundResultString(PCWSTR pwzRes) {_strInboundResult += pwzRes;};
   void     SetOutboundResult(DWORD dwRes) {_dwOutboundResult = dwRes;};
   void     AppendOutboundResultString(PCWSTR pwzRes) {_strOutboundResult += pwzRes;};

   CStrW    _strInboundResult;
   DWORD    _dwInboundResult;
   CStrW    _strOutboundResult;
   DWORD    _dwOutboundResult;
   BOOL     _fInboundVerified;
   BOOL     _fOutboundVerified;

   // not implemented to disallow copying.
   CVerifyTrust(const CVerifyTrust&);
   const CVerifyTrust& operator=(const CVerifyTrust&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CNewTrustWizard
//
//  Purpose:    New trust creation wizard.
//
//-----------------------------------------------------------------------------
class CNewTrustWizard
{
public:
   CNewTrustWizard(CDsDomainTrustsPage * pTrustPage);
   ~CNewTrustWizard();

   // Wizard page managment data structures and methods
   HRESULT CreatePages(void);
   HRESULT LaunchModalWiz(void);

   typedef std::stack<unsigned> PAGESTACK;
   typedef std::list<CTrustWizPageBase *> PAGELIST;

   PAGELIST          _PageList;
   PAGESTACK         _PageIdStack;

   void              SetNextPageID(CTrustWizPageBase * pPage, int iNextPageID);
   BOOL              IsBacktracking(void) {return _fBacktracking;};
   BOOL              HaveBacktracked(void) {return _fHaveBacktracked;};
   void              ClearBacktracked(void) {_fHaveBacktracked = false;};
   void              BackTrack(HWND hPage);
   HFONT             GetTitleFont(void) {return _hTitleFont;};
   CDsDomainTrustsPage * TrustPage(void) {return _pTrustPage;};
   CTrustWizPageBase * GetPage(unsigned uDlgResId);
   void              SetCreationResult(HRESULT hr) {_hr = hr;};
   HRESULT           GetCreationResult(void) {return _hr;};
   void              ShowStatus(CStrW & strMsg, bool fNewTrust = true);
   void              InitHelp(void);
   bool              OtherDomainIsForestRoot(void) {return _fIsForestRoot;};

   // Methods that collect data. They return zero for success or the page ID of
   // the creds page or the page ID of the error page.
   int               GetDomainInfo(void);
   int               TrustExistCheck(BOOL fPrompt = TRUE);
   int               OtherDomainForestRootCheck(void);

   // Methods that implement the steps of trust creation/modification.
   // These are executed in the order listed. They all return the page ID of
   // the next wizard page to be shown.
   int               CollectInfo(void);
   int               ContinueCollectInfo(BOOL fPrompt = TRUE); // continues CollectInfo.
   int               CreateOrUpdateTrust(void);
   int               VerifyOutboundTrust(void);
   int               VerifyInboundTrust(void);

   // Additonal methods passed to CCredMgr::_pNextFcn
   int               RetryCollectInfo(void);
   int               RetryContinueCollectInfo(void); // continues ContinueCollectInfo1 if creds were needed.

   // Objects that hold state info.
   CTrust            Trust;
   CRemoteDomain     OtherDomain;
   CWizError         WizError;
   CCredMgr          CredMgr;
   CVerifyTrust      VerifyTrust;

private:
   BOOL  AddPage(CTrustWizPageBase * pPage);
   void  MakeBigFont(void);

   CDsDomainTrustsPage *   _pTrustPage;
   BOOL                    _fBacktracking;
   BOOL                    _fHaveBacktracked;
   HFONT                   _hTitleFont;
   bool                    _fIsForestRoot;
   HRESULT                 _hr; // Controls whether the trust list is refreshed.
                                // It should only be set if the new trust
                                // creation failed. If a failure occurs after
                                // a trust is created, don't set this because
                                // in that case we still want the trust list to
                                // be refreshed.
   bool                    _fHelpInited;
   DWORD                   _dwHelpCookie;

   // not implemented to disallow copying.
   CNewTrustWizard(CNewTrustWizard&);
   const CNewTrustWizard& operator=(const CNewTrustWizard&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizPageBase
//
//  Purpose:    Common base class for wizard pages.
//
//-----------------------------------------------------------------------------
class CTrustWizPageBase
{
public:
   CTrustWizPageBase(CNewTrustWizard * pWiz,
                     UINT uDlgID,
                     UINT uTitleID,
                     UINT uSubTitleID,
                     BOOL fExteriorPage = FALSE);
   virtual ~CTrustWizPageBase();

   //
   //  Static WndProc to be passed to CreatePropertySheetPage.
   //
   static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam);
   //
   //  Instance specific window procedure
   //
   LRESULT PageProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

   HPROPSHEETPAGE          Create(void);
   HWND                    GetPageHwnd(void) {return _hPage;};
   UINT                    GetDlgResID(void) {return _uDlgID;};
   CNewTrustWizard *       Wiz(void) {return _pWiz;};
   CRemoteDomain &         OtherDomain(void) {return _pWiz->OtherDomain;};
   CTrust &                Trust(void) {return _pWiz->Trust;};
   CWizError &             WizErr(void) {return _pWiz->WizError;};
   CCredMgr &              CredMgr(void) {return _pWiz->CredMgr;};
   CVerifyTrust &          VerifyTrust() {return _pWiz->VerifyTrust;};
   CDsDomainTrustsPage *   TrustPage(void) {return _pWiz->TrustPage();};

protected:
   virtual int     Validate(void) = 0;
   virtual BOOL    OnInitDialog(LPARAM lParam) = 0;
   virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify) {return false;};
   virtual void    OnSetActive(void) = 0;
   void            OnWizBack(void);
   void            OnWizNext(void);
   virtual void    OnWizFinish(void) {};
   virtual void    OnWizReset(void) {};
   virtual void    OnDestroy(void) {};
   void            ShowHelp(PCWSTR pwzHelpFile);

   HWND _hPage;
   UINT _uDlgID;
   UINT _uTitleID;
   UINT _uSubTitleID;
   BOOL _fExteriorPage;
   BOOL _fInInit;
   DWORD _dwWizButtons;
   CNewTrustWizard * _pWiz;

private:
   // not implemented to disallow copying.
   CTrustWizPageBase(const CTrustWizPageBase &);
   const CTrustWizPageBase & operator=(const CTrustWizPageBase &);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizIntroPage
//
//  Purpose:    Intro page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizIntroPage : public CTrustWizPageBase
{
public:
   CTrustWizIntroPage(CNewTrustWizard * pWiz) :
         CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_INTRO_PAGE, 0, 0, TRUE)
         {TRACER(CTrustWizIntroPage, CTrustWizIntroPage);};

   ~CTrustWizIntroPage() {};

private:
   int     Validate(void) {return IDD_TRUSTWIZ_NAME_PAGE;};
   BOOL    OnInitDialog(LPARAM lParam);
   void    OnSetActive(void) {PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);};
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   // not implemented to disallow copying.
   CTrustWizIntroPage(const CTrustWizIntroPage&);
   const CTrustWizIntroPage& operator=(const CTrustWizIntroPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizNamePage
//
//  Purpose:    Name and pw page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizNamePage : public CTrustWizPageBase
{
public:
   CTrustWizNamePage(CNewTrustWizard * pWiz);
   ~CTrustWizNamePage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizNamePage(const CTrustWizNamePage&);
   const CTrustWizNamePage& operator=(const CTrustWizNamePage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizPwMatchPage
//
//  Purpose:    Trust passwords entered don't match page for trust wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizPwMatchPage : public CTrustWizPageBase
{
public:
   CTrustWizPwMatchPage(CNewTrustWizard * pWiz);
   ~CTrustWizPwMatchPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizPwMatchPage(const CTrustWizPwMatchPage&);
   const CTrustWizPwMatchPage& operator=(const CTrustWizPwMatchPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizCredPage
//
//  Purpose:    Credentials specification page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizCredPage : public CTrustWizPageBase
{
public:
   CTrustWizCredPage(CNewTrustWizard * pWiz);
   ~CTrustWizCredPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   void    SetText(void);

   BOOL    _fNewCall;

   // not implemented to disallow copying.
   CTrustWizCredPage(const CTrustWizCredPage&);
   const CTrustWizCredPage& operator=(const CTrustWizCredPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizMitOrWinPage
//
//  Purpose:   Domain not found, query for Non-Windows trust or re-enter name
//             wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizMitOrWinPage : public CTrustWizPageBase
{
public:
   CTrustWizMitOrWinPage(CNewTrustWizard * pWiz);
   ~CTrustWizMitOrWinPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizMitOrWinPage(const CTrustWizMitOrWinPage&);
   const CTrustWizMitOrWinPage& operator=(const CTrustWizMitOrWinPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizTransitivityPage
//
//  Purpose:   Realm transitivity page.
//
//-----------------------------------------------------------------------------
class CTrustWizTransitivityPage : public CTrustWizPageBase
{
public:
   CTrustWizTransitivityPage(CNewTrustWizard * pWiz);
   ~CTrustWizTransitivityPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizTransitivityPage(const CTrustWizTransitivityPage&);
   const CTrustWizTransitivityPage& operator=(const CTrustWizTransitivityPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizExternOrForestPage
//
//  Purpose:   External or Forest type trust wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizExternOrForestPage : public CTrustWizPageBase
{
public:
   CTrustWizExternOrForestPage(CNewTrustWizard * pWiz);
   ~CTrustWizExternOrForestPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify) {return false;};
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizExternOrForestPage(const CTrustWizExternOrForestPage&);
   const CTrustWizExternOrForestPage& operator=(const CTrustWizExternOrForestPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizDirectionPage
//
//  Purpose:    Trust direction trust wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizDirectionPage : public CTrustWizPageBase
{
public:
   CTrustWizDirectionPage(CNewTrustWizard * pWiz);
   ~CTrustWizDirectionPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify) {return false;};
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizDirectionPage(const CTrustWizDirectionPage&);
   const CTrustWizDirectionPage& operator=(const CTrustWizDirectionPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizBiDiPage
//
//  Purpose:    Ask to make a one way trust bidi trust wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizBiDiPage : public CTrustWizPageBase
{
public:
   CTrustWizBiDiPage(CNewTrustWizard * pWiz);
   ~CTrustWizBiDiPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify) {return false;};
   void    OnSetActive(void);
   void    SetSubtitle(void);

   // not implemented to disallow copying.
   CTrustWizBiDiPage(const CTrustWizBiDiPage&);
   const CTrustWizBiDiPage& operator=(const CTrustWizBiDiPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizSelectionsPage
//
//  Purpose:    Show the settings that will be used for the trust.
//
//-----------------------------------------------------------------------------
class CTrustWizSelectionsPage : public CTrustWizPageBase
{
public:
   CTrustWizSelectionsPage(CNewTrustWizard * pWiz);
   ~CTrustWizSelectionsPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);
   void    SetSelections(void);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizSelectionsPage(const CTrustWizSelectionsPage&);
   const CTrustWizSelectionsPage& operator=(const CTrustWizSelectionsPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizVerifyOutboundPage
//
//  Purpose:    Ask to confirm the new outbound trust.
//
//-----------------------------------------------------------------------------
class CTrustWizVerifyOutboundPage : public CTrustWizPageBase
{
public:
   CTrustWizVerifyOutboundPage(CNewTrustWizard * pWiz);
   ~CTrustWizVerifyOutboundPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizVerifyOutboundPage(const CTrustWizVerifyOutboundPage&);
   const CTrustWizVerifyOutboundPage& operator=(const CTrustWizVerifyOutboundPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizVerifyInboundPage
//
//  Purpose:    Ask to confirm the new inbound trust.
//
//-----------------------------------------------------------------------------
class CTrustWizVerifyInboundPage : public CTrustWizPageBase
{
public:
   CTrustWizVerifyInboundPage(CNewTrustWizard * pWiz);
   ~CTrustWizVerifyInboundPage() {};

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   BOOL  _fNeedCreds;

   // not implemented to disallow copying.
   CTrustWizVerifyInboundPage(const CTrustWizVerifyInboundPage&);
   const CTrustWizVerifyInboundPage& operator=(const CTrustWizVerifyInboundPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizStatusPage
//
//  Purpose:    Forest trust has been created and verified, show the status.
//
//-----------------------------------------------------------------------------
class CTrustWizStatusPage : public CTrustWizPageBase
{
public:
   CTrustWizStatusPage(CNewTrustWizard * pWiz);
   ~CTrustWizStatusPage() {};

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void);
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizStatusPage(const CTrustWizStatusPage&);
   const CTrustWizStatusPage& operator=(const CTrustWizStatusPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizSuffixesPage
//
//  Purpose:    Forest name suffixes page.
//
//-----------------------------------------------------------------------------
class CTrustWizSuffixesPage : public CTrustWizPageBase
{
public:
   CTrustWizSuffixesPage(CNewTrustWizard * pWiz);
   ~CTrustWizSuffixesPage() {};

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void);
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   // not implemented to disallow copying.
   CTrustWizSuffixesPage(const CTrustWizSuffixesPage&);
   const CTrustWizSuffixesPage& operator=(const CTrustWizSuffixesPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizDoneOKPage
//
//  Purpose:    Completion page when there are no errors.
//
//-----------------------------------------------------------------------------
class CTrustWizDoneOKPage : public CTrustWizPageBase
{
public:
   CTrustWizDoneOKPage(CNewTrustWizard * pWiz);
   ~CTrustWizDoneOKPage() {};

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void) {return -1;};
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizDoneOKPage(const CTrustWizDoneOKPage&);
   const CTrustWizDoneOKPage& operator=(const CTrustWizDoneOKPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizDoneVerErrPage
//
//  Purpose:    Completion page for when the verification fails.
//
//-----------------------------------------------------------------------------
class CTrustWizDoneVerErrPage : public CTrustWizPageBase
{
public:
   CTrustWizDoneVerErrPage(CNewTrustWizard * pWiz);
   ~CTrustWizDoneVerErrPage() {};

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void) {return -1;};
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizDoneVerErrPage(const CTrustWizDoneVerErrPage&);
   const CTrustWizDoneVerErrPage& operator=(const CTrustWizDoneVerErrPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizFailurePage
//
//  Purpose:    Failure page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizFailurePage : public CTrustWizPageBase
{
public:
   CTrustWizFailurePage(CNewTrustWizard * pWiz);
   ~CTrustWizFailurePage() {};

private:
   BOOL    OnInitDialog(LPARAM lParam);
   int     Validate(void) {return -1;};
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizFailurePage(const CTrustWizFailurePage&);
   const CTrustWizFailurePage& operator=(const CTrustWizFailurePage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizAlreadyExistsPage
//
//  Purpose:    Trust already exists page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizAlreadyExistsPage : public CTrustWizPageBase
{
public:
   CTrustWizAlreadyExistsPage(CNewTrustWizard * pWiz);
   ~CTrustWizAlreadyExistsPage() {};

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void) {return -1;};
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizAlreadyExistsPage(const CTrustWizAlreadyExistsPage&);
   const CTrustWizAlreadyExistsPage& operator=(const CTrustWizAlreadyExistsPage&);
};

#endif // TRUSTWIZ_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\admin\uacct.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       uacct.h
//
//  Contents:   User account page declarations
//
//  Classes:    
//
//  History:    29-Nov-99 JeffJon created
//
//-----------------------------------------------------------------------------

#ifndef __UACCT_H_
#define __UACCT_H_

#include "proppage.h"
#include "user.h"

#ifdef DSADMIN

static const PWSTR wzUPN          = L"userPrincipalName";

static const PWSTR wzSAMname      = L"sAMAccountName";   // DS max length 64,
#define MAX_SAM_NAME_LEN LM20_UNLEN                      // but SAM max is 20.

static const PWSTR wzPwdLastSet   = L"pwdLastSet";       // LARGE INTEGER

static const PWSTR wzAcctExpires  = L"accountExpires";   // [Interval] ADSTYPE_INTEGER

static const PWSTR wzLogonHours   = L"logonHours";       // ADSTYPE_OCTET_STRING

static const PWSTR wzSecDescriptor= L"nTSecurityDescriptor";

static const PWSTR wzUserWksta    = L"userWorkstations"; // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzLockoutTime  = L"lockoutTime";      // LARGE INTEGER

static const PWSTR wzUserAccountControlComputed = L"msDS-User-Account-Control-Computed";

// User-Workstations is a comma-separated list of NETBIOS machine names.
// The attribute has a range upper of 1024 characters. A NETBIOS machine name
// has a maximum length of 16 characters; add one for the comma and you have
// seventeen characters. Thus, the maximum logon workstations that can be
// stored is 1024/17.

#define MAX_LOGON_WKSTAS (1024/17)

#define cbLogonHoursArrayLength     21      // Number of bytes in the logon array

#define DSPROP_NO_ACE_FOUND