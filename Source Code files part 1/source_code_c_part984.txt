o keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    delete m_pServer;
    for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        delete m_paNamespaces[dwIx];
    delete m_paNamespaces;
    delete m_pClass;

    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        delete m_paKeys[dwIx];
    delete m_paKeys;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    delete [] m_pClass;
    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces++] = Macro_CloneLPWSTR(wszNamespace);

    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue );

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;

                VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    delete m_pName;
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];
    wcscpy(wszPath, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            swprintf(wszTemp, L"%u", V_UI4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            swprintf(wszTemp, L"%hd", V_I2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            swprintf(wszTemp, L"%hu", V_UI2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            swprintf(wszTemp, L"%d", V_I1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            swprintf(wszTemp, L"%u", V_UI1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];
                wcscpy(m_pOutput->m_pServer, pwcStart);

                *pOutput = m_pOutput;
                m_pOutput = 0;

                return NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            return SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef;
        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;

    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, char **argv)
{
    printf("Object Path Test\n");
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: objpath input-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

void main(int argc, char **argv)
{
        xmain(argc, argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\provider.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Provider.CPP
//
//  Purpose: Implementation of Provider class
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <objpath.h>
#include <cominit.h>
#include <brodcast.h>
#include <createmutexasprocess.h>
#include <stopwatch.h>
#include <SmartPtr.h>
#include <frqueryex.h>
#include "FWStrings.h"
#include "MultiPlat.h"

// Must instantiate static members
CHString Provider::s_strComputerName;

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider ctor
//
//  
//
//  Inputs:     name of this provider
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   suggest that derived classes implement their provider's ctor thusly:
//
//                  MyProvider::MyProvider(const CHString& setName) : 
//                      Provider(setName)
//
//  that way, a *further* derived class can specify its own name
//  
//
////////////////////////////////////////////////////////////////////////
Provider::Provider( LPCWSTR a_setName, LPCWSTR a_pszNameSpace /*=NULL*/ )
:   CThreadBase(),
    m_pIMosProvider( NULL ),
    m_piClassObject( NULL ),
    m_name( a_setName ),
    m_strNameSpace( a_pszNameSpace )
{
    // Initialize the computer name, then register with the framework.

    InitComputerName();

    CWbemProviderGlue::FrameworkLogin( a_setName, this, a_pszNameSpace );

}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider dtor
//
//  
//
//  Inputs:     none.
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   cleans up our pointer to the IMosProvider
//
////////////////////////////////////////////////////////////////////////
Provider::~Provider( void )
{
    // get out of the framework's hair
    CWbemProviderGlue::FrameworkLogoff( (LPCWSTR)m_name, (LPCWSTR)m_strNameSpace );
    
    // we can't release the interfaces here because CIMOM has a habit
    // of shutting down when it still has interface pointers open.
    /********************
    // Release the pointer returned to us by GetNamespaceConnection(), which 
    // will return us an AddRefed pointer.

    if ( NULL != m_pIMosProvider )
    {
        m_pIMosProvider->Release();
    }

    // The class object is returned to us by IMOSProvider::GetObject, so
    // we should try to release it here when we're done with it.

    if ( NULL != m_piClassObject )
    {
        m_piClassObject->Release();
    }
    ******************************/
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider::InitComputerName
//
//  Initializes our static computer name variable.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Because the idea behind creating providers is that
//              a single static instance is instantiated, this function
//              will most likely be called as part of DLL loading, we'll
//              introduce some thread safety here using a named mutex
//              but won't worry too much about it other than that.
//
////////////////////////////////////////////////////////////////////////
void Provider::InitComputerName( void )
{
    // For performance, check if the value is empty.  Only if it
    // is, should we then bother with going through a thread-safe
    // static initialization.  Because we are using a named mutex,
    // multiple threads will get the same kernel object, and will
    // be stop-gapped by the OS as they each acquire the mutex
    // in turn.

    if ( s_strComputerName.IsEmpty() )
    {
        CreateMutexAsProcess createMutexAsProcess(WBEMPROVIDERSTATICMUTEX);

        // Double check in case there was a conflict and somebody else
        // got here first.

        if ( s_strComputerName.IsEmpty() )
        {
            DWORD   dwBuffSize = MAX_COMPUTERNAME_LENGTH + 1;

            // Make sure the string buffer will be big enough to handle the
            // value.

            LPWSTR  pszBuffer = s_strComputerName.GetBuffer( dwBuffSize );

            if ( NULL != pszBuffer )
            {
                // Now grab the computer name and release the buffer, forcing
                // it to reallocate itself to the new length.

                if (!FRGetComputerName( pszBuffer, &dwBuffSize )) {
                    wcscpy(pszBuffer, L"DEFAULT");
                }
                s_strComputerName.ReleaseBuffer();
            }   // IF NULL != pszBuffer

        }   // IF strComputerName.IsEmpty()

    }   // IF strComputerName.IsEmpty()

}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Flush
//
//  flushes out all unnecessary memory usage
//  inlcuding the (unimplemented) cache
//  and the class object we clone from
//
//  Inputs:     nope
//
//  Outputs:    
//
//  Return:     the eternal void
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
void Provider::Flush()
{
    // TODO: implement cache flush
    BeginWrite();

    try
    {
        if (m_piClassObject)
        {
            m_piClassObject->Release();
            m_piClassObject = NULL;
        }

        if ( NULL != m_pIMosProvider )
        {
            m_pIMosProvider->Release();
            m_pIMosProvider = NULL;
        }
    }
    catch ( ... )
    {
        EndWrite();
        throw;
    }
    EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ValidateIMOSPointer
//
//  Verifies in a threadsafe manner, that our IWBEMServices pointer
//  is okay.
//
//  Inputs:     None.
//
//  Outputs:    
//
//  Return:     TRUE/FALSE      success/failure
//
//  Comments:   Requires that our NameSpace be valid.
//
////////////////////////////////////////////////////////////////////////

BOOL Provider::ValidateIMOSPointer( )
{

    // if we don't have a Namespace connection, get one.  Be aware that for
    // speed's sake we are testing the value outside of a critical section, but
    // because two threads may enter this block of code simultaneously, this
    // block is testing one more time inside the critical sections.

//    if ( NULL == m_pIMosProvider )
//    {
//        BeginWrite();
//
//        try
//        {
//
//            // See above (it's a redundant test), but keeps us from leaking and
//            // overwriting the value twice.
//
//            if ( NULL == m_pIMosProvider )
//            {
//                m_pIMosProvider = CWbemProviderGlue::GetNamespaceConnection( m_strNameSpace, pwszIID );
//            }
//        }
//        catch ( ... )
//        {
//            EndWrite();
//            throw;
//        }
//
//        EndWrite();
//    }
//
//    if (m_pIMosProvider == NULL)
//    {
//        throw CFramework_Exception(L"ValidateIMOSPointer failed");
//    }
//
//    return ( NULL != m_pIMosProvider );

    return TRUE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CreateNewInstance
//
//  
//
//  Inputs:     MethodContext* - context that this instance belongs to
//
//  Outputs:    
//
//  Return:     CInstance*
//
//  Comments:   caller is responsible for memory
//
////////////////////////////////////////////////////////////////////////
CInstance* Provider::CreateNewInstance( MethodContext*  pMethodContext )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CInstance* pNewInstance = NULL;
    IWbemClassObjectPtr pClassObject (GetClassObjectInterface(pMethodContext), false);

    IWbemClassObjectPtr piClone;
    hr = pClassObject->SpawnInstance(0, &piClone);
    if (SUCCEEDED(hr))
    {
        // The Instance is responsible for its own AddRef/Releasing
        pNewInstance = new CInstance(piClone, pMethodContext);

        if (pNewInstance == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }
    else
    {
        throw CFramework_Exception(L"SpawnInstance failed", hr);
    }

    
    return pNewInstance;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Commit
//
//  sends instance to CIMOM
//
//  Inputs:     CInstance* pInstance - the instance to pass off to cimom, 
//              bool bCache - should we cache this puppy? (unimplemented)
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   do not reference pointer once committed, it may not exist any more!
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::Commit(CInstance* pInstance, bool bCache /* = false*/)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // allow derived classes to fill out extra info.
//    GetExtendedProperties(pInstance);
    hRes = pInstance->Commit();

    // TODO: Implement cache
    // if !bCache...

    // We're done with pInstance, so...
    pInstance->Release();

   return hRes;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ExecuteQuery
//
//  
//
//  Inputs:     IWbemContext __RPC_FAR *    pCtx,
//
//  Outputs:    
//
//  Return:     HRESULT
//
//  Comments:   Calls a provider's ExecQuery function, or returns
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::ExecuteQuery( MethodContext* pContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = ValidateQueryFlags(lFlags);
    
    // Make sure we've got Managed Object Services avaliable, as we will need
    // it to get WBEMClassObjects for constructing Instances.
    
    if ( SUCCEEDED(hr) && ValidateIMOSPointer( ) )
    {
        // Check to see if this is an extended query
        CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
        if (pQuery2->IsExtended())
        {
            // It is an extended query.  Does the provider support them?
            if (FAILED(ValidateQueryFlags(WBEM_FLAG_FORWARD_ONLY)))
            {
                // We have an extended query, but the provider doesn't support it
                hr = WBEM_E_INVALID_QUERY;
            }
        }

        if (SUCCEEDED(hr))
        {    
            // Tell cimom he's got work to do on the instances when we send
            // them back.
            pContext->QueryPostProcess();
        
            // If the client hasn't overridden the class, we get back 
            // WBEM_E_PROVIDER_NOT_CAPABLE.  In that case, call the enumerate, and let
            // CIMOM do the work
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
            hr = ExecQuery(pContext, pQuery, lFlags);
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
        
            if (hr == WBEM_E_PROVIDER_NOT_CAPABLE) 
            {
                // Get the instances
                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
                hr = CreateInstanceEnum(pContext, lFlags);
                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
            }
        }
        else
        {
            hr = WBEM_E_INVALID_QUERY;
        }
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CreateInstanceEnum
//
//  
//
//  Inputs:     IWbemContext __RPC_FAR *    pCtx,
//              IWbemObjectSink __RPC_FAR * pResponseHandler
//  Outputs:    
//
//  Return:     
//
//  Comments:   enumerate all instances of this class
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::CreateInstanceEnum( MethodContext*    pContext, long lFlags /*= 0L*/ )
{
    HRESULT sc = ValidateEnumerationFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will need
    // it to get WBEMClassObjects for constructing Instances.

    if ( SUCCEEDED(sc) && ValidateIMOSPointer( ) )
    {
        PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
        sc = EnumerateInstances( pContext, lFlags );
        PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
    }

    return sc;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   PutInstance
//
//  CIMOM wants us to put this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::PutInstance(const CInstance& newInstance, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   PutInstance
//
//  CIMOM wants us to put this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::PutInstance( IWbemClassObject __RPC_FAR *pInst,
                             long lFlags,
                             MethodContext* pContext )
{
    HRESULT scode = ValidatePutInstanceFlags(lFlags);

    // No need to AddRef()/Release() pInst here, since we're just
    // passing it into the CInstance object, which should take
    // care of that for us internally.

    if (SUCCEEDED(scode))
    {
        CInstancePtr   pInstance (new CInstance( pInst, pContext ), false);

        if ( NULL != pInstance )
        {
            scode = PutInstance(*pInstance, lFlags);
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return scode;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   DeleteInstance
//
//  CIMOM wants us to delete this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::DeleteInstance(const CInstance& newInstance, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   DeleteInstance
//
//  CIMOM wants us to put this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::DeleteInstance( ParsedObjectPath* pParsedObjectPath,
                                  long lFlags,
                                  MethodContext* pContext )
{
    HRESULT sc = ValidateDeletionFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will 
    // need it in order to create a brand new instance.

    if ( SUCCEEDED(sc) && ValidateIMOSPointer( ) )
    {
        CInstancePtr   pInstance (CreateNewInstance( pContext ), false);

        // Load up the instance keys
        if ( SetKeyFromParsedObjectPath( pInstance, pParsedObjectPath ) )
        {
            sc = DeleteInstance(*pInstance, lFlags);
        }
        else
        {
            sc = WBEM_E_INVALID_OBJECT_PATH;
        }

    }

    return sc;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ExecMethod
//
//  CIMOM wants us to execute this method on this instance
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::ExecMethod(const CInstance& pInstance, 
                             BSTR bstrMethodName, 
                             CInstance *pInParams, 
                             CInstance *pOutParams, 
                             long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ExecMethod
//
//  CIMOM wants us to Execute this method on this instance
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::ExecMethod( ParsedObjectPath *pParsedObjectPath,
                              BSTR bstrMethodName,
                              long lFlags,
                              CInstance *pInParams,
                              CInstance *pOutParams,
                              MethodContext *pContext )
{
    HRESULT sc = ValidateMethodFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will 
    // need it in order to create a brand new instance.

    if ( SUCCEEDED(sc) && ValidateIMOSPointer( ) )
    {

        CInstancePtr   pInstance(CreateNewInstance( pContext ), false);

        if ( SetKeyFromParsedObjectPath( pInstance, pParsedObjectPath ) ) 
        {
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
            sc = ExecMethod(*pInstance, bstrMethodName, pInParams, pOutParams, lFlags);
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
        }
        else
        {
            sc = WBEM_E_INVALID_OBJECT_PATH;
        }

    }

    return sc;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetObject
//
//  called by the framework in response to a GetObject from CIMOM
//
//  Inputs:     ParsedObjectPath*       pParsedObjectPath - All the news
//                                      thats fit to print. 
//              IWbemContext __RPC_FAR* pCtx
//              IWbemObjectSink __RPC_FAR*pResponseHandler
//
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::GetObject(  ParsedObjectPath *pParsedObjectPath,
                              MethodContext *pContext, 
                              long lFlags /*= 0L*/ )
{
    HRESULT hr = ValidateGetObjFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will 
    // need it in order to create a brand new instance.

    if ( SUCCEEDED(hr) && ValidateIMOSPointer( ) )
    {
        CInstancePtr pInstance (CreateNewInstance( pContext ), false);

        // Load up the instance keys
        if ( SetKeyFromParsedObjectPath( pInstance, pParsedObjectPath ) )
        {
            // Look for per-property gets
            IWbemContextPtr pWbemContext (pContext->GetIWBEMContext(), false);

            CFrameworkQueryEx CQuery;
            hr = CQuery.Init(pParsedObjectPath, pWbemContext, GetProviderName(), m_strNameSpace);

            // Note that 'SUCCEEDED' DOESN'T mean that we have per-property gets.  It
            // just means that the query object was successfully initialized.
            if (SUCCEEDED(hr))
            {
                // Fill in key properties on query object
                IWbemClassObjectPtr pWbemClassObject(pInstance->GetClassObjectInterface(), false);
                CQuery.Init2(pWbemClassObject);

                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
                hr = GetObject(pInstance, lFlags, CQuery);
                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
            }
        }
        else
        {
            hr = WBEM_E_INVALID_OBJECT_PATH;
        }

        if (SUCCEEDED(hr))
        {
            // Account for the possibility that we have a SUCCESS code back from GetObject.
            HRESULT hRes = pInstance->Commit();
            hr = __max((ULONG)hRes, (ULONG)hr);
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider::GetInstancePath
//
//  Attempts to build an instance path for the supplied CInstance pointer.
//
//  Inputs:     const CInstance*    pInstance - Instance to build path for.
//
//  Outputs:    CHString&           strPath - Path from instance.
//
//  Return:     BOOL                Success/Failure.
//
//  Comments:   This function was created to help support the internal
//              short circuit we performed for obtaining local WBEM
//              Provider objects.  In this instance, we will use our
//              computer system name, namespace and instance relative
//              path to munge together a full WBEM Object Path.  This
//              is because only CIMOM objects will have this value set
//              and when we perform our short circuit, we cut CIMOM
//              out of the loop, so our instances don't have full
//              object paths.  This mostly helps out our association
//              logic, although a weakness of this solution is that
//              if the path that gets stored by CIMOM changes, we
//              will then need to change this function.
//
////////////////////////////////////////////////////////////////////////
bool Provider::GetLocalInstancePath( const CInstance *pInstance, 
                                     CHString& strPath )
{
    bool        fReturn = false;
    CHString    strRelativePath;

    if (pInstance && pInstance->GetCHString( L"__RELPATH", strRelativePath ) )
    {
        // We may want to use the OBJPath classes to piece this
        // together for us at a later time.

        strPath = MakeLocalPath(strRelativePath);

        fReturn = true;
    }

    return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider::MakeLocalPath
//
//  Builds a full instance path from a relative path
//
//  Inputs:     const CHString &strRelPath - Relative path
//
//  Outputs:    
//
//  Return:     CHString&           strPath - Path 
//
//  Comments:   Consider using GetLocalInstance path before using 
//             this function.
//
////////////////////////////////////////////////////////////////////////
CHString Provider::MakeLocalPath( const CHString &strRelPath )
{

    ASSERT_BREAK( (strRelPath.Find(L':') == -1) || ((strRelPath.Find(L'=') != -1) && (strRelPath.Find(L':') >= strRelPath.Find(L'=')) ));
    
    CHString sBase;
    
    sBase.Format(L"\\\\%s\\%s:%s", 
        (LPCWSTR)s_strComputerName, 
        m_strNameSpace.IsEmpty() ? DEFAULT_NAMESPACE: (LPCWSTR) m_strNameSpace, 
        (LPCWSTR)strRelPath);

    return sBase;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetKeyFromParsedObjectPath
//
//  called by the DeleteInstance and GetObject in order to load a
//  CInstance* with the key values in an object path.
//
//  Inputs:     CInstance*              pInstance - Instance to store
//                                      key values in.
//              ParsedObjectPath*       pParsedObjectPath - All the news
//                                      thats fit to print. 
//
//
//  Outputs:    
//
//  Return:     BOOL                Success/Failure
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

BOOL Provider::SetKeyFromParsedObjectPath( CInstance *pInstance, 
                                           ParsedObjectPath *pParsedPath )
{
    BOOL    fReturn = TRUE;
    SAFEARRAY *pNames = NULL;
    long lLBound, lUBound;
    
    // populate instance - This exact same routine is in wbemglue.cpp.  Changes here should be
    // reflected there (or someone should move these two somewhere else. instance.cpp?).
    for (DWORD i = 0; fReturn && i < (pParsedPath->m_dwNumKeys); i++)
    {
        if (pParsedPath->m_paKeys[i])
        {
            // If a name was specified in the form class.keyname=value
            if (pParsedPath->m_paKeys[i]->m_pName != NULL) 
            {
                fReturn = pInstance->SetVariant(pParsedPath->m_paKeys[i]->m_pName, pParsedPath->m_paKeys[i]->m_vValue);
            } 
            else 
            {
                // There is a special case that you can say class=value
                fReturn = FALSE;
                
                // only one key allowed in the format.  Check the names on the path
                if (pParsedPath->m_dwNumKeys == 1) 
                {
                    
                    // Get the names from the object
                    if (m_piClassObject->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pNames) == WBEM_S_NO_ERROR) 
                    {
                        BSTR t_bstrName = NULL ;
                        
                        try
                        {
                            SafeArrayGetLBound(pNames, 1, &lLBound);
                            SafeArrayGetUBound(pNames, 1, &lUBound);
                      
                            // Only one key?
                            if ((lUBound - lLBound) == 0) 
                            {                            
                                // Get the name of the key field and set it
                                SafeArrayGetElement(pNames, &lUBound, &t_bstrName );
                                
                                fReturn = pInstance->SetVariant( t_bstrName, pParsedPath->m_paKeys[i]->m_vValue);
                            }
                        }
                        catch ( ... )
                        {
                            if( NULL != t_bstrName )
                            {
                                SysFreeString( t_bstrName ) ;
                            }

                            SafeArrayDestroy(pNames);
                            throw;
                        }

                        SafeArrayDestroy(pNames);
                    }
                }
                ASSERT_BREAK(fReturn); // somebody lied about the number of keys or the datatype was wrong
            }
        }
        else
        {
            ASSERT_BREAK(0); // somebody lied about the number of keys!
            fReturn = FALSE;
        }
    }
    
    return fReturn;
}

// sets the CreationClassName to the name of this provider
bool Provider::SetCreationClassName(CInstance* pInstance)
{
    if (pInstance)
    {
        return pInstance->SetCHString(IDS_CreationClassName, m_name);
    }
    else
    {
        return false;
    }
}


// flag validation - returns WBEM_E_UNSUPPORTED parameter if 
// lFlags contains any flags not found in lAcceptableFlags
HRESULT Provider::ValidateFlags(long lFlags, FlagDefs lAcceptableFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // invert the acceptable flags, which then are the UNacceptable flags
    if (lFlags & ~((long)lAcceptableFlags))
        hr = WBEM_E_UNSUPPORTED_PARAMETER;
    else
        hr = WBEM_S_NO_ERROR;

    return hr;
}
// base level validation routines
// you can override these in order to support a flag
// that is unknown to the base class
HRESULT Provider::ValidateEnumerationFlags(long lFlags)
{
    return ValidateFlags(lFlags, EnumerationFlags);
}
HRESULT Provider::ValidateGetObjFlags(long lFlags)
{
    return ValidateFlags(lFlags, GetObjFlags);
}
HRESULT Provider::ValidateMethodFlags(long lFlags)
{
    return ValidateFlags(lFlags, MethodFlags);
}
HRESULT Provider::ValidateQueryFlags(long lFlags)
{
    return ValidateFlags(lFlags, QueryFlags);
}
HRESULT Provider::ValidateDeletionFlags(long lFlags)
{
    return ValidateFlags(lFlags, DeletionFlags);
}
HRESULT Provider::ValidatePutInstanceFlags(long lFlags)
{
    return ValidateFlags(lFlags, PutInstanceFlags);
}

IWbemClassObject* Provider::GetClassObjectInterface(MethodContext *pMethodContext)
{
    IWbemClassObject *pObject = NULL;

    if (ValidateIMOSPointer())
    {
		BOOL bWriting = TRUE;
        BeginWrite();

        try
        {
            if ( NULL == m_piClassObject )
            {
				bWriting = FALSE;

				//calling back into winmgmt - no critsec!
				EndWrite();

                IWbemContextPtr pWbemContext;

                if ( NULL != pMethodContext )
                {
                    pWbemContext.Attach(pMethodContext->GetIWBEMContext());
                }

                IWbemServicesPtr pServices(CWbemProviderGlue::GetNamespaceConnection( m_strNameSpace, pMethodContext ), false);


                HRESULT hr = pServices->GetObject( bstr_t( m_name ), 0L, pWbemContext, &pObject, NULL);

		        BeginWrite();
				bWriting = TRUE;

                if (SUCCEEDED(hr))
                {
					if (m_piClassObject == NULL)
					{
						m_piClassObject = pObject;
						pObject->AddRef();
					}
                }
                else
                {
                    // belt & suspenders check. Won't hurt.
                    m_piClassObject = NULL;

                    throw CFramework_Exception(L"SpawnInstance failed", hr);
                }
            }
            else
            {
                pObject = m_piClassObject;
                pObject->AddRef();
            }
        }
        catch ( ... )
        {
			if (bWriting)
			{
				EndWrite();
			}

			if (pObject)
			{
				pObject->Release();
				pObject = NULL;
			}

            throw;
        }

        EndWrite();
    }

    return pObject;
}

// If a provider wants to process queries, they should override this
HRESULT Provider::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

// find and create all instances of your class
HRESULT Provider::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

// you will be given an object with the key properties filled in.
// you need to fill in all of the rest of the properties
HRESULT Provider::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

// You will be given an object with the key properties filled in.
// You can either fill in all the properties, or check the Query object
// to see what properties are required.
HRESULT Provider::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query)
{
    // If we are here, the provider didn't override this method.  Fall back to the older
    // call.
   return GetObject(pInstance, lFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\stllock.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  StlLock.cpp
//
//  Purpose: implements the STL lockit class to avoid linking to msvcprt.dll
//
//***************************************************************************

#include "precomp.h"
#include <stllock.h>

__declspec(dllexport) CCritSec g_cs;

std::_Lockit::_Lockit()
{
    g_cs.Enter();
}

std::_Lockit::~_Lockit()
{
    g_cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\rundll.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  RunDll.cpp
//
//  Purpose: Allow framework to be used to run a command
//
//***************************************************************************

#include "precomp.h"

// This routine is meant to be called from RUNDLL32.EXE
extern "C" {
__declspec(dllexport) VOID CALLBACK
DoCmd(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{

    DWORD dwRet = WBEM_E_OUT_OF_MEMORY;
    BOOL bRet = FALSE;
    char *pBuff = (char *)calloc(strlen(lpszCmdLine) + 1, sizeof(char));

    if (pBuff) 
    {
        dwRet = WBEM_E_FAILED;

        try
        {
            // Parse the passed in command line to figure out what command we
            // are being asked to run.
            sscanf(lpszCmdLine, "%s ", pBuff);

            dwRet = ERROR_INVALID_FUNCTION;
            
            // Find out which command
            if (_stricmp(pBuff, "ExitWindowsEx") == 0) 
            {
                // Parse out the parameters for this command
                DWORD dwFlags, dwReserved;
                if (sscanf(lpszCmdLine, "%s %d %d ", pBuff, &dwFlags, &dwReserved) == 3) 
                {
                    // Clear the error (it appears ExitWindowsEx doesn't always clear old data)
                    SetLastError(0);

                    bRet = ExitWindowsEx(dwFlags, dwReserved);
                    dwRet = GetLastError();
                }
            }
            else if (_stricmp(pBuff, "InitiateSystemShutdown") == 0) 
            {
                // Parse out the parameters for this command
                DWORD dwFlags, dwReserved;
                bool bRebootAfterShutdown = false;
                bool bForceShutDown = false;

                if (sscanf(lpszCmdLine, "%s %d %d ", pBuff, &dwFlags, &dwReserved) == 3) 
                {
                    // Clear the error (it appears ExitWindowsEx doesn't always clear old data)
                    SetLastError(0);

                    if(dwFlags & EWX_REBOOT)
                    {
				        bRebootAfterShutdown = true;
                    }
			        if( dwFlags & EWX_FORCE)
				    {
                        bForceShutDown = true;
                    }

                    WCHAR wstrComputerName[MAX_COMPUTERNAME_LENGTH + 1] = { '\0' };
                    DWORD dwSize;

                    if(::GetComputerName(wstrComputerName, &dwSize))
                    {

                        bRet = InitiateSystemShutdown(
                            wstrComputerName, 
                            NULL, 
                            0 /* dwTimeout */, 
                            (bForceShutDown)? TRUE:FALSE, 
                            (bRebootAfterShutdown)? TRUE:FALSE );

                        dwRet = GetLastError();
                    }
                    else
                    {
                        dwRet = GetLastError();
                    }
                }
            }
        }
        catch ( ... )
        {
            free(pBuff);
        }

        free(pBuff);
    }

    // NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 
    //
    // We are aborting out at this point, since RunDLL32 in its finite wisdom doesn't allow
    // for the setting of the dos error level (who designs this stuff?).
    if (!bRet)
    {
        ExitProcess(dwRet);
    }

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\sources.inc ===
#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
#
#   All rights reserved.
#
############################################################################

WMIUNICODE=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

FRAMEDYN_INC=$(SDK)\FrameDyn\Include

TARGETPATH=obj
TARGETTYPE=DYNLINK

PRECOMPILED_OBJ=preframe.obj

TARGETLIBS= \
	$(COMMON_NEWTHROW_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
\
#FOR CloseProfileUserMapping...
\
	$(SDK_LIB_PATH)\kernl32p.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\Secur32.lib \

INCLUDES=$(INCLUDES); \
	$(COMMON_NEWTHROW_INC); \
	$(WMIIDL_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(FRAMEDYN_PRIVATE); \
	$(FRAMEDYN_INC);\
\
#FOR CloseProfileUserMapping...
\
	$(BASE_INC_PATH);

SOURCES= \
	..\stllock.cpp \
	..\brodcast.cpp \
	..\clsfctry.cpp \
	..\createmutexasprocess.cpp \
	..\EventProvider.cpp \
	..\FRQuery.cpp \
	..\FRQueryEx.cpp \
	..\FWStrings.cpp \
	..\Instance.cpp \
	..\MethodContext.cpp \
	..\MultiPlat.cpp \
	..\Provider.cpp \
	..\RunDLL.cpp \
	..\ThreadBase.cpp \
	..\Wbemglue.cpp \
	..\objpath.cpp \
	..\genlex.cpp \
	..\opathlex.cpp \
	..\winmsgevent.cpp

C_DEFINES=$(C_DEFINES) /DUSE_POLARITY /DBUILDING_DLL /D_WINDLL /D_WIN32_DCOM /DFRAMEWORK_ALLOW_DEPRECATED=0
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
USE_RTTI=1
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup

DLLDEF=$(O)\$(TARGETNAME).def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\wbemglue.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  WBEMGLUE.CPP
//
//  Purpose: Implementation of CWbemProviderGlue class
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <eventProvider.h>
#include <FRQueryEx.h>
#include <cnvmacros.h>
#include <BrodCast.h>
#include <cominit.h>
#include <StopWatch.h>
#include <comdef.h>
#include <SmartPtr.h>
#include <lmcons.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <Secext.h>
#include "FWStrings.h"
#include "MultiPlat.h"
#include <AutoImpRevert.h>
#include <lockwrap.h>

#include <winbasep.h>

class CWbemGlueImpersonation
{
	CWbemGlueImpersonation ( const CWbemGlueImpersonation& ) {}

	HRESULT m_hr;

	public:

	CWbemGlueImpersonation () : m_hr ( E_FAIL )
	{
		m_hr = CWbemProviderGlue::CheckImpersonationLevel ();
	}

	~CWbemGlueImpersonation ()
	{
		if SUCCEEDED ( m_hr )
		{
			WbemCoRevertToSelf ();
		}
	}

	HRESULT IsImpersonated () const
	{
		return m_hr;
	}
};

#define GLUETIMEOUT WBEM_INFINITE //(3 * 60 * 1000)

// Used in ASSERT_BREAK to give meaningful messages
#define DEPRECATED 1
#define MEMORY_EXHAUSTED 0
#define FRAMEWORK_EXCEPTION 0
#define UNSPECIFIED_EXCEPTION 0
#define STRUCTURED_EXCEPTION 0
#define DUPLICATE_RELEASE 0
#define IMPERSONATION_REVERTED 0
#define UNNECESSARY_CWBEMPROVIDERGLUE_INSTANCE 0

// Initialize Statics
STRING2LPVOID       CWbemProviderGlue::s_providersmap;
CCritSec            CWbemProviderGlue::s_csFactoryMap;
PTR2PLONG           CWbemProviderGlue::s_factorymap;
CCritSec            CWbemProviderGlue::s_csProviderMap;
CCritSec            CWbemProviderGlue::m_csStatusObject;
IWbemClassObject    *CWbemProviderGlue::m_pStatusObject = NULL;
BOOL                CWbemProviderGlue::s_bInitted = FALSE;
DWORD               CWbemProviderGlue::s_dwPlatform = 0;
DWORD               CWbemProviderGlue::s_dwMajorVersion = 0;
WCHAR               CWbemProviderGlue::s_wstrCSDVersion[128] = {0};

long                CWbemProviderGlue::s_lObjects = 0;

// Static Provider we use to initialize, uninitialize our static
// data.  We should be able to assume at Construct/Destruct time that
// we (the DLL) are being loaded/unloaded.
// later on -- we should, but we can't.  Current model is that we
// uninitialize when the last DLL that we service has called DLLLogoff,
// which had better be in response to "DllCanUnloadNow"

CWbemProviderGlue   g_wbemprovider;


/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::CWbemProviderGlue
//
//  Class CTor.  Uses static initialization functon to get static data
//  ready if this is the first instance of our object.
//
//  Inputs:     None
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

CWbemProviderGlue::CWbemProviderGlue()
:   m_strNamespace(),
m_lRefCount(0),
m_pCount(NULL),
m_pServices(NULL)
{
    Init();
}

CWbemProviderGlue::CWbemProviderGlue(PLONG pCount)
:   m_strNamespace(),
m_lRefCount(0),
m_pCount(pCount),
m_pServices(NULL)
{
    CWbemProviderGlue::IncrementMapCount(pCount);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::~CWbemProviderGlue
//
//  Class DTor.
//
//  Inputs:     None
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

CWbemProviderGlue::~CWbemProviderGlue()
{
    // Note that the item we are destructing here was not added in
    // the constructor, but in Initialize().
    if (m_pServices)
    {
        m_pServices->Release();
    }

    if (m_pCount != NULL)  // Indicates the static instance
    {
        if (DecrementMapCount(m_pCount) == 0)
        {
            FlushAll();
        }
    }
    else
    {
        UnInit();
    }
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::Init
//
//  Static initialization function for initializing critical sections
//  and such for making our static data thread-safe.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   Because we are protecting static data, we are using
//              a named mutex.  Construction and Destruction of object
//              instances should call these functions.
//
/////////////////////////////////////////////////////////////////////

void CWbemProviderGlue::Init( void )
{
    LogMessage(IDS_GLUEINIT);

    if (!s_bInitted)
    {
        // Note that we *have* to use the ansi version at this point,
        // since this is where we decide whether to use the ansi functions
        // or the unicode ones.
        OSVERSIONINFOA OsVersionInfoA;

        OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
        GetVersionExA(&OsVersionInfoA);

        s_dwPlatform = OsVersionInfoA.dwPlatformId;
        s_dwMajorVersion = OsVersionInfoA.dwMajorVersion;

        if (OsVersionInfoA.szCSDVersion == NULL)
        {
            s_wstrCSDVersion[0] = L'\0';
        }
        else
        {
            bool t_ConversionFailure = false ;
            WCHAR *wcsBuffer = NULL ;
            ANSISTRINGTOWCS(OsVersionInfoA.szCSDVersion, wcsBuffer, t_ConversionFailure );
            if ( ! t_ConversionFailure )
            {
                if ( wcsBuffer )
                {
                    wcscpy(s_wstrCSDVersion, wcsBuffer);
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
// Should do something here since we know version is not initialised.
            }
        }

        s_bInitted = TRUE;
    }
    else
    {
        ASSERT_BREAK(UNNECESSARY_CWBEMPROVIDERGLUE_INSTANCE);
    }
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::UnInit
//
//  Static cleanup function for cleaning up critical sections
//  and such for making our static data thread-safe.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   Because we are protecting static data, we are using
//              a named mutex.  Construction and Destruction of object
//              instances should call these functions.
//
/////////////////////////////////////////////////////////////////////

void CWbemProviderGlue::UnInit( void )
{
    LogMessage(IDS_GLUEUNINIT);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetStaticMutex
//
//  Creates and returns an instance of the named mutex used to
//  protect our static initialization functions.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   The mutex, although it is named, makes the process
//              id part of the name, guaranteeing that it is still
//              unique across processes.
//
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::QueryInterface
//
//  COM function called to ask us if we support a particular
//  face type.  If so, we addref ourselves and return the
//  ourselves as an LPVOID.
//
//  Inputs:     REFIID          riid - Interface being queried for.
//
//  Outputs:    LPVOID FAR*     ppvObj - Interface pointer.
//
//  Returns:    None.
//
//  Comments:   The only interfaces we support are IID_IUnknown and
//              IID_IWbemServices.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemProviderGlue::QueryInterface( REFIID riid, LPVOID FAR *ppvObj )
{
    LogMessage(L"CWbemProviderGlue::QueryInterface");

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IWbemServices *) this;
    }
    else if (IsEqualIID(riid, IID_IWbemServices))
    {
        *ppvObj = (IWbemServices *) this;
    }
    else if (IsEqualIID(riid, IID_IWbemProviderInit))
    {
        *ppvObj = (IWbemProviderInit *) this;
    }
    else
    {
        try
        {
            *ppvObj = NULL ;
            if (IsVerboseLoggingEnabled())
            {
                WCHAR      wcID[128];
                StringFromGUID2(riid, wcID, 128);

                LogMessage2(L"CWbemProviderGlue::QueryInterface - unsupported interface (%s)", wcID);
            }
        }
        catch ( ... )
        {
        }

        return ResultFromScode(E_NOINTERFACE) ;
    }

    AddRef() ;

    return NOERROR ;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddRef
//
//  Increments the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   Requires that a correponding call to Release be
//              performed.
//
/////////////////////////////////////////////////////////////////////

ULONG CWbemProviderGlue::AddRef( void )
{
    CSetStructuredExceptionHandler t_ExceptionHandler;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            // this will be an approximation because another thread could come through...
            LogMessage2(L"CWbemProviderGlue::AddRef, count is (approx) %d", m_lRefCount +1);
        };
    }
    catch ( ... )
    {
    }

    // InterlockedIncrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.

    return InterlockedIncrement( &m_lRefCount );
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::Intialize
//
//  Inputs:     Many.
//
//  Outputs:    None.
//
//  Returns:
//
//  Comments:   any global initializations, esp those that call CIMOM should go here.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::Initialize(
                                      /* [in] */ LPWSTR pszUser,
                                      /* [in] */ LONG lFlags,
                                      /* [in] */ LPWSTR pszNamespace,
                                      /* [in] */ LPWSTR pszLocale,
                                      /* [in] */ IWbemServices __RPC_FAR *pNamespace,
                                      /* [in] */ IWbemContext __RPC_FAR *pCtx,
                                      /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    CSetStructuredExceptionHandler t_ExceptionHandler;
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s(%s)", IDS_GLUEINITINTERFACE, pszNamespace);
        }
    }
    catch ( ... )
    {
    }

    if ( (NULL != pszNamespace) && (NULL != pNamespace) )
    {
        try
        {
            // this may come back to bite me
            // CIMOM promises that this will only be called on one thread, once per object
            // and that no queries will be issued until after initialize is called.
            // therefore - I don't need a critical section, here -
            m_strNamespace = pszNamespace;
            m_strNamespace.MakeUpper();

            pNamespace->AddRef();
            m_pServices = pNamespace;
        }
        catch ( CFramework_Exception e_FR )
        {
            ASSERT_BREAK(FRAMEWORK_EXCEPTION);
            hr = WBEM_E_PROVIDER_FAILURE;
        }
        catch ( CHeap_Exception e_HE )
        {
            ASSERT_BREAK(MEMORY_EXHAUSTED);
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        catch(CStructured_Exception e_SE)
        {
            ASSERT_BREAK(STRUCTURED_EXCEPTION);
            hr = WBEM_E_PROVIDER_FAILURE;
        }
        catch ( ... )
        {
            ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
            hr = WBEM_E_PROVIDER_FAILURE;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if (pInitSink)
    {
        pInitSink->SetStatus(hr, 0);
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::Release
//
//  Decrements the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

ULONG CWbemProviderGlue::Release()
{
    // InterlockedDecrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.

    // We want to hold the value locally in case two threads
    // Release at the same time and one gets a final release,
    // and deletes, leaving a potential window in which a thread
    // deletes the object before the other returns and tries to
    // reference the value from within the deleted object.

    CSetStructuredExceptionHandler t_ExceptionHandler;
    ULONG   nRet = InterlockedDecrement( &m_lRefCount );

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage2(L"CWbemProviderGlue::Release, count is (approx) %d", m_lRefCount);
        }
    }
    catch ( ... )
    {
    }

    if( 0 == nRet )
    {
        try
        {
            LogMessage(IDS_GLUEREFCOUNTZERO);
        }
        catch ( ... )
        {
        }
        delete this;
    } else if (nRet > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
    }

    return nRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FlushAll
//
//  Inputs:     voidness
//
//  Outputs:    more voidness
//
//  Returns:    see above
//
//  Comments:   flushes caches, calls all of the provider's flushes.
//              no need to flush event providers map, flush will be
//              called on the provider pointer
//
/////////////////////////////////////////////////////////////////////
void CWbemProviderGlue::FlushAll(void)
{
    PROVIDERPTRS::iterator      setIter;

    // We DEFINITELY want to protect the Map while this is running!
    LockProviderMap();

    try
    {
        // pProvider doesn't get addref'ed, so doesn't need to be released
        Provider *pProvider = NULL;

        CLockWrapper lockwrap(m_csFlushPtrs);

        for (setIter = m_FlushPtrs.begin(); setIter != m_FlushPtrs.end(); setIter++)
        {
            pProvider = (Provider*) *setIter;
            if ( pProvider != NULL )
            {
                // If one provider poops out, try the others.
                try
                {
                    pProvider->Flush();
                }
                catch ( ... )
                {
                }
            }
        }

        m_FlushPtrs.clear();
    }
    catch ( ... )
    {
        UnlockProviderMap();
        throw;
    }

    UnlockProviderMap();

    if (m_pStatusObject)
    {
        m_csStatusObject.Enter();
        if (m_pStatusObject)
        {
            m_pStatusObject->Release();
            m_pStatusObject = NULL;
        }
        m_csStatusObject.Leave();
    }
}

// SetStatusObject
// sets the properties in the extended status object so that it can be returned when
// the glue layer calls SetStatus at the end of the method invocation.
// will return false if the status object has already been filled.
// (first one in wins)
bool CWbemProviderGlue::SetStatusObject(

    MethodContext *pContext,
    LPCWSTR pNamespace,
    LPCWSTR pDescription,
    HRESULT hr,
    const SAFEARRAY *pPrivilegesNotHeld,/* = NULL */
    const SAFEARRAY *pPrivilegesRequired/* = NULL */
)
{
    bool bRet = false;

    ASSERT_BREAK(pContext != NULL);
    if (pContext)
    {
        IWbemClassObjectPtr pObj ( GetStatusObject(pContext, pNamespace), false );

        if (pObj != NULL)
        {
            // Variant_t handles the VariantInit/VariantClear
            variant_t v;

            pContext->SetStatusObject(pObj);

            // set hresult ("StatusCode")
            v.vt   = VT_I4;
            v.lVal = (long)hr;
            pObj->Put(IDS_STATUSCODE, 0, &v, NULL);
            v.Clear();

            // set description
            if (pDescription)
            {
                v = pDescription;

                if (v.bstrVal != NULL)
                {
                    bRet = SUCCEEDED(pObj->Put(IDS_DESCRIPTION, 0, &v, NULL));
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                v.Clear();
            }

            // privileges properties
            if (pPrivilegesNotHeld)
            {
                SAFEARRAY *pSafeArray = NULL;
                // blithy casting away the const...
                if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)pPrivilegesNotHeld, &pSafeArray ) ) )
                {
                    v.vt = VT_BSTR | VT_ARRAY;
                    v.parray = pSafeArray;
                    pObj->Put(IDS_PRIVILEGESNOTHELD, 0, &v, NULL);
                    v.Clear();
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

            if (pPrivilegesRequired)
            {
                SAFEARRAY *pSafeArray = NULL;
                // blithy casting away the const...
                if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)pPrivilegesRequired, &pSafeArray ) ) )
                {
                    v.vt = VT_BSTR | VT_ARRAY;
                    v.parray = pSafeArray;
                    pObj->Put(IDS_PRIVILEGESREQUIRED, 0, &v, NULL);
                    v.Clear();
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
    }

    return bRet;
}

IWbemClassObject *CWbemProviderGlue::GetStatusObject(

    MethodContext *pContext,
    LPCWSTR pNamespace
)
{
    ASSERT_BREAK(pContext != NULL);
    IWbemClassObject *pStatusObj = NULL;

    if (pContext != NULL)
    {
        // first time in, we cache the class object
        if (!m_pStatusObject)
        {
            m_csStatusObject.Enter();

            // check again - someone might have snuck in!
            if (!m_pStatusObject)
            {
                IWbemServicesPtr pSrvc;
                IWbemContextPtr pWbemContext (pContext->GetIWBEMContext(), false);

                pSrvc.Attach ( GetNamespaceConnection( pNamespace, pContext ) ) ;
                if ( pSrvc )
                {
                    // not checking return code, error object should be NULL on error
                    pSrvc->GetObject( bstr_t( IDS_WIN32PRIVILEGESSTATUS ), 0, pWbemContext, &m_pStatusObject, NULL );
                }

            }
            m_csStatusObject.Leave();
        }

        if (m_pStatusObject)
            m_pStatusObject->SpawnInstance(0, &pStatusObj);
    }
    else
    {
        LogErrorMessage(L"NULL parameter to GetStatusObject");
    }

    return pStatusObj;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::ExecQueryAsync
//
//  Place holder for the ExecQuery function.
//
//  Inputs:     const BSTR  QueryFormat - Query Format String
//              const BSTR  Query - The actual query
//              long        lFlags - Additional flags.
//              IWbemContext __RPC_FAR *pCtx - Context we were called in.
//              IWbemObjectSink FAR *pResponseHandler - Response Handler
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::ExecQueryAsync(

    const BSTR QueryFormat,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
        StopWatch stopWatch(CHString(IDS_EXECQUERY) + CHString(Query));
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_EXECQUERY, Query);
        }

        // Now create an External Method Context object and go to town
        ExternalMethodContextPtr  pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

#ifdef PROVIDER_INSTRUMENTATION
        pContext->pStopWatch = &stopWatch;
#endif

        if (pContext != NULL)
        {
            CFrameworkQueryEx CQuery;
//            hr = CQuery.InitEx(QueryFormat, Query, lFlags, m_strNamespace);
            hr = CQuery.Init(QueryFormat, Query, lFlags, m_strNamespace);
            if (SUCCEEDED(hr))
            {
                // Find the class name for the query
                bstr_t bstrClass (CQuery.GetQueryClassName(), false);
                if ((WCHAR *)bstrClass != NULL)
                {
                    // Search for the class name in our map of providers, we know which
                    // namespace we are when we get constructed.
                    // pProvider doesn't get addref'ed, so doesn't need to be released.
                    Provider *pProvider = SearchMapForProvider( bstrClass, m_strNamespace );
                    if ( NULL != pProvider )
                    {

                        // Initialize the CQuery.m_keysonly variable.  Note that we CAN'T do this as part
                        // of Init, because we need the pProvider pointer.  And we can do the init
                        // down here, because we need the bstrClass that we get from Init.  And we can't
                        // do this as part of CQuery.KeysOnly because you can't get the IWbemClassObject
                        // from there.
                        IWbemClassObjectPtr IClass(pProvider->GetClassObjectInterface(pContext), false);
                        if (IClass != NULL)
                        {
                            CQuery.Init2(IClass);

                            // Impersonate connected user
							CWbemGlueImpersonation impersonate;
                            if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                            {
                                // Set up to call FlushAll
                                AddFlushPtr(pProvider);

                                WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                                WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                                DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                                GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                                // Everything is in place, run the query
                                hr = pProvider->ExecuteQuery( pContext, CQuery, lFlags );

                                dwLen = UNLEN + DNLEN + 1 + 1;

                                GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                                if (wcscmp(wszName, wszName2) != 0)
                                {
                                    ASSERT_BREAK(IMPERSONATION_REVERTED);
                                    LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                        wszName2, wszName, Query);
                                }
                            }
                        }
                        else
                        {
                            // we don't know WHY we couldn't get the interface,
                            // generic error it is...
                            hr = WBEM_E_FAILED;
                        }

                    }
                    else
                    {
                        LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, (LPCWSTR)bstrClass);
                        hr = WBEM_E_INVALID_CLASS;
                    }
                }
                else
                {
                    LogErrorMessage(IDS_INVALIDCLASSNAME);
                    hr = WBEM_E_INVALID_CLASS;
                }
            }

            pStatusObject.Attach(pContext->GetStatusObject());
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_EXECQUERY, Query);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_EXECQUERY, Query, hr);
        }
    }
    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // We must call SetStatus so CIMOM doesn't lose any threads.
    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER))
    {
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject);
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif
        hr = WBEM_S_NO_ERROR;
    }

    Release();

#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::CreateInstanceEnumAsync
//
//  Locates the provider for the specified class name and
//  calls its CreateInstanceEnum function.
//
//  Inputs:     const BSTR      Class - Name of provider
//              long            lFlags - Enumeration flags.
//              IWbemContext __RPC_FAR  *pCtxt - Context pointer
//              IWbemObjectSink __RPC_FAR  *pResponseHandler - Response
//                                          handler.
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::CreateInstanceEnumAsync(

    const BSTR a_bstrClass,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
    StopWatch stopWatch(CHString(IDS_CREATEINSTANCEENUM) + CHString(Class));
    stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT hr = WBEM_E_INVALID_CLASS;
    IWbemClassObjectPtr pStatusObject;
    bool bSendStatus = true;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_CREATEINSTANCEENUM, a_bstrClass);
        }

        // Check for per-property gets
        CFrameworkQueryEx CQuery;
        hr = CQuery.Init(NULL, pCtx, a_bstrClass, m_strNamespace);

        // Note that we AREN'T calling Init2, which means if they specified "__RELPATH"
        // as their property, we won't expand that out to the key names.  However, since
        // we are going to call ExecQuery, and it reprocesses the query and DOES call
        // Init2, this isn't an issue.
//        CQuery.Init2(pWbemClassObject);

        // If they are doing per-property gets, then turn this into a query.
        if (SUCCEEDED(hr))
        {
            if (CQuery.AllPropertiesAreRequired())
            {
                // Search for the class name in our map of providers, we know which
                // namespace we are when we get constructed.
                // pProvider doesn't get addref'ed, so no release necessary
                Provider *pProvider = SearchMapForProvider( a_bstrClass, m_strNamespace );

                if ( NULL != pProvider )
                {
                    // Now create an External Method Context object and go to town
                    ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

                    if ( NULL != pContext )
                    {
						CWbemGlueImpersonation impersonate;
                        if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                        {
                            // Set up to call FlushAll
                            AddFlushPtr(pProvider);

                            WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                            WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                            DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                            GetUserNameEx(NameSamCompatible, wszName, &dwLen);

#ifdef PROVIDER_INSTRUMENTATION
                            pContext->pStopWatch = &stopWatch;
#endif
                            hr = pProvider->CreateInstanceEnum( pContext, lFlags );

                            dwLen = UNLEN + DNLEN + 1 + 1;

                            GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                            if (wcscmp(wszName, wszName2) != 0)
                            {
                                ASSERT_BREAK(IMPERSONATION_REVERTED);
                                LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                    wszName2, wszName, a_bstrClass);
                            }
                        }
                        pStatusObject.Attach(pContext->GetStatusObject());
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
                else
                {
                    LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, a_bstrClass);
					hr = WBEM_E_INVALID_CLASS;
                    bSendStatus = false;
                }
            }
            else
            {
                bstr_t bstrtQuery = CQuery.GetQuery();

                hr =
                    ExecQueryAsync(
                        L"WQL",
                        bstrtQuery,
                        lFlags,
                        pCtx,
                        pResponseHandler);

                // Since execquery sent whatever status is necessary
                bSendStatus = false;
            }

        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_CREATEINSTANCEENUM, a_bstrClass);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_CREATEINSTANCEENUM, a_bstrClass, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && bSendStatus)
    {

#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif

        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );

#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif

        hr = WBEM_S_NO_ERROR;
    }

    Release();
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif
    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetObjectAsync
//
//  Parses the supplied object path and hands the request off
//  to the appropriate provider.
//
//  Inputs:     const BSTR      ObjPath - Object Path containing
//                              keys to required object.
//              long            lFlags - Get Object flags.
//              IWbemContext __RPC_FAR  *pCtxt - Context pointer
//              IWbemObjectSink __RPC_FAR  *pResponseHandler - Response
//                                          handler.
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::GetObjectAsync(

   const BSTR ObjectPath,
   long lFlags,
   IWbemContext __RPC_FAR *pCtx,
   IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
        StopWatch stopWatch(CHString(IDS_GETOBJECTASYNC) + CHString(ObjectPath));
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT              hr = WBEM_E_FAILED;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;
    ParsedObjectPath    *pParsedPath = NULL;
    CObjectPathParser    objpathParser;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_GETOBJECTASYNC, ObjectPath);
        }

        // Parse the object path passed to us by CIMOM
        // ==========================================
        int nStatus = objpathParser.Parse( ObjectPath,  &pParsedPath );

        if ( 0 == nStatus )
        {

            // Now try to find the provider based on the class name
            // pProvider doesn't get addref'ed, so no release necessary
            Provider *pProvider = SearchMapForProvider( pParsedPath->m_pClass, m_strNamespace );

            // If we got a provider, let it handle itself like a grown-up provider
            // should.

            if ( NULL != pProvider )
            {
                // Now create an External Method Context object and go to town

                ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

                if ( NULL != pContext )
                {
#ifdef PROVIDER_INSTRUMENTATION
                    pContext->pStopWatch = &stopWatch;
#endif
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->GetObject( pParsedPath, pContext, lFlags );
                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                wszName2, wszName, ObjectPath);
                        }
                    }

                    pStatusObject.Attach(pContext->GetStatusObject());
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

            }
            else
            {
                LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, pParsedPath->m_pClass);
                hr = WBEM_E_INVALID_CLASS;
                bLocalError = true;
            }

        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_GETOBJECTASYNC, ObjectPath);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_GETOBJECTASYNC, ObjectPath, hr);
        }

    }
    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Start(StopWatch::FrameworkTimer);
#endif
        hr = WBEM_S_NO_ERROR;
    }

    // Clean up the Parsed Path
    if (pParsedPath)
    {
        objpathParser.Free( pParsedPath );
    }

    Release();
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif
    return hr;

}

/////////////////////////////////////////////////////////////////////
//
//   Function:   CWbemProviderGlue::PutInstanceAsync
//
//   Locates the provider for the specified class name and
//   calls its CreateInstanceEnum function.
//
//   Inputs:     IWbemClassObject __RPC_FAR *pInst - Instance whose
//                                           values to use.
//               long                        lFlags - PutInstance flags.
//               IWbemContext __RPC_FAR *pCtxt - Context pointer
//               IWbemObjectSink __RPC_FAR *pResponseHandler - Response
//                                           handler.
//
//   Outputs:    None.
//
//   Returns:    SCCODE      - COM Status.
//
//   Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::PutInstanceAsync(

    IWbemClassObject __RPC_FAR *pInst,
    long                     lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

    HRESULT  hr = WBEM_E_INVALID_CLASS;
    variant_t vClass;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        // Set up to get the class name of the instance being passed to us
        // ask the framework if it has this class registered for support
        // ===============================================================

        // Get the class name
        pInst->Get( IDS_CLASS, 0, &vClass, NULL, NULL );

        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_PUTINSTANCEASYNC, vClass.bstrVal);
        }

        // pProvider doesn't get addref'ed, so no release necessary
        Provider *pProvider = SearchMapForProvider( vClass.bstrVal, m_strNamespace );

        // If we got a provider, let it handle itself like a grown-up provider
        // should.
        if ( NULL != pProvider )
        {
            // Now create an External Method Context object and go to town
            ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

            if ( NULL != pContext )
            {
                IWbemClassObjectPtr  pInstPostProcess;
                if (SUCCEEDED(hr = PreProcessPutInstanceParms(pInst, &pInstPostProcess, pCtx)))
                {
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->PutInstance( pInstPostProcess, lFlags, pContext );

                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                wszName2, wszName, vClass.bstrVal);
                        }
                    }
                }
                pStatusObject.Attach(pContext->GetStatusObject());
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, vClass.bstrVal);
			hr = WBEM_E_INVALID_CLASS;
            bLocalError = true;
        }


        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_PUTINSTANCEASYNC, vClass.bstrVal);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_PUTINSTANCEASYNC, vClass.bstrVal, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );
        hr = WBEM_S_NO_ERROR;
    }

    Release();
    return hr;

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::PreProcessPutInstanceParms()
//
//  IF __PUT_EXT_PROPERTIES is specified, will parse out the intended properties
//  and set to NULL those props that are not explicitly being put.
//
//  Inputs:  [IN] IWbemClassObject __RPC_FAR *pInstIn - Instance whose values to use.
//           [OUT] IWbemClassObject __RPC_FAR **pInstOut - processed instance
//           IWbemContext __RPC_FAR *pCtxt - Context pointer
//
//  Outputs:    None.
//
//  Returns:    WBEM_S_NO_ERROR if the only extension specified is __PUT_EXT_PROPERTIES
//                      or if no extensions are specified
//              WBEM_E_UNSUPPORTED_PUT_EXTENSION if any other flag is set.
//              WBEM_E_SEVERE_SCREWUP if some other darn thing happened.
//
//  Comments:   You may get a different IWbemObject out than you put in
//              it's your responsibility to release it.
//              On error - pInstOut is undefined.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::PreProcessPutInstanceParms(

    IWbemClassObject __RPC_FAR *pInstIn,
    IWbemClassObject __RPC_FAR **pInstOut,
    IWbemContext __RPC_FAR *pCtx
)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    // Variant_t handles the VariantInit/VariantClear
    variant_t vValue;

    if (
            pCtx != NULL &&
            SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXTENSIONS", 0, &vValue)) &&
            V_VT(&vValue) == VT_BOOL &&
            V_BOOL(&vValue) == VARIANT_TRUE
       )
    {
        // easy checks first, are there unsupported parms?
        vValue.Clear();
        if (SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXT_STRICT_NULLS", 0, &vValue))
            && (V_VT(&vValue)   == VT_BOOL)
            && (V_BOOL(&vValue) == VARIANT_TRUE))
                hr = WBEM_E_UNSUPPORTED_PUT_EXTENSION;
        else
        {
            vValue.Clear();
            if (SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXT_ATOMIC", 0, &vValue))
                && (V_VT(&vValue)   == VT_BOOL)
                && (V_BOOL(&vValue) == VARIANT_TRUE))
                    hr = WBEM_E_UNSUPPORTED_PUT_EXTENSION;
        }

        vValue.Clear();
        if ((SUCCEEDED(hr) || (hr != WBEM_E_UNSUPPORTED_PUT_EXTENSION))
            && SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXT_PROPERTIES", 0, &vValue)))
        {
            if (V_VT(&vValue) == (VT_BSTR|VT_ARRAY))
                hr = NullOutUnsetProperties(pInstIn, pInstOut, vValue);
            else
                hr = WBEM_E_INVALID_PARAMETER;
        }
        else if (hr == WBEM_E_NOT_FOUND)
        {
            // well, if we've never heard of it, it MUST be wrong...
            hr = WBEM_E_UNSUPPORTED_PUT_EXTENSION;
        }
    }
    else if (hr == WBEM_E_NOT_FOUND)
    {
        // no extensions - no problems.
        // out interface is same as in interface
        hr = WBEM_S_NO_ERROR;
        *pInstOut = pInstIn;
        (*pInstOut)->AddRef();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::NullOutUnsetProperties
//
//  returns a copy of the input class, any properties whose names are listed
//  in the variant are set to NULL in the output class
//
//
//  Inputs:  IWbemClassObject __RPC_FAR *pInst - Instance whose
//                                          values to NULL
//              VARIANT                     contains names to not NULL out.
//
//  Outputs:    None.
//
//  Returns:    the ubiquitous HRESULT
//
//  Comments:   Assumes you've done your homework and the Variant
//              is a BSTR Array containing property names.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::NullOutUnsetProperties(

    IWbemClassObject __RPC_FAR *pInstIn,
    IWbemClassObject __RPC_FAR **pInstOut,
    const VARIANT& vValue
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // get ourselves a copy to work with
    CInstancePtr pInstance;

    // Variant_t handles the VariantInit/VariantClear
    variant_t vName;
    variant_t vNameSpace;

    hRes = pInstIn->Get(IDS_CLASS, 0, &vName, NULL, NULL);

    if (SUCCEEDED(hRes))
    {
        hRes = pInstIn->Get(L"__NAMESPACE", 0, &vNameSpace, NULL, NULL);
    }

    if (SUCCEEDED(hRes) && SUCCEEDED( hRes = GetEmptyInstance(vName.bstrVal, &pInstance, vNameSpace.bstrVal)))
    {
        // and off we go...
        SAFEARRAY *pNames = vValue.parray;
        long nBiggestName;
        if (SUCCEEDED(hRes = SafeArrayGetUBound(pNames, 1, &nBiggestName)))
        {
            BSTR t_bstrName = NULL ;
            *pInstOut = pInstance->GetClassObjectInterface();

            variant_t value;

            // wander through the names, for every one we find
            // copy the property value to the out pointer
            for (long i = 0; i <= nBiggestName; i++)
            {
                SafeArrayGetElement(pNames, &i, t_bstrName ) ;
                try
                {
                    pInstIn->Get( t_bstrName, 0, &value, NULL, NULL);
                    (*pInstOut)->Put( t_bstrName, 0, &value, 0);
                }
                catch( ... )
                {
                    SysFreeString( t_bstrName ) ;
                    throw ;
                }
                SysFreeString( t_bstrName ) ;
            }

            // and, oh what the heck - let's copy the keys, too...
            SAFEARRAY *pKeyNames = NULL;
            if (SUCCEEDED(hRes = pInstIn->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pKeyNames)))
            {
                try
                {
                    SafeArrayGetUBound(pKeyNames, 1, &nBiggestName);
                    for (i = 0; i <= nBiggestName; i++)
                    {
                        try
                        {
                            SafeArrayGetElement( pKeyNames, &i, t_bstrName );
                            pInstIn->Get( t_bstrName, 0, &value, NULL, NULL );
                            (*pInstOut)->Put( t_bstrName, 0, &value, 0 );
                        }
                        catch( ... )
                        {
                            SysFreeString( t_bstrName ) ;
                            throw ;
                        }
                        SysFreeString( t_bstrName ) ;
                    }
                }
                catch (...)
                {
                    SafeArrayDestroy(pKeyNames);
                    throw ;
                }

                SafeArrayDestroy(pKeyNames);
            }
        }
        else
        {
            // failed to get array upper bound!
            hRes = WBEM_E_FAILED;
        }
    }

    return hRes;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::DeleteInstanceAsync
//
//  Locates the provider for the specified class name and
//  calls its DeleteInstance function.
//
//  Inputs:  IWbemClassObject __RPC_FAR *pInst - Instance whose
//                                          values to use.
//              long                        lFlags - PutInstance flags.
//              IWbemContext __RPC_FAR *pCtxt - Context pointer
//              IWbemObjectSink __RPC_FAR *pResponseHandler - Response
//                                          handler.
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::DeleteInstanceAsync(

    const BSTR        ObjectPath,
    long              lFlags,
    IWbemContext      __RPC_FAR *pCtx,
    IWbemObjectSink   __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

    HRESULT             hr = WBEM_E_FAILED;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;

    ParsedObjectPath *pParsedPath = NULL;
    CObjectPathParser   objpathParser;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_DELETEINSTANCEASYNC, ObjectPath);
        }

        // Parse the object path passed to us by CIMOM
        // ==========================================
        int nStatus = objpathParser.Parse( ObjectPath,  &pParsedPath );

        if ( 0 == nStatus )
        {
            // Now try to find the provider based on the class name
            // pProvider doesn't get addref'ed, so no release necessary
            Provider *pProvider = SearchMapForProvider( pParsedPath->m_pClass, m_strNamespace );

            // If we got a provider, let it handle itself like a grown-up provider
            // should.

            if ( NULL != pProvider )
            {
                // Now create an External Method Context object and go to town

                ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

                if ( NULL != pContext )
                {
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->DeleteInstance( pParsedPath, lFlags, pContext );

                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                wszName2, wszName, ObjectPath);
                        }
                    }
                    pStatusObject.Attach(pContext->GetStatusObject());
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

            }
            else
            {
                hr = WBEM_E_INVALID_CLASS;
                LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, pParsedPath->m_pClass);
                bLocalError = true;
            }

        }
        else
        {
            LogErrorMessage3(L"%s (%s)", IDS_COULDNOTPARSE, ObjectPath);
            bLocalError = true;
        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_DELETEINSTANCEASYNC, ObjectPath);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_DELETEINSTANCEASYNC, ObjectPath, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject);
        hr = WBEM_S_NO_ERROR;
    }

    // Clean up the Parsed Path
    if (pParsedPath)
    {
        objpathParser.Free( pParsedPath );
    }

    Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::ExecMethodAsync
//
//  Locates the provider for the specified class name and
//  calls its ExecMethod function.
//
//  Inputs:
// const BSTR ObjectPath,  - Object path on which to execute the method
// const BSTR MethodName,  - Name of the method to execute
// long lFlags,      - Any flags
// IWbemContext __RPC_FAR *pCtx,
// IWbemClassObject __RPC_FAR *pInParams,  - Pointer to IWbemClassObject
//                                           that contains parms
// IWbemObjectSink __RPC_FAR *pResponseHandler)
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::ExecMethodAsync(

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
    StopWatch stopWatch(CHString(IDS_EXECMETHODASYNC) + CHString(ObjectPath) + CHString(MethodName));
    stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT             hr = WBEM_E_FAILED;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;

    ParsedObjectPath *pParsedPath = NULL;
    CObjectPathParser   objpathParser;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage4(L"%s%s.%s", IDS_EXECMETHODASYNC, ObjectPath, MethodName);
        }

        // Parse the object path passed to us by CIMOM
        // ==========================================
        int nStatus = objpathParser.Parse( ObjectPath,  &pParsedPath );

        if ( 0 == nStatus )
        {
            // Now try to find the provider based on the class name
            // pProvider doesn't get addref'ed, so no release necessary
            Provider *pProvider = SearchMapForProvider( pParsedPath->m_pClass, m_strNamespace );

            // If we got a provider, let it handle itself like a grown-up provider
            // should.

            if ( NULL != pProvider )
            {
                IWbemClassObjectPtr pOutClass;
                IWbemClassObjectPtr pOutParams;
                CInstancePtr COutParam;
                CInstancePtr CInParam;
                hr = WBEM_S_NO_ERROR;

                 // Now create an External Method Context object and go to town
                ExternalMethodContextPtr  pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);
#ifdef PROVIDER_INSTRUMENTATION
                pContext->pStopWatch = &stopWatch;
#endif

                // Check for out of memory
                if (NULL == pContext)
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                // add check to ensure that we do not call a static method
                // on an instance of a class.
                if (SUCCEEDED(hr) && pParsedPath->IsInstance())
                {
                    IWbemClassObjectPtr pObj(pProvider->GetClassObjectInterface(pContext), false);
                    if (pObj)
                    {
                        IWbemQualifierSetPtr pSet;
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                        if (SUCCEEDED(pObj->GetMethodQualifierSet(MethodName, &pSet)))
                        {
                        // disallow an instance to invoke a static method
#ifdef PROVIDER_INSTRUMENTATION
                            stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                            if (SUCCEEDED(pSet->Get( IDS_Static, 0, NULL, NULL)))
                                hr = WBEM_E_INVALID_METHOD;
#ifdef PROVIDER_INSTRUMENTATION
                                stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                        }
                    }
                }

                // If there are in params, convert them to a cinstance.
                if (SUCCEEDED(hr) && (NULL != pInParams) )
                {
                    CInParam.Attach(new CInstance(pInParams, pContext));

                    if (NULL == CInParam)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }

                // Get the output class for the method
                if (SUCCEEDED(hr))
                {
                    IWbemClassObjectPtr pObj(pProvider->GetClassObjectInterface(pContext), false);
                    if (pObj != NULL)
                    {
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                    hr = pObj->GetMethod(MethodName, 0, NULL, &pOutClass);
#ifdef PROVIDER_INSTRUMENTATION
                    stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                    }
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }
                }

                // If there is no output class, pOutClass is null (by design).  So, if there was no error
                // and we got an pOutClass, get an instance and wrap it in a CInstance
                if (SUCCEEDED(hr) && (pOutClass != NULL))
                {
#ifdef PROVIDER_INSTRUMENTATION
                    stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                    hr = pOutClass->SpawnInstance(0, &pOutParams);
#ifdef PROVIDER_INSTRUMENTATION
                    stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                    if (SUCCEEDED(hr))
                    {
                        COutParam.Attach(new CInstance(pOutParams, pContext));

                        // Out of memory
                        if (NULL == COutParam)
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                }

                if ( SUCCEEDED(hr) )
                {
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->ExecMethod( pParsedPath, MethodName, lFlags, CInParam, COutParam, pContext );

                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage5(L"Warning! User name at exit (%s) != user name at entry (%s) for %s.%s",
                                wszName2, wszName, ObjectPath, MethodName);
                        }
                    }
                }

                // If there is an output object
                if (COutParam != NULL)
                {

                    // Only send back an output object if the method succeeded
                    if (SUCCEEDED(hr))
                    {

                        // Send the object back
                        IWbemClassObjectPtr pObj(COutParam->GetClassObjectInterface(), false);
                        IWbemClassObject *pObj2 = (IWbemClassObject *)pObj;
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif

                        pResponseHandler->Indicate( 1, &pObj2);
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                    }
                }

                pStatusObject.Attach(pContext->GetStatusObject());

            }
            else
            {
                LogErrorMessage3(L"%s (%s)", IDS_PROVIDERNOTFOUND, pParsedPath->m_pClass);
                hr = WBEM_E_INVALID_CLASS;
                bLocalError = true;
            }

        }
        else
        {
            LogErrorMessage3(L"%s (%s)", IDS_COULDNOTPARSE, ObjectPath);
            bLocalError = true;
        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage4(L"%s%s.%s - Succeeded", IDS_EXECMETHODASYNC, ObjectPath, MethodName);
            else
                LogMessage5(L"%s%s.%s - FAILED (%x)", IDS_EXECMETHODASYNC, ObjectPath, MethodName, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif
        hr = WBEM_S_NO_ERROR;
    }

    // Clean up the Parsed Path
    if (pParsedPath)
    {
        objpathParser.Free( pParsedPath );
    }

    Release();

#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetNamespaceConnection
//
//  Establishes a connection to the supplied namespace by first
//  assigning a default if needed, then searching our map, and if
//  that fails, then actually connecting.
//
//  Inputs:     const BSTR  NameSpace - NameSpace of provider
//
//  Outputs:    None.
//
//  Returns:    IWbemServices *pointer to IWbemServices corresponding
//                              to the connected namespace.
//
//  Comments:   Default Namespace is Root\\Default
//
//
/////////////////////////////////////////////////////////////////////

IWbemServices *CWbemProviderGlue::GetNamespaceConnection(

    LPCWSTR pwszNameSpace
)
{
    ASSERT_BREAK(DEPRECATED);

    bstr_t  bstrNamespace(pwszNameSpace);

    // Root\CimV2 is the default name space
    if (    NULL    ==  pwszNameSpace
        ||  L'\0'   ==  *pwszNameSpace )
    {
        bstrNamespace = DEFAULT_NAMESPACE;
    }

    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s%s", IDS_GETNAMESPACECONNECTION, (LPCWSTR)bstrNamespace);
    }

    IWbemLocatorPtr pIWbemLocator;
    IWbemServices *pWbemServices = NULL;

    HRESULT hRes = CoCreateInstance (

        CLSID_WbemLocator, //CLSID_WbemAdministrativeLocator,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_IUnknown,
        ( void ** ) &pIWbemLocator
        ) ;

    if (SUCCEEDED(hRes))
    {
        hRes = pIWbemLocator->ConnectServer(bstrNamespace,  // Namespace
            NULL,          // Userid
            NULL,           // PW
            NULL,           // Locale
            0,              // flags
            NULL,           // Authority
            NULL,           // Context
            &pWbemServices
            );

        if (SUCCEEDED(hRes))
        {
        }
        else
        {
            LogErrorMessage3(L"Failed to Connectserver to namespace %s (%x)", (LPCWSTR)bstrNamespace, hRes);
        }
    }
    else
    {
        LogErrorMessage2(L"Failed to get locator (%x)", hRes);
    }

    return pWbemServices;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLogin
//
//  Static entry point for providers to login to the framework,
//  providing us with info for our map, and allowing us to return
//  an IWbemServices pointer for the base provider class to
//  manipulate to its heart's content.
//
//  Inputs:     LPCWSTR&       strName - Name of object for map.
//              Provider *pProvider - Pointer Name Maps to.
//              LPCWSTR          pszNameSpace - NameSpace of provider
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   None.
//
//
/////////////////////////////////////////////////////////////////////
void CWbemProviderGlue::FrameworkLogin(

    LPCWSTR      a_szName,
    Provider     *a_pProvider,
    LPCWSTR      a_pszNameSpace
)
{
    if (IsVerboseLoggingEnabled())
    {
        if (a_pszNameSpace != NULL)
        {
            LogMessage4(L"%s%s:%s", IDS_FRAMEWORKLOGIN, a_pszNameSpace, a_szName);
        }
        else
        {
            LogMessage4(L"%s%s:%s", IDS_FRAMEWORKLOGIN, DEFAULT_NAMESPACE, a_szName);
        }
    }

    // AddProviderToMap, searches the Map for a match first.
    // If one is found, it does not perform the actual add.
    // Check that the pointers are the same.  If they're
    // different, this is what happened.

    // pProvider doesn't get addref'ed, so no release necessary
    Provider *t_pTestProvider = AddProviderToMap( a_szName, a_pszNameSpace, a_pProvider );

    if ( t_pTestProvider != a_pProvider )
    {
        // this should never happen
        // a provider should login only once at construction and out at destruction
        // this should coincide with DLLs being loaded and unloaded.
        LogErrorMessage4(L"%s (%s:%s)", IDS_LOGINDISALLOWED, a_pszNameSpace, a_szName);
        ASSERT_BREAK( FALSE );
    }

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLogoff
//
//  Static entry point for providers to log out of the framework,
//  this should be called from the provider's dtor so that we release
//  all of our pointers so they don't dangle.
//
//  Inputs:     LPCWSTR&       strName - Name of object for map.
//              LPCWSTR          pszNameSpace - NameSpace of provider
//
//  Outputs:    None.
//
//  Returns:    usually.
//
//  Comments:   We don't bother removing entries from the namespace map.
//
//
/////////////////////////////////////////////////////////////////////
void CWbemProviderGlue::FrameworkLogoff(

    LPCWSTR a_pszName,
    LPCWSTR a_pszNamespace
)
{
    STRING2LPVOID::iterator      mapIter;

    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s%s", IDS_FRAMEWORKLOGOFF, a_pszName);
    }

    CHString    strQualifiedName( a_pszName );

    // If our NameSpace is non-NULL (we use DEFAULT_NAMESPACE then), AND it
    // is not DEFAULT_NAMESPACE, concat the namespace to the provider name
    // so we can differentiate providers across namespaces.

    if (    (a_pszNamespace != NULL) && (a_pszNamespace[0] != L'\0')
        &&  0   !=  _wcsicmp(a_pszNamespace, DEFAULT_NAMESPACE ) )
    {
        strQualifiedName += a_pszNamespace;
    }

    // Convert characters to upper case before searching for
    // them in the map.  Since we convert to upper case when
    // we store the map associations, this effectively makes
    // us case-insensitive.

    strQualifiedName.MakeUpper();

    LockProviderMap();

    try
    {
        if( ( mapIter = s_providersmap.find( strQualifiedName ) ) != s_providersmap.end() )
            s_providersmap.erase(mapIter);
        else
            ASSERT_BREAK(0 /* did not find provider to log off!*/);
    }
    catch ( ... )
    {
        UnlockProviderMap();
        throw;
    }

    UnlockProviderMap();
}


/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllInstances
//
//  Static entry point for providers to obtain instance lists from
//  other providers.
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get list for.
//              TRefPointerCollection<CInstance> *pList - List to fill.
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllInstances(

    LPCWSTR                               pszClassName,
    TRefPointerCollection<CInstance>      *pList,
    LPCWSTR                               pszNamespace,   /* = NULL*/
    MethodContext                         *pMethodContext        /* = NULL*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    if (pszClassName)
    {
        CHString sQuery;

        sQuery.Format(L"SELECT * FROM %s where __CLASS = \"%s\"", pszClassName, pszClassName);
        hr = GetInstancesByQuery( sQuery, pList, pMethodContext, pszNamespace);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllInstancesAsynch
//
//  Static entry point for providers to obtain instances from
//  other providers. Note that this is not, strictly speaking,
//  an asynchronous implementation - it does HELP the asynch calls
//  in that it does not build a big list and that the callback allows
//  the provider to respond asynchronously
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get instances from.
//
//              Provider *      this is the "this" pointer for the requester
//              LPProviderInstanceCallback callback function to eat the instances provided
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//              this puppy shares a lot of code with GetAllInstances, but I
//              can't find a clean way to combine them.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllInstancesAsynch(

    LPCWSTR pszClassName,
    Provider *pRequester,
    LPProviderInstanceCallback pCallback,
    LPCWSTR pszNamespace,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (pszClassName)
    {
        CHString sQuery;
        sQuery.Format(L"SELECT * FROM %s where __CLASS = \"%s\"", pszClassName, pszClassName);
        hr = GetInstancesByQueryAsynch( sQuery, pRequester, pCallback, pszNamespace, pMethodContext, pUserData);

        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllDerivedInstances
//
//  Static entry point for providers to obtain instance lists from
//  other providers. This one will return all instances derived from
//  the base class passed in.
//
//  Inputs:     LPCWSTR          pszBaseClassName - Name of base class
//                              to get list for.
//              TRefPointerCollection<CInstance> *pList - List to fill.
//              LPCWSTR          pszNamespace - Namespace of provider.
//              MethodContext *pMethodContext, // must not be NULL
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllDerivedInstances(

    LPCWSTR pszBaseClassName,
    TRefPointerCollection<CInstance> *pList,
    MethodContext *pMethodContext,
    LPCWSTR pszNamespace
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (pszBaseClassName)
    {
        CHString sQuery;
        sQuery.Format(L"SELECT * FROM %s", pszBaseClassName);
        hr = GetInstancesByQuery( sQuery, pList, pMethodContext, pszNamespace);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllDerivedInstancesAsynch
//
//  Static entry point for providers to obtain instances from
//  other providers. Note that this is not, strictly speaking,
//  an asynchronous implementation - it does HELP the asynch calls
//  in that it does not build a big list and that the callback allows
//  the provider to respond asynchronously
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get instances from.
//
//              Provider*       this is the "this" pointer for the requester
//              LPProviderInstanceCallback callback function to eat the instances provided
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//              this puppy shares a lot of code with GetAllInstances, but I
//              can't find a clean way to combine them.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllDerivedInstancesAsynch(

    LPCWSTR pszProviderName,
    Provider *pRequester,
    LPProviderInstanceCallback pCallback,
    LPCWSTR pszNamespace,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (pszProviderName)
    {
        CHString sQuery;
        sQuery.Format(L"SELECT * FROM %s", pszProviderName);
        hr = GetInstancesByQueryAsynch( sQuery, pRequester, pCallback, pszNamespace, pMethodContext, pUserData);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstancesByQuery
//
//  Static entry point for providers to obtain instance lists from
//  other providers. This one will return all instances matching a query.
//
//  Inputs:     LPCWSTR          Query to execute "Select * from win32_foo where bar = "baz""
//              TRefPointerCollection<CInstance> *pList - List to fill.
//              MethodContext *pMethodContext, // must not be NULL
//              LPCWSTR          pointer to namespace - may be NULL (means default -- root\cimv2)
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstancesByQuery( LPCWSTR query,
                                               TRefPointerCollection<CInstance> *pList,
                                               MethodContext *pMethodContext,
                                               LPCWSTR   pszNamespace    /* = NULL*/)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s (%s)", IDS_GETINSTANCESBYQUERY, query);
    }

    HRESULT hr = WBEM_E_FAILED;

    if ( (query != NULL) &&
         (pList != NULL) &&
         (pMethodContext != NULL) )
    {
        IEnumWbemClassObjectPtr pEnum;

        IWbemContextPtr pWbemContext;
        if (pMethodContext)
        {
            pWbemContext.Attach(pMethodContext->GetIWBEMContext());
        }

        IWbemServicesPtr piService;

        // get a service interface
        if (pszNamespace == NULL || pszNamespace[0] == L'\0')
        {
            piService.Attach(GetNamespaceConnection(NULL, pMethodContext));
        }
        else
        {
            piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext));
        }

        if ( piService != NULL)
        {
            {
                // Assures that impersonation goes
                // back to the way it was before the
                // call to CIMOM.
                CAutoImpRevert air;
                DWORD dwImpErr = air.LastError();
                if(dwImpErr == ERROR_SUCCESS)
                {
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                    hr = piService->ExecQuery(bstr_t(IDS_WQL), bstr_t(query), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, pWbemContext, &pEnum);
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                }
                else
                {
                    LogErrorMessage2(L"Failed to open current thread token for checking impersonation, with error %d", dwImpErr);
                    hr = WBEM_E_FAILED;
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                IWbemClassObjectPtr pObj;
                ULONG nReturned;

                // author's apology:
                //      we loop through, using Next() to get each instance
                //      we bail when we get WBEM_S_FALSE because that's the end of the enumeration
                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                for (hr = pEnum->Next(GLUETIMEOUT, 1, &pObj, &nReturned);
                    (SUCCEEDED(hr) && (hr != WBEM_S_FALSE) && (hr != WBEM_S_TIMEDOUT) ) ;
                    hr = pEnum->Next(GLUETIMEOUT, 1, &pObj, &nReturned))
                {
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                    if (pObj != NULL && nReturned)
                    {
                        CInstancePtr pInstance(new CInstance(pObj, pMethodContext), false);

                        if (pInstance != NULL)
                        {
                            // Check to see if adding to the list succeeds
                            if (!pList->Add(pInstance))
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

                    }
                }

                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

                // the Next will return WBEM_S_FALSE when it is done.  However, that
                // means that THIS function had no error.
                if (hr == WBEM_S_FALSE)
                {
                    hr = WBEM_S_NO_ERROR;
                }
                // fencepost check - the last error might have been access denied
                // but it's okay if we got any instances at all
                else if (hr == WBEM_E_ACCESS_DENIED)
                    if (pList->GetSize() > 0)
                        hr = WBEM_S_NO_ERROR;


            }   // IF SUCCEEDED
        }
        else
            LogErrorMessage(IDS_FAILED);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetInstancesByQuery");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    if (IsVerboseLoggingEnabled())
    {
        if (SUCCEEDED(hr))
        {
            LogMessage3(L"%s (%s) - Succeeded", IDS_GETINSTANCESBYQUERY, query);
        }
        else
        {
            LogMessage4(L"%s (%s) - FAILED (%x)", IDS_GETINSTANCESBYQUERY, query, hr);
        }
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::IsDerivedFrom
//
//  Static entry point for providers to obtain derivation information
//
//  Inputs:     LPCWSTR          pszBaseClassName - Name of base class
//              LPCWSTR          pszDerivedClassName - Name of class we're testing
//              MethodContext   *pMethodContext
//
//  Outputs:    None.
//
//  Returns:    true iff pszDerivedClassName is derived from pszBaseClassName
//
//  Comments:   This function cannot short circuit, because a derived class may be external
//
/////////////////////////////////////////////////////////////////////

bool CWbemProviderGlue::IsDerivedFrom(

    LPCWSTR pszBaseClassName,
    LPCWSTR pszDerivedClassName,
    MethodContext *pMethodContext,
    LPCWSTR   pszNamespace    /* = NULL*/
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    bool bRet = false;

    if ( (pszBaseClassName != NULL) &&
         (pszDerivedClassName != NULL) &&
         (pMethodContext != NULL) )
    {
        IWbemServicesPtr piService;

        // get a service interface
        piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext ));

        // find the derived class object
        if (piService != NULL)
        {
            IWbemClassObjectPtr pObj;
            IWbemContextPtr pWbemContext;
            if (pMethodContext)
            {
                pWbemContext.Attach(pMethodContext->GetIWBEMContext());
            }

            PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
            HRESULT hr = piService->GetObject( bstr_t( pszDerivedClassName ), 0, pWbemContext, &pObj, NULL);
            PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

            if (SUCCEEDED(hr) && (pObj != NULL))
            {
                // Variant_t handles the VariantInit/VariantClear
                variant_t v;

                if (SUCCEEDED(pObj->Get((unsigned short *)IDS_DERIVATION, 0, &v, NULL, NULL)))
                {
                    BSTR bstrTemp = NULL;
                    SAFEARRAY *psa = V_ARRAY(&v);
                    LONG uBound;
                    SafeArrayGetUBound(psa, 1, &uBound);

                    // if base class is in the list in the derivation, we're true!
                    for (LONG i = 0; !bRet && (i <= uBound); i++)
                    {
                        SafeArrayGetElement(psa, &i, &bstrTemp);
                        try
                        {
                            bRet = (_wcsicmp(pszBaseClassName, bstrTemp) == 0);
                        }
                        catch ( ... )
                        {
                            SysFreeString(bstrTemp);
                            throw ;
                        }
                        SysFreeString(bstrTemp);
                    }
                }
            }
        }
    }
    else
    {
        LogErrorMessage(L"NULL parameter to IsDerivedFrom");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetEmptyInstance
//
//  Static entry point for providers to obtain a single empty instance
//  of a provider object.
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get list for.
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    CInstance       **ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////
//      DEPRECATED
HRESULT WINAPI CWbemProviderGlue::GetEmptyInstance(

    LPCWSTR       pszClassName,
    CInstance **ppInstance,
    LPCWSTR       pszNamespace
)
{
    ASSERT_BREAK(DEPRECATED);

    HRESULT      hr = WBEM_E_INVALID_CLASS;

    if ( (pszClassName != NULL) &&
         (ppInstance != NULL) )
    {
        // Search for the class name in our map of providers, we know which
        // namespace we are when we get constructed.

        // pProvider doesn't get addref'ed, so no release is necessary
        Provider *pProvider = SearchMapForProvider( pszClassName, pszNamespace );

        if ( NULL != pProvider )
        {
            // Now create an Internal Method Context object, since this function
            // only gets called internal to our DLL.  Using a NULL for the
            // list pointer, essentially creates a dummy context so we can
            // do our commit dance as painlessly as possible.

            InternalMethodContextPtr pContext (new InternalMethodContext( NULL, NULL, NULL ), false);

            if ( NULL != pContext )
            {
                // Assume things will go wrong like a good liitle paranoiac
                hr = WBEM_E_FAILED;

                // Before asking for a new instance, we MUST verify that the
                // provider has a valid IMOS pointer.  If it does'nt, CreateNewInstance
                // may GPF (this is a safety check we must do because of our
                // little short circuit.

                // We don't do short circuits anymore.
//                if ( pProvider->ValidateIMOSPointer() )
                {
                    // Set the error code appropriately depending on whether or
                    // not the Instance gets created correctly.

                    // The instance returned will have been AddRefed, so it will
                    // be up to the caller to Release() it.

                    if ( ( *ppInstance = pProvider->CreateNewInstance( pContext ) ) != NULL )
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
		else
		{
			hr = WBEM_E_INVALID_CLASS;
		}
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetEmptyInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetEmptyInstance
//
//  Static entry point for providers to obtain a single empty instance
//  of a provider object.  This alternate form makes a call back
//  into WINMGMT.
//
//  Inputs:     MethodContext    *Context object for this call
//              LPCWSTR          pszProviderName - Name of provider to
//                               get instance of.
//              LPCWSTR          pszNamespace - Namespace of class.
//
//  Outputs:    CInstance       **ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetEmptyInstance(

    MethodContext   *pMethodContext,
    LPCWSTR         pszProviderName,
    CInstance       **ppOutInstance,
    LPCWSTR         a_pszNamespace
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_E_FAILED;

    if ( (pMethodContext != NULL) &&
         (pszProviderName != NULL) &&
         (ppOutInstance != NULL) )
    {

        CInstancePtr pClassInstance;

        hr = GetInstanceFromCIMOM(pszProviderName, a_pszNamespace, pMethodContext, &pClassInstance);

        if (SUCCEEDED(hr))
        {
            IWbemClassObjectPtr pClassObject(pClassInstance->GetClassObjectInterface(), false);
            if (pClassObject != NULL)
            {
                IWbemClassObjectPtr pObj;
                hr = pClassObject->SpawnInstance(0, &pObj);

                if (SUCCEEDED(hr))
                {
                    *ppOutInstance = new CInstance(pObj, pMethodContext);
                    if (*ppOutInstance == NULL)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
            }
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetEmptyInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FillInstance
//
//  Static entry point for providers to pass us an instance with
//  key data filled out, which we will use to locate the correct
//  provider and ask it to fill out completely.
//
//  Inputs:     CInstance        *pInstance - Instance to fill out.
//              LPCWSTR          pszNamespace - Namespace for provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////
//        DEPRECATED!
HRESULT WINAPI CWbemProviderGlue::FillInstance(

    CInstance *pInstance,
    LPCWSTR   pszNamespace /*= NULL*/
)
{
    ASSERT_BREAK(DEPRECATED);

    HRESULT      hr = WBEM_E_FAILED;

    if (pInstance != NULL)
    {
        // Check that we have an instance pointer, then pull out the
        // class name and name space.  From there we can find the
        // appropriate provider and ask it to get the object.

        if ( NULL != pInstance )
        {
            CHString strProviderName;
            pInstance->GetCHString( IDS_CLASS, strProviderName );

            // Search for the class name in our map of providers, we know which
            // namespace we are when we get constructed.

            // pProvider is not addref'ed, so no release is necessary
            Provider *pProvider = SearchMapForProvider( strProviderName, pszNamespace );

            if ( NULL != pProvider )
            {
                // Pass the pInstance off to the provider and let it take care
                // of obtaining the correct values.

                hr = pProvider->GetObject( pInstance );
            }
            else
            {
                hr = WBEM_E_INVALID_CLASS;
            }
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to FillInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FillInstance
//
//  Static entry point for providers to pass us an instance with
//  key data filled out, use to make a call back into winmgmt.
//
//  Inputs:     MethodContext *Context object for this call
//              CInstance     *pInstance - Instance to fill out.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::FillInstance(

    MethodContext *pMethodContext,
    CInstance     *pInstance
)
{
    ASSERT_BREAK(DEPRECATED);

    HRESULT      hr = WBEM_E_FAILED;

    if ( (pMethodContext != NULL) &&
         (pInstance != NULL) )
    {
        // Check that we have an instance pointer, then pull out the path
        // and send it to cimom.
        CHString strPathName;

        pInstance->GetCHString( L"__RELPATH", strPathName );
        hr = GetInstanceByPath(strPathName, &pInstance, pMethodContext);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to FillInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstanceKeysByPath
//
//  Static entry point for providers to pass us an instance path
//  to retrieve.  This class uses per-property gets to request
//  only the keys on the object we are retrieving.
//
//  Inputs:     pszInstancePath Object path to retrieve
//              CInstance     *pInstance - Instance to fill out.
//              MethodContext *Context object for this call
//
//  Outputs:    None
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstanceKeysByPath(

    LPCWSTR           pszInstancePath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( (pMethodContext != NULL) &&
         (pszInstancePath != NULL) &&
         (ppInstance != NULL) )
    {

        IWbemContextPtr pWbemContext(pMethodContext->GetIWBEMContext(), false);

        // We need to have a real context object, not an internal method context
        if (pWbemContext != NULL)
        {
            VARIANT vValue;
            V_VT(&vValue) = VT_BOOL;
            V_BOOL(&vValue) = VARIANT_TRUE;

            // Set the appropriate properties on the context object
            if ( (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue))) &&
                 (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_KEYS_ONLY", 0L, &vValue))) &&
                 (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_CLIENT_REQUEST", 0L, &vValue))))
            {
                LogMessage2(L"GetInstanceKeysByPath: %s", pszInstancePath);
                hr = GetInstanceByPath(pszInstancePath, ppInstance, pMethodContext);

                V_BOOL(&vValue) = VARIANT_FALSE;
                pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue);
            }
        }
        else
        {
            ASSERT_BREAK(FALSE);
            LogErrorMessage(L"Can't use InternalMethodContext to GetInstanceKeysByPath");
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstancePropertiesByPath
//
//  Static entry point for providers to pass us an instance path
//  to retrieve.  This class uses per-property gets to request
//  only the properties specified in the array.
//
//  Inputs:     pszInstancePath Object path to retrieve
//              CInstance     *pInstance - Instance to fill out.
//              MethodContext *Context object for this call
//              csaProperties Properties to request
//
//  Outputs:    None
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstancePropertiesByPath(

    LPCWSTR           pszInstancePath,
    CInstance **ppInstance,
    MethodContext *pMethodContext,
    CHStringArray &csaProperties
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( (pMethodContext != NULL) &&
         (pszInstancePath != NULL) &&
         (ppInstance != NULL) )
    {

        IWbemContextPtr pWbemContext(pMethodContext->GetIWBEMContext(), false);

        // We need to have a real context object, not an internal method context
        if (pWbemContext != NULL)
        {
            variant_t vValue;
            V_VT(&vValue) = VT_BOOL;
            V_BOOL(&vValue) = VARIANT_TRUE;

            // First set the value that says we are using Get extensions
            if ((SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue))) &&
                (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_CLIENT_REQUEST", 0L, &vValue))) )
            {
                // Delete any unneeded properties
                pWbemContext->DeleteValue(L"__GET_EXT_KEYS_ONLY", 0L);

                // Now build the array of properties
                SAFEARRAYBOUND rgsabound [ 1 ] ;

                rgsabound[0].cElements = csaProperties.GetSize() ;
                rgsabound[0].lLbound = 0 ;
                V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;
                if ( V_ARRAY(&vValue) )
                {
                    V_VT(&vValue) = VT_BSTR | VT_ARRAY;

                    for (long x=0; x < csaProperties.GetSize(); x++)
                    {
                        bstr_t bstrProp = csaProperties[x];

                        SafeArrayPutElement(
                            V_ARRAY(&vValue),
                            &x,
                            (LPVOID) (BSTR) bstrProp);
                    }

                    // Put the array into the context object
                    if (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_PROPERTIES", 0L, &vValue)))
                    {
                        LogMessage2(L"GetInstancePropertiesByPath: %s", pszInstancePath);
                        // Make the call
                        hr = GetInstanceByPath(pszInstancePath, ppInstance, pMethodContext);

                        vValue.Clear();
                        V_VT(&vValue) = VT_BOOL;
                        V_BOOL(&vValue) = VARIANT_FALSE;
                        pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue);
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
        else
        {
            ASSERT_BREAK(FALSE);
            LogErrorMessage(L"Can't use InternalMethodContext to GetInstanceKeysByPath");
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstanceByPath
//
//  Static entry point for providers to obtain a single empty instance
//  of a provider object.
//
//  Inputs:     LPCWSTR          pszInstancePath - Path to Object.  This
//                              MUST be a full path,
//              MethodContext   *pMethodContext - Method Context containing
//                              (hopefully) the WbemContext we need
//                              to propogate.
//
//  Outputs:    CInstance**     ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstanceByPath(

    LPCWSTR           pszInstancePath,
    CInstance **ppInstance,
    MethodContext *pMethodContext /* = NULL */
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT      hr = WBEM_E_FAILED;

    if ( (pszInstancePath != NULL) &&
         (ppInstance != NULL) )
    {
        CHString strComputerName;
        GetComputerName( strComputerName );

        // For this revision, we DO NOT support getting paths that are not local.
        // This is because if the machine name is anything other than the local
        // one, we run the risk of freezing while CIMOM goes out and tries to find
        // the machine (up to around 5 minutes according to his Levness.

        ParsedObjectPath *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        // Parse the object path passed to us by CIMOM
        // ==========================================
        int nStatus = objpathParser.Parse( pszInstancePath,  &pParsedPath );

        try
        {
            if ( 0 == nStatus )
            {
                // Machine names MUST match.  Null indicates no machine name specified.

                if (( pParsedPath->m_pServer == NULL) ||
                    ( strComputerName.CompareNoCase( pParsedPath->m_pServer ) == 0 ) ||
                    ( wcscmp(pParsedPath->m_pServer, L".") == 0 )
                    )
                {
                    // Now try to find the provider based on the class name
                    CHString strNamespace;

                    // Pull out the name space parts, and concatenate them using a '\\'
                    // character.  e.g. root\default.

                    for ( DWORD dwCtr = 0; dwCtr < pParsedPath->m_dwNumNamespaces; dwCtr++ )
                    {
                        if ( dwCtr != 0 )
                        {
                            strNamespace += L"\\";
                        }

                        strNamespace += pParsedPath->m_paNamespaces[dwCtr];
                    }

                    // We need to propogate the Wbem Context if we are going out
                    // to CIMOM!

                    IWbemContextPtr pWbemContext;
                    CWbemProviderGlue *pGlue = NULL;

                    if ( NULL != pMethodContext )
                    {
                        pWbemContext.Attach(pMethodContext->GetIWBEMContext());
                        pGlue = pMethodContext->GetProviderGlue();
                    }
                    else
                    {
                        ASSERT_BREAK(DEPRECATED);
                    }

                    InternalMethodContextPtr pInternalContext (
                                            new InternalMethodContext(
                                                    NULL,
                                                    pWbemContext,
                                                    pGlue), false);

                    if ( NULL != pInternalContext )
                    {
                        hr = GetInstanceFromCIMOM( pszInstancePath, strNamespace, pInternalContext, ppInstance );
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }


                }   // IF Machine Names MATCH
                else
                {
                    hr = WBEM_E_INVALID_PARAMETER;  // INVALID MACHINE NAME
                }

                // Clean up the Parsed Path
                objpathParser.Free( pParsedPath );

            }   // IF nStatus == 0
            else
            {
                hr = WBEM_E_INVALID_OBJECT_PATH;
            }
        }
        catch ( ... )
        {
            // Clean up the Parsed Path
            if (pParsedPath)
            {
                objpathParser.Free( pParsedPath );
            }
            throw ;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetInstanceByPath");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstanceFromCIMOM
//
//  Static entry point for providers to obtain a single instance
//  of a WBEM Object. obtaining said object from CIMOM.
//
//  Inputs:     LPCWSTR          pszInstancePath - Path to Object.  This
//                              MUST be a full path,
//              LPCWSTR          pszNameSpace - NameSpace of Object.
//              MethodContext *pMethodContext - Method Context
//
//  Outputs:    CInstance **ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//              will return WBEM_E_INVALID_NAMESPACE if it's not a namespace we support
//                  (might otherwise be valid, but not so far as WE are concerned).
//
//  Comments:   This is an internal entry point, allowing providers
//              that failed the short circuit to be propogated
//              by calling into CIMOM.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstanceFromCIMOM(

    LPCWSTR          pszInstancePath,
    LPCWSTR          pszNamespace,
    MethodContext *pMethodContext,
    CInstance **ppInstance
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
    HRESULT             hr = WBEM_E_FAILED;

    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s (%s)", IDS_INSTANCEFROMCIMOM, pszInstancePath);
    }

    // We need to propogate the Wbem Context (if any) that was passed to
    // us by CIMOM.
    IWbemContextPtr pWbemContext;

    if ( NULL != pMethodContext )
    {
        pWbemContext.Attach(pMethodContext->GetIWBEMContext());
    }
    else
    {
        ASSERT_BREAK(DEPRECATED);
    }

    // If we failed to find the provider, try using CIMOM to do our
    // dirty work for us.

    IWbemServicesPtr    piService;
    IWbemClassObjectPtr piObject;

    // get a service interface
    if ( (pszNamespace == NULL) || (pszNamespace[0] == L'\0' ))
    {
        piService.Attach(GetNamespaceConnection(NULL, pMethodContext));
    }
    else
    {
        piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext ));
    }

    if ( NULL != piService )
    {

        // No go out to CIMOM to get the object, if this succeeds, new an
        // instance and store everything internally.
        {
            // Assures that impersonation goes
            // back to the way it was before the
            // call to CIMOM.
            CAutoImpRevert air;
            DWORD dwImpErr = air.LastError();

            if(dwImpErr == ERROR_SUCCESS)
            {
                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                hr = piService->GetObject( bstr_t(pszInstancePath), 0, pWbemContext, &piObject, NULL );
                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
            }
            else
            {
                LogErrorMessage2(L"Failed to open current thread token for checking impersonation, with error %d", dwImpErr);
                hr = WBEM_E_FAILED;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            *ppInstance = new CInstance( piObject, pMethodContext );
            if (*ppInstance == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

        }
    }
    else
    {
        LogErrorMessage(IDS_FAILED);
        hr = WBEM_E_INVALID_NAMESPACE;
    }

    if (IsVerboseLoggingEnabled())
    {
        if (SUCCEEDED(hr))
        {
            LogMessage3(L"%s (%s) - Succeeded", IDS_INSTANCEFROMCIMOM, pszInstancePath);
        }
        else
        {
            LogMessage4(L"%s (%s) - FAILED (%x)", IDS_INSTANCEFROMCIMOM, pszInstancePath, hr);
        }
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::SearchMapForProvider
//
//  Searches our Provider map for a match against the supplied
//  provider name/NameSpace combination
//
//  Inputs:     const LPCWSTR& strName - Provider Name to find.
//              const LPCWSTR& strNamespace - Provider's Namespace
//
//  Outputs:    None.
//
//  Returns:    Provider *pointer to a provider that was given to
//                        us by a call to FrameworkLogin.
//
//  Comments:   None.
//
//
/////////////////////////////////////////////////////////////////////

Provider *CWbemProviderGlue::SearchMapForProvider(

    LPCWSTR a_pszProviderName,
    LPCWSTR a_pszNamespace
)
{
    Provider *pProvider   =   NULL;
    STRING2LPVOID::iterator      mapIter;

    // If our NameSpace is non-NULL (we use DEFAULT_NAMEPSACE then), AND it
    // is not DEFAULT_NAMESPACE, concat the namespace to the provider name
    // so we can differentiate providers across namespaces.

    CHString strQualifiedName( a_pszProviderName );
    CHString strLocNamespace( a_pszNamespace );

    if (    !strLocNamespace.IsEmpty()
        &&  0   !=  strLocNamespace.CompareNoCase( DEFAULT_NAMESPACE ) )
    {

        // Convert the / characters to \ for comparison
        WCHAR *pszBuff;
        pszBuff = strLocNamespace.GetBuffer(0);
        while ((pszBuff = wcschr(pszBuff, '/')) != NULL)
        {
            *pszBuff = '\\';
        }
        strLocNamespace.ReleaseBuffer();

        strQualifiedName += strLocNamespace;
    }

    // Convert characters to upper case before searching for
    // them in the map.  Since we convert to upper case when
    // we store the map associations, this effectively makes
    // us case-insensitive.

    strQualifiedName.MakeUpper();

    // Protect the map while we're inside this

    LockProviderMap();

    try
    {
        if( ( mapIter = s_providersmap.find( strQualifiedName ) ) != s_providersmap.end() )
        {
            pProvider = (Provider*) (*mapIter).second;
        }
    }
    catch ( ... )
    {
        UnlockProviderMap();
        throw;
    }

    UnlockProviderMap();

    return pProvider;

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddProviderToMap
//
//  Adds a provider to our map.  Searches the map first, and if it's
//  not in it, adds it to the map.
//
//  Inputs:     const LPCWSTR strName - Provider Name to Add.
//              const LPCWSTR strNamespace - Namespace for provider.
//              Provider *pProvider - Provider to add to map.
//
//  Outputs:    None.
//
//  Returns:    Provider *pointer to a provider in the map (may
//                              be different from the supplied one)
//
//  Comments:   None.
//
//
/////////////////////////////////////////////////////////////////////

Provider *CWbemProviderGlue::AddProviderToMap(

    LPCWSTR a_szProviderName,
    LPCWSTR a_pszNamespace,
    Provider *a_pProvider
)
{
    STRING2LPVOID::iterator      mapIter;

    // If our NameSpace is non-NULL (we use DEFAULT_NAMEPSACE then), AND it
    // is not DEFAULT_NAMESPACE, concat the namespace to the provider name
    // so we can differentiate providers across namespaces.

    CHString    strQualifiedName( a_szProviderName );

    if ( ( a_pszNamespace != NULL) && (a_pszNamespace[0] != L'\0')
        &&  (0   !=  _wcsicmp(a_pszNamespace, DEFAULT_NAMESPACE )) )
    {
        strQualifiedName += a_pszNamespace;
    }

    // Convert characters to upper case before searching for
    // them in the map.  Since we convert to upper case when
    // we store the map associations, this effectively makes
    // us case-insensitive.

    strQualifiedName.MakeUpper();

    // Protect the map while we're inside this

    Provider *pReturnProvider = NULL;
    LockProviderMap();

    try
    {
        // First check if we've already got a provider.
        if( ( mapIter = s_providersmap.find( strQualifiedName ) ) != s_providersmap.end() )
        {
            pReturnProvider = (Provider*) (*mapIter).second;
			
			//delete it, we're gonna update it shortly
			s_providersmap.erase(mapIter);
        }

        if ( NULL == pReturnProvider )
        {
            pReturnProvider = a_pProvider;
        }

		//add in the newly logged in provider
        s_providersmap[strQualifiedName] = (LPVOID) a_pProvider;
    }
    catch ( ... )
    {
        UnlockProviderMap();
        throw;
    }

    UnlockProviderMap();

    return pReturnProvider;

}



void CWbemProviderGlue::GetComputerName( CHString& strComputerName )
{
    // Fill the supplied CHString with the local machine name
    DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;

    FRGetComputerName(strComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
    strComputerName.ReleaseBuffer();

    if (strComputerName.IsEmpty())
    {
        strComputerName = L"DEFAULT";
    }
}

BOOL CWbemProviderGlue::FrameworkLoginDLL(LPCWSTR a_pszName)
{
    return CWbemProviderGlue::FrameworkLoginDLL(a_pszName, NULL);
}

BOOL CWbemProviderGlue::FrameworkLogoffDLL(LPCWSTR a_pszNname)
{
      return CWbemProviderGlue::FrameworkLogoffDLL(a_pszNname, NULL);
}

void CWbemProviderGlue::IncrementObjectCount(void)
{
    InterlockedIncrement(&s_lObjects);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage2(L"CWbemProviderGlue::IncrementObjectCount. Count is (approx) %d", s_lObjects);
    }
}

LONG CWbemProviderGlue::DecrementObjectCount(void)
{
    LONG lRet = InterlockedDecrement(&s_lObjects);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage2(L"CWbemProviderGlue::DecrementObjectCount. Count is (approx) %d", s_lObjects);
    }

    return lRet;
}

// checks impersonation level
// impersonates client if allowed
HRESULT WINAPI CWbemProviderGlue::CheckImpersonationLevel()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        HRESULT hRes = WbemCoImpersonateClient();
        if (SUCCEEDED(hRes)) // From cominit.cpp - needed for nt3.51
        {
            // Now, let's check the impersonation level.  First, get the thread token
            HANDLE hThreadTok;
            DWORD dwImp, dwBytesReturned;

            if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hThreadTok
                ))
            {
                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN)
                {
                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    // If we failed to get the thread token for any other reason, log an error.
                    LogErrorMessage2(L"Impersonation failure - OpenThreadToken failed (0x%x)", dwLastError);
                    hr = WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                // We really do have a thread token, so let's retrieve its level

                if (GetTokenInformation(
                    hThreadTok,
                    TokenImpersonationLevel,
                    &dwImp,
                    sizeof(DWORD),
                    &dwBytesReturned
                    ))
                {
                    // Is the impersonation level Impersonate?
                    if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation))
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hr = WBEM_E_ACCESS_DENIED;
                        LogErrorMessage3(L"%s Level(%d)", IDS_ImpersonationFailed, dwImp);
                    }
                }
                else
                {
                    hr = WBEM_E_FAILED;
                    LogErrorMessage3(L"%s Token(%d)", IDS_ImpersonationFailed, GetLastError());
                }

                // Done with this handle
                CloseHandle(hThreadTok);
            }

			if (FAILED(hr))
			{
				WbemCoRevertToSelf();
			}
        }
        else if (hRes == E_NOTIMPL)
        {
            // On 3.51 or vanilla 95, this call is not implemented, we should work anyway
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            LogErrorMessage3(L"%s CoImpersonate(%d)", IDS_ImpersonationFailed, hRes);
        }
    }
    else
    {
        // let win9X in...
        hr = WBEM_S_NO_ERROR;
    }

    if (IsVerboseLoggingEnabled())
    {
        WCHAR wszName[UNLEN + DNLEN + 1 + 1];  // domain + \ + name + null
        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

        if (GetUserNameEx(NameSamCompatible, wszName, &dwLen))
        {
            LogMessage2(L"Impersonation running as: %s", wszName);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstancesByQueryAsynch
//
//  Static entry point for providers to obtain instances from
//  other providers. Note that this is not, strictly speaking,
//  an asynchronous implementation - it does HELP the asynch calls
//  in that it does not build a big list and that the callback allows
//  the provider to respond asynchronously
//
//  Inputs:     LPCWSTR          Query to execute "Select * from win32_foo where bar = "baz""
//              Provider *      this is the "this" pointer for the requester
//              LPProviderInstanceCallback callback function to eat the instances provided
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstancesByQueryAsynch(

    LPCWSTR query,
    Provider *pRequester,
    LPProviderInstanceCallback pCallback,
    LPCWSTR pszNamespace,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage2(L"GetInstancesByQueryAsynch (%s)", query);
    }

    HRESULT         hr = WBEM_E_FAILED;

    if ( (query != NULL) &&
         (pRequester != NULL) &&
         (pCallback != NULL) &&
         (pMethodContext != NULL) )
    {

        // We need to propogate the WBEM context...ESPECIALLY...if we are going out
        // to CIMOM.

        IWbemContextPtr pWbemContext;
        if (pMethodContext)
        {
            pWbemContext.Attach(pMethodContext->GetIWBEMContext());
        }
        else
        {
            ASSERT_BREAK(DEPRECATED);
        }

        // Now create an Internal Method Context object, since this function
        // only gets called internal to our DLLs
        InternalMethodContextAsynchPtr pInternalContext (new InternalMethodContextAsynch(pRequester,
                                                                                        pCallback,
                                                                                        pWbemContext,
                                                                                        pMethodContext,
                                                                                        pUserData), false);

        if ( NULL != pInternalContext )
        {
            // using CIMOM to do our dirty work for us.
            IWbemServicesPtr  piService;

            // get a service interface
            if (pszNamespace == NULL || pszNamespace[0] == L'\0')
            {
                piService.Attach(GetNamespaceConnection(NULL, pMethodContext));
            }
            else
            {
                piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext ));
            }

            if ( NULL != piService )
            {
                IEnumWbemClassObjectPtr pEnum;
                {
                    // Assures that impersonation goes
                    // back to the way it was before the
                    // call to CIMOM.
                    CAutoImpRevert air;
                    DWORD dwImpErr = air.LastError();

                    if(dwImpErr == ERROR_SUCCESS)
                    {
                        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                        hr = piService->ExecQuery(bstr_t(IDS_WQL),
                            bstr_t(query),
                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            pWbemContext,
                            &pEnum);
                        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                    }
                    else
                    {
                        LogErrorMessage2(L"Failed to open current thread token for checking impersonation, with error %d", dwImpErr);
                        hr = WBEM_E_FAILED;
                    }
                }

                if ( SUCCEEDED( hr ) )
                {
                    IWbemClassObjectPtr pObj;
                    ULONG nReturned;

                    // we retrieve all instances of this class and it's children.  Note that
                    // the next returns WBEM_S_FALSE at the end which PASSES the SUCCEEDED()
                    // test, but fails the pObj test.
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                    while (SUCCEEDED(hr) && SUCCEEDED(hr = pEnum->Next(GLUETIMEOUT, 1, &pObj, &nReturned)) && (pObj != NULL))
                    {
                        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                        CInstancePtr pInstance(new CInstance(pObj, pMethodContext), false);
                        if (pInstance != NULL)
                        {
                            // For reasons quite beyond me, InternalContext::Commit doesn't
                            // release, but external does.  Note that the smartptr is doing
                            // the release here.
                            hr = pInternalContext->Commit(pInstance);
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }

                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

                    // the Next will return WBEM_S_FALSE when it is done.  However, that
                    // means that THIS function had no error.
                    if (hr == WBEM_S_FALSE)
                    {
                        hr = WBEM_S_NO_ERROR;
                    }

                }   // IF SUCCEEDED
            }
            else
            {
                LogErrorMessage(IDS_FAILED);
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetInstancesByQueryAsynch");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    if (IsVerboseLoggingEnabled())
    {
        if (SUCCEEDED(hr))
        {
            LogMessage2(L"GetInstancesByQueryAsynch (%s) - Succeeded", query);
        }
        else
        {
            LogMessage3(L"GetInstancesByQueryAsynch (%s) - FAILED (%x)", query, hr);
        }
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

IWbemServices *CWbemProviderGlue::InternalGetNamespaceConnection(

    LPCWSTR pwszNameSpace
)
{
    IWbemServices *pWbemServices = NULL;

    bstr_t  bstrNamespace;

    // Root\CimV2 is the default name space
    if ( NULL    !=  pwszNameSpace &&  L'\0'   !=  *pwszNameSpace )
    {
        bstrNamespace = pwszNameSpace;
    }
    else
    {
        ASSERT_BREAK(DEPRECATED);
        bstrNamespace = DEFAULT_NAMESPACE;
    }

    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s%s", IDS_GETNAMESPACECONNECTION, (LPCWSTR)bstrNamespace);
    }

    _wcsupr(bstrNamespace);

    // If we are looking for the namespace our class is in, we already
    // got an IWbemServices pointer for this from Initialize
    if (m_strNamespace.Compare(bstrNamespace) == 0)
    {
        pWbemServices = m_pServices;
        pWbemServices->AddRef();
    }
    else
    {
        IWbemLocatorPtr pIWbemLocator;

        HRESULT hRes = CoCreateInstance (

            CLSID_WbemLocator, //CLSID_WbemAdministrativeLocator,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
            IID_IUnknown,
            ( void ** ) &pIWbemLocator
            ) ;

        if (SUCCEEDED(hRes))
        {
            hRes = pIWbemLocator->ConnectServer(bstrNamespace,  // Namespace
                NULL,          // Userid
                NULL,           // PW
                NULL,           // Locale
                0,              // flags
                NULL,           // Authority
                NULL,           // Context
                &pWbemServices
                );

            if (FAILED(hRes))
            {
                LogErrorMessage3(L"Failed to Connectserver to namespace %s (%x)",
                    (LPCWSTR)bstrNamespace, hRes);
            }
        }
        else
        {
            LogErrorMessage2(L"Failed to get locator (%x)", hRes);
        }
    }

    return pWbemServices;
}

IWbemServices *WINAPI CWbemProviderGlue::GetNamespaceConnection( LPCWSTR wszNameSpace, MethodContext *pMethodContext )
{
    IWbemServices *pServices = NULL;
    CWbemProviderGlue *pGlue = NULL;

    if ( pMethodContext && (pGlue = pMethodContext->GetProviderGlue()) )
    {
        pServices = pGlue->InternalGetNamespaceConnection(wszNameSpace);
    }
    else
    {
        pServices = GetNamespaceConnection(wszNameSpace);
    }

    return pServices;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLoginDLL
//
//  Static entry point for providers to register their DLL with
//  the framework.  This PLONG must be the same one used in
//  FrameworkLogoffDll and as the parameter to the CWbemGlueFactory
//  constructor.
//
/////////////////////////////////////////////////////////////////////

BOOL CWbemProviderGlue::FrameworkLoginDLL(LPCWSTR pszName, PLONG plRefCount)
{
    BOOL bRet = TRUE;
    LogMessage3(L"%s%s", IDS_DLLLOGGED, pszName);

    // If this *is* null, that means we are using the backword compatibility
    // version of FrameworkLoginDLL, which uses CWbemProviderGlue::s_lObjects
    // which has already been initialized.
    if (plRefCount != NULL)
    {
        *plRefCount = 0;
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLogoffDLL
//
//  Static entry point for providers to determine whether they
//  should return TRUE to DllCanUnloadNow.  This PLONG must be the
//  same one used in FrameworkLoginDLL and as the parameter to the
//  CWbemGlueFactory constructor.
//
/////////////////////////////////////////////////////////////////////

BOOL CWbemProviderGlue::FrameworkLogoffDLL(LPCWSTR pszName, PLONG plRefCount)
{
    BOOL bRet = TRUE;

    LogMessage3(L"%s%s", IDS_DLLUNLOGGED, pszName);

    // If this *is* null, that means we are using the backword compatibility
    // version of FrameworkLoginDLL
    if (plRefCount != NULL)
    {
        bRet = *plRefCount == 0;
    }
    else
    {
        bRet = CWbemProviderGlue::s_lObjects == 0;
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddToFactoryMap
//
//  Adds a new CWbemGlueFactory to the s_factorymap map.
//
/////////////////////////////////////////////////////////////////////

VOID CWbemProviderGlue::AddToFactoryMap(const CWbemGlueFactory *pGlue, PLONG plRefCount)
{
    LockFactoryMap();

    try
    {
        // If this *is* null, that means we are using the backword compatibility
        // version of FrameworkLoginDLL
        if (plRefCount != NULL)
        {
            CWbemProviderGlue::s_factorymap[pGlue] = plRefCount;
        }
        else
        {
            CWbemProviderGlue::s_factorymap[pGlue] = &CWbemProviderGlue::s_lObjects;
        }
    }
    catch (...)
    {
        UnlockFactoryMap();
        throw;
    }

    UnlockFactoryMap();
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::RemoveFromFactoryMap
//
//  Removes a CWbemGlueFactory from the s_factorymap map.
//
/////////////////////////////////////////////////////////////////////

VOID CWbemProviderGlue::RemoveFromFactoryMap(const CWbemGlueFactory *pGlue)
{
    LockFactoryMap();

    try
    {
        bool bFound = false;
        PTR2PLONG::iterator mapIter;

        mapIter = s_factorymap.find(pGlue);

        if ( mapIter != s_factorymap.end() )
        {
            s_factorymap.erase(mapIter);
        }
        else
        {
            LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
        }
    }
    catch( ... )
    {
        UnlockFactoryMap();
        throw;
    }

    UnlockFactoryMap();
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::IncrementMapCount
//
//  Increments the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::IncrementMapCount(const CWbemGlueFactory *pGlue)
{
    LONG lRet = -1;
    LockFactoryMap();

    try
    {
        PTR2PLONG::iterator mapIter;
        mapIter = CWbemProviderGlue::s_factorymap.find( pGlue );

        if (mapIter != CWbemProviderGlue::s_factorymap.end())
        {
            lRet = InterlockedIncrement((*mapIter).second);
        }
        else
        {
            // This is very bad.  This should have been created
            // at CWbemGlueFactory constructor time.
            LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
        }
    }
    catch( ... )
    {
        UnlockFactoryMap();
        throw;
    }

    UnlockFactoryMap();
    return lRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::IncrementMapCount
//
//  Increments the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::IncrementMapCount(PLONG pCount)
{
    return InterlockedIncrement(pCount);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::DecrementMapCount
//
//  Decrements the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::DecrementMapCount(const CWbemGlueFactory *pGlue)
{
    LONG lRet = -1;
    LockFactoryMap();

    try
    {
        // Find the matching CWbemGlueFactory in the CWbemGlueFactory<->refcount map
        PTR2PLONG::iterator mapIter;
        mapIter = CWbemProviderGlue::s_factorymap.find( pGlue );

        if (mapIter != CWbemProviderGlue::s_factorymap.end())
        {
            lRet = InterlockedDecrement((*mapIter).second);

            if (lRet < 0)
            {
                LogErrorMessage2(L"RefCount < 0 for glue %p", pGlue);
                ASSERT_BREAK(DUPLICATE_RELEASE);
            }
        }
        else
        {
            LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
        }
    }
    catch ( ... )
    {
        UnlockFactoryMap();
        throw;
    }

    UnlockFactoryMap();
    return lRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::DecrementMapCount
//
//  Decrements the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::DecrementMapCount(PLONG pCount)
{
    LONG lRet = InterlockedDecrement(pCount);

    if (lRet < 0)
    {
        LogErrorMessage2(L"RefCount < 0 for %p", pCount);
        ASSERT_BREAK(DUPLICATE_RELEASE);
    }

    return lRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetMapCountPtr
//
//  Returns the pointer to the plong for this glue factory
//
/////////////////////////////////////////////////////////////////////

PLONG CWbemProviderGlue::GetMapCountPtr(const CWbemGlueFactory *pGlue)
{
    PLONG pRet = NULL;
    LockFactoryMap();

    try
    {
        // Find the matching CWbemGlueFactory in the CWbemGlueFactory<->refcount map
        PTR2PLONG::iterator mapIter;
        mapIter = CWbemProviderGlue::s_factorymap.find( pGlue );

        if (mapIter != CWbemProviderGlue::s_factorymap.end())
        {
            pRet = mapIter->second;
        }
        else
        {
            LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
        }
    }
    catch( ... )
    {
        UnlockFactoryMap();
        throw;
    }

    UnlockFactoryMap();
    return pRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddFlushPtr
//
//  Add the this pointer to a provider to the list of providers
//  that need to be flushed.
//
/////////////////////////////////////////////////////////////////////

void CWbemProviderGlue::AddFlushPtr(LPVOID pVoid)
{
    CLockWrapper lockwrap(m_csFlushPtrs);

    m_FlushPtrs.insert(pVoid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\winmsgevent.cpp ===
//=================================================================

//

// WinMsgEvent.cpp -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <lockwrap.h>
#include "WinMsgEvent.h"
					
// initialize class globals
CCritSec							CWinMsgEvent::mg_csMapLock ;
CCritSec							CWinMsgEvent::mg_csWindowLock ;
CAutoEvent							CWinMsgEvent::mg_aeCreateWindow ;
CWinMsgEvent::Sink_Map				CWinMsgEvent::mg_oSinkMap ;
HANDLE								CWinMsgEvent::mg_hThreadPumpHandle = NULL;
HWND								CWinMsgEvent::mg_hWnd = NULL;

#define EVENT_MAP_LOCK_ CLockWrapper t_oAcs( mg_csMapLock ) ;
#define WINDOW_LOCK_ CLockWrapper t_oAcs( mg_csWindowLock ) ;
 
// per object call
CWinMsgEvent::CWinMsgEvent()
{}

// per object call
CWinMsgEvent::~CWinMsgEvent()
{
	UnRegisterAllMessages() ;

	// clear the WM_ENDSESSION handler
	if( mg_oSinkMap.end() == mg_oSinkMap.find( WM_ENDSESSION ) )
	{
        // Note: If WM_ENDSESSION was never IN the map, this 
        // call will return zero (failed).  However, it won't
        // do anything bad, so just ignore it.
		SetConsoleCtrlHandler( &CtrlHandlerRoutine, FALSE ) ;
	}
}


// per object call
void CWinMsgEvent::RegisterForMessage(
		
IN UINT a_message
) 
{	
	BOOL t_bFound = FALSE ;
	BOOL t_bCreateWindow = FALSE ;

	{	EVENT_MAP_LOCK_

		if( mg_oSinkMap.empty() )
		{
			t_bCreateWindow = TRUE ;
		}
		else // lookup for message/object duplicate
		{		
            CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
			t_SinkIter = mg_oSinkMap.find( a_message ) ;
			
			while( t_SinkIter != mg_oSinkMap.end() )
			{				
				if( a_message == t_SinkIter->first )
				{
					if( this == t_SinkIter->second )
					{
						t_bFound = TRUE ;
						break ;
					}
					++t_SinkIter ;
				}
				else
				{
					break ;
				}
			}
		}

		if( !t_bFound )
		{		
			// Set up a handler to simulate this message
			// as we won't get it running under local system account.
			if( WM_ENDSESSION == a_message && 
				mg_oSinkMap.end() == mg_oSinkMap.find( WM_ENDSESSION ) )
			{
				SetConsoleCtrlHandler( &CtrlHandlerRoutine, TRUE ) ;
			}

			// map the desired message for this object instance 
			mg_oSinkMap.insert( 

				pair<UINT const, CWinMsgEvent*>
				( a_message,
				  this ) ) ; 			
		}
	}

	if( t_bCreateWindow )
	{
		CreateMsgProvider() ;
	}
}

// per object call
bool CWinMsgEvent::UnRegisterMessage(
		
IN UINT a_message
) 
{
	bool t_bRet = false ;
	BOOL t_bDestroyWindow = FALSE ;

	{	EVENT_MAP_LOCK_

        CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
		t_SinkIter = mg_oSinkMap.find( a_message ) ;
					 
		while( t_SinkIter != mg_oSinkMap.end() )
		{
			if( a_message == t_SinkIter->first )
			{
				if( this == t_SinkIter->second )
				{
					t_SinkIter = mg_oSinkMap.erase( t_SinkIter ) ;				
					t_bRet = true ;
					break;
				}
				else
				{
					t_SinkIter++;
				}
			}
			else
			{
				break ;
			}
		}

		if( mg_oSinkMap.empty() )
		{
			t_bDestroyWindow = TRUE ;
		}
	}

	if( t_bDestroyWindow )
	{
		DestroyMsgWindow() ;
	}

	return t_bRet ;
}

// per object call
void CWinMsgEvent::UnRegisterAllMessages() 
{
	BOOL t_bDestroyWindow = FALSE ;

	{	// Used for scoping the lock

        EVENT_MAP_LOCK_

        CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
		t_SinkIter = mg_oSinkMap.begin() ;

		while( t_SinkIter != mg_oSinkMap.end() )
		{
			if( this == t_SinkIter->second )
			{
				t_SinkIter = mg_oSinkMap.erase( t_SinkIter ) ;
			}
            else
            {
                t_SinkIter++;
            }
		}

    	if( mg_oSinkMap.empty() )
        {
            t_bDestroyWindow = TRUE;
        }		
	}

	if( t_bDestroyWindow )
	{
		DestroyMsgWindow() ;
	}
}


// global private
void CWinMsgEvent::CreateMsgProvider()
{	
	WINDOW_LOCK_

	if( NULL == mg_hThreadPumpHandle )
	{
		DWORD t_dwThreadID ;

		// Create a thread that will spin off a windowed msg pump
		mg_hThreadPumpHandle = CreateThread(
							  NULL,						// pointer to security attributes
							  0L,						// initial thread stack size
							  dwThreadProc,				// pointer to thread function
							  0L,						// argument for new thread
							  0L,						// creation flags
							  &t_dwThreadID ) ;

		// wait for async window create
		mg_aeCreateWindow.Wait( INFINITE );
		
		if( !mg_hWnd )
		{
			CloseHandle( mg_hThreadPumpHandle ) ;
			mg_hThreadPumpHandle = NULL ;
		}
	}
}

//
void CWinMsgEvent::DestroyMsgWindow() 
{
	WINDOW_LOCK_

	HANDLE	t_hThreadPumpHandle = mg_hThreadPumpHandle ;
	HWND	t_hWnd				= mg_hWnd ;
	
	// clear globals
	mg_hThreadPumpHandle	= NULL ;
	mg_hWnd					= NULL ;

	if( t_hWnd )
	{
		SendMessage( t_hWnd, WM_CLOSE, 0, 0 ) ;
	}
	
	if( t_hThreadPumpHandle )
	{
		WaitForSingleObject( 
			
			t_hThreadPumpHandle,
			20000
		);

		CloseHandle( t_hThreadPumpHandle ) ;
	}
}

BOOL WINAPI CWinMsgEvent::CtrlHandlerRoutine(DWORD dwCtrlType)
{
	HWND	t_hWnd		= NULL ;
	UINT	t_message	= 0 ;
	WPARAM	t_wParam	= 0 ;
	LPARAM	t_lParam	= 0 ; 
	
	// simulate the message
	if( CTRL_LOGOFF_EVENT == dwCtrlType )
	{
		t_message	= WM_ENDSESSION ;
		t_wParam	= TRUE ;				// session ending
		t_lParam	= ENDSESSION_LOGOFF ;	// Logoff event
	}
	else if( CTRL_SHUTDOWN_EVENT == dwCtrlType )
	{
		t_message	= WM_ENDSESSION ;
		t_wParam	= TRUE ;	// session ending
		t_lParam	= 0 ;		// Shutdown event
	}
	
	if( t_message )
	{
		//
		MsgWndProc( t_hWnd, 
					t_message,
					t_wParam,
					t_lParam ) ;
	}

    return FALSE;       // Pass event on to next handler.
}

// worker thread pump, global private
DWORD WINAPI CWinMsgEvent::dwThreadProc( LPVOID a_lpParameter )
{
	DWORD t_dwRet = FALSE ;
	
	if( CreateMsgWindow() )
	{
		WindowsDispatch() ;

		t_dwRet = TRUE ;
	}
		
	UnregisterClass( MSGWINDOWNAME, GetModuleHandle(NULL) ) ;

	return t_dwRet ;
}

// global private
HWND CWinMsgEvent::CreateMsgWindow()
{
	DWORD t_Err = 0;
	HMODULE t_hMod = GetModuleHandle(NULL);
	
	if (t_hMod != NULL)
	{
		WNDCLASS wndclass ;
		wndclass.style			= 0 ;
		wndclass.lpfnWndProc	= MsgWndProc ;
		wndclass.cbClsExtra		= 0 ;
		wndclass.cbWndExtra		= 0 ;
		wndclass.hInstance		= t_hMod ;
		wndclass.hIcon			= NULL ;
		wndclass.hCursor		= NULL ;
		wndclass.hbrBackground	= NULL ;
		wndclass.lpszMenuName	= NULL ;
		wndclass.lpszClassName	= MSGWINDOWNAME ;

		RegisterClass( &wndclass ) ;
    
		mg_hWnd = CreateWindowEx( WS_EX_TOPMOST,
						MSGWINDOWNAME,
						TEXT("WinMsgEventProv"),
						WS_OVERLAPPED,
						CW_USEDEFAULT,
						CW_USEDEFAULT,
						CW_USEDEFAULT,
						CW_USEDEFAULT,
						NULL, 
						NULL,
						t_hMod,
						NULL ) ;
	}
	else
	{
		t_Err = GetLastError();
	}

	mg_aeCreateWindow.Signal();
	return mg_hWnd ;
}

// global private
void CWinMsgEvent::WindowsDispatch()
{
	BOOL t_GetMessage ;
	MSG	 t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( &t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( &t_lpMsg ) ;
		DispatchMessage ( &t_lpMsg ) ;
	}
}

// global private
LRESULT CALLBACK CWinMsgEvent::MsgWndProc(

IN HWND a_hWnd,
IN UINT a_message,
IN WPARAM a_wParam,
IN LPARAM a_lParam
)
{
	LRESULT			t_lResult = TRUE ;
	E_ReturnAction	t_eReturnAction = e_DefProc ;

	switch ( a_message ) 
	{
		default:
		{	
			// Run through the message map 
			// If registered requestor(s) are found dispatch it...  

			EVENT_MAP_LOCK_

            CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
			t_SinkIter = mg_oSinkMap.find( a_message ) ;

			while( t_SinkIter != mg_oSinkMap.end() )
			{				
				if( a_message == t_SinkIter->first )
				{
					// signal
					t_SinkIter->second->WinMsgEvent(

										a_hWnd,
										a_message,
										a_wParam,
										a_lParam,
										t_eReturnAction,
										t_lResult ) ;	
					++t_SinkIter ;
				}
				else
				{
					break ;
				}
			}
			// special return processing --- 
			//
			// The default is to defer to DefWindowProc.
			// However, multiple sinks can exist for a message. 
			// Each may require special return processing.
			//
			// Example: WM_POWERBROADCAST submessage PBT_APMQUERYSUSPEND requires
			// the returning of TRUE to indicate interest in additional Power
			// Event messages. This a passive request ( asking for additional info )
			// but another sink registered for this message may have a different opinion.
			// Trivial perhaps, but other message processing may be different; placing
			// the requestor at odds with the intent of another. 

			// Behavior here: All sinks are called with the
			// updated t_eReturnAction from the last sink call. 
			// If a sink suspects it would have to act diffently based on specific
			// knowledge of message usage the sink will have to instead spin off
			// its own window to handle the special return and not make use of this
			// generalized class.
			// 			
			if( e_DefProc == t_eReturnAction )
			{
                t_lResult = DefWindowProc( a_hWnd, a_message, a_wParam, a_lParam ) ;
            }
			break ;
		}

        case WM_CLOSE:
        {
            if ( mg_hWnd != NULL)
            {
                t_lResult = 0;
            }
            else
            {
                t_lResult = DefWindowProc( a_hWnd, a_message, a_wParam, a_lParam ) ;
            }
            break;
        }
		
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd, WM_QUIT, 0, 0 ) ;
            t_lResult = 0;
		}
		break ;
    }

    return t_lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\threadbase.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  ThreadBase.CPP
//
//  Purpose: Implementation of CThreadBase class
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::CThreadBase
//
//  Class Constructor.
//
//  Inputs:     THREAD_SAFETY_MECHANISM etsm - Thread Safety Mechanism.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

CThreadBase::CThreadBase( THREAD_SAFETY_MECHANISM etsm /*=etsmSerialized*/ )
:   m_lRefCount( 1 ),   // Our initial ref count is always 1
    m_etsm( etsm )
{
    InitializeCriticalSection( &m_cs ); // Void function, so it best work.
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::~CThreadBase
//
//  Class Destructor.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

CThreadBase::~CThreadBase( void )
{
    DeleteCriticalSection( &m_cs );
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::OnFinalRelease
//
//  Virtual function called by Release() when our RefCount reaches 0.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Override if you want, but always call down to the base
//              implementation and let it call delete on 'this'.
//
////////////////////////////////////////////////////////////////////////

void CThreadBase::OnFinalRelease( void )
{
    delete this;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::AddRef
//
//  Increases our Reference count by one.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Uses Lock(), Unlock() to protect the data.  We may want
//              to change the function to use InterlockedIncrement().
//
////////////////////////////////////////////////////////////////////////

LONG CThreadBase::AddRef( void )
{
    
    LONG nRet = InterlockedIncrement(&m_lRefCount);

    return nRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::Release
//
//  Decreases our Reference count by one.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Uses Lock(), Unlock() to protect the data.  We may want
//              to use InterlockedDecrement();
//
////////////////////////////////////////////////////////////////////////

LONG CThreadBase::Release( void )
{
    LONG nRet;
    
    BOOL    fFinalRelease = ( (nRet = InterlockedDecrement(&m_lRefCount)) == 0 );

    ASSERT_BREAK(nRet >= 0);

    if ( fFinalRelease )
    {
        OnFinalRelease();
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\eventprovider.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  EventProvider.H
//
//  Purpose: Definition of EventProvider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _EVENT_PROVIDER_COMPILED_
#define _EVENT_PROVIDER_COMPILED_

#ifdef EVENT_PROVIDER_ENABLED

#include "Provider.h"

// class EventProvider
//      Encapsulation of the IWbemEventProvider interfaces
class EventProvider : public Provider
{
public:
    EventProvider( const CHString& setName, LPCWSTR pszNameSpace = NULL );
    ~EventProvider( void );

    virtual HRESULT ProvideEvents(MethodContext *pContext, long lFlags = 0L  ) =0;
    // functions much like EnumerateInstances in Provider
    // use CreateNewInstance to create event instance
    // use Commit to send it on its merry way

    // overrides of the base class' pure virtuals, return WBEM_E_PROVIDER_NOT_CAPABLE
    // logic is that an event provider will not want to support them in the general case
    virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
    virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    // entry point for the framework's use.  Do not override.
    HRESULT KickoffEvents( MethodContext *pContext, long lFlags  =0L );

protected:  
    // flag validation
    virtual HRESULT ValidateProvideEventsFlags(long lFlags);
    virtual HRESULT ValidateQueryEventsFlags(long lFlags);

private:

};

#endif //EVENT_PROVIDER_ENABLED

#endif //_EVENT_PROVIDER_COMPILED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\fwcommon.h ===
//***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  FWcommon.h
//
//  Purpose: Definition of EventProvider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#define FRAMEWORK_ALLOW_DEPRECATED 0

// ALWAYS INCLUDE THIS FILE FIRST!

#ifndef _FW_COMMON_H_
#define _FW_COMMON_H_

// move warnings to level four
#pragma warning(4 : 4275 4800 4786 4251)
//	C4275: non DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier'
//	C4800: forcing bool variable to one or zero, possible performance loss
//	C4786: 'identifier' : identifier was truncated to 'number' characters in the debug information
//	C4251: 'identifier' : class 'type' needs to have dll-interface to export class 'type2'


#include "windows.h"

// This function gets macro'ed to GetObjectW and GetObjectA based on the
// contents of UNICODE.  However, we USE a function called GetObject.  For
// single binary support, we can't have this being macro'ed.  If the actual
// win32 api GetObject is needed, call the GetObjectW or GetObjectA directly.
#undef GetObject
#include <wbemidl.h>
#include <wmiutils.h>

// If USE_POLARITY not defined, some Framedyn.dll symbols may not resolve correctly
// It's a declspec(dllimport/dllexport) issue.
#ifndef USE_POLARITY

// For most users, this is the correct setting for POLARITY.
#define USE_POLARITY

#endif

// Required since TCHAR.H defines _ttoi64 -> atoi64, which requires oldnames.lib, which
// we don't use.
#define atoi64 _atoi64

#include <Polarity.h>

#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP

#include <stllock.h>
extern POLARITY CCritSec g_cs;

#include "utillib.h"
#include "ThrdBase.h"
#include "RefPtrCo.h"
#include "MethodCo.h"
#include "FRQuery.h"
#include "wbemglue.h"
#include "instance.h"

class CFramework_Exception
{
private:

	CHString m_sErrorText;
    HRESULT m_hr;

public:

	CFramework_Exception ( LPCWSTR lpwszErrorText, HRESULT hr) : m_hr ( hr ) , m_sErrorText ( lpwszErrorText) {}
	CFramework_Exception ( LPCWSTR lpwszErrorText) : m_hr ( WBEM_S_NO_ERROR ) , m_sErrorText ( lpwszErrorText) {}
	~CFramework_Exception () {}

	HRESULT GetHRESULT() { return m_hr ; }
	CHString &GetErrorText() { return m_sErrorText; }
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\frquery.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FRQuery.h
//
//  Purpose: query support classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FRAMEWORK_QUERY_H_
#define _FRAMEWORK_QUERY_H_
#include <stdio.h>
#include <sql_1.h>
#include <comdef.h>
#include <vector>

class POLARITY CFrameworkQuery
{
public:
    CFrameworkQuery();
    ~CFrameworkQuery();

    // Finds out if a particular field was requested by the query in either
    // the Select statement, or the Where statement.  Only meaningful if we
    // are in ExecQueryAsync and the query has been sucessfully parsed.
    bool IsPropertyRequired(LPCWSTR propName);

    // Gets the class name from the query.  Only meaningful if we are
    // in ExecQueryAsync and the query has been sucessfully parsed.  It
    // is the responsibility of the caller to SysFreeString the returned
    // string.
    BSTR GetQueryClassName(void) { return SysAllocString(m_bstrtClassName); }

    // Given a property name, it will return all the values
    // that the query requests in a CHStringArray.
    // Select * from win32_directory where drive = "C:" GetValuesForProp(L"Drive") -> C:
    // Where Drive = "C:" or Drive = "D:" GetValuesForProp(L"Drive") -> C:, D:
    // Where Path = "\DOS" GetValuesForProp(L"Drive") -> (empty)
    // Where Drive <> "C:" GetValuesForProp(L"Drive") -> (empty)
    // Where Drive = "C:" or (Drive = "D:" and Mounted = true) GetValuesForProp(L"Drive") -> C:, D:
    HRESULT GetValuesForProp(LPCWSTR wszPropName, CHStringArray& achNames);

    // Here's an overloaded version in case client wants to pass in a vector of _bstr_t's
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<_bstr_t>& vectorNames);

    // Returns a list of all the properties specified in the Select clause, plus.
    // all the the properties from the Where clauses.  If the returned array is empty, all
    // properties are required.
    void GetRequiredProperties(CHStringArray &saProperties);

    // Boolean indicating if all properties are being requested.
    bool AllPropertiesAreRequired(void) { return (m_csaPropertiesRequired.GetSize() == 0); }

    // Boolean indicating if only the key properties are required.
    bool KeysOnly(void) { return m_bKeysOnly; }

    // Accessor function to retrieve wql query
    const CHString &GetQuery() ;

    // Moves the values into the member variables.  Should never be called by users.
    HRESULT Init(
        
        const BSTR bstrQueryFormat, 
        const BSTR bstrQuery, 
        long lFlags,
        CHString &sNamespace
    );

    // Moves the values into the member variables.  Should never be called by users.
    HRESULT Init(

        ParsedObjectPath *pParsedObjectPath, 
        IWbemContext *pCtx, 
        LPCWSTR lpwszClassName,
        CHString &sNamespace
    );

    // Initializes the KeysOnly data member.  Should never be called by users.
    void Init2(IWbemClassObject *IClass);


protected:

    /*****************************************************************************/
    /* The rest of these data members and functions are intended for Microsoft   */
    /* internal use only. Use by third parties is unsupported and unrecommended. */
    /*****************************************************************************/

    SQL_LEVEL_1_RPN_EXPRESSION *m_pLevel1RPNExpression;
    CHStringArray m_csaPropertiesRequired;
    enum QueryTypes{eUnknown, eWQLCommand, eContextObject} m_QueryType;

    DWORD IsInList(const CHStringArray &csaArray, LPCWSTR pwszValue);

    BOOL IsReference(LPCWSTR lpwszPropertyName);
    const CHString &GetNamespace();

private:

    CHString m_sNamespace;
    long m_lFlags;
    IWbemClassObject *m_IClass;
    CHString m_sQueryFormat;

    void Reset(void);
    bool m_bKeysOnly;
    bool m_AddKeys;
    CHString m_sQuery;
    bstr_t m_bstrtClassName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\methodco.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MethodCo.h
//
//  Purpose: declaration of MethodContext class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _METHOD_CONTEXT_H__
#define _METHOD_CONTEXT_H__

//#include "ThrdBase.h"
//#include "refptrco.h"

#ifdef PROVIDER_INSTRUMENTATION
    #include <stopwatch.h>
#endif

class CInstance;
class Provider;
class MethodContext;
class CWbemProviderGlue;
class InternalMethodContextAsynch;

typedef HRESULT (WINAPI *LPProviderInstanceCallback)(Provider *pProvider, CInstance *pInstance, MethodContext *pContext, void *pUserData);

//////////////////////////////////////////////////////
//
//  STRUCT MethodContext
//
// a little something to make sure we can keep our threads from getting tangled
// idea is that there is one MethodContext for each request from CIMOM or another provider
// pointers are passed around.
//////////////////////////////////////////////////////
class POLARITY MethodContext : public CThreadBase
{
public:
    friend InternalMethodContextAsynch;
    friend CWbemProviderGlue;

    MethodContext(IWbemContext   __RPC_FAR *piContext, CWbemProviderGlue *pGlue);
    ~MethodContext();
    
    virtual HRESULT Commit(CInstance *pInstance) = 0;
    virtual IWbemContext __RPC_FAR *GetIWBEMContext();
    
    LONG AddRef(void);
    LONG Release(void);
    virtual void QueryPostProcess(void);
        
    bool SetStatusObject(IWbemClassObject *pObj);
    IWbemClassObject __RPC_FAR *GetStatusObject();

#ifdef PROVIDER_INSTRUMENTATION
    StopWatch *pStopWatch;
#endif
    
private:
    CWbemProviderGlue* GetProviderGlue();
    CWbemProviderGlue   *m_pGlue;
    IWbemContext        __RPC_FAR *m_pContext;
    IWbemClassObject    __RPC_FAR *m_pStatusObject;

};

// for queries and suchlike that originate in CIMOM
class 
__declspec(uuid("9113D3B4-D114-11d2-B35D-00104BC97924")) 
ExternalMethodContext  : public MethodContext
{
public:
    ExternalMethodContext(IWbemObjectSink __RPC_FAR *pResponseHandler,
                          IWbemContext    __RPC_FAR *pContext,
                          CWbemProviderGlue *pGlue,
                          void                      *pReserved = NULL
                          );
    
    HRESULT Commit(CInstance *pInstance);
    virtual void QueryPostProcess(void);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    IWbemObjectSink __RPC_FAR *m_pResponseHandler;
    void                      *m_pReserved;
};

// for queries and suchlike that come from within.
// contains a list of objects returned. 
class 
__declspec(uuid("6AF4B074-D121-11d2-B35D-00104BC97924"))
InternalMethodContext : public MethodContext
{
public:
    InternalMethodContext(TRefPointerCollection<CInstance> *pList ,
                          IWbemContext    __RPC_FAR *pContext,
                          CWbemProviderGlue *pGlue);
    ~InternalMethodContext();
    
    HRESULT Commit(CInstance *pInstance);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    TRefPointerCollection<CInstance> *m_pInstances;
};

// for queries and suchlike that come from within.
// "Asynch" is a bit of a misnomer - but it does help support
// asynchronous calls, in that each instance committed is routed
// to a callback function supplied by the requester
class 
__declspec(uuid("D98A82E8-D121-11d2-B35D-00104BC97924"))
InternalMethodContextAsynch : public MethodContext
{
public:
    InternalMethodContextAsynch(Provider *pThat,
                                LPProviderInstanceCallback pCallback,
                                IWbemContext __RPC_FAR *pContext,
                                MethodContext *pUsersContext,
                                void *pUserData);
    ~InternalMethodContextAsynch();
    
    HRESULT Commit(CInstance *pInstance);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    Provider *m_pThat;
    LPProviderInstanceCallback m_pCallback;
    void *m_pUserData;
    MethodContext *m_pUsersContext;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\stllock.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  stllock.h
//
//  Purpose: Critical section class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _STLLOCK_H_
#define _STLLOCK_H_

class CCritSec : public CRITICAL_SECTION
{
public:
    CCritSec() 
    {
        InitializeCriticalSection(this);
    }
    ~CCritSec()
    {
        DeleteCriticalSection(this);
    }
    void Enter()
    {
        EnterCriticalSection(this);
    }
    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\provider.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Provider.h
//
//  Purpose: declaration of Provider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_H__
#define _PROVIDER_H__

/////////////////////////////////////////////////////
// INSTANCE Provider
//
// pure virtual base class for providers
// holds instances
// gathers information and instantiates instances
/////////////////////////////////////////////////////
class POLARITY Provider : public CThreadBase
{
    // CWbemProviderGlue needs to access some protected/private methods
    // which we don't want to publish to just anyone.

    friend class CWbemProviderGlue;

    public:
        Provider( LPCWSTR a_pszName, LPCWSTR a_pszNameSpace = NULL );
        ~Provider();

    protected:
        /* Override These Methods To Implement Your Provider */
        
        // This is the entrypoint for changes.
        // You are handed a changed instance.
        // If you can make the changes - do so.
        // If you cannot return an appropriate error code (WBEM_E_XXXXXXX)
        // base object returns WBEM_E_PROVIDER_NOT_CAPABLE
        virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);

        // entrypoint to delete an instance
        // examine the instance passed in, determine whether you can delete it
        virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

        // execute a method
        virtual HRESULT ExecMethod(const CInstance& cInstance, 
                                   const BSTR bstrMethodName, 
                                   CInstance *pInParams, 
                                   CInstance *pOutParams, 
                                   long lFlags = 0L);

        // find and create all instances of your class
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

        // you will be given an object with the key properties filled in
        // you need to fill in all of the rest of the properties, or
        // return WBEM_E_NOT_FOUND if the object doesn't exist.
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);

        // You will be given an object with the key properties filled in.
        // You can either fill in all the properties, or check the Query object
        // to see what properties are required.  If you don't implement this method, the
        // GetObject(CInstance, long) method will be called instead.
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query);

        // If a provider wants to process queries, they should override this
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                                  CFrameworkQuery& cQuery, 
                                  long lFlags = 0L);

        // flushes cache
        // only override if you allocate memory that could be flushed
        virtual void Flush(void);

        /* Helpers - Use These, Do Not Override */

        // allocate a new instance & return pointer to it
        // the memory is your responsibility to Release()
        // UNLESS you pass it off to Provider::Commit
        CInstance *CreateNewInstance(MethodContext *pMethodContext);

        // used to send your new instance back to the framework
        // set bCache to true to cache object 
        // !! caching is NOT IMPLEMENTED in this release !!
        // do not delete or release the pointer once committed.
        HRESULT Commit(CInstance *pInstance, bool bCache = false);

        // Helper function for building a WBEM Object Path for a local Instance
        bool GetLocalInstancePath( const CInstance *pInstance, CHString& strPath );

        //   Builds a full instance path from a relative path
        CHString MakeLocalPath( const CHString &strRelPath );

        // Returns the computer name as a CHString.  Save yourself the os call,
        // since we've got it hanging around anyway.
        const CHString &GetLocalComputerName() {return s_strComputerName;}
        const CHString &GetNamespace() {return m_strNameSpace;}

        // sets the CreationClassName property to the name of this provider
        bool SetCreationClassName(CInstance *pInstance);

        // accesses the name of the provider
        const CHString &GetProviderName() {return m_name;}

        // Flag validation constants
        enum FlagDefs
        {
            EnumerationFlags = (WBEM_FLAG_DIRECT_READ | WBEM_FLAG_SEND_STATUS),
            GetObjFlags = (WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ),
            MethodFlags = WBEM_FLAG_SEND_STATUS,
            DeletionFlags = WBEM_FLAG_SEND_STATUS,
            PutInstanceFlags = (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_SEND_STATUS),
            QueryFlags = WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ
        };

        // returns WBEM_E_UNSUPPORTED_PARAMETER or WBEM_S_NO_ERROR
        HRESULT ValidateFlags(long lFlags, FlagDefs lAcceptableFlags);

        // you can override the following to support flags 
        // above and beyond those listed in FlagDefs above
        virtual HRESULT ValidateEnumerationFlags(long lFlags);
        virtual HRESULT ValidateGetObjFlags(long lFlags);
        virtual HRESULT ValidateMethodFlags(long lFlags);
        virtual HRESULT ValidateQueryFlags(long lFlags);
        virtual HRESULT ValidateDeletionFlags(long lFlags);
        virtual HRESULT ValidatePutInstanceFlags(long lFlags);
        
    private:

        IWbemServices       *m_pIMosProvider;    // provides instances
        CHString            m_name;             // name of this provider
        CHString            m_strNameSpace;     // name of this provider's namespace
        IWbemClassObject    *m_piClassObject;    // holds class object from which others are cloned.

        static CHString     s_strComputerName;  // Holds the computer name for building
                                                // instance paths.
        
        BOOL ValidateIMOSPointer( void );       // This function ensures that our IMOS
                                                // pointer is available, and is called
                                                // by the framework entrypoint functions

        /* Interfaces For Use by the Framework         */
        HRESULT GetObject(  ParsedObjectPath *pParsedObjectPath, 
                            MethodContext *pContext, long lFlags = 0L );

        HRESULT ExecuteQuery( MethodContext *pContext, 
                              CFrameworkQuery &pQuery, 
                              long lFlags = 0L);

        HRESULT CreateInstanceEnum( MethodContext *pContext, long lFlags = 0L );

        HRESULT PutInstance( IWbemClassObject __RPC_FAR *pInst,
                             long lFlags,
                             MethodContext *pContext );

        HRESULT DeleteInstance( ParsedObjectPath *pParsedObjectPath,
                                long lFlags,
                                MethodContext *pContext );

        HRESULT ExecMethod( ParsedObjectPath *pParsedObjectPath,
                            BSTR bstrMethodName,
                            long lFlags,
                            CInstance *pInParams,
                            CInstance *pOutParams,
                            MethodContext *pContext );

        // Static helper function called by constructor to make sure the
        // computer name variable is properly initialized.
        static void WINAPI InitComputerName( void );

        // Sets an instance key from a parsed object path.
        BOOL SetKeyFromParsedObjectPath( CInstance *pInstance, 
                                         ParsedObjectPath *pParsedObjectPath );

        IWbemClassObject *GetClassObjectInterface(MethodContext *pMethodContext);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\instance.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Instance.h
//
//  Purpose: Definition of CInstance class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INSTANCE_H_
#define _INSTANCE_H_

#define WBEMINT64 CHString
#define WBEMINT16 short

///////////////////////////////////////////
//
// CLASS CInstance
//
// base instance class
// encapsulation of IWbemClassObject
///////////////////////////////////////////
class
__declspec(uuid("3402945E-D19A-11d2-B35E-00104BC97924"))
POLARITY CInstance
{
    public:
        CInstance(IWbemClassObject *piClassObject, MethodContext *pMethodContext);
        virtual ~CInstance();

        // AddRef/Release
        LONG   AddRef( void );
        LONG   Release( void );

        // Get and Set for various data types
        bool SetNull(LPCWSTR name );
        bool SetStringArray(LPCWSTR name, const SAFEARRAY &strArray);
        bool SetWORD(LPCWSTR name,  WORD w);
        bool SetDWORD(LPCWSTR name,  DWORD d);
        bool Setbool(LPCWSTR name,  bool  b);
        bool SetVariant(LPCWSTR name,  const VARIANT& variant );
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        bool SetCharSplat(LPCWSTR name,  DWORD dwResID);
#endif
        bool SetCharSplat(LPCWSTR name,  LPCWSTR pStr);
        bool SetCharSplat( LPCWSTR name,  LPCSTR pStr);
        bool SetWCHARSplat(LPCWSTR name,  LPCWSTR pStr);
        bool SetDateTime(LPCWSTR name,  const WBEMTime& wbemtime );
        bool SetTimeSpan(LPCWSTR name,  const WBEMTimeSpan& wbemtimespan );
        bool SetWBEMINT64(LPCWSTR name, const WBEMINT64& wbemint64 );
        bool SetWBEMINT64(LPCWSTR name, const LONGLONG i64Value );
        bool SetWBEMINT64( LPCWSTR name, const ULONGLONG i64Value );
        bool SetWBEMINT16(LPCWSTR name, const WBEMINT16& wbemint16 );
        bool SetByte(LPCWSTR name, BYTE b );
        bool SetEmbeddedObject (LPCWSTR name, CInstance& cInstance ) ;
        bool SetDOUBLE(LPCWSTR name, DOUBLE dub );
        bool SetCHString(LPCWSTR name, LPCWSTR str);
        bool SetCHString(LPCWSTR name,  const CHString& str);
        bool SetCHString(LPCWSTR name, LPCSTR str);

        bool GetStringArray(LPCWSTR name,  SAFEARRAY *& strArray)     const;
        bool GetCHString(LPCWSTR name, CHString& str) const;
        bool GetWCHAR(LPCWSTR name,  WCHAR **pW) const;
        bool GetWORD(LPCWSTR name,  WORD& w) const;
        bool GetDWORD(LPCWSTR name,  DWORD& d) const;
        bool Getbool(LPCWSTR name,  bool&  b) const;
        bool GetVariant(LPCWSTR name, VARIANT& variant ) const;
        bool GetDateTime(LPCWSTR name,  WBEMTime& wbemtime ) const;
        bool GetTimeSpan(LPCWSTR name,  WBEMTimeSpan& wbemtimespan ) const;
        bool GetWBEMINT64(LPCWSTR name, WBEMINT64& wbemint64 ) const;
        bool GetWBEMINT64(LPCWSTR name, LONGLONG& i64Value ) const;
        bool GetWBEMINT64( LPCWSTR name, ULONGLONG& i64Value) const;
        bool GetWBEMINT16(LPCWSTR name, WBEMINT16& wbemint16 ) const;
        bool GetByte(LPCWSTR name, BYTE& b ) const;
        bool GetEmbeddedObject(LPCWSTR name, CInstance** pInstance,  MethodContext *pMethodContext) const;
        bool GetDOUBLE(LPCWSTR name, DOUBLE& dub) const;
        bool IsNull(LPCWSTR name) const;
        bool GetStatus(LPCWSTR name, bool &a_Exists , VARTYPE &a_VarType ) const ;

        HRESULT Commit(void);
        IWbemClassObject *GetClassObjectInterface();
        MethodContext *GetMethodContext() const;

    protected:
        // All items in this section intended for Microsoft internal use only
        // use by third parties is unsupported and unrecommended
        void LogError(LPCWSTR errorStr, LPCWSTR pFunctionName, LPCWSTR pArgs = NULL, HRESULT hError = -1) const;

        IWbemClassObject *m_piClassObject;
        MethodContext*   m_pMethodContext;
        LONG             m_nRefCount;

        friend class CWbemProviderGlue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\refptrco.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  RefPtrCo.h
//
//  Purpose: definition of TRefPointerCollection template
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRCOLLECTION_H__
#define __REFPTRCOLLECTION_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTRCOLLECTION_POSITION;
#define	REFPTRCOLLECTION_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPointerCollection : public CThreadBase
{
public:

	// Construction/Destruction
	TRefPointerCollection();
	~TRefPointerCollection();
    TRefPointerCollection(const TRefPointerCollection& trpc);

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );

	BOOL		BeginEnum( REFPTRCOLLECTION_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTRCOLLECTION_POSITION& pos );
	void		EndEnum( void );

	void		Empty( void );
    int         GetSize( void ) const;

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPointerCollection<TYPED_PTR>& Copy( const TRefPointerCollection<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::TRefPointerCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection( void )
:	CThreadBase(),
	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::~CRefPointerCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::~TRefPointerCollection( void )
{
	Empty();
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::CRefPointerCollection
//              Copy constructor
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection(
    const TRefPointerCollection& trpc)
{
    Copy(trpc);	
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		// Get write access
		if ( BeginWrite() )
		{
            try
            {
			    // If Add succeeds, the pointer will be released when it
			    // is removed.

			    ptr->AddRef();

			    if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
			    {
				    fReturn = TRUE;
			    }
			    else
			    {
				    ptr->Release();	// Add failed, so Release the AddRef
			    }
            }
            catch ( ... )
            {
    	        EndWrite() ;
                throw;
            }

			EndWrite();	// Release the BeginWrite()
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTRCOLLECTION_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::BeginEnum( REFPTRCOLLECTION_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	if ( BeginRead() )
	{
		pos = REFPTRCOLLECTION_START;
		fReturn = TRUE;
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	Ends Read Access granted by calling BeginEnum().
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::EndEnum( void )
{
	EndRead();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetNext
//
//	Uses the REFPTRCOLLECTION_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPointerCollection<TYPED_PTR>::GetNext( REFPTRCOLLECTION_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( BeginRead() )
	{
		if ( ++pos < (DWORD) m_ptrArray.GetSize() )
		{
			ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

			if ( NULL != ptr )
			{
				ptr->AddRef();
			}
		}

		EndRead();
	}

	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

	BeginWrite();

    try
    {

	    int	nSize	=	m_ptrArray.GetSize();

	    // Only empty it if it is not empty
	    if ( nSize > 0 )
	    {
		    TYPED_PTR*	ptr		=	NULL;

		    for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		    {
			    ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			    if ( NULL != ptr )
			    {
				    ptr->Release();	// AddRef we did when we added it
			    }
		    }

		    // Now dump the array
		    m_ptrArray.RemoveAll();

	    }	// IF nSize > 0

    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPointerCollection<TYPED_PTR>& TRefPointerCollection<TYPED_PTR>::Copy( const TRefPointerCollection<TYPED_PTR>& collection )
{
	// By default this is an infinite wait, so it best come back
	BeginWrite();

    try
    {

	    // Dump out the array
	    Empty();

	    int	nSize = collection.m_ptrArray.GetSize();

	    for ( int nCount = 0; nCount < nSize; nCount++ )
	    {
		    TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		    // Add will automatically AddRef the pointer again.
		    Add( ptr );
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetSize
//
//	Inputs:		None.
//
//	Outputs:	Number of elements in the collection
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
int TRefPointerCollection<TYPED_PTR>::GetSize(void) const
{
    return m_ptrArray.GetSize();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\thrdbase.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  ThrdBase.h
//
//  Purpose: Definition of ThreadBase class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __THREADBASE_H__
#define __THREADBASE_H__

class POLARITY CThreadBase
{
public:

	enum THREAD_SAFETY_MECHANISM
	{
		etsmFirst		= 0,
		etsmSerialized	= 0,
		etsmPriorityRead,
		etsmPriorityWrite,
		etsmLast
	};

	// Construction/Destruction
	CThreadBase( THREAD_SAFETY_MECHANISM etsm = etsmSerialized );
	virtual ~CThreadBase();

	// Thread Safe Ref/Counting functions
	LONG	AddRef( void );
	LONG	Release( void );

	// Provide Readable Read/Write accessors should
	// we not want to serialize at a later date.  Note
	// that timeouts have no meaning unless we're
	// doing a non-serialized implementation.

	BOOL	BeginRead( DWORD dwTimeOut = INFINITE );
	void	EndRead( void );

	BOOL	BeginWrite( DWORD dwTimeOut = INFINITE );
	void	EndWrite( void );

protected:

	virtual void	OnFinalRelease( void );

	// Thread Safety functions


private:

	CRITICAL_SECTION		m_cs;
	LONG					m_lRefCount;
	THREAD_SAFETY_MECHANISM	m_etsm;

	// Private thread safety functions.  We can maybe promote
	// these to protected if we see a need to later, however
	// for right now, everyone should specify if they mean
	// to read or write when they wish to access data that
	// may change.

	void	Lock( void );
	void	Unlock( void );

};

inline BOOL CThreadBase::BeginRead( DWORD dwTimeout /*=INFINITE*/ )
{
	EnterCriticalSection( &m_cs );
	return TRUE;
}

inline void CThreadBase::EndRead( void )
{
	LeaveCriticalSection( &m_cs );
}

inline BOOL CThreadBase::BeginWrite( DWORD dwTimeout /*=INFINITE*/ )
{
	EnterCriticalSection( &m_cs );
	return TRUE;
}

inline void CThreadBase::EndWrite( void )
{
	LeaveCriticalSection( &m_cs );
}

inline void CThreadBase::Lock( void )
{
	EnterCriticalSection( &m_cs );
}

inline void CThreadBase::Unlock( void )
{
	LeaveCriticalSection( &m_cs );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\createmutexasprocess.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  CreateMutexAsProcess.h
//
//  Purpose: Create a mutex NOT using impersonation
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CREATE_PROCESS_AS_MUTEX_
#define _CREATE_PROCESS_AS_MUTEX_

///////////////////////////////////////////////////////////////////
//  Creates a specified mutex under the process account context.
//
//  Uses construction/destruction semantics - just declare one
//	on the stack, scoped around the area where you are making 
//	calls that could cause the deadlock;
//////////////////////////////////////////////////////////////////
class POLARITY CreateMutexAsProcess
{
public:
	CreateMutexAsProcess(const WCHAR *cszMutexName);
	~CreateMutexAsProcess();
private:
	HANDLE m_hMutex;
};

//  This Mutex should be instanciated around any calls to 
//  LookupAccountSid, LookupAccountName, 
//
#define SECURITYAPIMUTEXNAME L"Cimom NT Security API protector"

// Used by provider.cpp
#define WBEMPROVIDERSTATICMUTEX L"WBEMPROVIDERSTATICMUTEX"

// Used by all perfmon routines.
#define WBEMPERFORMANCEDATAMUTEX L"WbemPerformanceDataMutex"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\lockwrap.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  LockWrap.h
//
//  Purpose: Wrapper class for critical sections
//
//***************************************************************************

#include "stllock.h"

#if _MSC_VER > 1000
#pragma once
#endif

// You use this class by passing via the constructor the name of the 
// critical section you want to lock.  When the CLockWrapper goes
// out of scope it will unlock itself.
class CLockWrapper
{
public:
    CLockWrapper(CCritSec &cs)
    {
	    m_pCS = &cs;

	    m_pCS->Enter();
    }

    ~CLockWrapper()
    {
        m_pCS->Leave();
    }

protected:
    CCritSec *m_pCS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\frqueryex.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FRQueryEx.h
//
//  Purpose: Extended and non-published query support classes
//
//***************************************************************************

#pragma once

#define SetBit( p, offset ) \
            *((BYTE*)p + ((unsigned int)offset / 8)) |= (1 << ((unsigned int)offset % 8) )

#define IsBitSet( p, offset )   \
            *((BYTE*)p + ((unsigned int)offset / 8)) & (1 << ((unsigned int)offset % 8) )

#define SetAllBits( p, maxBits )    \
            memset( p , 0xff, ((unsigned int)maxBits / 8) + 1 )

#define ZeroAllBits( p, maxBits )   \
            memset( p , 0x00, ((unsigned int)maxBits / 8) + 1 )

class POLARITY CFrameworkQueryEx : public CFrameworkQuery
{
protected:
    CHString m_sQueryEx;

public:
    CFrameworkQueryEx();
    ~CFrameworkQueryEx();

// Note: call VariantInit on the variants before calling this function.

// This method is a quick and dirty implementation.  It is needed to allow for optimization of
// a specific type of query that is generated by cimon during a specific type of assocation queries.
// If the association is between two instances of the same class (like Directory To SubDirectory),
// cimom generates a query of the form WHERE (Antecedent = 'D:\foo' or Dependent = 'D:\foo').  The normal
// GetValuesForProp can't handle this.
//
// First this routine checks the query to see if it is an OR query between
// exactly two expressions.  The expressions must be = operators (ie not >, <=, etc).
// If so, then it checks the property names of the two expressions against the two passed in property names.
// If they both match, it sends back the values in the variants, and returns TRUE;
//
// So, these queries all return FALSE for a call like this (L"x", L"y", vVar1, vVar2):
// "Select * from foo"
// "Select * from foo where x=5",
// "Select * from foo where x=5 and y = 7"
// "Select * from foo where x = 5 or x = 6 or x = 7"
// "Select * from foo where x = 5 or y < 8"
// "Select * from foo where x = 5 or z = 9"

// These will return TRUE for the same call
// "Select * from foo where x = 5 or y = 6
// "Select * from foo where y = 6 or x = 5"
// "Select * from foo where (y = 6 or x = 5)"
    BOOL Is3TokenOR(LPCWSTR wszProp1, LPCWSTR wszProp2, VARIANT &vVar1, VARIANT &vVar2);


/*****************************************************************************
 *
 *  FUNCTION    : IsNTokenAnd
 *
 *  DESCRIPTION : Checks to see if the query is of the form:
 *                propname1 = value1 [and propname2 = value2 [and etc]]]
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : CHStringArray - Outputs the propnames
 *                CHPtrArray    - Outputs array of variant_t*
 *
 *  RETURNS     : TRUE if the query is of the correct form, else FALSE
 *
 *  COMMENTS    :
 *
 *  The only joining operator recognized is AND.  'OR' and 'NOT' will both
 *  cause the function to return FALSE.  Because of the operation of the
 *  parsing class, parenthesis will get simplified out if all joining operators
 *  are AND, so ((propname1 = value1) and propname2 = value2) should also work.
 *
 *  The properties must be doing equality comparisons (=) to their values (ie not
 *  >, < >=, etc).  If they are not, this function returns FALSE.
 *
 *  Lastly, property names cannot repeat, or else this function returns FALSE.
 *
 *  Both the CHStringArray and the CHPtrArray must be empty before calling this
 *  function.  Further, the elements CHPtrArray MUST BE FREED BY THE CALLER.
 *
 *  As a note, the property names returned in sarr will all be uppercase.
 *
 *  Also note, queries of the form propname1 = value1 will return true.
 *
 *****************************************************************************/

    BOOL IsNTokenAnd(CHStringArray &sarr, CHPtrArray &sPtrArr);


    // Like CFrameworkQuery::GetValuesForProp except uses variant_t's.
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<_variant_t>& vectorValues);

    // Like CFrameworkQuery::GetValuesForProp except uses ints
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<int>& vectorValues);

/*****************************************************************************
 *
 *  FUNCTION    : GetPropertyBitMask
 *
 *  DESCRIPTION : Checks an array of property names, and sets a bitmask to
 *                show which properties are required.
 *
 *  INPUTS      : Array to scan
 *
 *  OUTPUTS     : Array of bits.
 *
 *  RETURNS     :
 *
 *  COMMENTS    : We must populate the elements in the where clause, otherwise
 *                winmgmt will postprocess away all our instances.
 *
 *****************************************************************************/
    void GetPropertyBitMask(const CHPtrArray &Properties, LPVOID pBits);

    virtual HRESULT InitEx(

            const BSTR bstrQueryFormat, 
            const BSTR bstrQuery, 
            long lFlags,
            CHString &sNamespace
    );

    virtual bool IsExtended();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\include\wbemglue.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WBEMGLUE.H
//
//  Purpose: Implementation of WBEM Glue classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WbemGlue_H_Included
#define _WbemGlue_H_Included

#undef PURE
#define PURE {return (ULONG)E_NOTIMPL;}
typedef LPVOID *PPVOID;

#include <wbemidl.h>
#include <map>
#include <set>
#include <provider.h>

#define DEFAULT_NAMESPACE       L"Root\\CimV2"

typedef std::map<CHString, LPVOID> STRING2LPVOID;
typedef std::map<LPCVOID, PLONG> PTR2PLONG;
typedef std::set<LPVOID> PROVIDERPTRS;

class CWbemGlueFactory;
class CWbemGlueImpersonation;

class POLARITY CWbemProviderGlue : public IWbemServices, public IWbemProviderInit
{

	friend class CWbemGlueImpersonation;

	public:
    // Public Static functions
    // these are for use by implementors of Framework based providers

    static HRESULT WINAPI GetAllInstances( LPCWSTR pszClassName, 
                                           TRefPointerCollection<CInstance> *pList, 
                                           LPCWSTR pszNamespace, 
                                           MethodContext *pMethodContext );

    static HRESULT WINAPI GetAllInstancesAsynch( LPCWSTR pszClassName, 
                                                 Provider *pRequester, 
                                                 LPProviderInstanceCallback pCallback, 
                                                 LPCWSTR pszNamespace, 
                                                 MethodContext *pMethodContext, 
                                                 void *pUserData );

    static HRESULT WINAPI GetAllDerivedInstancesAsynch( LPCWSTR pszBaseClassName, 
                                                        Provider *pRequester, 
                                                        LPProviderInstanceCallback pCallback, 
                                                        LPCWSTR pszNamespace, 
                                                        MethodContext *pMethodContext, 
                                                        void *pUserData );

    static HRESULT WINAPI GetAllDerivedInstances( LPCWSTR pszBaseClassName, 
                                                  TRefPointerCollection<CInstance> *pList, 
                                                  MethodContext *pMethodContext, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                                  LPCWSTR pszNamespace = NULL);
#else
                                                  LPCWSTR pszNamespace);
#endif

    static HRESULT WINAPI GetInstanceByPath( LPCWSTR pszObjectPath, 
                                             CInstance **ppInstance, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                             MethodContext *pMethodContext = NULL );
#else
                                             MethodContext *pMethodContext);
#endif

    static HRESULT WINAPI GetInstanceKeysByPath( LPCWSTR pszInstancePath,
                                                 CInstance **ppInstance,
                                                 MethodContext *pMethodContext);

    static HRESULT WINAPI GetInstancePropertiesByPath( LPCWSTR pszInstancePath,
                                                 CInstance **ppInstance,
                                                 MethodContext *pMethodContext,
                                                 CHStringArray &csaProperties);

    static HRESULT WINAPI GetInstancesByQuery( LPCWSTR query, 
                                               TRefPointerCollection<CInstance> *pList, 
                                               MethodContext *pMethodContext,  
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                               LPCWSTR pszNamespace = NULL);
#else
                                               LPCWSTR pszNamespace);
#endif

    static HRESULT WINAPI GetInstancesByQueryAsynch( LPCWSTR query, 
                                                     Provider *pRequester, 
                                                     LPProviderInstanceCallback pCallback, 
                                                     LPCWSTR pszNamespace, 
                                                     MethodContext *pMethodContext, 
                                                     void *pUserData );

#ifdef FRAMEWORK_ALLOW_DEPRECATED
    // This version of GetEmptyInstance is deprecated.  Use the next one.
    static HRESULT WINAPI GetEmptyInstance( LPCWSTR pszClassName, 
                                            CInstance **ppInstance, 
                                            LPCWSTR pszNamespace = NULL);
#endif

    static HRESULT WINAPI GetEmptyInstance( MethodContext *pMethodContext, 
                                            LPCWSTR pszClassName, 
                                            CInstance **ppInstance, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                            LPCWSTR pszNamespace = NULL);
#else
                                            LPCWSTR pszNamespace);
#endif

    // Both of these FillInstance calls are deprecated.  Use GetInstanceByPath, or the even
    // more performant functions GetInstanceKeysByPath or GetInstancePropertiesByPath.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
    static HRESULT WINAPI FillInstance( CInstance *pInstance, 
                                        LPCWSTR pszNamespace = NULL );

    static HRESULT WINAPI FillInstance( MethodContext *pMethodContext, 
                                        CInstance *pInstance );
#endif

    // determine whether one class is derived from another
    static bool  WINAPI IsDerivedFrom( LPCWSTR pszBaseClassName, 
                                       LPCWSTR pszDerivedClassName, 
                                       MethodContext *pMethodContext, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                       LPCWSTR pszNamespace = NULL );
#else
                                       LPCWSTR pszNamespace);
#endif

    // logging in and out of framework
    // each framework based DLL must log in and out with these functions

     // Deprecated in favor of the version that takes a PLONG.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
    static BOOL WINAPI FrameworkLoginDLL(LPCWSTR name);
    static BOOL WINAPI FrameworkLogoffDLL(LPCWSTR name);
#endif

    // You must pass the *same* PLONG to all three of FrameworkLoginDLL, 
    // FrameworkLogoffDLL, and the CWbemGlueFactory constructor.
    static BOOL WINAPI FrameworkLoginDLL(LPCWSTR name, PLONG plRefCount);
    static BOOL WINAPI FrameworkLogoffDLL(LPCWSTR name, PLONG plRefCount);

    static bool WINAPI SetStatusObject(MethodContext *pContext, LPCWSTR pNamespace, 
                                        LPCWSTR pDescription, HRESULT hr, 
                                        const SAFEARRAY *pPrivilegesNotHeld = NULL,
                                        const SAFEARRAY *pPrivilegesRequired = NULL);

    ////////////////////////////////////////////////////////////////////////////////////
    // note: the following public functions are necessary to allow COM communication  //
    //       with CIMOM.  Provider Implementors will not need to call these.          //
    ////////////////////////////////////////////////////////////////////////////////////

#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR *ppvObj) ;
    STDMETHOD_(ULONG, AddRef)(THIS) ;
    STDMETHOD_(ULONG, Release)(THIS) ;
#endif
    
   virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
    );

    STDMETHOD(CreateInstanceEnumAsync)(THIS_
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(GetObjectAsync)( THIS_
            const BSTR ObjectPath, 
            long lFlags, 
            IWbemContext __RPC_FAR *pCtx, 
            IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(ExecQueryAsync)(THIS_
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(PutInstanceAsync)( THIS_
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(DeleteInstanceAsync)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );

    STDMETHOD(ExecMethodAsync)( const BSTR, 
                                const BSTR, 
                                long, 
                                IWbemContext*, 
                                IWbemClassObject*,
                                IWbemObjectSink*
    );


 // Unsupported service methods
 // ===========================

    STDMETHOD(OpenNamespace)(THIS_
            const BSTR Namespace, 
            long lFlags,  
            IWbemContext __RPC_FAR *pCtx,
            IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace, 
            IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
    )
        { return E_NOTIMPL; }
    

    STDMETHOD(PutClass)(IWbemClassObject __RPC_FAR *pObject, 
                        long lFlags, 
                        IWbemContext __RPC_FAR *pCtx, 
                        IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
         {return E_NOTIMPL;}

    STDMETHOD(DeleteClass)(  
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
         {return E_NOTIMPL;}

    STDMETHOD(CreateClassEnum)(
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
         {return E_NOTIMPL;}

    STDMETHOD(CreateClassEnumAsync)(
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
         {return E_NOTIMPL;}

    STDMETHOD(PutInstance)(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(DeleteInstance)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(CancelAsyncRequest)(THIS_ long lAsyncRequestHandle
    )
         {return E_NOTIMPL;}

    STDMETHOD(CancelAsyncCall)(IWbemObjectSink __RPC_FAR *pSink
    )
         {return E_NOTIMPL;}

    STDMETHOD(CreateInstanceEnum)(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
         {return E_NOTIMPL;}
  
    STDMETHOD(ExecQuery)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
         {return E_NOTIMPL;}

    STDMETHOD(QueryObjectSink)(long lFlags, 
                               IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
    )
         {return E_NOTIMPL;}


    STDMETHOD(GetObject)( const BSTR ObjectPath, 
                          long lFlags, 
                          IWbemContext __RPC_FAR *pCtx, 
                          IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject, 
                          IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )

         {return E_NOTIMPL;}

    STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
       {return E_NOTIMPL;}
        
        
    STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
       {return E_NOTIMPL;}
        
    STDMETHOD(ExecMethod)(const BSTR, 
                          const BSTR, 
                          long, 
                          IWbemContext*, 
                          IWbemClassObject*,
                          IWbemClassObject**, 
                          IWbemCallResult**
    )
       {return E_NOTIMPL;}

    CWbemProviderGlue();
    CWbemProviderGlue(PLONG pCount);
    ~CWbemProviderGlue(); // Destructor

    // used by the provider base class - you probably will never need to call this directly
    static IWbemServices *WINAPI GetNamespaceConnection( LPCWSTR NameSpace );
    static IWbemServices *WINAPI GetNamespaceConnection( LPCWSTR NameSpace, MethodContext *pMethodContext );

    // each provider class must log in and out with these in their constructors and destructors
    // this is done for you in the Provider base class
    static void WINAPI FrameworkLogin( LPCWSTR a_pszName, 
                                       Provider *a_pProvider, 
                                       LPCWSTR a_pszNameSpace );

    static void WINAPI FrameworkLogoff( LPCWSTR a_pszName, 
                                        LPCWSTR a_pszNameSpace );

    static void WINAPI IncrementObjectCount(void);

    static LONG WINAPI DecrementObjectCount(void);

    static DWORD WINAPI GetOSMajorVersion() { return s_dwMajorVersion; }

    static DWORD WINAPI GetPlatform() { return s_dwPlatform; }

    static LPCWSTR WINAPI GetCSDVersion() { return s_wstrCSDVersion; }

 private:

    IWbemServices *WINAPI InternalGetNamespaceConnection( LPCWSTR NameSpace );

    static HRESULT WINAPI GetInstanceFromCIMOM( LPCWSTR pszObjectPath,
                                        LPCWSTR pszNameSpace,
                                        MethodContext *pMethodContext,
                                        CInstance **ppInstance );   

    void FlushAll(void);

    static Provider *WINAPI SearchMapForProvider( LPCWSTR a_pszProviderName, 
                                                  LPCWSTR a_pszNamespace );

    static Provider *WINAPI AddProviderToMap( LPCWSTR a_pszProviderName, 
                                              LPCWSTR a_strNamespace, 
                                              Provider *a_pProvider );

    static void WINAPI LockProviderMap( void );

    static void WINAPI UnlockProviderMap( void );

    static void WINAPI LockFactoryMap( void );

    static void WINAPI UnlockFactoryMap( void );

    static IWbemClassObject *WINAPI GetStatusObject( MethodContext *pContext, 
                                                     LPCWSTR pNamespace);
    static void WINAPI Init( void );

    static void WINAPI UnInit( void );

    static void WINAPI GetComputerName( CHString& strComputerName );
    
    static HRESULT WINAPI CheckImpersonationLevel();

    HRESULT PreProcessPutInstanceParms(IWbemClassObject __RPC_FAR *pInstIn, 
                                       IWbemClassObject __RPC_FAR **pInstOut, 
                                       IWbemContext __RPC_FAR *pCtx);    

    HRESULT NullOutUnsetProperties(IWbemClassObject __RPC_FAR *pInstIn, 
                                   IWbemClassObject __RPC_FAR **pInstOut, 
                                   const VARIANT& vValue);

    void AddFlushPtr(LPVOID pVoid);

    long    m_lRefCount; 
    CHString    m_strNamespace;
    IWbemServices *m_pServices;
    static long s_lObjects; // number of objects out there - class factories & WbemGlues
    PLONG m_pCount;
    PROVIDERPTRS m_FlushPtrs;
    CCritSec         m_csFlushPtrs;

    static STRING2LPVOID    s_providersmap;
    static CCritSec s_csProviderMap;
    static CCritSec m_csStatusObject;
    static BOOL s_bInitted;
    static DWORD s_dwPlatform;
    static DWORD s_dwMajorVersion;
    static WCHAR s_wstrCSDVersion[128];
    static IWbemClassObject *m_pStatusObject;
    static PTR2PLONG        s_factorymap;
    static CCritSec         s_csFactoryMap;

protected:
    friend CWbemGlueFactory;

    static LONG IncrementMapCount(const CWbemGlueFactory *pGlue);
    static LONG IncrementMapCount(PLONG pCount);
    static LONG DecrementMapCount(const CWbemGlueFactory *pGlue);
    static LONG DecrementMapCount(PLONG pCount);
    static PLONG GetMapCountPtr(const CWbemGlueFactory *pGlue);
    static VOID AddToFactoryMap(const CWbemGlueFactory *pGlue, PLONG pdwRefCount);
    static VOID RemoveFromFactoryMap(const CWbemGlueFactory *pGlue);
};

inline void CWbemProviderGlue::LockProviderMap( void )
{
    EnterCriticalSection( &s_csProviderMap );
}

inline void CWbemProviderGlue::UnlockProviderMap( void )
{
    LeaveCriticalSection( &s_csProviderMap );
}

inline void CWbemProviderGlue::LockFactoryMap( void )
{
    EnterCriticalSection( &s_csFactoryMap );
}

inline void CWbemProviderGlue::UnlockFactoryMap( void )
{
    LeaveCriticalSection( &s_csFactoryMap );
}

class POLARITY CWbemGlueFactory : public IClassFactory
{
 protected:
    long m_lRefCount;

 public:
     // Deprecated in favor of the constructor that takes a PLONG.  This
     // must be the same PLONG that is passed to FrameworkLoginDLL &
     // FrameworkLogoffDLL.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        CWbemGlueFactory(void);
#endif
        CWbemGlueFactory(PLONG plRefCount);
        ~CWbemGlueFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CWbemGlueFactory *PCWbemGlueFactory;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\brodcast.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  BrodCast.h
//
//  Purpose: Logging functions
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef BRODCAST_IS_INCLUDED
#define BRODCAST_IS_INCLUDED

#include <time.h>
#include <CRegCls.h>

//#define MAX_STRING_SIZE 4096

class POLARITY ProviderLog;
extern POLARITY ProviderLog captainsLog;

// Needed to add L to the __FILE__
#define __T2(x)      L ## x
#define _T2(x)       __T2(x)

// macros to make calling easier
// first two versions of LogMessage spots in the file & line number for you
#define LogMessage(pszMessageString)        captainsLog.LocalLogMessage(pszMessageString, _T2(__FILE__), __LINE__, ProviderLog::Verbose)
#define LogMessage2(pszMessageString, p1)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1)
#define LogMessage3(pszMessageString, p1, p2)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2)
#define LogMessage4(pszMessageString, p1, p2, p3)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3)
#define LogMessage5(pszMessageString, p1, p2, p3, p4)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4)
#define LogMessage6(pszMessageString, p1, p2, p3, p4, p5)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4, p5)
#define LogMessage7(pszMessageString, p1, p2, p3, p4, p5, p6)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4, p5, p6)
#define LogMessage8(pszMessageString, p1, p2, p3, p4, p5, p6, p7)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4, p5, p6, p7)

#define LogErrorMessage(pszMessageString)   captainsLog.LocalLogMessage(pszMessageString, _T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly)
#define LogErrorMessage2(pszMessageString, p1)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1)
#define LogErrorMessage3(pszMessageString, p1, p2)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2)
#define LogErrorMessage4(pszMessageString, p1, p2, p3)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3)
#define LogErrorMessage5(pszMessageString, p1, p2, p3, p4)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4)
#define LogErrorMessage6(pszMessageString, p1, p2, p3, p4, p5)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4, p5)
#define LogErrorMessage7(pszMessageString, p1, p2, p3, p4, p5, p6)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4, p5, p6)
#define LogErrorMessage8(pszMessageString, p1, p2, p3, p4, p5, p6, p7)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4, p5, p6, p7)

#define LogMessageEx(pszMessageString, pszFileName, nLineNo)        captainsLog.LocalLogMessage(pszMessageString, pszFileName, nLineNo, ProviderLog::Verbose) 
#define LogErrorMessageEx(pszMessageString, pszFileName, nLineNo)   captainsLog.LocalLogMessage(pszMessageString, pszFileName, nLineNo, ProviderLog::ErrorsOnly) 

#define IsVerboseLoggingEnabled()                                   ((BOOL)(ProviderLog::Verbose == captainsLog.IsLoggingOn(NULL)))     
#define IsErrorLoggingEnabled()                                     ((BOOL)captainsLog.IsLoggingOn(NULL))


// provide basic logging functionality
// serialize access to the log file, etc.
// intent is that usage is through the macros above
// don't bother instanciating one of these puppies.

class POLARITY ProviderLog : protected CThreadBase
{
public:
    enum LogLevel{None, ErrorsOnly, Verbose };

    ProviderLog();
    ~ProviderLog();

    // Broadcast functions
    void LocalLogMessage(LPCWSTR pszMessageString, LPCWSTR pszFileName, int lineNo, LogLevel level);
    void LocalLogMessage(LPCWSTR pszFileName, int lineNo, LogLevel level, LPCWSTR pszFormatString,...);
    // void POLARITY LocalLogMessage(OLECHAR *pwszFormatString,...);

    LogLevel IsLoggingOn(CHString* pPath = NULL);

private:
    void CheckFileSize(LARGE_INTEGER& nowSize, const CHString &path);

    // note - do not use these directly, use the IsLoggingOn method
    unsigned __int64 m_lastLookedAtRegistry; // what time we last looked in the registry to see if logging is enabled
    LogLevel m_logLevel;             // 0 == no logging; 1 == logging; 2 == verbose logging
    LARGE_INTEGER    m_maxSize;      // Maximum size of log file before rollover
    CHString m_path;                 // complete path of log file

    static bool m_beenInitted;       // catch someone instanciating one of these...
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\npath.h ===
/*++



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    NPATH.H

Abstract:

    object path parser

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#define DELETE_ME

class KeyRef
{
public:
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
   ~KeyRef();

    static void *operator new(size_t n);
    static void operator delete(void *ptr);

    static void *operator new[](size_t n);
    static void operator delete[](void *ptr);
};

class ParsedObjectPath
{
public:
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL SetServerName(LPCWSTR wszServerName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
//    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();

    static void *operator new(size_t n);
    static void operator delete(void *ptr);

    static void *operator new[](size_t n);
    static void operator delete[](void *ptr);
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class CObjectPathParser
{
private:

    ObjectParserFlags m_eFlags;

public:
    enum { NoError, SyntaxError, InvalidParameter, OutOfMemory };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
    void Free( LPWSTR wszUnparsedPath );

    static void *operator new(size_t n);
    static void operator delete(void *ptr);

    static void *operator new[](size_t n);
    static void operator delete[](void *ptr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\smartptr.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  SmartPtr.h
//
//  Purpose: Declare smartpointer typedefs
//
//***************************************************************************

#pragma once
#include <io.h>

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemQuery, __uuidof(IWbemQuery));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment, __uuidof(IUnsecuredApartment));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));
//_COM_SMARTPTR_TYPEDEF(IWbemBackupRestore, __uuidof(IWbemBackupRestore));
_COM_SMARTPTR_TYPEDEF(IWbemRefresher, __uuidof(IWbemRefresher));
_COM_SMARTPTR_TYPEDEF(IWbemHiPerfEnum, __uuidof(IWbemHiPerfEnum));
_COM_SMARTPTR_TYPEDEF(IWbemConfigureRefresher, __uuidof(IWbemConfigureRefresher));
_COM_SMARTPTR_TYPEDEF(IMofCompiler, __uuidof(IMofCompiler));
_COM_SMARTPTR_TYPEDEF(ExternalMethodContext, __uuidof(ExternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContext, __uuidof(InternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContextAsynch, __uuidof(InternalMethodContextAsynch));
_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class SmartCloseHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHandle(HANDLE h):m_h(h){}
   ~SmartCloseHandle(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class Smart_findclose
{

private:
	intptr_t m_h;

public:
	Smart_findclose():m_h(0){}
	Smart_findclose(intptr_t h):m_h(h){}
   ~Smart_findclose(){if (m_h!=0) _findclose(m_h);}
	intptr_t operator =(intptr_t h) {if (m_h) _findclose(m_h); m_h=h; return h;}
	operator intptr_t() const {return m_h;}
	intptr_t* operator &() {if (m_h) _findclose(m_h); m_h = 0; return &m_h;}
};

class SmartFindClose
{

private:
	HANDLE m_h;

public:
	SmartFindClose():m_h(INVALID_HANDLE_VALUE){}
	SmartFindClose(HANDLE h):m_h(h){}
   ~SmartFindClose(){if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class SmartCloseServiceHandle
{

private:
	SC_HANDLE m_h;

public:
	SmartCloseServiceHandle():m_h(NULL){}
	SmartCloseServiceHandle(SC_HANDLE h):m_h(h){}
   ~SmartCloseServiceHandle(){if (m_h!=NULL) CloseServiceHandle(m_h);}
	SC_HANDLE operator =(SC_HANDLE h) {if (m_h!=NULL) CloseServiceHandle(m_h); m_h=h; return h;}
	operator SC_HANDLE() const {return m_h;}
	SC_HANDLE* operator &() {if (m_h!=NULL) CloseServiceHandle(m_h); m_h = NULL; return &m_h;}
};

class CSmartCreatedDC
{
public:
    CSmartCreatedDC(HDC hdc) { m_hdc = hdc;}
	operator HDC() const {return m_hdc;}
    ~CSmartCreatedDC() 
    { 
        if (m_hdc)
            DeleteDC(m_hdc); 
    }

protected:
    HDC m_hdc;
};

class CSmartBuffer
{
private:
	LPBYTE m_pBuffer;

public:
	CSmartBuffer() : m_pBuffer(NULL) {}
	CSmartBuffer(LPBYTE pBuffer) : m_pBuffer(pBuffer) {}
    CSmartBuffer(DWORD dwSize)
    {
        m_pBuffer = new BYTE[dwSize];
        if (m_pBuffer == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    ~CSmartBuffer()
    {
        Free();
    }

	LPBYTE operator =(LPBYTE pBuffer) 
    {
        Free();
            
        m_pBuffer = pBuffer; 
        
        return m_pBuffer;
    }
	
    operator LPBYTE() const { return m_pBuffer; }
	
    LPBYTE* operator &()
    {
        Free();

        m_pBuffer = NULL;
        
        return &m_pBuffer;
    }

protected:
    void Free()
    {
        if (m_pBuffer != NULL) 
        {
            delete [] m_pBuffer;
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\impself.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  ImpSelf.h
//
//  Purpose: Impersonate self wrapper
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _IMPSELF_H
#define _IMPSELF_H

// Instantiate an instance of this class to impersonate the
// Winmgmt.exe process.  When the class goes out of scope
// the thread will go back to where it was before this
// class was instantiated.
class CImpersonateSelf
{
public:
    CImpersonateSelf()
    {
        // After this function m_hToken will either have a valid token
        // or it will have INVALID_HANDLE_VALUE.
        if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE, 
            &m_hToken))
            m_hToken = INVALID_HANDLE_VALUE;
        else
            RevertToSelf();
    }
    
    ~CImpersonateSelf()
    {
        if (m_hToken != INVALID_HANDLE_VALUE)
        {
            ImpersonateLoggedOnUser(m_hToken);
            CloseHandle(m_hToken);
        }
    }

protected:
    HANDLE m_hToken;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\stopwatch.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  StopWatch.h
//
//  Purpose: Timing functions
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _STOPWATCH_COMPILED_ALREADY_
#define _STOPWATCH_COMPILED_ALREADY_

#include <wchar.h>
#include <stdio.h>

#ifdef PROVIDER_INSTRUMENTATION

    #define PROVIDER_INSTRUMENTATION_START(pmc, timer) \
        if ( pmc && pmc->pStopWatch) \
            pmc->pStopWatch->Start(timer);

    #define PROVIDER_INSTRUMENTATION_START2(pStopWatch, timer) \
        if (pStopWatch) \
            pStopWatch->Start(timer);


class POLARITY StopWatch
{
public:
    // those types of timers we have.
    // note that any new timers must be added before NTimers
    enum Timers {NullTimer = -1, FrameworkTimer =0, ProviderTimer, AtomicTimer, WinMgmtTimer, NTimers};

    StopWatch(const CHString& reason);

    // start a particular timer, stopping the previous one
    void Start(Timers timer);
    // call this only at the very end
    void Stop();
    
    __int64 GetTime(Timers timer);

    void LogResults();

private:
    // something to spit to the log to identify this run
    CHString m_reason;

    // track the times we're timing
    // elapsed times in array
    __int64  m_times[NTimers];
    // the one we're currently tracking
    Timers m_currentTimer;
    // the start time for the one we're currently tracking
    LARGE_INTEGER  m_startTime;
};

inline StopWatch::StopWatch(const CHString& reason)
{
    m_reason = reason;
    m_currentTimer = NullTimer;
    ZeroMemory(m_times, sizeof(m_times));
}

inline void StopWatch::Start(Timers timer)
{
    LARGE_INTEGER count;
    QueryPerformanceCounter(&count);

    if (m_currentTimer != NullTimer)
        m_times[m_currentTimer] += count.QuadPart - m_startTime.QuadPart;

    m_currentTimer = timer;
    m_startTime = count;
}
inline void StopWatch::Stop()
{
    Start(NullTimer);
}
inline __int64 StopWatch::GetTime(Timers timer)
{
    return m_times[timer];
}

inline void StopWatch::LogResults()
{
	FILE *fpLogFile;

	fpLogFile = _wfopen( L"C:\\StopWatch.log", L"a+" );

	if(fpLogFile) 
	{
		WCHAR datebuffer [9];
		WCHAR timebuffer [9];
		_wstrdate( datebuffer );
		_wstrtime( timebuffer );

        LARGE_INTEGER omega;
        QueryPerformanceFrequency(&omega);

//		_ftprintf(fpLogFile, L"%s\n\t%-8s %-8s\n", m_reason, datebuffer, timebuffer);
		fwprintf(fpLogFile, L"%s\n ", m_reason);
        fwprintf(fpLogFile, L"Framework\tProvider\tWinmgmt \tAtomic\n %I64u\t%I64u\t%I64u\t%I64u\n",
            GetTime(FrameworkTimer), GetTime(ProviderTimer), GetTime(WinMgmtTimer), omega);

        fclose(fpLogFile);
	}
}

#else

    #define PROVIDER_INSTRUMENTATION_START(pmc, timer)
    #define PROVIDER_INSTRUMENTATION_START2(pStopWatch, timer)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\private\winmsgevent.h ===
//=================================================================

//

// WinMsgEvent.h -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _WBEM_MESSAGE_EVENT_FORWARDER_H
#define _WBEM_MESSAGE_EVENT_FORWARDER_H

using namespace std;
#define MSGWINDOWNAME TEXT("WinMsgEventProvider") 

//
class POLARITY CAutoEvent 
{
	HANDLE	m_hEvent ;
public:	
	CAutoEvent()	{ m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ); };
    ~CAutoEvent()	{ CloseHandle( m_hEvent ); };

	DWORD Wait( DWORD a_dwMillSec ) { return WaitForSingleObject( m_hEvent, a_dwMillSec ); };
    BOOL Signal()					{ return SetEvent( m_hEvent ); }; 
};

//
class POLARITY CWinMsgEvent 
{
private:

	static	CCritSec			mg_csMapLock ;
	static	CCritSec			mg_csWindowLock ;
	static	CAutoEvent			mg_aeCreateWindow ; 
	typedef std::multimap<UINT, CWinMsgEvent*> Sink_Map ;
	static	Sink_Map			mg_oSinkMap ;
	
	static  HANDLE				mg_hThreadPumpHandle ;
	static	HWND				mg_hWnd ;		 

	static void HandleEvent( DWORD a_dwPowerEvent, DWORD a_dwData ) ;
		
	static void CreateMsgProvider() ;
	static HWND CreateMsgWindow() ;
	static void DestroyMsgWindow() ;
	static void WindowsDispatch() ;
	
	static LRESULT CALLBACK MsgWndProc(

				IN HWND a_hWnd,
				IN UINT a_message,
				IN WPARAM a_wParam,
				IN LPARAM a_lParam ) ;
		
	static DWORD WINAPI dwThreadProc( LPVOID lpParameter );
	static BOOL WINAPI CtrlHandlerRoutine( DWORD dwCtrlType ) ;

protected:

	void RegisterForMessage(
		
		IN UINT a_message
		) ;

	bool UnRegisterMessage(
		
		IN UINT a_message
		) ;

	void UnRegisterAllMessages() ;


public:

    CWinMsgEvent () ;
    ~CWinMsgEvent () ;

	enum E_ReturnAction {
		e_DefProc,			// call DefWindowProc
		e_ReturnResult		// return msg with WinMsgEvent() LRESULT  
	};

	virtual void WinMsgEvent(
		
		IN	HWND a_hWnd,
        IN	UINT a_message,
        IN	WPARAM a_wParam,
        IN	LPARAM	a_lParam,
		OUT E_ReturnAction &eRetAction,
		OUT LRESULT &a_lResult
		) = 0 ;
};


#endif // _WBEM_MESSAGE_EVENT_FORWARDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WMIparse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMIPARSE.RC
//
#define IDS_WMI_DESC                    12700
#define IDS_WMI_NO_ERROR                12701
#define IDS_WMI_OOM                     12702
#define IDS_WMI_CANT_LOAD_SOURCE        12703
#define IDS_WMI_CANT_OPEN_TARGET        12704
#define IDS_WMI_NO_OPEN_FILE            12705
#define IDS_WMI_NOT_MOF_FILE            12706
#define IDS_WMI_CANT_WRITE_FILE         12707
#define IDS_WMI_SYNTAX                  12708
#define IDS_WMI_HANDLER_ERROR           12709
#define IDS_WMI_UNKNOWN_ERROR           12710
#define IDS_WMI_PARSER_DESC             12711
#define IDS_WMI_BAD_FILE                12712
#define IDS_WMI_NO_MEMORY               12713
#define IDS_WMI_UNICODE_ERROR           12714
#define IDS_WMI_EXCEPTION               12715
#define IDS_WMI_GENERIC_LOCATION        12716
#define IDS_WMI_FULL_CONTEXT            12717
#define IDS_WMI_LINE_ERROR              12718
#define IDS_WMI_VAL_HOTKEY              12750
#define IDS_WMI_VAL_BAD_CHARS           12751
#define IDS_OPT_DESC                    12752
#define IDS_OPT_HELP                    12753
#define IDS_DISABLE_WATERMARKING_BOOL   12754
#define IDS_DISABLE_WATERMARKING_BOOL_HELP 12755

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define PSH_WIZARD97 PSH_WIZARD
#define RBBS_GRIPPERALWAYS 0

#include <afxres.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>			// MFX Ole stuff
#include <afxtempl.h>	    // MFC template collection classes.

#include <parser.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmiclass.h ===
//-----------------------------------------------------------------------------

//  

//  File: WMIClass.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


#ifndef WMICLASS_H
#define WMICLASS_H

class CWMILocClassFactory : public IClassFactory, public CLObject
{
public:
	CWMILocClassFactory();

#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif
	
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	STDMETHOD(CreateInstance)(THIS_ LPUNKNOWN, REFIID, LPVOID *);
	STDMETHOD(LockServer)(THIS_ BOOL);

	~CWMILocClassFactory();
	
private:
	UINT m_uiRefCount;
	
};


#endif // WMICLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmiclass.cpp ===
//-----------------------------------------------------------------------------

//  

//  File: WMIClass.CPP

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  Implementation file for the WMI MOF parser IClassFactory object.
//  
//-----------------------------------------------------------------------------

#include "stdafx.h"


#include "WMIparse.h"
#include "resource.h"
#include "WMIlprs.h"

#include "WMIclass.h"


CWMILocClassFactory::CWMILocClassFactory()
{
	m_uiRefCount = 0;

	AddRef();
	IncrementClassCount();
}


#ifdef _DEBUG

void
CWMILocClassFactory::AssertValid(void)
		const
{
	CLObject::AssertValid();
}



void
CWMILocClassFactory::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
}

#endif // _DEBUG


ULONG
CWMILocClassFactory::AddRef(void)
{
	return ++m_uiRefCount;
}



ULONG
CWMILocClassFactory::Release(void)
{
	LTASSERT(m_uiRefCount != 0);
	
	m_uiRefCount--;
	
	if (m_uiRefCount == 0)
	{
		delete this;
		return 0;
	}

	return m_uiRefCount;
}



HRESULT
CWMILocClassFactory::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_NOINTERFACE;

	*ppvObj = NULL;
	
	if (iid == IID_IUnknown)
	{
		*ppvObj = (IUnknown *)this;
		sc = S_OK;
	}
	else if (iid == IID_IClassFactory)
	{
		*ppvObj = (IClassFactory *)this;
		sc = S_OK;
	}
	
	if (sc == S_OK)
	{
		AddRef();
	}
	return ResultFromScode(sc);
}



HRESULT
CWMILocClassFactory::CreateInstance(
		LPUNKNOWN pUnknown,
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_UNEXPECTED;

	*ppvObj = NULL;
	
	if (pUnknown != NULL)
	{
		sc = CLASS_E_NOAGGREGATION;
	}
	else
	{
		try
		{
			CWMILocParser *pParser;

			pParser = new CWMILocParser;

			sc = pParser->QueryInterface(iid, ppvObj);

			pParser->Release();
		}
		catch (CMemoryException *pMemoryException)
		{
			sc = E_OUTOFMEMORY;
			pMemoryException->Delete();
		}
	}

	return ResultFromScode(sc);
}



HRESULT
CWMILocClassFactory::LockServer(
		BOOL)
{
	return E_NOTIMPL;
}



CWMILocClassFactory::~CWMILocClassFactory()
{
	LTASSERT(m_uiRefCount == 0);
	DEBUGONLY(AssertValid());

	DecrementClassCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmilfile.cpp ===
//=============================================================================

//  

// File: WMIlFile.cpp

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//  
//=============================================================================
 
#include "stdafx.h"
#include <buildnum.h>
#include <helpids.h>

#include "WMIparse.h"
#include "resource.h"
#include "WMIlprs.h"


#include "WMIlfile.h"

//*****************************************************************************
//
//  CWMILocFile::CWMILocFile
//
//*****************************************************************************

CWMILocFile::CWMILocFile(
		ILocParser *pParentClass)
{
	//
	// C.O.M. initialization
	//
	m_pParentClass = pParentClass;
    m_sCurrentNamespace = "";
	m_ulRefCount = 0;

	//
	//  WMI file initialization
	//
	m_uiLineNumber = 0;
	m_pOpenSourceFile = NULL;
	m_pOpenTargetFile = NULL;

	AddRef();
	IncrementClassCount();
}

//*****************************************************************************
//
//  CWMILocFile::GetFileDescriptions
//
//*****************************************************************************

void CWMILocFile::GetFileDescriptions(
		CEnumCallback &cb)
{
	EnumInfo eiFileInfo;
	CLString strDesc;
	
	eiFileInfo.szAbbreviation = NULL;

	LTVERIFY(strDesc.LoadString(g_hDll, IDS_WMI_DESC));

	eiFileInfo.szDescription = (const TCHAR *)strDesc;
	eiFileInfo.ulValue = ftWMIFileType;

	cb.ProcessEnum(eiFileInfo);
}

//*****************************************************************************
//
//  CWMILocFile::AddRef
//
//*****************************************************************************

ULONG CWMILocFile::AddRef(void)
{
	if (m_pParentClass != NULL)
	{
		m_pParentClass->AddRef();
	}
	
	return m_ulRefCount++;
}

//*****************************************************************************
//
//  CWMILocFile::Release
//
//*****************************************************************************

ULONG CWMILocFile::Release(void)
{
	LTASSERT(m_ulRefCount != 0);

	if (m_pParentClass != NULL)
	{
		
		m_pParentClass->Release();
	}

	m_ulRefCount--;
	if (m_ulRefCount == 0)
	{
		delete this;
		return 0;
	}
	
	return m_ulRefCount;
}

//*****************************************************************************
//
//  CWMILocFile::QueryInterface
//
//*****************************************************************************

HRESULT CWMILocFile::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	if (m_pParentClass != NULL)
	{
		return m_pParentClass->QueryInterface(iid, ppvObj);
	}
	else
	{
		SCODE scRetVal = E_NOINTERFACE;

		*ppvObj = NULL;
		
		if (iid == IID_IUnknown)
		{
			*ppvObj = (IUnknown *)this;
			scRetVal = S_OK;
		}
		else if (iid == IID_ILocFile)
		{
			*ppvObj = (ILocFile *)this;
			scRetVal = S_OK;
		}

		if (scRetVal == S_OK)
		{
			AddRef();
		}
		return ResultFromScode(scRetVal);
	}
}

//*****************************************************************************
//
//  CWMILocFile::AssertValidInterface
//
//*****************************************************************************

void CWMILocFile::AssertValidInterface(void)
		const
{
	AssertValid();
}

//*****************************************************************************
//
//  CWMILocFile::OpenFile
//
//*****************************************************************************

BOOL CWMILocFile::OpenFile(
		const CFileSpec &fsFile,
		CReporter &Reporter)
{
	LTTRACEPOINT("OpenFile()");
	
	BOOL fRetCode;
	
	LTASSERT(m_pOpenTargetFile == NULL);
	fRetCode = FALSE;

	m_didFileId = fsFile.GetFileId();
	m_pstrFileName = fsFile.GetFileName();
	
	if (m_pOpenSourceFile != NULL)
	{
        fclose(m_pOpenSourceFile);
		m_pOpenSourceFile = NULL;
	}

    // We are just going to open the file.
    // and save the handle.
    // ===================================
	
	try
	{

		m_pOpenSourceFile = fopen(_T(m_pstrFileName), "rb");

		if (!m_pOpenSourceFile)
		{			
			fclose(m_pOpenSourceFile);
			m_pOpenSourceFile = NULL;
		}
        else
        {           
            fRetCode = TRUE;
        }

    }
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;

		strContext.LoadString(g_hDll, IDS_WMI_GENERIC_LOCATION);
		
		Reporter.IssueMessage(esError, strContext, g_hDll, IDS_WMI_NO_MEMORY,
				g_locNull);

		pMemoryException->Delete();
	}
	return fRetCode;
}

//*****************************************************************************
//
//  CWMILocFile::GetFileType
//
//*****************************************************************************

FileType CWMILocFile::GetFileType(void)
		const
{
	//
	//  Just return some number that isn't ftUnknown...
	//
	return ftWMIFileType;
}

//*****************************************************************************
//
//  CWMILocFile::GetFileTypeDescription
//
//*****************************************************************************

void CWMILocFile::GetFileTypeDescription(
		CLString &strDesc)
		const
{
	LTVERIFY(strDesc.LoadString(g_hDll, IDS_WMI_DESC));
	
	return;
}


//*****************************************************************************
//
//  CWMILocFile::GetAssociatedFiles
//
//*****************************************************************************

BOOL CWMILocFile::GetAssociatedFiles(
		CStringList &lstFiles)
		const
{
	LTASSERT(lstFiles.GetCount() == 0);
	
	lstFiles.RemoveAll();
	return FALSE;
}

//*****************************************************************************
//
//  CWMILocFile::EnumerateFile
//
//*****************************************************************************

BOOL CWMILocFile::EnumerateFile(
		CLocItemHandler &ihItemHandler,
		const CLocLangId &lid,
		const DBID &dbidFileId)
{
    BOOL bRet = TRUE;
    DBID dbidThisId = dbidFileId;

	LTTRACEPOINT("EnumerateFile()");
	
	if (m_pOpenSourceFile == NULL)
	{
		return FALSE;
	}

    // Enumerate file will need to:
    // * Parse the MOF.
    // * Walk through all qualifiers.  For each "Amended" qualifier, 
    //   send back a CLocItem whose key is namespace, class, property and qualifier name.
    // * Fail if the language ID does not match that of LocaleID.
    // * Parent objects are namespaces, classes
    // =============================================================

	m_cpSource = lid.GetCodePage(cpAnsi);
    m_wSourceId = lid.GetLanguageId();

    ihItemHandler.SetProgressIndicator(0);	

    bRet = ReadLines(ihItemHandler, dbidFileId, FALSE);

	return bRet;
}

//*****************************************************************************
//
//  CWMILocFile::GenerateFile
//
//*****************************************************************************

BOOL CWMILocFile::GenerateFile(
		const CPascalString &pstrTargetFile,
		CLocItemHandler &ihItemHandler,
		const CLocLangId &lidSource,
		const CLocLangId &lidTarget,
		const DBID &dbidParent)
{
	LTASSERT(m_pOpenTargetFile == NULL);
	BOOL fRetVal = TRUE;

	if (m_pOpenSourceFile== NULL)
	{
		return FALSE;
	}
    // Generate File needs to:
    // * Parse the MOF.
    // * Walk through all qualifiers.  For each "Amended" qualifier,
    //   send back a CLocItem whose key is namespace, class, property and qualifier name.
    // * Replace all Amended qualifiers with localized text
    // * Replace all occurrences of the locale ID in namespaces and qualifiers
    //   with the new one.
    // =================================================================================
    
	m_cpSource = lidSource.GetCodePage(cpAnsi);
	m_cpTarget = lidTarget.GetCodePage(cpAnsi);

    m_wSourceId = lidSource.GetLanguageId();
    m_wTargetId = lidTarget.GetLanguageId();
    	
	try
	{
		CFileException excFile;
		fRetVal = FALSE;
		
		if (m_pOpenTargetFile != NULL)
		{
			fclose(m_pOpenTargetFile);
			m_pOpenTargetFile = NULL;
		}

        char FileName[255];
        strcpy(FileName, _bstr_t(_T(pstrTargetFile)));

        // This file must be in Unicode.
        HANDLE hFile = CreateFile(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL,
            CREATE_ALWAYS, 0, NULL);
	    if(hFile != INVALID_HANDLE_VALUE)
	    {
		    char cUnicodeHeader[2] = {0xff, 0xfe};
		    DWORD dwWrite;
            WriteFile(hFile, cUnicodeHeader, 2, &dwWrite, NULL);
            CloseHandle(hFile);
	    }      
	
		m_pOpenTargetFile = fopen(FileName, "ab");

		if (!m_pOpenTargetFile)
		{			
			fclose(m_pOpenTargetFile);
			m_pOpenTargetFile = NULL;
		}
        else
        {
            fRetVal = TRUE;
        }
	}
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;
		GetFullContext(strContext);
		
		ihItemHandler.IssueMessage(esError, strContext, g_hDll, IDS_WMI_NO_MEMORY,
				g_locNull);

		pMemoryException->Delete();
	}
	catch (CFileException *pFileException)
	{		
		fclose(m_pOpenTargetFile);
		fRetVal = FALSE;

		ReportFileError((const WCHAR *)pstrTargetFile, m_didFileId, pFileException, ihItemHandler);

		pFileException->Delete();
	}

	if (!fRetVal)
	{
		return fRetVal;
	}
	
	if (!GetParserOptionBool(g_puid, OPT_DISABLE_WATERMARKING))
	{
		WriteWaterMark();
	}
		
	fRetVal = ReadLines(ihItemHandler, dbidParent, TRUE);
	
	fclose(m_pOpenTargetFile);

	if (!fRetVal)
	{
		CLFile::Remove(pstrTargetFile);
	}

	return fRetVal;
}

//*****************************************************************************
//
//  CWMILocFile::GenerateItem
//
//*****************************************************************************

BOOL CWMILocFile::GenerateItem(
		CLocItemHandler &ihItemHandler,
		CLocItemSet &isItemSet,
        wchar_t **pOutBuffer,
        UINT &uiStartingPos)
{

	BOOL fRetVal = TRUE;
    UINT uiLength;

    wchar_t *pTemp = *pOutBuffer;

    _bstr_t sQualifierValue;

    // If nothing has changed, we can just
    // ignore this line.

    fRetVal = GetQualifierValue(pTemp, uiStartingPos, sQualifierValue, uiLength);
    if (fRetVal)
    {
        fRetVal = ihItemHandler.HandleItemSet(isItemSet);
		if (fRetVal)
		{
            sQualifierValue = "";
            for (int i = 0; i < isItemSet.GetSize(); i++)
            {			
				CVC::ValidationCode vcRetVal;
				CLocItem *pLocItem = isItemSet[i];
				CLString strContext;
 				CLocation loc;
				
				GetFullContext(strContext);
				loc.SetGlobalId(
						CGlobalId(pLocItem->GetMyDatabaseId(), otResource));
				loc.SetView(vTransTab);
				
				CPascalString pstrId, pstrText;
			
				pLocItem->GetUniqueId().GetResId().GetId(pstrId);
				pstrText = pLocItem->GetLocString().GetString();
                
                if (i > 0)
                    sQualifierValue += L"\",\"";

                sQualifierValue += (const wchar_t *)pstrText;
            }

            // Set it live in the buffer.  We are not going to 
            // write it to the file until the very end.

            fRetVal = SetQualifierValue(pTemp, pOutBuffer, uiStartingPos, sQualifierValue, uiLength);				
            pTemp = *pOutBuffer;

        }

    }		
    
	return fRetVal;
}
	


//*****************************************************************************
//
//  CWMILocFile::EnumerateItem
//
//*****************************************************************************

BOOL CWMILocFile::EnumerateItem(
		CLocItemHandler &ihItemHandler,
		CLocItemSet &isItemSet)
{
	BOOL fRetVal;
	
	if (isItemSet.GetSize() != 0)
	{
		fRetVal = ihItemHandler.HandleItemSet(isItemSet);
	}
	else
	{
		fRetVal = TRUE;
	}

	return fRetVal;
}



#ifdef _DEBUG

//*****************************************************************************
//
//  CWMILocFile::AssertValid
//
//*****************************************************************************

void CWMILocFile::AssertValid(void)
		const
{
	CLObject::AssertValid();
}

//*****************************************************************************
//
//  CWMILocFile::Dump
//
//*****************************************************************************

void CWMILocFile::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
}

#endif

//*****************************************************************************
//
//  CWMILocFile::~CWMILocFile
//
//*****************************************************************************

CWMILocFile::~CWMILocFile()
{
	DEBUGONLY(AssertValid());

	if (m_pOpenSourceFile != NULL)
	{
        fclose(m_pOpenSourceFile);
		m_pOpenSourceFile = NULL;
	}

	DecrementClassCount();
}

//*****************************************************************************
//
//  CWMILocFile::SetFlags
//
//*****************************************************************************

void CWMILocFile::SetFlags(
		CLocItem *pItem,
		CLocString &lsString)
		const
{
	ULONG ulItemType;

	pItem->SetFDevLock(FALSE);
	pItem->SetFUsrLock(FALSE);
	pItem->SetFExpandable(FALSE);
	
	LTVERIFY(pItem->GetUniqueId().GetTypeId().GetId(ulItemType));
	
	switch (ulItemType)
	{
	case wltNamespaceName:
		pItem->SetFDisplayable(TRUE);
		pItem->SetFNoResTable(TRUE);
		break;

	case wltClassName:
	case wltPropertyName:
		pItem->SetFDisplayable(FALSE);
		pItem->SetFNoResTable(FALSE);
		lsString.SetCodePageType(cpAnsi);
		lsString.SetStringType(CST::Text);
		break;

	default:
		LTASSERT(FALSE && "Unexpected item type!");
	}
}

//*****************************************************************************
//
//  CWMILocFile::ReadLines
//
//*****************************************************************************

BOOL CWMILocFile::ReadLines(
		CLocItemHandler &ihItemHandler,
		const DBID &dbidFileId,
		BOOL fGenerating)
{
	DBID dbidSectionId;
	BOOL fRetVal = TRUE;
	wchar_t *pstrNamespaceName;
    _bstr_t pstrClassName;
    UINT uiStartPos = 0;

	UINT uiCommentNum;
	UINT uiReadingOrder;

	dbidSectionId = dbidFileId;
	m_uiLineNumber = 0;
    BOOL bPendingObj = FALSE;

	
	try
	{
		UINT uiOldPercentage = 0, uiNewPercentage = 0;
        UINT uiBytesRead, uiCurrPos = 1;

        ihItemHandler.SetProgressIndicator(uiOldPercentage);
   
        fseek(m_pOpenSourceFile, 0, SEEK_END);
        long lSize = ftell(m_pOpenSourceFile) + 6;
        fseek(m_pOpenSourceFile, 0, SEEK_SET);

        // Check for UNICODE source file.
        // ==============================

        BYTE UnicodeSignature[2];
        BOOL bUnicode = FALSE;        

        if (fread(UnicodeSignature, sizeof(BYTE), 2, m_pOpenSourceFile) != 2)
        {
            fRetVal = FALSE;
            return fRetVal;
        }
        if ((UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE) ||
            (UnicodeSignature[0] == 0xFE && UnicodeSignature[1] == 0xFF))
        {
            bUnicode = TRUE;
            lSize *= 2;
        }
        if (!bUnicode)
            fseek(m_pOpenSourceFile, 0, SEEK_SET);

        wchar_t *pBuff = (wchar_t *)new wchar_t[lSize+1];        
        if (!pBuff)
        {
            fRetVal = FALSE;
            return fRetVal;
        }
        memset(pBuff,0,lSize*sizeof(wchar_t));

        // If this is not a Unicode file,
        // we need to perform a conversion.
        // =====================================

        if (bUnicode)
            uiBytesRead = fread(pBuff, sizeof(wchar_t), lSize, m_pOpenSourceFile);           
        else
        {
            char *pCharBuff = new char[lSize+1];
            if (pCharBuff)
            {
                uiBytesRead = fread(pCharBuff, sizeof(char), lSize, m_pOpenSourceFile);
                pCharBuff[lSize] = '\0';
                swprintf(pBuff, L"%S", pCharBuff);
                delete pCharBuff;
            }
        }
        pBuff[lSize] = '\0';

        if (uiBytesRead != 0)
        {
            wchar_t *pOutBuffer = NULL;
            uiCurrPos += uiBytesRead;
		    fRetVal = TRUE;
		    
		    pstrNamespaceName = NULL;
            m_sCurrentNamespace = L"";
            pstrClassName = L"";

		    uiCommentNum = 0;
		    uiReadingOrder = 1;
	
			WMIFileError wmiRet;
			CLocItemSet isItemSet;
            UINT uiTemp = 0;
            DWORD dwCount = 0;
			
            // If we are generating a file, make a copy
            // of the outbound buffer.

            if (fGenerating)
                pOutBuffer = pBuff;

            while (GetNextQualifierPos(L"amended", pBuff, uiTemp, uiTemp) && !bPendingObj)
            {			    
                // If we have found the "amended" keyword,
                // we want to find the namespace,
                // class, and property if applicable, and
                // generate the object as appropriate.
                // ======================================

                pstrNamespaceName = GetCurrentNamespace(pBuff, uiTemp);
                if (!pstrNamespaceName || !wcslen(pstrNamespaceName))
                {
                    delete pBuff;
                    return FALSE;
                }
                if (wcscmp(pstrNamespaceName, m_sCurrentNamespace))
                {
                    // We need to generate this object,
                    // and set it up as the current parent.
                    // ====================================

                    CLocItem *pNewItem = new CLocItem;
                    CPascalString sId;

                    if (pNewItem)
                    {

               			CLocUniqueId uid;
                        sId = (const WCHAR *)pstrNamespaceName;

                        uid.GetResId().SetId(sId);	
			            uid.GetTypeId().SetId(wltNamespaceName);
                        uid.SetParentId(dbidFileId);
            			pNewItem->SetUniqueId(uid);
			
			            CLocString lsString;
			
			            pNewItem->SetIconType(CIT::String);			            
                        CPascalString pstrComment, pstrText;
                       		
                        pNewItem->SetInstructions(pstrComment);
                        lsString.SetString(pstrText);

			            SetFlags(pNewItem, lsString);
			            pNewItem->SetLocString(lsString);
			            
			            isItemSet.Add(pNewItem);

					    uiReadingOrder = (uiReadingOrder + 999)/1000*1000;
				        isItemSet[0]->SetDisplayOrder(uiReadingOrder);
				        uiReadingOrder++;

                        fRetVal = EnumerateItem(ihItemHandler,
                        	isItemSet);

				        dbidSectionId.Clear();			        
				        dbidSectionId = isItemSet[0]->GetMyDatabaseId();
                        isItemSet.ClearItemSet();
                        uiTemp += 1;

                    }

                    m_sCurrentNamespace = pstrNamespaceName;
                    delete pstrNamespaceName; 


                }

                // For the class name, this is trickier.
                // If there are one or more qualifiers
                // on the class itself, we need to read ahead
                // to find the class name, and then
                // generate all the qualifier objects at once.
                // ==========================================

                wmiRet = GetNextItemSet(dwCount, pBuff, isItemSet, dbidSectionId, uiStartPos);
                while (wmiRet == WMINoError)
                {
                    // For each item, we want to set its key,
                    // and push it or write it as appropriate.
                    // ========================================

                    dwCount++;
                    ULONG ulItemType;
				    CLocUniqueId &rUid = isItemSet[0]->GetUniqueId();
				    
				    rUid.GetTypeId().GetId(ulItemType);
				    //if (ulItemType == wltClassName)
				    //{
					//   uiCommentNum = 0;
					//    uiReadingOrder = (uiReadingOrder + 999)/1000*1000;
				    //}
                    for (int i = 0; i < isItemSet.GetSize(); i++)
                    {
				        isItemSet[i]->SetDisplayOrder(uiReadingOrder);
				        uiReadingOrder++;
                    }

			        if (fGenerating)
                    {
                        fRetVal = GenerateItem(ihItemHandler,
                            isItemSet, &pOutBuffer, uiStartPos);

                        if (pBuff != pOutBuffer)
                        {
                            delete pBuff;
                            pBuff = NULL;
                            pBuff = pOutBuffer; // The old memory has already been deleted.
                        }
                        else
                        {
                            fRetVal = FALSE;
                        }
                    }
                    else
			        {
				        fRetVal = EnumerateItem(ihItemHandler,
				        	isItemSet);
			        }

                    isItemSet.ClearItemSet();
                    uiTemp += 1;

                    if (!fRetVal)
                    {
                        fRetVal = TRUE;
                        break;
                    }

                    wmiRet = GetNextItemSet(dwCount, pBuff, isItemSet, dbidSectionId, uiStartPos);
                    if (uiStartPos > uiTemp)
                        uiTemp = uiStartPos;

                    if (dwCount%20 == 0)
                    {
                        if (uiNewPercentage < 100)
                            uiNewPercentage++;
                        ihItemHandler.SetProgressIndicator(uiNewPercentage);				
                    }                             
                }

                // If we were generating the file,
                // we're done.
                // ==============================
                if (fGenerating)
                    break;

                if (uiNewPercentage < 100)
                    uiNewPercentage++;
                ihItemHandler.SetProgressIndicator(uiNewPercentage);				
               
            } 
        
            uiTemp = 0;

            // Now, we get to search and replace the locale IDs,
            // and actually write out the file.
            // =================================================

            if (fRetVal && fGenerating)
            {
                fRetVal = WriteNewFile(pOutBuffer);
            }

		}

        if (pBuff)
            delete pBuff;

        ihItemHandler.SetProgressIndicator(100);

	}
	catch (CFileException *pFileException)
	{
		fRetVal = FALSE;

		ReportFileError(m_pstrFileName, m_didFileId, pFileException, ihItemHandler);

		pFileException->Delete();
	}
	catch (CUnicodeException *pUnicodeException)
	{
		CLocation loc;

		loc.SetGlobalId(CGlobalId(m_didFileId, otFile));
		loc.SetView(vProjWindow);
		
		ReportUnicodeError(pUnicodeException, ihItemHandler, loc);

		pUnicodeException->Delete();
		fRetVal = FALSE;
	}
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;
		
		ihItemHandler.IssueMessage(esError, strContext,
				g_hDll, IDS_WMI_NO_MEMORY, g_locNull);
		
		fRetVal = FALSE;

		pMemoryException->Delete();
	}
	catch (CException *pException)
	{
		CLocation loc;

		loc.SetGlobalId(CGlobalId(m_didFileId, otFile));
		loc.SetView(vProjWindow);
		
		ReportException(pException, ihItemHandler, loc);

		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;
}



//*****************************************************************************
//
//  CWMILocFile::WriteWaterMark
//
//*****************************************************************************

void CWMILocFile::WriteWaterMark()
{
	LTASSERT(NULL != m_pOpenTargetFile);

	LTASSERT(NULL != m_pOpenSourceFile);

    // Do we need to support this?

}

//*****************************************************************************
//
//  CWMILocFile::GetNextQualifierPos
//
//*****************************************************************************

BOOL CWMILocFile::GetNextQualifierPos(const wchar_t *wTmp, const wchar_t *pBuff, UINT &uiNewPos, UINT uiStartingPos) 
{
    BOOL bRet = FALSE;
    UINT uiPos = uiStartingPos;
    BOOL bComment = FALSE;

    if (pBuff && wcslen(pBuff) < uiStartingPos)
        return FALSE;

    wchar_t *pTemp = (wchar_t *)pBuff;
    pTemp += uiStartingPos;

    while (TRUE)
    {
        wchar_t *pszTest2 = NULL;

        pszTest2 = wcsstr(pTemp, L":");
        if (pszTest2)
        {
            uiPos = pszTest2 - pBuff + 1;

            // Look for the "amended" keyword.
            // ==============================

			WCHAR temp = pszTest2[0];
            while(temp == L' ' || temp == L'\0' || temp == L':')
            {
                pszTest2++;
				temp = pszTest2[0];
            }

            if (temp != L'\0')
            {
                wchar_t wTmp2[8];
                wcsncpy(wTmp2, pszTest2, 7);
				wTmp2[7] = '\0';
                if (!wcsicmp(wTmp2, wTmp))
                {
                    bRet = TRUE;
                }
            }

            // If here, we found a non-match, so try again.
            // ============================================

            if (!bRet)
                pTemp = pszTest2 + 1;
            else
                break;
        }
        else
        {
            break;
        }
    }
   
    if (bRet)
        uiNewPos = uiPos;    

    return bRet;

}

//*****************************************************************************
//
//  CWMILocFile::GetCurrentNamespace
//
//*****************************************************************************

wchar_t *CWMILocFile::GetCurrentNamespace(wchar_t *pstr, UINT uPos)
{
    wchar_t *pTemp = pstr;
    _bstr_t pstrNamespace = m_sCurrentNamespace;
    UINT uiCurrPos = 0;
    BOOL bComment = FALSE;
    
    wchar_t wTmp[] = L"#pragma namespace";
    int iHCLen = wcslen(wTmp);

    // Find the first occurrence of the namespace
    // before the current position.

    if (pstrNamespace.length() > 0)
        pTemp = wcsstr(pTemp, pstrNamespace);   // Jump directly to the existing one.

    while (uiCurrPos < uPos)
    {
        wchar_t *pszTest2 = NULL;

        pszTest2 = wcsstr(pTemp, L"#");
        if (pszTest2)
        {
            // First, go back and make sure this isn't a comment line.
            // =======================================================            
            bComment = FALSE;

            wchar_t *pComment = pszTest2;
            while (pComment > pstr)
            {
                if (pComment[0] == L'\n' || pComment[0] == L'\r')
                {
                    if (pComment[1] == L'/' && pComment[2] == L'/')
                    {
                        bComment = TRUE;
                    }
                    else
                    {
                        bComment = FALSE;
                    }
                    break;
                }
                pComment--;
            }

            if (!bComment)
            {

                wchar_t wTmp2[100];
                wcsncpy(wTmp2, pszTest2, 17);
				wTmp2[17] = '\0';
                if (!wcsicmp(wTmp2, wTmp))
                {
                    uiCurrPos += (pszTest2 - pTemp);
                    wchar_t *pszTest3 = wcschr(pszTest2, L')');

                    int iLen = (pszTest3 - pszTest2);                    
                    wchar_t *pszTmpNS = new wchar_t[iLen*2+1];
                    if (pszTmpNS)
                    {
                        pszTest2 += iHCLen + 2; // skip quote and open parent.
                        wcsncpy(pszTmpNS, pszTest2, iLen - 2); // strip quotes.
                        pszTmpNS[iLen-iHCLen-3] = '\0';
                        pstrNamespace = pszTmpNS;

                        pTemp = pszTest2 + 1;
                        delete pszTmpNS;
                    }
                }
                else
                {
                    pTemp = pszTest2 + 1;
                }
            }
            else
            {
                pTemp = pszTest2 + 1;
            }
        }
        else
        {
            break;
        }
    }

    int iLen = wcslen(pstrNamespace) ;

    wchar_t *pNew = new wchar_t[iLen*2+1];
    if (pNew)
    {
        wcsncpy(pNew, (const wchar_t *)pstrNamespace, iLen);
        pNew[iLen] = '\0';
    }

    return pNew;

}

//*****************************************************************************
//
//  CWMILocFile::GetNextItemSet
//
//*****************************************************************************

CWMILocFile::WMIFileError CWMILocFile::GetNextItemSet(
		DWORD dwCurrPos,
        const _bstr_t &pstrCurrentLine,
		CLocItemSet &aNewItem,
		const DBID &dbidSection,
        UINT &uiStartPos)		
{

    // In this function, we know there is an
    // "amended" keyword in here somewhere.
    // We want to know to which class and/or
    // property does it belong?  If we don't
    // have enough data to figure it out,
    // we need to send back a WMIIncompleteObj
    // code.  
    // ======================================
    UINT uiCurrPos = 0;
    WMIFileError feRetCode = WMINoError;
    _bstr_t sQualifierName, sRawValue, sPropName, sClassName;
    BOOL bClass = FALSE;
    int iLen = pstrCurrentLine.length() + 1;
    iLen *= 2;

    // Get the position of the keyword
    // "amended" in this chunk of text.

    wchar_t *wTemp = new wchar_t[iLen+1];
    if (!wTemp)
    {
        feRetCode = WMIOOM;
        return feRetCode;
    }

    if (GetNextQualifierPos(L"amended", pstrCurrentLine, uiCurrPos, uiStartPos))
    {
        BOOL bArray = FALSE;

        uiStartPos = uiCurrPos;
    
        // Find the qualifier name and value.   
        // wTemp = Top of File
        // wTmp2 = "Amended" keyword
        // wQfrVal = Opening bracket
        // wBkwd = floating pointer.

        wchar_t *wTmp2 = NULL, *wBkwd = NULL, *wQfrVal = NULL;

        wcscpy(wTemp, pstrCurrentLine);
        wTemp[iLen] = '\0';

        wTmp2 = wTemp;
        wTmp2 += (uiCurrPos - 1); // the "Amended" keyword.
        
        wQfrVal = FindTop(wTmp2, wTemp, bArray);

        if (!wQfrVal) // Make sure we had an open parenth
        {
            feRetCode = WMISyntaxError;
            delete wTemp;
            return feRetCode;
        }

        // Find the beginning of the qualifier name.
        wBkwd = wQfrVal;

        while (wBkwd[0] != L',' && wBkwd[0] != L'[' && wBkwd >= wTemp)
        {
            wBkwd--;
        }

        if (wBkwd[0] != L',' && wBkwd[0] != L'[') // Make sure we had a valid qualifier name.
        {
            feRetCode = WMISyntaxError;
            delete wTemp;
            return feRetCode;
        }       

        WCHAR *token;
        UINT uiLen;

        wBkwd += 1;
        
        wchar_t wTmpBuff[256];
        wcsncpy(wTmpBuff, wBkwd, wQfrVal - wBkwd);   
        wTmpBuff[wQfrVal - wBkwd] = '\0';
        sQualifierName = wTmpBuff;

        GetQualifierValue(wTemp, uiStartPos, sRawValue, uiLen);

        // Finally, populate the CLocItem.
        // ===============================
    
	    LTASSERT(aNewItem.GetSize() == 0);
	    
	    if (feRetCode == WMINoError)
	    {
		    CLocItem *pNewItem;
		    
		    try
		    {
                // Now we have a value, but it may be an 
                // array.  If so, we need to add one CLocItem
                // for each value in the array.

                VectorString arrValues;
                if (bArray)
                    ParseArray(sRawValue, arrValues);
                else
                    arrValues.push_back(sRawValue);

                for (int i = 0; i < arrValues.size(); i++)
                {               
                    wchar_t szTmp[20];
                    swprintf(szTmp, L"%ld", dwCurrPos);

                    _bstr_t sValue = arrValues.at(i);

			        pNewItem = new CLocItem;

			        CLocUniqueId uid;

                    CPascalString sTempString;

                    sTempString = sQualifierName;
                    sTempString += szTmp;
                               
			        uid.GetResId().SetId(sTempString) ;

			        if (bClass)
			            uid.GetTypeId().SetId(wltClassName);
                    else
                        uid.GetTypeId().SetId(wltPropertyName);

                    uid.SetParentId(dbidSection);				
			        pNewItem->SetUniqueId(uid);
			        
			        CLocString lsString;
                    CPascalString pstrComment, pstrText;

                    pstrText = sValue;                
                
			        pNewItem->SetIconType(CIT::String);
                    pNewItem->SetInstructions(pstrComment);
			        
                    lsString.SetString(pstrText);
			        SetFlags(pNewItem, lsString);
			        pNewItem->SetLocString(lsString);
			        
			        aNewItem.Add(pNewItem);
                }

		    }
		    catch (CMemoryException *pMemoryException)
		    {
			    feRetCode = WMIOOM;
			    
			    pMemoryException->Delete();
		    }
	    }
	    else
	    {
		    LTTRACE("Unable to process line '%ls'",
				    (const WCHAR *)pstrCurrentLine);
	    }
       
    }
    else
    {
        feRetCode = WMINoMore;
    }
    uiStartPos = uiCurrPos;


    delete wTemp;
	return feRetCode;
}

const UINT WMI_MAX_CONTEXT = 256;

//*****************************************************************************
//
//  CWMILocFile::GetFullContext
//
//*****************************************************************************

void CWMILocFile::GetFullContext(
		CLString &strContext)
		const
{
	CLString strFormat;

	strFormat.LoadString(g_hDll, IDS_WMI_FULL_CONTEXT);

	strContext.Empty();

	_sntprintf(strContext.GetBuffer(WMI_MAX_CONTEXT), WMI_MAX_CONTEXT,
			(const TCHAR *)strFormat,
			(const WCHAR *)m_pstrFileName, (UINT)m_uiLineNumber);
	strContext.ReleaseBuffer();
	
}

//*****************************************************************************
//
//  CWMILocFile::ReportFileError
//
//*****************************************************************************

void CWMILocFile::ReportFileError(
		const _bstr_t &pstrFileName,
		const DBID &didFileId,
		CFileException *pFileException,
		CReporter &Reporter)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szFileErrorMessage[MAX_MESSAGE];
	CLocation loc;
	
	pFileException->GetErrorMessage(szFileErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_BAD_FILE, (const WCHAR *)pstrFileName,
			szFileErrorMessage);

	GetFullContext(strContext);
	loc.SetGlobalId(CGlobalId(didFileId, otFile));
	loc.SetView(vProjWindow);
	
	Reporter.IssueMessage(esError, strContext, strMessage, loc);
}

//*****************************************************************************
//
//  CWMILocFile::ReportUnicodeError
//
//*****************************************************************************

void CWMILocFile::ReportUnicodeError(
		CUnicodeException *pUnicodeException,
		CReporter &Reporter,
		const CLocation &Location)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szUnicodeErrorMessage[MAX_MESSAGE];
	CLocation loc;
	
	pUnicodeException->GetErrorMessage(szUnicodeErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_UNICODE_ERROR, szUnicodeErrorMessage);
	GetFullContext(strContext);
	
	Reporter.IssueMessage(esError, strContext, strMessage, Location,
			IDH_UNICODE_CONV);
}

//*****************************************************************************
//
//  CWMILocFile::ReportException
//
//*****************************************************************************

void CWMILocFile::ReportException(
		CException *pException,
		CReporter &Reporter,
		const CLocation &Location)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szErrorMessage[MAX_MESSAGE];
	
	pException->GetErrorMessage(szErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_EXCEPTION, szErrorMessage);
	GetFullContext(strContext);

	Reporter.IssueMessage(esError, strContext, strMessage, Location);
}

//*****************************************************************************
//
//  CWMILocFile::GetQualifierValue
//
//*****************************************************************************

BOOL CWMILocFile::GetQualifierValue(wchar_t *pBuffer, UINT &uiPos, _bstr_t &sValue, UINT &uiPhysLen)
{

    // This needs to read up the text of the qualifier,
    // strip out the quotes and carriage returns, and
    // return it and its *physical* length-in-file.

    BOOL fRetVal = FALSE;
    BOOL bArray = FALSE;

    wchar_t *pTemp = pBuffer;

    pTemp += uiPos;

    pTemp = FindTop(pTemp, pBuffer, bArray);
    if (pTemp)
    {
        wchar_t tempBuff[4096];
        int iCount = 0;

        pTemp++;    // Step past this character.
        uiPhysLen = 0;

        WCHAR *token = pTemp;
        BOOL bEnd = FALSE;
        while (!bEnd)
        {
            uiPhysLen++;    // Count every character.
            WCHAR *Test;

            switch(*token)
            {
            case L'\0':
                bEnd = TRUE;
                break;
            case L'\n':
            case L'\r':
            case L'\t':
                break;
            case L'\"':
                if (!iCount)
                    break;
            case L')':
            case L'}': 
                Test = token - 1;
                while (TRUE)                    
                {
                    if (*Test == L' ' || *Test == L'\r' || *Test == L'\n' || *Test == L'\t')
                    {
                        Test--;
                        continue;
                    }
                    if (*Test == L'\"')
                    {
                        bEnd = TRUE;
                    }
                    else
                    {
                        tempBuff[iCount] = *token;
                        iCount++;
                    }
                    break;
                }
                break;
            default:
                tempBuff[iCount] = *token;
                iCount++;
                break;

            }
            token++;
        }
        if (tempBuff[iCount-1] == L'\"')
            tempBuff[iCount-1] = '\0';
        else
            tempBuff[iCount] = '\0';
        sValue = tempBuff;
        fRetVal = TRUE;
    }
    uiPhysLen -= 1; // We want to keep the closing parenth.

    return fRetVal;

}

//*****************************************************************************
//
//  CWMILocFile::SetQualifierValue
//
//*****************************************************************************

BOOL CWMILocFile::SetQualifierValue(wchar_t *pIn, wchar_t **pOut, UINT &uiPos, _bstr_t &sValue, UINT &uiLen, BOOL bQuotes)
{
    // This needs to write the localized qualifier value
    // and erase *uiLen* characters.
    // uiPos will need to be updated with the *new*
    // position of this qualifier.
    
    BOOL fRetVal = FALSE;
    wchar_t *pStart = pIn + uiPos;
    BOOL bArray = FALSE;

    pStart = FindTop(pStart, pIn, bArray);
    if (pStart)
    {
        int iNewLen = wcslen(sValue);
        int iLen = wcslen(pIn) + 3;
        if (iNewLen > uiLen)                // The length of the new buffer
            iLen += (iNewLen - uiLen);      // If the new value is longer, add it.

        pStart++;                                     // jump past the '(' character.  uiLen starts now.
        int iPos = pStart-pIn;                        // The current position.

        iLen *= 2;
        wchar_t *pNew = new wchar_t[iLen+3];

        if (pNew)
        {
            int iTempPos = 0;

            wcsncpy(pNew, pIn, iPos);       // Copy the initial part of the file.
            if (bQuotes)
                pNew[iPos] = '\"';             
            pNew[iPos+1] = '\0';            // Null terminate

            wcscat(pNew, sValue);           // Add the new value.

            iPos += 1 + wcslen(sValue);     // Jump past the value
            if (bQuotes)
                pNew[iPos] = '\"';
            pNew[iPos+1] = '\0';            // Null terminate the value.

            pStart += uiLen;                // Jump past the current value.
            
            iTempPos = iPos;
            iPos = wcslen(pIn) - (pStart-pIn);  // Calculate the length of the rest of the file.
            
            wcsncat(pNew, pStart, iPos);        // Append the rest of the file to the new buffer.

            pStart = pNew + iLen;
            pStart = FindPrevious(pStart, L";", pNew);
            pStart[1] = L'\r';
            pStart[2] = L'\n';
            pStart[3] = L'\0';
                      
            *pOut = pNew;

            fRetVal = TRUE;
        }
    }

    // Adjust the position.

    int iNewLen = wcslen(sValue);
    if (iNewLen < uiLen)
        uiPos -= (uiLen - iNewLen);
    else
        uiPos += (iNewLen - uiLen);
    uiPos += 3;

    return fRetVal;
}

//*****************************************************************************
//
//  CWMILocFile::WriteNewFile
//
//*****************************************************************************

BOOL CWMILocFile::WriteNewFile(wchar_t *pBuffer)
{
    // This needs to seek and replace all instances of the 
    // original Locale with the new one.
    // ===================================================

    BOOL fRetVal = FALSE, fSuccess = TRUE;
    UINT uiPos = 0, uiStartingPos = 0;
    int uiLen = wcslen(pBuffer);

    _bstr_t sThisLocale, sTargetLocale;
    wchar_t wOldCodePage[30], wNewCodePage[30];
    swprintf(wOldCodePage, L"_%X", m_wSourceId );
    swprintf(wNewCodePage, L"_%X", m_wTargetId );

    if (m_wSourceId != m_wTargetId)
    {

        wchar_t *pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }

        // Now look for the locale if 
        // it was converted to a decimal.
        // ==============================

        swprintf(wOldCodePage, L"(%ld)", m_wSourceId );
        swprintf(wNewCodePage, L"(%ld)", m_wTargetId );

        pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }
    }

    if (fSuccess)
    {
        fRetVal = TRUE;

        // Finally, write out the buffer to a brand new file
        // =================================================

        while (uiLen >= 0)
        {
            if (fwrite(pBuffer, sizeof(wchar_t), (uiLen > 4096) ? 4096: uiLen, m_pOpenTargetFile) < 0)
            {
                fRetVal = FALSE;
                break;
            }
            else
            {
                fRetVal = TRUE;
                pBuffer += 4096;
                uiLen -= 4096;
            }

            fflush(m_pOpenTargetFile);
        }
    }

    return fRetVal;

}

//*****************************************************************************
//
//  CWMILocFile::FindPrevious
//
//*****************************************************************************

wchar_t *CWMILocFile::FindPrevious(wchar_t *pBuffer, const wchar_t *pFind, const wchar_t *pTop)
{

    wchar_t *pRet = NULL;
    WCHAR t1, t2;
    int iLen = wcslen(pFind);
    BOOL bFound = FALSE;

    pRet = pBuffer;
    while (pRet >= pTop)
    {
        t2 = pRet[0];
        for (int i = 0; i < iLen; i++)
        {
            t1 = pFind[i];

            if (t1 == t2)
            {
                bFound = TRUE;
                break;
            }
        }
        
        if (bFound)
            break;

        pRet--;
    }

    if (pRet <= pTop)
        pRet = NULL;

    return pRet;
}

//*****************************************************************************
//
//  CWMILocFile::FindTop
//
//*****************************************************************************

wchar_t *CWMILocFile::FindTop(wchar_t *wTmp2, wchar_t *wTop, BOOL &bArray)
{

    wchar_t *wQfrVal = FindPrevious(wTmp2, L"({", wTop);        

    while (wQfrVal)
    {
        WCHAR *pQT = wQfrVal + 1;
        BOOL bFound = FALSE;

        while (TRUE)
        {
            if (*pQT != L' ' && *pQT != L'\t' && *pQT != L'\r' && *pQT != L'\n')
            {
                if (*pQT == L'\"')
                {
                    bFound = TRUE;
                }
                break;
            }
            pQT++;
        }
        
        if (!bFound)
        {
            wQfrVal --;
            wQfrVal = FindPrevious(wQfrVal, L"({", wTop);        
        }
        else
            break;
    }

    if (wQfrVal)
    {
        if (wQfrVal[0] == L'{')
            bArray = TRUE;
    }

    return wQfrVal;

}

//*****************************************************************************
//
//  CWMILocFile::ParseArray
//
//*****************************************************************************

void CWMILocFile::ParseArray(wchar_t *pIn, VectorString &arrOut)
{

    wchar_t Buff[4096];
    wchar_t *pLast = pIn;
    if (*pLast == L'\"')
        pLast++;
    wchar_t *pFind = wcsstr(pIn, L"\",");

    arrOut.clear();

    while (pFind)
    {
        wchar_t temp = pFind[-1];
        if (temp == '\\')
        { 
            pFind++;
            pFind = wcsstr(pFind, L"\",");
            continue;
        }

        wcsncpy(Buff, pLast, pFind-pLast);
        Buff[pFind-pLast] = '\0';

        arrOut.push_back(_bstr_t(Buff));

        // Now move pFind to the next valid char.

        while (pFind[0] == L'\n' || 
            pFind[0] == L'\r' ||
            pFind[0] == L' ' ||
            pFind[0] == L',' ||
            pFind[0] == L'\"' )
            pFind++;

        pLast = pFind ;
        pFind = wcsstr(pFind, L"\",");
    }

    wcscpy(Buff, pLast);
    
    if (Buff[wcslen(Buff)-1] == L'\"')
        Buff[wcslen(Buff)-1] = L'\0';   // strip off that trailing quote.
    else
        Buff[wcslen(Buff)] = L'\0';   // strip off that trailing quote.
    arrOut.push_back(_bstr_t(Buff));

    return;
}

//*****************************************************************************
//
//  CVC::ValidateString
//
//*****************************************************************************

CVC::ValidationCode ValidateString(
		const CLocTypeId &,
		const CLocString &clsOutputLine,
		CReporter &repReporter,
		const CLocation &loc,
		const CLString &strContext)
{
	CVC::ValidationCode vcRetVal = CVC::NoError;
	CLString strMyContext = strContext;

	if (strMyContext.GetLength() == 0)
	{
		strMyContext.LoadString(g_hDll, IDS_WMI_GENERIC_LOCATION);
	}

    loc; repReporter; clsOutputLine;
	
/*
	if (clsOutputLine.HasHotKey())
	{
		vcRetVal = CVC::UpgradeValue(vcRetVal, CVC::Warning);
		repReporter.IssueMessage(esWarning, strMyContext, g_hDll,
				IDS_WMI_VAL_HOTKEY, loc);
	}
	
	_bstr_t pstrBadChars;
	UINT uiBadPos;

	pstrBadChars.SetString(L"\n\ra", (UINT)3);
	
	if (pstrOutput.FindOneOf(pstrBadChars, 0, uiBadPos))
	{
		vcRetVal = CVC::UpgradeValue(vcRetVal, CVC::Error);

		repReporter.IssueMessage(esError, strMyContext, g_hDll,
				IDS_WMI_VAL_BAD_CHARS, loc);
	}
    */
	return vcRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmilprs.cpp ===
//-----------------------------------------------------------------------------

//

// File: WMIParse.cpp

//

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// Author: Kjell Swedin
// Maintainer: MikeCo, JackN
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "string.h"

#include "WMIParse.h"
#include "resource.h"
#include "WMIlfile.h"
#include "WMIlprs.h"


//*****************************************************************************
//
// CWMILocParser Construction
//
//*****************************************************************************

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Constructor for CWMILocParser.
//
//-----------------------------------------------------------------------------
CWMILocParser::CWMILocParser() : CPULocParser(g_hDll)
{
	m_fOptionInit = FALSE;
	IncrementClassCount();
}


CWMILocParser::~CWMILocParser()
{
	DEBUGONLY(AssertValid());

	DecrementClassCount();

	// Remove any options
	UnRegisterOptions();
}


//*****************************************************************************
//
// CWMILocParser Overrides
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
//
// ILocVersion
//
///////////////////////////////////////////////////////////////////////////////

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Reports the parser version information.
//
//-----------------------------------------------------------------------------
void 
CWMILocParser::OnGetParserVersion(
		DWORD &dwMajor,	
		DWORD &dwMinor, 
		BOOL &fDebug) const
{
	dwMajor = dwCurrentMajorVersion;
	dwMinor = dwCurrentMinorVersion;
	fDebug = fCurrentDebugMode;
}

	
///////////////////////////////////////////////////////////////////////////////
//
// ILocParser
//
///////////////////////////////////////////////////////////////////////////////

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Initializes the parser. Registers options for the WMI parser.
//
//-----------------------------------------------------------------------------
HRESULT
CWMILocParser::OnInit(
		IUnknown * pUnk
		)
{
	UNREFERENCED_PARAMETER(pUnk);

	LTASSERT(!m_fOptionInit);

	RegisterOptions();
	return ERROR_SUCCESS;
}


HRESULT
CWMILocParser::OnCreateFileInstance(
		ILocFile *&pLocFile,
		FileType ft)
{
	SCODE sc = E_INVALIDARG;

	pLocFile = NULL;

	if (ft == ftUnknown ||
		ft == ftWMIFileType)
	{
		try
		{
			pLocFile = new CWMILocFile(NULL);
			sc = S_OK;
		}
		catch (const CMemoryException *)
		{
			sc = E_OUTOFMEMORY;
		}
	}

	return ResultFromScode(sc);
}


void
CWMILocParser::OnGetParserInfo(
		ParserInfo &pi)
		const
{
	LTASSERT(pi.elExtensions.GetCount() == 0);

	pi.aParserIds.SetSize(1);
	pi.aParserIds[0].m_pid = pidWMI;
	pi.aParserIds[0].m_pidParent = pidNone;

	try
	{
		LTVERIFY(pi.strDescription.LoadString(g_hDll, IDS_WMI_PARSER_DESC));
		LTVERIFY(pi.strHelp.LoadString(g_hDll, IDS_OPT_HELP));
		
		pi.elExtensions.AddTail("MOF");
	}
	catch (CMemoryException *pe)
	{
		pi.strDescription.Empty();
		pe->Delete();
	}
}


void
CWMILocParser::OnGetFileDescriptions(
		CEnumCallback &cb)
		const
{
	CWMILocFile::GetFileDescriptions(cb);
}


///////////////////////////////////////////////////////////////////////////////
//
// ILocStringValidation
//
///////////////////////////////////////////////////////////////////////////////

CVC::ValidationCode
CWMILocParser::OnValidateString(
		const CLocTypeId &ltiType,
		const CLocTranslation &trTrans,
		CReporter *pReporter,
		const CContext &context)
{
	CLString strContext;

	DEBUGONLY(ltiType.AssertValid());
	DEBUGONLY(trTrans.AssertValid());
	LTASSERT(pReporter != NULL);
	DEBUGONLY(pReporter->AssertValid());
	
	return ::ValidateString(ltiType, trTrans.GetTargetString(), *pReporter, 
			context.GetLocation(), context.GetContext());
}


//*****************************************************************************
//
// Parser options.
//
//*****************************************************************************

// Reference count the registering of options since these are global to the
// parser.

static INT g_nOptionRegisterCount = 0;

BEGIN_LOC_UI_OPTIONS_BOOL(optsParserBools)
		LOC_UI_OPTIONS_BOOL_ENTRY(OPT_DISABLE_WATERMARKING,
				FALSE, CLocUIOption::etCheckBox,
				IDS_DISABLE_WATERMARKING_BOOL,
				IDS_DISABLE_WATERMARKING_BOOL_HELP,
				NULL, CLocUIOption::stUser | CLocUIOption::stOverride),

	END_LOC_UI_OPTIONS_BOOL();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Register any options for the parser.
//
//-----------------------------------------------------------------------------
void
CWMILocParser::RegisterOptions()
{

	LTASSERT(g_nOptionRegisterCount >= 0);

	if (g_nOptionRegisterCount++ > 0)
	{
		// Already registered
		return;
	}

	SmartRef<CLocUIOptionSet> spOptSet;
	CLocUIOptionImpHelper OptHelp(g_hDll);
	
	spOptSet = new CLocUIOptionSetDef;
	spOptSet->SetGroupName(g_puid.GetName());
	
	OptHelp.SetBools(optsParserBools, COUNTOF(optsParserBools));

	OptHelp.GetOptions(spOptSet.GetInterface(), IDS_OPT_DESC, 
		IDS_OPT_HELP);

	m_fOptionInit = RegisterParserOptions(spOptSet.GetInterface());

	if (m_fOptionInit)
	{
		spOptSet.Extract();
	}
}

void
CWMILocParser::UnRegisterOptions()
{
	if (m_fOptionInit)
	{
		if (--g_nOptionRegisterCount == 0)
		{
			UnRegisterParserOptions(g_puid);		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmiparse.cpp ===
//-----------------------------------------------------------------------------

//  

//  File: WMIparse.cpp

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#include "stdafx.h"

#include "WMIclass.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

LONG g_lActiveClasses = 0;
HMODULE g_hDll;
PUID g_puid(pidWMI, pidNone);

static AFX_EXTENSION_MODULE WMIparseDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	UNREFERENCED_PARAMETER(lpReserved);
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("WMIPARSE.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(WMIparseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(WMIparseDLL);
		g_hDll = hInstance;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("WMIPARSE.DLL Terminating!\n");

		//
		//  If there are active classes, they WILL explode badly once the
		//  DLL is unloaded...
		//
		LTASSERT(DllCanUnloadNow() == S_OK);
		AfxTermExtensionModule(WMIparseDLL);
	}
	return 1;   // ok
}





// {74FCE960-7F7F-11ce-8311-00AA00383930}
static const CLSID ciWMIParserCLSID =
{ 0x74fce960, 0x7f7f, 0x11ce, { 0x83, 0x11, 0x0, 0xaa, 0x0, 0x38, 0x39, 0x30 } };


STDAPI_(void)
DllGetParserCLSID(
		CLSID &ciParserCLSID)
{
	ciParserCLSID = ciWMIParserCLSID;
}



STDAPI
DllRegisterParser(void)
{
	return RegisterParser(g_hDll);
}



STDAPI
DllUnregisterParser(void)
{
	return UnregisterParser(pidWMI, pidNone);
}


	
STDAPI
DllGetClassObject(
		REFCLSID cidRequestedClass,
		REFIID iid,
		LPVOID *ppClassFactory)
{
	SCODE sc = E_UNEXPECTED;

	*ppClassFactory = NULL;

	if (cidRequestedClass != ciWMIParserCLSID)
	{
		sc = CLASS_E_CLASSNOTAVAILABLE;
	}
	else
	{
		try
		{
			CWMILocClassFactory *pClassFactory;

			pClassFactory = new CWMILocClassFactory;

			sc = pClassFactory->QueryInterface(iid, ppClassFactory);

			pClassFactory->Release();
		}
		catch (CMemoryException *pMemoryException)
		{
			sc = E_OUTOFMEMORY;
			pMemoryException->Delete();
		}
	}
	
	return ResultFromScode(sc);
}

void
IncrementClassCount(void)
{
	InterlockedIncrement(&g_lActiveClasses);
}



void
DecrementClassCount(void)
{
	LTASSERT(g_lActiveClasses != 0);
	
	InterlockedDecrement(&g_lActiveClasses);
}

	   

STDAPI
DllCanUnloadNow(void)
{
	SCODE sc;
	
	sc = (g_lActiveClasses == 0) ? S_OK : S_FALSE;

	return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmilprs.h ===
//-----------------------------------------------------------------------------

//

//  File: WMIparse.h

//

//  Author: Kjell Swedin

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
//-----------------------------------------------------------------------------

#ifndef WMIPARSE_H
#define WMIPARSE_H

#define OPT_DISABLE_WATERMARKING "DisableWatermarking"

class CWMILocParser : public CPULocParser
{
public:
	CWMILocParser();
	~CWMILocParser();

// Overrides
public:
	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType);
	virtual void OnGetParserInfo(ParserInfo &) const;
	virtual void OnGetFileDescriptions(CEnumCallback &) const;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor, BOOL &fDebug) const;

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &trTrans, CReporter *pReporter,
			const CContext &context);

// Implementation
protected:
	void GetDefaultExtensionList(CLocExtensionList & elExtList) const;

private:
	void RegisterOptions();
	void UnRegisterOptions();

	BOOL m_fOptionInit;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-2001 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-2001 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmiparse.h ===
//-----------------------------------------------------------------------------

//  

//  File: WMIParse.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//-----------------------------------------------------------------------------

void IncrementClassCount(void);
void DecrementClassCount(void);

extern HMODULE g_hDll;
extern PUID g_puid;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\wmilfile.h ===
//-----------------------------------------------------------------------------

//  

//  File: WMILFile.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef WMILOCFIL_H
#define WMILOCFIL_H

#include <vector>

const FileType ftWMIFileType = ftUnknown+1;

class CWMILocFile : public ILocFile, public CLObject
{
public:

	CWMILocFile(ILocParser *);

	static void GetFileDescriptions(CEnumCallback &);
	
    typedef std::vector<_bstr_t> VectorString;
protected:
	//
	//  Standard IUnknown methods
	//
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	//
	//  Standard Debugging interfaces
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(const CFileSpec REFERENCE,
			CReporter REFERENCE);
	STDMETHOD_(FileType, GetFileType)(void) const;
	STDMETHOD_(void, GetFileTypeDescription)(CLString REFERENCE) const;
	STDMETHOD_(BOOL, GetAssociatedFiles)(CStringList REFERENCE) const;

	STDMETHOD_(BOOL, EnumerateFile)(CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE);
	STDMETHOD_(BOOL, GenerateFile)(const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE);

	//
	//  CLObect implementation
	//
#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif

private:
	//
	//  Private methods to prevent callers access.
	//
	~CWMILocFile();
	CWMILocFile();
	const CWMILocFile &operator=(const CWMILocFile &);

	//
	//  Private data for C.O.M. implementation
	ILocParser *m_pParentClass;
	ULONG m_ulRefCount;

	//
	//  WMI specific private data.
	//
	enum WMIFileError
	{
		WMINoError,
		WMIOOM,
		WMICantOpenSourceFile,
		WMICantOpenTargetFile,
		WMINoOpenFile,
		WMINotWMIFile,
		WMICantWriteFile,
		WMISyntaxError,
		WMIFileError2,
		WMIHandlerError,
		WMIUnknownError,
        WMIIncompleteObj,
        WMINoMore
	};
	enum WMILineTypes
	{
		wltUnknown,
		wltNamespaceName,
		wltClassName,
		wltPropertyName
	};

	UINT m_uiLineNumber;
	DBID m_didFileId;
	_bstr_t m_pstrFileName;
	_bstr_t m_pstrTargetFile;
    
	FILE *m_pOpenSourceFile;
    FILE *m_pOpenTargetFile;
	
	CodePage m_cpSource;
	CodePage m_cpTarget;

    WORD m_wSourceId;
    WORD m_wTargetId;

    _bstr_t m_sCurrentNamespace;

    BOOL ReadLines(CLocItemHandler &, const DBID &, BOOL);
    WMIFileError GetNextItemSet(DWORD dwCurrPos,const _bstr_t &, CLocItemSet &,
		const DBID &, UINT &uiStartPos) ;
    BOOL GetNextQualifierPos(const wchar_t *, const wchar_t *, UINT &uiPos, UINT uiStartingPos = 0);
    BOOL EnumerateItem(CLocItemHandler &, CLocItemSet &);
	BOOL GenerateItem(CLocItemHandler &, CLocItemSet &, wchar_t **, UINT &uiStartingPos);
    void SetFlags(CLocItem *, CLocString &) const;
	void GetFullContext(CLString &) const;
	void ReportFileError(const _bstr_t &pstrFileName,
			const DBID &didFileId, CFileException *pFileException,
			CReporter &Reporter) const;
	void ReportUnicodeError(CUnicodeException *pUnicodeException,
			CReporter &Reporter, const CLocation &Location) const;
	void ReportException(CException *pException,
			CReporter &Reporter, const CLocation &) const;
    BOOL GetQualifierValue(wchar_t *, UINT &, _bstr_t &, UINT &);
    BOOL SetQualifierValue(wchar_t *, wchar_t **, UINT &, _bstr_t &, UINT &, BOOL bQuotes = TRUE);
    BOOL WriteNewFile(wchar_t *);
    wchar_t *FindPrevious(wchar_t *, const wchar_t *pTop, const wchar_t *);
    wchar_t *GetCurrentNamespace(wchar_t *, UINT uPos);
    wchar_t *FindTop(wchar_t *, wchar_t *, BOOL &);
    void ParseArray(wchar_t *, VectorString &);

    void WriteWaterMark();
	
};

CVC::ValidationCode ValidateString(const CLocTypeId &, const CLocString &clsOutputLine,
		CReporter &repReporter, const CLocation &loc, const CLString &strContext);

#endif // WMILOCFIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil.h ===
//-----------------------------------------------------------------------------

//  

//  File: esputil.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Common classes for Espresso
//  
//  
//-----------------------------------------------------------------------------

#pragma once

#pragma comment(lib, "esputil.lib")

#ifdef __cplusplus
#include <mitutil.h>
#include <locutil.h>

//
//  Not everybody gets this by default.

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>
#include <loctypes.h>					//  Generic types.
#include ".\esputil\puid.h"			//  Parser Unique ID
#include ".\esputil\espreg.h"
#include ".\esputil\espenum.h"			//  Various enumeration like objects
#include ".\esputil\dbid.h"			//  Database IDs
#include ".\esputil\globalid.h"
#include ".\esputil\location.h"		//  location for Got To functionality
#include ".\esputil\goto.h"
#include ".\esputil\filespec.h"
#include ".\esputil\context.h"			//  Context for messages - string and location

#include ".\esputil\reporter.h"		//  Message reporting mechanism
#include ".\esputil\espopts.h"


#include ".\esputil\clfile.h"			//  Wrapper for CFile
#include ".\esputil\_wtrmark.h"

#include ".\esputil\resid.h"			//  Resource ID class
#include ".\esputil\typeid.h"			//  Type ID class
#include ".\esputil\uniqid.h"			//  Loc item ID
#include ".\esputil\binary.h"			//  LocItem binary data object
#include ".\esputil\interface.h"
#include ".\esputil\locitem.h"			//  Contents of a single loc item.
#include ".\esputil\itemhand.h"		//  Item handler call-back class


#include ".\esputil\LUnknown.h"		//	CLUnknown child IUnknown helper class.

//
//  These pieces are for the Espresso core components only.
//
#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including ESPUTIL private components")

//
//  These files are semi-private - Parsers should not see them.
//
#include ".\esputil\SoftInfo.h"		//	Information about Software projects.
#include ".\esputil\_var.h"
#include ".\esputil\_importo.h"			//  Import options object
#include ".\esputil\_globalid.h"
#include ".\esputil\_goto.h"
#include ".\espUtil\_reporter.h"
#include ".\esputil\_errorrep.h"
#include ".\esputil\_espopts.h"
#include ".\esputil\_interface.h"
#endif


#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\extension.h ===
//-----------------------------------------------------------------------------

//  

//  File: extension.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#include <esputil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\helpids.h ===
//-----------------------------------------------------------------------------

//  

//  File: helpids.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

//
//  We based off 12000 since that is the start of our resource ID range.
//  DON'T USE MATH -  the Help compiler is messed up
//
//  These have to be unique.  ESPPRJ and RESTBL use up the range 12000-12400
//  for their system wide unique resource ID's, so start at 12400.
//
#define IDH_SPELLDIALOG				12400
#define IDH_UNICODE_CONV			12401   
#define IDH_ENUMERATION_UNSUCCESS		12402
#define IDH_DLGLNIT_RESOURCE			12404
//#define IDH_ACME_PAGEFAULT			12406
#define IDH_NO_PARSER_UPDATE			12408
#define IDH_NO_PARSER_UPLOAD			12410
#define IDH_GENERATE_TERMINATED		12412
#define IDH_OSTRMANX_CLEAR			12414
#define IDH_ITEMS_UNMATCHED			12416
#define IDH_MESSAGE_TABLE			12418
//#define IDH_LINKER_OLD			12426
#define IDH_GETROW_ERROR			12428
#define IDH_SDM_DIALOG				12430
#define IDH_ESPGCOMP				12432
#define IDH_ESPGCOMP_OPTIONS			12434
#define IDH_Eraser_Message			12436
#define IDH_SOURCE_SAME_GEN			12438
#define IDH_SOURCE_SAME_UP			12440	



//The following are for the Project Settings and User Settings Tabs
#define IDH_RESOPT_VALIDATION			12442
#define IDH_RESOPT_SPELLING			12444
#define IDH_RESOPT_TRANSLATION		12446
#define IDH_ESPOPT_FILE				12448
#define IDH_ESPOPT_COPY_ACROSS		12450
#define IDH_ESPOPT_ADMIN			12452
#define IDH_ESPOPT_SET_FONT			12454
#define IDH_ESPOPT_RES_ANLY			12456
#define IDH_ESPOPT_CUSTOM			12003
#define IDH_ESPOPT_LOOKUP			12453
#define IDH_ESPOPT_CUSTFIELD_GLO		30536
#define IDH_ESPOPT_CUSTFIELD_PRO		12003
#define IDH_ESPOPT_COLUMNS			12513
#define IDH_ESPOPT_SUGGESTIONS		37692
#define IDH_ESPOPT_PSEUDO			12478

//The following are for the Parser Properties dialog, General and <parser name> tabs
#define IDH_ESPOPT_PARSER_PROP_GEN		12458
#define	IDH_ESPOPT_PARSER_PROP_SPEC	12460

//This provides help @ the output/translation window when the user presses F1 with the focus there...
#define IDH_PROJECT_WINDOW_F_ONE			12462
#define IDH_TRANS_WINDOW_F_ONE				12464
#define IDH_OUTPUT_PLACEHOLDER				12466

//This is for F1-on-error-message-in-output-window-help
#define IDH_UNEXPECTED_NULL_MACSDM		12468

#define IDH_WORKSPACE_WINDOW_GLOSSARY_F_ONE	12470
#define IDH_WORKSPACE_WINDOW_FILTER_F_ONE 	12472
#define IDH_GLOSSARY_TABLE_F_ONE			12474
#define IDH_SUGGESTIONS_F_ONE				12476

#define IDH_ESPOPT_EXTENSIONS				12480
#define IDH_ESPOPT_ACCELERATORS			12482

//File|Open glossary
#define IDH_FILE_OPEN_GLOSSARY	28676
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mitutil.h ===
//-----------------------------------------------------------------------------

//  

//  File: mitutil.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  This is just a redirector to the 'real' MITUTIL.H.
//  
//-----------------------------------------------------------------------------

#include ".\mit\inc\mitutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil.h ===
//-----------------------------------------------------------------------------

//  

//  File: locutil.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL_H
#define LOCUTIL_H
#pragma once

#pragma comment(lib, "locutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#include <ComDef.h>
#pragma warning(ZCOM_WARNING_DEFAULT)

#ifndef __AFXOLE_H__
#include <afxole.h>
#pragma message("Warning: <afxole.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>
#include ".\LocUtil\FieldVal.h"
#include ".\LocUtil\Operator.h"
#include ".\LocUtil\FieldDef.h"
#include ".\LocUtil\FldDefList.h"
#include ".\LocUtil\Schema.h"
#include ".\LocUtil\FldDefHelp.h"

#include ".\LocUtil\locobj.h"
#include ".\LocUtil\locenum.h"
#include ".\LocUtil\espreg.h"			//  Registry and version info

#include ".\LocUtil\goto.h"
#include ".\LocUtil\gotohelp.h"

#include ".\locutil\report.h"
#include ".\LocUtil\progress.h"		//  'Progressive' objects base class
#include ".\LocUtil\cancel.h"			//  Base class for 'Cancelable" objects
#include ".\locutil\logfile.h"
#include ".\LocUtil\locpct.h"			//  Percent helper classes


#include ".\LocUtil\espopts.h"
#include ".\LocUtil\espstate.h"

#include ".\LocUtil\interface.h"
#include ".\LocUtil\product.h"			//	General functions about the Espresso product installed
#include ".\LocUtil\locstr.h"
#include ".\LocUtil\StringHelp.h"		//	String UI helpers
#include ".\LocUtil\ExtList.h"			//	File Extension list
#include ".\LocUtil\lstime.h"

#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including LOCUTIL private components")


//  These files are semi-private - Parsers should not see them.
//
#include ".\LocUtil\FileDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\FileExclDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\DcsGrid.h"			// Function for DisplayColumn and MIT Grid
#include ".\LocUtil\PasStrMerge.h"

#include ".\LocUtil\_errorrep.h"		//  Error reporting mechanism
#include ".\LocUtil\_pumpidle.h"		//  Mechanism for idle time
#include ".\LocUtil\_username.h"
#include ".\LocUtil\_progress.h"
#include ".\LocUtil\_cancel.h"
#include ".\LocUtil\_locstr.h"
#include ".\LocUtil\_optvalstore.h"
#include ".\LocUtil\_espopts.h"
#include ".\LocUtil\_extension.h"
#include ".\LocUtil\_interface.h"
#include ".\LocUtil\_locenum.h"
#include ".\LocUtil\_report.h"

#include ".\LocUtil\ShowWarnings.h"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\loctypes.h ===
//-----------------------------------------------------------------------------

//  

//  File: loctypes.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  This file contains defintions for simple types that have no
//  implementation.  If you have a 'universal' type that requires
//  implementation, put it in the 'esputil' directory.
//  
//-----------------------------------------------------------------------------
 

#pragma once

typedef ULONG SequenceNum;
//typedef int CodePage;
typedef ULONG FileId;
typedef ULONG BinaryId;

const BinaryId bidInvalid = 0;

typedef WORD ParserId;
const ParserId pidNone = 0;

typedef CWordArray CLocParserIdArray;

typedef WORD FileType;

//const CodePage cpInvalidCodePage = 0xDEADBEEF;

const FileType ftUnknown = 0; //Global filetype for an unknown type

// maximum number of bytes for strings corresponding to text fields
const size_t MAX_TXT = 255;

//Maximum number of nodes for Espresso szParents fields
const int MAX_PARENT_NODES = 31;
//
//  These values given to us by the VC guys, and are also in shell\ids.h
//
#ifndef MIN_ESPRESSO_RESOURCE_ID
const DWORD MIN_ESPRESSO_RESOURCE_ID  = 12000;
#endif
#ifndef MAX_ESPRESSO_RESOURCE_ID
const DWORD MAX_ESPRESSO_RESOURCE_ID  = 13999;
#endif

//
//  Now partion our range up for UI and non-UI (shared) components.
//
const DWORD MIN_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID;
const DWORD MAX_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID + 699;
const DWORD MIN_ESP_NONUI_RESOURCE_ID = MAX_ESP_UI_RESOURCE_ID + 1;
const DWORD MAX_ESP_NONUI_RESOURCE_ID = MAX_ESPRESSO_RESOURCE_ID;


enum VisualEditor
{
	veNone,
	veApstudio,
	veApstudioSubRes,
	veExternalEditor

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mitthrow.h ===
//-----------------------------------------------------------------------------

//  

//  File: MitThrow.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#include ".\Mit\inc\MitThrow.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\ltapi.h ===
//-----------------------------------------------------------------------------

//  

//  File: ltapi.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mitwarning.h ===
//******************************************************************************

//

// MitWarning.h: MIT Template Library warnings

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parseman.h ===
//-----------------------------------------------------------------------------

//  

//  File: parseman.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
#pragma comment(lib, "parseman.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>

#include ".\parseman\pinfo.h"
#include ".\parseman\pmanager.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parser.h ===
//-----------------------------------------------------------------------------

//  

//  File: parser.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Mother of all include files for parsers.  This should be everything that
//  a parser needs.
//  
//-----------------------------------------------------------------------------

#pragma once

#define ESPRESSO_AUX_COMPONENT

#include <esputil.h>
#include <pbase.h>
#include <parsutil.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\precenum.h ===
#include ".\mit\inc\PreCEnum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsutil.h ===
//-----------------------------------------------------------------------------

//  

//  File: parsutil.h|inc

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "parsutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>						// Provide interface definitions 

#include ".\parsers\ParsUtil\LocParser.h"
#include ".\parsers\ParsUtil\LocChild.h"
#include ".\parsers\ParsUtil\LocBinary.h"
#include ".\parsers\ParsUtil\LocVersion.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase.h ===
//-----------------------------------------------------------------------------

//  

//  File: pbase.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Parser base classes.  Parsers should really be using parsers.h
//  
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "pbase.lib")

#include ".\pbase\locfile.h"
#include ".\pbase\parseapi.h"
#include ".\pbase\pversion.h"
#include ".\pbase\subparse.h"
#include ".\pbase\binary.h"
#include ".\pbase\imgres32.h"
#include ".\pbase\mnemonic.h"
#include ".\pbase\idupdate.h"
#include ".\pbase\updatelog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\puser.h ===
//-----------------------------------------------------------------------------

//  

//  File: puser.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Master include file for components that need to use parsers, but not
//  implement a parser.
//
//  If you are implementing a parser, use PARSER.H instead.
//  
//-----------------------------------------------------------------------------
 
#pragma once

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
#include <parseman.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parserid.h ===
//-----------------------------------------------------------------------------

//

// File: parserid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
// See 'parserid.txt' in the Parsers directory for a description of these
// constants.
//
//-----------------------------------------------------------------------------
 
#pragma once

const ParserId pidMac   = 1;
const ParserId pidText  = 2;
const ParserId pidWin32 = 3;
const ParserId pidIni   = 4;
const ParserId pidWin16 = 5;
const ParserId pidTok   = 6;
const ParserId pidInf   = 7;
const ParserId pidRiff  = 8;
const ParserId pidFox   = 9;
const ParserId pidDos7  = 10;
const ParserId pidNet	= 11;
const ParserId pidVxd	= 12;
const ParserId pidScan	= 13;
const ParserId pidMsg   = 14;
const ParserId pidWinboot = 15;
const ParserId pidRPLBoot = 16;
const ParserId pidMacTok = 17;
const ParserId pidPpd   = 18;
const ParserId pidBmpIcon = 19;
const ParserId pidProject = 20;
const ParserId pidSrg = 21;
const ParserId pidHEAT = 22;

const ParserId pidNashville_BEGIN = 23;	
const ParserId pidNashville_END = 32;   

const ParserId pidPegasus_BEGIN = 33;
const ParserId pidPegasus_STR = 33;
const ParserId pidPegasus_END = 47;   

const ParserId pidOPC = 48;
const ParserId pidDAT = 49;

const ParserId pidPublisher_BEGIN = 50;	
const ParserId pidPublisher_DES = 50;
const ParserId pidPublisher_POC = 51;
const ParserId pidPublisher_CAT = 52;
const ParserId pidPublisher_END = 59;

const ParserId pidJavaRB = 60;

const ParserId pidOffice_BEGIN = 61;
const ParserId pidOffice_END = 80;

const ParserId pidAccWiz = 81;
const ParserId pidINX = 82;

const ParserId pidMsi = 83;
const ParserId pidForms3 = 84;
const ParserId pidVbForms = 85;
const ParserId pidMmc = 86;
const ParserId pidMAPIcfg = 87;

const ParserId pidServerApps_BEGIN = 88;
const ParserId pidServerApps_SysMessages = 88;
const ParserId pidServerApps_END = 92;

const ParserId pidProjectLCP = 93;
const ParserId pidExchangeMNC = 94;

const ParserId pidFsfParse = 95;

const ParserId pidCBTParse = 96;
const ParserId pidWMI = 97;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\binary.h ===
//-----------------------------------------------------------------------------

//  

//  File: binary.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_BINARY_H
#define ESPUTIL_BINARY_H


//
//  Base class for binary classes.  This allows serialization
//  of arbitrary data.
//

class CLocVariant;
class CLocItem;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocBinary : public CObject
{
public:
	CLocBinary();

	virtual void AssertValid(void) const;

	//
	//  Serialization routines. Supports serialization withour dynamic creation
	//
	virtual void Serialize(CArchive &archive);  //Afx serialize function

	//
	//  Result code for comparing one binary class from another.
	//
	enum CompareCode
	{
		noChange,		
		partialChange,    //Only non-localizable data changed
		fullChange        //Localizable data changed
	};
	virtual CompareCode Compare (const CLocBinary *) = 0;

	// Called to update the non-localizable data - Used when compare returns
	// partialChange

	virtual void PartialUpdate(const CLocBinary * binSource) = 0;

	enum Alignment
	{
		a_Default,
		a_Left,
		a_Center,
		a_Right,
		a_Top,
		a_VCenter,
		a_Bottom
	};

	//
	//  The universe of possible binary properties that may be queried for.
	//  This order must NOT change, or you may break old parsers!  Put new
	//  properties at the end.
	//
	enum Property
	{
		//
		//  Native formats..
		//
		p_dwXPosition,
		p_dwYPosition,
		p_dwXDimension,
		p_dwYDimension,
		p_dwAlignment,
		p_blbNativeImage,

		p_dwFontSize,
		p_pasFontName,
		p_dwFontWeight,
		p_dwFontStyle,

		//
		//  Interchange formats..
		//
		p_dwWin32XPosition,
		p_dwWin32YPosition,
		p_dwWin32XDimension,
		p_dwWin32YDimension,
		p_dwWin32Alignment,				// Use Alignment enum
		p_dwWin32ExtAlignment,			// Extended - Use Alignment enum
		p_blbWin32Bitmap,
		p_blbWin32DialogInit,
		
		//
		//  Generic - usable both for Native and Interchange
		//
		p_bVisible,						// Is the item visable?
		p_bDisabled,					// Is the item disabled?
		p_bLTRReadingOrder,				// Is the reading order L to R?
		p_bLeftScrollBar,				// Scroll bar on left?

		//
		//	"Styles" tab for dialog controls.
		//
		p_bLeftText,					// Display text to left of control?

	
		p_bWin32LTRLayout,              // WS_EX_LAYOUT_RTL
		p_bWin32NoInheritLayout,        // WS_EX_NOINHERIT_LAYOUT

		p_dwWin32VAlignment,				// Use Alignment enum

		// Insert new entries here
	};

	virtual BOOL GetProp(const Property, CLocVariant &) const;
	virtual BOOL SetProp(const Property, const CLocVariant &);
	
	//
	// Attempts to convert CBinary in CLocItem to same type as this 
	//
	virtual BOOL Convert(CLocItem *);
	virtual BinaryId GetBinaryId(void) const = 0;
	
	virtual ~CLocBinary();

	BOOL NOTHROW GetFBinaryDirty(void) const;
	BOOL NOTHROW GetFPartialUpdateBinary(void) const;
	void NOTHROW SetFBinaryDirty(BOOL);
	void NOTHROW SetFPartialUpdateBinary(BOOL);

protected:
	
private:
	//
	//  Copy constructor and assignment are hidden, since we
	//  shouldn't be copying these things around.
	//
	CLocBinary(const CLocBinary &);
	const CLocBinary& operator=(const CLocBinary &);
	//
	//  These allow a user to determine what parts of the item have been
	//  changed.
	//
	struct Flags
	{
		BOOL m_fBinaryDirty         :1;
		BOOL m_fPartialUpdateBinary :1;
	};

	Flags m_Flags;
};

#pragma warning(default: 4275)

#include "binary.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\clfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - we create the CFile
//  
//-----------------------------------------------------------------------------
inline
CLFile::CLFile()
{
	m_pFile = new CFile();
	m_bDeleteFile = TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - user provides a CFile.  User is
//  responsible for the CFile object!
//  
//-----------------------------------------------------------------------------

inline
CLFile::CLFile(
		CFile *pFile)
{
	LTASSERT(pFile != NULL);
	m_pFile = pFile;
	m_bDeleteFile = FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Destructor - also delete contained CFile if not user supplied.
//
//-----------------------------------------------------------------------------

inline
CLFile::~CLFile()
{
	DEBUGONLY(AssertValid());
	if (m_bDeleteFile)
	{
		delete m_pFile;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Read a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count read 
CLFile::ReadByte(
	BYTE & byte)				//where to place the byte
{
	if (Read(&byte, sizeof(BYTE)) != sizeof(BYTE))
	{
		AfxThrowFileException(CFileException::endOfFile);
	}
	return sizeof(BYTE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Write a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count written
CLFile::WriteByte(
		const BYTE & byte)
{
	Write(&byte, sizeof(BYTE));
	return sizeof(BYTE);
}


//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
inline
DWORD
CLFile::GetPosition()
		const
{
	return m_pFile->GetPosition();
}

inline
DWORD
CLFile::SeekToEnd()
{
	return m_pFile->SeekToEnd();
}

inline
void
CLFile::SeekToBegin()
{
	m_pFile->SeekToBegin();
}

inline
LONG
CLFile::Seek(
		LONG lOff,
		UINT nFrom)
{
	return m_pFile->Seek(lOff, nFrom);
}

inline
void
CLFile::SetLength(
		DWORD dwNewLen)
{
	m_pFile->SetLength(dwNewLen);
}

inline
DWORD
CLFile::GetLength()
		const
{
	return m_pFile->GetLength();
}

inline
UINT
CLFile::Read(
		void* lpBuf,
		UINT nCount)
{
	return m_pFile->Read(lpBuf, nCount);
}

inline
void
CLFile::Write(
		const void* lpBuf,
		UINT nCount)
{
	m_pFile->Write(lpBuf, nCount);
}

inline
void
CLFile::Flush()
{
	m_pFile->Flush();
}

inline
void
CLFile::Close()
{
 	m_pFile->Close();
}


inline
void
CLFile::Abort()
{
	m_pFile->Abort();
}



inline
CLString
CLFile::GetFileName(void)
		const
{
	return m_pFile->GetFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\binary.inl ===
//-----------------------------------------------------------------------------
//  
//  File: binary.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Required inline functions for generating binary info template classes.
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFBinaryDirty(void)
		const
{
	return m_Flags.m_fBinaryDirty;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFBinaryDirty(
		BOOL f)
{
	m_Flags.m_fBinaryDirty = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFPartialUpdateBinary(void)
		const
{
	return m_Flags.m_fPartialUpdateBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFPartialUpdateBinary(
		BOOL f)
{
	m_Flags.m_fPartialUpdateBinary = f;
}



//-----------------------------------------------------------------------------
//
//  Default conversion of one Binary to another format - it fails
//
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::Convert(CLocItem *)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\clfile.h ===
//-----------------------------------------------------------------------------

//  

//  File: clfile.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Wrapper class for CFile.  It allows us to use CPascalString for
//  file names, and does some 'text mode' read/write operations.
//  This class contains a pointer to a CFile but contains most of
//  the CFile methods thus it can be used as a CFile.  CLFile will either
//  use an existing CFile provided at construction time or it will create its
//  own CFile as needed.  In either case, the enbeded CFile is destroyed when
//  the CLFile is destroyed.
//  
//-----------------------------------------------------------------------------
 
#ifndef CLFILE_H
#define CLFILE_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLFile : public CObject
{
public:
	CLFile();
	CLFile(CFile *);
	~CLFile();

	void AssertValid(void) const;

//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
	DWORD GetPosition() const;

	DWORD SeekToEnd();
	void SeekToBegin();

	LONG Seek(LONG lOff, UINT nFrom);
	void SetLength(DWORD dwNewLen);
	DWORD GetLength() const;

	UINT Read(void* lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nCount);

	void LockRange(DWORD dwPos, DWORD dwCount);
	void UnlockRange(DWORD dwPos, DWORD dwCount);

	void Abort();
	void Flush();
	void Close();

	CLString GetFileName(void) const;

//-----------------------------------------------------------------------------
// The following are all the CLFile methods
//-----------------------------------------------------------------------------


	BOOL Open(const CPascalString &pstrFileName, UINT nOpenFlags,
			CFileException *pError = NULL);

	static void Rename(const CPascalString &pstrFileName,
			const CPascalString &pstrNewName);
	static void Remove(const CPascalString &pstrFileName);

	static void CopyFile(
			const CPascalString &pasSource,
			const CPascalString &pasTarget,
			BOOL fFailIfExist = TRUE,
			CProgressiveObject *pProgress = NULL);
	
	static BOOL GetStatus(const CPascalString &pstrFileName,
			CFileStatus &rStatus);
	static void SetStatus(const CPascalString &pstrFileName,
			const CFileStatus &status);

	UINT ReadLine(CPascalString &pstrLine, CodePage cp);
	UINT ReadLine(CPascalString &pstrLine);

	UINT ReadString(CPascalString &pstrLine, CodePage cp);
	UINT ReadString(CPascalString &pstrLine);

	UINT ReadByte(BYTE &);
	UINT ReadWord(WORD &, BOOL BigEnded = FALSE);
	UINT ReadDWord(DWORD &, BOOL BigEnded = FALSE);

	UINT ReadPascalB(CPascalString &);
	UINT ReadPascalW(CPascalString &);
	UINT ReadPascalD(CPascalString &);

	UINT ReadPascalB(CPascalString &, CodePage);
	UINT ReadPascalW(CPascalString &, CodePage);
	UINT ReadPascalD(CPascalString &, CodePage);

	UINT Read(CPascalString &pstr, UINT nCount, CodePage cp);
	UINT Read(CPascalString &pstr, UINT nCount);

	UINT WriteLine(const CPascalString &pstrLine, CodePage cp);
	UINT WriteLine(const CPascalString &pstrLine);

	UINT WriteString(const CPascalString &pstrString, CodePage cp);
	UINT WriteString(const CPascalString &pstrString);

	UINT WriteByte(const BYTE &);
	UINT WriteWord(const WORD &, BOOL BigEnded = FALSE);
	UINT WriteDWord(const DWORD &, BOOL BigEnded = FALSE);

	UINT WritePascalB(const CPascalString &);
	UINT WritePascalW(const CPascalString &);
	UINT WritePascalD(const CPascalString &);

	UINT WritePascalB(const CPascalString &, CodePage);
	UINT WritePascalW(const CPascalString &, CodePage);
	UINT WritePascalD(const CPascalString &, CodePage);

	UINT Write(const CPascalString &pstrString);
	UINT Write(const CPascalString &pstrString, CodePage cp);

	UINT SkipToBoundary(UINT nBoundary);
	UINT PadToBoundary(UINT nBoundary, BYTE ucPad = 0);
	void Pad(UINT nCount, BYTE ucPad = 0);

	UINT CopyRange(CLFile &Target, UINT uiNumBytes,
			CProgressiveObject *pProgress = NULL);
	
protected:
	CFile *m_pFile;
	BOOL m_bDeleteFile;	//Should we delete m_pFile in our destructor?
};


enum FileStat
{
	fsNoStatus = 0x00,
	fsNotFound = 0x01,
	fsUpToDate = 0x02,
	fsFileNewer = 0x04,
	fsFileOlder = 0x08,
	fsNotReadable = 0x10,
	fsNotWritable = 0x20
};



WORD
LTAPIENTRY LocateFile(
		const CLString &strFileName,
		const COleDateTime &tGmtFileTime);



#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clfile.inl"
#endif

#endif // CLFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\context.inl ===
//-----------------------------------------------------------------------------
//  
//  File: context.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
CContext::CContext()
{}


inline
CContext::CContext(
		const CContext & context)
	: m_strContext(context.m_strContext), m_loc(context.m_loc)
{}


inline
CContext::CContext(
		const CLString &strContext)
	: m_strContext(strContext)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID)
	: m_strContext(hDll, uiStringID)
{}



inline
CContext::CContext(
		const CLString &strContext,
		const CLocation &loc)
	: m_strContext(strContext), m_loc(loc)
{}

	

inline
CContext::CContext(
		const CLString &strContext,
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabid,
		Component component)
	: m_strContext(strContext), m_loc(dbid, ot, view, tabid, component)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID,
		const CLocation &loc)
	: m_strContext(hDll, uiStringID), m_loc(loc)
{}


inline
CContext::CContext(
		HINSTANCE hDll, 
		UINT uiStringID, 
		const DBID & dbid, 
		ObjectType ot, 
		View view, 
		TabId tabid, 
		Component component)
	: m_strContext(hDll, uiStringID), 
	  m_loc(dbid, ot, view, tabid, component)
{}


inline
const CLString &
CContext::GetContext(void) const
{
	return m_strContext;
}



inline
const CLocation &
CContext::GetLocation(void)
		const
{
	return m_loc;
}



inline
const 
CContext &
CContext::operator=(const CContext & context)
{
	m_strContext	= context.m_strContext;
	m_loc			= context.m_loc;

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\dbid.h ===
//-----------------------------------------------------------------------------

//  

//  File: dbid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef DBID_H
#define DBID_H


//
// represents a database id
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY DBID : public CObject
{
public:
	//
	// ctors
	//
	DBID();
	DBID(const DBID& id);
	DBID(long l);
	~DBID();

	//
	// debug methods
	//
	void AssertValid() const;
	//
	// 'get like' methods
	//
	BOOL NOTHROW IsNull() const;
	NOTHROW operator long () const;
	int NOTHROW operator==(const DBID &) const;
	int NOTHROW operator!=(const DBID &) const;

	//
	// 'put like' methods
	//
	void NOTHROW operator=(const DBID&);
	void NOTHROW Set(long);
	void NOTHROW Clear();

protected:
	long m_l;

private:
	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)

typedef CArray<DBID, DBID &> CDBIDArray;

	
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "dbid.inl"
#endif

const extern LTAPIENTRY DBID g_NullDBID;
  
#endif // DBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\context.h ===
//-----------------------------------------------------------------------------

//  

//  File: context.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_CONTEXT_H
#define ESPUTIL_CONTEXT_H



//
//  This class should NOT be used as a base class.
//
class LTAPIENTRY CContext
{
public:
	CContext();
	CContext(const CContext &);
	CContext(const CLString &);
	CContext(HINSTANCE, UINT uiStringId); 
	CContext(const CLString &, const CLocation &);
	CContext(HINSTANCE, UINT uiStringId, const CLocation &);
	CContext(const CLString &, const DBID &, ObjectType, View,
			TabId = NullTabId, Component = cmpNone);
	CContext(HINSTANCE, UINT uiStringID, const DBID &, ObjectType, View, 
			TabId = NullTabId, Component = cmpNone);
	
	void AssertValid(void) const;

	const CContext &operator=(const CContext &);

	const CLString &GetContext(void) const;
	const CLocation &GetLocation(void) const;

	BOOL operator==(const CContext &);
			
private:

	CLString m_strContext;
	CLocation m_loc;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "context.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\espenum.h ===
//-----------------------------------------------------------------------------

//  

//  File: espenum.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPENUM_H
#define ESPENUM_H



extern const LTAPIENTRY CString ftDescUnknown; //Description for unknown file types


class LTAPIENTRY CIconType
{
public:
	// Special note: these enum value sequence is of vital importance to
	// the GUI components.  Please preserve them.
	enum IconType
	{
		None = 0,
		Project,		// project root icon
		Directory,		// Part of project structure
		File,			// File object in the project
		Expandable,		// Generic Expandable node in a file.
						// Special note: Any value up to Expandable is
						// currently display as a folder in prj window
		Bitmap,			// Bitmap
		Dialog,			// Dialog like items
		Icon,			// Icon resource
		Version,		// Version stamping resources
		String,			// String resources
		Accel,			// Accelerator
		Cursor,			// Cursor resource
		Menu,			// Menu resources
		Custom,			// Custom resources
		Reference		// icon for reference glossary
	};

	NOTHROW static const TCHAR * GetIconName(CIconType::IconType);
	NOTHROW static HBITMAP GetIconBitmap(CIconType::IconType);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szIconNames[];
	CIconType();
};

typedef CIconType CIT;



class LTAPIENTRY CLocStatus
{
public:
	enum LocStatus
	{
		InvalidLocStatus = 0,
		NotLocalized,
		Updated,
		Obsolete_AutoTranslated,  //  Don't use this!  Obsolete!
		Localized = 4,
		NotApplicable,
		InvalidLocStatus2  // used by edbval to determine a invalid status
		                   // a new "valid" status must be entered before this.
	};

	NOTHROW static const TCHAR * GetStatusText(CLocStatus::LocStatus);
	NOTHROW static const TCHAR * GetStatusShortText(CLocStatus::LocStatus);
	NOTHROW static CLocStatus::LocStatus MapShortTextToEnum(const TCHAR *);
	NOTHROW static CLocStatus::LocStatus MapCharToEnum(const TCHAR);
	NOTHROW static CLocStatus::LocStatus MapLongTextToEnum(const TCHAR *szLongName);
	
	static void Enumerate(CEnumCallback &);
	
private:
	struct StatusInfo
	{
		const TCHAR *szStatusShortText;
		const TCHAR *szStatusText;
	};

	static const StatusInfo m_Info[];

	CLocStatus();
};

typedef CLocStatus CLS;




#endif // ESPENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\dbid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: dbid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// every new DBID is null
//
//-----------------------------------------------------------------------------
inline
DBID::DBID()
{
	m_l = 0;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid LONG
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		LONG l)
{
	LTASSERT(l > 0);

	m_l = l;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid other dbid
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		const DBID& id)
{
	ASSERT_VALID(&id);

	m_l = id.m_l;

	DEBUGONLY(++m_UsageCounter);
}



inline
DBID::~DBID()
{
	DEBUGONLY(--m_UsageCounter);
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::Set(
		LONG l)
{
	ASSERT_VALID(this);
	LTASSERT(l > 0);
	LTASSERT(m_l == 0);

	m_l = l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::operator=(
		const DBID& id)
{
	ASSERT_VALID(this);
	LTASSERT(m_l == 0);
	ASSERT_VALID(&id);

	m_l = id.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LONG operator, the only way to get the value of a DBID, any attempt to get
// the value of a null DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
DBID::operator LONG ()
		const
{
	ASSERT_VALID(this);
	LTASSERT(m_l > 0);

	return m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to clear (make it null) the dbid must be explicit
//
//-----------------------------------------------------------------------------
inline
void
DBID::Clear()
{
	ASSERT_VALID(this);

	m_l = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to know if a dbid is null
//
//-----------------------------------------------------------------------------
inline
BOOL
DBID::IsNull()
		const
{
	ASSERT_VALID(this);

	return (m_l == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator==(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l == dbid.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator!=(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l != dbid.m_l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\espopts.h ===
//-----------------------------------------------------------------------------

//  

//  File: espopts.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


LTAPIENTRY BOOL RegisterParserOptions(CLocUIOptionSet*);
LTAPIENTRY void UnRegisterParserOptions(const PUID&);

LTAPIENTRY BOOL GetParserOptionValue(const PUID &, LPCTSTR szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetParserOptionBool(const PUID&, LPCTSTR pszName);
LTAPIENTRY const CPascalString GetParserOptionString(const PUID&, LPCTSTR pszName);
LTAPIENTRY DWORD GetParserOptionNumber(const PUID&, LPCTSTR pszName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\espreg.h ===
//-----------------------------------------------------------------------------

//  

//  File: espreg.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 



//
//  Provided so parsers can register themselves.
//
LTAPIENTRY HRESULT RegisterParser(HMODULE);
LTAPIENTRY HRESULT UnregisterParser(ParserId pid, ParserId pidParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\filespec.h ===
//-----------------------------------------------------------------------------

//  

//  File: filespec.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_FILESPEC_H
#define ESPUTIL_FILESPEC_H

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFileSpec : public CObject
{
public:
	NOTHROW CFileSpec();
	NOTHROW CFileSpec(const CFileSpec &);
	NOTHROW CFileSpec(const CPascalString &, const DBID &);

	void AssertValid(void) const;

	NOTHROW void SetFileName(const CPascalString &);
	NOTHROW void SetFileId(const DBID &);

	NOTHROW const CPascalString & GetFileName(void) const;
	NOTHROW const DBID & GetFileId(void) const;

	NOTHROW const CFileSpec & operator=(const CFileSpec &);
	
	~CFileSpec();
	
private:
	
	CPascalString m_pasFileName;
	DBID m_didFileId;
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\globals.h ===
//-----------------------------------------------------------------------------

//  

//  File: globals.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\goto.h ===
//-----------------------------------------------------------------------------

//  

//  File: goto.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


LTAPIENTRY CGoto *CreateEspGoto(const CLocation &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\globalid.h ===
//-----------------------------------------------------------------------------

//  

//  File: globalid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL_GLOBALID_H
#define ESPUTIL_GLOBALID_H

enum ObjectType
{
	otNone,
	otFile,
	otResource,
};



///////////////////////////////////////////////////////////////////////////////
//
// global id object, represents what fully qualifies any database item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CGlobalId: public CObject
{
public:
	//
	// ctor/dtor
	//
	NOTHROW CGlobalId();
	NOTHROW CGlobalId(const DBID &dbid, ObjectType otType);
	NOTHROW CGlobalId(const CGlobalId &id);
	NOTHROW ~CGlobalId();
	
	//
	// operators
	//
	NOTHROW int operator==(const CGlobalId &) const;
	NOTHROW int operator!=(const CGlobalId &) const;

	NOTHROW const CGlobalId & operator=(const CGlobalId &);
	
	NOTHROW const DBID & GetDBID() const;
	NOTHROW ObjectType GetObjType(void) const;
	
protected:
	//
	// debug routines
	//
	virtual void AssertValid() const;

	//
	// data members
	//
	DBID  m_dbid;
	ObjectType  m_otObjType;

	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "globalid.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\itemhand.h ===
//-----------------------------------------------------------------------------

//  

//  File: itemhand.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration for the item handler class.  This encapsulates the call-back
//  functionality for the Parsers during an enumeration.
//  
//-----------------------------------------------------------------------------
 

#ifndef ITEMHAND_H
#define ITEMHAND_H


class LTAPIENTRY CLocItemHandler : public CReporter, public CCancelableObject
{
public:
	CLocItemHandler();

	void AssertValid(void) const;
	
	virtual BOOL HandleItemSet(CLocItemSet &) = 0;

	virtual ~CLocItemHandler();
			
private:
};

#endif //  ITEMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\interface.h ===
//-----------------------------------------------------------------------------

//  

//  File: interface.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once


extern const LTAPIENTRY IID IID_ILocStringValidation;

class CLocTranslation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocTranslation REFERENCE,
				CReporter *, const CContext &) PURE;
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\globalid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: globalid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CGlobalId::CGlobalId()
{
	m_otObjType = otNone;
	
	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ctor
//
//-----------------------------------------------------------------------------
inline
CGlobalId::CGlobalId(
		const DBID &dbid,
		ObjectType ot)
{
	m_dbid = dbid;
	m_otObjType = ot;

	DEBUGONLY(++m_UsageCounter);
}

inline
CGlobalId::CGlobalId(
		const CGlobalId &id)
{
	m_dbid = id.m_dbid;
	m_otObjType = id.m_otObjType;

	DEBUGONLY(++m_UsageCounter);
}



inline
CGlobalId::~CGlobalId()
{
	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator==(
		const CGlobalId& id)
		const
{
	return (m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator!=(
		const CGlobalId& id)
		const
{
	return !(m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get the dbid
//
//-----------------------------------------------------------------------------

inline
const DBID &
CGlobalId::GetDBID()
		const
{
	return m_dbid;
}


inline
ObjectType
CGlobalId::GetObjType(void)
		const
{
	return m_otObjType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\location.h ===
//-----------------------------------------------------------------------------

//  

//  File: location.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCATION_H
#define ESPUTIL_LOCATION_H



typedef CWnd *TabId;
const TabId NullTabId = 0;

enum View
{
	vNone,
	vTransTab,
	vVisualEditor,
	vProjWindow
};

enum Component
{
	cmpNone,
	cmpSource,
	cmpTarget,
	cmpSourceAndTarget
};
	
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocation : public CObject
{
public:
	NOTHROW CLocation();
	NOTHROW CLocation(const CLocation &);
	NOTHROW CLocation(const CGlobalId &, View, TabId = NullTabId, Component = cmpNone);
	NOTHROW CLocation(const DBID &, ObjectType, View, TabId = NullTabId, Component = cmpNone);
	
#ifdef _DEBUG
	virtual void AssertValid(void) const;
#endif
	
	NOTHROW const CLocation & operator=(const CLocation &);
	NOTHROW int operator==(const CLocation &) const;
	NOTHROW int operator!=(const CLocation &) const;

	NOTHROW const CGlobalId & GetGlobalId(void) const;
	NOTHROW TabId GetTabId(void) const;
	NOTHROW View GetView(void) const;
	NOTHROW Component GetComponent(void) const;
	NOTHROW BOOL IsVisual(void) const;

	NOTHROW void SetGlobalId(const CGlobalId &);
	NOTHROW void SetTabId(const TabId);
	NOTHROW void SetView(View);
	NOTHROW void SetComponent(Component);

	NOTHROW ~CLocation() {};

private:
	NOTHROW void AssignFrom(const CLocation &);
	NOTHROW BOOL Compare(const CLocation &) const;
	
	CGlobalId m_giId;
	TabId m_TabId;
	View m_View;
	Component m_Component;
};

#pragma warning(default: 4275)

const extern LTAPIENTRY CLocation g_locNull;

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "location.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\itemhand.inl ===
//-----------------------------------------------------------------------------
//  
//  File: itemhand.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Retail versions do nothing.  Debug code is in reporter.cpp
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\locitem.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locitem.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocItem class.  This is included by locitem.h.
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has a localizable string.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if there's a localizable string
CLocItem::HasLocString(void)
		const
{
	return !GetLocString().GetString().IsNull();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has binary info.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if the item has bin. content
CLocItem::HasBinary(void)
		const
{
	return m_pBinary!= NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the database id for the item.  This is internal to the DB, and
//  should not be used except to indicate parent child relationships and for
//  database operations.
//  
//-----------------------------------------------------------------------------
inline
const DBID&								// The database id for the item.
CLocItem::GetMyDatabaseId(void)
		const
{
	return m_dbid;
}





inline
const DBID &
CLocItem::GetPseudoParentId(void)
		const
{
	return m_PseudoParent;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
const CLocUniqueId &
CLocItem::GetUniqueId(void)
	const
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
CLocUniqueId &
CLocItem::GetUniqueId(void)
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the translation of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetTranslationStatus(void)
		const
{
	return m_lsTranslationStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the binary part of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetBinaryStatus(void)
		const
{
	return m_lsBinaryStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current translation origin for the item.
//  
//-----------------------------------------------------------------------------
inline
CTO::TranslationOrigin							// origin for the item.
CLocItem::GetTranslationOrigin(void)
		const
{
	return m_toTranslationOrigin;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAS::ApprovalState							// Status for the item.
CLocItem::GetApprovalStatus(void)
		const
{
	return m_asApprovalStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current auto approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAA::AutoApproved 						// Status for the item.
CLocItem::GetAutoApproved(void)
		const
{
	return m_auto_approved;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current confidence level for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetConfidenceLevel(void)
		const
{
	return m_confidence_level;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom1 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom1(void)
		const
{
	return m_custom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom2 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom2(void)
		const
{
	return m_custom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom3 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom3(void)
		const
{
	return m_custom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom4 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom4(void)
		const
{
	return m_custom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom5 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom5(void)
		const
{
	return m_custom5;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom6 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom6(void)
		const
{
	return m_custom6;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the display order for the item. This is used to provide a default
//  ordering of items in the resource table.  Lower values are displayed first.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Display order for the item.
CLocItem::GetDisplayOrder(void)
		const
{
	return m_uiDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the CLocString for the item.  To determine if it is valid, use
//  HasLocString().  A valid string can be blank!
//  
//-----------------------------------------------------------------------------
inline
const CLocString &						// Current string for the item.
CLocItem::GetLocString(void)
	const
{
	return m_lsString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'intructions' (developer provided comments) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Developer intructions.
CLocItem::GetInstructions(void)
		const
{
	return m_pstrInstructions;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'term notes' (glossary note) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Glossary Notes.
CLocItem::GetTermNotes(void)
		const
{
	return m_pstrTermNotes;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'InstrAtt'  for an item.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFInstrAtt(void)
		const
{
	return m_Flags.m_fInstrAtt;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the binary content for an item.  If this function returns FALSE, the
//  return pointer is set to NULL.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the content is valid.
CLocItem::GetBinary(
		const CLocBinary *&pBinary) // RETURN pointer
		const
{
	pBinary = m_pBinary;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Similar to GetBinary() but after this call
//	the item will no longer have a CLocBinary.
//	By calling this member, the caller gets
//	ownership of the CLocBinary, so he is responsible
//	of either deleting the CLocBinary or assigning
//	it to another CLocItem via the SetBinary() member.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if a CLocBinary was extracted.
CLocItem::ExtractBinary(
		CLocBinary *&pBinary) // RETURN pointer
{
	pBinary = m_pBinary;
	m_pBinary = NULL;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the icon type fro the item.
//  
//-----------------------------------------------------------------------------
inline
CIT::IconType
CLocItem::GetIconType(void)
		const
{
	return m_icIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the editor for this item (and all it's children!).
//  
//-----------------------------------------------------------------------------
inline
VisualEditor
CLocItem::GetVisualEditor(void)
		const
{
	return m_veEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the database id for the item.  ONLY the database code should use
//  this method.  This may become protected/private in the future!
//
//  The Database id will not allow itself be set twice!
//
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetMyDatabaseId(
		const DBID& dbid)				// New datbase id for this item.
{
	m_dbid = dbid;
}



inline void
CLocItem::SetPseudoParent(
		const DBID &dbid)
{
	m_PseudoParent.Clear();
	
	m_PseudoParent = dbid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the translation part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsTranslationStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the binary part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetBinaryStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsBinaryStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the translation origin for the item.  This is of interest to the
//  Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationOrigin(
		CTO::TranslationOrigin toNewOrigin)		// New origin for the item.
{
	m_toTranslationOrigin = toNewOrigin;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the approval status for the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetApprovalStatus(
		CAS::ApprovalState asNewStatus)		// New status for the item.
{
	m_asApprovalStatus = asNewStatus;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the auto approval status for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetAutoApproved(
		CAA::AutoApproved aaNewStatus)		// New status for the item.
{
	m_auto_approved = aaNewStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the confidence level for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetConfidenceLevel(
		long lConfLevel)		// New confidence level for the item.
{
	m_confidence_level = lConfLevel;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom1 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom1(
		long lCustom1)		
{
	m_custom1 = lCustom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom2 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom2(
		long lCustom2)		
{
	m_custom2 = lCustom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom3 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom3(
		long lCustom3)		
{
	m_custom3 = lCustom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom4 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom4(
		long lCustom4)		
{
	m_custom4 = lCustom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom5 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom5(
		long lCustom5)		
{
	m_custom5 = lCustom5;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom6 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom6(
		long lCustom6)		
{
	m_custom6 = lCustom6;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the display order for an item.  This is used to provide a default
//  ordering of items in the resource table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetDisplayOrder(
		UINT uiNewDisplayOrder)			// New display order for the item.
{
	m_uiDisplayOrder = uiNewDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the visual editor for the item.  The parser sets this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetVisualEditor(
		VisualEditor veNewEditor)
{
	m_veEditor = veNewEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the icon type.  This is displayed bside the item in the Translation
//  table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetIconType(
		CIT::IconType itNewIconType)
{
	m_icIconType = itNewIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the intstructions for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetInstructions(
		const CPascalString &pstrNewInstructions) // New instructions.
{
	if (pstrNewInstructions != m_pstrInstructions)
	{
		m_pstrInstructions = pstrNewInstructions;
		SetFInstructionsDirty(TRUE);
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the term notes for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTermNotes(
		const CPascalString &pstrNewTermNotes) // New Term Notes.
{
	if (pstrNewTermNotes != m_pstrTermNotes)
	{
		m_pstrTermNotes = pstrNewTermNotes;
	}
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the InstrAtt for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFInstrAtt(
		BOOL f)
{
	m_Flags.m_fInstrAtt = f;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears all the dirty flags for the item and its sub-components.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::ClearDirtyFlags(void)
{
	m_Flags.m_fTargetStringDirty = m_Flags.m_fStringDirty = 
			m_Flags.m_fItemDirty = m_Flags.m_fInstructionsDirty = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various internal state flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtString(void) const
{
	return m_Flags.m_fEqualSrcTgtString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtString(BOOL f)
{
	m_Flags.m_fEqualSrcTgtString = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtBinary(void) const
{
	return m_Flags.m_fEqualSrcTgtBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtBinary(BOOL f)
{
	m_Flags.m_fEqualSrcTgtBinary = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get and set methods for all the Dirty flags.  Used by the update code.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFStringDirty(void) const
{
	return m_Flags.m_fStringDirty;
}

inline
void
CLocItem::SetFStringDirty(BOOL f)
{
	m_Flags.m_fStringDirty = f;
}

inline
BOOL
CLocItem::GetFTargetStringDirty(void) const
{
	return m_Flags.m_fTargetStringDirty;
}

inline
void
CLocItem::SetFTargetStringDirty(BOOL f)
{
	m_Flags.m_fTargetStringDirty = f;
}

inline
BOOL
CLocItem::GetFItemDirty(void) const
{
	return m_Flags.m_fItemDirty;
}

inline
void
CLocItem::SetFItemDirty(BOOL f)
{
	m_Flags.m_fItemDirty = f;
}

inline
BOOL
CLocItem::GetFInstructionsDirty(void)
		const
{
	return m_Flags.m_fInstructionsDirty;
}

inline
void
CLocItem::SetFInstructionsDirty(
		BOOL f)
{
	m_Flags.m_fInstructionsDirty = f;
}

inline
BOOL
CLocItem::GetFValidTranslation(void) const
{
	return m_Flags.m_fValidTranslation;
}

inline
void
CLocItem::SetFValidTranslation(BOOL f)
{
	m_Flags.m_fValidTranslation = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Global is anything in this CBinary dirty
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::IsAnyDirty()
{
	return m_Flags.m_fItemDirty ||
		m_Flags.m_fStringDirty || 
		m_Flags.m_fTargetStringDirty ||
		m_Flags.m_fInstructionsDirty ||
		(m_pBinary==NULL ? FALSE : m_pBinary->GetFBinaryDirty());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various parser flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFDevLock(void) const
{
	return m_Flags.m_fDevLock;
}

inline
void
CLocItem::SetFDevLock(BOOL f)
{
	m_Flags.m_fDevLock = f;
}

inline
BOOL
CLocItem::GetFUsrLock(void) const
{
	return m_Flags.m_fUsrLock;
}
inline
void
CLocItem::SetFUsrLock(BOOL f)
{
	m_Flags.m_fUsrLock = f;
}

inline
BOOL
CLocItem::GetFTransLock(void) const
{
	return m_Flags.m_fTransLock;
}
inline
void
CLocItem::SetFTransLock(BOOL f)
{
	m_Flags.m_fTransLock = f;
}


inline
BOOL
CLocItem::GetFExpandable(void) const
{
	return m_Flags.m_fExpandable;
}

inline
void
CLocItem::SetFExpandable(BOOL f)
{
	m_Flags.m_fExpandable = f;
}

inline
BOOL
CLocItem::GetFDisplayable(void) const
{
	return m_Flags.m_fDisplayable;
}

inline
void
CLocItem::SetFDisplayable(BOOL f)
{
	m_Flags.m_fDisplayable = f;
}

inline
BOOL
CLocItem::GetFNoResTable(void) const
{
	return m_Flags.m_fNoResTable;
}

inline
void
CLocItem::SetFNoResTable(BOOL f)
{
	m_Flags.m_fNoResTable = f;
}



inline
void
CLocItem::SetLocString(
		const CLocString &lsNewString)
{
	m_lsString = lsNewString;
}



inline
void
CLocItem::SetUniqueId(
		const CLocUniqueId &uid)
{
	m_uid = uid;
}



inline
void
CLocItem::ClearUniqueId(void)
{
	m_uid.ClearId();
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the binary content for the item.  If there was a previous binary
//  content, it is deleted.
//  
//-----------------------------------------------------------------------------
inline 
void
CLocItem::SetBinary(
		CLocBinary *pNewBinary)
{
	if (m_pBinary != NULL)
	{
		delete m_pBinary;
	}
	m_pBinary = pNewBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item editable?
//  
//-----------------------------------------------------------------------------
inline
BOOL 
CLocItem::IsLocked(void) const
{
	return (GetFDevLock() || GetFUsrLock());
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
BOOL CLocItem::GetFVisEditorIgnore(void) const
{
	return m_Flags.m_fVisEditorIgnore;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set if the item is ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
void 
CLocItem::SetFVisEditorIgnore(BOOL f)
{
	m_Flags.m_fVisEditorIgnore = f; 
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Needed so that the CMnemonic class can be used as the key of a CMap
//  
//-----------------------------------------------------------------------------
inline
CMnemonic::operator unsigned long() const
{
	return MAKELONG(m_cHotkeyChar, m_nHotkeyScope);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\puid.h ===
//-----------------------------------------------------------------------------

//  

//  File: puid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#pragma once

struct LTAPIENTRY PUID
{
	PUID();
	PUID(ParserId pid, ParserId pidParent);
	CLString GetName(void) const;
	
	ParserId m_pid;
	ParserId m_pidParent;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "puid.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\location.inl ===
//-----------------------------------------------------------------------------
//  
//  File: location.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
void
CLocation::AssignFrom(
		const CLocation &other)
{
	m_giId = other.m_giId;
	m_TabId = other.m_TabId;
	m_View = other.m_View;
	m_Component = other.m_Component;
}



inline
BOOL
CLocation::Compare(
		const CLocation &other)
		const
{
	return m_giId == other.m_giId &&
		m_TabId == other.m_TabId &&
		m_View == other.m_View &&
		m_Component == other. m_Component;
}



inline
CLocation::CLocation()
{
	m_TabId = NullTabId;
	m_View = vNone;
	m_Component = cmpNone;
}



inline
CLocation::CLocation(
		const CLocation &Other)
{
	AssignFrom(Other);
}



inline
CLocation::CLocation(
		const CGlobalId &giId,
		View view,
		TabId tabId,
		Component component)
	: m_giId(giId), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
CLocation::CLocation(
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabId,
		Component component)
	: m_giId(dbid, ot), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
const CLocation &
CLocation::operator=(
		const CLocation &Other)
{
	AssignFrom(Other);

	return *this;
}



inline
int
CLocation::operator==(
		const CLocation &Other) const
{
	return Compare(Other);
}



inline
int
CLocation::operator!=(
		const CLocation &Other) const
{
	return !Compare(Other);
}



inline
const CGlobalId &
CLocation::GetGlobalId(void)
		const
{
	return m_giId;
}



inline
TabId
CLocation::GetTabId(void)
		const
{
	return m_TabId;
}



inline
View
CLocation::GetView(void)
		const
{
	return m_View;
}



inline
Component
CLocation::GetComponent(void)
		const
{
	return m_Component;
}



inline
BOOL
CLocation::IsVisual(void)
		const
{
	return (m_View == vVisualEditor);
}



inline
void
CLocation::SetGlobalId(
		const CGlobalId &gid)
{
	m_giId = gid;
}



inline
void
CLocation::SetTabId(
		const TabId TabId)
{
	m_TabId = TabId;
}



inline
void
CLocation::SetView(
		View vView)
{
	m_View = vView;
}



inline
void
CLocation::SetComponent(
		Component comp)
{
	m_Component = comp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\puid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: puid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
PUID::PUID()
{
	m_pid = pidNone;
	m_pidParent = pidNone;
}



inline
PUID::PUID(
		ParserId pid,
		ParserId pidParent)
{
	m_pid = pid;
	m_pidParent = pidParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\lunknown.h ===
//-----------------------------------------------------------------------------

//  

//  File: LUnknown.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined (EspUtil_LUnknown_h)
#define EspUtil_LUnknown_h


////////////////////////////////////////////////////////////////////////////////
// CLUnknown
//
//	A abstract base class that is designed to help when creating child classes
//	that depend on a parent class.  These classes can not exist by themselves,
//	but instead mearly export different interfaces to the parent class.
//
// Rules:
//	1.	All classes must have a valid, non-NULL parent pointer.
//	2.	The parent class is responsible for AddRef()'ing itself during
//		QueryInterface().
//
////////////////////////////////////////////////////////////////////////////////

class LTAPIENTRY CLUnknown
{
// Construction
public:
	CLUnknown(IUnknown * pParent);
protected:  // Don't allow stack objects
	virtual ~CLUnknown() = 0;

// Data
protected:
	ULONG		m_ulRef;	// Reference count
	IUnknown *	m_pParent;	// Parent of object

// Operations
public:
	ULONG AddRef();
	ULONG Release();
	HRESULT QueryInterface(REFIID iid, LPVOID * ppvObject);
};
////////////////////////////////////////////////////////////////////////////////

#include "LUnknown.inl"

#if !defined(DECLARE_CLUNKNOWN)

#define DECLARE_CLUNKNOWN() \
public: \
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj); \
	STDMETHOD_(ULONG, AddRef)(THIS); \
	STDMETHOD_(ULONG, Release)(THIS);

#endif

#if !defined(IMPLEMENT_CLUNKNOWN)

#define IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::AddRef(void) \
	{ \
		return CLUnknown::AddRef(); \
	}

#define IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::Release(void) \
	{ \
		return CLUnknown::Release(); \
	}

#define IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass) \
	STDMETHODIMP ObjectClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
	{ \
		return (HRESULT) CLUnknown::QueryInterface(riid, ppVoid); \
	}

#define IMPLEMENT_CLUNKNOWN(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass)

#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\locitem.h ===
//-----------------------------------------------------------------------------

//  

//  File: locitem.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCITEM_H
#define LOCITEM_H



#pragma warning(disable : 4251)  // Shut up already about _declspec(import)
#pragma warning(disable : 4275)  // Shut up already about _declspec(export)

class CLocItem;


//
//  Class to hold an array of pointers to items.
//
class LTAPIENTRY CLocItemPtrArray : public CTypedPtrArray<CPtrArray, CLocItem *>
{
public:
	NOTHROW CLocItemPtrArray(BOOL fDelete=TRUE);

	void AssertValid(void) const;

	void NOTHROW ClearItemPtrArray(void);
	int NOTHROW Find(DBID, const CLocItem * &, BOOL bLocalizableOnly = FALSE) const;

	virtual ~CLocItemPtrArray();

private:
	CLocItemPtrArray(const CLocItemPtrArray &);
	void operator=(const CLocItemPtrArray &);

	BOOL m_fDelete;
};


//
//  Class to hold an item set.  This is an array of items that all have the
//  same identifier.
//
class LTAPIENTRY CLocItemSet : public CLocItemPtrArray
{
public:
	NOTHROW CLocItemSet(BOOL fDelete=TRUE);

	void AssertValid(void) const;
	
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	NOTHROW const DBID & GetPseudoParentId(void) const;

	NOTHROW void ClearItemSet(void);

	NOTHROW void Match(const CLocItemSet &, CMap<int, int, int, int> &);

	NOTHROW int Find(CLocItem * pItem, int nStartAt = 0);
	
	NOTHROW ~CLocItemSet();
	
private:
	static const CLocUniqueId m_luid;     //This is a default last ditch 
	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  A localizable item. 
//  It represents either source or target data, depending on the context, but not both.
//
class LTAPIENTRY CLocItem : public CObject
{
public:
	NOTHROW CLocItem();

	void AssertValid(void) const;
	
	//
	//  Read-only access members
	//
	NOTHROW BOOL HasLocString(void) const;
	NOTHROW BOOL HasBinary(void) const;
	
	NOTHROW const DBID & GetMyDatabaseId(void) const;
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	const DBID &GetPseudoParentId(void) const;
	NOTHROW CLocUniqueId & GetUniqueId(void);
	
	NOTHROW CLS::LocStatus GetTranslationStatus(void) const;
	NOTHROW CLS::LocStatus GetBinaryStatus(void) const;
	NOTHROW CTO::TranslationOrigin GetTranslationOrigin(void) const;
	NOTHROW CAS::ApprovalState GetApprovalStatus(void) const;
	NOTHROW CAA::AutoApproved GetAutoApproved(void) const;
	NOTHROW long GetConfidenceLevel(void) const;
	NOTHROW long GetCustom1(void) const;
	NOTHROW long GetCustom2(void) const;
	NOTHROW long GetCustom3(void) const;
	NOTHROW long GetCustom4(void) const;
	NOTHROW long GetCustom5(void) const;
	NOTHROW long GetCustom6(void) const;

	NOTHROW const CLocString & GetLocString(void) const;
	
	NOTHROW BOOL GetBinary(const CLocBinary *&) const;

	NOTHROW CIT::IconType GetIconType(void) const;
	NOTHROW const CPascalString & GetInstructions(void) const;
	NOTHROW const CPascalString GetInstructions(BOOL) const;
	NOTHROW const CPascalString & GetTermNotes(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	NOTHROW VisualEditor GetVisualEditor(void) const;

	NOTHROW BOOL GetFEqualSrcTgtString(void) const;
	NOTHROW void SetFEqualSrcTgtString(BOOL);
	NOTHROW BOOL GetFEqualSrcTgtBinary(void) const;
	NOTHROW void SetFEqualSrcTgtBinary(BOOL);
	NOTHROW BOOL GetFStringDirty(void) const;
	NOTHROW void SetFStringDirty(BOOL);
	NOTHROW BOOL GetFTargetStringDirty(void) const;
	NOTHROW void SetFTargetStringDirty(BOOL);
	NOTHROW BOOL GetFItemDirty(void) const;
	NOTHROW void SetFItemDirty(BOOL);
	NOTHROW BOOL IsAnyDirty(void);
	NOTHROW BOOL IsLocked(void) const;

	NOTHROW BOOL GetFDevLock(void) const;
	NOTHROW void SetFDevLock(BOOL);
	NOTHROW BOOL GetFTransLock(void) const;
	NOTHROW void SetFTransLock(BOOL);
	NOTHROW BOOL GetFUsrLock(void) const;
	NOTHROW void SetFUsrLock(BOOL);
	NOTHROW BOOL GetFExpandable(void) const;
	NOTHROW void SetFExpandable(BOOL);
	NOTHROW BOOL GetFDisplayable(void) const;
	NOTHROW void SetFDisplayable(BOOL);
	NOTHROW BOOL GetFNoResTable(void) const;
	NOTHROW void SetFNoResTable(BOOL);
	NOTHROW BOOL GetFValidTranslation(void) const;
	NOTHROW void SetFValidTranslation(BOOL);
	NOTHROW BOOL GetFVisEditorIgnore(void) const;
	NOTHROW void SetFVisEditorIgnore(BOOL);

	NOTHROW void SetFInstructionsDirty(BOOL);
	NOTHROW BOOL GetFInstructionsDirty(void) const;
	
	NOTHROW void SetFInstrAtt(BOOL);
	NOTHROW BOOL GetFInstrAtt(void) const;

	//
	//  Assignment members.  These set the appropriate dirty flags in the
	//  item.
	//

	NOTHROW void SetMyDatabaseId(const DBID&);
	NOTHROW void SetUniqueId(const CLocUniqueId &);
	NOTHROW void SetPseudoParent(const DBID &);
	NOTHROW void SetLocString(const CLocString &);
	NOTHROW void ClearUniqueId(void);
	NOTHROW void SetTranslationStatus(CLS::LocStatus);
	NOTHROW void SetBinaryStatus(CLS::LocStatus);
	NOTHROW void SetTranslationOrigin(CTO::TranslationOrigin);
	NOTHROW void SetApprovalStatus(CAS::ApprovalState);
	NOTHROW void SetAutoApproved(CAA::AutoApproved);
	NOTHROW void SetConfidenceLevel(long);
	NOTHROW void SetCustom1(long);
	NOTHROW void SetCustom2(long);
	NOTHROW void SetCustom3(long);
	NOTHROW void SetCustom4(long);	
	NOTHROW void SetCustom5(long);
	NOTHROW void SetCustom6(long);
	NOTHROW void SetIconType(CIT::IconType);
	NOTHROW void SetInstructions(const CPascalString &);
	NOTHROW void SetTermNotes(const CPascalString &);
	NOTHROW void SetDisplayOrder(UINT);
	NOTHROW void SetVisualEditor(VisualEditor);


	//
	//  Setting the binary part will delete the
	//  previous one!
	//
	NOTHROW void SetBinary(CLocBinary *);

	NOTHROW BOOL ExtractBinary(CLocBinary *&);

	NOTHROW void TransferBinary(CLocItem *);

	//
	//  Clear ALL the dirty flags for the item.
	//
	NOTHROW void ClearDirtyFlags(void);

	//	Kind of smart assignment
	BOOL UpdateFrom(CLocItem &);

	enum eLocContent
	{
		Source,
		Target
	};

	enum eDataFlow
	{
		FromFileToDb,
		FromDbToFile
	};
	//	Kind of assignment for localizable content only.
	BOOL UpdateLocContentFrom(
		CLocItem & itemInput, 
		eDataFlow nDataFlow, 
		eLocContent nFrom, 
		eLocContent nTo);
	//Used to know how similar is the localizable content between 2 items
	enum eMatchType
	{
		matchEmpty,
		matchBinary,
		matchString,
		matchFull
	};
	int MatchLocContent(const CLocItem &);
	//
	//  Comparisons between localizable items.
	//
	NOTHROW int operator==(const CLocItem &) const;
	NOTHROW int operator!=(const CLocItem &) const;

	NOTHROW BOOL BobsConsistencyChecker(void) const;
	
	virtual ~CLocItem();

protected:
	
	//
	//  Private helper functions.
	//
	NOTHROW BOOL CompareItems(const CLocItem &);
	
private:

	//
	//  Flags that apply to the entire item.  These control the display and
	//  editablity and internal status of an item.
	//
	struct Flags
	{
		BOOL m_fDevLock           :1; // Resource locked (in source file) from parser data
		BOOL m_fUsrLock           :1; // Resource locked (by user) from parser data
		BOOL m_fTransLock         :1; // Resource locked (for the user) from parser data
		BOOL m_fExpandable        :1; // Expandable in project window
		BOOL m_fDisplayable       :1; // Display in project window
		BOOL m_fNoResTable        :1; // Don't display in res table
		BOOL m_fStringDirty       :1; // has the source locstring changed?
		BOOL m_fTargetStringDirty :1; // has the target locstring changed?
		BOOL m_fItemDirty         :1; // has any other part of the item changed?
		BOOL m_fEqualSrcTgtString :1; // are the src&tgt strings equal?
		BOOL m_fEqualSrcTgtBinary :1; // are the src&tgt binaries equal?
		BOOL m_fValidTranslation  :1; // is the target string (the translation) good 
									  // for an autotranslate ?
		BOOL m_fVisEditorIgnore   :1; // is the item ignored in the visual editor?
									  // in memory state only.
		BOOL m_fInstructionsDirty :1;
		BOOL m_fInstrAtt		  :1; // has the instruction changed by Update command?
	};

	//
	//  Prevents the default copy constructor from being called.
	//
	CLocItem(const CLocItem &);
	virtual void Serialize(CArchive &) {}
	const CLocItem &operator=(const CLocItem &);
	
	//
	//  Item data.
	//

	//Language-independent members
	DBID           m_dbid;             //Id of item within the db
	DBID           m_PseudoParent;
	CLocUniqueId   m_uid;
	CLocString     m_lsString;
	CIT::IconType  m_icIconType;       //UI Icon that visually indicates item type
	CPascalString  m_pstrInstructions; //Instructions on how to localize the item
	CPascalString  m_pstrTermNotes;    // glossary notes 
	CLS::LocStatus m_lsTranslationStatus;		// Translation Loc status
	CLS::LocStatus m_lsBinaryStatus;			// Binary Loc status
	CTO::TranslationOrigin m_toTranslationOrigin;	// translation origin
	CAS::ApprovalState	m_asApprovalStatus;
	CAA::AutoApproved m_auto_approved;		// AUTO APPROVED
	long m_confidence_level;				// confidence level
	long m_custom1;							// CUSTOM1
	long m_custom2;							// CUSTOM2
	long m_custom3;							// CUSTOM3
	long m_custom4;							// CUSTOM4
	long m_custom5;							// CUSTOM5
	long m_custom6;							// CUSTOM6
	VisualEditor   m_veEditor;         //Graphical editor used for the item
	Flags          m_Flags;            //Various flags

	//Language-dependent members
	UINT           m_uiDisplayOrder;   //Physical order of item in the file
	CLocBinary    *m_pBinary;        //Parser-specific properties

	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  Callback class used to provide information about
//  items to the item log.
//
class LTAPIENTRY CItemInfo
{
public:
	CItemInfo() {};
	
	virtual ~CItemInfo() {};

	virtual CLString GetFileName(const CLocItem *) = 0;
	virtual CLString GetItemName(const CLocItem *) = 0;
	
private:
	CItemInfo(const CItemInfo &);
	const CItemInfo & operator=(const CItemInfo &);
};



//Classes used to retrieve mnemonics (aka hotkeys) from parsers
class LTAPIENTRY CMnemonic
{
public:
	NOTHROW operator unsigned long() const;
	WCHAR m_cHotkeyChar;
	WORD m_nHotkeyScope;

};

class LTAPIENTRY CMnemonicsMap : public CMap<CMnemonic, CMnemonic &,
					  CLocItemPtrArray *, CLocItemPtrArray * &>
{
public:
	CMnemonicsMap() 
	{};

	~CMnemonicsMap();

private:
	CMnemonicsMap(const CMnemonicsMap &);
	void operator=(int);
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locitem.inl"
#endif

#endif // LOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\reporter.h ===
//-----------------------------------------------------------------------------

//  

//  File: reporter.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_REPORTER_H
#define ESPUTIL_REPORTER_H



//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReporter : public CReport
{
public:
	CReporter() {};

	void AssertValid(void) const;


 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	//
	//  The usage of these versions of IssueMessage is discouraged.  Use the
	//  versions with the CGoto objects instead.
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity,
			const CPascalString &strContext, const CLString &strMessage,
			const CLocation &, UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			HMODULE hResourceModule, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, const CLString &strMessage ,
			const CLocation &, UINT uiHelpContext = 0);
	
	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);


	virtual void IssueMessage(MessageSeverity, const CContext &context,
			const CLString &strMessage, UINT uiHelpId = 0);
	virtual void IssueMessage(MessageSeverity, const CContext &context,
			HMODULE hResourceModule, UINT uiStringId, UINT uiHelpId = 0);
	
	virtual ~CReporter();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReporter(const CReporter &);
	const CReporter &operator=(const CReporter &);

};

#pragma warning(default: 4275)


#endif // ESPUTIL_REPORTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\lunknown.inl ===
//-----------------------------------------------------------------------------
//  
//  File: LUnknown.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//*****************************************************************************
//
// CLUnknown Constructions / Destruction
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::CLUnknown(
		IUnknown * pParent
		)
{
	LTASSERT(pParent != NULL);

	m_ulRef = 0;
	m_pParent = pParent;
	m_pParent->AddRef();
//	AddRef();  // Don't AddRef() itself.  The caller is expected to do this
}


///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::~CLUnknown()
{
	LTASSERT(m_ulRef == 0);

	LTASSERT(m_pParent != NULL);
	m_pParent->Release();	
}


//*****************************************************************************
//
// CLUnknown Operations
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::AddRef()
{
	return ++m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::Release()
{
	LTASSERT(m_ulRef > 0);

	if (--m_ulRef == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
HRESULT
CLUnknown::QueryInterface(REFIID iid, LPVOID * ppvObject)
{
	LTASSERT(ppvObject != NULL);

	return m_pParent->QueryInterface(iid, ppvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Espresso.rc
//
#define IDS_NOTE                        12746
#define IDS_WARNING                     12747
#define IDS_ERROR                       12748
#define IDS_ABORT                       12749
#define IDS_SHUTDOWN                    12750
#define IDS_OUTTAB_FILE                 12751
#define IDS_OUTTAB_TEST                 12752
#define IDS_OUTTAB_GBOX                 12753
#define IDS_OUTTAB_LOCK                 12754
#define IDS_OUTTAB_UPDATE               12755
#define IDS_OUTTAB_MESSAGES             12756
#define IDS_SETTINGS_CTX                12766
#define IDS_SETTINGS_INDENT             12767
#define IDS_SETTINGS_SEP                12768
#define IDS_SETTINGS_DEFAULT            12769
#define IDS_SETTINGS_USER               12770
#define IDS_SETTINGS_OVERRIDE           12771
#define IDS_DISP_ICON                   12772
#define IDS_DISP_SOURCE                 12773
#define IDS_DISP_TRANSLATION            12774
#define IDS_DISP_PREVIOUS               12775
#define IDS_DISP_INSTRUCTIONS           12776
#define IDS_DISP_TERM_NOTE              12777
#define IDS_DISP_RESOURCE_ID            12778
#define IDS_DISP_TRANSLATION_STATUS     12779
#define IDS_DISP_BINARY_STATUS          12780
#define IDS_DISP_TRANSLATION_ORIGIN     12781
#define IDS_DISP_STRING_CATEGORY        12782
#define IDS_DISP_APPROVAL               12783
#define IDS_DISP_LOCK                   12784
#define IDS_DISP_SRC_LOCK               12785
#define IDS_DISP_PARSER_ID              12786
#define IDS_DISP_MODIFIED_DATE          12787
#define IDS_DISP_MODIFIED_BY            12788
#define IDS_DISP_CUSTOM1                12789
#define IDS_DISP_CUSTOM2                12790
#define IDS_DISP_CUSTOM3                12791
#define IDS_DISP_CUSTOM4                12792
#define IDS_DISP_CUSTOM5                12793
#define IDS_DISP_CUSTOM6                12794
#define IDS_IconHelp                    12795
#define IDS_SourceTermHelp              12796
#define IDS_TranslationHelp             12797
#define IDS_PreviousSourceHelp          12798
#define IDS_InstructionHelp             12799
#define IDS_TermNoteHelp                12800
#define IDS_ResourceIDHelp              12801
#define IDS_TransStatusHelp             12802
#define IDS_BinStatusHelp               12803
#define IDS_TransOriginHelp             12804
#define IDS_StringCategoryHelp          12805
#define IDS_ApprovalStatusHelp          12806
#define IDS_UserLockHelp                12807
#define IDS_DevLockHelp                 12808
#define IDS_ParserIDHelp                12809
#define IDS_ModifiedDateHelp            12810
#define IDS_ModifiedByHelp              12811
#define IDS_Custom1Help                 12812
#define IDS_Custom2Help                 12813
#define IDS_Custom3Help                 12814
#define IDS_Custom4Help                 12815
#define IDS_Custom5Help                 12816
#define IDS_Custom6Help                 12817
#define IDS_SoftwareDescription         12818
#define IDS_DISP_INSTRUCTIONS_ATT       12819
#define IDS_InstructionAttHelp          12820
#define IDS_DISP_SRC_LEN                12821
#define IDS_SRC_LEN_HELP                12822
#define IDS_DISP_TGT_LEN                12823
#define IDS_TGT_LEN_HELP                12824
#define IDS_TransLockHelp               12825
#define IDS_DISP_TRANS_LOCK             12826
#define IDS_DISP_SRC_HK                 12827
#define IDS_SRC_HK_HELP                 12828
#define IDS_DISP_TGT_HK                 12829
#define IDS_TGT_HK_HELP                 12830
#define IDS_DISP_AUTO_APPROVED          12831
#define IDS_AutoApprovedHelp            12832
#define IDS_DISP_CONFIDENCE_LEVEL       12833
#define IDS_ConfidenceLevelHelp         12834
#define IDS_ConfidenceLevel_Invalid     12835

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12604
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12608
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\stdafx.h ===
//-----------------------------------------------------------------------------

//  

//  File: stdafx.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning(disable : 4663 )
#pragma warning(disable : 4665 )

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#pragma warning(disable : 4664 )
#include <afxtempl.h>

#include <mitutil.h>
#include <locutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\resid.h ===
//-----------------------------------------------------------------------------

//  

//  File: resid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef RESID_H
#define RESID_H


class LTAPIENTRY CLocResId : public CLocId
{
public:
	NOTHROW CLocResId();

	void AssertValid(void) const;

	const CLocResId &operator=(const CLocResId &);

	int NOTHROW operator==(const CLocResId &) const;
	int NOTHROW operator!=(const CLocResId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "resid.inl"
#endif

#endif  // RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\softinfo.h ===
//******************************************************************************

//

// SoftInfo.h: Software Utility classes

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_SoftInfo_h_INCLUDED)
#define ESPUTIL_SoftInfo_h_INCLUDED

struct LTAPIENTRY SoftCol
{
	// Unique string names for columns
	static const WCHAR * szIcon;
	static const WCHAR * szSource;
	static const WCHAR * szTarget;
	static const WCHAR * szPreviousSource;
	static const WCHAR * szInstructions;
	static const WCHAR * szInstrAtt;
	static const WCHAR * szNote;
	static const WCHAR * szResourceID;
	static const WCHAR * szTranslationStatus;
	static const WCHAR * szBinaryStatus;
	static const WCHAR * szOrigin;
	static const WCHAR * szCategory;
	static const WCHAR * szApproval;
	static const WCHAR * szLock;
	static const WCHAR * szSourceLock;
	static const WCHAR * szTransLock;
	static const WCHAR * szModifiedDate;
	static const WCHAR * szModifiedBy;
	static const WCHAR * szAutoApproved;
	static const WCHAR * szConfidenceLevel;
	static const WCHAR * szCustom1;
	static const WCHAR * szCustom2;
	static const WCHAR * szCustom3;
	static const WCHAR * szCustom4;
	static const WCHAR * szCustom5;
	static const WCHAR * szCustom6;
	static const WCHAR * szParserID;
	static const WCHAR * szSrcLen;
	static const WCHAR * szTgtLen;
	static const WCHAR * szSrcHotKey;
	static const WCHAR * szTgtHotKey;
	
	// Unique ID's for columns
	//
	// DO NOT 'INSERT' ITEMS.  You will change the ID's and
	// mess people up.
	
	typedef enum
	{
		FLD_ICON,
		FLD_SOURCE_TERM,
		FLD_TARGET_TERM,
		FLD_PREVIOUS_SOURCE_TERM,
		FLD_INSTRUCTIONS,
		FLD_INSTR_ATT,
		FLD_GLOSSARY_NOTE,
		FLD_UNIQUE_ID,
		FLD_TRANSLATION_STATUS,
		FLD_BINARY_STATUS,
		FLD_TRANSLATION_ORIGIN,
		FLD_STRING_TYPE,
		FLD_APPROVAL_STATE,
		FLD_USR_LOCK,
		FLD_DEV_LOCK,
		FLD_TRANS_LOCK,
		FLD_MODIFIED_DATE,
		FLD_MODIFIED_BY,
		FLD_AUTO_APPROVED,
		FLD_CONFIDENCE_LEVEL,
		FLD_CUSTOM1,
		FLD_CUSTOM2,
		FLD_CUSTOM3,
		FLD_CUSTOM4,
		FLD_CUSTOM5,
		FLD_CUSTOM6,
		//
		//  Add displayable columns here.
		
		FLD_PARSER_ID = 50,
		//
		//  Add non-displayable, RESTBL required columns here

		FLD_SRC_LEN = 100,
		FLD_TGT_LEN,
		FLD_SRC_HK,
		FLD_TGT_HK,
		//
		//  Add non-displayable, non-RESTBL columns here. 
		
		FLD_COUNT = 30					// Make sure this is accurate!
	} FIELD;

	// RAID:  LS42 Bug 46 fixed by MikeL
	// Functions to validate the value of the above
	// column types.  All validate functions must pass
	// two parameters:  1-LPCTSTR. and 2-DWORD
	static BOOL ValidateDefault (LPCTSTR lpszNewText, DWORD dwNewNum);
	static BOOL ValidateConfidenceLevel (LPCTSTR lpszNewText, DWORD dwNewNum);

	// Exported functions
	static void GetSoftwareSchema(CTableSchema * & pSchema);
	static const CLString & GetDisplayName(FIELD col);

	static const CColumnDefinition * GetColumnDefinition(FIELD col);

	static int GetColumnCount();

	static int GetCustomColumnCount();
	static BOOL IsCustomColumn(FIELD col);

// Implementation
protected:
	static void BuildStringCategory(CTableSchema * pSchema);
	static void BuildApprovalState(CTableSchema * pSchema);
};

#endif // ESPUTIL_SoftInfo_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\typeid.h ===
//-----------------------------------------------------------------------------

//  

//  File: typeid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef TYPEID_H
#define TYPEID_H


class LTAPIENTRY CLocTypeId : public CLocId
{
public:
	NOTHROW CLocTypeId();

	void AssertValid(void) const;

	const CLocTypeId &operator=(const CLocTypeId &);

	int NOTHROW operator==(const CLocTypeId &) const;
	int NOTHROW operator!=(const CLocTypeId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "typeid.inl"
#endif

#endif // TYPEID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\resid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline funxtions for the Resource ID.  This file should ONLY be included
//  by resid.h.
//  
//-----------------------------------------------------------------------------
 
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocResId::CLocResId()
{}



inline
const CLocResId &
CLocResId::operator=(
		const CLocResId & locId)
{
	CLocId::operator=(locId);
	return *this;
}


inline
int
CLocResId::operator==(
		const CLocResId & locId)
		const
{
	return CLocId::operator==(locId);
}


inline
int
CLocResId::operator!=(
		const CLocResId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\uniqid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uniqid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline function definitions for the Espresso Unique ID.  This file should
//  ONLY be included by uniqid.h.
//  
//-----------------------------------------------------------------------------
 

inline
const DBID&
CLocUniqueId::GetParentId(void)
		const
{
	return m_dbid;
}



inline
const CLocTypeId &
CLocUniqueId::GetTypeId(void)
		const
{
	return m_tid;
}



inline
const CLocResId &
CLocUniqueId::GetResId(void)
		const
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the parent ID for the item.  This portion of the ID is set by the
//  parser.
//  
//-----------------------------------------------------------------------------
inline
DBID&
CLocUniqueId::GetParentId(void)
{
	return m_dbid;
}

inline
CLocTypeId &
CLocUniqueId::GetTypeId(void)
{
	return m_tid;
}

inline
CLocResId &
CLocUniqueId::GetResId(void)
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comapre two ID's.  
//  
//-----------------------------------------------------------------------------
inline
int								        //  Zero if different
CLocUniqueId::operator==(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return IsEqualTo(uidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compare two ID's
//  
//-----------------------------------------------------------------------------
inline
int										// Zero if identical
CLocUniqueId::operator!=(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return !IsEqualTo(uidOther);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the Parent ID component of the ID.
//  
//-----------------------------------------------------------------------------
inline
void
CLocUniqueId::SetParentId(
		const DBID& dbidNewId)			// New Parent ID
{
	m_dbid = dbidNewId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_errorrep.h ===
//-----------------------------------------------------------------------------

//  

//  File: _errorrep.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ERRORREP_H
#define ESPUTIL__ERRORREP_H


////////////////////// the new global issuemessage functions.
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLString &strMessage, const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		HINSTANCE hResourceDll, UINT uiStringId, const CLocation &,
		UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLocation &, CException *);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLString &strMessage, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContextId, UINT uiStringId, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLocation &, CException *);

void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		const CLString &, UINT uiHelpId = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		HINSTANCE, UINT, UINT uiHelpId = 0);

void LTAPIENTRY SetErrorReporter(CReporter *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReporter(CReporter *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\typeid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: typeid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the Type ID.  This file should ONLY be included
//  by typeid.h.
//
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocTypeId::CLocTypeId()
{}



inline
const CLocTypeId &
CLocTypeId::operator=(
		const CLocTypeId & locId)
{
	CLocId::operator=(locId);

	return *this;
}

inline
int
CLocTypeId::operator==(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator==(locId);
}



inline
int
CLocTypeId::operator!=(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_espenum.h ===
//-----------------------------------------------------------------------------

//  

//  File: _espenum.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ESPENUM_H
#define ESPUTIL__ESPENUM_H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_espopts.h ===
//-----------------------------------------------------------------------------

//  

//  File: _espopts.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

LTAPIENTRY CLocOptionValStore *  GetParserOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetParserOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateParserOptionValues(void);
LTAPIENTRY CLocUIOptionSet * GetParserOptionSet(const PUID &);

LTAPIENTRY void SummarizeParserOptions(CReport *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		const CLString &strContext,
		HINSTANCE hResourceDll,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLString &strMessage,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);

	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, hResourceDll, uiStringId, loc,uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLocation &loc, 
		CException *pe)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, loc, pe);
}




inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		const CLString &strMessage,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), strMessage, context.GetLocation(),
			uiHelpId);
	
}



inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		HINSTANCE hResDll,
		UINT uiStringId,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), hResDll, uiStringId,
			context.GetLocation(), uiHelpId);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\uniqid.h ===
//-----------------------------------------------------------------------------

//  

//  File: uniqid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  What we use to uniquely identify a localizable item.
//  
//-----------------------------------------------------------------------------
 

#ifndef UNIQID_H
#define UNIQID_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUniqueId : public CObject
{
public:
	NOTHROW CLocUniqueId();

	void AssertValid(void) const;

	NOTHROW const DBID & GetParentId(void) const;
	NOTHROW const CLocTypeId & GetTypeId(void) const;
	NOTHROW const CLocResId & GetResId(void) const;

	NOTHROW DBID & GetParentId(void);
	NOTHROW CLocTypeId & GetTypeId(void);
	NOTHROW CLocResId & GetResId(void);
	
	void GetDisplayableUniqueId(CPascalString &) const;	
	
	NOTHROW int operator==(const CLocUniqueId &) const;
	NOTHROW int operator!=(const CLocUniqueId &) const;
	
	const CLocUniqueId &operator=(const CLocUniqueId&);

	void SetParentId(const DBID&);

	NOTHROW void ClearId(void);
	NOTHROW BOOL IsNull();
	
	virtual ~CLocUniqueId();

protected:
	//
	//  Implementation functions.
	//
	NOTHROW BOOL IsEqualTo(const CLocUniqueId &) const;

private:
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocUniqueId(const CLocUniqueId &);
	void Serialize(CArchive &ar);

	DBID       m_dbid;
	CLocTypeId m_tid;
	CLocResId  m_rid;
	
	DEBUGONLY(static CCounter m_DisplayCounter);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uniqid.inl"
#endif

#endif // UNIQID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_globalid.h ===
//-----------------------------------------------------------------------------

//  

//  File: _globalid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__GLOBALID_H
#define ESPUTIL__GLOBALID_H

///////////////////////////////////////////////////////////////////////////////
//
// global id path object, represents a fully qualified path from the root of
// the project to a specified item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4275)
class LTAPIENTRY CGlobalIdPath : public CTypedPtrList < CPtrList, CGlobalId * >
{
public:
	int NOTHROW operator==(const CGlobalIdPath &) const;
	const CGlobalIdPath & operator = (const CGlobalIdPath& idPath);
	~CGlobalIdPath();

	void SetIdPath(const CLString &strFilePath, 
					const CLString &strResourcePath);

	void GetStrPath(CLString &strFilePath, CLString &strResourcePath) const;

	void NOTHROW DeleteContents();
};
#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_goto.h ===
//-----------------------------------------------------------------------------

//  

//  File: _goto.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(ESPUTIL__goto_h_INCLUDED)
#define ESPUTIL__goto_h_INCLUDED
 
class LTAPIENTRY CEspGotoFactory : public CRefCount
{
public:
	CEspGotoFactory() {};
	
	virtual CGoto * CreateGoto(const CLocation &) = 0;

private:
	CEspGotoFactory(const CEspGotoFactory &);
};



void LTAPIENTRY RegisterEspGotoFactory(CEspGotoFactory *);

#endif // ESPUTIL__goto_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_reporter.h ===
//-----------------------------------------------------------------------------

//  

//  File: _reporter.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__REPORTER_H
#define ESPUTIL__REPORTER_H


//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReporter : public CReporter
{
public:
	CNullReporter()	{};

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
};

		


#pragma warning (disable:4251)

class LTAPIENTRY CBufferReporter : public CReporter
{
public:
	CBufferReporter();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReporter();

	const CBufferReport & GetBufReport(void) const;

private:
	CBufferReport m_bufReport;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReporter : public CReporter
{
public:
	CMessageBoxReporter();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

private:
	CMessageBoxReport m_mbReport;
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReporter : public CReporter
{
public:
	CFileReporter();

	BOOL InitFileReporter(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReporter();

private:
	CFileReport m_fReport;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReporter : public CReporter
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
private:
	CStdOutReport m_stReport;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReporter : public CReporter
{
public:
	CRedirectReporter();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReporter *pReporter);
	
private:
	CRedirectReport m_rdReport;
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReporter : public CReporter
{
public:
	CActivateReporter(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	CActivateReport m_actReport;
};



//
//  Allows you to use a CReport as a CReporter.
class LTAPIENTRY CReportReporter : public CReporter
{
public:
	CReportReporter(CReport *);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto,
			CGotoHelp *pGotoHelp);
	virtual void Activate();
	virtual void Clear();
	virtual void SetConfidenceLevel(ConfidenceLevel);
	
	
private:
	CReport *m_pReport;
};


#pragma warning(default:4251)

//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReporter(COutputTabs::OutputTabs idx, CReporter *pReporter);
NOTHROW LTAPIENTRY CReporter * GetReporter(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReporters();

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_reporter.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_interface.h ===
//-----------------------------------------------------------------------------

//  

//  File: _interface.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


struct LOCRESOURCEFILEINFO
{
	CFile *pFile;						// Res32 file
	LangId idLang;						// Language of the file
};

typedef LOCRESOURCEFILEINFO *LPLOCRESOURCEFILEINFO;

struct SProjectInfo
{
	CLString m_strProjPath;
	LangId m_lSource;
	LangId m_lTarget;
};


	
DECLARE_INTERFACE_(ILocExtensionResource, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum ResourceEvent
	{
		reNewFile,
		reUserCancel,
		reMakeSrcResFailed		// RAID: LS42 bug 250 fixed by MikeL (Added)
	};
	
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ CReport *, const SProjectInfo &) PURE;

	STDMETHOD(Stop)(THIS_ CReport *) PURE;

	STDMETHOD(OnEvent)(THIS_ ResourceEvent event, const CLocVariant &var,
			CReport *pReporter) PURE;
	STDMETHOD(Analyze)(THIS_
			const LOCRESOURCEFILEINFO &SourceFileInfo,
			const LOCRESOURCEFILEINFO &pTargetFileInfo,
			const CDBIDArray &aDBID,
			CReport *pReporter,
			const CLString &strContext,
			BOOL &fModifiedTarget) PURE;

	STDMETHOD_(void, SetProjName)(const CLString & strProjName) PURE;
	STDMETHOD_(BOOL, InitReports)() PURE;
};

	
interface __declspec(uuid("{9F9D180F-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtensionResource;


interface ILocTransFields;


DECLARE_INTERFACE_(ILocExtensionTranslation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum TranslationEvent
	{
		teNewFile,
		teUserCancel,
	};
	
	enum StartLocation
	{
		slProjectTree,
		slTranslationWindow
	};

	STDMETHOD_(BOOL, IsReadOnly)() CONST_METHOD PURE;
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ StartLocation slStart,
			CReport *, const SProjectInfo &) PURE;
	
	STDMETHOD(Stop)(THIS_ CReport *) PURE;
	
	STDMETHOD(OnEvent)(THIS_ TranslationEvent event,
			const CLocVariant &var, CReport *pReport) PURE;

	STDMETHOD(ProcessRow)(THIS_ ILocTransFields *pITransFields,
			CReport *, const CLString &strContext) PURE;
};

interface __declspec(uuid("{C35F8B61-FE4D-11d0-A5A1-00C04FC2C6D8}"))
		ILocExtensionTranslation;



DECLARE_INTERFACE_(ILocTransFields, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum PreferredGoto
	{
		pgDefault,
		pgProjWindow,
		pgTransTable,
		pgVisEditor
	};
	
	//
	//  Properties
	STDMETHOD_(CGoto *, GetGoto)(PreferredGoto pg = pgDefault) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullItemName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullFileName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasString)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasBinary)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, IsStringLocked)() CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValues)(UINT, CPasStringArray &)
		CONST_METHOD PURE;
	
	//
	//  Data retrieval methods
	STDMETHOD_(void, GetUniqueID)(CLocUniqueId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTargetString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetPreviousSource)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetInstructions)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTermNote)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTextStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetBinaryStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetStringType)(CST::StringType &) CONST_METHOD PURE;
	STDMETHOD_(void, GetApprovalState)(CAS::ApprovalState &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTranslationOrigin)(CTO::TranslationOrigin &)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTgtLockedToSource)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetUserLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetAutoApproved)(CAA::AutoApproved & aa) CONST_METHOD PURE;
	STDMETHOD_(void, GetParserId)(ParserId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdatedBy)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdateTime)(COleDateTime &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetTargetBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetInstrAttn)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetConfidenceLevel)(LONG &) CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValue)(UINT, CPascalString &) CONST_METHOD PURE;

	//
	//  Danger!  Use these, and you can totally destroy user data
	//  MAKE SURE YOU KNOW WHAT YOU ARE DOING!
	STDMETHOD(BeginEdit)() PURE;
	STDMETHOD(EndEdit)(BOOL fCommit) PURE;

	//
	//  NOTE!  Set methods implement 'business logic' - changing an item may
	//  lead to several other changes - for example, changing the target
	//  string may change the localization status.
	STDMETHOD(SetCustomFieldValue)(const UINT, const CPascalString &) PURE;	
 	STDMETHOD(SetInstructions)(const CPascalString &) PURE;
 	STDMETHOD(SetTermNote)(const CPascalString &) PURE;
 	STDMETHOD(SetStringType)(const CST::StringType) PURE;

 	STDMETHOD(SetTranslationOrigin)(const CTO::TranslationOrigin) PURE;

 	STDMETHOD(SetTextStatus)(const CLS::LocStatus) PURE;
 	STDMETHOD(SetApprovalState)(const CAS::ApprovalState) PURE;
 	STDMETHOD(SetTargetString)(const CLocString &) PURE;
 	STDMETHOD(SetTgtLockedToSource)(BOOL) PURE;
 	STDMETHOD(SetUserLock)(BOOL) PURE;
 	STDMETHOD(SetAutoApproved)(const CAA::AutoApproved aa) PURE;
	STDMETHOD(SetInstrAttn)(BOOL) PURE;
	
 	STDMETHOD(RevertString)() PURE;

	STDMETHOD(SetTargetBinary)(const CLocBinary *) PURE;
 	STDMETHOD(SetBinaryStatus)(const CLS::LocStatus) PURE;

};


interface __declspec(uuid("{42C5D1E7-FE50-11d0-A5A1-00C04FC2C6D8}"))
		ILocTransFields;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_importo.h ===
//-----------------------------------------------------------------------------

//  

//  File: importo.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Class for Import Data Options
//
//  Owner: KenWal
//
//  Code Review Status: Not Reviewed
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__IMPORTO_H
#define ESPUTIL__IMPORTO_H


#pragma warning(disable : 4251)			// class 'bar' needs to have dll-
										//interface to be used by clients of
										//class 'Foo'
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocImportOptions : public CObject
{
public:

	CLocImportOptions();
	CLocImportOptions(const CLocImportOptions&);

	enum Option
	{
		coor_size = 0,
		allNonText,
		instructions,
		lockFlag,
		translockFlag,
		stringCategory,
		approvalStatus,
		custom1,
		custom2,
		custom3,
		custom4,
		custom5,
		custom6,
		termNote,
		parserOptions,
		copy,
		MAX_OPTION		//always last in the list
	};

	NOTHROW void Reset();
	NOTHROW BOOL HasOptionSet() const;
	NOTHROW BOOL GetOption(Option opt) const;
	NOTHROW void SetOption(Option opt, BOOL bEnable);

	const CStringArray &GetGroupNames(void) const;
	void AddGroupName(const CString &);
	
	NOTHROW CLocImportOptions& operator=(const CLocImportOptions&);

	virtual void AssertValid(void) const;

protected:
	BYTE m_storage[MAX_OPTION];
	CStringArray m_aOptionGroupNames;
};

struct LTAPIENTRY ImportCount
{
	ImportCount();
	
	ULONG ulResources;
	ULONG ulParserOptions;
	ULONG ulEspressoOptions;
	ULONG ulCustomFields;
};

#pragma warning(default : 4251)
#pragma warning(default: 4275)

#endif //ESPUTIL_IMPORTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_wtrmark.h ===
//-----------------------------------------------------------------------------

//  

//  File: _wtrmark.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


const int EWM_MAX_LENGTH = 512;		  // Watermarks should never be longer
                                      // than this	

static TCHAR g_cWMSep = _T('\t');

// All watermarks begin with this string
static TCHAR g_szWMLocString[] = _T("Localized");


//
// This class does not need to be exported as all implementations
// are inline
//
class CLocWMCommon
{
 public:
	CLocWMCommon(const CLString& strSource, const ParserId& pid, 
			const CLString& strParserVer);

	CLString m_strSource;		// Name of the source file
	ParserId m_pid;				// Parser using the watermark
	CLString m_strParserVer;  	// Version of the parser 
};

//
// struct defining the header of watermarks when encoded in binary file types
//
#include <pshpack1.h>

struct EWM_HEADER
{
	BYTE bVersion;	   	// Version of the binary data                            
	WORD wLength;		// Length of the string		
};

#include <poppack.h>

const BYTE EWM_ESP21_VERSION = 0;
const BYTE EWM_ESP30_VERSION = 1;
const BYTE EWM_DEFAULT_VERSION = 1;

//
// This function will retrieve the current date from the system and build the 
// common Espresso WaterMark. A Tab character separates elements of the 
// watermark.
//
void LTAPIENTRY ComposeWaterMark(const CLocWMCommon& wm, 
	CLString& strWaterMark);


//
// This function will encode the watermark into non-readable characters and 
// place the encoded string with the WM_HEADER in baOut.  
//
void LTAPIENTRY EncodeWaterMark(const CLString& strNormal, CByteArray& baOut);

void LTAPIENTRY EnCryptWaterMark(DWORD* pData, int nLength);


#include "_wtrmark.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_var.h ===
//-----------------------------------------------------------------------------

//  

//  File: var.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__VAR_H
#define ESPUTIL__VAR_H


//
// variant object, represents a VARIANT
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY  CVar : public CObject
{
public:
	CVar();
	CVar(const CVar&);
	CVar(VARIANT);
	CVar(const CPascalString&);
	CVar(PWSTR);
	CVar(PCWSTR);
	CVar(PSTR);
	CVar(PCSTR);
	CVar(SHORT);
	CVar(WCHAR);
	CVar(UINT);
	CVar(BOOL);
	CVar(BYTE);
	CVar(LONG);
	CVar(DATE);
	CVar(DWORD);
	CVar(tm*);			// build from a date in tm format
	~CVar();

	NOTHROW const CVar& operator = (const CVar &);
	NOTHROW const CVar& operator = (VARIANT);
	NOTHROW const CVar& operator = (const CPascalString&);
	NOTHROW const CVar& operator = (PWSTR);
	NOTHROW const CVar& operator = (PCWSTR);
	NOTHROW const CVar& operator = (PSTR);
	NOTHROW const CVar& operator = (PCSTR);
	NOTHROW const CVar& operator = (SHORT);
	NOTHROW const CVar& operator = (WCHAR);
	NOTHROW const CVar& operator = (UINT);
	NOTHROW const CVar& operator = (BOOL);
	NOTHROW const CVar& operator = (BYTE);
	NOTHROW const CVar& operator = (LONG);
	NOTHROW const CVar& operator = (DATE);
	NOTHROW const CVar& operator = (DWORD);

	NOTHROW operator COleVariant   (VOID) const;
	NOTHROW operator LPVARIANT     (VOID);
	NOTHROW operator CPascalString (VOID) const;
	NOTHROW operator SHORT         (VOID) const;
	NOTHROW operator WCHAR         (VOID) const;
	NOTHROW operator UINT          (VOID) const;
	NOTHROW operator BOOL          (VOID) const;
	NOTHROW operator BYTE          (VOID) const;
	NOTHROW operator LONG          (VOID) const;
	NOTHROW operator DATE          (VOID) const;
	NOTHROW operator DWORD         (VOID) const;
	NOTHROW operator PSTR          (VOID) const;
	NOTHROW operator PCSTR         (VOID) const;
	NOTHROW operator PWSTR         (VOID) const;
	NOTHROW operator PCWSTR        (VOID) const;

	void AnsiToWide();
	void WideToAnsi();

	void SetBSTR(BSTR);
	
	void SetStringByteLen(const char * sz, unsigned int ui);

	NOTHROW int GetLength();

	NOTHROW BOOL IsNull() const;
	NOTHROW VOID SetNull();
	NOTHROW VOID SetError();

	NOTHROW BOOL operator==(const CVar& v) const;
	NOTHROW BOOL operator!=(const CVar& v) const;

	//
	// debug routines
	//
	virtual void AssertValid() const;

private:
	VARIANT m_var;
};

#pragma warning(default: 4275)


#endif //ESPUTIL_VAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetNotes(void)
		const
{
	return m_bufReport.GetNotes();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetWarnings(void)
		const
{
	return m_bufReport.GetWarnings();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetErrors(void)
		const
{
	return m_bufReport.GetErrors();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetAborts(void)
		const
{
	return m_bufReport.GetAborts();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReporter.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetMessages(void)
		const
{
	return m_bufReport.GetMessages();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Returns the CBufferReport object.
//  
//-----------------------------------------------------------------------------
inline
const CBufferReport &
CBufferReporter::GetBufReport(void)
	const
{
	return m_bufReport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\esputil\_wtrmark.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _wtrmark.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

inline
CLocWMCommon::CLocWMCommon(
	const CLString& strSource, 
	const ParserId& pid, 
	const CLString& strParserVer)
{
	m_strSource = strSource;
	m_pid = pid;
	m_strParserVer = strParserVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\dbhelp.h ===
//******************************************************************************

//

//  DbHelp.h:  LocStudio LocUtil

//

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_DbHelp_h_INCLUDED)
#define ESPUTIL_DbHelp_h_INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY DbHelp
{
// Operations
public:
	static void GetSecFilePath(CLString & stPathName);
	static BOOL BuildSecFile(CLString & stSystemRegKey);
	static BOOL CreateSecurityFile();
	static BOOL SetupRegistry();

// Data
protected:
	static BOOL		m_fInit;
	static CLString m_stRegKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\cancel.h ===
//-----------------------------------------------------------------------------

//  

//  File: cancel.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_CANCEL_H
#define ESPUTIL_CANCEL_H



class CCancelDialog;

class LTAPIENTRY CCancelableObject : public CProgressiveObject
{
public:
	CCancelableObject(void);

	virtual void AssertValid(void) const;
	
	virtual BOOL fCancel(void) const = 0;

	virtual ~CCancelableObject();
};



#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cancel.inl"
#endif

#endif // ESPUTIL_CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\espopts.h ===
//-----------------------------------------------------------------------------

//  

//  File: espopts.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\dcsgrid.h ===
//------------------------------------------------------------------------------

//

// File: DcsGrid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//------------------------------------------------------------------------------
 
#if !defined(__DcsGrid_h__)
#define __DcsGrid_h__

namespace MitDisplayColumns
{
	interface IOption;
	interface IColumn;
};

//------------------------------------------------------------------------------
class LTAPIENTRY CDcsGrid
{
public:
	static int DisplayOrder(MitDisplayColumns::IOption * pdcOption, 
			long nColumnID, long nOffsetDO);
	static int DisplayOrder(MitDisplayColumns::IColumn * pdcColumn, 
			long nOffsetDO);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CCancelableObject::CCancelableObject(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\espreg.h ===
//-----------------------------------------------------------------------------

//  

//  File: espreg.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 

struct LocVersionInfo
{
	WORD    wVerMajor;
	WORD    wVerMinor;
	WORD    wVerBuild;
	CString strVerString;
};


LTAPIENTRY void NOTHROW GetVersionInfo(LocVersionInfo &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoUserSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoMachineSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW MyRegDeleteKey(HKEY &, const TCHAR *);

LTAPIENTRY void NOTHROW GetRegistryString(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\enumstringtype.h ===
//******************************************************************************

//

// EnumStringType.h: Common enum String Type definitions

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important - if must change it, make sure you make the
//  corresponding changes in GetTypeName() and GetTypeTLA()!
//  All new values must be added TO THE END, or you will break old
//  parsers...
//

BEGIN_ENUM(StringType)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Text)
	ENUM_ENTRY(gdo, Message)
	ENUM_ENTRY(gdo, ErrorMessage)
	ENUM_ENTRY(gdo, Comment)
	ENUM_ENTRY(gdo, StatusBarText)
	ENUM_ENTRY(gdo, ToolTipText)
	ENUM_ENTRY(gdo, KeyName)
	ENUM_ENTRY(gdo, ArgumentName)
	ENUM_ENTRY(gdo, FunctionName)
	ENUM_ENTRY(gdo, FolderName)
	ENUM_ENTRY(gdo, FontName)
	ENUM_ENTRY(gdo, StaticText)
	ENUM_ENTRY(gdo, DialogTitle)
	ENUM_ENTRY(gdo, TabControl)
	ENUM_ENTRY(gdo, GroupBoxTitle)
	ENUM_ENTRY(gdo, EditBox)
	ENUM_ENTRY(gdo, Button)
	ENUM_ENTRY(gdo, OptionButton)
	ENUM_ENTRY(gdo, CheckBox)
	ENUM_ENTRY(gdo, CustomControl)
	ENUM_ENTRY(gdo, TrackBar)
	ENUM_ENTRY(gdo, ProgressBar)
	ENUM_ENTRY(gdo, DriveLetter)
	ENUM_ENTRY(gdo, Folder)
	ENUM_ENTRY(gdo, MenuItem)
	ENUM_ENTRY(gdo, Accelerator)
	ENUM_ENTRY(gdo, Version)
	ENUM_ENTRY(gdo, Translation)
	ENUM_ENTRY(gdo, ListBox)
	ENUM_ENTRY(gdo, ScrollBar)
	ENUM_ENTRY(gdo, ComboBox)
	ENUM_ENTRY(gdo, RadioButton)
	ENUM_ENTRY(gdo, GroupBox)
	ENUM_ENTRY(gdo, General)
	ENUM_ENTRY(gdo, Unknown)
	ENUM_ENTRY(gdo, Keyword)
	ENUM_ENTRY(gdo, TopicTitle)
	ENUM_ENTRY(gdo, PageTitle)
	ENUM_ENTRY(gdo, Command)
	ENUM_ENTRY(gdo, Address)
	ENUM_ENTRY(gdo, AlternativeText)
	ENUM_ENTRY(gdo, HTMLText)
	ENUM_ENTRY(gdo, HTMLTitle)
	ENUM_ENTRY(gdo, JavaText)
	ENUM_ENTRY(gdo, Number)
	ENUM_ENTRY(gdo, PageInformation)
	ENUM_ENTRY(gdo, Style)
	ENUM_ENTRY(gdo, VBScriptText)
	ENUM_ENTRY(gdo, Property)
	ENUM_ENTRY(gdo, MacroAction)
	ENUM_ENTRY(gdo, FileName)
	ENUM_ENTRY(gdo, Billboards)
	ENUM_ENTRY(gdo, DialogItem)
	ENUM_ENTRY(gdo, Description)
	ENUM_ENTRY(gdo, FeatureTitle)
	ENUM_ENTRY(gdo, FeatureDescription)
	ENUM_ENTRY(gdo, INIFileName)
	ENUM_ENTRY(gdo, INIFileKey)
	ENUM_ENTRY(gdo, INIFileSection)
	ENUM_ENTRY(gdo, INIFileValue)
	ENUM_ENTRY(gdo, AppData)
	ENUM_ENTRY(gdo, RegistryValue)
	ENUM_ENTRY(gdo, ResourceData)
	ENUM_ENTRY(gdo, ShortcutDescription)
	ENUM_ENTRY(gdo, ShortcutName)
	ENUM_ENTRY(gdo, ShortcutHotKey)
	ENUM_ENTRY(gdo, ShortcutArgument)
	ENUM_ENTRY(gdo, Verb)
	ENUM_ENTRY(gdo, Argument)
	ENUM_ENTRY(gdo, ComponentID)
	ENUM_ENTRY(gdo, FileSize)
	ENUM_ENTRY(gdo, Fileversion)
	ENUM_ENTRY(gdo, FileLanguage)
	ENUM_ENTRY(gdo, Documentation)
END_ENUM(StringType)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\fieldval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: FieldVar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CColumnVal::CColumnVal()
{
	m_cvt = cvtNone;
}



inline
void
CColumnVal::SetString(
		const CPascalString &pas)
{
	m_cvt		= cvtString;
	m_pasString	= pas;
}



inline
void
CColumnVal::SetLong(
		long nValue)
{
	m_cvt	= cvtLong;
	m_long	= nValue;
}



inline
void
CColumnVal::SetDate(
		const COleDateTime &dt)
{
	m_cvt = cvtDate;
	m_Time = dt;
}



inline
void
CColumnVal::SetBool(
		BOOL b)
{
	m_cvt = cvtBool;

	m_bool = b;
}



inline
CColumnVal::CColumnVal(
		const CColumnVal &other)
{
	AssignFrom(other);
}



inline
CColumnVal::CColumnVal(
		const CPascalString &pas)
{
	SetString(pas);
}



inline
CColumnVal::CColumnVal(
		long nValue)
{
	SetLong(nValue);
}



inline
CColumnVal::CColumnVal(
		const COleDateTime &dt)
{
	SetDate(dt);
}



inline
CColumnVal::CColumnVal(
		BOOL b)
{
	SetBool(b);
}

		
		

inline
const CColumnVal &
CColumnVal::operator=(const CColumnVal &other)
{
	AssignFrom(other);
	
	return *this;
}



inline
void
CColumnVal::SetStringIndex(
		long idxValue)
{
	m_cvt	= cvtStringList;
	m_long	= idxValue;
}



inline
CColumnVal::ColumnValType
CColumnVal::GetType()
		const
{
	return m_cvt;
}



inline
const CPascalString &
CColumnVal::GetString()
		const
{
	LTASSERT(m_cvt == cvtString);
	return m_pasString;
}



inline
long
CColumnVal::GetLong()
		const
{
	LTASSERT(m_cvt == cvtLong);
	return m_long;
}



inline
const COleDateTime &
CColumnVal::GetDate()
		const
{
	LTASSERT(m_cvt == cvtDate);
	return m_Time;
}



inline
BOOL
CColumnVal::GetBool()
		const
{
	LTASSERT(m_cvt == cvtBool);
	return m_bool;
}



inline
long
CColumnVal::GetStringIndex()
		const
{
	LTASSERT(m_cvt == cvtStringList);
	return m_long;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\enumplatform.h ===
//******************************************************************************

//

// EnumPlatform.h: Common enum Platform definitions

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important: all new values must be added TO THE END, or you 
//  will break old parsers...
//

BEGIN_ENUM(Platform)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Windows)
	ENUM_ENTRY(gdo, WinNT)
	ENUM_ENTRY(gdo, Macintosh)
	ENUM_ENTRY(gdo, DOS)
	ENUM_ENTRY(gdo, Other)
	ENUM_ENTRY(gdo, All)
END_ENUM(Platform)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\extlist.h ===
//-----------------------------------------------------------------------------

//  

//  File: extlist.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Definition of an extension list.  Used by the parsers to tell the caller
//  what the parser is will to handle.
//  
//-----------------------------------------------------------------------------
 
#ifndef EXTLIST_H
#define EXTLIST_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLocExtensionList : public CStringList
{
public:
	CLocExtensionList();

	void AssertValid(void) const;
	
	//
	//  Conversion routines to/from CLString's.
	//
	void NOTHROW ConvertToCLString(CLString &) const;
	BOOL NOTHROW ConvertFromCLString(const CLString &);
	
	~CLocExtensionList();
private:
	
};

#pragma warning(default : 4275)

#endif // EXTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\espstate.h ===
//-----------------------------------------------------------------------------

//  

//  File: espstate.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


// *************************************************************************************************
// TEMPORARY: Move to seperate file

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CEspState : public CObject
{
// Construction
public:
	CEspState();

// Enums
public:
	enum eState
	{
		esIdle				= 0,
		esUpdate			= 1,
		esGenerate			= 2,
		esUpload			= 3,
		esCopyData			= 4,
		esImportData		= 5,
		esImportGlossary	= 7,
		esInternal			= 8,
		esMerge				= 9,
		esOther					= 10,
		esOpeningMainTab		= 11,
		esOpeningResEdTab		= 12,
		esSavingResEdChanges	= 13,
		esApplyingFilter		= 14,
		esOpeningEDB            = 15,
		NUM_STATES
	};

// Data
private:
	BOOL		m_fComplete;
	IDispatch * m_pdispCheckTree;
	IDispatch * m_pdispDescBox;
	IDispatch * m_pdispDlgGlosGrid;
	eState		m_nOperation;		// Current operation
	eState		m_nLastOperation;	// Previous operation

// Operations
public:
	eState GetState();
	eState GetLastState();
	BOOL SetState(eState state);
	BOOL StartState(eState state);  // Moves to state and not complete
	BOOL FinishState();				// Moves to idle and complete

	BOOL GetComplete();
	void SetComplete(BOOL fComplete = TRUE);

	// Functions to store the current CheckTree and DescBox.
	//
	// NOTE: These functions do not AddRef() the pointers assigned since they
	// should never hold onto the interface outside of the parent's lifetime.
	//
	IDispatch * GetCurrentCheckTree();
	IDispatch * GetCurrentDescBox();
	IDispatch * GetCurrentDlgGlosGrid();
	void SetCurrentCheckTree(IDispatch * pdisp);
	void SetCurrentDescBox(IDispatch * pdisp);
	void SetCurrentDlgGlosGrid(IDispatch * pdisp);
};


//
//  Sets a state on creation, calls FinishState on destruction
class LTAPIENTRY CEspStateObj
{
public:
	CEspStateObj(CEspState::eState);
	
	~CEspStateObj();

private:
	int foo;
};

	

#pragma warning(default: 4275)

LTAPIENTRY CEspState & GetEspState();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\fielddef.h ===
//******************************************************************************

//  

//  FieldDef.h:	Common Column Definitions

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//******************************************************************************
 
#pragma once

#pragma warning(disable:4275)  // Exported classes

//------------------------------------------------------------------------------
struct LTAPIENTRY COLUMN_STRING_ENTRY
{
// Construction
public:
	COLUMN_STRING_ENTRY();
	COLUMN_STRING_ENTRY(const COLUMN_STRING_ENTRY & entry);

// Data
public:
	CLString	st;				// Display String
	long		nID;			// User value (unique ID)

// Operations
public:
	const COLUMN_STRING_ENTRY & operator=(const COLUMN_STRING_ENTRY & entry);
};

typedef CArray<COLUMN_STRING_ENTRY, COLUMN_STRING_ENTRY&> CColStrEntryArray;

//------------------------------------------------------------------------------
class LTAPIENTRY CColumnStrList : public CLocThingList<COLUMN_STRING_ENTRY>
{
// Operations
public:
	BOOL FindDisplayName(long nID, CLString & stName) const;
	BOOL FindID(const CLString &stName,long &nID) const;
};

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added m_pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
class LTAPIENTRY CColumnDefinition : public CRefCount
{
public:
	CColumnDefinition(const WCHAR * pszInternalName, long nID,
			const CLString &strName, const CLString &strHelp,
			CColumnVal::ColumnValType vt, Operators ops,
			BOOL fDisplayable, BOOL fSortable, BOOL fReadOnly,
			PFNVALIDATE pfnValidateFunc);

	void SetStringList(const CColumnStrList & lstColumnStr);
	
	const CPascalString & GetInternalName() const;
	long GetID() const;
	const CLString & GetDisplayName() const;
	const CLString & GetHelpText() const;
	BOOL IsDisplayable() const;
	BOOL IsSortable() const;
	BOOL IsReadOnly() const;
	
	CColumnVal::ColumnValType GetColumnType() const;
	Operators GetOperators() const;

	const CColumnStrList & GetStringList() const; 

	BOOL Validate (LPCTSTR lpsz, DWORD dw) const;

	
private:
	CPascalString	m_pasInternalName;	// Unique String ID
	long		m_nID;				// Unique Number ID (can be any number)
	CLString	m_strDisplayName;	// Displayed name
	CLString	m_strHelpText;		// Description of column
	CColumnVal::ColumnValType m_vt;	// Type of data
	Operators	m_ops;				// Valid filtering operations
	BOOL		m_fDisplayable;		// Column is displayable
	BOOL		m_fSortable;		// Column is sortable
	BOOL		m_fReadOnly;		// Column is read-only
	PFNVALIDATE	m_pfnValidateFunc;	// Pointer to column value validation func

	CColumnStrList m_lstColumnStr;
};


//------------------------------------------------------------------------------
// CEnumIntoColStrList provides a method of enumerating directly into a list of
// COLUMN_STRING_ENTRY's.
//
class LTAPIENTRY CEnumIntoColStrList : public CEnumCallback
{
// Construction
public:
	CEnumIntoColStrList(CColumnStrList & lstColStr, BOOL fLock = TRUE);
	~CEnumIntoColStrList();

// CEnumCallback implementation
public:
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CColumnStrList & m_lstColStr;
	BOOL	m_fLock;				// Lock list when finished
};


//------------------------------------------------------------------------------
class LTAPIENTRY CColDefUtil
{
// Operations
public:
	static void FillBool(CButton * pbtn, BOOL fValue = TRUE);	
	static void FillBool(CListBox * plbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	
	static void FillBool(CComboBox * pcbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	

	static void FillStringList(CListBox * plbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);	
	static void FillStringList(CComboBox * pcbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);


	//------------------------------------------------------------------------------
	class LTAPIENTRY CColDefCB : public CObject
	{
	public:
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CCheckBoxCB : public CColDefCB
	{
	public:
		CCheckBoxCB(CButton * pbtn);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CButton * const m_pbtn;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CListBoxCB : public CColDefCB
	{
	public:
		CListBoxCB(CListBox * plbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CListBox * const m_plbc;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CComboBoxCB : public CColDefCB
	{
	public:
		CComboBoxCB(CComboBox * pcbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CComboBox * const m_pcbc;
	};
};

LTAPIENTRY int AddListBoxItem(CListBox * plbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddListBoxItem(CListBox * plbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);

LTAPIENTRY void GetBoolValue(BOOL fValue, CLString & stValue);

#pragma warning(default:4275)  // Exported classes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\fieldval.h ===
//-----------------------------------------------------------------------------

//  

//  File: FieldVal.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable : 4251)
class LTAPIENTRY CColumnVal
{
public:
	CColumnVal();
	explicit CColumnVal(const CColumnVal & val);
	explicit CColumnVal(const CPascalString & pasValue);
	explicit CColumnVal(long nValue);
	explicit CColumnVal(const COleDateTime & dateValue);
	explicit CColumnVal(BOOL fValue);
	
	enum ColumnValType
	{
		cvtNone,
		cvtString,
		cvtLong,
		cvtDate,
		cvtBool,
		cvtStringList,
		cvtLocTerm
	};

	void Serialize(CArchive &);
	
	const CColumnVal & operator=(const CColumnVal & val);
	void SetString(const CPascalString & pasValue);
	void SetLong(const long nValue);
	void SetDate(const COleDateTime & dateValue);
	void SetBool(const BOOL fValue);
	void SetStringIndex(const long nValue);
	
	ColumnValType GetType() const;
	const CPascalString &GetString() const;
	long GetLong() const;
	const COleDateTime & GetDate() const;
	BOOL GetBool() const;
	long GetStringIndex() const;
	
	int operator==(const CColumnVal &);
	int operator!=(const CColumnVal &);
	
#ifdef LTASSERT_ACTIVE
	void AssertValid(void) const;
#endif
	
private:
	BOOL Compare(const CColumnVal & valCompare);
	void AssignFrom(const CColumnVal & valSrc);
	
	ColumnValType m_cvt;
	
	union
	{
		long m_long;
		BOOL m_bool;
	};
	CPascalString m_pasString;
	COleDateTime m_Time;
};

typedef CColumnVal CCV;

#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "FieldVal.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\fileexcldlg.h ===
//-----------------------------------------------------------------------------

//

// File: FileExclDlg.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//-----------------------------------------------------------------------------
#if !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
#define AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_

#pragma warning(disable : 4275)
#pragma warning(disable : 4251)


class LTAPIENTRY CLFileExclDlg : public CLFileDialog
{
	DECLARE_DYNAMIC(CLFileExclDlg)

public:
	CLFileExclDlg(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);


	BOOL GetExclusivePref( ) const;

// Dialog Data
	//{{AFX_DATA(CLFileExclDlg)
	BOOL m_bExclusive;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLFileExclDlg)
    public:
    virtual int DoModal();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CLFileExclDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
    virtual BOOL OnInitDialog();
	afx_msg void OnClickChkExcl();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#pragma warning(default : 4275)
#pragma warning(default : 4251)


#endif // !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\goto.h ===
//-----------------------------------------------------------------------------

//  

//  File: goto.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class LTAPIENTRY CGoto : public CRefCount
{
public:
	CGoto()	{};
	
	virtual void Edit() = 0;
	virtual BOOL Go() = 0;


private:
	CGoto(const CGoto &);
	
};

#pragma warning(disable:4251)

class LTAPIENTRY CShellGoto : public CGoto
{
public:
	CShellGoto(const TCHAR *szFileName);

	virtual void Edit();
	virtual BOOL Go();

private:

	CLString m_strFileName;
};

#pragma warning(default:4251)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\flddeflist.h ===
//-----------------------------------------------------------------------------

//  

//  File: flddeflist.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CColumnDefinition;

//------------------------------------------------------------------------------
class LTAPIENTRY CColDefList : public CTypedPtrList<CPtrList, CColumnDefinition *>
{
// Construction
public:
	CColDefList();
	CColDefList(const CColDefList &);
	
	~CColDefList();

// Operations
public:
	BOOL FindColumnDefinition(long nSearchID, const CColumnDefinition * & pFoundColDef) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

#pragma warning(default : 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\filedlg.h ===
//-----------------------------------------------------------------------------

//

// File: FileDlg.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//-----------------------------------------------------------------------------
 
#if !defined(__FileDlg_h__)
#define __FileDlg_h__

#pragma warning(disable : 4275)

class LTAPIENTRY CLFileDialog : public CFileDialog
{
	DECLARE_DYNAMIC(CLFileDialog)

public:
	CLFileDialog(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);

// Operations
public:
	CString GetFileFilter();

	virtual int DoModal();

// Attributes
public:
	virtual void SetOkButtonText(TCHAR const * const szOkText);
	virtual void SetOkButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCancelButtonText(TCHAR const * const szCancelText);
	virtual void SetCancelButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCheckIfBufferTooSmall(BOOL const bCheckIfBufferTooSmall);

// Data
protected:
	CLString m_strOkButton;				// new OK button text for dialog
	CLString m_strCancelButton;			// new Cancel button text for dialog
	BOOL m_bCheckIfBufferTooSmall;		// should DoModal() checks condition?

// Implementation
protected:
	//{{AFX_MSG(CProjectOpenDlg)
    virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Implementation
protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT * pResult);
};

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\globals.h ===
//-----------------------------------------------------------------------------

//  

//  File: globals.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#include "resource.h"
 
extern HINSTANCE g_hLocUtilDll;

void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\flddefhelp.h ===
//-----------------------------------------------------------------------------

//  

//  File: flddefhelp.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
struct SBasicColumn
{
	const WCHAR *szInternalName;
	long nID;
	UINT IDSName;
	UINT IDSHelp;
	CColumnVal::ColumnValType vt;
	Operators ops;
	BOOL fDisplay;
	BOOL fSort;
	BOOL fReadOnly;
	PFNVALIDATE pfnValidateFunc;
};


struct SStringListColumn
{
	SBasicColumn sBasic;
	UINT IDSStringList;
};


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CColDefHelper : public CObject
{
public:
	CColDefHelper(HINSTANCE h);

	void SetBasicColumns(const SBasicColumn * pBasic, UINT nCntBasic);
	void SetStringColumns(const SStringListColumn * pStrings, UINT nCntStrings);
	
	CTableSchema * CreateSchema(const SchemaId &, UINT IDSDescription);
	
private:
	HINSTANCE				 m_hInst;
	const SBasicColumn *	 m_pBasicColumns;
	const SStringListColumn *m_pStringColumns;
	UINT					 m_uiBasicCount;
	UINT					 m_uiStringCount;
};


#pragma warning(default : 4275)

const TCHAR COL_PICK_SEPARATOR = _T('\n');

#define BEGIN_BASIC_COLUMN_DEFS(var) \
const SBasicColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define BASIC_COLUMN_DEF_ENTRY(name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc) \
	{name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc}

#define END_BASIC_COLUMN_DEFS() \
}

#define BEGIN_STRING_LIST_COLUMN_DEFS(var) \
const SStringListColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define STRING_LIST_COLUMN_ENTRY(name, nID, IDSName, IDSHelp, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc, IDSList) \
	{ { name, nID, IDSName, IDSHelp, CColumnVal::cvtStringList, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc }, IDSList}

#define END_STRING_LIST_COLUMN_DEFS() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\interface.h ===
//-----------------------------------------------------------------------------

//  

//  File: interface.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\gotohelp.h ===
//-----------------------------------------------------------------------------

//  

//  File: gotohelp.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTAPIENTRY CGotoHelp : public CRefCount
{
public:
	virtual void Edit() = 0;
	
	virtual BOOL GotoHelp() = 0;
	
};



class LTAPIENTRY CEspGotoHelp : public CGotoHelp
{
public:
	explicit CEspGotoHelp(UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	UINT m_uiHelpId;
};


class LTAPIENTRY CExternalGotoHelp : public CGotoHelp
{
public:
	CExternalGotoHelp(const TCHAR *szFileName, UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	CLString m_strFileName;
	UINT m_uiHelpId;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\locobj.h ===
//-----------------------------------------------------------------------------

//  

//  File: locobj.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Defines the mother of all classes for the Espresso 2.0 project.  For now,
//  this just devolved to CObject.  We define it just in case we decide to
//  implement our own mother of all classes.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCOBJ_H
#define LOCOBJ_H


//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CObject is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CLObject : public CObject
{
public:
	CLObject();

	virtual void AssertValid(void) const;

	virtual void Serialize(CArchive &ar);

	virtual UINT GetSchema(void) const;
	
	virtual ~CLObject();

protected:

private:
};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locobj.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\locobj.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locobj.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Mother object constructor.  Does nothing, since for now we rely on
//  AFX CObject to do the work for us.
//  
//-----------------------------------------------------------------------------
inline
CLObject::CLObject()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\locenum.h ===
//-----------------------------------------------------------------------------

//  

//  File: locenum.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//------------------------------------------------------------------------------
class LTAPIENTRY CStringType
{
public:
	//
	//  This order is important - if must change it, make sure you make the
	//  corresponding changes in GetTypeName() and GetTypeTLA()!
	//  All new values must be added TO THE END, or you will break old
	//  parsers...
	//
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumStringType.h"
	
	static int DefaultValue;
	NOTHROW static const TCHAR * GetTypeName(CStringType::StringType);
	NOTHROW static const TCHAR * GetTypeTLA(CStringType::StringType);
	static void Enumerate(CEnumCallback &);
	static const CStringType::StringType GetStringType(const TCHAR * tChIn);
	static const TCHAR * GetDefaultStringTypeText();
	static const CStringType::StringType GetDefaultStringType();
	static bool IsValidStringType(const CStringType::StringType &nIn);
	static bool IsValidStringType(const TCHAR * tChIn);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CStringType();

	//
	//  Used to store the info about each element in the enum...
	//
	struct StringTypeInfo
	{
		TCHAR szTLA[4];
		const TCHAR * szName;
	};

	static const StringTypeInfo m_Info[];
};

typedef CStringType CST;


//------------------------------------------------------------------------------
class LTAPIENTRY CPlatform
{
public:
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumPlatform.h"
	
	NOTHROW static const TCHAR * GetPlatformName(CPlatform::Platform);
	static void Enumerate(CEnumCallback &);
	static const CPlatform::Platform CPlatform::GetPlatformType(const TCHAR * tChplat);
	static const TCHAR * GetDefaultPlatformText();
	static const CPlatform::Platform GetDefaultPlatform();
	static bool IsValidPlatform(const CPlatform::Platform &nIn);
	static bool IsValidPlatform(const TCHAR * tChplat);
	
private:
	static int DefaultValue;
	COSPlatform();
	static const TCHAR * const m_szPlatformNames[];
};


//------------------------------------------------------------------------------
class LTAPIENTRY CLocApprovalState
{
public:
	enum ApprovalState
	{
		Invalid = 0,
		Old_Pending,					// OBSOLETE! Do Not Use!
		Approved,
		PreApproved,
		NotReady,
		Failed,
		ForResearch,
		NotApplicable
	};
	static ApprovalState DefaultValue;
	NOTHROW static const TCHAR * GetApprovalText(CLocApprovalState::ApprovalState);
	static void Enumerate(CEnumCallback &);
	static const CLocApprovalState::ApprovalState GetApprovalState(const TCHAR * );
	static const TCHAR * GetDefaultApprovalText();
	static const CLocApprovalState::ApprovalState GetDefaultApprovalState();
	static BOOL IsValidApprovalState(const CLocApprovalState::ApprovalState &nIn);
	static BOOL IsValidApprovalState(const TCHAR * );
	
private:
	struct SStateName
	{
		ApprovalState as;
		const TCHAR *szName;
	};
	
	static const SStateName m_aStateNames[];
	CLocApprovalState();
};

typedef CLocApprovalState CAS;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocAutoApproved
{
// Operations
public:
	enum AutoApproved
	{
		Invalid = 0,
		No,
		Partial,
		Yes,
		NotApplicable
	};

	NOTHROW static TCHAR const * GetAutoApprovedText(AutoApproved const aa);
	static void Enumerate(CEnumCallback & cbEnumCallback);
	static AutoApproved const GetAutoApproved(TCHAR const * const tChIn);
	static TCHAR const * GetDefaultAutoApprovedText();
	static AutoApproved const GetDefaultAutoApproved();
	static bool IsValidAutoApproved(AutoApproved const nIn);
	static bool IsValidAutoApproved(TCHAR const * tChIn);
	
// Construction
private:
	// prevent constructing, copying and assigning
	CLocAutoApproved();
	CLocAutoApproved(CLocAutoApproved const &);
	CLocAutoApproved const & operator=(CLocAutoApproved const &);

// Member Variables
private:
	static TCHAR const * const m_szAutoApprovedNames[];
	static AutoApproved const DefaultValue;
};

typedef CLocAutoApproved CAA;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocTranslationOrigin
{
public:
	enum TranslationOrigin
	{
		Invalid = 0,
		New,
		Uploaded,
		AutoTranslated,
		Copied,
		PreviousVersion,
		NotApplicable
	};

	NOTHROW static const TCHAR * GetOriginText(CLocTranslationOrigin::TranslationOrigin);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szOriginNames[];
	CLocTranslationOrigin();
};

typedef CLocTranslationOrigin CTO;

class LTAPIENTRY COutputTabs
{
public:
	enum OutputTabs
	{
		File,
		Test,
		Messages,
		Update,
		Utility,
		GlobalErrorBox,
		OutputMax
	};

	static void Enumerate(CEnumCallback &);
	
private:
	static const UINT m_nStateNames[];
	COutputTabs();
};



class LTAPIENTRY CValidationCode
{
public:
	enum ValidationCode
	{
		NotHandled,			// for sub-parser use ONLY
		NoError,
		Warning,
		Error
	};

	NOTHROW static ValidationCode UpgradeValue(ValidationCode OldValue,
			ValidationCode NewValue);
	
private:
	CValidationCode();
};

typedef CValidationCode CVC;


//------------------------------------------------------------------------------
class LTAPIENTRY CValidationOptions
{
public:
	CValidationOptions();
	
	enum ValidationOption
	{
		CheckDBCSHotKeyPos = 0,
		CheckDBCSHotKeyChar,
		CheckRemovedHotKey,
		CheckAddedHotKey,
		CheckHotKeyPosition,
		CheckRemovedAccelerator,
		CheckReorderableParams,
		CheckPrintf,
		CheckBlankTarget,
		CheckBlankSource,
		CheckNewLineCount,
		CheckChangedTerminator,
		CheckLeadingPunctuation,
		CheckTrailingPunctuation,
		CheckLeadingSpaces,
		CheckTrailingSpaces,
		CheckTranslationSize,
		CheckNULChanges,
		CheckCharsInCodePage,
		//
		//  Internal value, DO NOT USE
		//
		END_MARKER
	};

	static void Enumerate(CEnumCallback &);
	NOTHROW static void GetText(ValidationOption, CLString &);
	NOTHROW static void GetLongText(ValidationOption vo, CLString &strText);

	NOTHROW void SetFlag(ValidationOption, BOOL);
	NOTHROW BOOL GetFlag(ValidationOption) const;
	NOTHROW const CValidationOptions & operator=(const CValidationOptions &);
	
private:
	DWORD dwFlags;
};

typedef CValidationOptions CVO;


//------------------------------------------------------------------------------
class LTAPIENTRY CAmpKeyword
{
public:
	enum AmpKeyword
	{
		amp = 0,
		lt,
		gt,
	};
	
	static const WCHAR * GetValue(CAmpKeyword::AmpKeyword);
	static unsigned int GetValueLength(CAmpKeyword::AmpKeyword);
	static WCHAR GetEquivalentChar(CAmpKeyword::AmpKeyword);
	static int FindAmpKeyword(const WCHAR * pwszStr, unsigned int nPos);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CAmpKeyword();

	//
	//  Used to store the info about each element in the enum...
	//
	struct SAmpKeyword
	{
		const WCHAR * m_wszValue;
		WCHAR m_chEquivalentChar;
	};

	static const SAmpKeyword m_aAmpKeywords[];
	static const int m_nNumAmpKeywords;
};

typedef CAmpKeyword CAK;


//------------------------------------------------------------------------------
// CEnumIntoPasStrList provides a method of enumerating directly into a list of
// CPascalString's.
//
// ASSUMPTIONS:
// 1.  Enumerators will send data in proper increasing order
// 2.  No gaps in indicies.
//
class LTAPIENTRY CEnumIntoPasStrList: public CEnumCallback
{
// Construction
public:
	CEnumIntoPasStrList(CPasStringList & lstPasStr, BOOL fLock = TRUE);
	~CEnumIntoPasStrList();

// CEnumCallback implementation
public:
	virtual void SetRange(UINT nStart, UINT nFinish);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CPasStringList & m_lstPasStr;
	UINT	m_nStart;				// Start of range
	UINT	m_nFinish;				// End of range
	UINT	m_nCurrent;				// Check of current item TO retrieve
	BOOL	m_fLock;				// Lock list when finished
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\locstr.h ===
//-----------------------------------------------------------------------------

//  

//  File: locstr.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Definition of a localizable string.  The following classes are defined:
//      CLocString - all the operations we can do on a localizable string.
//  
//-----------------------------------------------------------------------------
 

#ifndef LOCSTR_H
#define LOCSTR_H


interface ILocStringValidation;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocString : public CObject
{
public:
	NOTHROW CLocString();

	void AssertValid(void) const;
	
	//
	//  Information about the localizable string...
	//
	NOTHROW BOOL HasHotKey(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	
	NOTHROW int operator==(const CLocString &) const;
	NOTHROW int operator!=(const CLocString &) const;
	//
	//  Some useful assigment operators.
	//
 	NOTHROW void SetString(const CPascalString&);
	NOTHROW void SetHotKeyChar(WCHAR);
	NOTHROW void SetHotKeyPos(UINT);
	NOTHROW void ClearHotKey(void);
	NOTHROW void SetNote(const CPascalString &);
	
	// Conversion from/to Windows hot key strings
	// This is also the format used to display strings in edit mode
	NOTHROW int ParseString(const CPascalString & pasStr, WORD langId);
	NOTHROW void ComposeString(CPascalString & pasStr, WORD langId) const;


	NOTHROW CST::StringType GetStringType(void) const;
	NOTHROW CodePageType GetCodePageType(void) const;
	NOTHROW void SetStringType(CST::StringType);
	NOTHROW void SetCodePageType(CodePageType);


	// Conversion from/to displayable string in the resource table.
	void GetDisplayLString(CLString &strDest, LangId langId);
	void GetDisplayPString(CPascalString &strDest, LangId langId, BOOL bReplaceMetaCharacters);
	void GetEditableString(CLString &strDest, LangId langId);
	int ParseEditableString(const CLString &strSrc, LangId langId, CString &strErr);
	int ParseEscapeChar(BOOL bSetHotkeyPos, CPascalString &strErr);
	int ParseAmpersand(LangId langId,BOOL bSetHotkeyPos,CPascalString &strErr);
	
	NOTHROW const CLocString& operator=(const CLocString&);
	
	NOTHROW ~CLocString();

protected:

private:

	//
	//  Private implementation functions.
	//
	NOTHROW void CopyLocString(const CLocString &);
	virtual void Serialize(CArchive &) {}
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocString(const CLocString&);

	CPascalString m_pasBaseString;
	CST::StringType m_stStringType;
	WCHAR m_wchHotKeyChar;
	UINT m_uiHotKeyPos;
	CodePageType m_cptCodePageType;		 //  cpAnsi
	CPascalString m_pstrNote;
};



class LTAPIENTRY CLocTranslation : public CObject
{
public:
	CLocTranslation();
	CLocTranslation(const CLocTranslation &);
	CLocTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);

	NOTHROW int operator==(const CLocTranslation &) const;
	NOTHROW int operator!=(const CLocTranslation &) const;

	void AssertValid(void) const;

	NOTHROW void SetTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);
	NOTHROW void SetNote(const CPascalString &);
	NOTHROW void CalculateRanking(const CLocString &);
	
	NOTHROW const CLocString & GetSourceString(void) const;
	NOTHROW const CLocString & GetTargetString(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW UINT GetRanking(void) const;
	NOTHROW LangId GetSourceLanguage(void) const;
	NOTHROW LangId GetTargetLanguage(void) const;
	
	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &) const;

	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &, BOOL,
			const CLString &, CReport *, CGoto *) const;
	
	NOTHROW const CLocTranslation & operator=(const CLocTranslation &);
	
	~CLocTranslation();

private:
	NOTHROW void CopyTranslation(const CLocTranslation &);

	NOTHROW void ReordBuildSig(const CLocString &, CPascalString *) const;
	NOTHROW void PrintfBuildSig(const CLocString &, CPascalString &) const;
	NOTHROW int ReplaceableLength(const CPascalString &, UINT) const;
	
	CLocString      m_lsSource;
	LangId          m_lidSource;
	CLocString      m_lsTarget;
	LangId          m_lidTarget;
	CPascalString   m_pstrGlossaryNote;
	UINT            m_uiRanking;
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locstr.inl"
#endif


#endif //LOCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\locpct.h ===
//-----------------------------------------------------------------------------

//  

//  File: LOCPCT.H

//  

//  Declarations for CLocPercentFrame and CLocPercentHelper

//

//  Author:  kenwal

//

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL__LocPct_H__INCLUDED
#define LOCUTIL__LocPct_H__INCLUDED

// Classes in this header file
class CLocPercentHelper;
class CLocPercentFrame;

//
// The CLocPercentHelper class can help in building acurate
// percentage complete messages for complicated processes.
//
// Here is how the CLocPercentHelper works.
//
// The CLocPercentHelper class deals with "frames" of work.  Each frame
// is 100% of a unit of work.  A CLocPercentHelper will always
// start off with 1 frame.  If you want to use these functions
// you first need to call PercentSetUnits passing a number that will
// represent 100% complete.  For example if you need to process 4 items
// you could set this to 4.  After you process each item you would
// call PercentAddValue.  Correct status messages would be sent
// indicating you are 1/4, 2/4, 3/4, and 4/4 done.

// This processing comes in handy when you break up the work
// in sub functions, or "frames" of work.  Each function only 
// knows about what it needs to do.  

// Say in the resource example you call a function to handle each
// resource.  Each time the handler is called it is given 1/4 
// of the total time.  The handler can break up its time however 
// it likes without knowing how much total time there is.  

// Say the sub function needs to do 10 things.  It calls PercentSetUnits(10).
// It then calls PercentAddValue as each of the 10 things are
// accomplished.  The total percent will reflect that 100% of this
// sub function is really only 1/4 of the total percent.  The sub function
// only needs to worry about what it knows it has to do.  
// The sub function can assign part of its work to other functions
// by creating frames for them.  There is no limit to the number
// of frames.
// 

// Override the virtual function void OnSendPercentage(UINT nPct) 
// in your subclass of CLocPercentHelper to do what you want
// with the percent calculated from the helper.

// Example:

/*

	CLocPercentHelper pctHelp;
	pctHelp.PercentSetUnits(4); //assume 4 items to process
	
	do
	{
		pctHelp.PercentPushFrame(1); //Set up a new Frame equal
		                             //to 1 of my units of work.
									 //In this case 1/4 of the
									 //total time.
									 
									 //All of the Percent... functions
									 //called made now deal with
									 //this new frame.
		
		HandleItem(pctHelp);
		
		pctHelp.PersentPopFrame();	 //Remove the frame created
		                             //and mark the amount 
									 //of time it was equal to
									 //completed.
									 
	  
	}
	while (more items)
	  
-----------------------------------------------------------------------

  HandleItem(CLocPercentHelper& pctHelp) function
  
	pctHelp.PercentSetUnits(10);  //Assume this is a dialog resource
	                              //with 10 controls.  
								  //This function divides up 
								  //the work it needs to do in
								  //a way that makes sence for it.
								  //
								  //When this "frame" is at 100%
								  //the total percentage is still
								  //just 1/4 of the total time
								  //since this frame was given 1/4
								  //of the total time from the caller.
								  
  
	do
	{
					
		// This function can assign part of its processing 
		// to another function by calling PercentPushFrame also.
		
		HandleControl();
		pctHelp.PercentAddValue();	//Send a message to the 
		                            //handler indicating the 
									//current percentage.
									//The object will calculate
									//the total percent based on 
									//the current stack of frames.
	}
	
	while (more controls)  
		
		  
			
*/



//
// CLocPercentFrame represents a working unit of progress.  
// The progress model implemented with the CLocPercentHelper will
// support unlimited levels of work units.  
//
// This class is a helper class used only by CLocPercentHelper
//


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocPercentFrame : public CObject
{
	friend CLocPercentHelper;

protected:
	CLocPercentFrame();
	CLocPercentFrame(CLocPercentFrame* pParent, UINT nValueInParent);
	
	void SetComplete();
	// Force this frame to represent 100%. 
	
	void AddValue(UINT nValue);
	// Add nValue to the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetValue(UINT nValue);
	// Set the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetUnits(UINT nUnits);
	// Set the internal units
	
	UINT m_nUnits;			     //Number that represents 100%
	UINT m_nValue;          	 //Number that represent how far done
	                             //this frame is.
	
	CLocPercentFrame* m_pParent;	 //Pointer to the parent frame
	UINT m_nValueInParent;       //How much this frame is worth
	                             //in the parents context.
	
	void MemberInit();			 
	// Initialize member values 
};

//
// List of frames in the helper
//

class LTAPIENTRY CLocPercentFrameList : public CTypedPtrList<CPtrList, CLocPercentFrame*>
{
};


class LTAPIENTRY CLocPercentHelper : public CObject
{
public:
	
	CLocPercentHelper();

	virtual ~CLocPercentHelper();
	
	void PercentSetUnits(UINT nUnits, BOOL bReport = FALSE);
	// Set the units of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentSetValue(UINT nValue, BOOL bReport = TRUE);
	// Set the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentAddValue(UINT nValue = 1, BOOL bReport = TRUE);
	// Add nValue to the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetComplete(BOOL bReport = TRUE);
	// Set the current frame complete.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentForceAllComplete(BOOL bReport = TRUE);
	// Force all frames complete.
	// Calculate and report 100% done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentPushFrame(UINT nValueInParent = 1);
	// Create a new frame and assign in nValueInParent 
	// All Percent... calls made after this call deal with
	// the new frame.  
	
	void PercentPopFrame(BOOL bReport = TRUE);
	// Set the current frame complete and add the current
	// frames valueInParent to its parent frame. 
	// The current frames parent is now the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetStrict(BOOL bOnOff = TRUE);
	// Strict behavior means the helper will ASSERT (_DEBUG only) if 
	// the calculated percent is over 100%.  This can happen
	// if the unit values assigned to frames are not truly what 
	// the process does.  If you are unable to set acurate
	// unit values and the program quesses, you can turn
	// strict off.
	
	BOOL PercentIsStrict();
	// Return TRUE or FALSE if strict is on.
	
protected:

	// Support for Progress Reporting
	CLocPercentFrame m_FrameMain;	        //The main frame always 
	                                    //present.  This frame
	                                    //will never have a parent.
	
	CLocPercentFrameList m_FrameList;      //List of open frames.
	
	CLocPercentFrame* m_pCurrentFrame;     //Pointer to the current
	                                    //frame
	
	BOOL m_bStrict;						//Strict on will ASSERT if 
										//total % gets over 100
	
	
	void SendPercentage();
	// Calculates the percentage based on the current frame
	// Calles OnSendPercentage with the calulated value.
	
	void SafeDeleteFrame(CLocPercentFrame* pFrame);
	// Safely deletes a frame making sure the pFrame is 
	// not m_FrameMain.
	
	virtual void OnSendPercentage(UINT nPct);
	// Callback function for subclasses to do what they
	// want with the percentage.  Default implementation
	// does nothing.
 	
};

#pragma warning(default: 4275)

//
// Helper class with a CProgressiveObject
//
class LTAPIENTRY CLocPctProgress : public CLocPercentHelper
{
public:
	CLocPctProgress();
	CLocPctProgress(CProgressiveObject* pProgObj);

	void SetProgressiveObject(CProgressiveObject* pProgObj);

protected:
	virtual void OnSendPercentage(UINT nPct);

	CProgressiveObject* m_pProgObj;
};

#endif // LOCUTIL__LocPct_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\logfile.h ===
//-----------------------------------------------------------------------------

//  

//  File: logfile.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_LOGFILE_H
#define LOCUTIL_LOGFILE_H


class LTAPIENTRY CLogFile
{
public:
	CLogFile();
	
	virtual void IssueMessage(const CLString &strFileName, const CLString &strItemId,
			const CLString  &strChange, UINT uiChangeId,
			const CLString &strDetails, CGoto *, CGotoHelp *) = 0;
	
	virtual ~CLogFile();
	

private:
	CLogFile(const CLogFile &);
	const CLogFile &operator=(const CLogFile &);
};



CLString LTAPIENTRY GetLogFileName(const TCHAR *szProjectPath,
		const TCHAR *szAddOn, const TCHAR *szExtension);

#include "logfile.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocString object.  This file is included by
//  locstr.h, and should never be used directly.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return the 'generic' type of the string.  
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocString::GetStringType(void)
		const
{
	if (!m_pasBaseString.IsNull())
	{
		return m_stStringType;
	}
	else
	{
		return CST::None;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'Base' string.  This is the localizable string, 
//  It is the part that weighs most heavily in auto-translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetString(void)
		const
{
	return m_pasBaseString;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
CodePageType
CLocString::GetCodePageType(void)
		const
{
	return m_cptCodePageType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetNote(void)
		const
{
	return m_pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the string type.  The parser and database are the only people who
//  should be setting this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetStringType(
		CST::StringType newType)
{ 
	m_stStringType = newType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the 'Base' string.
//
//  This method can throw the following exceptions:
//      CMemoryException
//
//-----------------------------------------------------------------------------
inline
void
CLocString::SetString(
		const CPascalString &pstrNewBaseString)
{
	m_pasBaseString = pstrNewBaseString;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetCodePageType(
		CodePageType cptNew)
{
	m_cptCodePageType = cptNew;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears out the hot-key to an uninitialized state.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::ClearHotKey(void)
{
	m_wchHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  See if the hotkey has any info in it.  Checks to see if the hotkey is
//  a valid character (ie non-zero).
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if it contains a hotkey
CLocString::HasHotKey(void)
		const
{
	return (m_wchHotKeyChar != L'\0');
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character.  If the hot-key is not initialized, this
//  returns NUL.
//  
//-----------------------------------------------------------------------------
inline
WCHAR									// Hot key character.
CLocString::GetHotKeyChar(void)
		const
{
	return m_wchHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key position.  Interpretationb of the position is left up
//  to the caller.  If the hot-key is uninitialized, this returns 0.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Position of the hot key.
CLocString::GetHotKeyPos(void)
		const
{
	return m_uiHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the hot-key character
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyChar(
		WCHAR wchNewHotKeyChar)			// Character to set as hot key.
{
	m_wchHotKeyChar = wchNewHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the position of the hot-key
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyPos(
		UINT uiNewHotKeyPos)			// Position for the hot-key.
{
	m_uiHotKeyPos = uiNewHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for LocStrings.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocString::operator=(
		const CLocString &lsSource)
{
	CopyLocString(lsSource);

	return *this;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator==(
		const CLocString &lsOtherString) // String to compare
		const
{
	return ((((HasHotKey() && lsOtherString.HasHotKey()) &&
			(GetHotKeyChar() == lsOtherString.GetHotKeyChar()) &&
			(GetHotKeyPos() == lsOtherString.GetHotKeyPos())) ||
			(!HasHotKey() && !lsOtherString.HasHotKey())) &&
			m_pasBaseString == lsOtherString.m_pasBaseString);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator!=(
		const CLocString &lsOtherString) // String to compare
		const
{
	return !(operator==(lsOtherString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the Translation Object.  Just sets the components to
//  default bad values.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation()
{
	m_lidSource = BAD_LOCALE;
	m_lidTarget = BAD_LOCALE;
	m_uiRanking = 0;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for copying a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::CopyTranslation(
		const CLocTranslation &Source)
{
	m_lsSource = Source.m_lsSource;
	m_lidSource = Source.m_lidSource;
	m_lsTarget = Source.m_lsTarget;
	m_lidTarget = Source.m_lidTarget;
	m_pstrGlossaryNote = Source.m_pstrGlossaryNote;
	m_uiRanking = Source.m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for a CLocTranslation
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocTranslation &Source)
{
	CopyTranslation(Source);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets all the required components of a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	m_lsSource = Source;
	m_lidSource = lidSource;
	m_lsTarget = Target;
	m_lidTarget = lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the glossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrGlossaryNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the translation that takes all the required info.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	SetTranslation(Source, lidSource, Target, lidTarget);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int 
CLocTranslation::operator==(const CLocTranslation &locTran) const
{
	return (
			GetSourceString() == locTran.GetSourceString()
			&& GetSourceString().GetStringType() 
					== locTran.GetSourceString().GetStringType()
			&& GetTargetString() == locTran.GetTargetString()
			&& GetTargetString().GetStringType() 
					== locTran.GetTargetString().GetStringType()
			&& GetNote() == locTran.GetNote()
			&& GetRanking() == locTran.GetRanking()
		   );
}

inline
int 
CLocTranslation::operator!=(const CLocTranslation &locTran) const
{
	return !(operator==(locTran));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the source string of the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetSourceString(void)
		const
{
	return m_lsSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the target string for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetTargetString(void)
		const
{
	return m_lsTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the glkossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocTranslation::GetNote(void)
		const
{
	return m_pstrGlossaryNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the translation ranking for the strnslation.  See
//  CalculateRanking().
//  
//-----------------------------------------------------------------------------
inline
UINT
CLocTranslation::GetRanking(void)
		const
{
	return m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded source language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetSourceLanguage(void)
		const
{
	return m_lidSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded target language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetTargetLanguage(void)
		const
{
	return m_lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Validates the translation.  This make sure that all the needed components
//  of tghe source string exist in some form in the target string.  This
//  simply returns a validation code.
//  
//-----------------------------------------------------------------------------
inline
CVC::ValidationCode
CLocTranslation::ValidateTranslation(
		const CValidationOptions &Options)
		const
{
	CLString str;
	
	return ValidateTranslation(Options, FALSE, str, NULL, NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for the translation object.
//  
//-----------------------------------------------------------------------------
inline
const CLocTranslation &
CLocTranslation::operator=(
		const CLocTranslation &Source)	// Translation to copy from.
{
	CopyTranslation(Source);
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for the translation.  Nothing interesting happens here.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::~CLocTranslation()
{
	DEBUGONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\lstime.h ===
//-----------------------------------------------------------------------------

//  

//  File: lstime.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
VOID
LTAPIENTRY GMTTimeToLocalTime(COleDateTime &);


VOID
LTAPIENTRY LocalTimeToGMTTime(COleDateTime &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\logfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: logfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CLogFile::CLogFile()
{}



inline
CLogFile::~CLogFile()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\progress.h ===
//-----------------------------------------------------------------------------

//  

//  File: progress.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef _ESPUTIL_PROGRESS
#define _ESPUTIL_PROGRESS


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CProgressiveObject : virtual public CObject
{
public:
	CProgressiveObject();

	void AssertValid(void) const;
	
	virtual void SetProgressIndicator(UINT uiPercentage) = 0;
	virtual void SetDescription(HINSTANCE, DWORD);

	~CProgressiveObject();

	virtual void SetCurrentTask(CLString const & strTask) = 0;
	virtual void SetDescriptionString(CLString const & strDescription) = 0;
	
private:
	//
	// Private so nobody will use them...
	//
	CProgressiveObject(const CProgressiveObject &);
	const CProgressiveObject &operator=(const CProgressiveObject &);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "progress.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\operator.h ===
//-----------------------------------------------------------------------------

//  

//  File: operator.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UINT Operators;


class LTAPIENTRY CColumnOp
{
public:
	enum Operator
	{
		None   = 0,
		EQ 	   = 0x00000001,
		NOTEQ  = 0x00000002,
		GT     = 0x00000004,
		LT     = 0x00000008,
		LTEQ   = 0x00000010,
		GTEQ   = 0x00000020,
		WITHIN = 0x00000040,
		BEYOND = 0x00000080,

		CONTAINS     = 0x00000100,
		CONTAINSWORD = 0x00000200,
		STARTWITH    = 0x00000400,
		ENDWITH      = 0x00000800,
	};

	typedef CList<Operator, Operator> COperatorList;

	static CLString GetText(Operator);
	static void GetOperators(const Operators, COperatorList &);


private:
	CColumnOp();
};

typedef CColumnOp CCO;

const Operators NoOps = 0;
const Operators NumericOps = CCO::EQ | CCO::NOTEQ | CCO::GT | CCO::LT;
const Operators SimpStrOps = CCO::EQ | CCO::NOTEQ | CCO::STARTWITH | CCO::ENDWITH;
const Operators CompStrOps = CCO::CONTAINS | CCO::CONTAINSWORD;
const Operators StringOps  = SimpStrOps | CompStrOps;
const Operators StrListOps = CCO::EQ | CCO::NOTEQ;
const Operators DateOps    = CCO::LT | CCO::GT | CCO::EQ | CCO::NOTEQ | CCO::WITHIN | CCO::BEYOND;
const Operators BooleanOps = CCO::EQ | CCO::NOTEQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\product.h ===
//-----------------------------------------------------------------------------
//  
//  File: product.h
// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


struct ESP_USER_SETUP_DATA
{
	CLString strName;
	CLString strCompany;
};


BOOL LTAPIENTRY GetEspressoVersion(CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileVersion(const CLString& strFile, 
	CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileCopyright(const CLString& strFile, 
	CLString& strCopyright);

BOOL LTAPIENTRY GetSetupUserInfo(ESP_USER_SETUP_DATA& userData);

void LTAPIENTRY GetApplicationDirectory(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\passtrmerge.h ===
//-----------------------------------------------------------------------------

//

// File: PasStrMerge.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
// Declaration of a class which handles the merge of two Pascal strings.
//
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_PasStrMerge_h_INCLUDED
#define LOCUTIL_PasStrMerge_h_INCLUDED


class LTAPIENTRY CPascalStringMerge
{
public:
	static BOOL NOTHROW Merge(CPascalString &, const CPascalString &);

	static BOOL NOTHROW Merge(CPascalString & pasDestination,
			CPascalString const & pasSource, UINT const nMaxLength,
			CReport * const pReport, CLString const & strContext,
			CGoto * const pGoto = NULL);

private:
	static BOOL NOTHROW IsParagraph(const CPascalString &, const CPascalString &);

};


#endif	// #ifndef LOCUTIL_PasStrMerge_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LocUtil.rc
//
#define IDD_CANCELABLE                  12600
#define IDC_CANCEL_CURRENT              12601
#define IDC_TASK                        12602
#define IDD_PROGRESS                    12603
#define IDC_CANCEL_DESCRIPTION          12603
#define IDC_PROGDLG_PROGRESS            12604
#define IDC_OPERATION                   12606
#define IDC_PROGRESS                    12607
#define IDD_WARNINGS                    12608
#define IDC_CHK_EXCL                    12608
#define IDC_WARNINGS_EDT                12609
#define IDD_OPEN_EXCL                   12610
#define IDS_SETTINGS_INDENT             12700
#define IDS_SETTINGS_SEP                12701
#define IDS_SETTINGS_CTX                12702
#define IDS_SETTINGS_DEFAULT            12703
#define IDS_SETTINGS_USER               12704
#define IDS_SETTINGS_OVERRIDE           12705
#define IDS_TRUNCATED_TO_FIT            12706
#define IDS_AMPERSAND_NOT_ALONE         12707
#define IDS_CANT_HAVE_2HOTKEY           12708
#define IDS_AMPERSAND_NO_BLANK          12709
#define IDS_INVALID_HOTKEY_CHAR         12710
#define IDS_OUTTAB_FILE                 12712
#define IDS_OUTTAB_TEST                 12713
#define IDS_OUTTAB_GBOX                 12714
#define IDS_OUTTAB_LOCK                 12715
#define IDS_OUTTAB_UPDATE               12716
#define IDS_OUTTAB_MESSAGES             12717
#define IDS_VAL_BLANK_TARGET            12718
#define IDS_VAL_BLANK_SOURCE            12719
#define IDS_VAL_REMOVE_HK               12720
#define IDS_VAL_ADDED_HK                12721
#define IDS_VAL_LINE_COUNT              12722
#define IDS_VAL_REMOVE_ACCEL            12723
#define IDS_VAL_CHANGED_TERMINATOR      12724
#define IDS_VAL_LEADING_WHITESPACE      12725
#define IDS_VAL_LEADING_PUNCTUATION     12726
#define IDS_VAL_TRAILING_WHITESPACE     12727
#define IDS_VAL_TRAILING_PUNCTUATION    12728
#define IDS_VAL_TRANSLATION_SIZE        12729
#define IDS_VAL_HOTKEY_POSITION         12730
#define IDS_VAL_DBCS_POS                12731
#define IDS_VAL_DBCS_CHAR               12732
#define IDS_VAL_BLANK_TARGET_LONG       12733
#define IDS_VAL_BLANK_SOURCE_LONG       12734
#define IDS_VAL_REMOVE_HK_LONG          12735
#define IDS_VAL_ADDED_HK_LONG           12736
#define IDS_VAL_LINE_COUNT_LONG         12737
#define IDS_VAL_REMOVE_ACCEL_LONG       12738
#define IDS_VAL_CHANGED_TERMINATOR_LONG 12739
#define IDS_VAL_LEADING_WHITESPACE_LONG 12740
#define IDS_VAL_LEADING_PUNCTUATION_LONG 12741
#define IDS_VAL_TRAILING_WHITESPACE_LONG 12742
#define IDS_VAL_TRAILING_PUNCTUATION_LONG 12743
#define IDS_VAL_TRANSLATION_SIZE_LONG   12744
#define IDS_VAL_HOTKEY_POSITION_LONG    12745
#define IDS_VAL_DBCS_POS_LONG           12746
#define IDS_VAL_DBCS_CHAR_LONG          12747
#define IDS_VAL_REORDERABLE             12748
#define IDS_VAL_PRINTF                  12749
#define IDS_VAL_REORDERABLE_LONG        12750
#define IDS_VAL_PRINTF_LONG             12751
#define IDS_VAL_CHECK_NUL               12752
#define IDS_VAL_CHECK_NUL_LONG          12753
#define IDS_VAL_CHECK_CHARS_IN_CP       12754
#define IDS_VAL_CHECK_CHARS_IN_CP_LONG  12755
#define IDS_NOTE                        12756
#define IDS_WARNING                     12757
#define IDS_ERROR                       12758
#define IDS_ABORT                       12759
#define IDS_TOO_MANY_FILES_SELECTED     12760
#define IDS_TRUE                        12761
#define IDS_FALSE                       12762
#define IDS_OUTTAB_UTILITY              12763
#define IDS_EQ                          12764
#define IDS_NOTEQ                       12765
#define IDS_GT                          12766
#define IDS_LT                          12767
#define IDS_LTEQ                        12768
#define IDS_GTEQ                        12769
#define IDS_WITHIN                      12770
#define IDS_BEYOND                      12771
#define IDS_CONTAINS                    12772
#define IDS_EXTENSIONS                  12773
#define IDS_EXTENSIONS_HELP             12774
#define IDS_CONTAINSWORD                12775
#define IDS_CANCEL                      12776
#define IDS_STOP                        12777
#define IDS_STARTWITH                   12778
#define IDS_ENDWITH                     12779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12611
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12609
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\progress.inl ===
//-----------------------------------------------------------------------------
//  
//  File: progress.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CProgressiveObject::CProgressiveObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\showwarnings.h ===
//-----------------------------------------------------------------------------

//  

//  File: ShowWarnings.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(PKGUTIL__ShowWarnings_h__INCLUDED)
#define PKGUTIL__ShowWarnings_h__INCLUDED

enum eWarningFilter
{
	wfNote,
	wfWarning,
	wfError,
	wfAbort,
	wfAll
};


int LTAPIENTRY ShowWarnings(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL,
		eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, UINT nMsgBoxFlags = MB_OK);

#endif // PKGUTIL__ShowWarnings_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\schema.h ===
//-----------------------------------------------------------------------------

//  

//  File: schema.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL_Schema_h_INCLUDED)
#define LOCUTIL_Schema_h_INCLUDED

#pragma once

namespace MitDisplayColumns
{
	interface IManager;
	interface IOption;
};

class CColDefList;

//------------------------------------------------------------------------------
class LTAPIENTRY SchemaId : public _GUID
{
public:
	SchemaId();
	SchemaId(const _GUID &);
	
	void Load(CArchive &);
	void Store(CArchive &) const;
	void Serialize(CArchive &);

	const SchemaId & operator=(const SchemaId &);
	const SchemaId & operator=(const _GUID &);
	
	INT operator==(const SchemaId &);
	INT operator!=(const SchemaId &);

private:
	BOOL Compare(const SchemaId &);
};


//------------------------------------------------------------------------------
class LTAPIENTRY CTableSchema : public CRefCount
{
// Construction
public:
	CTableSchema(const SchemaId &, const CLString &, const CColDefList &);
	
// Data
protected:
	SchemaId	m_Schema;
	CLString	m_strDescription;
	CColDefList	m_lstColDefs;

// Attributes
public:
	const SchemaId & GetSchemaId() const;
	const CLString & GetDescription() const;
	const CColDefList & GetColDefList() const;

	int GetDisplayColumnCount() const;

// Operations
public:
	const CColumnDefinition * GetColumnDefinition(long nSearchID) const;
	const CColumnDefinition * GetColumnDefinition(const CLString & stSearchID) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};


//------------------------------------------------------------------------------
struct LTAPIENTRY DcsHelp
{
	static void
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, 
			MitDisplayColumns::IManager * const pManager, 
			MitDisplayColumns::IOption ** ppOption = NULL);

	static void 
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, _bstr_t bstrName, 
			MitDisplayColumns::IManager * const pManager, long rgID[], int cIDs,
			MitDisplayColumns::IOption ** ppOption = NULL);
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "schema.inl"
#endif

#endif // LOCUTIL_Schema_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\stdafx.h ===
//-----------------------------------------------------------------------------

//  

//  File: stdafx.h|locutil

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxtempl.h>
#include <afxole.h>

#include <mitutil.h>
#include <MitTL.h>

// Import TypeLibs before header files
#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#import <TypeLibs\MitDC.tlb> named_guids, raw_method_prefix("raw_")
#pragma warning(ZCOM_WARNING_DEFAULT)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\report.h ===
//-----------------------------------------------------------------------------

//  

//  File: report.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 


enum MessageSeverity
{
	esNote,
	esWarning,
	esError,
	esAbort
};

//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReport  // : virtual public CObject
{
public:
	CReport();

	virtual void AssertValid(void) const;

	virtual void Activate(void);
	virtual void Clear(void);

	enum ConfidenceLevel
	{
		Low,
		High
	};
	
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	
	NOTHROW static const CLString & GetErrorCodeText(MessageSeverity ms);
	
	virtual ~CReport();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReport(const CReport &);
	const CReport &operator=(const CReport &);

	//
	//  Text for MessageSeverities.
	//
	static CLString strSeverities[4];
	friend void GlobalInitStrings(void);
};

#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\stringhelp.h ===
//******************************************************************************

//

// StringHelp.h: Microsoft LocStudio

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

#if !defined(LOCUTIL__StringHelp_h__INCLUDED)
#define LOCUTIL__StringHelp_h__INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY CStringHelp
{
// Enums
public:
	enum Mode
	{
		mDisplay,	// Use display-mode logic
		mEdit		// Use edit-mode logic
	};

// Construction
public:
	CStringHelp(Mode mode, CReport * pReport);

// Data
protected:
	Mode		m_mode;
	CReport *	m_pReport;
	int			m_cErrors;
	CLString	m_stContext;

	BOOL			m_fFirstErrorSet;
	CWnd const *	m_pwndError;		// Optional window of first error
	int				m_idxError;			// Optional index of first error

// Attributes
public:
	int GetErrorCount();
	void ResetErrorCount();
	const CLString & GetContext();
	void SetContext(const CLString & stContext);

	BOOL GetFirstError(CWnd const * & pwnd, int & idxError);

// Operations
public:
	void LoadString(const CPascalString & pasSrc, CLString & stDest);
	void LoadString(_bstr_t bstrSrc, CLString & stDest);
	void LoadString(const CPascalString & pasSrc, CEdit * pebc);
	void LoadString(_bstr_t bstrSrc, CEdit * pebc);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest);
	BOOL SaveString(CEdit const * const pebc, CPascalString & pasDest);
	BOOL SaveString(CEdit const * const pebc, _bstr_t & bstrDest);

// Implementation
protected:
	void SetError(CWnd const * pwnd, int idxError);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest, CWnd const * pwnd);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest, CWnd const * pwnd);
};

#endif // LOCUTIL__StringHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_errorrep.h ===
//-----------------------------------------------------------------------------

//  

//  File: _errorrep.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__errorrep_h_INCLUDED)
#define LOCUTIL__errorrep_h_INCLUDED

////////////////////// the new global issuemessage functions.

UINT LTAPIENTRY EspMessageBox(const CLString strMessage, UINT uiType = MB_OK,
		UINT uiDefault=IDOK, UINT uiHelpContext=0);
UINT LTAPIENTRY EspMessageBox(HINSTANCE hResourceDll, UINT uiStringId,
		UINT uiType=MB_OK, UINT uiDefault=IDOK, UINT uiHelp = 0);

class CReport;

void LTAPIENTRY SetErrorReport(CReport *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReport(CReport *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif // LOCUTIL__errorrep_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\warndlg.h ===
//******************************************************************************

//  

//  File: WarnDlg.H

//

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//******************************************************************************

#if !defined(LOCUTIL__WarnDlg_h__INCLUDED)
#define LOCUTIL__WarnDlg_h__INCLUDED

//------------------------------------------------------------------------------
class CWarningsDlg : public CDialog
{
// Construction
public:
	CWarningsDlg(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL, 
			eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, 
			UINT nMsgBoxFlags = MB_OK, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CWarningsDlg)
	enum { IDD = IDD_WARNINGS };
	CButton	m_btnYes;
	CButton	m_btnCancel;
	CButton	m_btnNo;
	CButton	m_btnOK;
	//}}AFX_DATA

// Data
protected:
	const CBufferReport *	m_pBufMsg;
	CLString				m_stTitle;
	eWarningFilter			m_wf;
	BOOL					m_fShowContext;
	UINT					m_nMsgBoxFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningsDlg)
	public:
	virtual int DoModal();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void AddString(CEdit * pebc, const CLString & stAdd, int & len);

	// Generated message map functions
	//{{AFX_MSG(CWarningsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif  // LOCUTIL__WarnDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_espopts.h ===
//-----------------------------------------------------------------------------

//  

//  File: _espopts.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__espopts_h_INCLUDED)
#define LOCUTIL__espopts_h_INCLUDED

LTAPIENTRY BOOL RegisterOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterOptions(const TCHAR *szName);
LTAPIENTRY BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetGroupName(const TCHAR * szName, CLString & strGroup);
LTAPIENTRY BOOL SetOptionDefault(const TCHAR *szName, const CLocVariant &);

LTAPIENTRY const CLocUIOptionSetList &  GetOptions(void);

LTAPIENTRY CLocOptionValStore *  GetOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateOptionValues(void);

LTAPIENTRY void SummarizeOptions(CReport *);


#pragma warning(disable : 4251) // class 'foo' needs to have dll-interface 
								// to be used by clients of class 'bar' 

class LTAPIENTRY CLocOptionManager
{
public:
	const CLocUIOptionSetList &GetOptions(void);

	CLocOptionValStore *GetOptionStore(CLocUIOption::StorageType);
	void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
	BOOL RegisterOptions(CLocUIOptionSet *);
	void UnRegisterOptions(const TCHAR *szOptSetName);

	BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
	BOOL GetOptionValue(const TCHAR *szGroupName, const TCHAR *szName,
			CLocOptionVal *&);
	
	void UpdateOptionValues(void);
	void SummarizeOptionValues(CReport *pReport);
	
	BOOL SetOptionDefault(const TCHAR *szName, const
			CLocVariant &varValue);
	void UpdateCurrentValue(CLocUIOption *pOption);
	BOOL GetGroupName(const TCHAR* szName, CLString& strGroup);	
protected:
	void NotifyAll(void);
	void GetCurrentValue(CLocUIOption *, CLocOptionVal *&);
	void DumpOptionSet(CLocUIOptionSet *, UINT, CReport *);
	
private:
	CLocUIOptionSetList m_osOptSetList;
	SmartRef<CLocOptionValStore> m_spUserStore;
	SmartRef<CLocOptionValStore> m_spOverrideStore;
};

#pragma warning(default : 4251)

#endif // LOCUTIL__espopts_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_cancel.h ===
//-----------------------------------------------------------------------------

//

// File: _cancel.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__CANCEL_H
#define ESPUTIL__CANCEL_H

#pragma once

#pragma warning(disable:4275 4251)

class CCancelDialog;

class LTAPIENTRY CCancelDisplay : public CCancelableObject
{
public:
	CCancelDisplay(CWnd *pParent = NULL);

	//
	//  CCancelableObject methods.
	virtual BOOL fCancel(void) const;

	virtual void SetDescriptionString(const CLString &);
	virtual void SetCurrentTask(const CLString &);

	//
	//  CProgressiveObject methods.
	virtual void SetProgressIndicator(UINT uiPercentage);

	~CCancelDisplay();

	void SetDelay(clock_t);

	enum CancelButtonText { nCancel, nStop, COUNT_OF_ENUM };
	void SetCancelButtonText(CancelButtonText const nCancelButtonText);

	void DisplayDialog(BOOL);

protected:
	friend CCancelDialog;
	void SetCancel(BOOL);
	void ChangeCancelButtonText();

private:
	BOOL m_fCancel;
	CCancelDialog *m_pCancelDialog;
	CLString m_strDescription;
	CLString m_strTask;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t m_ctDisplayTime;
	CancelButtonText m_nCancelButtonText;
	BOOL m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CWnd *m_pParent;
};


#pragma warning(default:4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_cancel.inl"
#endif

#endif // ESPUTIL__CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\schema.inl ===
//-----------------------------------------------------------------------------
//  
//  File: schema.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
SchemaId::SchemaId()
	: _GUID(GUID_NULL)
{}

	

inline
SchemaId::SchemaId(
		const _GUID &guid)
	: _GUID(guid)
{}



inline
void
SchemaId::Load(
		CArchive &ar)
{
	if (ar.Read((_GUID *) this, sizeof(_GUID)) != sizeof(_GUID))
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}



inline
void
SchemaId::Store(
		CArchive &ar)
		const
{
	ar.Write((_GUID *) this, sizeof(_GUID));
}




inline
void
SchemaId::Serialize(
		CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
const SchemaId &
SchemaId::operator=(
		const SchemaId &other)
{
	return operator=((_GUID &)other);
}



inline
const SchemaId &
SchemaId::operator=(
		const _GUID &other)
{
	(_GUID &)(*this) = other;

	return *this;
}



inline
int
SchemaId::operator==(
		const SchemaId &other)
{
	return Compare(other);
}



inline
int
SchemaId::operator!=(
		const SchemaId &other)
{
	return !Compare(other);
}



inline
BOOL
SchemaId::Compare(
		const SchemaId &other)
{
	return ((_GUID &)*this) == ((_GUID &)other);
}



inline
const SchemaId & 
CTableSchema::GetSchemaId() const
{
	return m_Schema;
}


inline
const CLString & 
CTableSchema::GetDescription() const
{
	return m_strDescription;
}


inline
const CColDefList & 
CTableSchema::GetColDefList() const
{
	return m_lstColDefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_interface.h ===
//-----------------------------------------------------------------------------

//  

//  File: _interface.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
UINT
EspMessageBox(
		HINSTANCE hResourceDll,
		UINT uiStringId,
		UINT uiType,
		UINT uiDefault,
		UINT uiHelp)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	return EspMessageBox(strMessage, uiType, uiDefault, uiHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_locenum.h ===
//-----------------------------------------------------------------------------

//  

//  File: _locenum.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(LOCUTIL__locenum_h_INCLUDED)
#define LOCUTIL__locenum_h_INCLUDED
 
//
//  This class is used in UI. SetSel() is used to set the initial
//	selection in the combo box
//
class LTAPIENTRY CEnumIntoComboBox: public CEnumCallback
{
public:
	CEnumIntoComboBox(CComboBox *pLB=NULL, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
};

class LTAPIENTRY CEnumIntoListBox: public CEnumCallback
{
public:
	CEnumIntoListBox(CListBox *pLB=NULL, 
				DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
};


class LTAPIENTRY CWEnumIntoComboBox: public CWEnumCallback
{
public:
	CWEnumIntoComboBox(CComboBox *pLB=NULL, BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	BOOL		m_bForEdit;   // If this flag is true, the strings in the Combo box are displayed in Editing mode
};


class LTAPIENTRY CWEnumIntoListBox: public CWEnumCallback
{
public:
	CWEnumIntoListBox(CListBox *pLB=NULL, 
				BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
	BOOL		m_bForEdit;		// If this flag is true, the strings in the Listbox are displayed in Editing mode
};

#endif  // LOCUTIL__locenum_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_extension.h ===
//-----------------------------------------------------------------------------

//  

//  File: _extension.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Classes to support the new Espresso Extensions interfaces.
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UUID ExtensionID;
typedef UUID OperationID;

struct LTAPIENTRY LOCEXTENSIONMENU
{
	LOCEXTENSIONMENU();
	
	CLString strMenuName;				// Name of the Menu
	IID      iidProcess;				// IID for the process interface the
										// menu requires
	OperationID    idOp;				// Allows a single DLL to implement
};

typedef CArray<LOCEXTENSIONMENU, LOCEXTENSIONMENU &> CLocMenuArray;


DECLARE_INTERFACE_(ILocExtension, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;


	//
	//  ILocExtension methods
	//

	//
	//  In Initialize, extension will...
	//   Add any menus it needs to the array of menu obejcts
	//   Register any options it has with Espresso
	//   Ignore the IUnknown for now.
	STDMETHOD(Initialize)(IUnknown *) PURE;

	//
	//  Since extensions may have state, we can't use QueryInterface.
	//  This method has similar semantics, except that in most cases
	//  we expect to get a new objects.  Also, QI on a returned
	//  object doesn't have to support ILocExtension.
	STDMETHOD(GetExtension)(const OperationID &, LPVOID FAR*ppvObj) PURE;
	
	//
	//  In UnInitialize the extension will...
	//   UnRegister any of its options.
	STDMETHOD(UnInitialize)(void) PURE;
};

struct __declspec(uuid("{9F9D180E-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtension;

LTAPIENTRY void UUIDToString(const UUID &, CLString &);

LTAPIENTRY void RegisterExtension(const ExtensionID &,
		const TCHAR *szDescription, HINSTANCE,
		const CLocMenuArray &);
LTAPIENTRY void UnRegisterExtension(const ExtensionID &);

LTAPIENTRY BOOL RegisterExtensionOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterExtensionOptions(const TCHAR *szName);


//
//  Extensions need to export the following function:
//  STDAPI GetExtension(ILocExtension *&);
typedef HRESULT (STDAPICALLTYPE *PFNExtensionEntryPoint)(ILocExtension *&);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_progress.h ===
//-----------------------------------------------------------------------------

//  

//  File: _progress.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__PROGRESS_H
#define ESPUTIL__PROGRESS_H

class CProgressDialog;
class CInputBlocker;

#pragma warning(disable:4251)

class LTAPIENTRY CProgressDisplay : public CProgressiveObject
{
public:
	CProgressDisplay(CWnd *pParent = NULL);

	void SetDelay(clock_t);
	void DisplayDialog(BOOL);

	void SetProgressIndicator(UINT uiPercentage);

	void SetTitle(const CLString &);
	void SetTitle(HINSTANCE, DWORD);
	~CProgressDisplay();

	virtual void SetCurrentTask(CLString const & strTask);
	virtual void SetDescriptionString(CLString const & strDescription);

private:
	CProgressDialog *m_pDialog;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t         m_ctDisplayTime;
	BOOL	m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CLString m_strTitle;
	CLString m_strDescription;

	CWnd *m_pParent;
};

#pragma warning(default:4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_optvalstore.h ===
//-----------------------------------------------------------------------------

//  

//  File: _optvalstore.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValStore : public CRefCount, public CObject
{ public: CLocOptionValStore() {};

	void AssertValid(void) const;

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup)
			= 0;

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
 			const CLString &strOptionName) = 0;
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLocOptionVal *);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &) = 0;
	virtual BOOL RemoveOptions(const CLString &strOptionGroup) = 0;

private:
	CLocOptionValStore(const CLocOptionValStore &);
	void operator=(int);
};
	

class LTAPIENTRY CLocOptionValRegStore : public CLocOptionValStore
{
public:
	CLocOptionValRegStore();

	void AssertValid(void) const;
	
	BOOL SetRegistryKeyName(const TCHAR *);

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup);

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
			const CLString &strOptionName);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &);
	virtual BOOL RemoveOptions(const CLString &strOptionGroup);

	virtual ~CLocOptionValRegStore();

private:
	HKEY m_hkRegStorage;
	CLocOptionValSetList m_oslCache;

	void PurgeOptionCache(void);
};



#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_username.h ===
//-----------------------------------------------------------------------------

//  

//  File: username.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__USERNAME_H
#define ESPUTIL__USERNAME_H

LTAPIENTRY const NOTHROW CPascalString &GetCurrentUserName();
LTAPIENTRY void NOTHROW SetUserName(const CPascalString &);
LTAPIENTRY void NOTHROW ResetUserName(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_pumpidle.h ===
//-----------------------------------------------------------------------------

//  

//  File: pumpidle.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__PUMPIDLE_H
#define ESPUTIL__PUMPIDLE_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CPumpAndIdle : public CObject
{
public:
	CPumpAndIdle(BOOL fDelete);
	
	virtual BOOL PumpAndIdle(long lCount) = 0;

	void Delete(void);
	
private:
	CPumpAndIdle();
	CPumpAndIdle(const CPumpAndIdle &);
	void operator=(const CPumpAndIdle &);

	BOOL m_fDelete;
};

#pragma warning(default: 4275)

class LTAPIENTRY CTimerPump : public CPumpAndIdle
{
public:
	CTimerPump(BOOL fDelete, UINT uiSeconds);

	BOOL PumpAndIdle(long lCount);

	virtual void OnTimeout(void)  = 0;
	
private:
	UINT m_uiTimeout;
	clock_t m_tLastRun;
};



void LTAPIENTRY NOTHROW AddPumpClass(CPumpAndIdle *);
BOOL LTAPIENTRY NOTHROW RemovePumpClass(CPumpAndIdle *);

BOOL LTAPIENTRY PumpAndIdle(long lCount);
void LTAPIENTRY PumpAndIdle(void);

class CProgressDialog;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CInputBlocker : public CObject
{
public:
	CInputBlocker(CWnd* pParent = NULL);

	~CInputBlocker();

private:
	CInputBlocker(const CInputBlocker &);
	void operator=(const CInputBlocker &);

	CProgressDialog *pDlg;
	
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_locstr.h ===
//-----------------------------------------------------------------------------

//  

//  File: _locstr.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


#ifndef ESPUTIL__LOCSTR_H
#define ESPUTIL__LOCSTR_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CLocTranslationArray : public CArray<CLocTranslation, CLocTranslation &>
{
public:

protected:
	 NOTHROW void SwapElements(UINT, UINT);
};


#pragma warning(disable : 4251)	// class 'foo' needs to have dll-interface to be
							    // used by clients of class 'bar' 

class LTAPIENTRY CLocCrackedString : public CObject
{
public:
	CLocCrackedString();
			
	void AssertValid(void) const;
	
	const CLocCrackedString &operator=(const CLocCrackedString &);

	NOTHROW int operator==(const CLocCrackedString &) const;
	NOTHROW int operator!=(const CLocCrackedString &) const;

	NOTHROW void CrackLocString(const CLocString &, BOOL fAsSource);
	NOTHROW UINT GetRanking(const CLocCrackedString &) const;

	NOTHROW BOOL HasExtension(void) const;
	NOTHROW BOOL HasControl(void) const;
	NOTHROW BOOL HasHotKey() const;

	NOTHROW const CPascalString & GetBaseString(void) const;
	NOTHROW const CPascalString & GetExtension(void) const;
	NOTHROW const CPascalString & GetControl(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW CST::StringType GetStringType(void) const;
	
	void SetBaseString(const CPascalString &pasBaseString);
	void SetHotKey(WCHAR cHotKeyChar, UINT uiHotKeyPos);
	
	void MergeCrackedStrings(const CLocCrackedString &, LangId,
			BOOL fMergeAccel);

	NOTHROW void ConvertToLocString(CLocString &) const;

	static void SetModifiers(const CPasStringList &);
	static void SetKeyNames(const CPasStringList &);
	static WCHAR m_cKeyNameSeparator;
	
	~CLocCrackedString();

private:
	CLocCrackedString(const CLocCrackedString &);

	NOTHROW BOOL Compare(const CLocCrackedString &) const;
	NOTHROW void ClearCrackedString(void);
	NOTHROW static BOOL IsControl(const CPascalString &, BOOL fAsSource);
	NOTHROW static void TranslateControl(CPascalString &);
	void SetDefaultModifierNames();
	void SetDefaultKeyNames();
	
	NOTHROW static BOOL IsTerminator(const CPascalString &);
	static CPasStringArray m_psaModifiersSource;
	static CPasStringArray m_psaKeyNamesSource;
	static CPasStringArray m_psaModifiersTarget;
	static CPasStringArray m_psaKeyNamesTarget;
	static BOOL m_fModifiersInitialized;
	static BOOL m_fKeyNamesInitialized;
	
	CPascalString m_pstrBaseString;
	CPascalString m_pstrExtension;
	CPascalString m_pstrControl;
	WCHAR m_cControlLeader;
	WCHAR m_cHotKeyChar;
	UINT m_uiHotKeyPos;
	CST::StringType m_stStringType;
};

#pragma warning(default : 4275)
#pragma warning(default : 4251)	

LTAPIENTRY const CValidationOptions & GetValidationOptions(void);
LTAPIENTRY void SetValidationOptions(const CValidationOptions &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_locstr.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\ltapi.h ===
//-----------------------------------------------------------------------------

//  

//  File: ltapi.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-2001 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-2001 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Swaps two elements of the translation array.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslationArray::SwapElements(
		UINT iOne,						// First index to swap
		UINT iTwo)						// Second index to swap
{
	CLocTranslation Temp;
	
	LTASSERT(iOne <= (UINT)GetSize());
	LTASSERT(iTwo <= (UINT)GetSize());

	Temp = (*this)[iOne];
	(*this)[iOne] = (*this)[iTwo];
	(*this)[iTwo] = Temp;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for cracked strings.
//  
//-----------------------------------------------------------------------------
inline
const CLocCrackedString &
CLocCrackedString::operator=(
		const CLocCrackedString &csSource)
{
	m_pstrBaseString = csSource.m_pstrBaseString;
	m_pstrExtension = csSource.m_pstrExtension;
	m_pstrControl = csSource.m_pstrControl;
	m_cControlLeader = csSource.m_cControlLeader;
	m_cHotKeyChar = csSource.m_cHotKeyChar;
	m_uiHotKeyPos = csSource.m_uiHotKeyPos;

	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for comparing two cracked strings.  Language ID and
//  string type are NOT significant!
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocCrackedString::Compare(
		const CLocCrackedString &csOther)
		const
{
	return ((m_uiHotKeyPos    == csOther.m_uiHotKeyPos) &&
			(m_cHotKeyChar    == csOther.m_cHotKeyChar) &&
			(m_pstrControl    == csOther.m_pstrControl) &&
			(m_cControlLeader == csOther.m_cControlLeader) &&
			(m_pstrExtension  == csOther.m_pstrExtension) &&
			(m_pstrBaseString == csOther.m_pstrBaseString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator==(
		const CLocCrackedString &csOther)
		const
{
	return Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator!=(
		const CLocCrackedString &csOther)
		const
{
	return !Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the Cracked string has an 'extension'.  The extension
//  is a sequence of characters ("...", ">>", stc) that indicates that this
//  item leads to another UI element.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the extension is non-null.
CLocCrackedString::HasExtension(void)
		const
{
	return m_pstrExtension.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the cracked string has a 'control' sequence.  This is
//  usually text describing a shortcut key that invokes the same action as this
//  item, for example "Ctrl + F".
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the control seq. is non-null
CLocCrackedString::HasControl(void)
		const
{
	return m_pstrControl.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Check to see if the cracked string has a hot-key.  This come directly out
//  of the CLocString that was parsed into the Cracked String.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the string has a hot-key.
CLocCrackedString::HasHotKey(void)
		const
{
	return (m_cHotKeyChar != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'base string'.  This is the original string stripped of
//  extension and control sequences, and of the hot-key.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Base string.
CLocCrackedString::GetBaseString(void)
		const
{
	return m_pstrBaseString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the extension component of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetExtension(void)
		const
{
	return m_pstrExtension;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the constol sequence of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetControl(void)
		const
{
	return m_pstrControl;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character for the string.
//  
//-----------------------------------------------------------------------------
inline
WCHAR
CLocCrackedString::GetHotKeyChar(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_cHotKeyChar;
}



inline
UINT
CLocCrackedString::GetHotKeyPos(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_uiHotKeyPos;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string type for the string.
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocCrackedString::GetStringType(void)
		const
{
	return m_stStringType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleans out all the components of the cracked string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCrackedString::ClearCrackedString(void)
{
	m_pstrBaseString.ClearString();
	m_pstrExtension.ClearString();
	m_pstrControl.ClearString();
	m_cControlLeader = L'\0';
	m_cHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
	m_stStringType = CST::None;
}



inline
void
CLocCrackedString::SetBaseString(
		const CPascalString &pasBase)
{
	m_pstrBaseString = pasBase;
}



inline
void
CLocCrackedString::SetHotKey(
		WCHAR cHotKeyChar,
		UINT uiHotKeyPos)
{
	m_cHotKeyChar = cHotKeyChar;
	m_uiHotKeyPos = uiHotKeyPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_report.h ===
//-----------------------------------------------------------------------------

//  

//  File: _report.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_REPORT_H
#define LOCUTIL_REPORT_H

#pragma once

//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReport : public CReport
{
public:
	CNullReport() {};
	
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

};


//
//  This stuff is used for an implementation of CReport that will
//  'buffer' messages.  Use CBufferReporter if you don't want to
//  process messages until after the process producing them is done.
//  You can get the messages either by severity, or as a list of all
//  messages as they were issued.
//
struct ReportMessage
{
	MessageSeverity sev;
	CLString strContext;
	CLString strMessage;
	SmartRef<CGoto> spGoto;
	SmartRef<CGotoHelp> spGotoHelp;
};


typedef CTypedPtrList<CPtrList, ReportMessage *> MessageList;

#pragma warning (disable:4251)

class LTAPIENTRY CBufferReport : public CReport
{
public:
	CBufferReport();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReport();

private:

	MessageList m_mlNotes;
	MessageList m_mlWarnings;
	MessageList m_mlErrors;
	MessageList m_mlAborts;

	mutable MessageList m_mlMessages;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReport : public CReport
{
public:
	CMessageBoxReport();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CMessageBoxReport();

private:
	
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReport : public CReport
{
public:
	CFileReport();

	BOOL InitFileReport(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReport();

private:

	CFile m_OutputFile;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReport : public CReport
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	virtual void SetConfidenceLevel(ConfidenceLevel);

private:
	BOOL m_fEnabled;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReport : public CReport
{
public:
	CRedirectReport();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReport *pReport);
	
	~CRedirectReport();

private:
	struct RedirectInfo
	{
		SmartPtr<CReport> pReport;
		UINT uiRefCount;
	};

	RedirectInfo *m_pRedirectInfo;
	void NOTHROW Detach(void);
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReport : public CReport
{
public:
	CActivateReport(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	BOOL m_fActivated;
	CReport *m_pReport;
};



//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReport(COutputTabs::OutputTabs idx, CReport *pReport);
NOTHROW LTAPIENTRY CReport * GetReport(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReports();

#include "_report.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\mitctrl.h ===
//-----------------------------------------------------------------------------

//  

//  File: mitctrl.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#include "..\mitctrl\mitctrllib.h"

#ifndef MIT_MITCTRL_H
#define MIT_MITCTRL_H

//TODO get this from some other place
const	eventidSelChanged = 1L;
const	eventidCheckStateChange = 2L;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\mitthrow.h ===
//-----------------------------------------------------------------------------

//  

//  File: MitThrow.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#if !defined(MIT_MitThrow)
#define MIT_MitThrow

#if !defined(NO_NOTHROW)

#if !defined(NOTHROW)
#define NOTHROW __declspec(nothrow)
#endif

#else

#if defined(NOTHROW)
#undef NOTHROW
#endif

#define NOTHROW

#endif

#endif // MIT_MitThrow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\mittl.h ===
//******************************************************************************

//

// MitTL.h: MIT Template Library

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_TL_INCLUDED)
#define MIT_TL_INCLUDED

// General helpers

#include "..\MitTL\ComHelp.h"

#if defined(__ATLCOM_H__)			// Include ATL helpers if ATL is defined
	#include "..\MitTL\AtlComHelp.h"
#endif

#include "..\MitTL\MapHelp.h"

#include "MitThrow.h"
#include "..\MitTL\SmartPtr.h"

// Shared objects

#if defined(MitTL_UseDispIDCache)
	#include "..\MitTL\DispIDCache.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\mitwarning.h ===
//******************************************************************************

//

// MitWarning.h: MIT Template Library warnings

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\locutil\_report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _report.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetNotes(void)
		const
{
	return m_mlNotes;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetWarnings(void)
		const
{
	return m_mlWarnings;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetErrors(void)
		const
{
	return m_mlErrors;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetAborts(void)
		const
{
	return m_mlAborts;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReport.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetMessages(void)
		const
{
	return m_mlMessages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\mitui.h ===
//-----------------------------------------------------------------------------

//  

//  File: mitui.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "MITUI.LIB")

#include "..\mitui\bumpbox.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\mitdiff.h ===
//------------------------------------------------------------------------------

//  

//  mitdiff.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//
//------------------------------------------------------------------------------

#ifndef _MITDIFF_H
#define _MITDIFF_H


#ifdef MITDIFF
#define MITDIFFAPI __declspec(dllexport)
#else
#define MITDIFFAPI __declspec(dllimport)
#endif


//------------------------------------------------------------------------------
//
//	Support routines
//
//------------------------------------------------------------------------------

// Rotating hash from DDJ Sept. 97
inline unsigned
_HashString (const wchar_t *pwch, int cwch)
{
	int h = cwch;
	while (cwch--)
	{
		h = (h << 5) ^ (h >> 27) ^ *pwch++;
	}
	return h;
}


//------------------------------------------------------------------------------
//
//	Define the data types we want to diff
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Encapsulates a _bstr_t
class CBStr
{
public:
	CBStr () { }

	operator unsigned () const;								// Hash
	bool operator== (const CBStr& rhs) const;				// Compare

	_bstr_t m_bstr;
};

inline
CBStr::operator unsigned () const
{
	return _HashString (m_bstr, wcslen (m_bstr));
}

inline bool
CBStr::operator== (const CBStr& rhs) const
{
	return wcscmp (m_bstr, rhs.m_bstr) == 0;
}


//------------------------------------------------------------------------------
// Word (not zero-terminated) including word-class
class CWord
{
public:
	CWord () { }

	operator unsigned () const;								// Hash
	bool operator== (const CWord& rhs) const;				// Compare

	const wchar_t *m_pwchWord;
	int m_cwchWord;

	enum wordclass
	{
		wcWORD, wcSPACE, wcMIXED
	};
	wordclass m_wc;
};

inline
CWord::operator unsigned () const
{
	return _HashString (m_pwchWord, m_cwchWord);
}

inline bool
CWord::operator== (const CWord& rhs) const
{
	return m_wc == rhs.m_wc &&
			m_cwchWord == rhs.m_cwchWord &&
			memcmp (m_pwchWord, rhs.m_pwchWord, m_cwchWord * sizeof (wchar_t)) == 0;
}


//------------------------------------------------------------------------------
// Zero-terminated string + custom data
class CCustomString
{
public:
	CCustomString () { }

	operator unsigned () const;								// Hash
	bool operator== (const CCustomString& rhs) const;		// Compare

	const wchar_t *m_pwsz;
	DWORD m_custdata;
};

inline
CCustomString::operator unsigned () const
{
	return _HashString (m_pwsz, wcslen (m_pwsz));
}

inline bool
CCustomString::operator== (const CCustomString& rhs) const
{
	return m_custdata == rhs.m_custdata &&
			wcscmp (m_pwsz, rhs.m_pwsz) == 0;
}


//------------------------------------------------------------------------------
// Binary data block of size 16
class CBlob16
{
public:
	operator unsigned () const;								// Hash
	bool operator== (const CBlob16& rhs) const;				// Compare

	BYTE m_data[16];
};

inline
CBlob16::operator unsigned () const
{
	return _HashString ((const wchar_t *) m_data, 8);
}

inline bool
CBlob16::operator== (const CBlob16& rhs) const
{
	return memcmp (m_data, rhs.m_data, 16) == 0;
}


//------------------------------------------------------------------------------
//
//	Class holding diff result
//
//------------------------------------------------------------------------------

class CDiffResult
{
public:
	CByteArray m_abChanges1;
	CByteArray m_abChanges2;
	int m_iNumAdditions;
	int m_iNumDeletions;
	int m_iNumSubstitutions;
};


//------------------------------------------------------------------------------
//
//	Exported functions
//
//------------------------------------------------------------------------------

// Diff arrays of CBStr
void MITDIFFAPI Diff (
		const CBStr *aElems1,
		int iNumElems1,
		const CBStr *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CWord
void MITDIFFAPI Diff (
		const CWord *aElems1,
		int iNumElems1,
		const CWord *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CCustomString
void MITDIFFAPI Diff (
		const CCustomString *aElems1,
		int iNumElems1,
		const CCustomString *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CBlob16
void MITDIFFAPI Diff (
		const CBlob16 *aElems1,
		int iNumElems1,
		const CBlob16 *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of wchar_t (no class definition needed)
void MITDIFFAPI Diff (
		const wchar_t *aElems1,
		int iNumElems1,
		const wchar_t *aElems2,
		int iNumElems2,
		CDiffResult *result);


#endif	// !_MITDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\mitutil.h ===
//-----------------------------------------------------------------------------

//  

//  File: mitutil.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#ifndef IMPLEMENT
#pragma comment(lib, "mitutil.lib")
#endif

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#ifdef __cplusplus


#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#pragma message("Warning: <afxtempl.h> not in pre-compiled header file, including")
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#pragma message("Warning: <ole2.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>						// Provide interface definitions
#include "..\mitutil\macros.h"
#include "..\mitutil\ltdebug.h"					//  Espresso debugging facilities
#ifndef MIT_NO_DEBUG
#include "..\mitutil\stacktrace.h"
#include "..\mitutil\counter.h"
#endif

#ifndef MIT_NO_IMAGEHLP
#include <imagehlp.h>
#include "..\mitutil\imagehelp.h"	 	//	Helper class for imagehlp.dll
#endif

#include "..\mitutil\refcount.h"


#ifndef MIT_NO_SMART
#include "..\mitutil\smartptr.h"
#include "..\mitutil\smartref.h"
#endif


#ifndef MIT_NO_STRING
#include "..\mitutil\counter.h"
#include "..\mitutil\clstring.h"		//  Wrapper for CString
#include "..\mitutil\mitenum.h"
#include "..\mitutil\espnls.h"			//  Language Supportxo
#include "..\mitutil\cowblob.h"			//  Copy-on-write Blob class
#include "..\mitutil\passtr.h"			//  Pascal style (counted) strings
#include "..\mitutil\StringBlast.h"
#include "..\mitutil\strlist.h"
#include "..\mitutil\stringtokenizer.h"
#endif

#ifndef MIT_NO_FILE
#include "..\mitutil\loadlib.h"	        //  Wrapper for LoadLibrary
#include "..\mitutil\blobfile.h"
#include "..\mitutil\path.h"
#endif

#ifndef MIT_NO_OPTIONS
#include "..\mitutil\smartref.h"
#include "..\mitutil\locid.h"			//  Espresso ID's
#include "..\mitutil\locvar.h"			//  Variant type for CBinary
#include "..\mitutil\optionval.h"
#include "..\mitutil\optvalset.h"
#include "..\mitutil\uioptions.h"
#include "..\mitutil\uioptset.h"
#include "..\mitutil\uiopthelp.h"
#endif

#ifndef MIT_NO_MISC
#include "..\mitutil\flushmem.h"
#include "..\MitUtil\RegHelp.h"			// Registry helpers
#include "..\MitUtil\EditHelp.h"
#endif

#ifndef MIT_NO_DIFF
#include "..\mitutil\redvisit.h"
#include "..\mitutil\gnudiffalg.h"
#endif

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\premidlenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	typedef enum \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	typelib##name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	typelib##name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst)

#undef END_ENUM
#define END_ENUM(name) \
	} name;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\precenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	enum name \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst) \
	name = enumconst,

#undef END_ENUM
#define END_ENUM(name) \
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\inc\profile.h ===
//-----------------------------------------------------------------------------

//  

//  File: profile.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//
//  LocStudio  profile marks
//
//-----------------------------------------------------------------------------

#include "icecap\icapexp.h"

// Marks for profiling

// Note: numbers must be > 1000 

const long MARK_GRIDONPAINT1 = 1001;
const long MARK_GRIDONPAINT2 = 1002;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\clstring.h ===
//-----------------------------------------------------------------------------

//  

//  File: clstring.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef CLSTRING_H
#define CLSTRING_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLString : public CString
{
public:
	CLString();
	CLString(const CLString& stringSrc);
	CLString(TCHAR ch, int nRepeat = 1);
	CLString(LPCSTR lpsz);
	CLString(LPCTSTR lpch, int nLength);
	CLString(const unsigned char* psz);
	CLString(HINSTANCE, UINT);
	
	BOOL ReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bMatchCase);

	// overloaded assignment
	NOTHROW const CLString& operator=(const CString& stringSrc);
	
	NOTHROW const CLString& operator=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator=(char ch);
#endif
	NOTHROW const CLString& operator=(LPCSTR lpsz);
	NOTHROW const CLString& operator=(const unsigned char* psz);

	// string concatenation
	NOTHROW const CLString& operator+=(const CString &);
	NOTHROW const CLString& operator+=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator+=(char ch);
#endif
	NOTHROW const CLString& operator+=(LPCTSTR lpsz);

	CLString operator+(const CString &) const;
	CLString operator+(LPCTSTR sz) const;

	NOTHROW BOOL LoadString(HMODULE, UINT nId);

	//
	//  The following were copied from CString so we can
	//  'overload' them.

	NOTHROW void Format(LPCTSTR lpszFormat, ...);
	NOTHROW void Format(HMODULE, UINT nFormatID, ...);

	enum ECRLF
	{
		eNone	= 0,
		eCR		= 0x0001,		// '\r'
		eLF		= 0x0002,		// '\n'
		eAll	= eCR | eLF
	};
	void FixCRLF(UINT nCRLF, LPCTSTR pszIndent = NULL);

	DEBUGONLY(~CLString());
protected:

private:
	DEBUGONLY(static CCounter m_UsageCounter);

	//
	//  Evil!  Implicit Unicode conversions!
	CLString(LPCWSTR lpsz);
	NOTHROW const CLString& operator=(LPCWSTR lpsz);
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clstring.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\blobfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _blobfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the position with in the file. The position can be set (by calling
//	'Seek()') beyond the end of the data in the file, even beyond the space 
//	allocated for the file. In any case, 'Read()' and 'Write()' will deal with
//	that.
//------------------------------------------------------------------------------
inline
DWORD	//Returns current file position 
CBlobFile::GetPosition() const
{
	ASSERT_VALID(this);
	return m_nPosition;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the actual data size in the file, which is what determines the end
//	of file during readings.
//------------------------------------------------------------------------------
inline
DWORD	//Returns the file data length in bytes.
CBlobFile::GetLength() const
{
	ASSERT_VALID(this);
	return m_nFileSize; 
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Since we keep the file in memory always, we don't need to flush.
//------------------------------------------------------------------------------
inline
void CBlobFile::Flush()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Aborting is like closing.
//------------------------------------------------------------------------------
inline
void CBlobFile::Abort()
{
	ASSERT_VALID(this);

	Close();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
void CBlobFile::LockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline 
void CBlobFile::UnlockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
CFile* CBlobFile::Duplicate() const
{
	AfxThrowNotSupportedException();
	return NULL;
}

inline
UINT CBlobFile::GetBlobSize(void) const
{
	ASSERT_VALID(this);
	return m_blobData.GetBlobSize();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	That's the only way to that a caller can have access to the buffer data
//	of the blobfile's internal cowblob.	  
//  
//-----------------------------------------------------------------------------
inline
CBlobFile::operator const CLocCOWBlob &(void)
{
	return GetBlob();
}

inline
const CLocCOWBlob &
CBlobFile::GetBlob(void)
{
 	if (m_pBuffer != NULL)
	{
		m_blobData.ReleasePointer();
		m_pBuffer = NULL;
	}
	//Set correct requested cowblob size before giving access to the data.
	m_blobData.ReallocBlob(m_nFileSize);
	return m_blobData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\blobfile.h ===
//-----------------------------------------------------------------------------

//  

//  File: _blobfile.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_BLOBFILE_H
#define ESPUTIL_BLOBFILE_H


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Class CBlobFile is similar to CMemFile, except that it is implemented 
//	with a CLocCOWBlob
//------------------------------------------------------------------------------
//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CFile is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CBlobFile : public CFile
{
	DECLARE_DYNAMIC(CBlobFile)

public:
	// Constructor
	CBlobFile(UINT nGrowBytes = 0);
	CBlobFile(const CLocCOWBlob &, UINT nGrowBytes = 0);
	
	virtual ~CBlobFile();

	virtual void AssertValid() const;
	UINT GetBlobSize(void) const;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

	//
	//  These operators can't work on const objects, since they
	//  'fix up' the blob size.
	//
	operator const CLocCOWBlob &(void);
	const CLocCOWBlob &GetBlob(void);
	
	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

protected:
	// Advanced Overridables
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void GrowFile(DWORD dwNewLen);

protected:
	// Implementation
	UINT m_nGrowBytes;	//unit of growth of 'm_blobData'
	const UINT cm_nDefaultGrowth; //default unit of growth
	DWORD m_nPosition;	//current position within file
	DWORD m_nFileSize;	//actual number of bytes written to the file
	CLocCOWBlob m_blobData; //file data
	BYTE * m_pBuffer;		//pointer to buffer in blob

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "blobfile.inl"
#endif

#endif  //  BLOBFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\clstring.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clstring.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All these methods re-direct to the CString methods.
//  
//-----------------------------------------------------------------------------
inline
CLString::CLString()
		:
		CString()
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const CLString &stringSrc)
		:
		CString(stringSrc)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		TCHAR ch,
		int nRepeat)
		:
		CString(ch, nRepeat)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCSTR lpsz)
		:
		CString(lpsz)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCTSTR lpch,
		int nLength)
		:
		CString(lpch, nLength)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const unsigned char * psz)
		:
		CString(psz)
{
	DEBUGONLY(++m_UsageCounter);
}



inline
CLString::CLString(
		HINSTANCE hDll,
		UINT uiStringID)
{
	LTVERIFY(LoadString(hDll, uiStringID));
	DEBUGONLY(++m_UsageCounter);
}



inline 
const CLString &
CLString::operator=(
		const CString& stringSrc)
{
	CString::operator=(stringSrc);

	return *this;
}

inline
const CLString &
CLString::operator=(
		TCHAR ch)
{
	CString::operator=(ch);

	return *this;
}


#ifdef _UNICODE

inline
const CLString &
CLString::operator=(
		char ch)
{
	CString::operator=(ch);

	return *this;
}

#endif //  _UNICODE

inline
const CLString &
CLString::operator=(
		LPCSTR lpsz)
{
	CString::operator=(lpsz);

	return *this;
}

inline
const CLString &
CLString::operator=(
		const unsigned char * psz)
{
	CString::operator=(psz);

	return *this;
}

inline
const CLString &
CLString::operator+=(
		const CString & string)
{
	CString::operator+=(string);

	return *this;
}



inline 
const CLString &
CLString::operator+=(
		TCHAR ch)
{
	CString::operator+=(ch);

	return *this;
}

		

#ifdef _UNICODE

inline
const CLString &
CLString::operator+=(
		char ch)
{
	CString::operator+=(ch);

	return *this;
}

#endif  // _UNICODE

inline
const CLString &
CLString::operator+=(
		LPCTSTR lpsz)
{
	CString::operator+=(lpsz);

	return *this;
}


inline
CLString
CLString::operator+(
		const CString &str)
		const
{
	return CLString(*this)+=str;
}



inline
CLString
CLString::operator+(
		const TCHAR *sz)
		const
{
	return CLString(*this)+=sz;
}



inline
void
CLString::Format(
		LPCTSTR lpszFormat, ...)
{

	//
	//  This stolen from CString::Format()
	//
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
	
}

inline
void
CLString::Format(
		HMODULE hResourceModule,
		UINT nFormatID, ...)
{
	CLString strFormat;
	LTVERIFY(strFormat.LoadString(hResourceModule, nFormatID) != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}


#ifdef _DEBUG
inline
CLString::~CLString()
{
	DEBUGONLY(--m_UsageCounter);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\diff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: diff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CDifference::~CDifference()
{
}

inline
CDelta::~CDelta()
{
}

inline
CDiffAlgorithm::~CDiffAlgorithm()
{
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Calculates the delta following the given algorithm and then traverses
//	the delta and calls back the delta visitor for each difference in the delta.
//------------------------------------------------------------------------------
inline
void 
CDiffEngine::Diff(
	CDiffAlgorithm & diffalg, 
	const wchar_t * seq1, // [in] old sequence
	const wchar_t * seq2, // [in] new sequence
	const CDeltaVisitor & dv)
{
	CDelta * d;
	d = diffalg.CalculateDelta(seq1, seq2);
	d->Traverse(dv);
	delete d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\dllvars.h ===
//-----------------------------------------------------------------------------

//  

//  File: dllvars.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

extern HINSTANCE g_hMITUtilDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\edithelp.h ===
//******************************************************************************

//  

//  EditHelp.h

//

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//******************************************************************************

#if !defined(MITUTIL__EditHelp_h__INCLUDED)
#define MITUTIL__EditHelp_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY EditHelp
{
	static BOOL SetTopLine(CEdit * pebc, int iLine);

	static BOOL CanUndo(CEdit * pebc);
	static BOOL CanRedo(CEdit * pebc);
	static BOOL CanCut(CEdit * pebc);
	static BOOL CanClear(CEdit * pebc);
	static BOOL CanPaste(CEdit * pebc);
	static BOOL CanCopy(CEdit * pebc);
	static BOOL CanSelectAll(CEdit * pebc);

	static BOOL Undo(CEdit * pebc);
	static BOOL Redo(CEdit * pebc);
	static void Cut(CEdit * pebc);
	static void Copy(CEdit * pebc);
	static void Clear(CEdit * pebc);
	static void Paste(CEdit * pebc);
	static void SelectAll(CEdit * pebc);
	
	static BOOL IsReadOnly(CEdit * pebc);
	static BOOL IsEnabled(CEdit * pebc, UINT nCmdID);

	static BOOL DoEditCmd(CEdit * pebc, UINT nCmdID);
};

#endif // MITUTIL__EditHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\counter.h ===
//-----------------------------------------------------------------------------

//  

//  File: counter.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_COUNTER_H
#define ESPUTIL_COUNTER_H


class LTAPIENTRY CCounter
{
public:
	CCounter(const TCHAR *);
	
	UINT operator++(void);
	UINT operator--(void);
	void operator+=(UINT);
	void operator-=(UINT);
	
	void Dump(void) const;
	
	~CCounter();
	
private:
	UINT m_uiCurCount;
	UINT m_uiMaxCount;
	UINT m_uiTotal;
	
	const TCHAR *m_szDescription;
};


//------------------------------------------------------------------------------
class LTAPIENTRY CSmartCheck
{
public:
	CSmartCheck(DWORD dwFreqMilli = 2000);

	void Reset();
	BOOL Check();

protected:
	DWORD	m_dwFreqMilli;
	DWORD	m_dwCancelTickMin;	// prevents calling fCancel() too often
	DWORD	m_dwCancelTickMax;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\cowblob.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cowblob.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for CLocCOWBlob.  This file should only be used by
//  cowblob.h
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the blob.  Set the current size to zero.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::CLocCOWBlob()
{
	m_pBuffer = NULL;
	m_WriteCount = 0;

	m_uiGrowSize = m_uiDefaultGrowSize;

	DEBUGONLY(++m_UsageCounter);
}




#ifdef LTASSERT_ACTIVE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the number of outstanding GetPointer()'s there are.
//  DEBUGONLY method!
//
//-----------------------------------------------------------------------------
inline
UINT
CLocCOWBlob::GetWriteCount(void)
		const
{
	return m_WriteCount;
}

#endif // _DEBUG



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the granularity for memory allocations.  Memory will always be
//  allocated in amounts that are a multiple of the GrowSize.  This can be
//  useful if you are making small incremental reallocs - by setting a larger
//  grow size, you will allocate memory less often (but some may end up
//  being unused).
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::SetGrowSize(
		UINT uiGrowSize)
{
	LTASSERT(uiGrowSize != 0);
	
	if (uiGrowSize == 0)
	{
		m_uiGrowSize = m_uiDefaultGrowSize;
	}
	else
	{
		m_uiGrowSize = uiGrowSize;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Release a writable pointer.  GetPointer and ReleasePointer should be
//  paired.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::ReleasePointer(void)
{
	LTASSERT(m_WriteCount != 0);

	if (m_WriteCount != 0)
	{
		m_WriteCount--;
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return a read only pointer to storage.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::operator const void *(void)
		const
{
	return DataPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor.  Just detaches this blob from the user memory.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::~CLocCOWBlob()
{
	DEBUGONLY(CLocCOWBlob::AssertValid());
	
	Detach();

	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob NOT equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs are NOT identical
CLocCOWBlob::operator!=(
		const CLocCOWBlob & SourceBlob)
		const
{
	return !Compare(SourceBlob);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob IS equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs ARE identical
CLocCOWBlob::operator==(
		const CLocCOWBlob & SourceBlob)
		const
{
	return Compare(SourceBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\diff.h ===
//-----------------------------------------------------------------------------

//  

//  File: diff.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration of the following classes needed for string differencing:
//	CDifference, CDelta, CDeltaVisitor, CDiffAlgorithm, CDiffAlgortihmFactory,
//	CDiffEngine  
//-----------------------------------------------------------------------------
 
#ifndef DIFF_H
#define DIFF_H


class CDifference;
class CDeltaVisitor;
class CDelta;
class CDiffAlgorithm;
class CDiffAlgortihmFactory;
class CDiffEngine;

class CDifference // Represents each of the elements in a CDelta object
{
public:
	virtual ~CDifference();
	enum ChangeType
	{
		NoChange,
		Added,
		Deleted
	};
	virtual ChangeType GetChangeType() const = 0;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const = 0; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const = 0; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const = 0;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const = 0; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const = 0; //append this string to unit string
	virtual bool IsFirst() const = 0; //is this first difference in delta?
	virtual bool IsLast() const = 0; //is this last difference in delta?
};

class LTAPIENTRY CDeltaVisitor
{
public:
	//called for each element in a CDelta
	virtual void VisitDifference(const CDifference & diff) const = 0; 
};

class CDelta // sequence of CDifference elements
{
public:
	virtual ~CDelta();
	// Starts a visit to all CDifference elements in CDelta
	virtual void Traverse(const CDeltaVisitor & dv) = 0; 
};

class LTAPIENTRY CDiffAlgorithm
{
public:
	virtual ~CDiffAlgorithm();
	// Computes a CDelta object based on a certain diff algorithm
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2) = 0; 
};

// Encapsulates the creation of the diff algorithm
class LTAPIENTRY CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm() = 0;
};



// Generic diff engine that calculates delta and processes each difference in it
class LTAPIENTRY CDiffEngine
{
public:
	static void Diff(CDiffAlgorithm & diffalg, 
		const wchar_t * seq1, 
		const wchar_t * seq2, 
		const CDeltaVisitor & dv);
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "diff.inl"
#endif

#endif  //  DIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\cowblob.h ===
//-----------------------------------------------------------------------------

//  

//  File: cowblob.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Copy-On-Write (COW) blob class.  Hold binary information, but only copies
//  the data when it's written to.
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 
#ifndef COWBLOB_H
#define COWBLOB_H


class LTAPIENTRY CLocCOWBlob 
{
public:
	CLocCOWBlob();
	CLocCOWBlob(const CLocCOWBlob &);

	void AssertValid(void) const;

	LTASSERTONLY(UINT GetWriteCount(void) const);
	
	UINT GetBlobSize(void) const;
	void SetBlobSize(UINT);
	void ReallocBlob(UINT);
	void SetGrowSize(UINT);
	
	void *GetPointer(void);
	void ReleasePointer(void);
	void SetBuffer(const void *, size_t);
	
	operator const void *(void) const;

	const CLocCOWBlob &operator=(const CLocCOWBlob &);
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	~CLocCOWBlob();

	//  Comparison operators
	//
	NOTHROW int operator==(const CLocCOWBlob &) const;
	NOTHROW int operator!=(const CLocCOWBlob &) const;

protected:

private:
	typedef struct
	{
		DWORD RefCount;
		DWORD AllocSize;
		DWORD RequestedSize;
	} BlobHeader;

	NOTHROW void Attach(const CLocCOWBlob &);
	NOTHROW void Detach(void);
	NOTHROW void MakeWritable(void);
	NOTHROW BYTE * DataPointer(void) const;
	NOTHROW BlobHeader * GetBlobHeader(void);
	NOTHROW const BlobHeader * GetBlobHeader(void) const;
	NOTHROW DWORD & GetRefCount(void);
	NOTHROW DWORD GetAllocatedSize(void) const;
	NOTHROW DWORD GetRequestedSize(void) const;
	NOTHROW DWORD CalcNewSize(DWORD) const;
	BOOL Compare(const CLocCOWBlob &) const;
	
	BYTE *m_pBuffer;
	DWORD m_WriteCount;
	UINT m_uiGrowSize;
	static const UINT m_uiDefaultGrowSize;

#ifdef _DEBUG
	static CCounter m_UsageCounter;
	void FillEndZone(void);
	void CheckEndZone();
#endif
	
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cowblob.inl"
#endif

#endif // COWBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\espnls.h ===
//-----------------------------------------------------------------------------

//  

//  File: espnls.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Language support functions for Espresso.
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_ESPNLS_H
#define ESPUTIL_ESPNLS_H


typedef int CodePage;
const CodePage cpInvalidCodePage = 0xDEADBEEF;
const CodePage US_ACP = 1252;

typedef WORD LangId;
const int BAD_LOCALE = 0xFFFF;

enum CodePageType
{
	cpUnknown,
	cpAnsi,
	cpDos,
	cpMac,
	cpUnicode
};


struct LanguageInfo
{
	LangId lid;
	CodePage cpAnsi;
	CodePage cpDos;
	CodePage cpMac;
	const TCHAR *szName;
	const TCHAR *szShortName;
	WORD fLangFlags;
};

const WORD lfNoFlags = 0;
const WORD lfDBCSHotKey = 0x0001;

typedef void (*pfnLangHandler)(const LanguageInfo &, void *);

class LTAPIENTRY CLocLangId 
{
public:
	CLocLangId(void);
	
	LTASSERTONLY(void AssertValid(void) const);

	NOTHROW LangId GetLanguageId(void) const;
	NOTHROW CodePage GetCodePage(CodePageType) const;
	NOTHROW void GetLangName(CLString &) const;
	NOTHROW void GetLangShortName(CLString &) const;
	
	NOTHROW BOOL SetLanguageId(LangId);
	NOTHROW const CLocLangId & operator=(const CLocLangId &);
	
	NOTHROW int operator==(const CLocLangId &) const;
	NOTHROW int operator!=(const CLocLangId &) const;
	
	NOTHROW static UINT GetNumLangInfo(void);
	static void EnumerateLanguages(pfnLangHandler, void *);
	static void Enumerate(CEnumCallback &);
	NOTHROW static BOOL IsDBCSHotKey(LangId);
	NOTHROW BOOL IsDBCSHotKey(void) const;
	NOTHROW static BOOL IsValidLangId(LangId lid);
	
	LTASSERTONLY(~CLocLangId());
	
private:
	//
	//  Private implementation.
	//
	NOTHROW static const LanguageInfo & LocateLangInfo(LangId);
	NOTHROW static const LanguageInfo & GetLangInfo(UINT);
	
	//
	//  Private data.
	//
	LangId m_lid;
	const LanguageInfo *m_pLangInfo;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "espnls.inl"
#endif

#endif // ESPUTIL_ESPNLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\flushmem.h ===
//-----------------------------------------------------------------------------

//  

//  File: flushmem.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFlushMemory : public CObject
{
public:
	CFlushMemory(BOOL fDelete);

	virtual void FlushMemory(void) = 0;

	void Delete(void);

private:
	CFlushMemory();
	CFlushMemory(const CFlushMemory &);
	void operator=(const CFlushMemory &);

	BOOL m_fDelete;
};



class LTAPIENTRY CMinWorkSet : public CFlushMemory
{
public:
	CMinWorkSet(BOOL fDelete);
	
	void FlushMemory(void);
};



#pragma warning(default: 4275)

void LTAPIENTRY NOTHROW AddFlushClass(CFlushMemory *);
BOOL LTAPIENTRY NOTHROW RemoveFlushClass(CFlushMemory *);

void LTAPIENTRY FlushMemory(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\gnudiffalg.h ===
//-----------------------------------------------------------------------------

//  

//  File: gnudiffalg.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration of the CGNUDiffAlgorithm, CGNUDiffAlgFact
//-----------------------------------------------------------------------------
 
#ifndef GNUDIFFALG_H
#define GNUDIFFALG_H

#include "diff.h"

class LTAPIENTRY CGNUDiffAlgorithm : public CDiffAlgorithm
{
public:
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2); 
};

class LTAPIENTRY CGNUDiffAlgFact : public CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm();
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "gnudiffalg.inl"
#endif

#endif  //  GNUDIFFALG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\listdelta.h ===
//-----------------------------------------------------------------------------

//  

//  File: listdelta.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration of CListDelta
//-----------------------------------------------------------------------------
 
#ifndef LISTDELTA_H
#define LISTDELTA_H

#include "diff.h"

class CListDelta : public CDelta, public CList<CDifference *, CDifference * &>
{
public:
	virtual ~CListDelta();
	virtual void Traverse(const CDeltaVisitor & dv); 
};

#endif  //  LISTDELTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\locid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  In line definitions for the CLocID class.  This fgile should ONLY be
//  included by locid.h
//  
//-----------------------------------------------------------------------------
 

//-----------------------------------------------------------------------------
//  
//  Implementation.  Clears the contents of the ID.  Both parts are marked
//  invalid.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::ClearId(void)
{
	m_fHasNumericId = FALSE;
	m_fHasStringId = FALSE;

	m_ulNumericId = 0;
	m_pstrStringId.ClearString();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constuctor for a localization ID.  Sets it to have no valid ID.
//  
//-----------------------------------------------------------------------------
inline
CLocId::CLocId()
{
	ClearId();

	DEBUGONLY(++m_UsageCounter);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the numeric ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL                              //  TRUE means the numeric ID is valid
CLocId::HasNumericId(void)
		const
{
	return m_fHasNumericId;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the string ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL							        //  TRUE means the string ID is valid
CLocId::HasStringId(void)
		const
{
	return m_fHasStringId;
}



inline
BOOL
CLocId::IsNull(void)
		const
{
	return
		!HasStringId() &&
		!HasNumericId();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current numeric ID.  If the ID is invalid, the ID will be
//  zero.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		ULONG &ulNumericId)				// Location to put ID
		const
{
	ulNumericId = m_ulNumericId;
	
	return m_fHasNumericId;
}

		

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current string ID.  If the ID is invalid, it will be a NULL
//  string.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		CPascalString &pstrStringId)	// Location to put the ID.
		const
{
	pstrStringId = m_pstrStringId;
	
	return m_fHasStringId;
}


//-----------------------------------------------------------------------------
//  
//  Checks if the ID has been assigned to before.  If it has, throw an
//  exception.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::CheckPreviousAssignment(void)
		const
{
	if (m_fHasStringId || m_fHasNumericId)
	{
		AfxThrowNotSupportedException();
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compares two ID's to see if they are the same.  
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator==(
		const CLocId &lidOther)			// ID to compare to
		const
{
	return IsIdenticalTo(lidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Checks for in-equality between two ID's
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator!=(
		const CLocId &lidOther)
		const
{
	return !IsIdenticalTo(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\loadlib.h ===
//-----------------------------------------------------------------------------

//  

//  File: loadlib.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Class to manage LoadLibray/FreeLibary style DLL usage.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOADLIB_H
#define ESPUTIL_LOADLIB_H


#pragma warning(disable : 4251)
class LTAPIENTRY CLoadLibrary
{
public:
	NOTHROW CLoadLibrary(void);
	NOTHROW CLoadLibrary(const CLoadLibrary &);

	NOTHROW BOOL LoadLibrary(const TCHAR *szFileName);
	NOTHROW BOOL FreeLibrary(void);

	NOTHROW void WrapLibrary(HINSTANCE);
	
	NOTHROW void operator=(const CLoadLibrary &);

	NOTHROW HINSTANCE GetHandle(void) const;
	NOTHROW HINSTANCE ExtractHandle(void);
	NOTHROW operator HINSTANCE(void) const;

	NOTHROW FARPROC GetProcAddress(const TCHAR *) const;
	
	NOTHROW const CString & GetFileName(void) const;
	
	NOTHROW ~CLoadLibrary();
	
private:
	CString m_strFileName;
	HINSTANCE m_hDll;
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "loadlib.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\espnls.inl ===
//-----------------------------------------------------------------------------
//  
//  File: espnls.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the language id object.  This file should ONLY be
//  included by espnls.h
//  
//-----------------------------------------------------------------------------
 

inline
LangId
CLocLangId::GetLanguageId(void)
		const
{
	return m_lid;
}



inline
void
CLocLangId::GetLangName(
		CLString &strLangName)
		const
{
	LTASSERT(m_lid != 0);
	
	strLangName = m_pLangInfo->szName;
}



inline
void
CLocLangId::GetLangShortName(
		CLString &strLangShortName)
		const
{

	strLangShortName = m_pLangInfo->szShortName;
}



inline
int
CLocLangId::operator==(
		const CLocLangId &lidOther)
		const
{
	return (m_lid == lidOther.GetLanguageId());
}



inline
int
CLocLangId::operator!=(
		const CLocLangId &lidOther)
		const
{
	return !operator==(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\gnudiffalg.inl ===
//-----------------------------------------------------------------------------
//  
//  File: gnudiffalg.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline implementation of CDumbDiffAlgorithm, CDumbDiffAlgFact
//-----------------------------------------------------------------------------
 
inline 
CDiffAlgorithm * 
CGNUDiffAlgFact::CreateDiffAlgorithm()
{
	return new CGNUDiffAlgorithm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\imagehelp.h ===
//-----------------------------------------------------------------------------

//  

//  File: imagehelp.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  This file is a re-director for IMAGEHLP.DLL.  Rather than linking directly
//  with the DLL (which may not exist on Win 95 systems), this class will
//  dynamically load IMAGEHLP.DLL and then provide certain functions from it.
//  The functions currently available are those that I found immediately
//  useful, so this is not a complete list of IMAGEHLP functionality.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_IMAGEHLP_H
#define ESPUTIL_IMAGEHLP_H




class LTAPIENTRY CImageHelp
{
public:
	CImageHelp();
	BOOL ImagehlpAvailable(void);
			
	BOOL EnumerateLoadedModules(HANDLE, PENUMLOADED_MODULES_CALLBACK, void *);
	PIMAGE_NT_HEADERS ImageNtHeader(LPVOID);

	LPAPI_VERSION ImagehlpApiVersion(void);
	BOOL StackWalk(
			DWORD                             MachineType,
			HANDLE                            hProcess,
			HANDLE                            hThread,
			LPSTACKFRAME                      StackFrame,
			LPVOID                            ContextRecord,
			PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
			PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
			PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
			PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
		);

	BOOL SymGetModuleInfo(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PIMAGEHLP_MODULE    ModuleInfo
		);
	LPVOID SymFunctionTableAccess(
			HANDLE  hProcess,
			DWORD   AddrBase
		);

	BOOL SymGetSymFromAddr(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PDWORD              pdwDisplacement,
			OUT PIMAGEHLP_SYMBOL    Symbol
		);

	BOOL SymInitialize(
			IN HANDLE   hProcess,
			IN LPSTR    UserSearchPath,
			IN BOOL     fInvadeProcess
		);

	BOOL SymUnDName(
			IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
			OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
			IN  DWORD            UnDecNameLength    // Size of the buffer
		);

	DWORD SymLoadModule(
			IN  HANDLE          hProcess,
			IN  HANDLE          hFile,
			IN  PSTR            ImageName,
			IN  PSTR            ModuleName,
			IN  DWORD           BaseOfDll,
			IN  DWORD           SizeOfDll
		);
	DWORD UnDecorateSymbolName(
			LPSTR    DecoratedName,         // Name to undecorate
			LPSTR    UnDecoratedName,       // If NULL, it will be allocated
			DWORD    UndecoratedLength,     // The maximym length
			DWORD    Flags                  // See IMAGEHLP.H
		);

	DWORD SymGetOptions(void);
	DWORD SymSetOptions(DWORD);
	
	PIMAGE_NT_HEADERS CheckSumMappedFile(
	    LPVOID BaseAddress,
	    DWORD FileLength,
	    LPDWORD HeaderSum,
	    LPDWORD CheckSum
	    );

	BOOL MakeSureDirectoryPathExists(const TCHAR *);
	
private:

	void LoadImageHelp(void);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\loadlib.inl ===
//-----------------------------------------------------------------------------
//  
//  File: loadlib.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
CLoadLibrary::CLoadLibrary(void)
{
	m_hDll = NULL;
}



inline
HINSTANCE
CLoadLibrary::GetHandle(void)
		const
{
	return m_hDll;
}



inline
CLoadLibrary::operator HINSTANCE(void)
		const
{
	return GetHandle();
}



inline
HINSTANCE
CLoadLibrary::ExtractHandle(void)
{
	HINSTANCE hReturn;

	hReturn = m_hDll;

	m_strFileName.Empty();
	m_hDll = NULL;

	return hReturn;
}

	   

inline
const CString &
CLoadLibrary::GetFileName(void)
		const
{
	return m_strFileName;
}



inline
BOOL
CLoadLibrary::LoadLibrary(
		const TCHAR *szFileName)
{
	LTASSERT(m_hDll == NULL);
	   
	m_strFileName = szFileName;
	m_hDll = AfxLoadLibrary(m_strFileName);

	return (m_hDll != NULL);
}



inline
void
CLoadLibrary::WrapLibrary(
		HINSTANCE hDll)
{
	m_hDll = hDll;
}



inline
CLoadLibrary::CLoadLibrary(
		const CLoadLibrary &llSource)
{
	m_hDll = NULL;

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
void
CLoadLibrary::operator=(
		const CLoadLibrary &llSource)
{
	LTASSERT(m_hDll == NULL);

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
FARPROC
CLoadLibrary::GetProcAddress(
		const TCHAR *szProcName)
		const
{
	FARPROC fpFunction = NULL;
	
	if (m_hDll != NULL)
	{
		fpFunction = ::GetProcAddress(m_hDll, szProcName);
	}

	return fpFunction;
}



inline
BOOL
CLoadLibrary::FreeLibrary(void)
{
	BOOL fRetVal = TRUE;
	
 	if (m_hDll != NULL)
	{
		fRetVal = AfxFreeLibrary(m_hDll);
		m_hDll = NULL;
		m_strFileName.Empty();
	}

	return fRetVal;
}



inline
CLoadLibrary::~CLoadLibrary()
{
	FreeLibrary();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\locid.h ===
//-----------------------------------------------------------------------------

//  

//  File: locid.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  This is the definition of a localization ID.  It makes up part of the
//  localization unique ID, and is eesentially the implementation for
//  CLocResId and CLocTypeId.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCID_H
#define LOCID_H

#pragma warning(disable : 4275)

class LTAPIENTRY CLocId : public CObject
{
public:
	NOTHROW CLocId();

	void AssertValid(void) const;

	BOOL NOTHROW HasNumericId(void) const;
	BOOL NOTHROW HasStringId(void) const;
	BOOL NOTHROW IsNull(void) const;
	
	BOOL NOTHROW GetId(ULONG &) const;
	BOOL NOTHROW GetId(CPascalString &) const;

	void NOTHROW GetDisplayableId(CPascalString &) const;

	//
	//  These 'set' functions are 'write once'.  Once the ID has been
	//  set, it can't be changed.  Trying to set the ID again will
	//  cause an AfxNotSupportedException to be thrown.
	//
	void SetId(ULONG);
	void SetId(const CPascalString &);
	void SetId(const WCHAR *);
	void SetId(ULONG, const CPascalString &);
	void SetId(ULONG, const WCHAR *);
	
	const CLocId &operator=(const CLocId &);

	void NOTHROW ClearId(void);
	
	int NOTHROW operator==(const CLocId &) const;
	int NOTHROW operator!=(const CLocId &) const;

	virtual void Serialize(CArchive &ar);

	virtual ~CLocId();

protected:
	//
	//  Internal implementation functions.
	//
	BOOL NOTHROW IsIdenticalTo(const CLocId&) const;
	void NOTHROW CheckPreviousAssignment(void) const;
	 
private:
	//
	//  This prevent the default copy constructor from being
	//  called.
	//
	CLocId(const CLocId&);

	ULONG m_ulNumericId;            //  The numeric ID of the resource
	CPascalString m_pstrStringId;   //  The string ID of the resource
	BOOL m_fHasNumericId :1;		//  Indicates if the numeric ID is valid
	BOOL m_fHasStringId  :1;		//  Indicates if the string ID is valid

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_DisplayCounter);
};
#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locid.inl"
#endif

#endif  //  LOCID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\locvar.h ===
//-----------------------------------------------------------------------------

//  

//  File: locvar.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration of CLocVariant, our variant class.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCVAR_H
#define ESPUTIL_LOCVAR_H


enum LocVariantType
{
	lvtNone,
	lvtInteger,
	lvtString,
	lvtIntPlusString,
	lvtBOOL,
	lvtBlob,
	lvtStringList,
	lvtFileName,			// stores file name and editing extension string
};


typedef CLocThingList<CPascalString> CPasStringList;

UINT StoreToBlob(const CPasStringList &, CLocCOWBlob &, UINT uiOffset);
UINT LoadFromBlob(CPasStringList &, const CLocCOWBlob &, UINT uiOffset);
#pragma warning(disable : 4275 4251)

class LTAPIENTRY CLocVariant : public CObject
{
public:
	NOTHROW CLocVariant();

	void AssertValid(void) const;

	NOTHROW LocVariantType GetVariantType(void) const;
	
	NOTHROW DWORD GetDword(void) const;
	NOTHROW BOOL GetBOOL(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	NOTHROW const CLocId & GetIntPlusString(void) const;
	NOTHROW const CLocCOWBlob & GetBlob(void) const;
	NOTHROW const CPasStringList & GetStringList(void) const;
	NOTHROW const CLString & GetFileExtensions(void) const;
	
	NOTHROW int operator==(const CLocVariant &) const;
	NOTHROW int operator!=(const CLocVariant &) const;
	
	NOTHROW void SetDword(const DWORD);
	NOTHROW void SetBOOL(const BOOL);
	NOTHROW void SetString(const CPascalString &);
	NOTHROW void SetIntPlusString(const CLocId &);
	NOTHROW void SetBlob(const CLocCOWBlob &);
	NOTHROW void SetStringList(const CPasStringList &);
	NOTHROW void SetFileName(const CPascalString &, const CLString &);
	
	NOTHROW const CLocVariant & operator=(const CLocVariant &);
	BOOL ImportVariant(const VARIANT& var);
	BOOL ExportVariant(VARIANT& var) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	NOTHROW BOOL IsEqualTo(const CLocVariant &) const;
	
private:
	CLocVariant(const CLocVariant &);

	
	LocVariantType m_VarType;

	//
	//  Class objects can't be in a union.
	//
	union
	{
		DWORD m_dwInteger;
		BOOL  m_fBOOL;
	};
	CPascalString  m_psString;
	CLocId         m_IntPlusString;
	CLocCOWBlob    m_Blob;
	CPasStringList m_StringList;
	CLString       m_strFileExtensions;
};

#pragma warning(default : 4275 4251)


void Store(CArchive &, const CPasStringList &);
void Load(CArchive &, CPasStringList &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locvar.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\ltdebug.h ===
//-----------------------------------------------------------------------------

//  

//  File: ltdebug.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Debugging facilities for Espresso 2.x.  Included are augmented TRACE
//  and ASSERT facilities.
//  
//-----------------------------------------------------------------------------
 
#ifndef MITUTIL_LtDebug_h_INCLUDED
#define MITUTIL_LtDebug_h_INCLUDED

#pragma once


#if defined(_DEBUG)
#define LTTRACE_ACTIVE
#define LTASSERT_ACTIVE

#define new DEBUG_NEW
#define LTGetAllocNumber() LTGetAllocNumberImpl()

//
//  Executes code only in a DEBUG build.
//
#define DEBUGONLY(x) x

#define LTDebugBreak() LTBreak()

#else  // _DEBUG

#define DEBUGONLY(x) 

#define LTDebugBreak() (void) 0
#define LTGetAllocNumber() 0

#endif  // _DEBUG

#if defined(LTASSERT_ACTIVE) || defined (ASSERT_ALWAYS)
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef VERIFY
#undef VERIFY
#endif
#define ASSERT LTASSERT
#define VERIFY LTVERIFY

#ifndef _DEBUG
#pragma message("Warning: LTASSERT Active in non-debug build")
#endif
//
// The multilevel assert macros ensure that the line numbers get expanded to
// something like "115" instead of "line" or "__LINE__"
//
// This will evaluate the expression only once, UNLESS to ask it to 'Retry'.
// Then it will re-evaluate the expression after the return from the debugger.
//
#define LTASSERTONLY(x) x

#define LTASSERT(x) LTASSERT2(x, TEXT(__FILE__), __LINE__)

#define LTASSERT2(exp, file, line)  \
        while (!(exp) && LTFailedAssert(TEXT(#exp), file, line)) (void) 0

#define LTVERIFY(x) LTASSERT(x)

#else // defined(_DEBUG) || defined(ASSERT_ALWAYS)

#define LTASSERTONLY(x)
#define LTASSERT(x) (void) 0
#define LTVERIFY(x) x

#endif // defined(_DEBUG) || defined(ASSERT_ALWAYS)


#ifndef MIT_NO_DEBUG
//
//  Name of the project
//
#ifndef LTTRACEPROJECT
#define LTTRACEPROJECT "Borg"
#endif

//
//  Default value for the exe name if one was not supplied.
//
#ifndef LTTRACEEXE
#define LTTRACEEXE MSLOC
#endif

//
//  Used to put quotes around the LTTRACEEXE macro.
//
#define __stringify2(x) #x
#define __stringify(x) __stringify2(x)

//
// TODO - find a better place for this

		LTAPIENTRY void CopyToClipboard(const char *szMessage);

		
		
struct LTModuleInfo
{
	UINT uiPreferredLoadAddress;
	UINT uiActualLoadAddress;
	UINT uiModuleSize;
	char szName[MAX_PATH];
};

LTAPIENTRY void LTInitDebug(void);

LTAPIENTRY void LTInstallIMallocTracking();
LTAPIENTRY void LTDumpIMallocs(void);
LTAPIENTRY void LTTrackIMalloc(BOOL f);
LTAPIENTRY void LTRevokeIMallocTracking();

LTAPIENTRY void LTShutdownDebug(void);

LTAPIENTRY BOOL LTSetAssertSilent(BOOL);
LTAPIENTRY BOOL LTFailedAssert(const TCHAR *, const TCHAR *, int);
LTAPIENTRY void LTBreak(void);

LTAPIENTRY LONG LTGetAllocNumberImpl(void);
LTAPIENTRY void LTBreakOnAlloc(const char *szFilename, int nLineNum, long nAllocNum);

LTAPIENTRY BOOL LTCheckBaseAddress(HMODULE);
LTAPIENTRY BOOL LTCheckAllBaseAddresses(void);
LTAPIENTRY void LTCheckPagesFor(HINSTANCE);
LTAPIENTRY void LTCheckPagesForAll(void);

LTAPIENTRY void LTDumpAllModules(void);
LTAPIENTRY BOOL LTLocateModule(DWORD dwAddress, HMODULE *pInstance);
LTAPIENTRY BOOL LTGetModuleInfo(HMODULE, LTModuleInfo *);

LTAPIENTRY UINT LTGenStackTrace(TCHAR *szBuffer, UINT nBuffSize,
		UINT nSkip, UINT nTotal);

LTAPIENTRY void LTSetBoringModules(const char *aszBoring[]);
LTAPIENTRY void LTTrackAllocations(BOOL);
LTAPIENTRY void LTDumpAllocations(void);

LTAPIENTRY BOOL LTCheckResourceRange(HINSTANCE, WORD UniqueStart, WORD UniqueEnd,
		WORD SharedStart, WORD SharedEnd);
LTAPIENTRY BOOL LTCheckAllResRanges(WORD, WORD);

#pragma warning(disable:4275)

class LTAPIENTRY CAssertFailedException : public CException
{
public:
	CAssertFailedException(const TCHAR *);
	CAssertFailedException(const TCHAR *, BOOL);

	BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
			PUINT pnHelpContext = NULL);

	~CAssertFailedException();
	
private:
	CAssertFailedException();
	CAssertFailedException(const CAssertFailedException &);

	TCHAR *m_pszAssert;
};



class LTAPIENTRY LTTracePoint
{
public:
	LTTracePoint(const TCHAR *);

	~LTTracePoint();

private:
	LTTracePoint();

	const TCHAR *m_psz;
};



#pragma warning(default:4275)

//
//  Comment this out to remove ASSERTs from retail builds
//  #define LTASSERT_ACTIVE


#if defined(LTTRACE_ACTIVE)


static const TCHAR *szLTTRACEEXE = TEXT(__stringify(LTTRACEEXE));

//
//  The following let us control the output dynamically.  We use a function
//  pointer to route our debug output, and change the function pointer to
//  enable/disable tracing.
//
static void LTTRACEINIT(const TCHAR *, ...);
static void (*LTTRACE)(const TCHAR *, ...) = LTTRACEINIT;

void LTAPIENTRY LTTRACEOUT(const TCHAR *szFormat, va_list args);
void LTAPIENTRY LTTRACEON(const TCHAR *szFormat, ...);
void LTAPIENTRY LTTRACEOFF(const TCHAR *szFormat, ...);


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  LTTRACE is initialized to point to this function.  When first called, it
//  determines if tracing should be enabled, then routes LTTRACE through the
//  right handler.
//  
//-----------------------------------------------------------------------------
static
void
LTTRACEINIT(
		const TCHAR *szFormat,			//  printf style formatting string
		...)							//  Variable argument list to format 
{
	BOOL fDoTrace = 1;
	va_list args;
	const TCHAR * const szTraceProfile = TEXT("lttrace.ini");

	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT("Default"),
			fDoTrace,
			szTraceProfile);
	
	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT(LTTRACEPROJECT),
			fDoTrace,
			szTraceProfile);
	
	if (fDoTrace)
	{
		fDoTrace = GetPrivateProfileInt(
				TEXT("ExecutableTracing"),
				szLTTRACEEXE,
				fDoTrace,
				szTraceProfile);
	}
	
	if (fDoTrace)
	{
		LTTRACE = LTTRACEON;
		
		va_start(args, szFormat);
		
		LTTRACEOUT(szFormat, args);
	}
	else
	{
		LTTRACE = LTTRACEOFF;
	}
}


#define LTTRACEPOINT(sz) LTTracePoint lttp##__LINE__(TEXT(sz))

#else // defined(LTTRACE_ACTIVE)

//
//  Retail version of the debugging macros.  Everything
//  just 'goes away'.  We use (void) 0 so that these things
//  are statements in both the debug and retail builds.
//

static inline void LTNOTRACE(const TCHAR *, ...) 
{}

#define LTTRACE 1 ? (void) 0 : (void) LTNOTRACE
#define LTTRACEPOINT(x) (void) 0

#endif  // defined(LTTRACE_ACTIVE)


#endif // MIT_NO_DEBUG


#endif // #ifndef MITUTIL_LtDebug_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\macros.h ===
//-----------------------------------------------------------------------------

//  

//  File: macros.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#define COUNTOF(x) (sizeof(x)/sizeof(*x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\mitenum.h ===
//-----------------------------------------------------------------------------

//  

//  File: mitenum.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#pragma once

//
//  This is the information we enumerate about enumerators.
//
struct EnumInfo
{
	const TCHAR *szDescription;
	const TCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const EnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CEnumCallback() {};

private:
	CEnumCallback(const CEnumCallback &);
	CEnumCallback &operator=(const CEnumCallback &);
};


//
struct WEnumInfo
{
	const WCHAR *szDescription;
	const WCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CWEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const WEnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CWEnumCallback() {};

private:
	CWEnumCallback(const CWEnumCallback &);
	CWEnumCallback &operator=(const CWEnumCallback &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\ltimalloc.h ===
//-----------------------------------------------------------------------------

//  

//  File: ltimalloc.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTIMallocSpy : public IMallocSpy
{
public:
	LTIMallocSpy();
	~LTIMallocSpy();

	
	//
	// IUnknown interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
	
	virtual ULONG STDMETHODCALLTYPE AddRef( void);
	
	virtual ULONG STDMETHODCALLTYPE Release( void);
	
private:

	//
	// IMallocSpy methods.
	virtual ULONG STDMETHODCALLTYPE PreAlloc( 
            /* [in] */ ULONG cbRequest);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void STDMETHODCALLTYPE PostFree( 
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual int STDMETHODCALLTYPE PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
	virtual void STDMETHODCALLTYPE PreHeapMinimize( void);
        
	virtual void STDMETHODCALLTYPE PostHeapMinimize( void);

	UINT m_uiRefCount;
	CCounter m_IMallocCounter;
	CCounter m_IMallocUsage;

	ULONG m_ulSize;
};


void DumpOutstandingAllocs(void);
void SetTrackingMode(BOOL);

void LTAPIENTRY BreakOnIMalloc(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\locvar.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locvar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the variant class.  This should ONLY be included from
//  locvar.h
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor.  Sets the variant type to none ie no value is in
//  the variant.
//  
//-----------------------------------------------------------------------------
inline
CLocVariant::CLocVariant()
{
	m_VarType = lvtNone;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the type of the data in the variant.
//  
//-----------------------------------------------------------------------------
inline
LocVariantType
CLocVariant::GetVariantType(void)
		const
{
	return m_VarType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the integer data in the variant.  The data must have been set
//  previously as an integer.
//  
//-----------------------------------------------------------------------------
inline
DWORD
CLocVariant::GetDword(void)
		const
{
	LTASSERT(m_VarType == lvtInteger || m_VarType == lvtStringList);

	if (m_VarType == lvtInteger)
	{
		return m_dwInteger;
	}
	else
	{
		return m_StringList.GetIndex();
	}
}



inline
BOOL
CLocVariant::GetBOOL(void)
		const
{
	LTASSERT(m_VarType == lvtBOOL);
	
	return m_fBOOL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string data in the variant.  The data must have been set
//  previously as an string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocVariant::GetString(void)
		const
{
	LTASSERT(m_VarType == lvtString || m_VarType == lvtFileName);
		
	return m_psString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the dual string/integer data in the variant.  The data must have
//  been set previously as an dual string/integer.
//  
//-----------------------------------------------------------------------------
inline
const CLocId &
CLocVariant::GetIntPlusString(void)
		const
{
	LTASSERT(m_VarType == lvtIntPlusString);

	return m_IntPlusString;
}



inline
const CLocCOWBlob &
CLocVariant::GetBlob(void)
		const
{
	LTASSERT(m_VarType == lvtBlob);

	return m_Blob;
}



inline
const CPasStringList &
CLocVariant::GetStringList(void)
		const
{
	LTASSERT(m_VarType == lvtStringList);

	return m_StringList;
}

inline
const CLString & 
CLocVariant::GetFileExtensions(void) 
	const
{
	LTASSERT(m_VarType == lvtFileName);

	return m_strFileExtensions;
}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator==(
		const CLocVariant &lvOther)
		const
{

	return IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator!=(
		const CLocVariant &lvOther)
		const
{
	return !IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to an integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetDword(
		const DWORD dwNewValue)
{
	m_VarType = lvtInteger;

	m_dwInteger = dwNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetBOOL(
		const BOOL fNewValue)
{
	m_VarType = lvtBOOL;

	m_fBOOL = fNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a CPascalString value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetString(
		const CPascalString &psNewValue)
{
	m_VarType = lvtString;

	m_psString = psNewValue;
}

inline
void 
CLocVariant::SetFileName(
	const CPascalString &psNewValue,
	const CLString & strExtensions)
{
	m_VarType = lvtFileName;

	m_psString = psNewValue;
	m_strFileExtensions = strExtensions;

}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a dual string/integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetIntPlusString(
		const CLocId &NewIntPlusString)
{
	m_VarType = lvtIntPlusString;

	m_IntPlusString = NewIntPlusString;
}



inline
void
CLocVariant::SetBlob(
		const CLocCOWBlob &blbNewValue)
{
	m_VarType = lvtBlob;

	m_Blob = blbNewValue;
}



inline
void
CLocVariant::SetStringList(
		const CPasStringList &slNewValue)
{
	m_VarType = lvtStringList;

	m_StringList = slNewValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\optionval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optionval.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
const CLString &
CLocOptionVal::GetName(void)
		const
{
	return m_strName;
}



inline
const CLocVariant &
CLocOptionVal::GetValue(void)
		const
{
	return m_lvValue;
}



inline
void
CLocOptionVal::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
void
CLocOptionVal::SetValue(
		const CLocVariant &lvValue)
{
	m_lvValue = lvValue;

	LTASSERTONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\optionval.h ===
//-----------------------------------------------------------------------------

//  

//  File: optionval.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionVal : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionVal();

	void AssertValid(void) const;

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	NOTHROW void SetName(const CLString &);
	NOTHROW void SetValue(const CLocVariant &);

	NOTHROW const CLString & GetName(void) const;
	NOTHROW const CLocVariant & GetValue(void) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	virtual ~CLocOptionVal();

private:
	CLString m_strName;
	CLocVariant m_lvValue;

};


class LTAPIENTRY CLocOptionValList :
	public CTypedPtrList<CPtrList, CLocOptionVal *>
{
public:
	NOTHROW CLocOptionValList();

	void AssertValid(void) const;

	NOTHROW ~CLocOptionValList();

private:
	CLocOptionValList(const CLocOptionValList &);

	void operator=(const CLocOptionValList &);
};


#pragma warning(default: 4275)


//
//  Worker function for options upgrade.
LTAPIENTRY void DorkData(BYTE *, DWORD &);


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optionval.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\redvisit.inl ===
//-----------------------------------------------------------------------------
//  
//  File: redvisit.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CRichEditDeltaVisitor::CRichEditDeltaVisitor(
	CRichEditCtrl & red) :
	m_red(red)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\redvisit.h ===
//-----------------------------------------------------------------------------

//  

//  File: redvisit.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration of CRichEditDeltaVisitor
//-----------------------------------------------------------------------------
 
#ifndef REDVISIT_H
#define REDVISIT_H

#include "diff.h"

class CRichEditCtrl;

class LTAPIENTRY CRichEditDeltaVisitor : public CDeltaVisitor
{
public:
	CRichEditDeltaVisitor(CRichEditCtrl & red);
	virtual void VisitDifference(const CDifference & diff) const; 

private: 
	CRichEditCtrl & m_red;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "redvisit.inl"
#endif

#endif  //  REDVISIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\optvalset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optvalset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocOptionValSet::AddOption(
		CLocOptionVal *pOption)
{
	m_olOptions.AddTail(pOption);
}



inline
void
CLocOptionValSet::AddOptionSet(
		CLocOptionValSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);
}



inline
void
CLocOptionValSet::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
const CLocOptionValList &
CLocOptionValSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocOptionValSetList &
CLocOptionValSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocOptionValSet::GetName(void)
		const
{
	return m_strName;
}



inline
BOOL
CLocOptionValSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void *
CLocOptionValSet::GetPExtra(void)
		const
{
	return m_pExtra;
}



inline
DWORD
CLocOptionValSet::GetDWExtra(void)
		const
{
	return m_dwExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		void *pExtra)
{
	m_pExtra = pExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		DWORD dwExtra)
{
	m_dwExtra = dwExtra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\passtr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: passtr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor for a Pascal string.  Sets the length to zero, with
//  no storage.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString()
{
	//
	//  The string data class is initialized by it's constructor.
	//
	LTASSERT(m_blbData.GetBlobSize() == 0);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator to convert a CPascalString to a blob.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const CLocCOWBlob &(void)
		const
{
	return m_blbData;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - CPascalString to CPascalString.  
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &                     // Allows a=b=c;
CPascalString::operator=(
		const CPascalString &pstrSource)  // Source string
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData = ((const CLocCOWBlob &)pstrSource);
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for CPascalString's
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString(
		const CPascalString &pstrSource)
{
	LTASSERT(pstrSource.m_blbData.GetWriteCount() == 0);
	 
	operator=(pstrSource);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - Wide character C String to CPascalString.  The string
//  is COPIED into the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &             //  Allows a=b=c;
CPascalString::operator=(
		const WCHAR *wszSource)   //  Source, zero terminated string
{
	SetString(wszSource, wcslen(wszSource));

	return *this;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Appends a CPascalString to the current string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &			        // Allows a=b+=c syntax
CPascalString::operator+=(
		const CPascalString &pstrTail)	// Pascal string to append
{
	AppendBuffer(pstrTail, pstrTail.GetStringLength());
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a NUL terminated Unicode string to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR *szTail)			// NUL terminated string to append
{
	AppendBuffer(szTail, wcslen(szTail));
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a Unicode character to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR wch)			// WCHAR to append
{
	AppendBuffer(&wch, 1);
	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Comparison function for Pascal strings.
//  
//-----------------------------------------------------------------------------
inline
BOOL                                                // TRUE (1) if the same
CPascalString::IsEqualTo(
		const CPascalString &pstrOtherString) const // String to compare to
{
	return m_blbData == (const CLocCOWBlob &)pstrOtherString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CPascalString::operator==(
		const CPascalString &pstrOtherString) // String to compare
		const
{
	return IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator != - just the negative of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int                                                 // TRUE (1) if *not* equal
CPascalString::operator!=(
		const CPascalString &pstrOtherString) const // String to compare
{

	return !IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL terminated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline
int
CPascalString::operator==(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL termninated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline int
CPascalString::operator!=(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is there anything in the string?  This is different from a string of zero
//  length.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CPascalString::IsNull(void)
		const
{
	return ((const void *)m_blbData == NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the length of the pascal string.  If the length is zero, there may be
//  no storage associated with the string.  Use IsNull to check for storage.
//  
//-----------------------------------------------------------------------------
inline
UINT                                         // length of the string.
CPascalString::GetStringLength(void) const
{
	UINT uiBufferSize;

	uiBufferSize = m_blbData.GetBlobSize();
	LTASSERT((uiBufferSize % sizeof(WCHAR)) == 0);
	
	return (uiBufferSize != 0 ? (uiBufferSize/sizeof(WCHAR)-1): 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the length of the pascal string.  String contents are not preserved
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::SetStringLength(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize((uNewSize + 1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Realloc a string - set true size
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::ReallocString(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.ReallocBlob((uNewSize +  1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  As an optimization, the user can ask the Pascal string to reserve some
//  memory for future growth.  This would allow incremental additions to be
//  very efficent.  The reported size of the string is not changed - only the
//  amount of storage reserved for the string.
//
//  If the user requests less space than is already allocated, nothing
//  happens.
//
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReserveStorage(
		UINT nMinSize)					// Size (in chars) to reserve for
{
	if (nMinSize > GetStringLength())
	{
		UINT uiCurSize;

		uiCurSize = GetStringLength();
		ReallocString(nMinSize);
		ReallocString(uiCurSize);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get a pointer to the storage for the string.  This may be NULL if the
//  string has length 0.  This pointer should be considered INVALID if any
//  other assignment operation is performed on the Pascal string.  Calling
//  this dis-ables teh COW behavior of the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
WCHAR *
CPascalString::GetStringPointer(void)
{
	return (WCHAR *)m_blbData.GetPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Anytime you do a GetStringPointer, use ReleaseStringPointer to allow
//  the PascalString to revert to COW behavior.  Once you call this, the
//  pointer from GetStringPointer is INVALID.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReleaseStringPointer(void)
{
	m_blbData.ReleasePointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator version of GetString pointer.  Cast a CPascalString to
//  const WCHAR *, and you get a pointer to the string.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const WCHAR *(void) const
{
	return (const WCHAR *)(const void *)(m_blbData);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleanup on the string.  Sets the length to zero, and remove all storage.
//  This is different than assigning a NULL string - that is a string of
//  length 1, consisting of the NUL (zero) character.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ClearString(void)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize(0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for a Pascal string.  Frees up the current storage.  After
//  a Pascal string goes out of scope, all pointers to the internal storage
//  are invalid.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::~CPascalString()
{
	LTASSERTONLY(AssertValid());
	DEBUGONLY(--m_UsageCounter);
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Serialize for a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
void CPascalString::Serialize(CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
void
CPascalString::Store(
		CArchive &ar)
		const
{
	LTASSERT(ar.IsStoring());
	LTASSERTONLY(AssertValid());

	//
	//  HACK HACK HACK
	//  Emulate Old Espresso 3.0 serialization.
	m_blbData.Store(ar);
	
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator==(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator!=(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) != 0);
}



inline
int CPascalString::operator!=(
		const _bstr_t &bsOther)
		const
{
	return !(operator==(bsOther));
}



inline
int
operator==(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr == bsOther;
}



inline
int
operator!=(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr != bsOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\path.h ===
//////////////////////////////////////////////////////////////////////
// PATH.H
//
// Definition of CPath and CDir objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 07-May-93	mattg		Created
// 12-May-93	danw		Add operator = and GetDisplayName
// 20-May-93	mattg		Added CDir object
// 22-May-93	danw		Added ConstructObject and DestructObject
//								for collections.
// 11-Jul-93	mattg		Added many new methods to CPath and CDir
//							Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
//////////////////////////////////////////////////////////////////////

#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <sys\stat.h>
#endif

#pragma warning(disable : 4275 4251)


size_t RemoveNewlines(_TCHAR *);

//
// Compatible_GetFileAttributesEx
// g_pGetFileAttributesEx initially points to a function that chooses the new win32 api,
// GetFileAttributesEx if supported, or selects a compatible function that uses FindFirstFile.
//
extern BOOL AFX_DATA (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CPath;
	class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class LTAPIENTRY CPath : public CObject
{
	DECLARE_DYNAMIC(CPath)

	friend	class		CDir;

	friend	static VOID		ConstructElement(CPath *);
	friend	static VOID		DestructElement(CPath *);

protected:
	// Data
			CString		m_strCanon;
			int		m_ichLastSlash;	// used to quickly extract only dir or filename
			BOOL		m_Flags;
			enum	PathFlags
				{
					eIsActualCase = 1,
					eWantsRelative = 2,
				};
				// Canonicalized representation of pathname.
			static CMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CPath(const CPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { ASSERT(this!=NULL); return (m_ichLastSlash > 0); }

			BOOL		Create(const TCHAR *);
				// Initialize the object, given a filename.  The resulting
				// canonicalized filename will be relative to the current
				// directory.  For example, if the current directory is
				// C:\TEST and the argument is "FOO.C", the resulting
				// canonicalized filename will be "C:\TEST\FOO.C".  If the
				// argument is "..\FOO.C", the resulting canonicalized
				// filename will be "C:\FOO.C".

			BOOL		CreateFromDirAndFilename(const CDir &, const TCHAR *);
				// Initialize the object given a directory (CDir object) and
				// a filename.  This behaves exactly the same as the Create()
				// method, except that the Create() method canonicalizes the
				// filename relative to the CURRENT directory, whereas this
				// method canonicalizes the filename relative to the SPECIFIED
				// directory.

			BOOL		CreateTemporaryName(const CDir &, BOOL fKeep = TRUE);
				// Initialize the object given a directory.  The resulting
				// object will represent a UNIQUE filename in that directory.
				// This is useful for creating temporary filenames.
				//
				// WARNING
				// -------
				// After this method returns, the filename represented by this
				// object will EXIST ON DISK as a zero length file.  This is
				// to prevent subsequent calls to this method from returning
				// the same filename (this method checks to make sure it
				// doesn't return the name of an existing file).  IT IS YOUR
				// RESPONSIBILITY to delete the file one way or another.
				//
				// If you don't want this behavior, pass FALSE for 'fKeep',
				// and the file will not exist on disk.  Be aware, though,
				// that if you do this, subsequent calls to this method may
				// return the same filename.

			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strCanon);
						}
				// Scan the pathname for special character.  We cache this
				// information.

	inline  CPath &		operator =(const CPath & path)
						{
							ASSERT(path.IsInit());
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
				// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
					{
						ASSERT(IsInit());
						ASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'));
						return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
					}

				// Return a pointer to the filename part of the canonicalized
				// pathname, i.e., the filename with no leading drive or path
				// information. Return whole string if no backslash (not init).
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

			VOID		PostFixNumber();
				// Modifies the path by postfixing a number on the end of the path's
				// basename. If there is no number on the end of the path's basename
				// then the number 1 is postfixed. Otherwise if there already is a
				// number on the end of the path's basename then that number is
				// incremented by 1 and postfixed on the end of the basename (less the
				// original number).
				//
				// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
			
			VOID		GetBaseNameString(CString &) const;
				// Creates a CString representing the base name of the fully
				// canonicalized pathname.  For example, the base name of
				// the pathname "C:\FOO\BAR.C" is "BAR".
				//
				// This method can't return a pointer to internal data like
				// some of the other methods since it would have to remove
				// the extension in order to do so.

			VOID  		GetDisplayNameString(
										CString &,
										int cchMax = 16,
										BOOL bTakeAllAsDefault = FALSE
										) const;
				// Creates a CString representing the name of the file
				// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
				// less.  Only the actual characters are counted; the
				// terminating '\0' is not considered, so
				// CString::GetLength() on the result MAY return as much as
				// cchMax.  If cchMax is less than the length of the base
				// filename, the resulting CString will be empty, unless
				// bTakeAllAsDefault is TRUE, in which the base name is
				// copied in, regardless of length.
				//
				// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
				// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
					{
						ASSERT(IsInit());
						int iDot = m_strCanon.ReverseFind(_T('.'));
 						if (iDot < m_ichLastSlash)
							iDot = m_strCanon.GetLength();
						const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 						return retval;
					}

				// Return a pointer to the extension part of the canonicalized
				// pathname.  Returns a pointer to the '.' character of the
				// extension.  If the filename doesn't have an extension,
				// the pointer returned will point to the terminating '\0'.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
				// Return a pointer to the full (canonicalized) pathname.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!
	inline	const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { ASSERT(this!=NULL); return ((m_Flags & eIsActualCase)!=0); }
	void GetActualCase(BOOL bEntirePath = FALSE);
				// Adjusts the paths case to match the actual path and filename
				// on disk.
	void SetActualCase(LPCTSTR pszFileCase); 
				// Adjusts the paths case to match the actual path and filename
				// on disk, where pszFileCase already contains the correct case
				// for just the filename portion.
	static void ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
				// Return the fully canonicalized filename as a (const TCHAR *).
				// Same thing as GetFullPath(), but more convenient in some
				// cases.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

			int			operator ==(const CPath &) const;
				// Returns 1 if the two CPaths are identical, 0 if they are
				// different.

	inline	int			operator !=(const CPath & path) const { return(!(operator ==(path))); }
				// Returns 1 if the two CPaths are different, 0 if they are
				// identical.

	// Modification methods

			VOID		ChangeFileName(const TCHAR *);
				// Changes the file name to that specified by the
				// (const TCHAR *) argument.  The directory portion of the
				// pathname remains unchanged.  DO NOT pass in anything
				// other than a simple filename, i.e., do not pass in
				// anything with path modifiers.

			VOID		ChangeExtension(const TCHAR *);
				// Changes the extension of the pathname to be that specified
				// by the (const TCHAR *) argument.  The argument can either be
				// of the form ".EXT" or "EXT".  If the current pathname has
				// no extension, this is equivalent to adding the new extension.

			BOOL 		GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
				// Makes the path name relative to the supplied directory and
				// placed the result in strResult.  Function will only go
				// down from the supplied directy (no ..'s).  Returns TRUE if
				// relativization was successful, or FALSE if not (e.g. if
				// string doesn't start with ".\" or ..\ or at least \).
				//
				// Thus, if the base directory is c:\sushi\vcpp32:
				//
				//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
				//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
				//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
				//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

				// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
				//
				// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
				// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

				// If bQuote is true, then quotes are put around the relative
				// file name. (Useful for writing the filename out to a file)

				// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
				// and if the file is on the same drive we will ALWAYS
				// relativize it. Thus for the base dir c:\sushi\vcpp32
				//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

			BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
				// THIS FUNCTION IS OBSOLETE.  New code should use
				// CreateFromDirAndFilename().  The only difference between
				// that function and this one is that this one will
				// automatically remove quotes from around the relative
				// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							ASSERT(IsInit());
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return TRUE;

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
				// Returns TRUE if the filename represented by this object
				// is read-only on disk, FALSE if not.  NOT guaranteed to
				// work in all circumstances -- for example, will not return
				// TRUE for a file on a floppy drive that has been write-
				// protected.  I don't know of any way to get this information
				// from NT (GetFileAttributes doesn't work; GetVolumeInformation
				// doesn't work; _access just calls GetFileAttributes; etc.).
				// This method WILL correctly detect:
				//		- Files marked as read-only
				//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							ASSERT(IsInit());
							return(_access(m_strCanon, 00) != -1);
						}
				// Returns TRUE if the filename represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
						{
							ASSERT(IsInit());
							if (!fOverwriteOK && ExistsOnDisk())
								return(FALSE);
							int hFile = _creat(m_strCanon, _S_IREAD | _S_IWRITE);
							BOOL fCreate = (hFile != -1);
							if (fCreate)
							{
								VERIFY(_close(hFile) == 0);
								VERIFY(_unlink(m_strCanon) == 0);
							}
							return(fCreate);
						}
				// Returns TRUE if the filename represented by this object
				// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							ASSERT(IsInit());
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
				// Removes the file represented by this object from the disk.

	BOOL GetFileTime(LPFILETIME lpftLastWrite);
	BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CMapPathToOb:

extern const CString AFX_DATA pthEmptyString;

static inline VOID ConstructElement(CPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath);
BOOL IsFileWritable(LPCTSTR szFilePath);

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class LTAPIENTRY CDir : public CObject
{
	DECLARE_DYNAMIC(CDir)

	friend	class		CPath;

	friend	static VOID		ConstructElement(CDir *);
	friend	static VOID		DestructElement(CDir *);

protected:
			CString		m_strDir;
				// Directory name, including drive letter or
				// server/share.  Do NOT make any assumptions
				// about whether or not this ends in '\'!

			// Creates multi level directories just fine
			BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDir() {}
	inline				CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDir();

			BOOL		CreateFromCurrent();
				// Initialize from the current working directory.  This
				// may fail if the current working directory is unknown
				// or invalid.

			BOOL		CreateFromPath(const CPath &);
				// Initialize based on the directory of the specified
				// CPath object.  That is, if the CPath object represents
				// the file "C:\FOO\BAR\BLIX.C", the resulting directory
				// for this object will be "C:\FOO\BAR".  Returns FALSE
				// on failure.

			BOOL		CreateFromPath(const TCHAR *pszPath);
				// Initialize based on the directory of the specified
				// string.  That is, if the string contains the file name
				// "C:\FOO\BAR\BLIX.C", the generated directory for this
				// string will be "C:\FOO\BAR".  Returns FALSE on failure.

			BOOL		CreateTemporaryName();
				// Initialize this object to represent a temporary directory
				// on disk (e.g., "C:\TMP").

			inline BOOL		CreateFromString(const TCHAR * sz)
					{
						return  CreateFromStringEx(sz, FALSE);
					}	
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!

			BOOL		CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!
				// same as CreateFromString with minor change. Not treating as bug fix to CFS
				// due to lateness in VC 4.0 project time

				// if fRootRelative true, treat dir ending with colon as relative not root dir 
				// (actual correct handling)


			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strDir);
						}
				// Scan the pathname for special character.  We cache this information.

	inline	CDir &		operator =(const CDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
				// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int GetLength() const { return m_strDir.GetLength(); }
	      // Returns the length of the directory name

	// Miscellaneous methods

	BOOL	MakeCurrent() const;
				// Make this object the current working directory.  May fail
				// if the directory no longer exists (e.g., a floppy drive).

	inline	BOOL		ExistsOnDisk() const
						{
							// Tests if the directory exists.  We return FALSE
							// if <m_strDir> exists but is not a directory
							struct _stat statDir;
							if (_stat(m_strDir, &statDir) == -1)
								return FALSE;		 // Not found.
							else if (!(statDir.st_mode & _S_IFDIR))
								return FALSE;		 // Not a directory.
							else
								return TRUE;
						}
				// Returns TRUE if the directory represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
				// Creates the directory on disk.  If this fails, returns
				// FALSE.  If the directory already existed on disk, returns
				// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
				// Removes the directory from the disk.  If this fails for
				// any reason (directory does not exist, directory is not
				// empty, etc.), returns FALSE.

			BOOL		IsRootDir() const;
				// Returns TRUE if the directory represented by this object
				// is a root directory (e.g., "C:\"), FALSE if not.  Note that
				// calling this method will NOT tell you whether or not the
				// string representation ends in '\', since "\\server\share"
				// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

			VOID		AppendSubdirName(const TCHAR *);
				// Adds a subdirectory name.  For example, if this object
				// currently represents "C:\FOO\BAR", and the argument is
				// "$AUTSAV$", the resulting object represents
				// "C:\FOO\BAR\$AUTSAV$".
				//
				// WARNING: This method does NO validation of the result --
				// it does not check for illegal characters, or for a
				// directory name that is too long.  In particular, don't
				// pass "DIR1/DIR2" as an argument, since no conversion
				// (of '/' to '\') will occur.

			VOID		RemoveLastSubdirName();
				// Removes the last component of the directory name.  For
				// example, if this object currently represents
				// "C:\FOO\BAR\$AUTSAV$", after this method it will
				// represent "C:\FOO\BAR".  If you try to call this method
				// when the object represents a root directory (e.g., "C:\"),
				// it will ASSERT.

	// Comparison methods

			int			operator ==(const CDir &) const;
				// Returns 1 if the two CDirs are identical, 0 if they are
				// different.

	inline	int			operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
				// Returns 1 if the two CDirs are different, 0 if they are
				// identical.
};

//	Creation and destruction functions used by CMapDirToOb:

static inline VOID ConstructElement(CDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class LTAPIENTRY CCurDir : CDir
{
public:
	CCurDir(const char* szPath, BOOL bFile = FALSE);
	CCurDir(const CDir& dir);
	CCurDir();	// just saves the current directory and resets it
	~CCurDir();

	CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class LTAPIENTRY CFileOpenReturn : CObject
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	int			m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CPtrArray	m_rgszNames;

public:
	CFileOpenReturn (const _TCHAR * szRawString = NULL);
	~CFileOpenReturn ();

	inline BOOL IsSingle () const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow () const;
	//inline int  GetLength () const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer (int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit (const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension (int i, const CString& szExt);

	void CopyBuffer (_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname (int i, CString& strPath) const;

private:
	void GenArrayFromBuffer ();
	void GenBufferFromArray ();
	void ClearNamesArray ();
	void SetBuffer (const _TCHAR * szRawString);	
};


inline BOOL CFileOpenReturn::IsSingle () const
{
	return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
#pragma warning(default : 4275 4251)

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\optvalset.h ===
//-----------------------------------------------------------------------------

//  

//  File: optvalset.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValEnumCallback : public CObject
{
public:
	CLocOptionValEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocOptionVal *) = 0;
	virtual BOOL ProcessOption(const CLocOptionVal *) = 0;
	
private:
	CLocOptionValEnumCallback(const CLocOptionValEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocOptionValSet;

class LTAPIENTRY CLocOptionValSetList :
	public CTypedPtrList<CPtrList, CLocOptionValSet *>
{
public:
	NOTHROW CLocOptionValSetList() {};

	void AssertValid(void) const;

	NOTHROW void ReleaseAll();
	NOTHROW ~CLocOptionValSetList();

private:
	CLocOptionValSetList(const CLocOptionValSetList &);
	void operator=(const CLocOptionValSetList &);
};

 
class LTAPIENTRY CLocOptionValSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionValSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocOptionVal *);
	NOTHROW void AddOptionSet(CLocOptionValSet *);
	NOTHROW void SetName(const CLString &);
	
	NOTHROW const CLocOptionValList & GetOptionList(void) const;
	NOTHROW const CLocOptionValSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindOptionVal(const CLString &, CLocOptionVal *&pOption);
	NOTHROW BOOL FindOptionVal(const CLString &, const CLocOptionVal *&pOption) const;
	NOTHROW const CLString & GetName(void) const;
	
	NOTHROW BOOL IsEmpty(void) const;
	
	BOOL EnumOptions(CLocOptionValEnumCallback *);
	BOOL EnumOptions(CLocOptionValEnumCallback *) const;
	
	//
	//  Escape hatch.
	//
	NOTHROW void * GetPExtra(void) const;
	NOTHROW DWORD GetDWExtra(void) const;
	NOTHROW void SetExtra(void *);
	NOTHROW void SetExtra(DWORD);

protected:
	NOTHROW virtual ~CLocOptionValSet();

private:
	CLocOptionValList m_olOptions;
	CLocOptionValSetList m_oslSubOptions;
	CLString m_strName;
	
	union
	{
		void *m_pExtra;
		DWORD m_dwExtra;
	};
	
	CLocOptionValSet(const CLocOptionValSet &);
	void operator=(const CLocOptionValSet &);
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optvalset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\refcount.h ===
//-----------------------------------------------------------------------------

//  

//  File: refcount.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



class LTAPIENTRY CRefCount
{
public:
	CRefCount();

	//
	//  Declared as STDMETHOD so as compatible with COM.
	//
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	//
	//
	ULONG AddRef(void) const;
	ULONG Release(void) const;
	
protected:
	
	virtual ~CRefCount() = 0;

private:

	CRefCount(const CRefCount &);
	const CRefCount & operator=(const CRefCount &);
	UINT operator==(const CRefCount &);
	
	mutable UINT m_uiRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\passtr.h ===
//-----------------------------------------------------------------------------

//  

//  File: passtr.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration for a pascal (counted) style wide character string class.
//  The count reflects the number of characters (including NUL characters),
//  not the amount of storage.  Any string in a PascalString is automatically
//  given a NULL terminator, even if it already has one.  This extra terminator
//  is NOT in the count of characters in the string.
//  
//-----------------------------------------------------------------------------
 
#ifndef PASSTR_H
#define PASSTR_H


class _bstr_t;

class CUnicodeException : public CSimpleException
{
public:
	enum UnicodeCause
	{
		noCause = 0,
		invalidChar = 1,
		unknownCodePage
	};

	UnicodeCause m_cause;

	NOTHROW CUnicodeException(UnicodeCause);
	NOTHROW CUnicodeException(UnicodeCause, BOOL);
	
	NOTHROW ~CUnicodeException();

	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError, 
		PUINT pnHelpContext = NULL );
};


void LTAPIENTRY ThrowUnicodeException(CUnicodeException::UnicodeCause);


class LTAPIENTRY CPascalString
{
public:
	NOTHROW CPascalString();
	NOTHROW CPascalString(const CPascalString &);

	void AssertValid(void) const;

	//
	//  The ultimate assignment operator - any random collection
	//  of WIDE characters can be placed in the string.
	//  Also, we can convert any collection of DBCS style strings,
	//  so long as the user provides a code page to work with...
	//
	void SetString(const WCHAR *, UINT);
	void SetString(const char *, UINT, CodePage);
	void SetString(const CLString &, CodePage);
	
	//
	//  Useful assignment operators
	//
	const CPascalString & operator=(const CPascalString &);
	const CPascalString & operator=(const WCHAR *);
	const CPascalString & operator=(const _bstr_t &);
	
	const CPascalString & operator+=(const CPascalString &);
	const CPascalString & operator+=(const WCHAR *);
	const CPascalString & operator+=(const WCHAR);

	void Format(const WCHAR *, ...);

	//
	//  Comparison operators for counted strings.
	//
	NOTHROW int operator==(const CPascalString &) const;
	NOTHROW int operator!=(const CPascalString &) const;

	NOTHROW int operator==(const _bstr_t &) const;
	NOTHROW int operator!=(const _bstr_t &) const;

	NOTHROW int operator==(const WCHAR *) const;
	NOTHROW int operator!=(const WCHAR *) const;
	
	NOTHROW BOOL IsNull(void) const;

	//
	//  Retrieving the data from the string.
	//
	NOTHROW UINT GetStringLength(void) const;
	void SetStringLength(UINT);
	void ReallocString(UINT);
	void ReserveStorage(UINT);

	NOTHROW WCHAR * GetStringPointer(void);
	NOTHROW void ReleaseStringPointer(void);

	NOTHROW operator const WCHAR *(void) const;
	// const BSTR GetBSTR(void) const;

	NOTHROW WCHAR operator[](UINT) const;
	NOTHROW WCHAR & operator[](UINT);

	//
	//  Sub-string extraction
	//
	NOTHROW void Left(CPascalString &, UINT) const;
	NOTHROW void Right(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT, UINT) const;

	//
	//  Locate
	//
	NOTHROW BOOL Find(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL FindOneOf(const CPascalString&, UINT, UINT &) const;
	NOTHROW BOOL FindExcept(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL FindSubString(const CPascalString &, UINT, UINT &) const;
	
	NOTHROW BOOL ReverseFind(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindOneOf(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindExcept(const CPascalString &, UINT, UINT &) const;
	
	//
	//  Clears the contents of a Pascal string.
	//
	NOTHROW void ClearString(void);

	//
	//  Conversion API's for Pascal style strings.
	//
	enum ConvFlags 
	{
		ConvNoFlags = 0,					// No conversion options
		HexifyDefaultChars = 0x01,			// Hexify chars that convert to the default char
		HexifyNonPrintingChars = 0x02,
		HexifyWhiteSpace = 0x04,
		ConvAddNull = 0x08,
		ConvAllFlags = 0xFF
	};
	
	void ConvertToCLString(CLString &, CodePage, BOOL fHex=FALSE) const;
	void ConvertToMBCSBlob(CLocCOWBlob &, CodePage, DWORD dwFlags = ConvNoFlags) const;
	NOTHROW void MakeUpper(void);
	NOTHROW void MakeLower(void);
	_bstr_t MakeBSTRT() const;
	
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	static const char *szUnmappableChar;
	static char cHexLeaderChar;
	
 	static void EscapeBackSlash(const CPascalString &srcStr, 
		CPascalString &destStr);

	int ParseEscapeSequences(CPascalString &pasError);
	
	~CPascalString();
 
protected:
	NOTHROW BOOL IsEqualTo(const CPascalString &) const;
	NOTHROW void AppendBuffer(const WCHAR *, UINT);
	
private:
	void FormatV(const WCHAR *, va_list arglist);
	
	CLocCOWBlob m_blbData;
	operator const CLocCOWBlob &(void) const;

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_StorageCounter);
};

typedef CArray<CPascalString, CPascalString &> CPasStringArray;
	
//
//  Comparison helper functions.  These should all have the
//  CPascalString as the SECOND arguement.
//
NOTHROW int LTAPIENTRY operator==(const WCHAR *, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const WCHAR *, const CPascalString &);

NOTHROW int LTAPIENTRY operator==(const _bstr_t &, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const _bstr_t, const CPascalString &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "passtr.inl"
#endif

#endif  //  PASSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mitutil.rc
//
#define IDS_BAD_UNICODE_CHAR            12700
#define IDS_BAD_CODE_PAGE               12701
#define IDS_UIVAL_ON                    12702
#define IDS_UIVAL_OFF                   12703
#define IDS_UIVAL_TRUE                  12704
#define IDS_UIVAL_FALSE                 12705
#define IDS_UIVAL_YES                   12706
#define IDS_UIVAL_NO                    12707
#define IDS_UIVAL_BLOB                  12708
#define IDS_HEX_MUST_BE_4DIGITS         12709
#define IDS_INVALID_ESCAPE              12710

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\reghelp.h ===
//******************************************************************************

//

// RegHelp.h : Collection of Registry helping functions

//

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL_RegHelp_h_INCLUDED)
#define MITUTIL_RegHelp_h_INCLUDED

#pragma once

//------------------------------------------------------------------------------
class LTAPIENTRY CRegHelp
{
public:
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, CString & stValue);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, DWORD & dwNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, long & nNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, VARIANT_BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, GUID & guid);
};

#endif // MITUTIL_RegHelp_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\smartptr.h ===
//-----------------------------------------------------------------------------

//  

//  File: smartptr.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SMARTPTR_H
#define ESPUTIL_SMARTPTR_H



template<class T>
class SmartPtr
{
public:
	NOTHROW SmartPtr();
	NOTHROW SmartPtr(T *);

	NOTHROW T & operator*(void) const;
	NOTHROW T * operator->(void) const;
	NOTHROW T* Extract(void);
	NOTHROW T* GetPointer(void);
	NOTHROW const T * GetPointer(void) const;
	NOTHROW BOOL IsNull(void) const;
	
	void operator=(T *);
	operator T* &(void);

	NOTHROW ~SmartPtr();
	
private:
	T *m_pObject;

	SmartPtr(const SmartPtr<T> &);
	void operator=(const SmartPtr<T> &);
	
	//
	//  This hackery prevents Smart Pointer from being on the heap
	//
	void operator delete(void *);
};

#include "smartptr.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\smartptr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: smartptr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

template <class T>
SmartPtr< T >::SmartPtr()
{
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::SmartPtr(
		T *pObject)
{
	m_pObject = pObject;
}



template <class T>
T &
SmartPtr< T >::operator*(void)
		const
{
	LTASSERT(m_pObject != NULL);
	return *m_pObject;
}



template <class T>
T *
SmartPtr< T >::operator->(void)
		const
{
	LTASSERT(m_pObject != NULL);
	
	return m_pObject;
}


template <class  T>
T *
SmartPtr< T >::Extract(void)
{
	T *pObj = m_pObject;
	m_pObject = NULL;

	return pObj;
}



template <class T>
T*
SmartPtr< T >::GetPointer(void)
{
	return m_pObject;
}


template <class T>
const T*
SmartPtr< T >::GetPointer(void) const
{
	return m_pObject;
}


template <class T>
BOOL
SmartPtr< T >::IsNull(void)
		const
{
	return m_pObject == NULL;
}



template <class T>
void
SmartPtr< T >::operator=(
		T *pObject)
{
	LTASSERT(m_pObject == NULL);

	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
	m_pObject = pObject;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  This should only be used to init a smart pointer.
//  
//-----------------------------------------------------------------------------
template <class T>
SmartPtr< T >::operator T * & (void)
{
	LTASSERT(m_pObject == NULL);
	
	return m_pObject;
}


template <class T>
void
SmartPtr< T >::operator delete(
		void *)
{
	LTASSERT(m_pObject != NULL);

	delete m_pObject;
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::~SmartPtr()
{
	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\smartref.h ===
//-----------------------------------------------------------------------------

//  

//  File: SmartRef.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SmartRef_H
#define ESPUTIL_SmartRef_H


template<class T>
class SmartRef
{
private:
	T *m_pInterface;

public:
	NOTHROW SmartRef()
	{
		m_pInterface = NULL;
	}

	//  Compiler bug, must be inline!
	NOTHROW SmartRef(T *pI) {m_pInterface = pI;};
	NOTHROW SmartRef(const SmartRef<T> &);

	NOTHROW T * operator->(void)
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW const T * operator->(void) const
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW T & operator*(void)
	{
		LTASSERT(m_pInterface != NULL);
		return *m_pInterface;
	}
	NOTHROW T * Extract(void)
	{
		return ExtractImpl();
	};
	
	NOTHROW T * GetInterface(BOOL fAddRef = FALSE)	
	{
		return GetInterfaceImpl(fAddRef);
	};

	NOTHROW const T * GetInterface(void) const
	{
		return m_pInterface;
	}
	
	NOTHROW BOOL IsNull(void) const
	{
		return m_pInterface == NULL;
	}
	
	NOTHROW ~SmartRef()
	{
		if (m_pInterface != NULL)
		{
			m_pInterface->Release();
		}
	}

	void operator=(T* pOther)
	{
		opEqImpl(pOther);
	}
	void operator=(const SmartRef<T> &other);

	T ** operator&(void);
	operator T* &(void) {return opTpRef();};
	
private:
	void operator delete(void *);

	NOTHROW T * ExtractImpl(void);
	NOTHROW T * GetInterfaceImpl(BOOL fAddRef);
	NOTHROW T * & opTpRef(void);
	void opEqImpl(T* pOther);

};

#include "SmartRef.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_

#pragma once


// StrigBlast requires the CString implicit conversions.
#ifdef _LS_NO_IMPLICIT
#undef _LS_NO_IMPLICIT
#endif // #ifdef _LS_NO_IMPLICIT

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>
#include <afxdisp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\stacktrace.h ===
//-----------------------------------------------------------------------------

//  

//  File: stacktrace.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Provides a mechanism for generating stacktraces and converting them to
//  human readable form.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STACKTRACE_H
#define ESPUTIL_STACKTRACE_H


const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;


//
//  'human readable' form of a stack-frame.  Provides module and function name.
struct SYMBOL_INFO
{
	DWORD dwAddress;
	DWORD dwOffset;
    TCHAR szModule[MODULE_NAME_LEN];
    TCHAR szSymbol[SYMBOL_NAME_LEN];
	BOOL fSymbolLocated;
};

#pragma warning(disable:4275)

//
//  How we return a complete human readable stack walk.
//
class LTAPIENTRY CSymbolList : public CTypedPtrList<CPtrList, SYMBOL_INFO *>
{
public:
	CSymbolList();

	void Clear(void);
	~CSymbolList();

private:
	CSymbolList(const CSymbolList &);
	void operator=(const CSymbolList &);
};

#pragma warning(default:4275)	

//
//  Class for generating stack traces.  Provides both native (compact) data
//  (in case you want to store it for later), and a human (versbose) form.
//
#pragma warning(disable : 4251)
class LTAPIENTRY CStackTrace
{
public:
	CStackTrace();

	~CStackTrace();

	void CreateStackTrace(void);
	void CreateStackTrace(UINT nSkip, UINT nTotal);
	void SetAddresses(const CDWordArray &);
	
	const CDWordArray &GetAddresses(void) const;

	void GetSymbolList(CSymbolList &) const;
	
private:
	CStackTrace(const CStackTrace &);
	void operator=(const CStackTrace &);

	CDWordArray m_adwAddresses;
};
#pragma warning(default : 4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\smartref.inl ===
//-----------------------------------------------------------------------------
//  
//  File: SmartRef.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 



template <class T>
SmartRef< T >::SmartRef(
		const SmartRef<T> &other)
{
	m_pInterface = const_cast<T *>(other.m_pInterface);
	m_pInterface->AddRef();
}



template <class T>
void
SmartRef< T >::operator=(
		const SmartRef<T> &pInterface)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = ((SmartRef<T> &)pInterface).GetInterface(TRUE);
}



template <class T>
T **
SmartRef< T >::operator&(void)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
		m_pInterface = NULL;
	}

	return &m_pInterface;
}



template <class T>
T *
SmartRef< T >::ExtractImpl(void)
{
	T *pInterface = m_pInterface;
	m_pInterface = NULL;
	return pInterface;
}


template <class T>
T *
SmartRef< T >::GetInterfaceImpl(
	BOOL fAddRef /*= FALSE*/)
{
	// Should never ask to AddRef with a NULL pointer

	LTASSERT(!fAddRef || NULL != m_pInterface);

	if (fAddRef)
	{
		m_pInterface->AddRef();
	}

	return m_pInterface;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// This should only be used to init a smart pointer.
// 
//-----------------------------------------------------------------------------
template <class T>
T * &
SmartRef< T >::opTpRef(void)
{
	LTASSERT(m_pInterface == NULL);
	
	return m_pInterface;
}


template <class T>
void
SmartRef< T >::opEqImpl(
		T *pOther)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = pOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\stringblast.h ===
//******************************************************************************

//

// StringBlast.h: Microsoft LocStudio

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL__StringBlast_h__INCLUDED)
#define MITUTIL__StringBlast_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY StringBlast
{
// Fast Win32 conversions
	static CLString MakeString(_bstr_t bstrSrc);
	static CLString MakeString(const CPascalString & pasSrc);
	static CLString MakeStringFromBStr(BSTR bstrSrc);
	static CLString MakeStringFromWide(const wchar_t * szwSrc);

	static _bstr_t MakeBStr(const char * szBuffer);
	static _bstr_t MakeBStrFromWide(const wchar_t * wszBuffer);
	static _bstr_t MakeBStr(const CLString & stSrc);
	static _bstr_t MakeBStrFromBStr(BSTR bstrSrc);
	static _bstr_t MakeBStr(const CPascalString & pasSrc);
	static _bstr_t MakeBStr(HINSTANCE hDll, UINT nStringID);

	// Use these functions when you need to get a raw BSTR
	static BSTR MakeDetachedBStr(const char * szBuffer);
	static BSTR MakeDetachedBStrFromWide(const wchar_t * wszBuffer);
	static BSTR MakeDetachedBStr(const CLString & stSrc);

};

#endif // MITUTIL__StringBlast_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\strlist.h ===
//-----------------------------------------------------------------------------

//  

//  File: strlist.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STRLIST_H
#define ESPUTIL_STRLIST_H


const UINT NO_INDEX = (DWORD) -1;
	
template<class T>
class CLocThingList
{
	
public:
	NOTHROW CLocThingList();

	UINT NOTHROW GetIndex(void) const;
	const CArray<T, T&> &GetStringArray(void) const;
	BOOL NOTHROW AdditionsAllowed(void) const;

	void SetThingList(const CArray<T, T&> &);
	UINT AddThing(T &);
	void InsertThing(UINT idxInsert, T & tNew);
	BOOL DeleteThing(UINT);
	BOOL NOTHROW SetIndex(UINT);
	void NOTHROW SetAdditionsAllowed(BOOL);
	UINT GetSize();

	const CLocThingList<T> &operator=(const CLocThingList<T> &);
	int NOTHROW operator==(const CLocThingList<T> &) const;
	int NOTHROW operator!=(const CLocThingList<T> &) const;
	
	NOTHROW ~CLocThingList();

private:
	CLocThingList(const CLocThingList<T> &);

	UINT m_uiIndex;
	CArray<T, T&> m_aThings;
	BOOL m_fAdditionsAllowed;
};

#include "strlist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\stringtokenizer.h ===
//-----------------------------------------------------------------------------

//  

//  File: StringTokenizer.h

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//
//  This file declares the CStringTokenizer class, which implements simple
//  linear tokenization of a String. The set of delimiters, which defaults
//  to common whitespace characters, may be specified at creation time or on a 
//  per-token basis.
//  Example usage:
//	CString s = "a test string";
//	CStringTokenizer st = new CStringTokenizer(s);
//	while (st.hasMoreTokens())
//  {
//		cout << st.nextToken() << endl;
//	}
//-----------------------------------------------------------------------------
#pragma once

#ifndef StringTokenizer_h
#define StringTokenizer_h

class LTAPIENTRY CStringTokenizer 
{
public:
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//-----------------------------------------------------------------------------
  CStringTokenizer();
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//   str - in, the string to be tokenized
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str, const WCHAR* delimiters);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str,
                   const WCHAR* delimiters,
                   BOOL  returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// destructs this tokenizer
//-----------------------------------------------------------------------------
  virtual ~CStringTokenizer();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// configure whether return delimiter as token
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  void setReturnTokens(BOOL returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// sets delimiters
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  void setDelimiters(const WCHAR* delimiters);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// parse a string to be tokenized
//   str - in, the null terminated string
//-----------------------------------------------------------------------------
  void parse(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// checks whether there are more tokens
//-----------------------------------------------------------------------------
  BOOL hasMoreTokens();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// get next token
//   length - out, the length of the token
//   return the pointer to the begining of the token
//-----------------------------------------------------------------------------
  const WCHAR* nextToken(unsigned int & length);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// count total number of tokens
//-----------------------------------------------------------------------------
  int     countTokens();

private:
  void skipDelimiters();
  int  IsDelimiter(WCHAR ch) const;

  int          m_currentPosition;
  int          m_maxPosition;
  const WCHAR* m_str;
  WCHAR*       m_delimiters;
  int          m_lenDelimiters;
  BOOL         m_retTokens;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\uioptions.h ===
//-----------------------------------------------------------------------------

//  

//  File: uioptions.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


class CReport;

#pragma warning(disable : 4251)

class LTAPIENTRY CLocUIOptionData
{
public:

	enum OptVal
	{
		ovCurrent,
		ovDefault,
		ovUser,
		ovOverride
	};
	
	CLocOptionVal *GetOptionValue(OptVal);

	CLocOptionVal *GetOptionValue(OptVal) const;
	
	void SetOptionValue(OptVal, CLocOptionVal *);
	BOOL Purge(void);
	
private:
	SmartRef<CLocOptionVal> m_spCurrentVal;
	SmartRef<CLocOptionVal> m_spUserVal;
	SmartRef<CLocOptionVal> m_spOverrideVal;
};


class CLocUIOptionSet;

class LTAPIENTRY CLocUIOption: public CLocOptionVal
{
public:
	CLocUIOption();

	void AssertValid(void) const;

	//
	//  New editor types should go at the END, so that old parsers
	//  can still use the ENUM without being re-compiled..
	//
	enum EditorType
	{
		etNone,
		etInteger,						// Maps to lvtInteger
		etUINT,							// Maps to lvtInteger
		etString,						// Maps to lvtString
		etFileName,						// Maps to lvtFileName
		etDirName,						// Maps to lvtString
		etStringList,					// Maps to lvtStringList
		etPickOne,						// Maps to lvtStringList
		etCheckBox,						// Maps to lvtBOOL
		etTrueFalse,					// Maps to lvtBOOL
		etYesNo,						// Maps to lvtBOOL
		etOnOff,						// Maps to lvtBOOL
		etCustom,						// Custom editor
	};

	//
	//  Used as bit flags to indicate where the option can be stored.
	enum StorageType
	{
		stUser = 0x0001,
		stOverride = 0x0002
	};

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	void NOTHROW SetDescription(const HINSTANCE hDll, UINT nDescriptionID);
	void NOTHROW SetHelpText(const HINSTANCE hDll, UINT nHelpTextId);
	void NOTHROW SetEditor(EditorType);
	void NOTHROW SetStorageTypes(WORD);
	void NOTHROW SetDisplayOrder(UINT);
	
	void NOTHROW GetDescription(CLString &) const;
	void NOTHROW GetHelpText(CLString &) const;
	EditorType NOTHROW GetEditor(void) const;
	WORD NOTHROW GetStorageTypes(void) const;
	UINT NOTHROW GetDisplayOrder(void) const;
	CLocUIOptionData::OptVal GetOptionValLocation(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
	virtual const CLString &GetGroupName(void) const = 0;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const = 0;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE) = 0;
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var) = 0;

protected:
	virtual ~CLocUIOption();

	friend class CLocUIOptionSet;
	friend class CLocOptionManager;
	friend class CUpdateOptionValCallback;
	
	void SetParent(CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

	const CLocUIOptionData &GetOptionValues(void) const;
	CLocUIOptionData &GetOptionValues(void);
	
private:
	HINSTANCE m_hDescDll, m_hHelpDll;
	UINT m_idsDesc, m_idsHelp;
	EditorType m_etEditor;
	WORD m_wStorageTypes;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet *m_pParent;
	CLocUIOptionData m_Values;
};


// Validate callback function
// This function will be called during the ValidateOption handling.

typedef CLocUIOption::OptionCode (*PFNOnValidateUIOption)
	(const CLocUIOption *pOption, CReport *pReport, const CLocVariant&);
 
class LTAPIENTRY CLocUIOptionDef : public CLocUIOption
{
public:
	CLocUIOptionDef();
	
	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);
	
	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;
	virtual const CLString &GetGroupName(void) const;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE);
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var);

	void SetValidationFunction(PFNOnValidateUIOption);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
	PFNOnValidateUIOption m_pfnValidate;
};

	

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionList :
	public CTypedPtrList<CPtrList, CLocUIOption *>
{
public:
	NOTHROW CLocUIOptionList();

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionList();
 
private:
	CLocUIOptionList(const CLocUIOptionList &);

	void operator=(const CLocUIOptionList &);
};

#pragma warning(default: 4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptions.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\strlist.inl ===
//-----------------------------------------------------------------------------
//  
//  File: strlist.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

template <class T>
CLocThingList<T>::CLocThingList()
{
	m_fAdditionsAllowed = FALSE;
	m_uiIndex = NO_INDEX;
}


template <class T>
UINT
CLocThingList<T>::GetIndex(void)
		const
{
	return m_uiIndex;
}



template <class T>
const CArray<T, T&> &
CLocThingList<T>::GetStringArray(void)
		const
{
	return m_aThings;
}



template <class T>
BOOL
CLocThingList<T>::AdditionsAllowed(void)
		const
{
	return m_fAdditionsAllowed;
}



template <class T>
void
CLocThingList<T>::SetThingList(
		const CArray<T, T&> &aNewThings)
{
	UINT uiNewSize = aNewThings.GetSize();
	
	m_aThings.SetSize(uiNewSize);

	for (UINT i=0; i<uiNewSize; i++)
	{
		m_aThings[i] = aNewThings[i];
	}
}



template <class T>
inline
UINT
CLocThingList<T>::AddThing(
		T &NewThing)
{
	return m_aThings.Add(NewThing);
}


template <class T>
inline
void
CLocThingList<T>::InsertThing(
		UINT idxInsert, 
		T & tNew
		)
{
	m_aThings.InsertAt(idxInsert, tNew);
}


template <class T>
inline
BOOL
CLocThingList<T>::DeleteThing(
		UINT iIndex)
{
    BOOL fRetVal = FALSE;
	if (iIndex < GetSize())
	{
		m_aThings.RemoveAt(iIndex);
		fRetVal = TRUE;
	}
	return fRetVal;	
}



template <class T>
inline
BOOL
CLocThingList<T>::SetIndex(
		UINT uiNewIndex)
{
	m_uiIndex = uiNewIndex;
	return FALSE;
}



template <class T>
inline
void
CLocThingList<T>::SetAdditionsAllowed(
		BOOL fAllowed)
{
	m_fAdditionsAllowed = fAllowed;
}


template <class T>
inline
UINT
CLocThingList<T>::GetSize()
{
	return m_aThings.GetSize();
}


template <class T>
const CLocThingList<T> &
CLocThingList<T>::operator=(
		const CLocThingList<T>& slOther)
{
	SetThingList(slOther.GetStringArray());
	SetIndex(slOther.GetIndex());

	SetAdditionsAllowed(slOther.AdditionsAllowed());
	
	return *this;
}


template <class T>
CLocThingList<T>::~CLocThingList()
{
	m_aThings.SetSize(0);
}

template <class T>
inline
int 
CLocThingList<T>::operator==(
		const CLocThingList<T>& list)
		const
{
	if (m_uiIndex != list.m_uiIndex
		|| m_fAdditionsAllowed != list.m_fAdditionsAllowed
		|| m_aThings.GetSize() != list.m_aThings.GetSize())
	{
		return 0;
	}

	for (int i=m_aThings.GetUpperBound(); i>=0; i--)
	{
		if (m_aThings[i] != list.m_aThings[i])
		{
			return 0;
		}
	}
	
	return 1;
}

template <class T>
inline
int 
CLocThingList<T>::operator!=(
		const CLocThingList<T>& list)
		const
{
	return !(operator==(list));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\uiopthelp.h ===
//-----------------------------------------------------------------------------

//  

//  File: uiopthelp.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Class used to represent a single 'option'.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

//
// Base structure
//
struct UI_OPTS_BASE
{
	TCHAR* pszName;				   // internal name of the option 
	UINT nDisplayName;			   // string id of the display name
	UINT nDisplayHelp;			   // string id of the help string
	PFNOnValidateUIOption pfnVal;    // function to call during validation. 
	                               // This may be null
	WORD wStorageTypes;			   // storage type of option	
	CLocUIOptionDef::ControlType wReadOnly;	  // ReadOnly value
	CLocUIOptionDef::ControlType wVisible;	  // Visible value
};



// Structures of option data

//
// BOOL options
//

struct UI_OPTS_BOOL
{
	UI_OPTS_BASE base;                // base class data 
	BOOL bDefValue;				   // default value of the option
	CLocUIOption::EditorType et;     // type of BOOL option
};

//
//  PICK options
//

struct UI_OPTS_PICK
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	BOOL bAdd;					   // allow additions to the list	
	UINT nListEntries;             // list of entries to pick from
	                               // Each entry is separated by \n
	                               // The last entry does not have a \n
};

const TCHAR UI_PICK_TERMINATOR = _T('\n');

// 
// DWORD options

struct UI_OPTS_DWORD
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	CLocUIOption::EditorType et;     // type of DWORD option
};


//
// String options
//
struct UI_OPTS_STR
{
	UI_OPTS_BASE base;                // base class data 
	UINT nDefValue;				   // string table entry for default value 
	CLocUIOption::EditorType et;
};


//
//  String list options
//

struct UI_OPTS_STRLIST
{
	UI_OPTS_BASE base;					// base class data 
	UINT nDefList;						// Each entry is separated by \n
										// The last entry does not have a \n
};


//
// File Name options
//
struct UI_OPTS_FILENAME
{
	UI_OPTS_BASE base;                // base class data 
	UINT nExtensions;	    		  // The default extensions to the UI
	UINT nDefValue;			  	      // string table entry for default value 
};


//
// Helper class definition
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionImpHelper : public CObject
{
public:

	CLocUIOptionImpHelper(HINSTANCE hInst);

	void GetOptions(CLocUIOptionSet *pOptionSet, UINT nDesc, UINT nHelp);
	
	void SetBools(const UI_OPTS_BOOL* pBools, int nCntBools);
	void SetPicks(const UI_OPTS_PICK* pPicks, int nCntPicks);
	void SetDwords(const UI_OPTS_DWORD* pDwords, int nCntDwords);
	void SetStrs(const UI_OPTS_STR* pStrs, int nCntStrs);
	void SetStrLists(const UI_OPTS_STRLIST* pStrLists, int nCntStrLists);
	void SetFNames(const UI_OPTS_FILENAME* pFNames, int nCntFNames);

	void AssertValid(void) const;

protected:
	HINSTANCE m_hInst;

	const UI_OPTS_BOOL* m_pBools;
	int m_nCntBools;

	const UI_OPTS_PICK* m_pPicks;
	int m_nCntPicks;

	const UI_OPTS_DWORD* m_pDwords;
	int m_nCntDwords;

	const UI_OPTS_STR* m_pStrs;
	int m_nCntStrs;

	const UI_OPTS_STRLIST* m_pStrLists;
	int m_nCntStrLists;

	const UI_OPTS_FILENAME* m_pFNames;
	int m_nCntFNames;

	void GetBoolOptions(CLocUIOptionSet* pOptionSet);
	void GetPicksOptions(CLocUIOptionSet* pOptionSet);
	void GetDwordsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrListsOptions(CLocUIOptionSet* pOptionSet);
	void GetFNamesOptions(CLocUIOptionSet* pOptionSet);

	void GetListFromId(UINT nId, CPasStringList& pasList);
	void GetStringFromId(UINT nId, CPascalString& pas);
};

#pragma warning(default : 4275)

//
// Helper macros for building data structures
//
// The _EXT versions of the macros allow setting the less common
// attributes (readonly and visible)
//


// BOOL
#define BEGIN_LOC_UI_OPTIONS_BOOL(var) \
const UI_OPTS_BOOL var[] =    \
{								 

#define LOC_UI_OPTIONS_BOOL_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_BOOL_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_BOOL() \
}                             



// Pick
#define BEGIN_LOC_UI_OPTIONS_PICK(var) \
const UI_OPTS_PICK var[] = \
{

#define LOC_UI_OPTIONS_PICK_ENTRY(name, def, add, list, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, add, list}

#define LOC_UI_OPTIONS_PICK_ENTRY_EXT(name, def, add, list, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, add, list}

#define END_LOC_UI_OPTIONS_PICK() \
}


// DWORD
#define BEGIN_LOC_UI_OPTIONS_DWORD(var) \
const UI_OPTS_DWORD var[] =    \
{								 

#define LOC_UI_OPTIONS_DWORD_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault},def, et}

#define LOC_UI_OPTIONS_DWORD_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible},def, et}

#define END_LOC_UI_OPTIONS_DWORD() \
}


// String
#define BEGIN_LOC_UI_OPTIONS_STR(var) \
const UI_OPTS_STR var[] =    \
{								 

#define LOC_UI_OPTIONS_STR_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_STR_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_STR() \
}


// String List
#define BEGIN_LOC_UI_OPTIONS_STRLIST(var) \
const UI_OPTS_STRLIST var[] =    \
{								 

#define LOC_UI_OPTIONS_STRLIST_ENTRY(name, def, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def}

#define LOC_UI_OPTIONS_STRLIST_ENTRY_EXT(name, def, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def}

#define END_LOC_UI_OPTIONS_STRLIST() \
}

// File Names
#define BEGIN_LOC_UI_OPTIONS_FILENAME(var) \
const UI_OPTS_FILENAME var[] =    \
{								 

#define LOC_UI_OPTIONS_FILENAME_ENTRY(name, def, id, idHelp, idExt, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, idExt, def}

#define LOC_UI_OPTIONS_FILENAME_ENTRY_EXT(name, def, id, idHelp, idExt, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, idExt, def}

#define END_LOC_UI_OPTIONS_FILENAME() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\worddiff.h ===
//-----------------------------------------------------------------------------

//  

//  File: worddiff.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Declaration of the CWordDiff
//-----------------------------------------------------------------------------
 
#ifndef WORDDIFF_H
#define WORDDIFF_H

typedef _bstr_t CWordUnit;

class CWordDiff : public CDifference
{
public:
	CWordDiff(ChangeType type, 
		int nOldPos,
		int nNewPos,
		bool bIsFirst,
		bool bIsLast,
		_bstr_t bstrWord,
		const wchar_t * pwszPrefix,
		const wchar_t * pwszSufix);

	virtual ChangeType GetChangeType() const;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const; //append this string to unit string
	virtual bool IsFirst() const; //is this first difference in delta?
	virtual bool IsLast() const; //is this last difference in delta?

private:
	ChangeType m_ChangeType;
	CWordUnit m_Word;
	const wchar_t * m_pwszPrefix;
	const wchar_t * m_pwszSufix;
	bool m_bIsFirst;
	bool m_bIsLast;
	int m_nOldPos;
	int m_nNewPos;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "worddiff.inl"
#endif

#endif  //  WORDDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\uioptions.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptions.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------




inline
CLocUIOption::CLocUIOption()
{
	m_hDescDll = NULL;
	m_hHelpDll = NULL;
	m_idsDesc = 0;
	m_idsHelp = 0;
	m_etEditor = etNone;

	m_wStorageTypes = 0;
	m_uiDisplayOrder = 0;

	m_pParent = NULL;
}



inline
void
CLocUIOption::SetDescription(
		const HINSTANCE hDll,
		UINT nDescriptionID)
{
	m_hDescDll = hDll;
	m_idsDesc = nDescriptionID;
}



inline
void
CLocUIOption::SetHelpText(
		const HINSTANCE hDll,
		UINT nHelpTextId)
{
	m_hHelpDll = hDll;
	m_idsHelp = nHelpTextId;
}



inline
void
CLocUIOption::SetEditor(
		EditorType et)
{
	m_etEditor = et;
}


inline
void
CLocUIOption::SetStorageTypes(
		WORD wStorageTypes)
{
	m_wStorageTypes = wStorageTypes;
}



inline 
CLocUIOption::EditorType
CLocUIOption::GetEditor(void) 
		const
{
	return m_etEditor;
}



inline
void
CLocUIOption::GetDescription(
		CLString &strDesc)
		const
{
	LTASSERT(m_hDescDll != NULL);
	LTASSERT(m_idsDesc != 0);
	
	strDesc.LoadString(m_hDescDll, m_idsDesc);
}



inline
void
CLocUIOption::GetHelpText(
		CLString &strHelp)
		const
{
	LTASSERT(m_hHelpDll != NULL);
	LTASSERT(m_idsHelp != 0);

	strHelp.LoadString(m_hHelpDll, m_idsHelp);
}



inline
WORD
CLocUIOption::GetStorageTypes(void)
		const
{
	return m_wStorageTypes;
}



inline
void
CLocUIOption::SetParent(
		CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}



inline
const CLocUIOptionSet *
CLocUIOption::GetParent(void)
		const
{
	return m_pParent;
}



inline
const CLocUIOptionData &
CLocUIOption::GetOptionValues(void) const
{
	return m_Values;
}



inline
CLocUIOptionData &
CLocUIOption::GetOptionValues(void)
{
	return m_Values;
}

inline
void CLocUIOptionDef::SetReadOnly(
	ControlType ct)
{
	m_ctReadOnly = ct;		
}	

inline
void CLocUIOptionDef::SetVisible(
	ControlType ct)
{
	m_ctVisible = ct;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\uioptset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocUIOptionSet::AddOption(
		CLocUIOption *pOption)
{
	m_olOptions.AddTail(pOption);

	pOption->SetParent(this);
}



inline
void
CLocUIOptionSet::AddOptionSet(
		CLocUIOptionSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);

	pOptionSet->SetParent(this);
}


inline
const CLocUIOptionList &
CLocUIOptionSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocUIOptionSetList &
CLocUIOptionSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocUIOptionSet::GetGroupName(void)
		const
{
	if (GetParent() != NULL)
	{
		return GetParent()->GetGroupName();
	}
	else
	{
		return m_strGroup;
	}
}

inline
UINT 
CLocUIOptionSet::GetDisplayOrder()
	 const
{
	return m_uiDisplayOrder;	
}	


inline
void
CLocUIOptionSet::SetDescription(
		const HINSTANCE hDll,
		UINT idsDesc)
{
	m_strDesc.LoadString(hDll, idsDesc);
}



inline
void
CLocUIOptionSet::SetDescription(
		const CLString &strDesc)
{
	m_strDesc = strDesc;
}


inline
void
CLocUIOptionSet::SetHelpText(
		const HINSTANCE hDll,
		UINT idsHelp)
{
	m_strHelp.LoadString(hDll, idsHelp);
}



inline
void
CLocUIOptionSet::SetHelpID(UINT uiHelpId)
{
	m_idHelp = uiHelpId;
}



inline
void
CLocUIOptionSet::SetGroupName(
		const TCHAR *szGroupName)
{
	m_strGroup = szGroupName;
}




inline
void
CLocUIOptionSet::SetHelpText(
		const CLString &strHelp)
{
	m_strHelp = strHelp;
}



inline
void
CLocUIOptionSet::GetDescription(
		CLString &strDesc)
		const
{
	strDesc = m_strDesc;
}



inline
void
CLocUIOptionSet::GetHelpText(
		CLString &strHelp)
		const
{
	strHelp = m_strHelp;
}



inline
UINT
CLocUIOptionSet::GetHelpID(void)
		const
{
	return m_idHelp;
}



inline
BOOL
CLocUIOptionSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void
CLocUIOptionSet::SetParent(
		const CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}

inline
void 
CLocUIOptionSet::SetDisplayOrder(
	UINT uiDisplayOrder)
{
	m_uiDisplayOrder = uiDisplayOrder;
}	


inline
const
CLocUIOptionSet *
CLocUIOptionSet::GetParent(void)
		const
{
	return m_pParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\worddiff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: worddiff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of CWordDiff
//-----------------------------------------------------------------------------
 
#include "ltdebug.h"

inline
CWordDiff::CWordDiff(
	CDifference::ChangeType type, 
	int nOldPos,
	int nNewPos,
	bool bIsFirst,
	bool bIsLast,
	_bstr_t bstrWord,
	const wchar_t * pwszPrefix,
	const wchar_t * pwszSufix) :
	m_ChangeType(type), m_Word(bstrWord), m_pwszPrefix(pwszPrefix),
	m_pwszSufix(pwszSufix), m_bIsFirst(bIsFirst), m_bIsLast(bIsLast),
	m_nOldPos(nOldPos), m_nNewPos(nNewPos)

{
	LTASSERT(pwszPrefix != NULL);
	LTASSERT(pwszSufix != NULL);
	LTASSERT(nOldPos >= -1);
	LTASSERT(nNewPos >= -1);
}

inline
CDifference::ChangeType 
CWordDiff::GetChangeType() 
const
{
	return m_ChangeType;
}

inline
const wchar_t * 
CWordDiff::GetUnit() 
const
{
	return m_Word;
}

inline
int 
CWordDiff::GetOldUnitPosition() 
const 
{
	return m_nOldPos;
}

inline
int 
CWordDiff::GetNewUnitPosition() 
const
{
	return m_nNewPos;
}

inline
const wchar_t * 
CWordDiff::GetPrefix() 
const
{
	return m_pwszPrefix;
}

inline
const wchar_t * 
CWordDiff::GetSufix() 
const
{
	return m_pwszSufix;
}

inline
bool 
CWordDiff::IsFirst() 
const
{
	return m_bIsFirst;
}

inline
bool 
CWordDiff::IsLast() 
const
{
	return m_bIsLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\mit\mitutil\uioptset.h ===
//-----------------------------------------------------------------------------

//  

//  File: uioptset.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CLocUIOption;
class CLocUIOptionList;

class LTAPIENTRY CLocUIOptionEnumCallback : public CObject
{
public:
	CLocUIOptionEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocUIOption *) = 0;
	virtual BOOL ProcessOption(const CLocUIOption *) = 0;
	
private:
	CLocUIOptionEnumCallback(const CLocUIOptionEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocUIOptionSet;

class LTAPIENTRY CLocUIOptionSetList :
	public CTypedPtrList<CPtrList, CLocUIOptionSet *>
{
public:
	NOTHROW CLocUIOptionSetList() {};

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionSetList();

private:
	CLocUIOptionSetList(const CLocUIOptionSetList &);
	void operator=(const CLocUIOptionSetList &);
};


//
//  This is used to control the order of the tabs displayed in the options
//  dialog.
enum OptionSetDisplayOrder
{
	osDefault = 50
};



class LTAPIENTRY CLocUIOptionSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocUIOptionSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocUIOption *);
	NOTHROW void AddOptionSet(CLocUIOptionSet *);
	NOTHROW void RemoveOptionSet(const TCHAR *);
	
	NOTHROW const CLocUIOptionList & GetOptionList(void) const;
	NOTHROW const CLocUIOptionSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindUIOption(const TCHAR *, CLocUIOption *&pOption);
	NOTHROW BOOL FindUIOption(const TCHAR *, const CLocUIOption *&pOption) const;
	
	NOTHROW void SetDescription(const HINSTANCE hDescDll, UINT idsDesc);
	NOTHROW void SetDescription(const CLString &);
	NOTHROW void SetHelpText(const HINSTANCE hHelpDll, UINT idsHelp);
	NOTHROW void SetHelpText(const CLString &);
	NOTHROW void SetHelpID(UINT);
	void SetGroupName(const TCHAR *);
	NOTHROW void SetDisplayOrder(UINT);
	
	NOTHROW void GetDescription(CLString &) const;
	NOTHROW void GetHelpText(CLString &) const;
	NOTHROW UINT GetHelpID(void) const;
	NOTHROW BOOL IsEmpty(void) const;
	const CLString &GetGroupName(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
		
	BOOL EnumOptions(CLocUIOptionEnumCallback *);
	BOOL EnumOptions(CLocUIOptionEnumCallback *) const;
	
	virtual void OnChange(void) const = 0;
	
protected:
	NOTHROW virtual ~CLocUIOptionSet();

	void SetParent(const CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

private:
	CLocUIOptionList m_olOptions;
	CLocUIOptionSetList m_oslSubOptions;
	CLString m_strDesc, m_strHelp;
	UINT m_idHelp;
	const CLocUIOptionSet *m_pParent;
	CLString m_strGroup;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet(const CLocUIOptionSet &);
	void operator=(const CLocUIOptionSet &);
};


class LTAPIENTRY CLocUIOptionSetDef : public CLocUIOptionSet
{
public:
	CLocUIOptionSetDef();

	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);

	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;

	virtual void OnChange(void) const;

	const CLocUIOptionSetDef & operator=(const CLocUIOptionSetDef &);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parseman\pdesc.h ===
//-----------------------------------------------------------------------------

//  

//  File: pdesc.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PARSEMAN_PDESC_H
#define PARSEMAN_PDESC_H

typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

//
//  This class is used to gather all the file descriptions before
//  we write them into the registry.  
//
class CFileDescriptionsCallback : public CEnumCallback
{
public:
	CFileDescriptionsCallback();
	
	BOOL ProcessEnum(const EnumInfo &);
	
	const FileDescriptionList &GetFileDescriptions(void) const;
	
	~CFileDescriptionsCallback();
	
private:
	FileDescriptionList m_FileDescriptions;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parseman\pmanager.h ===
//-----------------------------------------------------------------------------

//  

//  File: pmanager.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PMANAGER_H
#define PMANAGER_H


#pragma warning(disable : 4251)

typedef CTypedPtrMap<CMapWordToPtr, ParserId, CLocParserInfo *> CLocParserMap;
typedef CTypedPtrMap<CMapStringToPtr, CString, CLocParserList *> CLocExtMap;
typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

interface ILocFile;
struct ParserInfo;

class CParserUnloader;

class LTAPIENTRY CLocParserManager : public CLObject
{
	friend CLocParserInfo;
public:
	CLocParserManager();
	
	void AssertValid(void) const;
	
	BOOL InitParserManager(IUnknown *);
	static BOOL ReloadRegistry(void);
	static void UnloadParsers(void);
	static void UnloadUnusedParsers(void);
	
	static void GetManagerVersion(DWORD &dwMajor, DWORD &dwMinor, BOOL &fDebug);
	static BOOL AddParserToSystem(const CLString &);
	static const CLocParserInfo *GetParserInfo(ParserId pid, ParserId pidParent);
	static BOOL RemoveParserFromSystem(ParserId pid, ParserId pidParent);
	static UINT FindParsers(void);
	
	static BOOL GetLocParser(ParserId, ILocParser *&);
	static BOOL GetLocFile(const CFileSpec &, ParserId, FileType,
			ILocFile *&, CReporter &);
	static BOOL FindLocFile(const CPascalString &, CLocParserIdArray &);
	static BOOL GetStringValidation(ParserId, ILocStringValidation *&);
	
	static const CLocParserList &GetParserList(void);

	static void GetParserFilterString(CLString &);

	~CLocParserManager();

protected:
	static void RemoveCurrentInfo(void);
	static BOOL LoadParserInfo(const HKEY &, CLocParserInfo *&);
	static BOOL LoadMasterParserInfo(const HKEY &);
	static BOOL LoadSubParsers(const HKEY &, CLocParserInfo *);
	static BOOL WriteFileTypes(const HKEY &, const FileDescriptionList &);
	
	static BOOL OpenParserSubKey(HKEY &, ParserId, ParserId);
	static BOOL AddParserToRegistry(const CLString &, const ParserInfo &,
			const FileDescriptionList &);

	static void AddToFilter(const CLocParserInfo *, const CLocExtensionList &);

private:
	static LONG             m_lRefCount;    // 
	static CLocParserMap    m_ParserMap;    // Associative map, ID -> Parser.
	static CLocParserList   m_ParserList;   // List of open parser DLL's.
	static CLocParserList   m_SubParserList;// list of all sub-parsers.
	static CLocExtMap       m_ExtensionMap;	// Associative map, extension->parser.
	static CLString         m_strFilter;    // Filter list for parser files.
	static IUnknown *       m_pUnknown;
	static CParserUnloader  m_Unloader;
};


//
//  Undecorated versions of these functions for GetProcAddress users...
//
extern "C"
{
	LTAPIENTRY HRESULT AddParserToSystem(const TCHAR *strFileName);
	LTAPIENTRY HRESULT RemoveParserFromSystem(ParserId pid, ParserId pidParent);
}

		
#pragma warning(default : 4251)

#endif // PMANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parseman\unloader.h ===
//-----------------------------------------------------------------------------

//  

//  File: uloader.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class CParserUnloader : public CFlushMemory
{
public:
	CParserUnloader(BOOL fDelete);
	
	void FlushMemory(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parseman\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
#include <afxtempl.h>

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parseman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parseman.rc
//
#define IDS_PARSEMAN_CONTEXT            12700
#define IDS_BAD_VERSION                 12701
#define IDS_FILT_ALL_FILES              12702
#define IDS_DEBUG_MISMATCH              12703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parseman\pinfo.h ===
//-----------------------------------------------------------------------------

//  

//  File: pinfo.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Class that holds information about a parser.
//  
//-----------------------------------------------------------------------------
 
#ifndef PINFO_H
#define PINFO_H


class CLocParserManager;

class CLocParserInfo;
typedef CTypedPtrList<CPtrList, CLocParserInfo *> CLocParserList;

#pragma warning(disable : 4251)

interface ILocParser;
interface ILocStringValidation;

class LTAPIENTRY CLocParserInfo : public CLObject
{
public:

	void AssertValid(void) const;

	const CLString &GetParserName(void) const;
	const CLString &GetParserDescription(void) const;
	const CLString &GetParserHelp(void) const;
	ParserId GetParserId(void) const;
	BOOL GetDllVersion(CLString &) const;
	const CLocExtensionList &GetExtensionList() const;
	const CLocParserList &GetSubParserList(void) const;

	~CLocParserInfo();

protected:
	friend CLocParserManager;
	
	CLocParserInfo();

	HINSTANCE GetParserHandle(void) const;
	ILocParser * GetParserPointer(void) const;
	ILocStringValidation *GetValidationPointer(void);
	
	BOOL LoadParserDll(void);
	BOOL InitSubParsers(ILocParser *);
	
	BOOL FreeParserDll(void);
	BOOL AttemptUnload(void);
	
	BOOL IsLoaded(void) const;
	
	void SetParserName(const CLString &);
	void SetParserDescription(const CLString &);
	void SetParserHelp(const CLString &);
	
	void SetParserId(ParserId);
	BOOL SetExtensionList(const CLString  &);
	void AddSubParser(CLocParserInfo *);
	void AddExtensions(const CLocExtensionList &);
	CLocParserList &GetSubParserList(void);

	clock_t GetLastAccessTime(void) const;
	
	static BOOL LoadParserDll(const CLString &strFileName,
			CReporter *pReporter, HMODULE &hDll, ILocParser *&pLocParser);
	static BOOL GetParserObjects(CReporter *, CLoadLibrary &, ILocParser *&);
	
private:
	
	CLString m_strParserName;
	CLString m_strParserDescription;
	CLString m_strParserHelp;
	CLocExtensionList m_elExtList;
	ParserId m_pidParserId;
	HINSTANCE m_hParserDll;
	ILocParser *m_pParserObject;
	ILocStringValidation *m_pValidationObject;
	BOOL m_fLoadAttempted;
	BOOL m_fValidationTried;
	UINT m_uiSubParserUsageCount;
	mutable clock_t m_tLastAccess;
	
	CLocParserList m_pSubParsers;
};

#pragma warning(default : 4251)



#endif  // PINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\locchild.h ===
//-----------------------------------------------------------------------------

//  

//  File: LocChild.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCCHILD_H)
#define PARSUTIL_LOCCHILD_H


#pragma warning(disable : 4275)


class CPULocParser;

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocChild : public CLUnknown, public CLObject
{
// Construction
public:
	CPULocChild(CPULocParser * pParent);
	virtual ~CPULocChild();

// Data
private:
	CPULocParser * m_pParent;

// Attributes
public:
	CPULocParser * GetParent() const;

// COM Interfaces
public:

// Overrides
public:

// Implementation
protected:

	//  CLObject

	virtual void AssertValid(void) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\locbinary.h ===
//-----------------------------------------------------------------------------

//  

//  File: LocBinary.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCBINARY_H)
#define PARSUTIL_LOCBINARY_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocBinary : public ILocBinary, public CPULocChild
{
// Construction
public:
	CPULocBinary(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//
	// ILocBinary interface
	//
	BOOL STDMETHODCALLTYPE CreateBinaryObject(BinaryId,	CLocBinary * REFERENCE);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\locversion.h ===
//-----------------------------------------------------------------------------

//  

//  File: LocVersion.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCVERSION_H)
#define PARSUTIL_LOCVERSION_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocVersion : public CPULocChild, public ILocVersion
{
// Construction
public:
	CPULocVersion(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocVersion
	void STDMETHODCALLTYPE GetParserVersion(DWORD &dwMajor, DWORD &dwMinor,
			BOOL &fDebug) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\locparser.h ===
//-----------------------------------------------------------------------------

//  

//  File: LocParser.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCPARSER_H)
#define PARSUTIL_LOCPARSER_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocParser : public ILocParser, public CLObject
{
// Construction
public:
	CPULocParser(HINSTANCE hDll);
	virtual ~CPULocParser();

// Data
private:
	ULONG				m_ulRefCount;	// COM reference count
	HINSTANCE			m_hInst;		// Instance Handle

	BOOL				m_fEnableVersion;
	BOOL				m_fEnableBinary;
	BOOL				m_fEnableStrVal;

// COM Interfaces
public:

	//  IUnknown standard interface.
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID * ppvObj);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocParser interface implementation
	HRESULT STDMETHODCALLTYPE Init(IUnknown *);
	HRESULT STDMETHODCALLTYPE CreateFileInstance(ILocFile * REFERENCE, FileType);
	void STDMETHODCALLTYPE GetParserInfo(ParserInfo &) const;
	void STDMETHODCALLTYPE GetFileDescriptions(CEnumCallback &) const;

// Operations
public:

// Implementation
protected:
	BOOL EnableInterface(REFIID riid, BOOL fEnable = TRUE);
	virtual BOOL IsInterfaceEnabled(REFIID riid) const;

// Overrides
public:

	// IUnknown
	virtual HRESULT OnQueryInterface(REFIID riid, LPVOID * ppvObj);

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType) = 0;
	virtual void OnGetParserInfo(ParserInfo &) const = 0;
	virtual void OnGetFileDescriptions(CEnumCallback &) const = 0;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor,
			BOOL &fDebug) const = 0;

	// ILocBinary
	virtual BOOL OnCreateBinaryObject(BinaryId id, CLocBinary * REFERENCE pBinary);

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context) = 0;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\locstrval.h ===
//-----------------------------------------------------------------------------

//  

//  File: LocStrVal.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCSTRVAL_H)
#define PARSUTIL_LOCSTRVAL_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocStringValidation : public CPULocChild, public ILocStringValidation
{
// Construction
public:
	CPULocStringValidation(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocStringValidation
	CVC::ValidationCode STDMETHODCALLTYPE ValidateString(
			const CLocTypeId &ltiType, const CLocTranslation &trTrans,
			CReporter *pReporter, const CContext &context);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\parsutil.h ===
//-----------------------------------------------------------------------------

//  

//  File: ParsUtil.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------

#if !defined (__ParsUtil_h__)
#define __ParsUtil_h__

void IncrementClassCount();
void DecrementClassCount();

extern HMODULE g_hDll;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PARSUTIL.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\parsers\parsutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcoll.h>		// MFC collection support
#include <afxtempl.h>		// MFC template support

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\iresobj.h ===
//-----------------------------------------------------------------------------

//  

//  File: IResObj.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IRESOBJ_H
#define IRESOBJ_H


class CLocItemPtrArray;
class CFile;
class CResObj;
class CLocItem;

extern const IID IID_ICreateResObj;

DECLARE_INTERFACE_(ICreateResObj, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	// Creates a CResObj for win32 resoruce processing
	//Inputs:
	//	- A pointer to a CLocItem object containing the type and Id of the item
	//	- The size of the resource.
	//	- An void pointer to unknown data to be passed from enumeration to generate
	//Return:
	//	- A CResObj pointer or NULL if the type is not recognized
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ CLocItem * pLocItem,
		DWORD dwSize, void * pvHeader) PURE;
};
#endif  // IRESOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\mnemonic.h ===
//-----------------------------------------------------------------------------

//  

//  File: Mnemonic.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//
//	Declaration of ILocMnemonics. 
//	This interface allows to retrieve the mnemonics (aka hotkeys) of a 
//	resource
//
//	Owner: EduardoF
//  
//-----------------------------------------------------------------------------

#ifndef MNEMONIC_H
#define MNEMONIC_H


extern const IID IID_ILocMnemonics;

DECLARE_INTERFACE_(ILocMnemonics, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Gets the mnemonics (aka hotkeys) in the resource array of locitems.
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- A 'CHotkeysMap' map containing the mnemonics.
	//Return:
	//	TRUE if the mnemonics could be retrieved successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, GetMnemonics)
			(THIS_ CLocItemPtrArray &, int, int, LangId, CReporter * pReporter, 
			CMnemonicsMap &) PURE;

};



#endif  // MNEMONIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\locfile.h ===
//-----------------------------------------------------------------------------

//  

//  File: LocFile.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//
//  Operations we can perforn on a localizable file.
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_LOCFILE_H
#define PBASE_LOCFILE_H


class CLocItemHandler;


extern const IID IID_ILocFile;


DECLARE_INTERFACE_(ILocFile, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(THIS_ const CFileSpec REFERENCE,
			CReporter REFERENCE) PURE;
	STDMETHOD_(FileType, GetFileType)(THIS) const PURE;
	STDMETHOD_(void, GetFileTypeDescription)(THIS_ CLString REFERENCE)
		const PURE;
	STDMETHOD_(BOOL, GetAssociatedFiles)(THIS_ CStringList REFERENCE)
		const PURE;

	STDMETHOD_(BOOL, EnumerateFile)(THIS_ CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE) PURE;
	STDMETHOD_(BOOL, GenerateFile)(THIS_ const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE) PURE;
};


#endif //  PBASE_LOCFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\idupdate.h ===
//-----------------------------------------------------------------------------

//  

//  File: idupdate.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_IDUPDATE_H
#define PBASE_IDUPDATE_H

extern const IID IID_ILocIDUpdate;

DECLARE_INTERFACE_(ILocIDUpdate, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ID Update methods.
	//
	STDMETHOD_(BOOL, RequiresUpdate)(THIS_ FileType) PURE;
	STDMETHOD_(FileType, GetUpdatedFileType)(THIS_ FileType) PURE;

	STDMETHOD_(BOOL, GetOldUniqueId)(THIS_ CLocUniqueId REFERENCE) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\binary.h ===
//-----------------------------------------------------------------------------

//  

//  File: Binary.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//
//  Class to hold 'binary' (non-string) information about a localizable item.
//  
//-----------------------------------------------------------------------------

#ifndef BINARY_H
#define BINARY_H


//
//  Binary interface.  Parsers provide an implementation of this in order
//  to create binary objects for other users.
//
extern const IID IID_ILocBinary;

DECLARE_INTERFACE_(ILocBinary, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, CreateBinaryObject)(THIS_ BinaryId, CLocBinary *REFERENCE) PURE;
};



#endif  // BINARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\pstrval.h ===
//-----------------------------------------------------------------------------

//  

//  File: pstrval.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  String Validation interface.
//
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_PSTRVAL_H
#define PBASE_PSTRVAL_H

extern const IID IID_ILocStringValidation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocString REFERENCE,
				CReporter *) PURE;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\parseapi.h ===
//-----------------------------------------------------------------------------

//  

//  File: parseapi.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  Main interface to a file parser DLL.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#ifndef PARSEAPI_H
#define PARSEAPI_H


extern const IID IID_ILocParser;
extern const IID IID_ILocParser_20;

struct ParserInfo
{
	CArray<PUID, PUID &> aParserIds;
	CLString strDescription;
	CLocExtensionList elExtensions;
	CLString strHelp;
};


DECLARE_INTERFACE_(ILocParser, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  LocParser methods.
	//
	STDMETHOD(Init)(THIS_ IUnknown *) PURE;
	
	STDMETHOD(CreateFileInstance)(THIS_ ILocFile *REFERENCE, FileType) PURE;

	STDMETHOD_(void, GetParserInfo)(THIS_ ParserInfo REFERENCE)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetFileDescriptions)(THIS_ CEnumCallback &)
		CONST_METHOD PURE;
};


//
//  Here for DOCUMENTATION only.  Implementors should export the following
//  functions from every Parser DLL.
//
static const char * szParserEntryPointName = "DllGetParserCLSID";
typedef void (STDAPICALLTYPE *PFNParserEntryPoint)(CLSID REFERENCE);

STDAPI_(void) DllGetParserCLSID(CLSID REFERENCE);


static const char * szParserRegisterEntryPointName = "DllRegisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserRegisterEntryPoint)(void);

STDAPI DllRegisterParser(void);


static const char *szParserUnregisterEntryPointName = "DllUnregisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserUnregisterEntryPoint)(void);

STDAPI DllUnregisterParser(void);

//
//  Implementors also need to implement the DllGetClassObject function.
//  An optional (but RECOMMENDED) function is DllCanUnloadNow.
//  See the OLE 2 reference manual for details about these functions.
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI DllCanUnloadNow(void);


#endif // PARSEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\imgres32.h ===
//-----------------------------------------------------------------------------

//  

//  File: ImgRes32.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IMGRES32_H
#define IMGRES32_H


struct Res32FontInfo
{
	WORD wLength;			//Structure length
	WORD wPointSize;		
	WORD wWeight;
	WORD wStyle;
	CPascalString pasName;
};

class CLocItemPtrArray;
class CFile;

extern const IID IID_ILocRes32Image;

DECLARE_INTERFACE_(ILocRes32Image, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Builds a Res32 file image of a resource from the resource's CLocItem objects
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to an existing empty CFile.
	//  - A pointer to a Res32FontInfo structure
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The CFile object has the res32 image of the resource.
	//	- The CLocItemPtrArray object has its items ordered by physical
	//	location in the res32 image.	
	//Return:
	//	TRUE if the image was created successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, MakeRes32Image)(THIS_ CLocItemPtrArray *, int, int, 
		LangId, CFile *, Res32FontInfo*, CLocItemHandler *) PURE;

	//Breaks the Res32 image of a resource into the corresponding CLocItem objects.
	//Inputs:
	//	- A pointer to a CFile object containing the res32 image of a resource.
	//	- The resource's language id.
	//	- A pointer to a CLocItemPtrArray containing the CLocItem objects of the
 	//	resource. The items are expected to be ordered by position in the res32 image.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The items in the CLocItemPtrArray object are updated with the new data from
 	//	the res32 image.
	//Return:
	//	TRUE if the imaged could be parsed and if the items could be updated successfully.
	//	FALSE, otherwise.
	STDMETHOD_(BOOL, CrackRes32Image)(THIS_ CFile *, LangId, CLocItemPtrArray *, CLocItemHandler *) PURE;
};



#endif  // IMGRES32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\subparse.h ===
//-----------------------------------------------------------------------------

//  

//  File: SubParse.H

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_SUBPARSE_H
#define PBASE_SUBPARSE_H


extern const IID IID_ILocSubParserManager;

typedef CTypedPtrArray<CPtrArray, ILocParser *> ILocSubParserArray;

DECLARE_INTERFACE_(ILocSubParserManager, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD(InitSubParsers)(THIS_ ILocSubParserArray REFERENCE)
		CONST_METHOD PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\prodver\prodver.h ===
#define rmj 4
#define rmm 2
#define rup 169
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\updatelog.h ===
//-----------------------------------------------------------------------------

//  

//  File: updatelog.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_UPDATELOG_H
#define PBASE_UPDATELOG_H


extern const IID IID_ILocUpdateLog;

DECLARE_INTERFACE_(ILocUpdateLog, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, ReportItemDifferences)
		(THIS_ const CLocItem *pOldItem, const CLocItem *pNewItem,
				CItemInfo *, CLogFile *) PURE;
};


struct __declspec(uuid("{6005AF23-EE76-11d0-A599-00C04FC2C6D8}")) ILocUpdateLog;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\inc\pbase\pversion.h ===
//-----------------------------------------------------------------------------

//  

//  File: pversion.h

// Copyright (c) 1994-2001 Microsoft Corporation, All Rights Reserved 
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PVERSION_H
#define PVERSION_H

extern const IID IID_ILocVersion;

extern const DWORD dwCurrentMajorVersion;
extern const DWORD dwCurrentMinorVersion;
#ifdef _DEBUG
const BOOL fCurrentDebugMode = TRUE;
#else
const BOOL fCurrentDebugMode = FALSE;
#endif

DECLARE_INTERFACE_(ILocVersion, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//
	//
	STDMETHOD_(void, GetParserVersion)(
			THIS_ DWORD REFERENCE dwMajor,
			DWORD REFERENCE dwMinor,
			BOOL REFERENCE fDebug)
		CONST_METHOD PURE;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\moengine\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#include <ole2.h>
#include <windows.h>
#include <rpc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\moengine\moengine.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MOENGINE.CPP
//
//  Purpose: Code-generation engine for HMM* providers
//
//  Comments:
//
/**************************************************************************

  -- .

                    Generates .CPP, .H, .MAK, .DEF, files for providers
                    
    MOProviderOpen()        :   Provider initialization
    MOProviderCancel()      :   Cancels construction of current provider
    MOProviderClose()       :   Provider cleanup, writes provider files

    MOPropSetOpen()         :   Property set initialization
    MOPropSetCancel()       :   Cancels construction of target property set
    MOPropertyAdd()         :   Adds property to target property set

    MOPropertyAttribSet()   :   Sets attributes of pre-existing property

    MOGetLastError()        :   Returns code of last error encountered
    MOResetLastError()      :   Clears recorded error code

 Revisions:

    09/17/96        a-jmoon     created
	1/22/98			a-brads		updated to new framework

 String substitutions:

 Designator     Description
 ==========     =======================

    %%1         Provider base file name
    %%2         Provider description
    %%3         HMMS type library path
    %%4         Library UUID
    %%5         Provider UUID
     
    %%6         System directory

    %%7         Property set base file name
    %%8         Property set description
    %%9         Property set name
    %%A         Property set UUID
    %%B         Property set class name
    %%C         Property set parent class name
      
    %%D         Property name definitions
    %%E         Property enumerations (TPROP)
    %%F         Property name extern definitions
    %%G         Property template declarations
    %%H         Property PUT methods
    %%I         Property GET methods

    %%J         Upper-cased property set base file name
    %%K         Attribute assignments         

**************************************************************************/

#include "precomp.h"

#include <stdio.h>
#include <conio.h>
#include <io.h>
#include <comdef.h>

#define POLARITY
#include <chstring.h>

#define MO_ENGINE_PROGRAM
#include <moengine.h>

#include "resource.h"

HINSTANCE       hOurAFXResourceHandle ;
PROVIDER_INFO  *pProviderList = NULL ;
CHString         sSystemDirectory ;
DWORD           dwLastError ;

/*****************************************************************************
*
*  FUNCTION    : DLLMain
*
*  DESCRIPTION : DLL entry function
*
*  INPUTS      : 
*
*  OUTPUTS     :
*
*  RETURNS     : TRUE
*
*  COMMENTS    : Saves our DLL's instance handle, gets system directory
*
*****************************************************************************/

BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReasonForCall, LPVOID pReserved)
{
	WCHAR szTemp[_MAX_PATH] ;

	UNREFERENCED_PARAMETER(hInstance) ;
	UNREFERENCED_PARAMETER(dwReasonForCall) ;    
	UNREFERENCED_PARAMETER(pReserved) ;

	hOurAFXResourceHandle = GetModuleHandle(_T("MOENGINE.DLL")) ;

	GetSystemDirectory(szTemp, sizeof(szTemp)/sizeof(WCHAR)) ;

	sSystemDirectory  = szTemp ;
	sSystemDirectory += _T("\\") ;

	// This directory is quoted in the IDL file, so needs double backslashes
	//======================================================================

	DoubleBackslash(sSystemDirectory) ;

	return TRUE;
}
    
/*****************************************************************************
*
*  FUNCTION    : MOProviderOpen
*
*  DESCRIPTION : Initializes provider data
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

DllExport DWORD MOProviderOpen(LPCWSTR pszBaseName,
								LPCWSTR pszDescription,
								LPCWSTR pszOutputPath,
								LPCWSTR pszTLBPath,
								LPCWSTR pszLibraryUUID,
								LPCWSTR pszProviderUUID)
{
	PROVIDER_INFO *pProvider, *pTemp ;

	// Base file name is the only rejection criterion
	//===============================================

	if(!pszBaseName || !pszBaseName[0]) 
	{
        // As odd as this looks, it's what the ui is expecting.
		dwLastError = MO_ERROR_INVALID_FILENAME ;
		return MO_INVALID_ID ;
	}

	// Create a new provider record
	//=============================

	pProvider = new PROVIDER_INFO ;
	if(pProvider == NULL) 
	{
        // As odd as this looks, it's what the ui is expecting.
		dwLastError = MO_ERROR_MEMORY ;
		return MO_INVALID_ID ;
	}

	pProvider->dwProviderID = MONewProviderID() ;

	// Verify input data & construct provider record
	//==============================================

	pProvider->sBaseName     = pszBaseName ;
	pProvider->sDescription  = pszDescription                       ? CHString(pszDescription)    : _T("") ;
	pProvider->sOutputPath   = pszOutputPath && pszOutputPath[0]    ? CHString(pszOutputPath)     : _T(".") ;
	pProvider->sTLBPath      = pszTLBPath && pszTLBPath[0]          ? CHString(pszTLBPath)        : _T(".") ;
	pProvider->sLibraryUUID  = pszLibraryUUID                       ? CHString(pszLibraryUUID)    : MOCreateUUID() ;
	pProvider->sProviderUUID = pszProviderUUID                      ? CHString(pszProviderUUID)   : MOCreateUUID() ;
	pProvider->pPropSetList  = NULL ;
    
	// Make sure there's a trailing backslash on the path specs
	//=========================================================

	if(pProvider->sOutputPath.Right(1) != _T("\\")) 
	{
		pProvider->sOutputPath += _T("\\") ;
	}

	if(pProvider->sTLBPath.Right(1) != _T("\\")) 
	{
		pProvider->sTLBPath += _T("\\") ;
	}

	// Type library path is quoted in source, so needs double backslashes
	//===================================================================

	DoubleBackslash(pProvider->sTLBPath) ;

	// Assemble output file names
	//===========================

	_stprintf(pProvider->szDEFFileSpec, _T("%s%s.DEF"), 
			(LPCTSTR) pProvider->sOutputPath, 
			(LPCTSTR) pProvider->sBaseName) ;

//	_stprintf(pProvider->szIDLFileSpec, _T("%s%s.IDL"), 
//			(LPCTSTR) pProvider->sOutputPath, 
//			(LPCTSTR) pProvider->sBaseName) ;

	_stprintf(pProvider->szMOFFileSpec, _T("%s%s.MOF"),
			(LPCTSTR) pProvider->sOutputPath, 
			(LPCTSTR) pProvider->sBaseName) ;

	_stprintf(pProvider->szOLEFileSpec, _T("%sMAINDLL.CPP"), 
			(LPCTSTR) pProvider->sOutputPath) ;

	_stprintf(pProvider->szMAKFileSpec, _T("%s%s.MAK"),
			(LPCTSTR) pProvider->sOutputPath,
			(LPCTSTR) pProvider->sBaseName) ;

	// Insert at end of provider list
	//===============================

	pTemp = (PROVIDER_INFO *) &pProviderList ;
	while(pTemp->pNext != NULL) 
	{
		pTemp = pTemp->pNext ;
	}

	pProvider->pNext = NULL ;
	pTemp->pNext = pProvider ;

	return pProvider->dwProviderID ;    
}

/*****************************************************************************
*
*  FUNCTION    : MOProviderCancel
*
*  DESCRIPTION : Simply kills provider-in-progress
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

DllExport void MOProviderCancel(DWORD dwProviderID)
{
	MOProviderDestroy(dwProviderID) ;
}    

/*****************************************************************************
*
*  FUNCTION    : MOProviderClose
*
*  DESCRIPTION : Terminates construction of a provider & writes files
*
*  INPUTS      : dwProviderID  : ID of provider to commit
*                bForceFlag    : If TRUE, existing files are overwritten
*                                If FALSE, no files are created (provider
*                                must still be closed or cancelled)
*
*  OUTPUTS     :
*
*  RETURNS     : MO_SUCCESS if successful, error code otherwise
*
*  COMMENTS    :
*
*****************************************************************************/

DllExport DWORD MOProviderClose(DWORD dwProviderID, BOOL bForceFlag)
{
	PROVIDER_INFO *pProvider ;
	PROPSET_INFO *pPropSet ;
	DWORD dwRetCode = MO_SUCCESS ;
	WCHAR szTemp[_MAX_PATH], *pSlash ;

	// Get the provider record
	//========================

	pProvider = GetProviderFromID(dwProviderID) ;
	if(pProvider == NULL) 
	{
		dwLastError = MO_ERROR_PROVIDER_NOT_FOUND ;
		return MO_ERROR_PROVIDER_NOT_FOUND ;
	}

	// Check directory/file existence if force flag set
	//=================================================

	_tcscpy(szTemp, (LPCTSTR) pProvider->sOutputPath.Left(pProvider->sOutputPath.GetLength()-1)) ;
	if(!bForceFlag) 
	{
		if(_taccess(szTemp, 0) == -1) 
		{
			dwLastError = MO_ERROR_DIRECTORY_NOT_FOUND ;
			return MO_ERROR_DIRECTORY_NOT_FOUND ;
		}
        
		if(_taccess(pProvider->szDEFFileSpec, 0) != -1 ||
//			_taccess(pProvider->szIDLFileSpec, 0) != -1 ||
			_taccess(pProvider->szOLEFileSpec, 0) != -1) 
		{
			dwLastError = MO_ERROR_FILES_EXIST ;
			return MO_ERROR_FILES_EXIST ;
		}

		// We need to traverse provider's property sets for file names
		//============================================================

		pPropSet = pProvider->pPropSetList ;
		while(pPropSet != NULL) 
		{
			if(_taccess(pPropSet->szCPPFileSpec, 0) != -1 ||
				_taccess(pPropSet->szHFileSpec,   0) != -1) 
			{
				dwLastError = MO_ERROR_FILES_EXIST ;
				return MO_ERROR_FILES_EXIST ;
			}

			pPropSet = pPropSet->pNext ;
		}	// end while loop
	}

	// Create output directory if necessary
	//=====================================

	if(_taccess(szTemp, 0) == -1) 
	{
		pSlash = szTemp ;

		for( ; ; ) 
		{
			pSlash = _tcschr(pSlash, _T('\\')) ;
			if(pSlash == NULL) 
			{
				CreateDirectory(szTemp, NULL) ;
				break ;
			}

			if(*(pSlash-1) != _T(':')) 
			{
				*pSlash = 0 ;
				CreateDirectory(szTemp, NULL) ;
				*pSlash = _T('\\') ;
			}

			pSlash++ ;
		}
	}

	if(_taccess(szTemp, 0) == -1) 
	{
		dwLastError = MO_ERROR_DIRECTORY ;
		return MO_ERROR_DIRECTORY ;
	}

	pPropSet = pProvider->pPropSetList ;
	while(pPropSet != NULL) 
	{
		pProvider->sObj += _T("\"$(OUTDIR)\\") + pPropSet->sBaseName + _T(".obj\" ");
		pProvider->sCpp += pPropSet->sBaseName + _T(".cpp ");
		pPropSet = pPropSet->pNext ;
	}

	// Create the output files
	//========================

	dwRetCode = CreateProviderFile(pProvider, NULL, pProvider->szDEFFileSpec, IDR_TEMPLATE_DEF) ;

    if (dwRetCode == MO_SUCCESS)
	    dwRetCode = CreateProviderFile(pProvider, NULL, pProvider->szMOFFileSpec, IDR_TEMPLATE_MOF) ;

//	  if (dwRetCode == MO_SUCCESS)
//	    dwRetCode = CreateProviderFile(pProvider, NULL, pProvider->szIDLFileSpec, IDR_TEMPLATE_ODL) ;
//	  if (dwRetCode == MO_SUCCESS)
//	    dwRetCode = CreateProviderFile(pProvider, NULL, pProvider->szOLEFileSpec, IDR_TEMPLATE_OLE) ;

    if (dwRetCode == MO_SUCCESS)
        dwRetCode = CreateProviderFile(pProvider, pPropSet, pProvider->szMAKFileSpec, IDR_TEMPLATE_MAK)	;

	pPropSet = pProvider->pPropSetList ;
	while(pPropSet != NULL) 
	{
		if (dwRetCode == MO_SUCCESS)
    	    dwRetCode = CreateProviderFile(pProvider, pPropSet, pPropSet->szCPPFileSpec, IDR_TEMPLATE_CPP) ;

		if (dwRetCode == MO_SUCCESS)
    	    dwRetCode = CreateProviderFile(pProvider, pPropSet, pPropSet->szHFileSpec,   IDR_TEMPLATE_H) ;

		if (dwRetCode == MO_SUCCESS)
    	    dwRetCode = CreateProviderFile(pProvider, pPropSet, pProvider->szOLEFileSpec, IDR_TEMPLATE_DLL) ;

		pPropSet = pPropSet->pNext ;
	}



	// Delete all the associated records
	//==================================

	MOProviderDestroy(dwProviderID) ;
	return dwRetCode ;
}    

/*****************************************************************************
*
*  FUNCTION    : MOPropSetOpen
*
*  DESCRIPTION : Opens property set
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

DllExport DWORD MOPropSetOpen(DWORD       dwProviderID,
								LPCWSTR pszBaseName,
								LPCWSTR pszDescription,
								LPCWSTR pszPropSetName,
								LPCWSTR pszPropSetUUID,
								LPCWSTR pszClassName,
								LPCWSTR pszParentClassName) 
{
	PROVIDER_INFO *pProvider ;
	PROPSET_INFO *pPropSet, *pTemp ;

	// Validate our input
	//===================

	if(!pszBaseName     || !pszBaseName[0]      ||
		!pszPropSetName  || !pszPropSetName[0]   ||
		!pszClassName    || !pszClassName[0]) 
	{
        // As odd as this looks, it's what the ui is expecting.
		dwLastError = MO_ERROR_INVALID_PARAMETER ;        
		return MO_INVALID_ID ;
	}

	// Locate the provider
	//====================

	pProvider = GetProviderFromID(dwProviderID) ;
	if(pProvider == NULL) 
	{
        // As odd as this looks, it's what the ui is expecting.
		dwLastError = MO_ERROR_PROVIDER_NOT_FOUND ;
		return MO_INVALID_ID ;
	}

	// Create new property set record
	//===============================

	pPropSet = new PROPSET_INFO ;
	if(pPropSet == NULL) 
	{
        // As odd as this looks, it's what the ui is expecting.
		dwLastError = MO_ERROR_MEMORY ;
		return MO_INVALID_ID ;
	}

	pPropSet->dwPropSetID			= MONewPropSetID(pProvider) ;
	pPropSet->sBaseName				= pszBaseName ;
	pPropSet->sDescription			= pszDescription ? CHString(pszDescription) : _T("") ;
	pPropSet->sPropSetName			= pszPropSetName ;
	pPropSet->sPropSetUUID			= pszPropSetUUID && pszPropSetUUID[0] ? CHString(pszPropSetUUID) : MOCreateUUID() ;
	pPropSet->sClassName			= pszClassName ;
	pPropSet->sParentClassName		= pszParentClassName && pszParentClassName[0] ? CHString(pszParentClassName) : _T("Provider") ;
	pPropSet->pPropertyList			= NULL ;
	pPropSet->pPropertyAttribList	= NULL ;
	pPropSet->sBaseUpcase			= pszBaseName ;
	pPropSet->sBaseUpcase.MakeUpper() ;

	// Create output file names
	//=========================

	_stprintf(pPropSet->szCPPFileSpec, _T("%s%s.CPP"), 
			(LPCTSTR) pProvider->sOutputPath, 
			(LPCTSTR) pPropSet->sBaseName) ;

	_stprintf(pPropSet->szHFileSpec, _T("%s%s.H"), 
			(LPCTSTR) pProvider->sOutputPath, 
			(LPCTSTR) pPropSet->sBaseName) ;

	// Add to the provider's list
	//===========================

	pTemp = (PROPSET_INFO *) &pProvider->pPropSetList ;
	while(pTemp->pNext != NULL) 
	{
		pTemp = pTemp->pNext ;
	}

	pPropSet->pNext = NULL ;
	pTemp->pNext = pPropSet ;

	return pPropSet->dwPropSetID ;
}


/*****************************************************************************
*
*  FUNCTION    : MOPropertyAdd
*
*  DESCRIPTION : Adds property to existing/open property set
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     : MO_SUCCESS or error code
*
*  COMMENTS    : 
*
*****************************************************************************/

DllExport DWORD MOPropertyAdd(DWORD       dwProviderID,
								DWORD       dwPropSetID,
								LPCWSTR     pszProperty,
								LPCWSTR     pszName,
								LPCWSTR     pszPutMethod,
								LPCWSTR     pszGetMethod,
								DWORD       dwType,
								DWORD       dwFlags)
{
	PROVIDER_INFO *pProvider ;
	PROPSET_INFO *pPropSet ;
	PROPERTY_INFO *pProperty, *pTemp ;

	// Validate
	//=========

	if(!pszProperty || !pszProperty[0] ||
		!pszName     || !pszName[0]) 
	{
		dwLastError = MO_ERROR_INVALID_PARAMETER ;
		return MO_ERROR_INVALID_PARAMETER ;
	}

	// Locate the provider
	//====================

	pProvider = GetProviderFromID(dwProviderID) ;
	if(pProvider == NULL) 
	{
		dwLastError = MO_ERROR_PROVIDER_NOT_FOUND ;
		return MO_ERROR_PROVIDER_NOT_FOUND ;
	}

	// Locate the property set
	//========================

	pPropSet = GetPropSetFromID(pProvider, dwPropSetID) ;
	if(pProvider == NULL) 
	{
		dwLastError = MO_ERROR_PROPSET_NOT_FOUND ;
		return MO_ERROR_PROPSET_NOT_FOUND ;
	}

	// Create new property record
	//===========================

	pProperty = new PROPERTY_INFO ;
	if(pProperty == NULL) 
	{
		dwLastError = MO_ERROR_MEMORY ;
		return MO_ERROR_MEMORY ;
	}

	pProperty->sProperty    = pszProperty ;
	pProperty->sName        = pszName ;
	pProperty->sPutMethod   = pszPutMethod && pszPutMethod[0] ? CHString(pszPutMethod) : _T("NULL") ;
	pProperty->sGetMethod   = pszGetMethod && pszGetMethod[0] ? CHString(pszGetMethod) : _T("NULL") ;
	pProperty->dwType       = dwType ;
	pProperty->dwFlags      = dwFlags ;

	// Create property name pointer
	//=============================

    pProperty->sPropertyNamePtr.Format(L"p%s", pszProperty);

	// Add to the property set
	//========================

	pTemp = (PROPERTY_INFO *) &pPropSet->pPropertyList ;
	while(pTemp->pNext != NULL) 
	{
		pTemp = pTemp->pNext ;
	}

	pProperty->pNext = NULL ;
	pTemp->pNext = pProperty ;

	return MO_SUCCESS ;
}    

/*****************************************************************************
*
*  FUNCTION    : MOPropertyAttribSet
*
*  DESCRIPTION : Allows user to assign attributes to properties at run-time
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

DllExport DWORD MOPropertyAttribSet(DWORD       dwProviderID,
									DWORD       dwPropSetID,
									LPCWSTR     pszProperty,
									DWORD       dwFlags)
{
	PROVIDER_INFO *pProvider ;
	PROPSET_INFO *pPropSet ;
	PROPERTY_ATTRIB_INFO *pPropAttrib ;

	// Validate
	//=========

	if(!pszProperty || !pszProperty[0]) 
	{
		dwLastError = MO_ERROR_INVALID_PARAMETER ;
		return MO_ERROR_INVALID_PARAMETER ;
	}

	// Locate the provider
	//====================

	pProvider = GetProviderFromID(dwProviderID) ;
	if(pProvider == NULL) 
	{
		dwLastError = MO_ERROR_PROVIDER_NOT_FOUND ;
		return MO_ERROR_PROVIDER_NOT_FOUND ;
	}

	// Locate the property set
	//========================

	pPropSet = GetPropSetFromID(pProvider, dwPropSetID) ;
	if(pProvider == NULL) 
	{
		dwLastError = MO_ERROR_PROPSET_NOT_FOUND ;
		return MO_ERROR_PROPSET_NOT_FOUND ;
	}

	// Create new record for property
	//===============================

	pPropAttrib = new PROPERTY_ATTRIB_INFO ;
	if(pPropAttrib == NULL) 
	{
		dwLastError = MO_ERROR_MEMORY ;
		return MO_ERROR_MEMORY ;
	}

	pPropAttrib->sProperty = pszProperty ;
	pPropAttrib->dwFlags = dwFlags ;

	pPropAttrib->pNext = pPropSet->pPropertyAttribList ;
	pPropSet->pPropertyAttribList = pPropAttrib ;

	return MO_SUCCESS ;
}    

/*****************************************************************************
*
*  FUNCTION    : MOGetLastError
*
*  DESCRIPTION : Retrieves error code
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     : Numeric code of last error encountered
*
*  COMMENTS    : 
*
*****************************************************************************/

DllExport DWORD MOGetLastError(void)
{
	return dwLastError ;
}

/*****************************************************************************
*
*  FUNCTION    : MOPropertyAttribSet
*
*  DESCRIPTION : Allows user to assign attributes to properties at run-time
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

DllExport void MOResetLastError(void)
{
	dwLastError = MO_SUCCESS ;
}

//=============================================================================
//=============================================================================
//
//
//                            UTILITY ROUTINES
//
//
//=============================================================================
//=============================================================================

/*****************************************************************************
*
*  FUNCTION    : MONewProviderID
*
*  DESCRIPTION : Generates ID unique among open providers
*
*  INPUTS      : nothing
*
*  OUTPUTS     : nothing
*
*  RETURNS     : Unique ID
*
*  COMMENTS    : No error returned
*
*****************************************************************************/

DWORD MONewProviderID()
{
	static DWORD dwNextID = MO_INVALID_ID ;
	while(++dwNextID == MO_INVALID_ID || GetProviderFromID(dwNextID) != NULL) ;
	return dwNextID ;
}    

/*****************************************************************************
*
*  FUNCTION    : MONewPropSetID
*
*  DESCRIPTION : Generates ID unique among open properties
*
*  INPUTS      : nothing
*
*  OUTPUTS     : nothing
*
*  RETURNS     : Unique ID
*
*  COMMENTS    : No error returned
*
*****************************************************************************/

DWORD MONewPropSetID(PROVIDER_INFO *pProvider)
{
	static DWORD dwNextID = MO_INVALID_ID ;

	while(++dwNextID == MO_INVALID_ID || GetPropSetFromID(pProvider, dwNextID) != NULL) ;

	return dwNextID ;
}    

/*****************************************************************************
*
*  FUNCTION    : GetProviderFromID
*
*  DESCRIPTION : Lookup function for open providers
*
*  INPUTS      : ID of desired provider
*
*  OUTPUTS     : none
*
*  RETURNS     : Pointer to provider record if found, NULL if not
*
*  COMMENTS    :
*
*****************************************************************************/

PROVIDER_INFO *GetProviderFromID(DWORD dwProviderID)
{
	PROVIDER_INFO *pProvider ;

	pProvider = pProviderList ;
	while(pProvider != NULL) 
	{
		if(pProvider->dwProviderID == dwProviderID) 
		{
		break ;
		}
		pProvider = pProvider->pNext ;
	}

	return pProvider ;
}    

/*****************************************************************************
*
*  FUNCTION    : GetPropSetFromID
*
*  DESCRIPTION : Lookup function for open property sets
*
*  INPUTS      : ID of desired property set
*
*  OUTPUTS     : none
*
*  RETURNS     : Pointer to provider record if found, NULL if not
*
*  COMMENTS    :
*
*****************************************************************************/

PROPSET_INFO *GetPropSetFromID(PROVIDER_INFO *pProvider, DWORD dwPropSetID)
{
	PROPSET_INFO *pPropSet ;

	pPropSet = pProvider->pPropSetList ;
	while(pPropSet != NULL) 
	{
		if(pPropSet->dwPropSetID == dwPropSetID) 
		{
			break ;
		}

		pPropSet = pPropSet->pNext ;
	}

	return pPropSet ;
}

/*****************************************************************************
*
*  FUNCTION    : MOProviderDestroy
*
*  DESCRIPTION : Destroys all structs associated with a provider
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     : MO_SUCCESS or error code
*
*  COMMENTS    :
*
*****************************************************************************/

DWORD MOProviderDestroy(DWORD dwProviderID)
{
	PROVIDER_INFO *pProvider, *pPredecessor ;
	PROPSET_INFO *pPropSet ;
	PROPERTY_INFO *pProperty ;
	PROPERTY_ATTRIB_INFO *pPropAttrib ;

	// Locate the provider record & remove from list
	//==============================================

	pProvider = pProviderList ;
	pPredecessor = (PROVIDER_INFO *) &pProviderList ;

	while(pProvider != NULL) 
	{
		if(pProvider->dwProviderID == dwProviderID) 
		{
			pPredecessor->pNext = pProvider->pNext ;        
			break ;
		}

		pPredecessor = pProvider ;
		pProvider = pProvider->pNext ;
	}

	// Was the provider record found?
	//===============================

	if(pProvider == NULL) 
	{
		return MO_ERROR_PROVIDER_NOT_FOUND ;
	}

	// Yep -- destroy everything
	//==========================

	while(pProvider->pPropSetList != NULL) 
	{
		pPropSet = pProvider->pPropSetList ;
		pProvider->pPropSetList = pPropSet->pNext ;

		while(pPropSet->pPropertyList != NULL) 
		{
			pProperty = pPropSet->pPropertyList ;
			pPropSet->pPropertyList = pProperty->pNext ;

			delete pProperty ;
		}

		while(pPropSet->pPropertyAttribList != NULL) 
		{
			pPropAttrib = pPropSet->pPropertyAttribList ;
			pPropSet->pPropertyAttribList = pPropAttrib->pNext ;

			delete pPropAttrib ;
		}

		delete pPropSet ;
	}

	delete pProvider ;

	return MO_SUCCESS ;
}    

/*****************************************************************************
*
*  FUNCTION    : MOCreateUUID
*
*  DESCRIPTION :
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

WCHAR *MOCreateUUID(void)
{
	static WCHAR szUUID[50] ;
	UUID RawUUID ;
	WCHAR *pszSysUUID ;

	// Make sure we don't return anything twice
	//=========================================    

	_tcscpy(szUUID, _T("Unable to create UUID")) ;

	// Generate the new UUID
	//======================

	if(UuidCreate(&RawUUID) == RPC_S_OK && UuidToString(&RawUUID, &pszSysUUID) == RPC_S_OK) 
	{
		_tcscpy(szUUID, (LPCWSTR) pszSysUUID) ;
		RpcStringFree(&pszSysUUID) ;
	}

	return szUUID ;
}    

/*****************************************************************************
*
*  FUNCTION    : CreateProviderFile
*
*  DESCRIPTION :
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

DWORD CreateProviderFile(PROVIDER_INFO *pProvider,
							PROPSET_INFO  *pPropSet,
							LPCWSTR       pszFileSpec,
							DWORD          dwTemplateID)
{
	CHString sTemp, sTemp2, sOutput ;
	int iIndex ;
	WCHAR cDesignator ;
	HRSRC hResHandle ;
	HGLOBAL hTemplateHandle ;
	char *pFrom, *pTo ;
	DWORD dwBufferSize ;

	// Locate/load template file as resource
	//======================================

	hResHandle = FindResource(hOurAFXResourceHandle, (LPCTSTR)(DWORD_PTR) dwTemplateID, _T("BINARY")) ;
	if(hResHandle == NULL) 
	{
		return MO_ERROR_TEMPLATE_NOT_FOUND ;
	}

	hTemplateHandle = LoadResource(hOurAFXResourceHandle, hResHandle) ;
	if(hTemplateHandle == NULL) 
	{
		return MO_ERROR_TEMPLATE_NOT_FOUND ;
	}

	// Put the resource into a CHString & find the closing
	// tilde string (~~~~~~) to place the terminating NULL
	// (the resource doesn't have the NULL in it...)  MS is
	// supposedly considering making SizeofResource()
	// actually return the proper size of the resource, but
	// for now it only returns rounded up to the next alignment.
	//==========================================================

	dwBufferSize = SizeofResource(hOurAFXResourceHandle, hResHandle) ;
	if(dwBufferSize == 0) 
	{
		return MO_ERROR_TEMPLATE_NOT_FOUND ;
	}

	pFrom = (char *) LockResource(hTemplateHandle) ;
	if(pFrom == NULL) 
	{
		return MO_ERROR_MEMORY ;
	}

	pTo = new char[dwBufferSize];
	if(pTo == NULL) 
	{
		return MO_ERROR_MEMORY ;
	}

	memcpy(pTo, pFrom, dwBufferSize) ;

	pFrom = strstr(pTo, "~~~~~~") ;
	if(pFrom == NULL) 
	{
        delete []pTo;
		return MO_ERROR_TEMPLATE_NOT_FOUND ;
	}

	*pFrom = 0 ;
	sTemp = pTo;
    delete []pTo;

	// Perform string substitutions
	//=============================

	sOutput  = _T("") ;
	iIndex = sTemp.Find(_T("%%")) ;
	while(iIndex != -1) 
	{
		cDesignator = sTemp.GetAt(iIndex + 2) ;
        if (_T('8') == cDesignator)
        {
        	// check to see if the string in pPropSet->sDescription
			// is valid.  i.e. no carriage returns.
			CHString chsCompString = pPropSet->sDescription;
			LONG len = chsCompString.GetLength();
			if (len)
			{
				for (int i = 0;i<len ;i++ )
				{
					if ((_T('\n') == chsCompString[i]) || (_T('\r') == chsCompString[i]))
					{
						chsCompString.SetAt(i, _T(' '));
					}	// end if
				}	// end for
				pPropSet->sDescription = chsCompString.GetBuffer(0);
			}	// end if
        }	// end if
		sOutput += sTemp.Left(iIndex) ;
		sTemp = sTemp.Right(sTemp.GetLength() - iIndex - 3) ;

        switch (cDesignator)
        {
            case _T('1'):
                sOutput += pProvider->sBaseName;
                break;

            case _T('2'):
                sOutput += pProvider->sDescription;
                break;

            case _T('3'):
                sOutput += pProvider->sTLBPath;
                break;

            case _T('4'):
                sOutput += pProvider->sLibraryUUID;
                break;

            case _T('5'):
                sOutput += pProvider->sProviderUUID;
                break;

            case _T('6'):
                sOutput += sSystemDirectory;
                break;

            case _T('7'):
                sOutput += pPropSet == NULL ? _T("") : pPropSet->sBaseName;
                break;

            case _T('8'):
                sOutput += pPropSet == NULL ? _T("") : pPropSet->sDescription;
                break;

            case _T('9'):
                sOutput += pPropSet == NULL ? _T("") : pPropSet->sPropSetName;
                break;

            case _T('A'): 
                sOutput += pPropSet == NULL ? _T("") : pPropSet->sPropSetUUID;
                break;

            case _T('B'):
                sOutput += pPropSet == NULL ? _T("") : pPropSet->sClassName;
                break;

            case _T('C'):
                sOutput += pPropSet == NULL ? _T("") : pPropSet->sParentClassName;
                break;

            case _T('D'):
                sOutput +=pPropSet == NULL ? _T("") : GetPropNameDefs(pPropSet);
                break;

//            case _T('E'):
//                sOutput += pPropSet == NULL ? _T("") : GetPropEnums(pPropSet);
//                break;

            case _T('F'):
                sOutput += pPropSet == NULL ? _T("") : GetPropNameExterns(pPropSet);
                break;

//            case _T('G'):
//                sOutput += pPropSet == NULL ? _T("") : GetPropTemplates(pPropSet);
//                break;

            case _T('H'):
                sOutput += pPropSet == NULL ? _T("") : GetPropPuts(pPropSet);
                break;

//					cDesignator == _T('I') ? pPropSet == NULL ? _T("") : GetPropGets(pPropSet);
            case _T('J'):
                sOutput += pPropSet == NULL ? _T("") : pPropSet->sBaseUpcase;
                break;

//            case _T('K'):
//                sOutput += pPropSet == NULL ? _T("") : GetPropertyAttribs(pPropSet);
//                break;

            case _T('L'):
                sOutput += pProvider->sCpp;
                break;

            case _T('M'):
                sOutput += pProvider->sObj;
                break;

            default:
//				CHString(_T("")) ;
                break;
        }

		iIndex = sTemp.Find(_T("%%")) ;
	}

	sOutput += sTemp ;

	// Write the output file
	//======================

    FILE *fOutFile = NULL;
    fOutFile = _tfopen(pszFileSpec, _T("wb"));
    if (fOutFile == NULL)
    {
        return MO_ERROR_FILE_OPEN ;
    }

    _bstr_t ToAnsi(sOutput);
    char *pAnsi = (char *)ToAnsi;
    
    if (fwrite(pAnsi, strlen(pAnsi), 1, fOutFile) != 1)
    {
        fclose(fOutFile);
        return MO_ERROR_FILE_WRITE_ERROR;
    }
    
    fclose(fOutFile);
    
    return MO_SUCCESS ;
}

/*****************************************************************************
*
*  FUNCTION    : MODoubleBackslash
*
*  DESCRIPTION : Converts single backslashes to double backslashes
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

void DoubleBackslash(CHString &sTarget)
{
    WCHAR szTemp[_MAX_PATH] = {0};

	// Convert to string for easier manipulation
	//==========================================

	_tcscpy(szTemp, (LPCWSTR) sTarget) ;
	sTarget = _T("") ;

	WCHAR *pToken = _tcstok(szTemp, _T("\\")) ;
	while(pToken != NULL) 
	{
		sTarget += pToken ;
		sTarget += _T("\\\\") ;
		pToken = _tcstok(NULL, _T("\\")) ;
	}
}

/*****************************************************************************
*
*  FUNCTION    : GetPropNameDefs
*
*  DESCRIPTION : Returns CHString containing property set name definitions
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

CHString GetPropNameDefs(PROPSET_INFO *pPropSet)
{
	PROPERTY_INFO *pProperty ;
	WCHAR szTemp[_MAX_PATH] ;
    
	CHString sTemp;

	if(pPropSet != NULL) 
	{
		pProperty = pPropSet->pPropertyList ;
		while(pProperty != NULL) 
		{
			_stprintf(szTemp, _T("const static WCHAR* %s = L\"%s\" ;\r\n"), 
					(LPCWSTR) pProperty->sPropertyNamePtr,
					(LPCWSTR) pProperty->sName) ;

			sTemp += szTemp ;

			pProperty = pProperty->pNext ;
		}
	}

	return sTemp ;
}    

/*****************************************************************************
*
*  FUNCTION    : GetPropEnums
*
*  DESCRIPTION : Returns CHString containing property TPROP declarations
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

//CHString GetPropEnums(PROPSET_INFO *pPropSet)
//{
//	PROPERTY_INFO *pProperty ;
//	WCHAR szTemp[_MAX_PATH] ;
//    
//	CHString sTemp;
//
//	if(pPropSet != NULL) 
//	{
//		pProperty = pPropSet->pPropertyList ;
//		while(pProperty != NULL) 
//		{
//			if(sTemp.IsEmpty()) 
//			{
//				sTemp = _T(":") ;
//			}
//			else 
//			{
//				_stprintf(szTemp, _T(",\r\n%*s"), pPropSet->sClassName.GetLength() * 2 + 5, _T("")) ;
//				sTemp += szTemp ;
//			}
//
//			_stprintf(szTemp, _T("TPROP(%s)"), (const WCHAR *) pProperty->sProperty) ;
//
//			sTemp += szTemp ;
//
//			pProperty = pProperty->pNext ;
//		}
//	}
//    
//	return sTemp ;
//}        

/*****************************************************************************
*
*  FUNCTION    : GetPropNameExterns
*
*  DESCRIPTION : Returns CHString containing property name external declarations
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

CHString GetPropNameExterns(PROPSET_INFO *pPropSet)
{
	PROPERTY_INFO *pProperty ;
	WCHAR szTemp[_MAX_PATH] ;
    
	CHString sTemp ;

	if(pPropSet != NULL) 
	{
		pProperty = pPropSet->pPropertyList ;
		while(pProperty != NULL) 
		{
			_stprintf(szTemp, _T("extern const WCHAR* %s ;\r\n"), LPCTSTR(pProperty->sPropertyNamePtr)) ;
			sTemp += szTemp ;
			pProperty = pProperty->pNext ;
		}
	}

	return sTemp ;
}    

/*****************************************************************************
*
*  FUNCTION    : GetPropTemplates
*
*  DESCRIPTION : Returns CHString containing property template declarations
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

//CHString GetPropTemplates(PROPSET_INFO *pPropSet)
//{
//	PROPERTY_INFO *pProperty ;
//	WCHAR szTemp[_MAX_PATH] ;
//	CHString sPropAttribs ;
//    
//	CHString sTemp ;
//
//	if(pPropSet != NULL) 
//	{
//		pProperty = pPropSet->pPropertyList ;
//		while(pProperty != NULL) 
//		{
//			// This is easier if we construct the property section separately
//			//===============================================================
//
//			sPropAttribs = BuildPropAttribString(pProperty->dwFlags) ;
//
//			_stprintf(szTemp, _T("        MOProperty <%s, %s, %s, %s, %s> %s ;\r\n"),
//					pProperty->dwType == MO_PROPTYPE_DWORD      ? _T("DWORD")       :
//					pProperty->dwType == MO_PROPTYPE_CHString    ? _T("CHString")    :
//					pProperty->dwType == MO_PROPTYPE_BOOL       ? _T("bool")     : 
//					pProperty->dwType == MO_PROPTYPE_DATETIME   ? _T("WBEMTime")    : _T("Variant"),
//					(const WCHAR *) pProperty->sPropertyNamePtr,
//					(const WCHAR *) sPropAttribs,
//					(const WCHAR *) pProperty->sPutMethod,
//					(const WCHAR *) pProperty->sGetMethod,
//					(const WCHAR *) pProperty->sProperty) ;
//
//			sTemp += szTemp ;
//        
//			pProperty = pProperty->pNext ;
//		}
//	}
//
//	return sTemp ;
//}    

/*****************************************************************************
*
*  FUNCTION    : GetPropertyAttribs
*
*  DESCRIPTION : Returns CHString containing run-time property attribute
*                assignments
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

//CHString GetPropertyAttribs(PROPSET_INFO *pPropSet)
//{
//	PROPERTY_ATTRIB_INFO *pPropAttrib ;
//	WCHAR szTemp[_MAX_PATH] ;
//	CHString sPropAttribs ;
//    
//	CHString sTemp ;
//
//	if(pPropSet != NULL) 
//	{
//		pPropAttrib = pPropSet->pPropertyAttribList ;
//		while(pPropAttrib != NULL) 
//		{
//			sPropAttribs = BuildPropAttribString(pPropAttrib->dwFlags) ;
//			_stprintf(szTemp, _T("    %s.SetAttributes(%s) ;\r\n"), 
//					(const WCHAR *) pPropAttrib->sProperty,
//					(const WCHAR *) sPropAttribs) ;
//
//			sTemp += szTemp ;
//
//			pPropAttrib = pPropAttrib->pNext ;
//		} 
//	}
//
//	return sTemp ;
//}    

/*****************************************************************************
*
*  FUNCTION    : BuildPropAttribString
*
*  DESCRIPTION : Constructs textual representation of property attributes
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

//CHString BuildPropAttribString (DWORD dwFlags)
//{
//	CHString sAttribs ;
//
//	if(dwFlags & MO_ATTRIB_READ) 
//	{
//		if(!sAttribs.IsEmpty()) 
//		{
//			sAttribs += _T(" | ") ;
//		}
//		sAttribs += _T("PROPERTY_READABLE") ;
//	}
//
//	if(dwFlags & MO_ATTRIB_WRITE) 
//	{
//		if(!sAttribs.IsEmpty()) 
//		{
//			sAttribs += _T(" | ") ;
//		}
//		sAttribs += _T("PROPERTY_WRITEABLE") ;
//	}
//
//	if(dwFlags & MO_ATTRIB_VOLATILE) 
//	{
//		if(!sAttribs.IsEmpty()) 
//		{
//			sAttribs += _T(" | ") ;
//		}
//		sAttribs += _T("PROPERTY_VOLATILE") ;
//	}
//
//	if(dwFlags & MO_ATTRIB_EXPENSIVE) 
//	{
//		if(!sAttribs.IsEmpty()) 
//		{
//			sAttribs += _T(" | ") ;
//		}
//		sAttribs += _T("PROPERTY_EXPENSIVE") ;
//	}
//
//	if(dwFlags & MO_ATTRIB_KEY) 
//	{
//		if(!sAttribs.IsEmpty()) 
//		{
//			sAttribs += _T(" | ") ;
//		}
//		sAttribs += _T("PROPERTY_KEY") ;
//	}
//
//	if(sAttribs.IsEmpty()) 
//	{
//		sAttribs = _T("0") ;
//	}
//
//	return sAttribs ;
//}

/*****************************************************************************
*
*  FUNCTION    : GetPropPuts
*
*  DESCRIPTION : Returns CHString containing run-time property attribute
*                assignments
*
*  INPUTS      :
*
*  OUTPUTS     :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/

CHString GetPropPuts (PROPSET_INFO *pPropSet)
{
	WCHAR szTemp[_MAX_PATH] ;
	CHString sPutType;
    PPROPERTY_INFO	pProperty = NULL;
	CHString sTemp = _T("");

	if (NULL != pPropSet)
	{
		pProperty = pPropSet->pPropertyList;
		
		while (NULL != pProperty)
		{
			_stprintf(szTemp, _T("//        pInstance->Set%s(%s, <Property Value>);\r\n"),
					pProperty->dwType == MO_PROPTYPE_DWORD      ? _T("DWORD")       :
					pProperty->dwType == MO_PROPTYPE_CHString   ? _T("CHString")    :
					pProperty->dwType == MO_PROPTYPE_BOOL       ? _T("bool")     : 
					pProperty->dwType == MO_PROPTYPE_DATETIME   ? _T("WBEMTime")    : 
					_T("Variant"),
					(LPCTSTR)pProperty->sPropertyNamePtr);

			sTemp += szTemp ;

			pProperty = pProperty->pNext;
		}

	}
	return sTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\moengine\include\resource.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MOENGINE.H
//
//  Purpose: Microsoft Developer Studio generated include file.  Used by 
//           MOEngine.rc
//
//***************************************************************************

//{{NO_DEPENDENCIES}}
#define IDR_TEMPLATE_DEF                102
#define IDR_TEMPLATE_CPP                103
#define IDR_TEMPLATE_H                  105
#define IDR_TEMPLATE_ODL                106
#define IDR_TEMPLATE_OLE                107
#define IDR_TEMPLATE_MOF                108
#define IDR_TEMPLATE_REG                109
#define IDR_TEMPLATE_DLL				110
#define IDR_TEMPLATE_MAK				111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\moengine\include\moengine.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MOENGINE.H
//
//  Purpose: Code-generation engine for framework providers
//
//***************************************************************************

#define DllImport   __declspec( dllimport )
#define DllExport   __declspec( dllexport )

// Error codes
//============

#define MO_INVALID_ID                   0x00

#define MO_SUCCESS                      0x00
#define MO_ERROR_PROVIDER_NOT_FOUND     0x01
#define MO_ERROR_INVALID_FILENAME       0x02
#define MO_ERROR_FILE_OPEN              0x03
#define MO_ERROR_TEMPLATE_NOT_FOUND     0x04
#define MO_ERROR_INVALID_PARAMETER      0x05
#define MO_ERROR_PROPSET_NOT_FOUND      0x06
#define MO_ERROR_MEMORY                 0x07
#define MO_ERROR_DIRECTORY              0x08
#define MO_ERROR_FILES_EXIST            0x09
#define MO_ERROR_DIRECTORY_NOT_FOUND    0x0A
#define MO_ERROR_FILE_WRITE_ERROR       0x0B

#define MO_PROPTYPE_UNKNOWN             0x00
#define MO_PROPTYPE_DWORD               0x01
#define MO_PROPTYPE_CHString            0x02
#define MO_PROPTYPE_BOOL                0x03
#define MO_PROPTYPE_DATETIME            0x04

#define MO_ATTRIB_READ                  0x01
#define MO_ATTRIB_WRITE                 MO_ATTRIB_READ      << 1
#define MO_ATTRIB_VOLATILE              MO_ATTRIB_WRITE     << 1
#define MO_ATTRIB_EXPENSIVE             MO_ATTRIB_VOLATILE  << 1
#define MO_ATTRIB_KEY                   MO_ATTRIB_EXPENSIVE << 1

#ifdef MO_ENGINE_PROGRAM

// Internal structures
//====================

typedef struct _PROPERTY_ATTRIB_INFO
{
    struct _PROPERTY_ATTRIB_INFO   *pNext ;
    CHString                        sProperty ;
    DWORD                           dwFlags ;
} PROPERTY_ATTRIB_INFO, *PPROPERTY_ATTRIB_INFO ;

typedef struct _PROPERTY_INFO
{
    struct _PROPERTY_INFO  *pNext ;
    CHString                 sProperty ;
    CHString                 sPropertyNamePtr ;
    CHString                 sName ;
    CHString                 sPutMethod ;
    CHString                 sGetMethod ;
    DWORD                   dwType ;
    DWORD                   dwFlags ;

} PROPERTY_INFO, *PPROPERTY_INFO ;

typedef struct _PROPSET_INFO
{
    struct _PROPSET_INFO   *pNext ;
    DWORD                   dwPropSetID ;
    CHString                 sBaseName ;
    CHString                 sBaseUpcase ;
    CHString                 sDescription ;
    CHString                 sPropSetName ;
    CHString                 sPropSetUUID ;
    CHString                 sClassName ;
    CHString                 sParentClassName ;
    WCHAR                    szCPPFileSpec[_MAX_PATH] ;
    WCHAR                    szHFileSpec[_MAX_PATH] ;
    PPROPERTY_INFO          pPropertyList ;
    PPROPERTY_ATTRIB_INFO   pPropertyAttribList ;
    
} PROPSET_INFO, *PPROPSET_INFO ;

typedef struct _PROVIDER_INFO
{
    struct _PROVIDER_INFO   *pNext ;
    DWORD                    dwProviderID ;
    CHString                 sBaseName ;
    CHString                 sDescription ;
    CHString                 sOutputPath ;
    CHString                 sTLBPath ;
    CHString                 sLibraryUUID ;
    CHString                 sProviderUUID ;
    CHString                 sCpp;
    CHString                 sObj;
    WCHAR                    szDEFFileSpec[_MAX_PATH] ;
    WCHAR                    szIDLFileSpec[_MAX_PATH] ;
    WCHAR                    szOLEFileSpec[_MAX_PATH] ;
    WCHAR                    szMOFFileSpec[_MAX_PATH] ;
	WCHAR 					 szMAKFileSpec[_MAX_PATH] ;
    PPROPSET_INFO            pPropSetList ;

} PROVIDER_INFO, *PPROVIDER_INFO ;

#endif

// Primary function prototypes
//============================

BOOL APIENTRY DllMain(HINSTANCE hInstance, 
                      DWORD     dwReasonForCall, 
                      LPVOID    lpReserved) ;

DllExport DWORD MOProviderOpen(LPCWSTR pszBaseName,
                               LPCWSTR pszDescription,
                               LPCWSTR pszOutputDirectory,
                               LPCWSTR pszTLBPath,
                               LPCWSTR pszLibraryUUID,
                               LPCWSTR pszProviderUUID) ;

DllExport DWORD MOProviderClose(DWORD     dwProviderID, 
                                BOOL      bForceFlag) ;

DllExport void MOProviderCancel(DWORD     dwProviderID) ;

DllExport DWORD MOPropSetOpen(DWORD       dwProviderID,
                              LPCWSTR     pszBaseName,
                              LPCWSTR     pszDescription,
                              LPCWSTR     pszPropSetName,
                              LPCWSTR     pszPropSetUUID,
                              LPCWSTR     pszClassName,
                              LPCWSTR     pszParentClassName) ;

DllExport DWORD MOPropertyAdd(DWORD       dwProviderID,
                              DWORD       dwPropSetID,
                              LPCWSTR     pszProperty,
                              LPCWSTR     pszName,
                              LPCWSTR     pszPutMethod,
                              LPCWSTR     pszGetMethod,
                              DWORD       dwType,
                              DWORD       dwFlags) ;

DllExport DWORD MOPropertyAttribSet(DWORD       dwProviderID,
                                    DWORD       dwPropSetID,
                                    LPCWSTR     pszProperty,
                                    DWORD       dwFlags) ;

DllExport DWORD MOGetLastError(void) ;


#ifdef MO_ENGINE_PROGRAM

// Utility function protos
//========================

DWORD           MONewProviderID(void) ;
DWORD           MONewPropSetID(PROVIDER_INFO *pProvider) ;
PROVIDER_INFO  *GetProviderFromID(DWORD dwProviderID) ;
PROPSET_INFO   *GetPropSetFromID(PROVIDER_INFO *pProvider, DWORD dwPropSetID) ;
DWORD           MOProviderDestroy(DWORD dwProviderID) ;
WCHAR           *MOCreateUUID(void) ;
DWORD           CreateProviderFile(PROVIDER_INFO *pProvider,
                                   PROPSET_INFO  *pPropSet,
                                   LPCWSTR        pszFileSpec,
                                   DWORD          dwTemplateID) ;
DWORD           CreateProviderMOF(PROVIDER_INFO *pProvider) ;
void            DoubleBackslash(CHString &sTarget) ;

CHString         GetPropNameDefs(PROPSET_INFO *pPropSet) ;
CHString         GetPropNameExterns(PROPSET_INFO *pPropSet) ;
CHString         GetPropPuts(PROPSET_INFO *pPropSet) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\moengine\template\template.h ===
/******************************************************************

Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

   %%7.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   %%8

*******************************************************************/

// Property set identification
//============================

#ifndef _%%7_H_
#define _%%7_H_

#define PROVIDER_NAME_%%J L"%%9"

// Property name externs -- defined in %%7.cpp
//=================================================

%%F
class %%B : public %%C 
{
    public:
        // Constructor/destructor
        //=======================

        %%B(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~%%B();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    private:
        // All data members for %%B should be included here.   

} ;

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The above sequance of tildes must not be removed.  This file is included
in MOENGINE as a resource, and is not NULL-terminated, requiring a unique
substring to identify the end of file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\clsfltr\precomp.h ===
#include <stdio.h>
#include <windows.h>
#include <malloc.h>

#define BIGBUFF 255
#define MAXENTRIES 1000

#define NAMESPACE 1
#define CLASS 2
#define PROPERTY 3
#define BLANK 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\clsfltr\clsfltr.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// clsfltr - filter classes and properties from wbemdumps
//
// see clsfltr /? for command line switches
//

#include "precomp.h"

int GetType(char *szBuff);
void WriteIt(char *szBuff, FILE *fOut, BOOL bRev);
int IsIn(char *szClass, char *szProperty);

int igRows;
char *szClassName[MAXENTRIES], *szPropertyName[MAXENTRIES];

int __cdecl main (int argc, char *argv[])
{

   FILE *fIn, *fOut, *fFltr;
   char szCurClass[BIGBUFF], szBuff[BIGBUFF];
   int x, dwRet;
   char *szHelp = "clsfltr - filter classes and properties from wbemdumps\n\n"
                  "Syntax: clsfltr <InputFile> <OutputFile> <FilterFile>\n"
                  "\n"
                  "Where:  <InputFile> is the redirectred output from WBEMDump\n"
                  "        <OutputFile> is the name of the file to write output to\n"
                  "        <FilterFile> is a file containing info about what lines\n"
                  "           to filter out of the InputFile\n\n"
                  "        Filter information is stored as a standard text file.  Each\n"
                  "        line in the file looks like one of the following:\n\n"
                  "           Win32LogicalDisk FreeSpaceInBytes\n"
                  "           Win32CurrentNetworkConnection *\n\n"
                  "        The first line will filter just the property FreeSpaceInBytes\n"
                  "        from all instances of the class Win32LogicalDisk in the input\n"
                  "        file.  The second line filters the entire\n"
                  "        Win32CurrentNetworkConnection class.\n"
                  "\n";

   // If not enough args, print the help
   if (argc < 4) {
      fputs(szHelp, stdout);
      return -1;
   }

   // Open the input, output, and filter files
   fIn = fopen(argv[1], "r");
   fOut = fopen(argv[2], "w");
   fFltr = fopen(argv[3], "r");

   if ((fIn == NULL) || (fOut == NULL) || (fFltr == NULL)) {
      printf("Failed to open file\n");
      return -1;
   }

   //=======================================================
   // Load the filter file

   // From the top
   if(!fseek(fFltr, 0L, SEEK_SET))
   {
       igRows = 0;  // Count how many rows we read

       while (!feof(fFltr)) {
          dwRet = fscanf(fFltr, "%s ", szBuff);

          // Read the class name and store it
          if (dwRet != -1) {
             szClassName[igRows] = (char *)malloc(strlen(szBuff) + 1);
             if(szClassName[igRows])
             {
                 strcpy(szClassName[igRows], szBuff);

                 // Read the property nane and store it
                 dwRet = fscanf(fFltr, "%s", szBuff);
                 if (dwRet != -1) {
                    szPropertyName[igRows] = (char *)malloc(strlen(szBuff) + 1);
                    if(szPropertyName[igRows])
                    {
                        strcpy(szPropertyName[igRows], szBuff);
                    }
                 }
             }
          }

          // If we found both a class and a property
          if (dwRet != -1) {
             igRows++;
          }
       }
   }
   // Done with the filter file
   fclose(fFltr);

   //=======================================================
   // Start walking through the input file
   if(fgets(szBuff, sizeof(szBuff), fIn))
   {
       while (!feof(fIn)) {
   
          // Find out what type of line we just read and react accordingly
          switch (GetType(szBuff)) {
          case NAMESPACE:
             // This is the namespace line.  Write it and continue on.
             WriteIt(szBuff, fOut, TRUE);
             fgets(szBuff, sizeof(szBuff), fIn);
             break;
          case CLASS:
             // This is a class line.  Check to see if it is in the filter list
             x = IsIn(szBuff, NULL);
             if (x == -1) {  // If it is not in the filter list at all
                // Write the class name, and all the properties until we run
                // out of properties
                WriteIt(szBuff, fOut, TRUE);
                fgets(szBuff, sizeof(szBuff), fIn);
                while (GetType(szBuff) == PROPERTY) {
                   WriteIt(szBuff, fOut, TRUE);
                   fgets(szBuff, sizeof(szBuff), fIn);
                }
             } else {
                // It is in the filter list, is it an ignore all?
                if (strcmp(szPropertyName[x], "*") == 0) {
                   // Skip all the properties for this class
                   do {
                      WriteIt(szBuff, fOut, FALSE);
                      fgets(szBuff, sizeof(szBuff), fIn);
                   } while (GetType(szBuff) == PROPERTY);
                } else {
                   // Just ignore specific properties

                   strcpy(szCurClass, szBuff);  // Save the class name               
                   WriteIt(szBuff, fOut, TRUE);  // Write the current line
                   fgets(szBuff, sizeof(szBuff), fIn);  // Get the next line

                   while (GetType(szBuff) == PROPERTY) {
                      // If this line is an ignore line, ignore it, else write it
                      if (IsIn(szCurClass, szBuff) != -1) {
                         WriteIt(szBuff, fOut, FALSE);
                      } else {
                         WriteIt(szBuff, fOut, TRUE);
                      }
                      fgets(szBuff, sizeof(szBuff), fIn);  // Get the next line
                   }
                }
             }
             break;
          case BLANK:
             // Blank line.  Write it, get the next.
             WriteIt(szBuff, fOut, TRUE);
             fgets(szBuff, sizeof(szBuff), fIn);
             break;
          default:
             break;
          } // end switch
       }  // end while
    }

   // Close the files and exit
   fclose(fIn);
   fclose(fOut);

   // Be nice and clean up after ourselves...
   for(long z = 0L;
       z < MAXENTRIES;
       z++)
   {
      if(szClassName[z])
      {
          free(szClassName[z]); szClassName[z] = NULL;
      }
      if(szPropertyName[z])
      {
          free(szPropertyName[z]); szPropertyName[z] = NULL;
      }
   }

   return 0;

}

//================================================================
// GetType - Find out what type of line this is.
//
int GetType(char *szBuff)
{
   char *pBuff;
   int iType;

   pBuff = szBuff;

   while ((*pBuff == ' ') || (*pBuff == '\t'))
      pBuff++;

   if (pBuff[0] == '<') {
      iType = NAMESPACE;
   } else {
         if (strchr(pBuff, '=')) {
            iType = PROPERTY;
         } else {
            if (pBuff[0] == '\n') {
               iType = BLANK;
            } else {
               iType = CLASS;
            }
         }
      }

   return iType;
}

//================================================================
// WriteIt - if bRev == TRUE, print the line, else just return
//
void WriteIt(char *szBuff, FILE *fOut, BOOL bRev)
{
   if (bRev) {
      fputs(szBuff, fOut);
   }
}

//================================================================
// IsIn - find out if the specified class and property is in
//        the filter list.  If property is null, the first instance
//        of the class is searched for.  The return value is the
//        index into the filter list of the match or -1 for not
//        found.
//
int IsIn(char *szClass, char *szProperty)
{
   int x;
   char *pChar;
   char szBuff[BIGBUFF];
   char szBuff2[BIGBUFF];

   pChar = szClass;
   // Trim leading spaces from class
   while ((*pChar == ' ') || (*pChar == '\t')) {
      pChar ++;
   }

   // Make a local copy
   strcpy(szBuff, pChar);

   // Drop the \n
   szBuff[strlen(szBuff) - 1] = '\0';

   // If a property was passed, trim it too
   if (szProperty != NULL) {
      pChar = szProperty;
      while ((*pChar == ' ') || (*pChar == '\t')) {
         pChar ++;
      }

      strcpy(szBuff2, pChar);
      pChar = szBuff2;
      while (*pChar != ' ') {
         pChar ++;
      }
      *pChar = '\0';
   }

   // Walk the filter list looking for a match
   for (x=0; x < igRows; x++) {
      if (_stricmp(szClassName[x], szBuff) == 0) {
         if (szProperty == NULL) {
            return x;
         } else {
            if (_stricmp(szBuff2, szPropertyName[x]) == 0) {
               return x;
            }
         }
      }
   }

   return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\moengine\template\template.cpp ===
/******************************************************************

Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

   %%7.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   %%8
  
  
******************************************************************/

#include <fwcommon.h>  // This must be the first include.

#include "%%7.h"

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================
%%B My%%7Set (PROVIDER_NAME_%%J, L"NameSpace") ;

// Property names
//===============
%%D
/*****************************************************************************
 *
 *  FUNCTION    :   %%B::%%B
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
%%B::%%B (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    %%C(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   %%B::~%%B
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
%%B::~%%B ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    %%B::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must 
*                       be filled in.  If there are no instances, return 
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/
HRESULT %%B::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

// TO DO: The following commented lines contain the 'set' methods for the
//        properties entered for this class.  They are commented because they
//        will NOT compile in their current form.  Each <Property Value> should be
//        replaced with the appropriate value.  Also, consider creating a new
//        method and moving these set statements and the ones from GetObject 
//        into that routine.  See the framework sample (ReindeerProv.cpp) for 
//        an example of how this might be done.
//
//        If the expectation is that there is more than one instance on the machine
//        EnumerateInstances should loop through the instances and fill them accordingly.
//
//        Note that you must ALWAYS set ALL the key properties.  See the docs for
//        further details.
///////////////////////////////////////////////////////////////////////////////
//    while ((!<DoneEnumeratingInstances>) && (SUCCEEDED(hRes))) 
//    {
//
//        // Create a new instance based on the passed-in MethodContext.
//        // Note that CreateNewInstance may throw, but will never return NULL.
//        CInstance* pInstance = CreateNewInstance(pMethodContext);
//
%%H//
//        hRes = pInstance->Commit();
//        pInstance->Release();
//  }

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    %%B::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/
HRESULT %%B::GetObject ( CInstance* pInstance, long lFlags )
{
    // TO DO: The GetObject function is used to search for an instance of this
    //        class on the machine based on the key properties.  Unlike
    //        EnumerateInstances which finds all instances on the machine, GetObject
    //        uses the key properties to find the matching single instance and 
    //        returns that instance.
    //
    //        Use the CInstance Get functions (for example, call 
    //        GetCHString(L"Name", sTemp)) against pInstance to see the key values 
    //        the client requested.
    HRESULT hr = WBEM_E_NOT_FOUND;

//    if (<InstanceExists>)
//    {
// TO DO: The following commented lines contain the 'set' methods for the
//        properties entered for this class.  They are commented because they
//        will NOT compile in their current form.  Each <Property Value> should be
//        replaced with the appropriate value.
//
%%H//
//        hr = WBEM_S_NO_ERROR;
//    }

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    %%B::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT %%B::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
     return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : %%B::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT %%B::PutInstance ( const CInstance &Instance, long lFlags)
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :    %%B::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT %%B::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :    %%B::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT %%B::ExecMethod ( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags)
{
    // For non-static methods, use the CInstance Get functions (for example, 
    // call GetCHString(L"Name", sTemp)) against Instance to see the key 
    // values the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The above sequence of tildes must not be removed.  This file is included
in MOENGINE as a resource, and is not NULL-terminated, requiring a unique
substring to identify the end of file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\delobj\delobj.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Turns off sections of windows.h

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
//#define NOCTLMGR
#define NODRAWTEXT
//#define NOGDI
#define NOKERNEL
//#define NOUSER
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
//#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NOMCX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\delobj\delobj.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// delobj - delete the specified object
//
// see delobj /? for command line options
//
// Notes: Most of this program is figuring out what they
//        want to delete.

#pragma warning(disable:4514 4201)

#include "delobj.h"    // this must come before windows.h

//#include <windows.h>  // Not needed since wbemsvc re-includes it
#include <stdio.h>      // fprintf
#include <wbemidl.h>     // hmm interface declarations
#include <utillib.h>
#include "genlex.h"
#include "objpath.h"
#include <wbemsec.h>

// Function declarations
void Init(IWbemServices **ppIWbemServices, WCHAR *pNamespace);
DWORD ProcessCommandLine(int argc, wchar_t *argv[]);
void FillIn(ParsedObjectPath **pclPath);

// Global variables
WCHAR *pwcsGUserID = NULL;
WCHAR *pwcsGPassword = NULL;
BSTR pwcsGNamespace = NULL;
WCHAR *pwcsGAuthority = NULL; // Authority for ConnectServer
long lGSFlags = 0;            // Security flags for ConnectServer
long lGImpFlag = RPC_C_IMP_LEVEL_IMPERSONATE;            // Impersonation level (-1 means use default)
DWORD dwGErrorFlags = 0;

//***************************************************************************
//
// wmain - used wmain since the command line parameters come in as wchar_t
//
//***************************************************************************
extern "C" int __cdecl wmain(int argc, wchar_t *argv[])
{
   SCODE sc;
   IWbemServices *pIWbemServices = NULL;
   int iSize;
   WCHAR *pNS;
   WCHAR *pwszPath;

   if (ProcessCommandLine(argc, argv) != S_OK) 
   {
      return(1);
   }

   CObjectPathParser clParse;
   ParsedObjectPath *clPath = NULL;

   // Parse out the elements of the path
   clParse.Parse(pwcsGNamespace, &clPath);

   // If the parse failed
   if (clPath == NULL) 
   {
      printf("Invalid path.\n");
      return 0;
   }

   // Populate any missing fields (like the server name or root\default)
   FillIn(&clPath);

   // Get the connect path
   iSize = wcslen(clPath->m_pServer);
   iSize += wcslen(clPath->GetNamespacePart());
   iSize += 4; // for initial \\, delimiter between server and class, and trailing null

   pNS = new WCHAR[iSize];
   if (!pNS)
   {
       printf("Out of memory\n");
       exit(1);
   }

   wcscpy(pNS, L"\\\\");
   wcscat(pNS, clPath->m_pServer);
   wcscat(pNS, L"\\");
   wcscat(pNS, clPath->GetNamespacePart());

   // Now, connect to cimom
   Init(&pIWbemServices, pNS);        // Connect to hmm

   // Get the path (excluding machine and ns)
   clParse.Unparse(clPath, &pwszPath);

   // If there are keys, we are deleting an instance
   if ((clPath->m_dwNumKeys > 0) || (clPath->m_bSingletonObj)) 
   {
      printf("Deleting instance ");
      sc = pIWbemServices->DeleteInstance(bstr_t(pwszPath), 0, NULL, NULL);
   } 
   else 
   { // no keys means a class
      printf("Deleting class ");
      sc = pIWbemServices->DeleteClass(bstr_t(pwszPath), 0, NULL, NULL);
   }

   // Free unneeded items
   delete pwszPath;
   delete pNS;
   clParse.Free(clPath);

   // Print the results
   if (sc != S_OK) 
   {
      PrintErrorAndExit("failed!", sc, dwGErrorFlags);
   } 
   else 
   {
      printf("succeeded.\n");
   }

   pIWbemServices->Release();
   OleUninitialize();               // Wrapup and exit

   return 0;
}

//***************************************************************************
// Function:   Init
//
// Purpose:   1 - Perform OLE initialization
//            2 - Create an instance of the MosLocator interface
//            3 - Use the pointer returned in step two to connect to
//                the server using the root\default namespace.
//***************************************************************************
void Init(IWbemServices **ppIWbemServices, WCHAR *pNamespace)
{
   HRESULT hr;
   DWORD   dwRes;
   SCODE  sc;
   IWbemLocator *pIWbemLocator = NULL;

//------------------------------------------------------------------------------------------
// 1.  OLE initialization.

   hr = OleInitialize(NULL);

   if (hr != S_OK) 
   {
      PrintErrorAndExit("OleInitialize Failed\nTerminating abnormally\n", hr, dwGErrorFlags);  //exits program
   }

// Get a session object.
// 2 - Create an instance of the MosLocator interface

   dwRes = CoCreateInstance(CLSID_WbemLocator,
                      NULL,
                      CLSCTX_INPROC_SERVER,
                      IID_IWbemLocator,
                      (LPVOID *) &pIWbemLocator);

   if (dwRes != S_OK) 
   {
      PrintErrorAndExit("Failed to create IWbemLocator object\n"
                 "Abnormal Termination\n", dwRes, dwGErrorFlags); // exits program
   }

//   3 - Use the pointer returned in step two to connect to
//       the server using the passed in namespace.

   sc = pIWbemLocator->ConnectServer(bstr_t(pNamespace),
                            pwcsGUserID, pwcsGPassword, NULL, // User, pw, locale
                            lGSFlags,        // flags
                            pwcsGAuthority,  // Authority
                            NULL,            // Context
                            ppIWbemServices
                           );
   if (sc != S_OK) 
   {
      PrintErrorAndExit("ConnectServer failed", sc, dwGErrorFlags); //exits program
   }
 
   DWORD dwAuthLevel, dwImpLevel;
   sc = GetAuthImp(*ppIWbemServices, &dwAuthLevel, &dwImpLevel);
   if (sc != S_OK) 
   {
       PrintErrorAndExit("GetAuthImp Failed on ConnectServer", sc, dwGErrorFlags);
   }

   if (lGImpFlag != -1) 
   {
       dwImpLevel = lGImpFlag;
   }

   sc = SetInterfaceSecurity(*ppIWbemServices, pwcsGAuthority, pwcsGUserID, pwcsGPassword, dwAuthLevel, dwImpLevel);
   if (sc != S_OK) 
   {
      PrintErrorAndExit("SetInterfaceSecurity Failed on ConnectServer", sc, dwGErrorFlags);
   }

   pIWbemLocator->Release();
   pIWbemLocator = NULL;
}

//*****************************************************************************
// Function:   ProcessCommandLine
// Purpose:    This function processes the command line for the program, 
//             filling in the global variables determining what the program 
//             will do.
//*****************************************************************************
DWORD ProcessCommandLine(int argc, wchar_t *argv[])
{
   int iLoop, iPlace;
   int iRetVal = S_OK;
   char *szHelp = "DelObj - Deletes the specified Object\n\n"
                  "Syntax:  DelObj [switches] <ObjectPath>\n"
                  "Where:   'ObjectPath' is the object (either class or instance) to delete\n"
                  "         'switches' is one or more of\n"
                  "           /U:<UserID> UserID to connect with (default: NULL)\n"
                  "           /P:<Password> Password to connect with (default: NULL)\n"
                  "           /F:<SecurityFlag> 0=DEFAULT; 1=NTLM; 2=WBEM\n"
                  "           /A:<Authority> Authority to connect with\n"
                  "           /I:<ImpLevel> Anonymous=1 Identify=2 Impersonate=3(dflt) Delegate=4\n"
                  "\n"
                  "Examples:\n"
                  "\n"
                  "   DelObj \\\\DAVWOH2\\ROOT\\DEFAULT:SClassA\n"
                  "   DelObj root:__namespace.name=\\\"queries\\\"\n"
                  "   DelObj \\ROOT\\DEFAULT:SClassA.Name=\\\"foo\\\"\n"
                  "   DelObj /u:administrator /p:xxx SClassA.Name=\\\"foo\\\"\n"
                  "   DelObj SClassA\n"
                  "   DelObj \\\\.\\root\\default\\SClassA\n"
                  "\n";

   // Process all the arguments.
   // ==========================

   iPlace = 0;

   // Set global flags depending on command line arguments
   for (iLoop = 1; iLoop < argc; ++iLoop) 
   {
      if (_wcsicmp(argv[iLoop], L"/HELP") == 0 || _wcsicmp(argv[iLoop],L"-HELP") == 0 || 
         (wcscmp(argv[iLoop], L"/?") == 0) || (wcscmp(argv[iLoop], L"-?") == 0)) 
      {
         fputs(szHelp, stdout);
         return(S_FALSE);
      } 
      else if (_wcsnicmp(argv[iLoop], L"/U:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-U:", 3) == 0) 
      {
         pwcsGUserID = (argv[iLoop])+3;
      } 
      else if (_wcsnicmp(argv[iLoop], L"/P:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-P:", 3) == 0) 
      {
         pwcsGPassword = (argv[iLoop])+3;
      } 
      else if (_wcsnicmp(argv[iLoop], L"/F:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-F:", 3) == 0) 
      {
         lGSFlags = _wtoi((argv[iLoop])+3);
      } 
      else if (_wcsnicmp(argv[iLoop], L"/W:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-W:", 3) == 0) 
      {
         dwGErrorFlags = _wtoi((argv[iLoop])+3);
      } 
      else if (_wcsnicmp(argv[iLoop], L"/A:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-A:", 3) == 0) 
      {
         pwcsGAuthority = (argv[iLoop])+3;
      } 
      else if (_wcsnicmp(argv[iLoop], L"/I:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-F:", 3) == 0) 
      {
         lGImpFlag = _wtoi((argv[iLoop])+3);
      } 
      else 
      {
         switch (iPlace) 
         {
             case 0:
                pwcsGNamespace = argv[iLoop];
                break;
             default:
                break;
         }
         ++iPlace;
      }
   }

   // See if we got enough arguments.
   // ===============================

   if (iPlace != 1) 
   {
      fputs(szHelp, stdout);
      return(S_FALSE);
   }

   // Finished.
   // =========

   return(S_OK);
}


//***************************************************************************
//
// FillIn - Fills in default server name and namespace for a ParsedObjectPath
//          if they were not specified.
//
//***************************************************************************
void FillIn(ParsedObjectPath **pclPath)
{

   WCHAR **pRoot;
   if ((*pclPath)->m_pServer == NULL) 
   {
      (*pclPath)->m_pServer = new WCHAR[2];

	  if ((*pclPath)->m_pServer)
	  {
        wcscpy((*pclPath)->m_pServer, L".");
	  }
      else
      {
          printf("Out of memory\n");
          exit(1);
      }
   }

   if ((*pclPath)->m_dwNumNamespaces < 1) 
   {
      pRoot = new WCHAR*[2];
      if(pRoot)
      {
        pRoot[0] = new WCHAR[(sizeof(L"root")/sizeof(WCHAR)) + 1];
        pRoot[1] = new WCHAR[(sizeof(L"default")/sizeof(WCHAR)) + 1];
      }
      else
      {
          printf("Out of memory\n");
          exit(1);
      }

      if(pRoot[0])
      {
          wcscpy(pRoot[0], L"root");
      }
      else
      {
          printf("Out of memory\n");
          exit(1);
      }

      if(pRoot[1]) 
      {
          wcscpy(pRoot[1], L"default");
      }
      else
      {
          printf("Out of memory\n");
          exit(1);
      }

      (*pclPath)->m_paNamespaces = pRoot;
      (*pclPath)->m_dwNumNamespaces = 2;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//
#define _WIN32_DCOM


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\utils.cpp ===
// **************************************************************************

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// File:  utils.cpp
//
// Description:
//    Set of sample routines
//
// History:
//
// **************************************************************************

//#pragma warning(disable:4201)  // nonstandard extension nameless struct (used in windows.h)
//#pragma warning(disable:4514)  // unreferenced inline function has been removed (used in windows.h)

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>
#include <sys\timeb.h>
#include "utillib.h"

//*****************************************************************************
// Function:   WbemErrorString
// Purpose:    Turns sc into a text string
//*****************************************************************************
BSTR WbemErrorString(SCODE sc)
{
    IWbemStatusCodeTextPtr pStatus;
    BSTR bstr = NULL;

    SCODE mysc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

    if (mysc == S_OK)
    {
        mysc = pStatus->GetErrorCodeText(sc, 0, 0, &bstr);
        if (mysc == S_OK)
        {
        }
        else
        {
            WCHAR szBuffer2[MAXITOA];
            WCHAR szBuffer[sizeof(szBuffer2) + 4];

            _ltow(sc, szBuffer2, 16);
            wcscpy(szBuffer, L"0x");
            wcscat(szBuffer, szBuffer2);
            bstr = SysAllocString(szBuffer);
        }
    }

    return bstr;
}

//***************************************************************************
// Function:  PrintError
// Purpose:   Formats and prints the error message
//***************************************************************************
void PrintError(char *pszFailureReason, SCODE psc, DWORD dwMode)
{
    VARIANT varString;
    SCODE sc;
    IWbemClassObject *pErrorObject = NULL;
    IErrorInfo* pEI = NULL;

    fprintf(stdout, "%s\n", pszFailureReason);
    fprintf(stdout, "FunctionReturn: %S(0x%08lx)\n", WbemErrorString(psc), psc);

    if (GetErrorInfo(0, &pEI) == S_OK)
    {
        pEI->QueryInterface(IID_IWbemClassObject, (void**)&pErrorObject);
        pEI->Release();
    }

    if (pErrorObject != NULL)
    {
        VariantInit(&varString);

        if (dwMode == ERROR_MODE_PRINTFIELDS)
        {
            if (pErrorObject->InheritsFrom(L"__NotifyStatus") != WBEM_NO_ERROR)
            {
                fprintf(stdout, "Unrecognized Error Object type\n");
            }
            else if (pErrorObject->InheritsFrom(L"__ExtendedStatus") == WBEM_NO_ERROR)
            {
                sc = pErrorObject->Get(L"Description", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get Description: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"Description: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);

                pErrorObject->Get(L"Operation", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get Operation: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"Operation: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);

                pErrorObject->Get(L"ParameterInfo", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get ParameterInfo: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"ParameterInfo: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);

                pErrorObject->Get(L"ProviderName", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get ProviderName: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"ProviderName: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);
            }
        }
        else
        {
            BSTR bstrObjectText = NULL;
            if (SUCCEEDED(pErrorObject->GetObjectText(0, &bstrObjectText)))
            {
                fprintf(stdout, "%wS", bstrObjectText);
                SysFreeString(bstrObjectText);
            }
        }

        RELEASE(pErrorObject);
    }
}

//***************************************************************************
// Function:  PrintErrorAndExit
// Purpose:   Formats an error message & exits program
//***************************************************************************
void PrintErrorAndExit(char *pszFailureReason, SCODE sc, DWORD dwMode)
{
    PrintError(pszFailureReason, sc, dwMode);

    // Clean up and exit
    OleUninitialize();
    printf("Abnormal Termination\n");
    exit(1);
};

//***************************************************************************
// Function:  PrintErrorAndAsk
// Purpose:   Prints the error message and prompts to continue
//***************************************************************************
void PrintErrorAndAsk(char *pszFailureReason, SCODE sc, DWORD dwMode)
{
    int c;

    PrintError(pszFailureReason, sc, dwMode);
    printf("Continue (Y/N)? ");

    c = getchar();
    while (getchar() != '\n')
    {
    }

    if ((c != 'Y') && (c != 'y'))
    {
        // Clean up and exit
        OleUninitialize();
        exit(1);
    }
};

//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a variant, returns a pointer to a string that is the variant type
//*****************************************************************************
const WCHAR *TypeToString(VARIANT *p)
{
    return TypeToString(p->vt);
}

//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a VARTYPE, returns a pointer to a string that is the variant type
//*****************************************************************************
const WCHAR *TypeToString(VARTYPE v)
{
    const static WCHAR *pVT_NULL  = L"VT_NULL";
    const static WCHAR *pVT_EMTPY = L"VT_EMPTY";
    const static WCHAR *pVT_I1    = L"VT_I1";
    const static WCHAR *pVT_UI1   = L"VT_UI1";
    const static WCHAR *pVT_I2    = L"VT_I2";
    const static WCHAR *pVT_UI2   = L"VT_UI2";
    const static WCHAR *pVT_I4    = L"VT_I4";
    const static WCHAR *pVT_UI4   = L"VT_UI4";
    const static WCHAR *pVT_I8    = L"VT_I8";
    const static WCHAR *pVT_UI8   = L"VT_UI8";
    const static WCHAR *pVT_R4    = L"VT_R4";
    const static WCHAR *pVT_R8    = L"VT_R8";
    const static WCHAR *pVT_BOOL  = L"VT_BOOL";
    const static WCHAR *pVT_BSTR  = L"VT_BSTR";
    const static WCHAR *pVT_DISPATCH = L"VT_DISPATCH";
    const static WCHAR *pVT_UNKNOWN = L"VT_UNKNOWN";
    const static WCHAR *pVT_I1_ARRAY = L"VT_I1 | VT_ARRAY";
    const static WCHAR *pVT_UI1_ARRAY  = L"VT_UI1 | VT_ARRAY";
    const static WCHAR *pVT_I2_ARRAY   = L"VT_I2 | VT_ARRAY";
    const static WCHAR *pVT_UI2_ARRAY  = L"VT_UI2 | VT_ARRAY";
    const static WCHAR *pVT_I4_ARRAY   = L"VT_I4 | VT_ARRAY";
    const static WCHAR *pVT_UI4_ARRAY  = L"VT_UI4 | VT_ARRAY";
    const static WCHAR *pVT_I8_ARRAY   = L"VT_I8 | VT_ARRAY";
    const static WCHAR *pVT_UI8_ARRAY  = L"VT_UI8 | VT_ARRAY";
    const static WCHAR *pVT_R4_ARRAY   = L"VT_R4 | VT_ARRAY";
    const static WCHAR *pVT_R8_ARRAY   = L"VT_R8 | VT_ARRAY";
    const static WCHAR *pVT_BOOL_ARRAY = L"VT_BOOL | VT_ARRAY";
    const static WCHAR *pVT_BSTR_ARRAY = L"VT_BSTR | VT_ARRAY";
    const static WCHAR *pVT_DISPATCH_ARRAY = L"VT_DISPATCH | VT_ARRAY";
    const static WCHAR *pVT_UNKNOWN_ARRAY = L"VT_UNKNOWN | VT_ARRAY";

    const WCHAR *pRetVal;

    switch (v)
    {
    case VT_NULL: pRetVal = pVT_NULL; break;

    case VT_I1: pRetVal = pVT_I1; break;
    case VT_UI1: pRetVal = pVT_UI1; break;
    case VT_I2: pRetVal = pVT_I2; break;
    case VT_UI2: pRetVal = pVT_UI2; break;
    case VT_I4: pRetVal = pVT_I4; break;
    case VT_UI4: pRetVal = pVT_UI4; break;
    case VT_I8: pRetVal = pVT_I8; break;
    case VT_UI8: pRetVal = pVT_UI8; break;
    case VT_R4: pRetVal = pVT_R4; break;
    case VT_R8: pRetVal = pVT_R8; break;
    case VT_BOOL: pRetVal = pVT_BOOL; break;
    case VT_BSTR: pRetVal = pVT_BSTR; break;
    case VT_DISPATCH: pRetVal = pVT_DISPATCH; break;
    case VT_UNKNOWN: pRetVal = pVT_UNKNOWN; break;

    case VT_I1|VT_ARRAY: pRetVal = pVT_I1_ARRAY; break;
    case VT_UI1|VT_ARRAY: pRetVal = pVT_UI1_ARRAY; break;
    case VT_I2|VT_ARRAY: pRetVal = pVT_I2_ARRAY; break;
    case VT_UI2|VT_ARRAY: pRetVal = pVT_UI2_ARRAY; break;
    case VT_I4|VT_ARRAY: pRetVal = pVT_I4_ARRAY; break;
    case VT_UI4|VT_ARRAY: pRetVal = pVT_UI4_ARRAY; break;
    case VT_I8|VT_ARRAY: pRetVal = pVT_I8_ARRAY; break;
    case VT_UI8|VT_ARRAY: pRetVal = pVT_UI8_ARRAY; break;
    case VT_R4|VT_ARRAY: pRetVal = pVT_R4_ARRAY; break;
    case VT_R8|VT_ARRAY: pRetVal = pVT_R8_ARRAY; break;
    case VT_BOOL|VT_ARRAY: pRetVal = pVT_BOOL_ARRAY; break;
    case VT_BSTR|VT_ARRAY: pRetVal = pVT_BSTR_ARRAY; break;
    case VT_DISPATCH|VT_ARRAY: pRetVal = pVT_DISPATCH_ARRAY; break;
    case VT_UNKNOWN|VT_ARRAY: pRetVal = pVT_UNKNOWN_ARRAY; break;

    default: pRetVal = L"<unknown>";
    }

    return pRetVal;
}

//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a CIMTYPE, returns a pointer to a string that is the variant type
//*****************************************************************************
const WCHAR *TypeToString(CIMTYPE v)
{
    const static WCHAR *pCIM_UNKNOWN = L"CIM_UNKNOWN";

    const static WCHAR *pCIM_ILLEGAL = L"CIM_ILLEGAL";
    const static WCHAR *pCIM_EMPTY = L"CIM_EMPTY";
    const static WCHAR *pCIM_SINT8 = L"CIM_SINT8";
    const static WCHAR *pCIM_UINT8 = L"CIM_UINT8";
    const static WCHAR *pCIM_SINT16 = L"CIM_SINT16";
    const static WCHAR *pCIM_UINT16 = L"CIM_UINT16";
    const static WCHAR *pCIM_SINT32 = L"CIM_SINT32";
    const static WCHAR *pCIM_UINT32 = L"CIM_UINT32";
    const static WCHAR *pCIM_SINT64 = L"CIM_SINT64";
    const static WCHAR *pCIM_UINT64 = L"CIM_UINT64";
    const static WCHAR *pCIM_REAL32 = L"CIM_REAL32";
    const static WCHAR *pCIM_REAL64 = L"CIM_REAL64";
    const static WCHAR *pCIM_BOOLEAN = L"CIM_BOOLEAN";
    const static WCHAR *pCIM_STRING = L"CIM_STRING";
    const static WCHAR *pCIM_DATETIME = L"CIM_DATETIME";
    const static WCHAR *pCIM_REFERENCE = L"CIM_REFERENCE";
    const static WCHAR *pCIM_OBJECT = L"CIM_OBJECT";

    const static WCHAR *pCIM_ILLEGAL_ARRAY = L"CIM_ILLEGAL | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_EMPTY_ARRAY = L"CIM_EMPTY | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT8_ARRAY = L"CIM_SINT8 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT8_ARRAY = L"CIM_UINT8 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT16_ARRAY = L"CIM_SINT16 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT16_ARRAY = L"CIM_UINT16 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT32_ARRAY = L"CIM_SINT32 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT32_ARRAY = L"CIM_UINT32 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT64_ARRAY = L"CIM_SINT64 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT64_ARRAY = L"CIM_UINT64 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_REAL32_ARRAY = L"CIM_REAL32 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_REAL64_ARRAY = L"CIM_REAL64 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_BOOLEAN_ARRAY = L"CIM_BOOLEAN | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_STRING_ARRAY = L"CIM_STRING | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_DATETIME_ARRAY = L"CIM_DATETIME | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_REFERENCE_ARRAY = L"CIM_REFERENCE | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_OBJECT_ARRAY = L"CIM_OBJECT | CIM_FLAG_ARRAY";

    const WCHAR *pRetVal;

    switch (v)
    {
        case CIM_ILLEGAL: pRetVal = pCIM_ILLEGAL; break;
        case CIM_EMPTY: pRetVal = pCIM_EMPTY; break;
        case CIM_SINT8: pRetVal = pCIM_SINT8; break;
        case CIM_UINT8: pRetVal = pCIM_UINT8; break;
        case CIM_SINT16: pRetVal = pCIM_SINT16; break;
        case CIM_UINT16: pRetVal = pCIM_UINT16; break;
        case CIM_SINT32: pRetVal = pCIM_SINT32; break;
        case CIM_UINT32: pRetVal = pCIM_UINT32; break;
        case CIM_SINT64: pRetVal = pCIM_SINT64; break;
        case CIM_UINT64: pRetVal = pCIM_UINT64; break;
        case CIM_REAL32: pRetVal = pCIM_REAL32; break;
        case CIM_REAL64: pRetVal = pCIM_REAL64; break;
        case CIM_BOOLEAN: pRetVal = pCIM_BOOLEAN; break;
        case CIM_STRING: pRetVal = pCIM_STRING; break;
        case CIM_DATETIME: pRetVal = pCIM_DATETIME; break;
        case CIM_REFERENCE: pRetVal = pCIM_REFERENCE; break;
        case CIM_OBJECT: pRetVal = pCIM_OBJECT; break;

        case CIM_SINT8 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT8_ARRAY; break;
        case CIM_UINT8 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT8_ARRAY; break;
        case CIM_SINT16 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT16_ARRAY; break;
        case CIM_UINT16 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT16_ARRAY; break;
        case CIM_SINT32 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT32_ARRAY; break;
        case CIM_UINT32 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT32_ARRAY; break;
        case CIM_SINT64 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT64_ARRAY; break;
        case CIM_UINT64 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT64_ARRAY; break;
        case CIM_REAL32 | CIM_FLAG_ARRAY: pRetVal = pCIM_REAL32_ARRAY; break;
        case CIM_REAL64 | CIM_FLAG_ARRAY: pRetVal = pCIM_REAL64_ARRAY; break;
        case CIM_BOOLEAN | CIM_FLAG_ARRAY: pRetVal = pCIM_BOOLEAN_ARRAY; break;
        case CIM_STRING | CIM_FLAG_ARRAY: pRetVal = pCIM_STRING_ARRAY; break;
        case CIM_DATETIME | CIM_FLAG_ARRAY: pRetVal = pCIM_DATETIME_ARRAY; break;
        case CIM_REFERENCE | CIM_FLAG_ARRAY: pRetVal = pCIM_REFERENCE_ARRAY; break;
        case CIM_OBJECT | CIM_FLAG_ARRAY: pRetVal = pCIM_OBJECT_ARRAY; break;

        default: pRetVal = pCIM_UNKNOWN; break;
    }

    return pRetVal;
}

//*****************************************************************************
// Function:   ValueToString
// Purpose:    Takes a variant, returns a string representation of that variant
//*****************************************************************************
WCHAR *ValueToString(CIMTYPE dwType, VARIANT *pValue, WCHAR **pbuf, WCHAR *fnHandler(VARIANT *pv))
{
    DWORD iTotBufSize;

    WCHAR *vbuf = NULL;
    WCHAR *buf = NULL;

    WCHAR lbuf[BLOCKSIZE];

    switch (pValue->vt)
    {
        case VT_EMPTY:
        {
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"<empty>");
            }
            break;
        }

        case VT_NULL:
        {
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"<null>");
            }
            break;
        }

        case VT_BOOL:
        {
            VARIANT_BOOL b = pValue->boolVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                if (!b)
                {
                    wcscpy(buf, L"FALSE");
                }
                else
                {
                    wcscpy(buf, L"TRUE");
                }
            }
            break;
        }

        case VT_I1:
        {
            char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                if (b >= 32)
                {
                    swprintf(buf, L"'%c' (%hd, 0x%hX)", b, (signed char)b, b);
                }
                else
                {
                    swprintf(buf, L"%hd (0x%hX)", (signed char)b, b);
                }
            }
            break;
        }

        case VT_UI1:
        {
            unsigned char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                if (b >= 32)
                {
                    swprintf(buf, L"'%c' (%hu, 0x%hX)", b, (unsigned char)b, b);
                }
                else
                {
                    swprintf(buf, L"%hu (0x%hX)", (unsigned char)b, b);
                }
            }
            break;
        }

        case VT_I2:
        {
            SHORT i = pValue->iVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%hd (0x%hX)", i, i);
            }
            break;
        }

        case VT_UI2:
        {
            USHORT i = pValue->uiVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%hu (0x%hX)", i, i);
            }
            break;
        }

        case VT_I4:
        {
            LONG l = pValue->lVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%d (0x%X)", l, l);
            }
            break;
        }

        case VT_UI4:
        {
            ULONG l = pValue->ulVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%u (0x%X)", l, l);
            }
            break;
        }

        case VT_R4:
        {
            float f = pValue->fltVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if (buf)
            {
                swprintf(buf, L"%10.4f", f);
            }
            break;
        }

        case VT_R8:
        {
            double d = pValue->dblVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if (buf)
            {
                swprintf(buf, L"%10.4f", d);
            }
            break;
        }

        case VT_BSTR:
        {
            if (dwType == CIM_SINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);

                buf = (WCHAR *)malloc(BLOCKSIZE);
                if (buf)
                {
                    swprintf(buf, L"%I64d", l, l);
                    }
            }
            else if (dwType == CIM_UINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);

                buf = (WCHAR *)malloc(BLOCKSIZE);
                if (buf)
                {
                    swprintf(buf, L"%I64u", l, l);
                }
            }
            else // string, datetime, reference
            {
                LPWSTR pWStr = pValue->bstrVal;
                buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
                if (buf)
                {
                    swprintf(buf, L"\"%wS\"", pWStr);
                }
            }
            break;
        }

        case VT_BOOL|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    VARIANT_BOOL v;
                    SafeArrayGetElement(pVec, &i, &v);
                    if (v)
                    {
                        wcscat(buf, L"TRUE");
                    }
                    else
                    {
                        wcscat(buf, L"FALSE");
                    }
                }
            }

            break;
        }

        case VT_I1|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");
                WCHAR *pos = buf;
                DWORD len;

                BYTE *pbstr;
                SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscpy(pos, L",");
                        pos += 1;
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    char v;
                    //            SafeArrayGetElement(pVec, &i, &v);
                    v = pbstr[i];

                    if (v < 32)
                    {
                        len = swprintf(lbuf, L"%hd (0x%X)", v, v);
                    }
                    else
                    {
                        len = swprintf(lbuf, L"'%c' %hd (0x%X)", v, v, v);
                    }

                    wcscpy(pos, lbuf);
                    pos += len;
                }
            }

            SafeArrayUnaccessData(pVec);

            break;
        }

        case VT_UI1|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");
                WCHAR *pos = buf;
                DWORD len;

                BYTE *pbstr;
                SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscpy(pos, L",");
                        pos += 1;
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    unsigned char v;
                    //            SafeArrayGetElement(pVec, &i, &v);
                    v = pbstr[i];

                    if (v < 32)
                    {
                        len = swprintf(lbuf, L"%hu (0x%X)", v, v);
                    }
                    else
                    {
                        len = swprintf(lbuf, L"'%c' %hu (0x%X)", v, v, v);
                    }

                    wcscpy(pos, lbuf);
                    pos += len;
                }
            }

            SafeArrayUnaccessData(pVec);

            break;
        }

        case VT_I2|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    SHORT v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%hd", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_UI2|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    USHORT v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%hu", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_I4|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    LONG v;
                    SafeArrayGetElement(pVec, &i, &v);
                    _ltow(v, lbuf, 10);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_UI4|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    ULONG v;
                    SafeArrayGetElement(pVec, &i, &v);
                    _ultow(v, lbuf, 10);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case CIM_REAL32|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    FLOAT v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%10.4f", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case CIM_REAL64|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    double v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%10.4f", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_BSTR|VT_ARRAY:
        {
            if (dwType == (CIM_UINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;

                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0)
                {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
					if (buf)
					{
	                    wcscpy(buf, L"<empty array>");
					}
                    break;
                }

                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if (buf)
                {
                    wcscpy(buf, L"");

                    for (long i = iLBound; i <= iUBound; i++)
                    {
                        if (!bFirst)
                        {
                            wcscat(buf, L",");
                        }
                        else
                        {
                            bFirst = FALSE;
                        }

                        BSTR v = NULL;

                        SafeArrayGetElement(pVec, &i, &v);

                        swprintf(lbuf, L"%I64u", _wtoi64(v));
                        wcscat(buf, lbuf);
                    }
                }
            }
            else if (dwType == (CIM_SINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;

                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0)
                {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
					if (buf)
					{
	                    wcscpy(buf, L"<empty array>");
					}
                    break;
                }

                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if (buf)
                {
                    wcscpy(buf, L"");

                    for (long i = iLBound; i <= iUBound; i++)
                    {
                        if (!bFirst)
                        {
                            wcscat(buf, L",");
                        }
                        else
                        {
                            bFirst = FALSE;
                        }

                        BSTR v = NULL;

                        SafeArrayGetElement(pVec, &i, &v);

                        swprintf(lbuf, L"%I64d", _wtoi64(v));
                        wcscat(buf, lbuf);
                    }
                }
            }
            else // string, datetime, reference
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                DWORD iNeed;
                size_t iVSize;
                DWORD iCurBufSize;

                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0)
                {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
					if (buf)
					{
	                    wcscpy(buf, L"<empty array>");
					}
                    break;
                }

                iTotBufSize = (iUBound - iLBound + 1) * BLOCKSIZE;
                buf = (WCHAR *)malloc(iTotBufSize);
                if (buf)
                {
                    buf[0] = L'\0';
                    iCurBufSize = 0;
                    iVSize = BLOCKSIZE;
                    vbuf = (WCHAR *)malloc(BLOCKSIZE);
                    if (vbuf)
                    {
                        size_t iLen;

                        for (long i = iLBound; i <= iUBound; i++)
                        {
                            BSTR v = NULL;
                            SafeArrayGetElement(pVec, &i, &v);
                            iLen = (wcslen(v) + 1) * sizeof(WCHAR);
                            if (iLen > iVSize)
                            {
                                vbuf = (WCHAR *)realloc(vbuf, iLen + sizeof(WCHAR));
                                iVSize = iLen;
                            }

                            // String size + (quotes + comma + null)
                            iNeed = (swprintf(vbuf, L"%wS", v) + 4) * sizeof(WCHAR);
                            if (iNeed + iCurBufSize > iTotBufSize)
                            {
                                iTotBufSize += (iNeed * 2);  // Room enough for 2 more entries
                                buf = (WCHAR *)realloc(buf, iTotBufSize);
                            }
                            wcscat(buf, L"\"");
                            wcscat(buf, vbuf);
                            if (i + 1 <= iUBound)
                            {
                                wcscat(buf, L"\",");
                            }
                            else
                            {
                                wcscat(buf, L"\"");
                            }
                            iCurBufSize += iNeed;
                            SysFreeString(v);
                        }
                        free(vbuf);
                    }
                }
            }

            break;
        }

        default:
        {
            if (fnHandler != NULL)
            {
                buf = fnHandler(pValue);
            }
            else
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if (buf)
                {
                    wcscpy(buf, L"<conversion error>");
                }
            }
            break;
        }
   }

   if (!buf)
   {
       PrintErrorAndExit("ValueToString() out of memory", S_OK, 0);
   }

   *pbuf = buf;
   return buf;
}

//*****************************************************************************
// Function:   cvt
// Purpose:    Converts unicode to oem for console output
// Note:       y must be freed by caller
//*****************************************************************************
char *cvt(WCHAR *x, char **y)
{
    int dwRet, i;
    i = WideCharToMultiByte( CP_OEMCP,
        0,
        x,
        -1,
        NULL,
        0,
        NULL,
        NULL);

    *y = (char *)calloc(i, 1);

    if (*y)
    {
        dwRet = WideCharToMultiByte( CP_OEMCP,
            0,
            x,
            -1,
            *y,
            i,
            NULL,
            NULL);

        if (dwRet == 0)
        {
            free(*y);
            *y = (char *)malloc(sizeof(CVTFAILED));
            if (*y)
            {
                memcpy(*y, CVTFAILED, sizeof(CVTFAILED));
            }
        }
    }
    else
    {
        PrintErrorAndExit("cvt() out of memory", S_OK, 0);
    }

    return *y;
}

//*****************************************************************************
// Function:   myWFPrintf
// Purpose:    Checks to see if outputing to console and converts strings
//             to oem if necessary.
// Note:       Returns number of characters written (ie if we write 3 oem
//             chars, it returns 3.  If it writes 4 wchars, it returns 4).
//*****************************************************************************
int myFWPrintf(FILE *f, WCHAR *fmt, ...)

{
    va_list    argptr;
    size_t i;

    int iSize = PAGESIZE;
    WCHAR *wszBuff = (WCHAR *)malloc(iSize);

    if (wszBuff)
    {
        wszBuff[(iSize/2)-2] = 0xffff;

        va_start(argptr, fmt);  // Init variable arguments

        // Format the string into a buffer.  Make sure the buffer is big enough
        while (_vsnwprintf(wszBuff, (iSize-1)/sizeof(WCHAR), fmt, argptr) == -1)
        {
            if (wszBuff[(iSize/2)-2] != 0xffff)
            {
                iSize += PAGESIZE;
                wszBuff = (WCHAR *)realloc(wszBuff, iSize);
                wszBuff[(iSize/2)-2] = 0xffff;
            }
            else
            {
                // unfortunately, _vsnwprintf won't handle the unicode character
                // 0xffff.  Since this isn't actually a valid unicode character,
                // we'll just ignore it.
                wcscpy(wszBuff, L"String contains 0xffff\n");
                break;
            }
        }

        if (f == stdout)
        {
            char *z = NULL;

            fputs(cvt(wszBuff,&z), f);
            i = strlen(z);
            free(z);
        }
        else
        {
            i = wcslen(wszBuff);
            fwrite(wszBuff, i * sizeof(WCHAR), 1, f);
        }

        free(wszBuff);
    }
    else
    {
        if (f == stdout)
        {
            char *szBuff = "myFWPrintf() out of memory";

            i = strlen(szBuff);
            fputs(szBuff, f);
        }
        else
        {
            wszBuff = L"myFWPrintf() out of memory";
            i = wcslen(wszBuff);
            fwrite(wszBuff, i * sizeof(WCHAR), 1, f);
        }
    }

    va_end(argptr);

    return (int)i;
}

//*****************************************************************************
// Function:   difftime
// Purpose:    Returns the elapsed time between two _timeb structures
// Note:       This is different from the crt routine which works on time_t
//             structures.
//*****************************************************************************
double difftime(struct _timeb finish, struct _timeb start)
{
    double dRet;

    if (start.millitm > finish.millitm)
    {
        dRet = ((finish.time - start.time) - 1) + (double)(((1000 + finish.millitm) - start.millitm) / 1000.0);
    }
    else
    {
        dRet = (finish.time - start.time) + (double)((finish.millitm - start.millitm) / 1000.0);
    }

    return dRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\wbemsec.h ===
//***************************************************************************

//

//  WBEMSEC.H

//

//  Purpose: Provides prototypes for some security helper functions.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _WBEMSEC_H_
#define _WBEMSEC_H_

HRESULT InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel);
SCODE GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel);
HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel);

#endif // _WBEMSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\wbemsec.cpp ===
//***************************************************************************

//

//  WBEMSEC.CPP

//

//  Purpose: Provides some security helper functions.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//#undef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
#include "precomp.h"
#include <wbemidl.h>
#include "wbemsec.h"

//***************************************************************************
//
//  InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel)
//
//  DESCRIPTION:
//
//  Initialize DCOM security.  The authentication level is typically
//  RPC_C_AUTHN_LEVEL_CONNECT,  and the impersonation level is typically
// RPC_C_IMP_LEVEL_IMPERSONATE.  When using asynchronous call backs, an
// authentication level of RPC_C_AUTHN_LEVEL_NONE is useful
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

HRESULT InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel)
{
    // Initialize security
    // ===================

    return CoInitializeSecurity(NULL, -1, NULL, NULL,
        dwAuthLevel, dwImpLevel,
        NULL, EOAC_NONE, 0);
}

//***************************************************************************
//
//  bool bIsNT
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

bool bIsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}


//***************************************************************************
//
//  SCODE ParseAuthorityUserArgs
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  ConnType            Returned with the connection type, ie wbem, ntlm
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE ParseAuthorityUserArgs(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User)
{

    // Determine the connection type by examining the Authority string

    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return E_INVALIDARG;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(Authority && wcslen(Authority) > 11)
    {
        if(pSlashInUser)
            return E_INVALIDARG;

        AuthArg = SysAllocString(Authority + 11);
        if(User) UserArg = SysAllocString(User);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        INT_PTR iDomLen = min(MAX_PATH-1, pSlashInUser-User);
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);

    return S_OK;
}


//***************************************************************************
//
//  SCODE GetAuthImp
//
//  DESCRIPTION:
//
//  Gets the authentication and impersonation levels for a current interface.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//  pdwAuthLevel    Set to the authentication level
//  pdwImpLevel    Set to the impersonation level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel)
{

    if(pFrom == NULL || pdwAuthLevel == NULL || pdwImpLevel == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc,
                                            NULL,
                                            pdwAuthLevel, pdwImpLevel,
                                            NULL, &dwCapabilities);

        // Special case of going to a win9x share level box

        if (sc == 0x800706d2)
        {
            *pdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
            *pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            sc = S_OK;
        }
        pFromSec->Release();
    }
    return sc;
}
//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  NOTE that setting the security blanket on the interface is not recommended.
//  The clients should typically just call CoInitializeSecurity( NULL, -1, NULL, NULL, 
//											RPC_C_AUTHN_LEVEL_DEFAULT, 
//											RPC_C_IMP_LEVEL_IMPERSONATE, 
//											NULL, 
//											EOAC_NONE, 
//											NULL );
//  before calling out to WMI.
//
//
//  PARAMETERS:
//
//  pInterface         Interface to be set
//  pDomain           Input, domain
//  pUser                Input, user name
//  pPassword        Input, password.
//  pFrom               Input, if not NULL, then the authentication level of this interface
//                           is used
//  bAuthArg          If pFrom is NULL, then this is the authentication level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser,
                             LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel)
{

    SCODE sc;
    if(pInterface == NULL)
        return E_INVALIDARG;

    // If we are lowering the security, no need to deal with the identification info

    if(dwAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
        return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);

    // If we are doing trivial case, just pass in a null authentication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) &&
        (pUser == NULL || wcslen(pUser) < 1) &&
        (pPassword == NULL || wcslen(pPassword) < 1))
            return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, NULL, EOAC_NONE);

    // If user, or Authority was passed in, the we need to create an authority argument for the login

    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL;
    sc = ParseAuthorityUserArgs(AuthArg, UserArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
    if(bIsNT())
    {
        if(UserArg)
        {
            authident.UserLength = (ULONG)wcslen(UserArg);
            authident.User = (LPWSTR)UserArg;
        }
        if(AuthArg)
        {
            authident.DomainLength = (ULONG)wcslen(AuthArg);
            authident.Domain = (LPWSTR)AuthArg;
        }
        if(pPassword)
        {
            authident.PasswordLength = (ULONG)wcslen(pPassword);
            authident.Password = (LPWSTR)pPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {
        char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

        // Fill in the indentity structure

        if(UserArg)
        {
            wcstombs(szUser, UserArg, MAX_PATH);
            authident.UserLength = (ULONG)strlen(szUser);
            authident.User = (LPWSTR)szUser;
        }
        if(AuthArg)
        {
            wcstombs(szAuthority, AuthArg, MAX_PATH);
            authident.DomainLength = (ULONG)strlen(szAuthority);
            authident.Domain = (LPWSTR)szAuthority;
        }
        if(pPassword)
        {
            wcstombs(szPassword, pPassword, MAX_PATH);
            authident.PasswordLength = (ULONG)strlen(szPassword);
            authident.Password = (LPWSTR)szPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    }
    sc = CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, &authident, EOAC_NONE);

    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdump\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdiag\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WBEMDiag.rc
//
#define IDS_STRING1                     1
#define IDS_NO_ADVICE                   1
#define IDS_TEST                        2
#define IDS_HELP                        2
#define ERR_80070005                    5
#define IDS_COMINIT                     10
#define IDS_WBEMINIT                    11
#define IDS_NSCONNECT                   12
#define IDS_PROVIDERLIST                13
#define IDS_COMPUTERLIST                14
#define IDS_COMPUTERDETAILS             15
#define IDS_CONNECTSUCCESS              16
#define IDS_PRESSENTER                  17
#define IDS_TRYHELP                     17
#define IDS_FINDINGLOCATOR              18
#define IDS_ERROR                       19
#define IDS_NSPROVIDERS                 20
#define IDS_NSCONNECTING                21
#define IDS_PROVIDERGET                 22
#define IDS_COMPUTERGET                 23
#define IDS_COMPUTERENUM                24
#define IDS_PROVIDERENUM                25
#define ERR_80040154_A                  50
#define ERR_80040154_B                  51
#define ERR_80040154_C                  52
#define ERR_80080005                    53
#define ERR_80040154                    340
#define ERR_800706BA                    1722
#define ERR_80041003                    4099
#define ERR_80041008                    4104
#define ERR_8004100E                    4110
#define ERR_80041013                    4115
#define ERR_80041014                    4116
#define ERR_80041024                    4132

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdiag\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BB5A039E_D487_11D1_9FF9_00C04F96F97D__INCLUDED_)
#define AFX_STDAFX_H__BB5A039E_D487_11D1_9FF9_00C04F96F97D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BB5A039E_D487_11D1_9FF9_00C04F96F97D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\utillib.h ===
// **************************************************************************

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// File:  utillib.h
//
// Description:
//    Set of sample routines
//
// History:
//
// **************************************************************************

#define MAXITOA  19
#define FWPRINTF myFWPrintf
#define CLASSPROP L"__CLASS"
#define SERVERPROP L"__SERVER"
#define PATHPROP L"__PATH"
#define NAMESPACEPROP L"__NAMESPACE"
#define SYSTEMCLASS L"__SystemClass"
#define RELPATHPROP L"__RELPATH"
#define NAMEPROP L"Name"
#define CIMTYPEQUAL L"CIMTYPE"
#define KEYQUAL L"key"
#define SYSTEMPREFIX L"__"
#define CVTFAILED L"WideCharToMultiByte failed\n"
#define RELEASE(a) if (a) { (a)->Release(); (a)=NULL;}
#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop  (this size stolen from cvt.h in c runtime library) */
#define PAGESIZE 4096
#define ERROR_MODE_PRINTFIELDS 0
#define ERROR_MODE_PRINTMOF 1
#define UNREFERENCED(x)

#include <comdef.h>

_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));

char *cvt(WCHAR *x, char **y);
double difftime(struct _timeb finish, struct _timeb start);
int myFWPrintf(FILE *f, WCHAR *fmt, ...);
const WCHAR *TypeToString(VARIANT *p);
const WCHAR *TypeToString(VARTYPE v);
const WCHAR *TypeToString(CIMTYPE v);
WCHAR *ValueToString(CIMTYPE dwType, VARIANT *pValue, WCHAR **pbuf, WCHAR *fnHandler(VARIANT *pv) = NULL);
BSTR WbemErrorString(SCODE sc);
void PrintErrorAndExit(char *pszFailureReason, SCODE sc, DWORD dwMode);
void PrintErrorAndAsk(char *pszFailureReason, SCODE sc, DWORD dwMode);
void PrintError(char *pszFailureReason, SCODE sc, DWORD dwMode);

class MyString {
private:
   WCHAR *pwszString;

public:
   MyString::MyString() {pwszString = (WCHAR *)calloc(1, sizeof(WCHAR));}
   MyString::~MyString() {free(pwszString);}
   WCHAR *GetString() {return pwszString;}
   void Empty() {free(pwszString);pwszString = (WCHAR *)calloc(1, sizeof(WCHAR));}
   WCHAR *GetCloneString()
   {
      WCHAR *buf = NULL;
	  if (pwszString)
	  {
		  buf = (WCHAR *)malloc((wcslen(pwszString) + 1) * sizeof(WCHAR));
		  if (buf)
			wcscpy(buf, pwszString);
	  }
      return buf;
   }
   const MyString& operator+=(const WCHAR *arg1) 
      {
         size_t iHave;
         size_t iNeed;
         if (arg1)
         {
             iHave = wcslen(pwszString);
             iNeed = wcslen(arg1);
             pwszString = (WCHAR *)realloc(pwszString, (iHave + iNeed + 1) * sizeof(WCHAR));
             wcscat(&pwszString[iHave], arg1);
         }
         return *this;
      }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdump\wbemdump.cpp ===
// **************************************************************************

//Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
// File:  wbemdump.cpp
//
// Description:
//    dumps the contents of the cimom repository
//    see wbemdump /? for command line switches
//
// History:
//
// **************************************************************************

#pragma warning(disable:4201)  // nonstandard extension nameless struct (used in windows.h)
#pragma warning(disable:4514)  // unreferenced inline function has been removed (used in windows.h)
#pragma warning(disable:4800)  // forcing value to bool 'true' or 'false' (performance warning)
#pragma warning(disable:4100)  // unreferenced formal parameter warning
#pragma warning(disable:4701)  // local variable may be used without having been initialized
#pragma warning(disable:4710)  // function not inlined

#define TIMEOUT 150
#define UNICODE_SIGNATURE "\xff\xfe"
#define _WIN32_DCOM
#define WIN32_LEAN_AND_MEAN 1
#define UNREFERENCED(x)

//#include <windows.h>  not needed since it is re-included in wbemidl.h
#include <wbemidl.h>     // wbem interface declarations
#include <stdio.h>      // fprintf
#include <locale.h>
#include <sys/timeb.h>
#include <wbemsec.h>
#include <utillib.h>
#include "wbemdump.h"

// Function declarations
void DoIndent();
BOOL CtrlHandler(DWORD fdwCtrlType);
HRESULT ShowInstancesSync(IWbemServices *pIWbemServices, IEnumWbemClassObject *IEnumWbemClassObject, DWORD &dwCount, LPCWSTR pwszClassName);
void EnumClasses(IWbemServices *pIWbemServices, LPCWSTR pwcsClass);
void EnumClassesSync(IWbemServices *pIWbemServices, LPCWSTR pwcsClass);
void EnumInstances(IWbemServices *pIWbemServices, LPCWSTR pwcsClassName );
void EnumNamespaces(IWbemServices *pIWbemServices, LPCWSTR pwcsClassName);
WCHAR *EnumProperties(IWbemClassObject *pIWbemClassObject);
void Init(IWbemServices **ppIWbemServices, LPCWSTR pNamespace);
IWbemClassObject *GetObj(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject);
DWORD ProcessCommandLine(int argc, wchar_t *argv[]);
void ExecuteQuery(IWbemServices *pIWbemServices, LPCWSTR pwcsQueryLanguage, LPCWSTR pwcsQuery);
void PrintMof(IWbemClassObject *pIWbemClassObject);
void ShowClass(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject);
BOOL CheckQualifiers(IWbemClassObject *pIWbemClassObject);
void ShowInstance(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject);
void CheckAssocEndPoints(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject);
int __cdecl BstrCmp(const void *arg1,const void *arg2);
WCHAR *EscapeChars(LPCWSTR szInBuf);
WCHAR *MyValueToString(VARIANT *pv);
void ShowInstanceHeader(LPCWSTR pwcsClassName);
void ResetGlobalFlags();
bool ParseCommandLine(int *numargs, wchar_t **p);
static void __cdecl wparse_cmdline (
                                    WCHAR *cmdstart,
                                    WCHAR **argv,
                                    WCHAR *args,
                                    int *numargs,
                                    int *numchars
                                    );

// Global flags
BOOL g_bShowSystem = FALSE;     // Show system objects
BOOL g_bShowSystem1 = FALSE;    // Show system objects except __SERVER or __PATH
BOOL g_bShowInstance = FALSE;   // Show instance from ObjectPath
BOOL g_bShowProperties = TRUE;  // Show properties
BOOL g_bRecurseClass = FALSE;   // Recurse down class tree
BOOL g_bRecurseNS = FALSE;      // Recurse down ns's
BOOL g_bCheckGet = FALSE;       // Check the GetObject function
BOOL g_bCheckAssoc = FALSE;     // Check Association endpoints
BOOL g_bDoQuery = FALSE;        // Run a query instead of doing an enum
BOOL g_bClassMofs = FALSE;      // Show mofs for classes
BOOL g_bInstanceMofs = FALSE;   // Show mofs for instances
BOOL g_bMofTemplate = FALSE;    // Show instance mof templates
BOOL g_bUnicodeCmdFile = FALSE; // Whether the cmd file is unicode
BOOL g_bTime1 = FALSE;          // Show timings for /Q queries
BOOL g_bTime2 = FALSE;          // Alternate show timings for /Q queries
BOOL g_bWarningContinue = FALSE; // Show warning and continue
BOOL g_bWarning = FALSE;        // Show warning and ask
BOOL g_bASync = FALSE;          // Use Async functions for instances

volatile bool g_bExit = false;           // Control C handling
long g_lSFlags = 0;              // Security flags for ConnectServer
long g_lImpFlag = RPC_C_IMP_LEVEL_IMPERSONATE;            // Impersonation level (-1 means use default)
long g_lAuthFlag = -1;           // Impersonation level (-1 means use default)
long g_lEFlags = 0;              // Flags for CreateXxxEnum
long g_lGFlags = 0;              // Flags for GetObject
DWORD g_dwErrorFlags = 0;          // Flags for error printing

//
FILE *g_fOut = NULL;          // Handle for unicode file
FILE *g_fCmdFile = NULL;      // Handle for command file

LPCWSTR g_pwcsNewLine = L"\n";    // Used to delimit lines
LPCWSTR g_pwcsNamespace = NULL;   // NameSpace to start from
LPCWSTR g_pwcsObjectPath = NULL;  // ObjectPath to show
LPCWSTR g_pwcsQuery = NULL;        // Query (for /q commands)
LPWSTR g_pwcsUserID = NULL;      // Userid for ConnectServer
LPWSTR g_pwcsPassword = NULL;    // PW for ConnectServer
LPWSTR g_pwcsAuthority = NULL;   // Authority for ConnectServer
LPCWSTR g_pwcsLocale = NULL;      // Locale for ConnectServer
BSTR g_bstrQualifierName = NULL; // Class Qualifier to filter on
BSTR g_bstrQualifierValue = NULL; // Class Qualifier value to filter on
DWORD g_dwLoopCnt = 1;           // Loop count
DWORD g_dwIndent = 0;              // Current indention level

IWbemContext *g_pContext;      // Pointer to ClassContext object

//***************************************************************************
//
// wmain - used wmain since the command line parameters come in as wchar_t
//
//***************************************************************************
extern "C" int __cdecl wmain(int argc, wchar_t *argv[])
{
    setlocale(LC_ALL, "");

    // Init Com
    int iRet = 0;

    SCODE sc = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (sc != S_OK)
    {
        PrintErrorAndExit("OleInitialize Failed", sc, g_dwErrorFlags);  //exits program
    }

    sc = CoInitializeSecurity(NULL, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_DEFAULT,
        RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0);

    if (ProcessCommandLine(argc, argv) == S_OK)
    {
        // Catch control-c
        SetConsoleCtrlHandler(
                (PHANDLER_ROUTINE) CtrlHandler,  // handler function
                TRUE);

        IWbemServicesPtr pIWbemServices;
        Init(&pIWbemServices, g_pwcsNamespace);        // Connect to wbem

        try
        {
            if (g_fCmdFile)
            {
                wchar_t *largv;
                int largc;

                while (!feof(g_fCmdFile))
                {
                    ResetGlobalFlags();

                    if (ParseCommandLine(&largc, &largv))
                    {
                        ProcessCommandLine(largc, (wchar_t **)largv);
                        if (g_bDoQuery)
                        {
                            ExecuteQuery(pIWbemServices, g_pwcsObjectPath, g_pwcsQuery);
                        }
                        else
                        {
                            EnumNamespaces(pIWbemServices, g_pwcsObjectPath);   // Enumerate Namespaces
                        }
                    }
                }
            }
            else
            {
                if (g_bDoQuery)
                {
                    ExecuteQuery(pIWbemServices, g_pwcsObjectPath, g_pwcsQuery);
                }
                else
                {
                    EnumNamespaces(pIWbemServices, g_pwcsObjectPath);   // Enumerate Namespaces
                }
            }
        }
        catch ( ... )
        {
            iRet = 1;
        }
    }
    else
    {
        iRet = 1;
    }

    // Wrapup and exit
    if (g_fOut)
    {
        fclose(g_fOut);
    }

    if (g_fCmdFile)
    {
        fclose(g_fCmdFile);
    }

    if (g_bstrQualifierName != NULL)
    {
        SysFreeString(g_bstrQualifierName);
    }

    if (g_bstrQualifierValue != NULL)
    {
        SysFreeString(g_bstrQualifierValue);
    }

    if (g_pContext != NULL)
    {
        g_pContext->Release();
    }

    CoUninitialize();

    return iRet;
}

//***************************************************************************
// Function:   Init
//
// Purpose:   1 - Create an instance of the WbemLocator interface
//            2 - Use the pointer returned in step two to connect to
//                the server using the specified namespace.
//***************************************************************************
void Init(IWbemServices **ppIWbemServices, LPCWSTR pNamespace)
{
    SCODE sc;

    // Use the IWbemLocatorEx?  Or IWbemLocator?
    IWbemLocatorPtr pIWbemLocator;

    sc = CoCreateInstance(CLSID_WbemLocator,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IWbemLocator,
        (LPVOID *) &pIWbemLocator);

    if (sc != S_OK)
    {
        PrintErrorAndExit("Failed to create IWbemLocator object", sc, g_dwErrorFlags); // exits program
    }

    sc = pIWbemLocator->ConnectServer(

            bstr_t(pNamespace),  // Namespace
            bstr_t(g_pwcsUserID),          // Userid
            bstr_t(g_pwcsPassword),        // PW
            bstr_t(g_pwcsLocale),          // Locale
            g_lSFlags,                       // flags
            g_pwcsAuthority,                 // Authority
            g_pContext,                      // Context
            ppIWbemServices
        );

    if (sc != WBEM_NO_ERROR)
    {
        PrintErrorAndExit("Connect failed", sc, g_dwErrorFlags); //exits program
    }

    DWORD dwAuthLevel, dwImpLevel;
    sc = GetAuthImp(*ppIWbemServices, &dwAuthLevel, &dwImpLevel);
    if (sc != S_OK)
    {
        PrintErrorAndExit("GetAuthImp Failed on ConnectServer", sc, g_dwErrorFlags);
    }

    if (g_lImpFlag != -1)
    {
        dwImpLevel = g_lImpFlag;
    }

    if (g_lAuthFlag != -1)
    {
        dwAuthLevel = g_lAuthFlag;
    }

    sc = SetInterfaceSecurity(*ppIWbemServices, g_pwcsAuthority, g_pwcsUserID, g_pwcsPassword, dwAuthLevel, dwImpLevel);
    if (sc != S_OK)
    {
        PrintErrorAndExit("SetInterfaceSecurity Failed on ConnectServer", sc, g_dwErrorFlags);
    }
}

//***************************************************************************
// Function:   EnumClasses
//
// Purpose:   Using either the sync or async CreateClassEnum call, walk
//            the classes.
//***************************************************************************
void EnumClasses(IWbemServices *pIWbemServices, LPCWSTR pwcsClass)
{
    if (!g_bASync)
    {
        EnumClassesSync(pIWbemServices, pwcsClass);
    }
    else
    {
        ClassQuerySinkPtr pMySink(new ClassQuerySink(pIWbemServices), false);

        SCODE sc = pIWbemServices->CreateClassEnumAsync(

                bstr_t(pwcsClass),
                WBEM_FLAG_SHALLOW | g_lEFlags,
                g_pContext,
                pMySink
            );

        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Could not create Class enumerator", sc, g_dwErrorFlags);  //Exits program
        }

        do
        {
            sc = WaitForSingleObject(pMySink->GetEvent(), TIMEOUT);
            if (g_bExit)
            {
                sc = pIWbemServices->CancelAsyncCall(pMySink);
                throw 1;
            }
        } while (sc == WAIT_TIMEOUT);

        sc = pMySink->GetResult();
        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Could not enum instances", sc, g_dwErrorFlags);  //Exits program
        }
    }
}

//*****************************************************************************
// Function:   EnumClassesSync
// Purpose:    Used by the Sync version of walking classes
//*****************************************************************************
void EnumClassesSync(IWbemServices *pIWbemServices, LPCWSTR pwcsClass)
{
    IEnumWbemClassObjectPtr pIEnumWbemClassObject;

    // Create an enumeration of all subclasses of pwcsClass
    SCODE sc = pIWbemServices->CreateClassEnum(

            bstr_t(pwcsClass),
            WBEM_FLAG_SHALLOW | g_lEFlags,
            g_pContext,
            &pIEnumWbemClassObject
        );

    if (sc != WBEM_NO_ERROR)
    {
        PrintErrorAndExit("Could not create Class enumerator", sc, g_dwErrorFlags);  //Exits program
    }

    DWORD dwAuthLevel, dwImpLevel;
    sc = GetAuthImp(pIWbemServices, &dwAuthLevel, &dwImpLevel);
    if (sc != S_OK)
    {
        PrintErrorAndExit("GetAuthImp Failed on CreateClassEnum", sc, g_dwErrorFlags);
    }

    if (g_lImpFlag != -1)
    {
        dwImpLevel = g_lImpFlag;
    }

    if (g_lAuthFlag != -1)
    {
        dwAuthLevel = g_lAuthFlag;
    }

    sc = SetInterfaceSecurity(pIEnumWbemClassObject, g_pwcsAuthority, g_pwcsUserID, g_pwcsPassword, dwAuthLevel, dwImpLevel);
    if (sc != S_OK)
    {
        PrintErrorAndExit("SetInterfaceSecurity Failed on CreateClassEnum", sc, g_dwErrorFlags);
    }

    ULONG uReturned;
    IWbemClassObjectPtr pIWbemClassObject;

    do
    {
        do
        {
            sc = pIEnumWbemClassObject->Next(

                    TIMEOUT,
                    1,
                    &pIWbemClassObject,
                    &uReturned
                );

            if (g_bExit)
            {
                throw 1;
            }
        } while (sc == WBEM_S_TIMEDOUT);

        if (sc == S_OK)
        {
            ShowClass(pIWbemServices, pIWbemClassObject);
        }
    } while (sc == S_OK);

    // Make sure we ended on a positive note
    if (sc != S_FALSE)
    {
        PrintErrorAndExit("Could not get next class", sc, g_dwErrorFlags);  //Exits program
    }
}

//*****************************************************************************
// Function:   ShowClass
// Purpose:    Calls the appropriate functions to show the passed in class
// Note:       This routine calls EnumClasses, which leads to recursion
//*****************************************************************************
void ShowClass(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject)
{
    variant_t varString;

    // Get the __class property
    SCODE sc = pIWbemClassObject->Get(CLASSPROP, 0L, &varString, NULL, NULL);
    if (sc != WBEM_NO_ERROR)
    {
        PrintErrorAndExit("Could not get __Class property for class", sc, g_dwErrorFlags);  // Exits program
    }

    // we are showing system objs or this is not a system obj
    if ((g_bShowSystem) || (wcsncmp(V_BSTR(&varString), SYSTEMPREFIX, 2) != 0))
    {
        if (CheckQualifiers(pIWbemClassObject))
        {
            // Either show the class mof, or show the instances
            if (g_bClassMofs)
            {
                PrintMof(pIWbemClassObject);
                if (g_bInstanceMofs)
                {
                    EnumInstances(pIWbemServices, V_BSTR(&varString));
                }
            }
            else
            {
                EnumInstances(pIWbemServices, V_BSTR(&varString));
            }
        }
    }

    // If we are supposed to recurse
    if (g_bRecurseClass)
    {
        if ((!g_bMofTemplate) && (g_bstrQualifierName == NULL))
        {
            g_dwIndent++;  // Increase indention level
        }

        EnumClasses(pIWbemServices, V_BSTR(&varString));  // Enumerate all classes under this class
        if ((!g_bMofTemplate) && (g_bstrQualifierName == NULL))
        {
            g_dwIndent--;  // Decrease indention level
        }
    }
}

//*****************************************************************************
// Function:   EnumInstances
// Purpose:    Enumerates all instances of the class passed in pwcsClassName
//             and calls EnumProperties with each one.
// Note:       Shows instances in one of four ways.
//             1) Show the instance mof
//             2) Show the instance values
//             3) Show the wbemdump command line needed to dump this instance
//             4) Show a template instance mof
//*****************************************************************************
void EnumInstances(IWbemServices *pIWbemServices, LPCWSTR pwcsClassName)
{
    SCODE sc;

    if (g_bMofTemplate)
    {
        IWbemClassObjectPtr pIWbemClassObject;
        IWbemClassObjectPtr clObject;

        // For a template, all I need is a blank instance, so get the object...
        sc = pIWbemServices->GetObject(

                bstr_t(pwcsClassName),
                g_lGFlags,
                g_pContext,
                &pIWbemClassObject,
                NULL
            );

        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Failed to GetObject in EnumInstances", sc, g_dwErrorFlags);
        }

        // ... And spawn a blank one
        sc = pIWbemClassObject->SpawnInstance(0L, &clObject);

        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Failed to SpawnInstance in EnumInstances", sc, g_dwErrorFlags);
        }

        // Now, print the properties
        ShowInstance(pIWbemServices, clObject);

    }
    else
    {
        // Put this here so we can see what class we were
        // working on if we get stuck.
        ShowInstanceHeader(pwcsClassName);

        if (g_bShowProperties)
        {
            IEnumWbemClassObjectPtr IEnumWbemClassObject;
            InstanceQuerySinkPtr pMySink;

            struct _timeb start, finish;
            LARGE_INTEGER freq, start2;
            QueryPerformanceFrequency(&freq);
			

            for (DWORD dwLoop = 0; dwLoop < g_dwLoopCnt; dwLoop++)
            {
                if (g_bTime1)
                {
                    _ftime(&start);
                }
                else
                {
                    memset(&start, 0, sizeof(start));
                }

                if (!g_bTime2)
                {
                    start2.QuadPart = 0;
                }
                else
                {
                    QueryPerformanceCounter(&start2);
                }

                if (!g_bASync)
                {
                    // Create the enum
                    sc = pIWbemServices->CreateInstanceEnum(

                            bstr_t(pwcsClassName), // with this name
                            WBEM_FLAG_SHALLOW | g_lEFlags,
                            g_pContext,
                            &IEnumWbemClassObject    // using this enumerator
                        );
                }
                else
                {
                    pMySink.Attach(new InstanceQuerySink(pIWbemServices, pwcsClassName));
                    sc = pIWbemServices->CreateInstanceEnumAsync(

                            bstr_t(pwcsClassName), // with this name
                            WBEM_FLAG_SHALLOW | g_lEFlags,
                            g_pContext,
                            pMySink
                        );
                }

                // If we are doing timings
                if (g_bTime1)
                {
                    _ftime(&finish);
                    fprintf(stdout, "CreateInstanceEnum: %6.4f seconds.\n", difftime(finish, start));
                }
                if (g_bTime2)
                {
                    LARGE_INTEGER finish2;
                    QueryPerformanceCounter(&finish2);
                    fprintf(stdout, "CreateInstanceEnum: %I64d (%6.4f)\n", finish2.QuadPart - start2.QuadPart, (double)(finish2.QuadPart - start2.QuadPart)/freq.QuadPart);
                }

                if (sc == WBEM_NO_ERROR)
                {
                    // If we are doing timings
                    if (g_bTime1)
                    {
                        _ftime(&start);
                    }
                    else
                    {
                        memset(&start, 0, sizeof(start));
                    }

                    if (!g_bTime2)
                    {
                        start2.QuadPart = 0;
                    }
                    else
                    {
                        QueryPerformanceCounter(&start2);
                    }

                    DWORD dwCount = 0;

                    if (!g_bASync)
                    {
                        sc = ShowInstancesSync(pIWbemServices, IEnumWbemClassObject, dwCount, pwcsClassName);
                    }
                    else
                    {
                        do
                        {
                            sc = WaitForSingleObject(pMySink->GetEvent(), TIMEOUT);
                            if (g_bExit)
                            {
                                sc = pIWbemServices->CancelAsyncCall(pMySink);
                                throw 1;
                            }
                        } while (sc == WAIT_TIMEOUT);

                        dwCount = pMySink->GetCount();
                        sc = pMySink->GetResult();
                        if (sc == WBEM_S_NO_ERROR)
                        {
                            sc = S_FALSE;
                        }
                    }

                    // If we are doing timings
                    if (g_bTime1)
                    {
                        _ftime(&finish);
                        fprintf(stdout, "ShowInstances: %6.4f seconds, %d instances.\n", difftime(finish, start), dwCount);
                    }

                    if (g_bTime2)
                    {
                        LARGE_INTEGER finish2;
                        QueryPerformanceCounter(&finish2);
                        fprintf(stdout, "ShowInstances: %I64d (%6.4f), %d instances.\n", finish2.QuadPart - start2.QuadPart, (double)(finish2.QuadPart - start2.QuadPart)/freq.QuadPart, dwCount);
                    }

                    // Make sure we ended on a positive note
                    if (sc != S_FALSE)
                    {
                        PrintErrorAndExit("Could not get next instance", sc, g_dwErrorFlags);  //Exits program
                    }
                }
                else
                {
                    PrintErrorAndExit("Couldn't create instance enum", sc, g_dwErrorFlags);
                }
            }
        }
    }
}

//*****************************************************************************
// Function:   EnumProperties
// Purpose:    Shows all property names of specified class
//*****************************************************************************
WCHAR *EnumProperties(IWbemClassObject *pIWbemClassObject)
{
    SCODE  sc;
    SAFEARRAY *psaNames = NULL;
    long lLower, lUpper, lCount;
    IWbemQualifierSetPtr pQualSet;
    MyString clMyBuff;

    // Get the property names
    if (g_bShowSystem)
    {
        sc = pIWbemClassObject->GetNames(NULL, WBEM_FLAG_ALWAYS, NULL, &psaNames);
    }
    else
    {
        sc = pIWbemClassObject->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
    }

    if (sc != WBEM_NO_ERROR)
    {
        PrintErrorAndExit("Couldn't GetNames", sc, g_dwErrorFlags); // Exits program
    }

    // Get the upper and lower bounds of the Names array
    sc = SafeArrayGetLBound(psaNames, 1, &lLower);
    if (S_OK != sc)
    {
        PrintErrorAndExit("Couldn't get safe array lbound", sc, g_dwErrorFlags);  //Exits program
    }

    sc = SafeArrayGetUBound(psaNames, 1, &lUpper);
    if (S_OK != sc)
    {
        PrintErrorAndExit("Couldn't get safe array ubound", sc, g_dwErrorFlags);  //Exits program
    }

    // Sort the array
    qsort(psaNames->pvData, lUpper - lLower + 1, sizeof(BSTR), BstrCmp);

    // For an instance template, print the 'INSTANCE OF <CLASS>' header
    if (g_bMofTemplate)
    {
        variant_t varString;

        sc = pIWbemClassObject->Get(CLASSPROP, 0L, &varString, NULL, NULL);
        if (S_OK != sc)
        {
            PrintErrorAndExit("Couldn't get class property in enumproperties", sc, g_dwErrorFlags);  //Exits program
        }

        for (DWORD x=0; x < g_dwIndent; x++)
        {
            clMyBuff += L"\t";
        }

        clMyBuff += L"instance of ";
        clMyBuff += V_BSTR(&varString);
        clMyBuff += L" {";
        clMyBuff += g_pwcsNewLine;
        g_dwIndent++;
    }

    BSTR PropName = NULL;
    variant_t varString, varVal;
    CIMTYPE dwType;
    WCHAR *pBuf = NULL;
    bool bKey = false;
    BSTR bstrCimType = NULL;
    IWbemClassObjectPtr clObject1, clObject2;

    // For all properties...
    for (lCount = lLower; lCount <= lUpper; lCount++)
    {
        // get the property name for this element
        sc = SafeArrayGetElement(psaNames, &lCount, &PropName);
        if (S_OK != sc)
        {
            PrintErrorAndExit("Couldn't get safe array element", sc, g_dwErrorFlags);  //Exits program
        }

        // Only print the property if
        //   we are showing all properties except __SERVER and __PATH and this is not them
        if (!((g_bShowSystem1) && ((_wcsicmp(PropName, SERVERPROP) == 0) || _wcsicmp(PropName, PATHPROP) == 0)))
        {
            for (DWORD x=0; x < g_dwIndent; x++)
            {
                clMyBuff += L"\t";
            }

            clMyBuff += PropName;
            sc = pIWbemClassObject->Get(PropName, 0L, &varString, &dwType, NULL);  // Get the value for the property
            if (sc != WBEM_NO_ERROR)
            {
                PrintErrorAndExit("Couldn't get Property Value", sc, g_dwErrorFlags);  //Exits program
            }

            // Get pointer to property qualifiers
            sc = pIWbemClassObject->GetPropertyQualifierSet(PropName, &pQualSet);

            // Get the QualifierSet
            if (sc == WBEM_NO_ERROR)
            {
                // Get CIMTYPE attribute (if any)
                sc = pQualSet->Get(CIMTYPEQUAL, 0L, &varVal, NULL);
                if (sc == WBEM_NO_ERROR)
                {
                    bstrCimType = SysAllocString(V_BSTR(&varVal));
                    varVal.Clear();
                }
                else if (sc != WBEM_E_NOT_FOUND)
                {  // some other error
                    PrintErrorAndExit("Could not get CIMTYPE qualifier", sc, g_dwErrorFlags);  // Exits program
                }

                // Determine if this is a key property
                sc = pQualSet->Get(KEYQUAL, 0L, &varVal, NULL);
                if (sc == WBEM_NO_ERROR)
                {
                    bKey = (bool)varVal.boolVal;
                }
                else if (sc == WBEM_E_NOT_FOUND)
                {  // not a key qualifier
                    bKey = false;
                }
                else
                { // some other error
                    PrintErrorAndExit("Could not get key qualifier", sc, g_dwErrorFlags);  // Exits program
                }

                // this mess is due to the fact that system properties don't have qualifiers
            } 
            else if (sc != WBEM_E_SYSTEM_PROPERTY)
            {
                PrintErrorAndExit("Could not GetPropertyQualifierSet", sc, g_dwErrorFlags);  // Exits program
            }
            else
            {
                bstrCimType = SysAllocString(L"");
            }

            // print variable type and key indicatory for property value
            if (!g_bMofTemplate)
            {
                clMyBuff += L" (";
                clMyBuff += TypeToString(dwType);

                if (bstrCimType != NULL)
                {
                    clMyBuff += L"/";
                    clMyBuff += bstrCimType;
                }

                // Mark the key fields
                if (bKey)
                {
                    clMyBuff += L")* ";
                }
                else
                {
                    clMyBuff += L") ";
                }
            }

            // If we are showing a mof template, and this property is an embedded object and
            // there is no default object, we will need to create a blank one.
            if ((g_bMofTemplate) &&
                (V_VT(&varString) == VT_NULL) &&
                ((dwType == CIM_OBJECT) || (dwType == (CIM_OBJECT | CIM_FLAG_ARRAY))))
            {
                IWbemServicesPtr pIWbemServices;

                Init(&pIWbemServices, g_pwcsNamespace);        // Connect to wbem

                // Get the object
                sc = pIWbemServices->GetObject(

                        bstr_t(&bstrCimType[7]),
                        g_lGFlags,
                        g_pContext,
                        &clObject1,
                        NULL
                    );
                if (sc != WBEM_NO_ERROR)
                {
                    PrintErrorAndExit("Failed to GetObject in EnumProperties", sc, g_dwErrorFlags);
                }

                // and spawn an instance of it
                sc = clObject1->SpawnInstance(0L, &clObject2);
                if (sc != WBEM_NO_ERROR)
                {
                    PrintErrorAndExit("Failed to SpawnInstance in EnumProperties", sc, g_dwErrorFlags);
                }

                // If this is an array, create a safearray object
                if (dwType & CIM_FLAG_ARRAY)
                {
                    // Create the array
                    SAFEARRAYBOUND rgsabound[1];
                    rgsabound[0].cElements = 1;
                    rgsabound[0].lLbound = 0;

                    V_ARRAY(&varString) = SafeArrayCreate((VARTYPE)(dwType & (~CIM_FLAG_ARRAY)), 1, rgsabound);

                    // Put the object into the safearray
                    void *vptr;

                    SafeArrayAccessData(V_ARRAY(&varString), &vptr);
                    clObject2->QueryInterface(IID_IUnknown, (void **)vptr);
                    SafeArrayUnaccessData(V_ARRAY(&varString));

                }
                else
                {
                    clObject2->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&varString));
                }

                // Reset the type from null to dwType
                V_VT(&varString) = (VARTYPE)dwType;
            }

            // Print the value
            clMyBuff += L" = ";
            if ((V_VT(&varString) == VT_UNKNOWN) || (V_VT(&varString) == (VT_UNKNOWN | VT_ARRAY)))
            {
                clMyBuff += g_pwcsNewLine;
                clMyBuff += ValueToString(dwType, &varString, &pBuf, MyValueToString);
            }
            else
            {
                // For mof templates, if this is an array, add the braces
                if ((g_bMofTemplate) && ((V_VT(&varString) & VT_ARRAY) != 0))
                {
                    clMyBuff += L"{";
                }
                clMyBuff += ValueToString(dwType, &varString, &pBuf, MyValueToString);
                if ((g_bMofTemplate) && (V_VT(&varString) & VT_ARRAY) != 0)
                {
                    clMyBuff += L"}";
                }
                // For mof templates, add the cimtype et al as a comment
                if (g_bMofTemplate)
                {
                    clMyBuff += L"\t//\t";
                    clMyBuff += TypeToString(dwType);
                    clMyBuff += L"\t";
                    clMyBuff += bstrCimType;
                    clMyBuff += L"\t";
                    BSTR bstrOrigin = NULL;
                    pIWbemClassObject->GetPropertyOrigin(PropName, &bstrOrigin);
                    clMyBuff += bstrOrigin;
                    if (bKey)
                    {
                        clMyBuff += L"\t*";
                    }
                    SysFreeString(bstrOrigin);
                }
                clMyBuff += g_pwcsNewLine;
            }

            // Release and reset for next pass
            if (bstrCimType != NULL)
            {
                SysFreeString(bstrCimType);
                bstrCimType = NULL;
            }
            bKey = false;

            free(pBuf);

            varString.Clear();
            varVal.Clear();
      }
      SysFreeString(PropName);
   }

   SafeArrayDestroy(psaNames);

   if (g_bMofTemplate)
   {
       g_dwIndent--;
       for (DWORD x=0; x < g_dwIndent; x++)
       {
           clMyBuff += L"\t";
       }

       clMyBuff += L"};";
       clMyBuff += g_pwcsNewLine;
   }

   return clMyBuff.GetCloneString();
}

//*****************************************************************************
// Function:   EnumNamespaces
// Purpose:    Enumerate NameSpaces
//*****************************************************************************
void EnumNamespaces(IWbemServices *pIWbemServices, LPCWSTR pwcsClassName)
{
    SCODE sc;

    // If we aren't showing mofs or command lines
    if (!((g_bClassMofs) || (g_bInstanceMofs) || (g_bShowInstance) || (g_bMofTemplate)))
    {
        variant_t varString;
        IWbemClassObjectPtr pIWbemClassObject;

        // Do this to get the right casing for the NameSpace
        // Call GetObject with a known-to-exist class
        sc = pIWbemServices->GetObject(

                bstr_t(SYSTEMCLASS),
                g_lGFlags,
                g_pContext,
                &pIWbemClassObject,
                NULL
            );

        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Could not GetObject of __SystemClass in EnumNamespaces", sc, g_dwErrorFlags);  // Exits program
        }

        sc = pIWbemClassObject->Get(NAMESPACEPROP, 0L, &varString, NULL, NULL);
        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Could not get __NameSpace property for class", sc, g_dwErrorFlags);  // Exits program
        }

        // Indent appropriate number of spaces and print namespace
        DoIndent();
        FWPRINTF(g_fOut, L"<%wS>%wS", V_BSTR(&varString), g_pwcsNewLine);

        // Everything under this should be indented one more level
        g_dwIndent++;
    }

    // If we are enumerating a specific class or instance, specify the class else pass null
    if (pwcsClassName != NULL)
    {
        IWbemClassObjectPtr pIWbemClassObject;

        // See if we are dealing with a single instance
        if (wcschr(pwcsClassName, L'=') != NULL)
        {
            variant_t varString;

            for (DWORD x=0; x < g_dwLoopCnt; x++)
            {
                sc = pIWbemServices->GetObject(

                        bstr_t(pwcsClassName),
                        g_lGFlags,
                        g_pContext,
                        &pIWbemClassObject,
                        NULL
                    );

                if (sc != WBEM_NO_ERROR)
                {
                    fprintf(stderr, "%S\n", pwcsClassName);
                    PrintErrorAndExit("Could not GetObject of specified class in EnumNamespaces", sc, g_dwErrorFlags);  // Exits program
                }

                sc = pIWbemClassObject->Get(CLASSPROP, 0L, &varString, NULL, NULL);
                if (sc != WBEM_NO_ERROR)
                {
                    PrintErrorAndExit("Could not get __Class property for class", sc, g_dwErrorFlags);  // Exits program
                }

                ShowInstanceHeader(V_BSTR(&varString));
                ShowInstance(pIWbemServices, pIWbemClassObject);
                varString.Clear();
            }
        }
        else
        {
            sc = pIWbemServices->GetObject(

                    bstr_t(pwcsClassName),
                    g_lGFlags,
                    g_pContext,
                    &pIWbemClassObject,
                    NULL
                );

            if (sc != WBEM_NO_ERROR)
            {
                fprintf(stderr, "%S\n", pwcsClassName);
                PrintErrorAndExit("Could not GetObject of specified class in EnumNamespaces", sc, g_dwErrorFlags);  // Exits program
            }

            ShowClass(pIWbemServices, pIWbemClassObject);
        }
    }
    else
    {
        EnumClasses(pIWbemServices, L"");
    }

    // If the user did not specify /S on the command line, we're done
    if (!g_bRecurseNS)
    {
        return;
    }

    IEnumWbemClassObjectPtr IEnumWbemClassObject;

    //Find any namespaces under the current namespace
    sc = pIWbemServices->CreateInstanceEnum(

            bstr_t(NAMESPACEPROP),         // with this name
            WBEM_FLAG_DEEP | g_lEFlags,
            g_pContext,
            &IEnumWbemClassObject   // using this enumerator
        );

    // If we find any namespaces, we'll want to enumerate them too
    if (sc == WBEM_NO_ERROR)
    {
        DWORD dwAuthLevel, dwImpLevel;
        sc = GetAuthImp(pIWbemServices, &dwAuthLevel, &dwImpLevel);
        if (sc != S_OK)
        {
            PrintErrorAndExit("GetAuthImp Failed on CreateInstanceEnum (ns)", sc, g_dwErrorFlags);
        }

        if (g_lImpFlag != -1)
        {
            dwImpLevel = g_lImpFlag;
        }

        if (g_lAuthFlag != -1)
        {
            dwAuthLevel = g_lAuthFlag;
        }

        sc = SetInterfaceSecurity(IEnumWbemClassObject, g_pwcsAuthority, g_pwcsUserID, g_pwcsPassword, dwAuthLevel, dwImpLevel);
        if (sc != S_OK)
        {
            PrintErrorAndExit("SetInterfaceSecurity Failed on CreateInstanceEnum (ns)", sc, g_dwErrorFlags);
        }

        ULONG uReturned;
        IWbemClassObjectPtr pIWbemClassObject;
        variant_t varString;

        do
        {
            do
            {
                // Get the name of the next namespace
                sc = IEnumWbemClassObject->Next(

                        TIMEOUT,
                        1,
                        &pIWbemClassObject,
                        &uReturned
                    );

                if (g_bExit)
                {
                    throw 1;
                }
            } while (sc == WBEM_S_TIMEDOUT);

            if (sc == S_OK)
            {
                // Get the name
                sc = pIWbemClassObject->Get(NAMEPROP, 0L, &varString, NULL, NULL);
                if (sc != WBEM_NO_ERROR)
                {
                    PrintErrorAndExit("Could not get name property", sc, g_dwErrorFlags);  // Exits program
                }

                IWbemServicesPtr pNewIWbemServices;

                // Open it
                sc = pIWbemServices->OpenNamespace(

                        V_BSTR(&varString),
                        0L,
                        NULL,
                        &pNewIWbemServices,
                        NULL
                    );
                if (sc != WBEM_NO_ERROR)
                {
                    PrintErrorAndExit("Failed to Open Namespace", sc, g_dwErrorFlags);  // Exits program
                }

                // Now show all the classes/instances in the new Namespace
                EnumNamespaces(pNewIWbemServices, pwcsClassName);

                // Release
                varString.Clear();
            }
        } while (sc == S_OK);

        // Make sure we ended on a positive note
        if (sc != S_FALSE)
        {
            PrintErrorAndExit("Could not get next namespace", sc, g_dwErrorFlags);  //Exits program
        }
    }
    else
    {
        PrintErrorAndExit("Failed to CreateInstanceEnum", sc, g_dwErrorFlags);  // Exits program
    }

    // Back up one level of indention
    g_dwIndent--;
}

//*****************************************************************************
// Function:   GetObj
// Purpose:    This is useful to test both enumerate and getobject
//*****************************************************************************
IWbemClassObject *GetObj(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject)
{
    SCODE sc;
    variant_t varString;
    IWbemClassObject *clObject = NULL;

    // Get the relative path of the current instance
    sc = pIWbemClassObject->Get(RELPATHPROP, 0L, &varString, NULL, NULL);
    if ((sc != WBEM_NO_ERROR) || (V_VT(&varString) != VT_BSTR))
    {
        if (g_bWarningContinue)
        {
            PrintError("Could not get path of class", sc, g_dwErrorFlags);
        }
        else if (g_bWarning)
        {
            PrintErrorAndAsk("Could not get path of class", sc, g_dwErrorFlags);  // might exit program
        }
        else
        {
            PrintErrorAndExit("Could not get path of class", sc, g_dwErrorFlags);  // might exit program
        }
        return NULL;
    }

    // Call GetObject with this path.  Obviously, this should succeed.
    sc = pIWbemServices->GetObject(

            V_BSTR(&varString),
            g_lGFlags,
            g_pContext,
            &clObject,
            NULL
        );

    if (sc != WBEM_NO_ERROR)
    {
        if (g_bWarningContinue)
        {
            PrintError("Could not GetObject on class", sc, g_dwErrorFlags);
        }
        else if (g_bWarning)
        {
            PrintErrorAndAsk("Could not GetObject on class", sc, g_dwErrorFlags);  // might exit program
        }
        else
        {
            PrintErrorAndExit("Could not GetObject on class", sc, g_dwErrorFlags);  // will exit program
        }
        return NULL;
    }

    return clObject;
}

//*****************************************************************************
// Function:   ExecuteQuery
// Purpose:    
//*****************************************************************************
void ExecuteQuery(IWbemServices *pIWbemServices, LPCWSTR pwcsQueryLanguage, LPCWSTR pwcsQuery)
{
    SCODE  sc;
    IEnumWbemClassObjectPtr IEnumWbemClassObject;
    InstanceQuerySinkPtr pMySink;

    struct _timeb start, finish;
    LARGE_INTEGER freq, start2;
    QueryPerformanceFrequency(&freq);

    DoIndent(); // Indent
    FWPRINTF(g_fOut, L"(%wS) %wS%wS", pwcsQueryLanguage, pwcsQuery, g_pwcsNewLine); //Print class name

    for (DWORD dwLoop = 0; dwLoop < g_dwLoopCnt; dwLoop++)
    {
        // If we are doing timings
        if (g_bTime1)
        {
            _ftime(&start);
        }

        if (!g_bTime2)
        {
            start2.QuadPart = 0;
        }
        else
        {
            QueryPerformanceCounter(&start2);
        }

        if (!g_bASync)
        {
            sc = pIWbemServices->ExecQuery(

                    bstr_t(pwcsQueryLanguage),
                    bstr_t(pwcsQuery),
                    0L | g_lEFlags,
                    g_pContext,
                    &IEnumWbemClassObject   // using this enumerator
                );
        }
        else
        {
            pMySink.Attach(new InstanceQuerySink(pIWbemServices, false));
            sc = pIWbemServices->ExecQueryAsync(

                    bstr_t(pwcsQueryLanguage),
                    bstr_t(pwcsQuery),
                    0L | g_lEFlags,
                    g_pContext,
                    pMySink
                );
        }

        // If we are doing timings
        if (g_bTime1)
        {
            _ftime(&finish);
            fprintf(stdout, "ExecQuery %6.4f seconds.\n", difftime(finish, start));
        }
        if (g_bTime2)
        {
            LARGE_INTEGER finish2;
            QueryPerformanceCounter(&finish2);
            fprintf(stdout, "ExecQuery: %I64d (%6.4f)\n", finish2.QuadPart - start2.QuadPart, (double)(finish2.QuadPart - start2.QuadPart)/freq.QuadPart);
        }

        if (sc == WBEM_NO_ERROR)
        {
            DWORD dwCount;

            // If we are doing timings
            if (g_bTime1)
            {
                _ftime(&start);
            }

            if (!g_bTime2)
            {
                start2.QuadPart = 0;
            }
            else
            {
                QueryPerformanceCounter(&start2);
            }

            if (!g_bASync)
            {
                sc = ShowInstancesSync(pIWbemServices, IEnumWbemClassObject, dwCount, false);
            }
            else
            {
                do
                {
                    sc = WaitForSingleObject(pMySink->GetEvent(), TIMEOUT);
                    if (g_bExit)
                    {
                        sc = pIWbemServices->CancelAsyncCall(pMySink);
                        throw 1;
                    }
                } while (sc == WAIT_TIMEOUT);

                dwCount = pMySink->GetCount();
                sc = pMySink->GetResult();
                if (sc == WBEM_S_NO_ERROR)
                {
                    sc = S_FALSE;
                }
            }

            // If we are doing timings
            if (g_bTime1)
            {
                _ftime(&finish);
                fprintf(stdout, "ShowInstances %6.4f seconds, %d instances.\n", difftime(finish, start), dwCount);
            }

            if (g_bTime2)
            {
                LARGE_INTEGER finish2;
                QueryPerformanceCounter(&finish2);
                fprintf(stdout, "ShowInstances: %I64d (%6.4f), %d instances.\n", finish2.QuadPart - start2.QuadPart, (double)(finish2.QuadPart - start2.QuadPart)/freq.QuadPart, dwCount);
            }

            // Make sure we ended on a positive note
            if (sc != S_FALSE)
            {
                PrintErrorAndExit("Could not get next query instance", sc, g_dwErrorFlags);  // Exits program
            }
        }
        else
        {
            PrintErrorAndExit("Error on query", sc, g_dwErrorFlags);
        }
    }
}

//*****************************************************************************
// Function:   ShowInstancesSync
// Purpose:    
//*****************************************************************************
HRESULT ShowInstancesSync(IWbemServices *pIWbemServices, IEnumWbemClassObject *IEnumWbemClassObject, DWORD &dwCount, LPCWSTR pwcsClassName)
{
    dwCount = 0;

    DWORD dwAuthLevel, dwImpLevel;
    SCODE sc = GetAuthImp(pIWbemServices, &dwAuthLevel, &dwImpLevel);
    if (sc != S_OK)
    {
        PrintErrorAndExit("GetAuthImp Failed on ExecQuery", sc, g_dwErrorFlags);
    }

    if (g_lImpFlag != -1)
    {
        dwImpLevel = g_lImpFlag;
    }

    if (g_lAuthFlag != -1)
    {
        dwAuthLevel = g_lAuthFlag;
    }

    sc = SetInterfaceSecurity(IEnumWbemClassObject, g_pwcsAuthority, g_pwcsUserID, g_pwcsPassword, dwAuthLevel, dwImpLevel);
    if (sc != S_OK)
    {
        PrintErrorAndExit("SetInterfaceSecurity Failed on ExecQuery", sc, g_dwErrorFlags);
    }

    ULONG uReturned;
    IWbemClassObjectPtr pIWbemClassObject;

    do
    {
        // Get the next instance
        do
        {
            sc = IEnumWbemClassObject->Next(

                    TIMEOUT,
                    1,
                    &pIWbemClassObject,
                    &uReturned
                );

            if (g_bExit)
            {
                throw 1;
            }
        } while (sc == WBEM_S_TIMEDOUT);

        if(sc == S_OK)
        {
            if (pwcsClassName != NULL)
            {
                ShowInstanceHeader(pwcsClassName);
            }
            else
            {
                pwcsClassName = NULL;
            }

            ShowInstance(pIWbemServices, pIWbemClassObject);
            dwCount++;
        }
    } while (sc == S_OK);

    return sc;
}

//*****************************************************************************
// Function:   PrintMof
// Purpose:    Prints the mof file for the class that was passed in
// Note:
//*****************************************************************************
void PrintMof(IWbemClassObject *clObject)
{
    SCODE sc;
    BSTR pObjectText = NULL;

    // Get the mof
    sc = clObject->GetObjectText(0L, &pObjectText);
    if (sc != WBEM_NO_ERROR)
    {
        PrintErrorAndExit("Failed to print mof", sc, g_dwErrorFlags);  // Exits program
    }

    // Print it
    FWPRINTF(g_fOut, L"%wS", pObjectText);

    // Clean up
    SysFreeString(pObjectText);
}

//*****************************************************************************
// Function:   ShowInstance
// Purpose:    Shows the appropriate info for one specific instance
// Note:
//*****************************************************************************
void ShowInstance(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject)
{
    IWbemClassObjectPtr clObject;
    WCHAR *buf;
    MyString clMyBuff;
    SCODE sc;
    variant_t varVal;
    bool bGotOne = false;

    // Get Object (useful to test both enumerate and getobject)
    if (g_bCheckGet)
    {
        clObject = GetObj(pIWbemServices, pIWbemClassObject);
        if (clObject == NULL)
        {
            clObject = pIWbemClassObject;
        }
        else
        {
            bGotOne = true;
        }
    }
    else
    {
        clObject = pIWbemClassObject;
    }

    if (g_bCheckAssoc)
    {
        CheckAssocEndPoints(pIWbemServices, pIWbemClassObject);
    }

    // If we are just showing the mof for each instance
    if (g_bInstanceMofs)
    {
        PrintMof(clObject);

        // If we are just printing the command line to show this instance
    }
    else if (g_bShowInstance)
    {
        // Start building the command line
        clMyBuff += L" \"";

        // Get the ns
        sc = clObject->Get(NAMESPACEPROP, 0L, &varVal, NULL, NULL);
        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Could not get __namespace", sc, g_dwErrorFlags);  // Exits program
        }
        varVal.Clear();

        // Add the relpath
        sc = clObject->Get(RELPATHPROP, 0L, &varVal, NULL, NULL);
        if (sc != WBEM_NO_ERROR)
        {
            PrintErrorAndExit("Could not get __relpath", sc, g_dwErrorFlags);  // Exits program
        }
        WCHAR *pW;
        pW = wcschr(V_BSTR(&varVal), L'=') + 1;
        buf = EscapeChars(pW);
        *(pW) = L'\0';
        clMyBuff += V_BSTR(&varVal);
        clMyBuff += buf;
        clMyBuff += L"\"";

        free(buf);

        // Print it and we're done
        FWPRINTF(g_fOut, L"%wS%wS", clMyBuff.GetString(), g_pwcsNewLine); // Print the command line
        clMyBuff.Empty();

    }
    else
    {
        // Otherwise we want to show the instance details
        if (!g_bMofTemplate)
        {
            g_dwIndent++;              // Increase indention level
        }
        buf = EnumProperties(clObject);
        FWPRINTF(g_fOut, L"%wS%wS", buf, g_pwcsNewLine); // Print the properties
        free(buf);
        if (!g_bMofTemplate)
        {
            g_dwIndent--;              // Decrease the indention level
        }
    }
}

//*****************************************************************************
// Function:   BstrCmp
// Purpose:    Compares 2 bstr arguments
// Note:       Used by the qsort routine
//*****************************************************************************
int __cdecl BstrCmp(const void *arg1,const void *arg2)
{
    return _wcsicmp( *(WCHAR **)arg1, *(WCHAR **)arg2 );
}

//*****************************************************************************
// Function:   DoIndent
// Purpose:    Indents g_dwIndent tabs
//*****************************************************************************
void DoIndent()
{
    for (DWORD x=0; x < g_dwIndent; x++)
    {
        fputws(L"\t", g_fOut);
    }
}

//*****************************************************************************
// Function:   ProcessCommandLine
// Purpose:    This function processes the command line for the program,
//             filling in the global variables determining what the program
//             will do.
//*****************************************************************************
DWORD ProcessCommandLine(int argc, wchar_t *argv[])
{
    int iLoop, iPlace;
    char *z;
    WCHAR *pwcsName, *pwcsValue;
    SCODE sc;
    variant_t vValue;
    char *szHelp = "WBEMDUMP - Dumps the contents of the CIMOM database.\n\n"
        "Syntax: wbemdump [switches] [Namespace [Class|ObjectPath] ]\n"
        "        wbemdump /Q [switches] Namespace QueryLanguage Query\n\n"
        "Where:  'Namespace' is the namespace to dump (defaults to root\\default)\n"
        "        'Class' is the name of a specific class to dump (defaults to none)\n"
        "        'ObjectPath' is one instance (ex \"SClassA.KeyProp=\\\"foobar\\\"\")\n"
        "        'QueryLanguage' is any WBEM supported query language (currently only\n"
        "           \"WQL\" is supported).\n"
        "        'Query' is a valid query for the specified language, enclosed in quotes\n"
        "        'switches' is one of\n"
        "           /S Recurse down the tree\n"
        "           /S2 Recurse down Namespaces (implies /S)\n"
        "           /E Show system classes and properties\n"
        "           /E1 Like /E except don't show __SERVER or __PATH property\n"
        "           /E2 Shows command lines for dumping instances (test mode)\n"
        "           /D Don't show properties\n"
        "           /G Do a GetObject on all enumerated instances\n"
        "           /G2 Do a GetObject on all reference properties\n"
        "           /G:<x> Like /G using x for flags (Amended=131072)\n"
        "           /M Get Class MOFS instead of data values\n"
        "           /M2 Get Instance MOFS instead of data values\n"
        "           /M3 Produce instance template\n"
        "           /B:<num> CreateEnum flags (SemiSync=16; Forward=32)\n"
        "           /AS Use Async functions\n"
        "           /W  Prompt to continue on warning errors\n"
        "           /WY Print warnings and continue\n"
        "           /W:1 Use IWbemClassObject::GetObjectText to show errors\n"
        "           /H:<name>:<value> Specify context object value (test mode)\n"
        "           /CQV:<name>[:value] Specify a class qualifier on which to filter\n"
        "           /T Print times on enumerations\n"
        "           /T2 Print times on enumerations using alternate timer\n"
        "           /O:<file> File name for output (creates Unicode file)\n"
        "           /C:<file> Command file containing multiple WBEMDUMP command lines\n"
        "           /U:<UserID> UserID to connect with (default: NULL)\n"
        "           /P:<Password> Password to connect with (default: NULL)\n"
        "           /A:<Authority> Authority to connect with\n"
        "           /I:<ImpLevel> Anonymous=1 Identify=2 Impersonate=3(dflt) Delegate=4\n"
        "           /AL:<AuthenticationLevel> None=1 Conn=2 Call=3 Pkt=4 PktI=5 PktP=6\n"
        "           /Locale:<localid> Locale to pass to ConnectServer\n"
        "           /L:<LoopCnt> Number of times to enumerate instances (leak check)\n"
        "\n"
        "Notes:  - You can redirect the output to a file using standard redirection.\n"
        "        - If the /C switch is used, the namespace on the command line must\n"
        "          be the same namespace that is used for each of the command lines.\n"
        "          It is not possible to use different namespaces on the different lines\n"
        "          in the command file.\n"
        "\n"
        "EXAMPLES:\n"
        "\n"
        "  WBEMDUMP /S /E root\\default            - Dumps everything in root\\default\n"
        "  WBEMDUMP /S /E /M /M2 root\\default     - Dump all class & instance mofs\n"
        "  WBEMDUMP root\\default foo              - Dumps all instances of the foo class\n"
        "  WBEMDUMP root\\default foo.name=\\\"bar\\\" - Dumps one instance of the foo class\n"
        "  WBEMDUMP /S2 /M root    - Dumps mofs for all non-system classes in all NS's\n"
        "  WBEMDUMP /Q root\\default WQL \"SELECT * FROM Environment WHERE Name=\\\"Path\\\"\""
        "\n";

    // Process all the arguments.
    // ==========================
    if (g_pwcsNamespace != NULL)
    {
        // Only applies to scripts
        iPlace = 1;
    }
    else
    {
        iPlace = 0;
    }

    // Set global flags depending on command line arguments
    for (iLoop = 1; iLoop < argc; ++iLoop)
    {
        if (_wcsicmp(argv[iLoop], L"/HELP") == 0 || _wcsicmp(argv[iLoop],L"-HELP") == 0 ||
            (wcscmp(argv[iLoop], L"/?") == 0) || (wcscmp(argv[iLoop], L"-?") == 0))
        {
            fputs(szHelp, stdout);
            return(S_FALSE);
        }
        else if (_wcsicmp(argv[iLoop], L"/S") == 0 || _wcsicmp(argv[iLoop],L"-S") == 0)
        {
            g_bRecurseClass = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/S2") == 0 || _wcsicmp(argv[iLoop],L"-S2") == 0)
        {
            g_bRecurseClass = TRUE;
            g_bRecurseNS = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/Q") == 0 || _wcsicmp(argv[iLoop],L"-Q") == 0)
        {
            g_bDoQuery = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/E") == 0 || _wcsicmp(argv[iLoop],L"-E") == 0)
        {
            g_bShowSystem = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/E1") == 0 || _wcsicmp(argv[iLoop],L"-E1") == 0)
        {
            g_bShowSystem = TRUE;
            g_bShowSystem1 = TRUE;
            g_bShowInstance = FALSE;
        }
        else if (_wcsicmp(argv[iLoop], L"/E2") == 0 || _wcsicmp(argv[iLoop],L"-E2") == 0)
        {
            g_bShowSystem1 = FALSE;
            g_bShowInstance = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/D") == 0 || _wcsicmp(argv[iLoop],L"-D") == 0)
        {
            g_bShowProperties = FALSE;
        }
        else if (_wcsicmp(argv[iLoop], L"/G") == 0 || _wcsicmp(argv[iLoop],L"-G") == 0)
        {
            g_bCheckGet = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/G2") == 0 || _wcsicmp(argv[iLoop],L"-G2") == 0)
        {
            g_bCheckAssoc = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/M") == 0 || _wcsicmp(argv[iLoop],L"-M") == 0)
        {
            g_bClassMofs = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/M2") == 0 || _wcsicmp(argv[iLoop],L"-M2") == 0)
        {
            g_bInstanceMofs = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/M3") == 0 || _wcsicmp(argv[iLoop],L"-M3") == 0)
        {
            g_bMofTemplate = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/W") == 0 || _wcsicmp(argv[iLoop],L"-W") == 0)
        {
            g_bWarning = TRUE;
            g_bWarningContinue = FALSE;
        }
        else if (_wcsnicmp(argv[iLoop], L"/W:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-W:", 3) == 0)
        {
            g_dwErrorFlags = _wtoi((argv[iLoop])+3);
        }
        else if (_wcsicmp(argv[iLoop], L"/WY") == 0 || _wcsicmp(argv[iLoop],L"-WY") == 0)
        {
            g_bWarningContinue = TRUE;
        }
        else if (_wcsicmp(argv[iLoop], L"/T") == 0 || _wcsicmp(argv[iLoop],L"-T") == 0)
        {
            g_bTime1 = TRUE;
        }
        else if (_wcsnicmp(argv[iLoop], L"/T2", 3) == 0 || _wcsnicmp(argv[iLoop],L"-T2", 3) == 0)
        {
            g_bTime2 = TRUE;
        }
        else if (_wcsnicmp(argv[iLoop], L"/G:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-G:", 3) == 0)
        {
            g_lGFlags = _wtoi((argv[iLoop])+3);
        }
        else if (_wcsnicmp(argv[iLoop], L"/H:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-H:", 3) == 0)
        {
            if (g_pContext == NULL)
            {
                sc = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&g_pContext);
                if (S_OK != sc)
                {
                    PrintErrorAndExit("Can't create context object", sc, g_dwErrorFlags);
                }
            }
            pwcsName = (argv[iLoop])+3;
            pwcsValue = wcschr(pwcsName, L':');
            if (pwcsValue == NULL)
            {
                PrintErrorAndExit("Can't parse Context value", 0, g_dwErrorFlags);
            }
            *pwcsValue = L'\0';
            pwcsValue++;
            vValue = pwcsValue;
            sc = g_pContext->SetValue(pwcsName, 0L, &vValue);
            if (S_OK != sc)
            {
                PrintErrorAndExit("Failed to SetValue on context object", 0, g_dwErrorFlags);
            }
        } 
        else if (_wcsnicmp(argv[iLoop], L"/U:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-U:", 3) == 0)
        {
            g_pwcsUserID = (argv[iLoop])+3;
        } 
        else if (_wcsnicmp(argv[iLoop], L"/P:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-P:", 3) == 0)
        {
            g_pwcsPassword = (argv[iLoop])+3;
            // Currently not implemented.
            //      }
            //      else if (_wcsnicmp(argv[iLoop], L"/F:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-F:", 3) == 0)
            //      {
            //         g_lSFlags = _wtoi((argv[iLoop])+3);
        }
        else if (_wcsnicmp(argv[iLoop], L"/I:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-F:", 3) == 0)
        {
            g_lImpFlag = _wtoi((argv[iLoop])+3);
        }
        else if (_wcsicmp(argv[iLoop], L"/AS") == 0 || _wcsicmp(argv[iLoop],L"-AS") == 0)
        {
            g_bASync = TRUE;
        }
        else if (_wcsnicmp(argv[iLoop], L"/AL:", 4) == 0 || _wcsnicmp(argv[iLoop],L"-AL:", 4) == 0)
        {
            g_lAuthFlag = _wtoi((argv[iLoop])+4);
        }
        else if (_wcsnicmp(argv[iLoop], L"/B:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-B:", 3) == 0)
        {
            g_lEFlags = _wtoi((argv[iLoop])+3);
        }
        else if (_wcsnicmp(argv[iLoop], L"/Locale:", 8) == 0 || _wcsnicmp(argv[iLoop],L"-Locale:", 8) == 0)
        {
            g_pwcsLocale = (argv[iLoop])+8;
        }
        else if (_wcsnicmp(argv[iLoop], L"/L:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-L:", 3) == 0)
        {
            g_dwLoopCnt = _wtoi((argv[iLoop])+3);
        }
        else if (_wcsnicmp(argv[iLoop], L"/A:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-A:", 3) == 0)
        {
            g_pwcsAuthority = (argv[iLoop])+3;
        }
        else if (_wcsnicmp(argv[iLoop], L"/O:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-O:", 3) == 0)
        {
            g_pwcsNewLine = L"\r\n";
            // must convert to oem string since w95 doesn't support _wfopen
            //         g_fOut = _wfopen(argv[iLoop], L"wb");
            g_fOut = fopen(cvt((argv[iLoop])+3, &z), "wb");
            free(z);
            if (g_fOut == NULL)
            {
                fprintf(stdout, "Can't open output file: %S (%d)\n", (argv[iLoop])+3, GetLastError());
                return(S_FALSE);
            }
            fputs(UNICODE_SIGNATURE, g_fOut);
        }
        else if (_wcsnicmp(argv[iLoop], L"/C:", 3) == 0 || _wcsnicmp(argv[iLoop],L"-C:", 3) == 0)
        {
            // must convert to oem string since w95 doesn't support _wfopen
            g_fCmdFile = fopen(cvt((argv[iLoop])+3, &z), "rb");
            free(z);
            if (g_fCmdFile == NULL)
            {
                fprintf(stdout, "Can't open command file: %S (%d)\n", (argv[iLoop])+3, GetLastError());
                return(S_FALSE);
            }

            // Now, let's see if we are dealing with a unicode file here
            char buff[2];
            fread(buff, 2, 1, g_fCmdFile);

            if (memcmp(buff, UNICODE_SIGNATURE, 2) != 0)
            {
                g_bUnicodeCmdFile = false;
                fseek(g_fCmdFile, 0, SEEK_SET);
            }
            else
            {
                g_bUnicodeCmdFile = true;
            }
        }
        else if (_wcsnicmp(argv[iLoop], L"/CQV:", 5) == 0 || _wcsnicmp(argv[iLoop],L"-CQV:", 5) == 0)
        {
            if (g_bstrQualifierName != NULL)
            {
                PrintErrorAndExit("Only 1 qualifer name can be filtered on", 0, g_dwErrorFlags);
            }
            pwcsName = (argv[iLoop])+5;
            pwcsValue = wcschr(pwcsName, L':');

            // all values
            if (pwcsValue == NULL)
            {
                g_bstrQualifierName = SysAllocString(pwcsName);
            }
            else
            {
                // Only specified value
                *pwcsValue = L'\0';
                pwcsValue++;
                g_bstrQualifierValue = SysAllocString(pwcsValue);
                g_bstrQualifierName = SysAllocString(pwcsName);
            }
        }
        else
        {
            switch (iPlace)
            {
                case 0:
                {
                    g_pwcsNamespace = argv[iLoop];
                    break;
                }
                case 1:
                {
                    g_pwcsObjectPath = argv[iLoop];
                    break;
                }
                case 2:
                {
                    g_pwcsQuery = argv[iLoop];
                    break;
                }
                default:
                {
                    break;
                }
            }

            ++iPlace;
        }
   }

   // See if we got enough arguments.
   // ===============================

   if (((iPlace > 2) && !g_bDoQuery) || ((iPlace != 3) && g_bDoQuery))
   {
       fputs(szHelp, stdout);
       return(S_FALSE);
   }

   if (!g_fOut)
   {
       g_fOut = stdout;
   }

   if (iPlace == 0)
   {
       g_pwcsNamespace = L"root\\default";
   }

   // Finished.
   // =========

   return(S_OK);
}

//*****************************************************************************
// Function:   EscapeChars
// Purpose:    'Escapes' characters in a string by placing '\' in front of
//             the " and \ characters.
// Notes:      Caller must free returned buffer
//*****************************************************************************
WCHAR *EscapeChars(LPCWSTR szInBuf)
{
    WCHAR *szOutBuf = NULL;
    int x;

    // Adding escape characters can't do more than double the string size
    szOutBuf = (WCHAR *)malloc(((wcslen(szInBuf) + 1) * sizeof(WCHAR)) * 2);
    x = 0;
    if(szOutBuf)
    {
        while (*szInBuf != 0)
        {
            if ((*szInBuf == L'\\') && (*(szInBuf + 1) == L'\"'))
            {
                szOutBuf[x++] = '\\';
            }
            else if (*szInBuf == L'"')
            {
                szOutBuf[x++] = '\\';
            }
            szOutBuf[x++] = *(szInBuf ++);
        }
        szOutBuf[x] = L'\0';
    }
    else
    {
        PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
    }

    return szOutBuf;
}

//*****************************************************************************
// Function:   MyValueToString
// Purpose:    A callback routine from utillib.  It is designed to handle any
//             variant types that ValueToString doesn't.  Specifically it
//             handles embedded objects.
//*****************************************************************************
WCHAR *MyValueToString(VARIANT *pv)
{
    WCHAR *buf = NULL;
    WCHAR *vbuf = NULL;

    switch (V_VT(pv))
    {
        case VT_UNKNOWN: // Currently only used for embedded objects
        {
            extern DWORD g_dwIndent;
            g_dwIndent++;
            buf = EnumProperties((IWbemClassObject *)pv->punkVal);  // May result in recursion
            g_dwIndent--;
            break;
        }

        case VT_UNKNOWN | VT_ARRAY:
        {
            g_dwIndent++;              // Increase indention level

            SAFEARRAY *pVec = pv->parray;
            long iLBound, iUBound;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)calloc(1, BLOCKSIZE);
                if (buf)
                {
                    for (DWORD x=0; x < g_dwIndent; x++)
                    {
                        buf[x] = L'\t';
                    }
                    wcscat(buf, L"<empty array>");
                    wcscat(buf, g_pwcsNewLine);
                }
                else
                {
                    PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
                }

                g_dwIndent--;              // Decrease indention level
                break;
            }

            buf = (WCHAR *)calloc(BLOCKSIZE, sizeof(WCHAR));

            if (buf)
            {
                IUnknownPtr v;
                IWbemClassObjectPtr pCO;
                variant_t varString;

                for (long i = iLBound; i <= iUBound; i++)
                {
                    SafeArrayGetElement(pVec, &i, &v);

                    pCO = v; // QI to IWbemClassObject
                    MyString clMyBuff;

                    HRESULT sc = pCO->Get(CLASSPROP, 0L, &varString, NULL, NULL);
                    if (S_OK != sc)
                    {
                        PrintErrorAndExit("Couldn't get class property in enumproperties", sc, g_dwErrorFlags);  //Exits program
                    }

                    //clMyBuff += g_pwcsNewLine;
                    for (DWORD x=0; x < g_dwIndent; x++)
                    {
                        clMyBuff += L"\t";
                    }
                    clMyBuff += L"instance of ";
                    clMyBuff += V_BSTR(&varString);
                    clMyBuff += L" {";
                    clMyBuff += g_pwcsNewLine;
                    g_dwIndent++;

                    varString.Clear();

                    vbuf = clMyBuff.GetCloneString();

                    // Copy into buffer
                    buf = (WCHAR *)realloc(buf, (wcslen(buf) + wcslen(vbuf) + 1) * sizeof(WCHAR));
                    if (buf)
                    {
                        wcscat(buf, vbuf);
                    }
                    else
                    {
                        PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
                    }

                    vbuf = EnumProperties(pCO);

                    // Copy into buffer
                    buf = (WCHAR *)realloc(buf, (wcslen(buf) + wcslen(vbuf) + 1) * sizeof(WCHAR));
                    if (buf) 
                    {
                        wcscat(buf, vbuf);
                    }
                    else
                    {
                        PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
                    }

                    // Add }
                    MyString clMyBuff2;

                    for (x=0; x < g_dwIndent-1; x++)
                    {
                        clMyBuff2 += L"\t";
                    }
                    clMyBuff2 += L" }";
                    clMyBuff2 += g_pwcsNewLine;
                    vbuf = clMyBuff2.GetCloneString();

                    // Copy into buffer
                    buf = (WCHAR *)realloc(buf, (wcslen(buf) + wcslen(vbuf) + 1) * sizeof(WCHAR));
                    if (buf)
                    {
                        wcscat(buf, vbuf);
                    }
                    else
                    {
                        PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
                    }

                    g_dwIndent--;

                    free(vbuf);
                }
            }
            else
            {
                PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
            }

            g_dwIndent--;              // Decrease indention level
            break;
        }

        default:
        {
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"<conversion error>");
            }
            else
            {
                PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
            }
        }
    }
    return buf;

}

//*****************************************************************************
// Function:   ShowInstanceHeader
// Purpose:    Prints the header at the top of each instance, unless we are
//             printing instance mofs
//*****************************************************************************
void ShowInstanceHeader(LPCWSTR pwcsClassName)
{
    if ((!g_bInstanceMofs) && (!g_bShowInstance))
    {
        DoIndent(); // Indent
        FWPRINTF(g_fOut, L"%wS%wS", pwcsClassName, g_pwcsNewLine); //Print class name
    }
}

//*****************************************************************************
// Function:   ResetGlobalFlags
// Purpose:    Resets the global flags to their default values.  This is
//             called in between command lines in a command file.
//*****************************************************************************
void ResetGlobalFlags()
{
    g_bShowSystem = FALSE;
    g_bShowSystem1 = FALSE;
    g_bShowInstance = FALSE;
    g_bShowProperties = TRUE;
    g_bRecurseClass = FALSE;
    g_bRecurseNS = FALSE;
    g_bCheckGet = FALSE;
    g_bCheckAssoc = FALSE;
    g_bDoQuery = FALSE;
    g_bClassMofs = FALSE;
    g_bInstanceMofs = FALSE;

    g_dwIndent = 0;              // Current indention level
    g_lGFlags = 0;

    g_pwcsObjectPath = NULL;  // ObjectPath to show
    g_pwcsQuery = NULL;      // Query (for /q commands)
}

//*****************************************************************************
// Function:   ParseCommandLine
// Purpose:    Reads the command line from a file and sends it to the parsing
//             routine.
//*****************************************************************************
bool ParseCommandLine(int *numargs, wchar_t **argv)
{
    WCHAR wszLine[4096];
    char szLine[4096];
    int numchars;
    WCHAR *p;

    // The parsing routine expects to find a program name as the first arg, so
    // give it one
    wcscpy(wszLine, L"xx ");

    // If this is a unicode command file, read a wcs
    if (g_bUnicodeCmdFile)
    {
        if (!fgetws(wszLine + 3, sizeof(wszLine)/sizeof(WCHAR), g_fCmdFile))
        {
            return false;
        }
    }
    else
    {
        // else convert to wcs
        szLine[0] = '\0';
        // If no more command lines
        if (!fgets(szLine, sizeof(szLine), g_fCmdFile))
        {
            return false;
        }
        swprintf(wszLine + 3, L"%S", szLine);
    }

    // Trim trailing cr, lf, space, and eof markers
    p = &wszLine[wcslen(wszLine)-1];
    while ((*p == L'\n') || (*p == L'\r') || (*p == L' ') || (*p == L'\x1a'))
    {
        *p = L'\0';
        p = &wszLine[wcslen(wszLine)-1];
    }

    // If we read a blank line
    if (wcscmp(wszLine, L"xx") == 0)
    {
        return false;
    }

    /* first find out how much space is needed to store args */
    wparse_cmdline(wszLine, NULL, NULL, numargs, &numchars);

    /* allocate space for argv[] vector and strings */
    p = (WCHAR *)malloc(*numargs * sizeof(WCHAR *) + numchars * sizeof(WCHAR));

    if (!p)
    {
        PrintErrorAndExit("Out of memory", 0, g_dwErrorFlags);
    }

    /* store args and argv ptrs in just allocated block */
    wparse_cmdline(wszLine, (wchar_t **)p, (wchar_t *)(((char *)p) + *numargs * sizeof(wchar_t *)), numargs, &numchars);

    *argv = p;
    (*numargs)--;

    return true;
}

/***
*static void parse_cmdline(cmdstart, argv, args, numargs, numchars)
*
*Purpose:
*       Parses the command line and sets up the argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, args
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only coujting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numchars has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       _TSCHAR *cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       _TSCHAR **argv - where to build argv array; NULL means don't
*                       build array
*       _TSCHAR *args - where to place argument text; NULL means don't
*                       store text
*
*Exit:
*       no return value
*       int *numargs - returns number of argv entries created
*       int *numchars - number of characters used in args buffer
*
*Exceptions:
*
*******************************************************************************/

#define DQUOTECHAR L'\"'
#define NULCHAR    L'\0'
#define SPACECHAR  L' '
#define TABCHAR    L'\t'
#define SLASHCHAR  L'\\'
static void __cdecl wparse_cmdline (
                                    WCHAR *cmdstart,
                                    WCHAR **argv,
                                    WCHAR *args,
                                    int *numargs,
                                    int *numchars
                                    )
{
    WCHAR *p;
    WCHAR c;
    int inquote;                /* 1 = inside quotes */
    int copychar;               /* 1 = copy char to *args */
    unsigned numslash;                  /* num of backslashes seen */

    *numchars = 0;
    *numargs = 1;       /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = args;

        /* A quoted program name is handled here. The handling is much
        simpler than for other arguments. Basically, whatever lies
        between the leading double-quote and next one, or a terminal null
        character is simply accepted. Fancier handling is not required
        because the program name must be a legal NTFS/HPFS file name.
        Note that the double-quote characters are not copied, nor do they
    contribute to numchars. */
    if ( *p == DQUOTECHAR )
    {
    /* scan from just past the first double-quote through the next
        double-quote, or up to a null, whichever comes first */
        while ( (*(++p) != DQUOTECHAR) && (*p != NULCHAR) )
        {

            ++*numchars;
            if ( args )
                *args++ = *p;
        }
        /* append the terminating null */
        ++*numchars;
        if ( args )
            *args++ = NULCHAR;

        /* if we stopped on a double-quote (usual case), skip over it */
        if ( *p == DQUOTECHAR )
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do
        {
            ++*numchars;
            if (args)
                *args++ = *p;

            c = (WCHAR) *p++;

        } while ( c != SPACECHAR && c != NULCHAR && c != TABCHAR );

        if ( c == NULCHAR )
        {
            p--;
        }
        else
        {
            if (args)
                *(args-1) = NULCHAR;
        }
    }

    inquote = 0;

    /* loop on each argument */
    for(;;)
    {
        if ( *p )
        {
            while (*p == SPACECHAR || *p == TABCHAR)
                ++p;
        }

        if (*p == NULCHAR)
            break;              /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = args;     /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for (;;)
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
            2N+1 backslashes + " ==> N backslashes + literal "
            N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == SLASHCHAR)
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == DQUOTECHAR)
            {
            /* if 2N backslashes before, start/end quote, otherwise
                copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                    {
                        if (p[1] == DQUOTECHAR)
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    } else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (args)
                    *args++ = SLASHCHAR;
                ++*numchars;
            }

            /* if at end of arg, break loop */
            if (*p == NULCHAR || (!inquote && (*p == SPACECHAR || *p == TABCHAR)))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (args)
                    *args++ = *p;
                ++*numchars;
            }
            ++p;
        }

        /* null-terminate the argument */

        if (args)
            *args++ = NULCHAR;          /* terminate string */
        ++*numchars;
    }

    /* We put one last argument in -- a null ptr */
    if (argv)
        *argv++ = NULL;
    ++*numargs;
}

//*****************************************************************************
// Function:   CheckQualifiers
// Purpose:    Checks to see if we are filtering on class qualifiers.  If
//             so, checks to see if the specified qualifier/value is present.
//*****************************************************************************
BOOL CheckQualifiers(IWbemClassObject *pIWbemClassObject)
{
    // If we are not filtering on qualifiers
    if (g_bstrQualifierName == NULL)
    {
        return TRUE;
    }

    BOOL bRet = TRUE;
    variant_t vValue;

    IWbemQualifierSet *pQualSet = NULL;
    HRESULT hr = pIWbemClassObject->GetQualifierSet(&pQualSet);

    // This should always work
    if (FAILED(hr))
    {
        PrintErrorAndExit("Failed to get class qualifier set", hr, g_dwErrorFlags); // exits program
    }

    // However, this might reasonably fail
    hr = pQualSet->Get(g_bstrQualifierName, 0L, &vValue, NULL);
    if (SUCCEEDED(hr))
    {
        // Ok, the qualifier is there.  Did they request a specific value?
        if (g_bstrQualifierValue == NULL)
        {
            bRet = TRUE;
        }
        else
        {
            // Check to see if the value match
            if (VariantChangeType(&vValue, &vValue, 0, VT_BSTR) == S_OK)
                bRet = _wcsicmp(V_BSTR(&vValue), g_bstrQualifierValue) == 0;
        }
    }
    else
    {
        // We failed to Get the qualifier.  Was it because the thing just wasn't there?
        if (hr == WBEM_E_NOT_FOUND)
        {
            bRet = FALSE;
        }
        else
        {
            // Some other error
            PrintErrorAndExit("Failed to Get class qualifier value", hr, g_dwErrorFlags); // exits program
        }
    }

    return bRet;

}

//*****************************************************************************
// Function:   CheckAssocEndPoints
// Purpose:    Checks to see if the references pointed to by the reference
//             properties of this class really exist.
//*****************************************************************************
void CheckAssocEndPoints(IWbemServices *pIWbemServices, IWbemClassObject *pIWbemClassObject)
{
    HRESULT hr;

    if (FAILED(hr = pIWbemClassObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY)))
    {
        PrintErrorAndExit("Failed to get Refs Enumeration", hr, g_dwErrorFlags); // exits program
    }

    BSTR bstrPropertyName = NULL;
    variant_t vVal;

    while (SUCCEEDED(hr = pIWbemClassObject->Next(0, &bstrPropertyName, &vVal, NULL, NULL)) &&
        (hr != WBEM_S_NO_MORE_DATA) )
    {
        if ( (V_VT(&vVal) == VT_BSTR) && (V_BSTR(&vVal) != NULL) )
        {
            if (FAILED(hr = pIWbemServices->GetObject(V_BSTR(&vVal), 0, NULL, NULL, NULL)))
            {
                char szBuff[_MAX_PATH];

                sprintf(szBuff, "Could not get endpoint for property %S", bstrPropertyName);

                if (g_bWarningContinue)
                {
                    PrintError(szBuff, hr, g_dwErrorFlags);
                }
                else if (g_bWarning)
                {
                    PrintErrorAndAsk(szBuff, hr, g_dwErrorFlags);  // might exit program
                }
                else
                {
                    PrintErrorAndExit(szBuff, hr, g_dwErrorFlags);  // will exit program
                }
            }
        }

        SysFreeString(bstrPropertyName);
        vVal.Clear();
    }
}

//*****************************************************************************
// Function:   CtrlHandler
// Purpose:    Checks to see if the references pointed to by the reference
//             properties of this class really exist.
//*****************************************************************************
BOOL CtrlHandler(DWORD fdwCtrlType)
{
    BOOL bRet = FALSE;

    switch (fdwCtrlType)
    {
        // Handle the CTRL+C signal.

        case CTRL_CLOSE_EVENT:
        case CTRL_C_EVENT:
        {
            g_bExit = true;
            bRet = TRUE;
        }

        // Pass other signals to the next handler.

        case CTRL_BREAK_EVENT:
        case CTRL_LOGOFF_EVENT:
        case CTRL_SHUTDOWN_EVENT:
        default:
        {
        }
    }
    
    return bRet;
}

//*****************************************************************************
// Class:      QuerySink
// Purpose:    Generic class to be used as the sink to wbem's async functions
//*****************************************************************************
QuerySink::QuerySink()
{
    m_lRef = 1;
    m_hResult = S_OK;
    m_hDone = CreateEvent(NULL, TRUE, FALSE, NULL);
}

QuerySink::~QuerySink()
{
    CloseHandle(m_hDone);
}

ULONG QuerySink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG QuerySink::Release()
{
    LONG lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        delete this;
    }
    return lRef;
}

HRESULT QuerySink::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = (IWbemObjectSink *) this;
        AddRef();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

HRESULT QuerySink::SetStatus(
            /* [in] */ LONG lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
        )
{
    UNREFERENCED(pObjParam);
    UNREFERENCED(strParam);

    if (WBEM_STATUS_COMPLETE == lFlags)
    {
        m_hResult = hResult;
        SetEvent(m_hDone);
    }

    return WBEM_S_NO_ERROR;
}

//*****************************************************************************
// Class:      InstanceQuerySink (derives from QuerySink)
// Purpose:    processes instances sent back from ExecQueryAsync 
//             and CreateInstanceEnumAsync
//*****************************************************************************
InstanceQuerySink::InstanceQuerySink(IWbemServices *pIWbemServices, LPCWSTR pwszClassName) : QuerySink()
{
    m_pIWbemServices = pIWbemServices;
    m_pwszClassName = pwszClassName;
    m_bFirst = true;
}

InstanceQuerySink::~InstanceQuerySink()
{
}

HRESULT InstanceQuerySink::Indicate(long lObjCount, IWbemClassObject **pArray)
{
    for (long i = 0; i < lObjCount; i++)
    {
        IWbemClassObject *pObj = pArray[i];

        if (m_pwszClassName != NULL)
        {
            if (!m_bFirst)
            {
                ShowInstanceHeader(m_pwszClassName);
            }
            else
            {
                m_bFirst = false;
            }
        }

        ShowInstance(m_pIWbemServices, pObj);
        m_dwCount++;
    }

    return WBEM_S_NO_ERROR;
}

//*****************************************************************************
// Class:      ClassQuerySink (derives from QuerySink)
// Purpose:    processes classes sent back from CreateClassEnum
//*****************************************************************************
ClassQuerySink::ClassQuerySink(IWbemServices *pIWbemServices) : QuerySink()
{
    m_pIWbemServices = pIWbemServices;
}

ClassQuerySink::~ClassQuerySink()
{
}

HRESULT ClassQuerySink::Indicate(long lObjCount, IWbemClassObject **pArray)
{
    for (long i = 0; i < lObjCount; i++)
    {
        IWbemClassObject *pObj = pArray[i];

        ShowClass(m_pIWbemServices, pObj);
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdiag\wbemdiag.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WBEMDiag.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "resource.h"
#include <wbemcli.h>
#include <comdef.h>

bool ConnectNamespace(IWbemLocator* pLocator, char* szNamespace, IWbemServices** ppNamespace);
void ListProviders(IWbemServices* pNamespace, char* szNamespace);
void ListComputerSystem(IWbemServices* pNamespace);
void PostError(HRESULT hr, UINT uContext);
void PrintHelp();
void PrintStringEx(UINT uID, ...);


HINSTANCE	hInst;		// Global for LoadString() to use

int main(int argc, char* argv[])
{
	try{

	HRESULT hr;
	char szNamespace[MAX_PATH];
	bool bListProviders = false;
	hInst = GetModuleHandle(NULL);


	switch(argc)
	{
/*#ifdef _DEBUG
	case 4:
		if (strcmp(argv[1], "-e") == 0)
		{
			HRESULT hr = strtoul(argv[2], NULL, 16);
			UINT uContext = atoi(argv[3]);
			PostError(hr, uContext);
			break;
		};
#endif
*/
	case 3:
		if (strcmp(argv[1],"-p") == 0)
		{
			bListProviders = true;
			strcpy(szNamespace,argv[2]);
		}
		else
			PrintHelp();
		break;
	case 2:
		if (strcmp(argv[1],"-p") == 0)
			bListProviders = true;
		else if ((strcmp(argv[1], "/?") == 0) ||
				(strcmp(argv[1], "-?") == 0) ||
				(strcmp(argv[1], "/h") == 0) ||
				(strcmp(argv[1], "-h") == 0)) 
			PrintHelp();
		else
		{
			strcpy(szNamespace,"\\\\");
			strcat(szNamespace, argv[1]);
			strcat(szNamespace, "\\root\\cimv2");
			break;
		};
	default:
		strcpy(szNamespace,"root\\cimv2");
	};
	
	// Initialize COM.
	if ((hr = CoInitialize(NULL)) == S_OK) 
	{
		IWbemLocator* pLocator;
		// Create an instance of the WbemLocator interface
		PrintStringEx(IDS_FINDINGLOCATOR);
		if ((hr = CoCreateInstance(CLSID_WbemLocator,
										NULL,
										CLSCTX_INPROC_SERVER,
										IID_IWbemLocator,
										(LPVOID *) &pLocator)) == S_OK)
		{
			IWbemServices* pNamespace = NULL;
			if (ConnectNamespace(pLocator, szNamespace, &pNamespace))
			{
				if (bListProviders)
					ListProviders(pNamespace, szNamespace);
				else
					ListComputerSystem(pNamespace);
				pNamespace->Release();
			};
			pLocator->Release();
		}
		else
			PostError(hr, IDS_WBEMINIT);
	}
	else
		PostError(hr, IDS_COMINIT);
	
	PrintStringEx(IDS_TRYHELP);
	return 0;

	}
	catch(...)
	{
		printf("\n\nThis program encounted an unrecoverable error.\n");
		return -1;
	};
}
bool ConnectNamespace(IWbemLocator* pLocator, char* szNamespace, 
					 IWbemServices** ppNamespace)
{
	PrintStringEx(IDS_NSCONNECTING, szNamespace);
	HRESULT hr;
	hr = pLocator->ConnectServer(_bstr_t(szNamespace), NULL, NULL, 
		NULL, 0L, NULL, NULL, ppNamespace);

	if (FAILED(hr))
		PostError(hr, IDS_NSCONNECT);
	else
		PrintStringEx(IDS_CONNECTSUCCESS);
	return (hr == S_OK);
};


void ListProviders(IWbemServices* pNamespace, char* szNamespace)
{
	IEnumWbemClassObject*	pEnum;
	HRESULT hr = pNamespace->CreateInstanceEnum(_bstr_t("__Win32Provider"), 
		WBEM_FLAG_DEEP, 0, &pEnum);
	if (FAILED(hr))
		PostError(hr, IDS_PROVIDERLIST);


	ULONG ulReturned;
	IWbemClassObject* pProvider;
	
	PrintStringEx(IDS_NSPROVIDERS, szNamespace);
	while(SUCCEEDED(hr = pEnum->Next(INFINITE, 1, &pProvider, &ulReturned)))
	{
		if (ulReturned == 1) try {

			_variant_t vProviderName;
			_variant_t vProviderCLSID;

			hr = pProvider->Get(_bstr_t("Name"), 0, &vProviderName, NULL, NULL);
			hr = pProvider->Get(_bstr_t("CLSID"), 0, &vProviderCLSID, NULL,	NULL);

			printf("%s\t: ", (char*)(_bstr_t)vProviderCLSID);
			printf("%s\n", (char*)(_bstr_t)vProviderName);

			pProvider->Release();
		}
		catch(_com_error err)
		{
			PostError(err.Error(), IDS_PROVIDERGET);
		}
		else 
			break;
	};

	pEnum->Release();

	if (FAILED(hr))
		PostError(hr, IDS_PROVIDERENUM);

};

void ListComputerSystem(IWbemServices* pNamespace)
{
	IEnumWbemClassObject*	pEnum;
	HRESULT hr = pNamespace->CreateInstanceEnum(_bstr_t("Win32_ComputerSystem"), 
		WBEM_FLAG_DEEP, 0, &pEnum);
	if (FAILED(hr))
		PostError(hr, IDS_COMPUTERGET);

	ULONG ulReturned;
	IWbemClassObject* pProvider;
	
	while(SUCCEEDED(hr = pEnum->Next(INFINITE, 1, &pProvider, &ulReturned)))
	{
		if (ulReturned == 1) try {

			PrintStringEx(IDS_COMPUTERDETAILS);

			_variant_t vBootupState, vCaption, vCreationClassName, vDescription,
				vDomain, vName, vPrimaryOwnerName, vSystemType, vUserName;

			pProvider->Get(_bstr_t("BootupState"), 0, &vBootupState, NULL, NULL);
			pProvider->Get(_bstr_t("Caption"), 0, &vCaption, NULL, NULL);
			pProvider->Get(_bstr_t("CreationClassName"), 0, &vCreationClassName, NULL, NULL);
			pProvider->Get(_bstr_t("Description"), 0, &vDescription, NULL, NULL);
			pProvider->Get(_bstr_t("Domain"), 0, &vDomain, NULL, NULL);
			pProvider->Get(_bstr_t("Name"), 0, &vName, NULL, NULL);
			pProvider->Get(_bstr_t("PrimaryOwnerName"), 0, &vPrimaryOwnerName, NULL, NULL);
			pProvider->Get(_bstr_t("SystemType"), 0, &vSystemType, NULL, NULL);
			pProvider->Get(_bstr_t("UserName"), 0, &vUserName, NULL, NULL);

			printf("BootupState:\t\t\t%s\n", (char*)(_bstr_t)vBootupState );
			printf("Caption:\t\t\t%s\n", (char*)(_bstr_t)vCaption );
			printf("CreationClassName:\t\t%s\n", (char*)(_bstr_t)vCreationClassName );
			printf("Description:\t\t\t%s\n", (char*)(_bstr_t)vDescription );
			printf("Domain:\t\t\t\t%s\n", (char*)(_bstr_t)vDomain );
			printf("Name:\t\t\t\t%s\n", (char*)(_bstr_t)vName );
			printf("PrimaryOwnerName:\t\t%s\n", (char*)(_bstr_t)vPrimaryOwnerName );
			printf("SystemType:\t\t\t%s\n", (char*)(_bstr_t)vSystemType );
			printf("UserName:\t\t\t%s\n", (char*)(_bstr_t)vUserName );
			
			pProvider->Release();
		}
		catch(_com_error err)
		{
			PostError(err.Error(), IDS_COMPUTERLIST);
		}
		else 
			break;
	};

	pEnum->Release();
	if (FAILED(hr))
		PostError(hr, IDS_COMPUTERENUM);

};

void PostError(HRESULT hr, UINT uContext)
{
	char szAdvice[1024];

	switch(hr)
	{
	case 0x80040154:
		switch(uContext)
		{
		case IDS_COMPUTERLIST:
			LoadString(hInst, ERR_80040154_A, szAdvice, 1024);
			break;
		case IDS_WBEMINIT:
			LoadString(hInst, ERR_80040154_B, szAdvice, 1024);
			break;
		default:
			LoadString(hInst, hr, szAdvice, 1024);
		};
		break;
	case 0x80080005:
		LoadString(hInst, ERR_80080005, szAdvice, 1024);
		break;
	default:
		if (LoadString(hInst, hr, szAdvice, 1024) == 0)
			LoadString(hInst, IDS_NO_ADVICE, szAdvice, 1024);
	};

	char szContext[70];
	LoadString(hInst, uContext, szContext, 70);

	PrintStringEx(IDS_ERROR, szContext, hr, szAdvice);

	exit(1);
};

void PrintHelp()
{
	PrintStringEx(IDS_HELP);
	exit(0);
};

void PrintStringEx(UINT uID, ...)
{
	char szString[1024];
	va_list params;
	va_start(params, uID);

	LoadString(hInst, uID, szString, 1024);
	vprintf(szString, params);
	va_end(params);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\diskperfwbem\dpdetail.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	File:  dpdetail.cpp
//
//	Description:
//		This file implements the DiskPerfDetails() routine which 
//		demonstrates how to enumerate properties for the DiskPerf
//		class and instances.
//
//	Part of :	DiskPerfWbem
//
//  History:	
//
//***************************************************************************

#include <objbase.h>
#include <wbemcli.h>
#include <stdio.h>

char PropListHeader[] =
	"DiskPerf Property Descriptions:\n\n"
	"WMI Data ID\tProperty\tDescription\n"
	"======================================="
	"=======================================\n"
	"";


//==============================================================================
//
//	DiskPerfDetails( IWbemServices * pIWbemServices ) 
//
//==============================================================================
void DiskPerfDetails( IWbemServices * pIWbemServices ) 
{
	HRESULT		hr;
	long		lLower, lUpper, lCount; 
	SAFEARRAY	*psaNames = NULL;
	BSTR		PropName  = NULL;
	VARIANT		pVal;
	ULONG		uReturned;

	IEnumWbemClassObject	*pEnum     = NULL;
	IWbemClassObject		*pPerfInst = NULL;
	IWbemQualifierSet		*pQualSet  = NULL;

	VariantInit( &pVal );

	// Alloc class name string for DiskPerf
	BSTR PerfClass = SysAllocString( L"DiskPerf" );

	// Here the object info for the Class - DiskPerf is retrieved and displayed

	// Collect object information for PerfClass
    if ( ( pIWbemServices->GetObject( PerfClass,
	                                  0L,
	                                  NULL,
	                                  &pPerfInst,
                                      NULL ) ) == WBEM_NO_ERROR )
	{
		// show the property description list header
		printf( PropListHeader );

		// Load up a safearray of property names
		if ( ( pPerfInst->GetNames( NULL,
		                            WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY,
		                            NULL, 
		                            &psaNames ) ) == WBEM_NO_ERROR )
		{
			// Get the upper and lower bounds of the Names array
			if ( ( hr = SafeArrayGetLBound( psaNames, 1, &lLower ) ) == S_OK ) 
			{
				hr = SafeArrayGetUBound( psaNames, 1, &lUpper );
			}

			if ( hr != S_OK ) 
			{
				printf( "Problem with property name array.\n" );
			}
			else
			{
				BSTR WmiQual  = SysAllocString( L"WmiDataId" );
				BSTR DescQual = SysAllocString( L"Description" );
				UINT uWmiId;

				for ( lCount = lLower; lCount <= lUpper; lCount++ ) 
				{
					// get the property name for this element
					if ( ( SafeArrayGetElement( psaNames, 
					                            &lCount, 
					                            &PropName)) == S_OK )
					{
						if ( ( pPerfInst->GetPropertyQualifierSet( PropName, &pQualSet ) ) == WBEM_NO_ERROR ) 
						{
							// check to see if the property is a WMI data Item and save its description
							// these are the DiskPerf counters
							if ( ( pQualSet->Get( WmiQual, 0L, &pVal, NULL ) ) == WBEM_NO_ERROR )
							{
								uWmiId = pVal.lVal;

								VariantClear( &pVal );
								if ( ( pQualSet->Get( DescQual, 0L, &pVal, NULL ) ) == WBEM_NO_ERROR )
								{
									wprintf( L"( %d )\t\t%s\t%s\n", uWmiId, PropName, pVal.bstrVal );
									VariantClear( &pVal );
								}
							}
							else
							{
								// knock out the properties I want to get explicitly
								wcscpy( PropName, L"" );
								SafeArrayPutElement( psaNames, &lCount, PropName );
							}
							if ( pQualSet )
							{
								pQualSet->Release( ); 
								pQualSet = NULL;
							}
						}
						SysFreeString( PropName );
					}
				}
				SysFreeString( WmiQual );
				SysFreeString( DescQual );
			}
		}
	}

	// Now that the object info is displayed, go get the values for all the
	// partition instances

	// Create enumerator for all partition instances
    hr = pIWbemServices->CreateInstanceEnum( PerfClass,
	                                         WBEM_FLAG_SHALLOW,
	                                         NULL,
	                                         &pEnum );

	if ( hr == WBEM_NO_ERROR )
	{
        while ( pEnum->Next( INFINITE,
		                     1,
                             &pPerfInst,
                             &uReturned ) == WBEM_NO_ERROR )
		{
			// Explicitly get the properties of InstanceName and Active state
			PropName = SysAllocString( L"InstanceName" );
			if ( ( pPerfInst->Get( PropName, 
			                       0L, 
			                       &pVal, 
			                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				wprintf( L"\n%s\n", pVal.bstrVal );
				VariantClear( &pVal );
			}

			PropName = wcscpy( PropName, L"Active" );
			if ( ( pPerfInst->Get( PropName, 
			                       0L, 
			                       &pVal, 
			                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				wprintf( L"\t%s\t\t= %s\n", PropName, pVal.boolVal ? L"TRUE" : L"FALSE" );
				VariantClear( &pVal );
			}
			SysFreeString( PropName );
			PropName = NULL;

			// Iterate through the properties again getting values only for WmiData items
			for ( lCount = lLower; lCount <= lUpper; lCount++ ) 
			{
				// get the property name for this element
				if ( ( SafeArrayGetElement( psaNames, 
				                            &lCount, 
				                            &PropName ) ) == WBEM_NO_ERROR )
				{
					// Get the value for the property.
					if ( ( pPerfInst->Get( PropName, 
					                       0L, 
					                       &pVal, 
					                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
					{
						if ( pVal.vt == VT_I4 )
						{
							wprintf( L"\t%s\t= %d\n", PropName, pVal.lVal );
						}
						else if ( pVal.vt == VT_BSTR )
						{
							wprintf( L"\t%s\t= %s\n", PropName, pVal.bstrVal );
						}
						else
						{
							wprintf( L"\t%s\t= NULL\n", PropName );
						}
						VariantClear( &pVal );
					}
				}
			}
			if ( pPerfInst )
			{ 
				pPerfInst->Release( );
				pPerfInst = NULL;
			}
		}
		pEnum->Release( );
	}
	else
	{
		printf( "Can't enumerate DiskPerf instances!\n" );
	}

	if ( psaNames )
	{
		SafeArrayDestroy( psaNames );
	}
	if ( PerfClass )
	{
		SysFreeString( PerfClass );
	}
}


#if 0
// This is useful for formatting unknown property values.

// **************************************************************************
//
//	ValueToString()
//
// Description:
//		Converts a variant to a displayable string.
//
// Parameters:
//		pValue (in) - variant to be converted.
//		pbuf (out) - ptr to receive displayable string.
//
// Returns:
//		Same as pbuf.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop  (this size stolen from cvt.h in c runtime library) */

LPWSTR ValueToString(VARIANT *pValue, WCHAR **pbuf)
{
   DWORD iNeed = 0;
   DWORD iVSize = 0;
   DWORD iCurBufSize = 0;

   WCHAR *vbuf = NULL;
   WCHAR *buf = NULL;


   switch (pValue->vt) 
   {

   case VT_NULL: 
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<null>");
         break;

   case VT_BOOL: {
         VARIANT_BOOL b = pValue->boolVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);

         if (!b) {
            wcscpy(buf, L"FALSE");
         } else {
            wcscpy(buf, L"TRUE");
         }
         break;
      }

   case VT_UI1: {
         BYTE b = pValue->bVal;
	      buf = (WCHAR *)malloc(BLOCKSIZE);
         if (b >= 32) {
            swprintf(buf, L"'%c' (%d, 0x%X)", b, b, b);
         } else {
            swprintf(buf, L"%d (0x%X)", b, b);
         }
         break;
      }

   case VT_I2: {
         SHORT i = pValue->iVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", i, i);
         break;
      }

   case VT_I4: {
         LONG l = pValue->lVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", l, l);
         break;
      }

   case VT_R4: {
         float f = pValue->fltVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", f);
         break;
      }

   case VT_R8: {
         double d = pValue->dblVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", d);
         break;
      }

   case VT_BSTR: {
		 LPWSTR pWStr = pValue->bstrVal;
		 buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
	     swprintf(buf, L"%wS", pWStr);
		 break;
		}

	// the sample GUI is too simple to make it necessary to display
	// these 'complicated' types--so ignore them.
   case VT_DISPATCH:  // Currently only used for embedded objects
   case VT_BOOL|VT_ARRAY: 
   case VT_UI1|VT_ARRAY: 
   case VT_I2|VT_ARRAY: 
   case VT_I4|VT_ARRAY: 
   case VT_R4|VT_ARRAY: 
   case VT_R8|VT_ARRAY: 
   case VT_BSTR|VT_ARRAY: 
   case VT_DISPATCH | VT_ARRAY: 
         break;

   default:
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<conversion error>");

   }

   *pbuf = buf;   
   return buf;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdump\wbemdump.h ===
// **************************************************************************

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
// File:  wbemdump.h
//
// **************************************************************************
#pragma once

// Generic class to be used as the sink to wbem's async functions.  Note that
// the constructor starts with a refcount of 1, so the instance created with NEW
// must be Released.  This release will delete the object.  Also note that this
// class doesn't do anything with the objects it receives.  It is meant to be
// overridden with methods that actually process the items.
class 
__declspec(uuid("995C5E57-BC79-42c2-93DD-1A2A1693A73A")) 
QuerySink : public IWbemObjectSink
{
protected:
    LONG m_lRef;
    HRESULT m_hResult;
    HANDLE m_hDone;

public:
    QuerySink();
   ~QuerySink();

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();        
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ LONG lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray
            )  { UNREFERENCED(apObjArray); UNREFERENCED(lObjectCount); return WBEM_E_FAILED; }
        
    virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ LONG lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
            );

    HANDLE GetEvent() { return m_hDone; }
    HRESULT GetResult() { return m_hResult; }
};

// Overrides the Indicate method of QuerySink to process the received instances.
class 
__declspec(uuid("3BFFE942-449C-416c-8D88-D84BAE2C4B79")) 
InstanceQuerySink : public QuerySink
{
protected:
    IWbemServicesPtr m_pIWbemServices;
    DWORD m_dwCount;
    LPCWSTR m_pwszClassName;
    bool m_bFirst;

public:
    InstanceQuerySink(IWbemServices *pIWbemServices, LPCWSTR pwszClassName);
   ~InstanceQuerySink();

    virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ LONG lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray
            );
        
    DWORD GetCount() { return m_dwCount; }
};

// Overrides the Indicate method of QuerySink to process the received classes
class 
__declspec(uuid("ED7F93C9-00E4-4cdd-B1A5-34CF14772D42")) 
ClassQuerySink : public QuerySink
{
protected:
    IWbemServicesPtr m_pIWbemServices;

public:
    ClassQuerySink(IWbemServices *pIWbemServices);
   ~ClassQuerySink();

    virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ LONG lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray
            );
        
};

// Overrides the Set method of QuerySink to process the IWbemServices pointer

_COM_SMARTPTR_TYPEDEF(ClassQuerySink, __uuidof(ClassQuerySink));
_COM_SMARTPTR_TYPEDEF(InstanceQuerySink, __uuidof(InstanceQuerySink));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\diskperfwbem\dpwbem.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	File:  dpwbem.cpp
//
//	Description:
//		Connects to the WMI server and calls DiskPerfDetails( ) to
//		retrieve partition properties.
//
//	Part of :	DiskPerfWbem
//
//  History:	
//
//***************************************************************************


#include <objbase.h>
#include <wbemcli.h>
#include <lmcons.h>
#include <stdio.h>


void			DiskPerfDetails( IWbemServices * pIWbemServices );
BOOL			InitSecurity( void );
DWORD WINAPI	WaitThread( HANDLE hWait );


//==============================================================================
//	main( )
//==============================================================================
int main( int argc, char **argv )
{
	HRESULT	hr;
	DWORD	ThreadId;
	HANDLE	hWait;
	TCHAR	szSysName[UNCLEN + 3];

	IWbemLocator	*pIWbemLocator  = NULL;
	IWbemServices	*pIWbemServices = NULL;

	if ( !SUCCEEDED( CoInitialize( NULL ) ) && !InitSecurity( ) ) 
	{
		printf( "COM stuff is hosed!\r\n" );

		return 0;
	}

	// Create an instance of the WbemLocator interface.
	if ( CoCreateInstance( CLSID_WbemLocator,
	                       NULL,
	                       CLSCTX_INPROC_SERVER,
	                       IID_IWbemLocator,
	                       (LPVOID *) &pIWbemLocator) == S_OK )
	{
		// setup BSTRs for namespace and authentication
				
		BSTR pNamespace = SysAllocStringLen( NULL, UNCLEN + sizeof( "\\root\\WMI" ) + 3 );
		BSTR pUserName  = NULL;
		BSTR pPassWord  = NULL;
		BSTR pDomain    = NULL;

		// format namespace and security strings
		if ( argc < 2 )
		{
			DWORD dwLen = sizeof( szSysName );

			wcscpy( pNamespace, L"\\\\.\\root\\WMI" );
			szSysName[0] = '\\';
			szSysName[1] = '\\';
			GetComputerName( szSysName + 2, &dwLen );
		}
		else
		{
			strcpy( szSysName, argv[1] );
			MultiByteToWideChar( CP_ACP, NULL, szSysName, UNCLEN + 3, pNamespace, UNCLEN + 3 );
			if ( argc > 3 )
			{
				if ( ( pUserName  = SysAllocStringLen( NULL, UNLEN + 1 ) ) )
				{
					MultiByteToWideChar( CP_ACP, NULL, argv[2], UNLEN, pUserName, UNLEN );
				}
				if ( ( pPassWord  = SysAllocStringLen( NULL, PWLEN + 1 ) ) )
				{
					MultiByteToWideChar( CP_ACP, NULL, argv[3], PWLEN, pPassWord, PWLEN );
				}
		
				if ( argc > 4 )
				{
					if ( ( pDomain = SysAllocStringLen( NULL, DNLEN + 1 ) ) )
					{
						MultiByteToWideChar( CP_ACP, NULL, argv[4], DNLEN, pDomain, DNLEN );
					}
				}
			}
			wcscat( pNamespace, L"\\root\\WMI" );
		}

		// Display connect message and start wait feedback thread
		printf( "Connecting to %s WMI server at ", szSysName );
		wprintf( L"%s...", pNamespace );

		// make a wait event and kick off wait thread
		hWait = CreateEvent( NULL, TRUE, FALSE, NULL );
		CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) WaitThread, hWait, 0, &ThreadId );

		// connect and get the IWbemServices pointer
		hr = pIWbemLocator->ConnectServer( pNamespace,
		                                   pUserName,
		                                   pPassWord,
		                                   0L,
		                                   0L,
		                                   pDomain,
		                                   NULL,
		                                   &pIWbemServices );

		// kill wait feedback thread
		SetEvent( hWait );
		CloseHandle( hWait );

		// See what WBEM/WMI says about DiskPerf
		if ( hr == WBEM_NO_ERROR )
		{	
			printf( "\nCool!  Connected with %s\n", szSysName );

			// Switch the security level to IMPERSONATE so that provider(s)
			// will grant access to system-level objects, and so that
			// CALL authorization will be used.
			CoSetProxyBlanket( pIWbemServices,	// proxy
				RPC_C_AUTHN_WINNT,				// authentication service
				RPC_C_AUTHZ_NONE, 				// authorization service
				NULL,							// server principle name
				RPC_C_AUTHN_LEVEL_CALL,			// authentication level
				RPC_C_IMP_LEVEL_IMPERSONATE,	// impersonation level
				NULL,							// identity of the client
				EOAC_NONE );					// capability flags

			DiskPerfDetails( pIWbemServices );
		}
		else
		{	
			printf( "\nBummer, failed to connect with %s, Error: 0x%8lX\n", szSysName, hr );
		}

		if ( pIWbemServices )
		{
			pIWbemServices->Release( );
		}

		// free up connect BSTRs
		if( pNamespace ) 
		{
			SysFreeString( pNamespace );
		}
		if( pUserName ) 
		{
			SysFreeString( pUserName );
		}
		if( pPassWord ) 
		{
			SysFreeString( pPassWord );
		}
		if( pDomain ) 
		{
			SysFreeString( pDomain );
		}

		if ( pIWbemLocator )
		{ 
			pIWbemLocator->Release( ); 
		}
	}
	else
	{	
		printf( "WMI services not present or unavailable!\n" );
	}

	CoUninitialize( );

	return 0;
}


//==============================================================================
//	WaitThread( HANDLE hWait )
//==============================================================================
DWORD WINAPI WaitThread( HANDLE hWait )
{
	while ( WaitForSingleObject( hWait, 300 ) == WAIT_TIMEOUT )
	{
		printf(".");
	}
	printf("\n");

	return 0;
}


//==============================================================================
//	InitSecurity( void )
//	Initialize COM security for DCOM services.
//==============================================================================
BOOL InitSecurity( void )
{
	// Adjust the security to allow client impersonation.
	HRESULT hres = CoInitializeSecurity
		(NULL, -1, NULL, NULL, 
		RPC_C_AUTHN_LEVEL_NONE, 
		RPC_C_IMP_LEVEL_IMPERSONATE, 
		NULL, 0, 0);

	return SUCCEEDED( hres );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\cimomevent.cpp ===
// cimomevent.cpp: implementation of the CCIMOMEvent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mca.h"
#include "cimomevent.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCIMOMEvent::CCIMOMEvent()
{

}

CCIMOMEvent::~CCIMOMEvent()
{

}

HRESULT CCIMOMEvent::PopulateObject(IWbemClassObject *pObj, BSTR bstrType)
{
	HRESULT hr;
	VARIANT v;
	IDispatch *pDisp = NULL;
	IWbemClassObject *tgtInst = NULL;
	IWbemClassObject *tgtEvent = NULL;

	VariantInit(&v);

	m_bstrType = SysAllocString(bstrType);

	if (SUCCEEDED(hr = pObj->Get(L"TheEvent", 0L, &v, NULL, NULL))) 
	{
	// Get the Event
		pDisp = (IDispatch *)V_DISPATCH(&v);
		pDisp->AddRef();

		VariantClear(&v);

	// Do ServerNamespace
		hr = pObj->Get(L"ServerNamespace", 0L, &v, NULL, NULL);
		m_bstrServerNamespace = SysAllocString(V_BSTR(&v));

		VariantClear(&v);

	// Do Time
		hr = pObj->Get(L"TimeOfIncident", 0L, &v, NULL, NULL);
		m_bstrTime = SysAllocString(V_BSTR(&v));

		VariantClear(&v);

		if(SUCCEEDED(pDisp->QueryInterface(IID_IWbemClassObject,
			(void **)&tgtInst)))
		{
			pDisp->Release();

			BSTR bstrTarget = NULL;

		// Do the EventType
			hr = tgtInst->Get(L"__CLASS", 0L, &v, NULL, NULL);
			m_bstrEvent = SysAllocString(V_BSTR(&v));

		// Decide whether to get TargetInstance or TargetClass
			if(wcscmp(L"__InstanceModificationEvent", V_BSTR(&v)) == 0 ||
			   wcscmp(L"__InstanceCreationEvent", V_BSTR(&v)) == 0 ||
			   wcscmp(L"__InstanceDeletionEvent", V_BSTR(&v)) == 0)
				bstrTarget = SysAllocString(L"TargetInstance");
			else if(wcscmp(L"__ClassModificationEvent", V_BSTR(&v)) == 0 ||
			   wcscmp(L"__ClassCreationEvent", V_BSTR(&v)) == 0 ||
			   wcscmp(L"__ClassDeletionEvent", V_BSTR(&v)) == 0)
				bstrTarget = SysAllocString(L"TargetClass");
			else
				AfxMessageBox(_T("Unknown Event Type!\n"));

			VariantClear(&v);

			if((bstrTarget != NULL) && SUCCEEDED(hr = tgtInst->Get(bstrTarget,
				0, &v, NULL, NULL))) 
			{
				pDisp = (IDispatch *)V_DISPATCH(&v);
				pDisp->AddRef();

				VariantClear(&v);

				if(SUCCEEDED(pDisp->QueryInterface(IID_IWbemClassObject,
					(void **)&tgtEvent)))
				{
					pDisp->Release();

					if ((hr = tgtEvent->Get(L"__RELPATH", 0L, &v,
						NULL, NULL) == S_OK))
					{
						m_bstrName = SysAllocString(V_BSTR(&v));

						VariantClear(&v);

						tgtEvent->Release();
					}
					else
						TRACE(_T("* Get() Item failed\n"));
				}
				else
					TRACE(_T("* QI() failed\n"));
			}
			else
			{
				TRACE(_T("* Get() tgtInst failed\n"));
			// We'll use the event rather than the target
				m_bstrName = SysAllocString(m_bstrEvent);
			}
		}
		else
			TRACE(_T("* QI() failed\n"));
	}
	else
		TRACE(_T("* Get() TheEvent failed\n"));

	return hr;
}

HRESULT CCIMOMEvent::Publish(void *pDlg)
{
	HRESULT hr;
	CString clMyBuff;
	CMcaDlg *pTheDlg = (CMcaDlg *)pDlg;

	// compose a string for the listbox.
	clMyBuff = _T("[");
	clMyBuff += m_bstrTime;
	clMyBuff += _T("]  {");
	clMyBuff += m_bstrType;
	clMyBuff += _T("}");

	pTheDlg->BroadcastEvent(m_bstrServerNamespace, m_bstrName, &clMyBuff,
							(void *)this);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\cimomevent.h ===
// cimomevent.h: interface for the CCIMOMEvent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CIMOMEVENT_H__F2485592_98F7_11D1_AA0A_0060081EBBAD__INCLUDED_)
#define AFX_CIMOMEVENT_H__F2485592_98F7_11D1_AA0A_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CCIMOMEvent  
{
public:
	CCIMOMEvent();
	virtual ~CCIMOMEvent();

	BSTR m_bstrName;	// The name is the name of the Target
	BSTR m_bstrType;	// The type is the IncidentType
	BSTR m_bstrEvent;	// The event is the type of event
	BSTR m_bstrServerNamespace;	// The servernamespace is the location
								// the event origionated from
	BSTR m_bstrTime;	// The time is the time from the Smpl_Incident

	HRESULT PopulateObject(IWbemClassObject *pObj, BSTR bstrType);
	HRESULT Publish(void *pDlg);
};

#endif // !defined(AFX_CIMOMEVENT_H__F2485592_98F7_11D1_AA0A_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\consumer.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef _CONSUMER_H_INCLUDED_
#define _CONSUMER_H_INCLUDED_

#include <wbemidl.h>
#include "mca.h"

class CConsumer : public IWbemUnboundObjectSink
{
public:
	CConsumer(CListBox	*pOutputList, CMcaApp *pTheApp);
	~CConsumer();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD(IndicateToConsumer)(IWbemClassObject *pLogicalConsumer,
									long lNumObjects,
									IWbemClassObject **ppObjects);

private:
	DWORD m_cRef;
//	LPCTSTR ErrorString(HRESULT hRes);
	LPCTSTR HandleRegistryEvent(IWbemClassObject *pObj, BSTR bstrType);
	LPCTSTR HandleSNMPEvent(IWbemClassObject *pObj, BSTR bstrType);
	LPCTSTR HandleWMIEvent(IWbemClassObject *pObj, BSTR bstrType);

	CListBox *m_pOutputList;
	CMcaApp *m_pParent;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\extrinsicevent.cpp ===
// extrinsicevent.cpp: implementation of the CExtrinsicEvent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mca.h"
#include "extrinsicevent.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CExtrinsicEvent::CExtrinsicEvent()
{

}

CExtrinsicEvent::~CExtrinsicEvent()
{

}

HRESULT CExtrinsicEvent::PopulateObject(IWbemClassObject *pObj, BSTR bstrType)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CExtrinsicEvent::Publish(void *pDlg)
{
	HRESULT hr = S_OK;
	CString clMyBuff;
	CMcaDlg *pTheDlg = (CMcaDlg *)pDlg;

	// compose a string for the listbox.
	clMyBuff = _T("[");
	clMyBuff += m_bstrTime;
	clMyBuff += _T("]  {");
	clMyBuff += m_bstrType;
	clMyBuff += _T("}");

	pTheDlg->BroadcastEvent(m_bstrServerNamespace, m_bstrTitle, &clMyBuff,
							(void *)this);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\consumer.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "consumer.h"
#include "cimomevent.h"
#include "extrinsicevent.h"
#include <objbase.h>

CConsumer::CConsumer(CListBox	*pOutputList, CMcaApp *pTheApp)
{
	m_pParent = pTheApp;
	m_cRef = 0;
	m_pOutputList = pOutputList;
}

CConsumer::~CConsumer()
{
}

STDMETHODIMP CConsumer::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConsumer::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConsumer::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CConsumer::IndicateToConsumer(IWbemClassObject *pLogicalConsumer,
											long lNumObjects,
											IWbemClassObject **ppObjects)
{
	HRESULT  hRes;
	VARIANT v;

	VariantInit(&v);

	// walk though the classObjects...
	for (int i = 0; i < lNumObjects; i++)
	{
		hRes = pLogicalConsumer->Get(SysAllocString(L"IncidentType"),
									 0, &v, NULL, NULL);

		if((wcscmp(L"registryKeyChange", V_BSTR(&v)) == 0) ||
			(wcscmp(L"registryKeyChange", V_BSTR(&v)) == 0) ||
			(wcscmp(L"registryKeyChange", V_BSTR(&v)) == 0))
		{
			CExtrinsicEvent *pEvent = new CExtrinsicEvent();
			//pEvent->PopulateObject(ppObjects[i], V_BSTR(&v));
			//pEvent->Publish((void *)m_dlg);
		}
		else
		{
			CCIMOMEvent *pEvent = new CCIMOMEvent();
			pEvent->PopulateObject(ppObjects[i], V_BSTR(&v));
			pEvent->Publish((void *)m_pParent->m_dlg);
		}
	}

	VariantClear(&v);

	return WBEM_NO_ERROR;
}

LPCTSTR CConsumer::HandleRegistryEvent(IWbemClassObject *pObj, BSTR bstrType)
{
	HRESULT hr;
	CString csReturn;
	VARIANT v;

	VariantInit(&v);
	csReturn.Empty();

	if(wcscmp(L"RegistryKeyChangeEvent", bstrType) == 0)
	{
		if(SUCCEEDED(hr = pObj->Get(L"KeyPath", 0L, &v, NULL, NULL)))
		{
			csReturn = " -RegistryKeyChange for ";
			csReturn += V_BSTR(&v);
		}
		else
			TRACE(_T("* Get(KeyPath) Item failed %s\n"),
				m_pParent->ErrorString(hr));
	}
	else if(wcscmp(L"RegistryTreeChangeEvent", bstrType) == 0)
	{
		if(SUCCEEDED(hr = pObj->Get(L"RootPath", 0L, &v, NULL, NULL)))
		{
			csReturn = " -RegistryTreeChange for ";
			csReturn += V_BSTR(&v);
		}
		else
			TRACE(_T("* Get(RootPath) Item failed %s\n"),
				m_pParent->ErrorString(hr));
	}
	else if(wcscmp(L"RegistryValueChangeEvent", bstrType) == 0)
	{
		if(SUCCEEDED(hr = pObj->Get(L"KeyPath", 0L, &v, NULL, NULL)))
		{
			csReturn = " -RegistryValueChange for ";
			csReturn += V_BSTR(&v);

			VariantClear(&v);
			if(SUCCEEDED(hr = pObj->Get(L"ValueName", 0L, &v, NULL, NULL)))
			{
				csReturn += " Value: ";
				csReturn += V_BSTR(&v);
			}
			else
				TRACE(_T("* Get(ValueName) Item failed %s\n"), 
					m_pParent->ErrorString(hr));
		}
		else
			TRACE(_T("* Get(KeyPath) Item failed %s\n"), 
				m_pParent->ErrorString(hr));
	}
	else
		TRACE(_T("* Error: Non-registry event sent to HandleRegistryEvent()\n"));

	return csReturn;
}

LPCTSTR CConsumer::HandleSNMPEvent(IWbemClassObject *pObj, BSTR bstrType)
{
	CString csReturn;
	VARIANT v;

	VariantInit(&v);
	csReturn.Empty();

	return csReturn;
}

LPCTSTR CConsumer::HandleWMIEvent(IWbemClassObject *pObj, BSTR bstrType)
{
	CString csReturn;
	VARIANT v;

	VariantInit(&v);
	csReturn.Empty();

	return csReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\factory.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <wbemidl.h>
#include "mca.h"

class CConsumerFactory : public IClassFactory
{
public:

	CConsumerFactory(CListBox	*pOutputList,/* CTreeCtrl *pMapView,*/
					 CMcaApp *pTheApp);
	virtual ~CConsumerFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD_(SCODE, CreateInstance)(IUnknown * pUnkOuter, 
									REFIID riid, 
									void ** ppvObject);

    STDMETHOD_(SCODE, LockServer)(BOOL fLock);

private:
	LONG m_cRef;
	CListBox	*m_pOutputList;
//	CTreeCtrl *m_pMapView;
	CMcaApp * m_pParent;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\extrinsicevent.h ===
// extrinsicevent.h: interface for the CExtrinsicEvent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EXTRINSICEVENT_H__F2485593_98F7_11D1_AA0A_0060081EBBAD__INCLUDED_)
#define AFX_EXTRINSICEVENT_H__F2485593_98F7_11D1_AA0A_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CExtrinsicEvent  
{
public:
	CExtrinsicEvent();
	virtual ~CExtrinsicEvent();

	BSTR m_bstrTitle;	// The title is the name used to reference the event
	BSTR m_bstrType;	// The type is the IncidentType
	BSTR m_bstrEvent;	// The event is the type of event
	BSTR m_bstrServerNamespace;	// The servernamespace is the location
								// the event origionated from
	BSTR m_bstrTime;	// The time is the time from the Smpl_Incident

	HRESULT PopulateObject(IWbemClassObject *pObj, BSTR bstrType);
	HRESULT Publish(void *pDlg);
};

#endif // !defined(AFX_EXTRINSICEVENT_H__F2485593_98F7_11D1_AA0A_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\factory.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	Part of :	WMI Tutorial.
//
//  History:	
//
//***************************************************************************

#include "stdafx.h"
#include "factory.h"
#include "consumer.h"

CConsumerFactory::CConsumerFactory(CListBox	*pOutputList, CMcaApp *pTheApp)
{
	m_pParent = pTheApp;
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CConsumerFactory::~CConsumerFactory()
{
}

//IUnknown methods

STDMETHODIMP CConsumerFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CConsumerFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CConsumerFactory::Release(void)
{
    int lNewRef = InterlockedDecrement(&m_cRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConsumerFactory::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CConsumerFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;
    CConsumer *pConsumer = NULL;

    if (pUnkOuter)
        return E_FAIL;

    pConsumer = new CConsumer(m_pOutputList, m_pParent);

    if (pConsumer == NULL)
		return E_FAIL;

    if (pConsumer)
        hr = pConsumer->QueryInterface(riid, ppv);
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConsumerFactory::LockServer
//
//  Synopsis:
//
//  Arguments:  [fLock]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP CConsumerFactory::LockServer(BOOL fLock)
{
    if (fLock)
        m_cRef++;
    else
        m_cRef--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\hmmv.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "hmmv.h"

/////////////////////////////////////////////////////////////////////////////
// CHmmv

IMPLEMENT_DYNCREATE(CHmmv, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CHmmv properties

VARIANT CHmmv::GetObjectPath()
{
	VARIANT result;
	GetProperty(0x2, VT_VARIANT, (void*)&result);
	return result;
}

void CHmmv::SetObjectPath(const VARIANT& propVal)
{
	SetProperty(0x2, VT_VARIANT, &propVal);
}

SCODE CHmmv::GetSc()
{
	SCODE result;
	GetProperty(0x1, VT_ERROR, (void*)&result);
	return result;
}

void CHmmv::SetSc(SCODE propVal)
{
	SetProperty(0x1, VT_ERROR, propVal);
}

CString CHmmv::GetNameSpace()
{
	CString result;
	GetProperty(0x3, VT_BSTR, (void*)&result);
	return result;
}

void CHmmv::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x3, VT_BSTR, propVal);
}

long CHmmv::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CHmmv operations

void CHmmv::ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szTitle, &varPathArray);
}

void CHmmv::QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pLabel, pQueryType, pQuery, pClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\msaregdialog.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#if !defined(AFX_MSAREGDIALOG_H__77B04DD2_A6FD_11D1_AA2D_0060081EBBAD__INCLUDED_)
#define AFX_MSAREGDIALOG_H__77B04DD2_A6FD_11D1_AA2D_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MSARegDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMSARegDialog dialog

class CMSARegDialog : public CDialog
{
// Construction
public:
	CMSARegDialog(CWnd* pParent = NULL, IWbemServices *pNamespace = NULL,
		IWbemLocator *pLocator = NULL);
	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMSARegDialog)
	enum { IDD = IDD_MSA_REG_DIALOG };
	CEdit	m_Edit;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSARegDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CMcaDlg *m_pParent;
	IWbemServices *m_pNamespace;
	IWbemLocator *m_pLocator;

	// Generated message map functions
	//{{AFX_MSG(CMSARegDialog)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSAREGDIALOG_H__77B04DD2_A6FD_11D1_AA2D_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\mcadlg.h ===
// mcadlg.h : header file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{AFX_INCLUDES()
#include "mschart.h"
#include "navigator.h"
#include "hmmv.h"
#include "webbrowser.h"
#include "security.h"
//}}AFX_INCLUDES

#if !defined(AFX_MCADLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
#define AFX_MCADLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_

#include "sinkobject.h"
//#include "methodsink.h"
#include "resource.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
//Globals

struct ListItem
{
	BSTR server;
	BSTR relpath;
	HTREEITEM handle;
	int icon;
};

struct NamespaceItem
{
	BSTR bstrNamespace;
	IWbemServices *pNamespace;
};

struct TimerItem
{
	int iPos;
	double dTimeStamp;
};

// Uhoh, it's a global :-)
extern bool g_bDemoRunning;

/////////////////////////////////////////////////////////////////////////////
// CMcaDlg dialog

class CMcaDlg : public CDialog
{
// Construction
public:
	// standard constructor
	CMcaDlg(CWnd* pParent = NULL, BSTR wcNamespace = L"\\\\.\\root\\sampler");
	void BroadcastEvent(BSTR bstrServ, BSTR bstrPath, CString *clTheBuff, void *pEvent);
	void AddToNamespaceList(BSTR bstrNamespace, IWbemServices *pNewNamespace);
	IWbemServices * ConnectNamespace(WCHAR * wcNamespace, WCHAR *wcUser);
	IWbemServices * CheckNamespace(BSTR wcItemNS);
	int GetNamespaceCount(void);
	NamespaceItem * GetNamespaceItem(int iPos);
	void AddToCancelList(void *pObj);
	LPCTSTR ErrorString(HRESULT hRes);
	HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, LPWSTR pPassword);
	
	IWbemServices *m_pNamespace;
	IWbemLocator *m_pLocator;
	BSTR m_wcNamespace;

// Dialog Data
	//{{AFX_DATA(CMcaDlg)
	enum { IDD = IDD_MCA_DIALOG };
	CButton	m_OKButton;
	CButton	m_DemoButton;
	CStatic	m_IncidStatic;
	CStatic	m_ActiveStatic;
	CListBox	m_outputList;
	CMSChart	m_Graph;
	CWebBrowser	m_Browser;
	CSecurity	m_Security;
	CNavigator	m_Navigator;
	CHmmv	m_Viewer;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMcaDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;
	
	unsigned char m_tcHtmlLocation[200];

	CPtrList m_NamespaceList;	// List of the current namespace pointers
	CPtrList m_TimerList;	// List to connect incidents with the graph
	CPtrList m_EventList;	// List of the events
	CPtrList m_CancelList;	// List of the objects that need to be canceled

	// State Variables
	bool m_bPolling;
	int m_iCount;
	int m_iPollCount;
	double m_dTimeStamp;
	bool m_bChart;
	int m_iSelected;
	bool m_bShowViewer;

	// Demo Variables
	bool m_bDemoLoaded;
	bool m_bStage2;
	bool m_bStage3;

	// Protected Functions
	int GetHTMLLocation(void);
	HRESULT ActivateNotification(void);
	void LoadDemo(void);
	void AddToObjectList(void *pObj);
	SCODE DetermineLoginType(BSTR & AuthArg, BSTR & UserArg, BSTR & Authority,BSTR & User);
	HRESULT SetInterfaceSecurity(IUnknown * pInterface, COAUTHIDENTITY * pauthident);

	
	// Generated message map functions
	//{{AFX_MSG(CMcaDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDblclkOutputlist();
	afx_msg void OnMiFileExit();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	afx_msg void OnPointSelectedMschart1(short FAR* Series, short FAR* DataPoint, short FAR* MouseFlags, short FAR* Cancel);
	afx_msg void OnMiOptQuery();
	afx_msg void OnMiOptNotify();
	afx_msg void OnMiFileRegister();
	afx_msg void OnMiHelpAbout();
	afx_msg void OnSelchangeOutputlist();
	afx_msg void OnDemoButton();
	afx_msg void OnMiOptRundemo();
	afx_msg void OnMiOptLoaddemo();
	afx_msg void OnMiFileMsaReg();
	afx_msg void OnMiOptProps();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnViewObjectNavigatorctrl1(LPCTSTR bstrPath);
	afx_msg void OnViewInstancesNavigatorctrl1(LPCTSTR bstrLabel, const VARIANT FAR& vsapaths);
	afx_msg void OnGetIWbemServicesNavigatorctrl1(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	afx_msg void OnGetIWbemServicesHmmvctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	afx_msg void OnQueryViewInstancesNavigatorctrl1(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
	afx_msg void OnNotifyOpenNameSpaceNavigatorctrl1(LPCTSTR lpcstrNameSpace);
	afx_msg void OnRequestUIActiveHmmvctrl1();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MCADLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\mca.h ===
// mca.h : main header file for the WBEMPERMEVENTS application

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#if !defined(AFX_MCA_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
#define AFX_MCA_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <wbemidl.h>
#include "resource.h"
#include "mcadlg.h"

/////////////////////////////////////////////////////////////////////////////
// CMcaApp:
// See mca.cpp for the implementation of this class
//

class CMcaApp : public CWinApp
{
public:
	CMcaApp();

	CMcaDlg *m_dlg;

	LPCTSTR ErrorString(HRESULT hRes);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMcaApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL


// Implementation

	//{{AFX_MSG(CMcaApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	DWORD m_clsReg;

	HRESULT CreateUser(void);
	void RegisterServer(void);
	void UnregisterServer(void);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MCA_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\mcadlg.cpp ===
// mcadlg.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "mca.h"
#include "mcadlg.h"
//#include "methoddialog.h"
#include "querydialog.h"
#include "regidialog.h"
#include "vcdatagrid.h"
#include "notificationsink.h"
#include "cimomevent.h"
#include "msaregdialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CHART_TIMER 420311

BSTR g_bstrDemoObject = SysAllocString(L"Win32_Service.Name=\"W3SVC\"");

//Turn the demo mode off first
bool g_bDemoRunning = false;

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMcaDlg dialog

CMcaDlg::CMcaDlg(CWnd* pParent, BSTR wcNamespace)
	: CDialog(CMcaDlg::IDD, pParent)
{
	HRESULT hr;

	m_wcNamespace = SysAllocString(wcNamespace);

	m_pLocator = NULL;

	// Create our locator for this session
	if(FAILED(hr = CoCreateInstance(CLSID_WbemLocator, NULL,
		CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void **)&m_pLocator)))
	{
		TRACE(_T("* Unable to create locator: %s\n"), ErrorString(hr));
		AfxMessageBox(_T("Failed to create IWbemLocator object\nNamespace acces will now be an impossibility\n\nPrepare for a crash! :-)"));
	}

	m_iSelected = 0;
	m_bChart = false;

	g_bDemoRunning = false;

//	Create((AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW, LoadCursor(NULL, IDC_CROSS),
//		   (HBRUSH)(GetStockObject(WHITE_BRUSH)), NULL)), );

	//{{AFX_DATA_INIT(CMcaDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMcaDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMcaDlg)
	DDX_Control(pDX, IDOK, m_OKButton);
	DDX_Control(pDX, IDC_DEMO_BUTTON, m_DemoButton);
	DDX_Control(pDX, IDC_INCID_STATIC, m_IncidStatic);
	DDX_Control(pDX, IDC_ACTIVE_STATIC, m_ActiveStatic);
	DDX_Control(pDX, IDC_OUTPUTLIST, m_outputList);
	DDX_Control(pDX, IDC_MSCHART1, m_Graph);
	DDX_Control(pDX, IDC_NAVIGATORCTRL1, m_Navigator);
	DDX_Control(pDX, IDC_HMMVCTRL1, m_Viewer);
	DDX_Control(pDX, IDC_EXPLORER1, m_Browser);
	DDX_Control(pDX, IDC_SECURITYCTRL1, m_Security);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMcaDlg, CDialog)
	//{{AFX_MSG_MAP(CMcaDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_LBN_DBLCLK(IDC_OUTPUTLIST, OnDblclkOutputlist)
	ON_COMMAND(ID_MI_FILE_EXIT, OnMiFileExit)
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_COMMAND(ID_MI_OPT_QUERY, OnMiOptQuery)
	ON_COMMAND(ID_MI_OPT_NOTIFY, OnMiOptNotify)
	ON_COMMAND(ID_MI_FILE_REGISTER, OnMiFileRegister)
	ON_COMMAND(ID_MI_HELP_ABOUT, OnMiHelpAbout)
	ON_LBN_SELCHANGE(IDC_OUTPUTLIST, OnSelchangeOutputlist)
	ON_BN_CLICKED(IDC_DEMO_BUTTON, OnDemoButton)
	ON_COMMAND(ID_MI_OPT_RUNDEMO, OnMiOptRundemo)
	ON_COMMAND(ID_MI_OPT_LOADDEMO, OnMiOptLoaddemo)
	ON_COMMAND(ID_MI_FILE_MSAREG, OnMiFileMsaReg)
	ON_COMMAND(ID_MI_OPT_PROPS, OnMiOptProps)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMcaDlg message handlers

BOOL CMcaDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_pNamespace = CheckNamespace(SysAllocString(m_wcNamespace));

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	HRESULT hr;

	m_bPolling = false;
	m_iCount = 0;
	m_iPollCount = 0;
	m_dTimeStamp = 0;

	SetTimer(CHART_TIMER, 10000, NULL);

	CVcDataGrid dg = m_Graph.GetDataGrid();

	// Initialize the Graph
	for(int i = 1; i <= 50; i++)
		dg.SetData(i, 1, 0, 0);

	m_bDemoLoaded = false;
	m_bShowViewer = true;
	m_bStage2 = false;
	m_bStage3 = false;

	GetHTMLLocation();

	if(FAILED(hr = ActivateNotification()))
	{
		TRACE(_T("* Error Querying Sampler NS: %s\n"), ErrorString(hr));
		AfxMessageBox(_T("Error Setting up notification queries\nStandard events will not be recieved"));
	}

	return TRUE;
}

int CMcaDlg::GetHTMLLocation(void)
{
	int iSuccess = 0;

	TCHAR tcKey[]= _T("Software\\Microsoft\\Sampler");
	TCHAR tcSubKey[] = _T("HTML Location");
    HKEY hKey1;
	DWORD dwRet;
	ULONG lSize = 200;
	LPBYTE lpData = &m_tcHtmlLocation[0];

	// delete the keys under CLSID\[guid] for Consumer
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, tcKey, &hKey1);
    if(dwRet == NOERROR)
    {
        RegQueryValueEx(hKey1, tcSubKey, NULL, NULL, lpData,
			&lSize);
        CloseHandle(hKey1);
    }

	return iSuccess;
}
void CMcaDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
		CDialog::OnSysCommand(nID, lParam);
}

void CMcaDlg::OnPaint() 
{
	if (IsIconic())
	{
	// device context for painting
		CPaintDC dc(this);

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

	// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

	// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
		CDialog::OnPaint();
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMcaDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CMcaDlg::OnDblclkOutputlist() 
{
	int iPos, iSize;
	POSITION pPos;
	CCIMOMEvent *pTheItem;
	char cBuffer[300];
	int iBufSize = 300;
	WCHAR wcBuffer[300];

	// Figure out who got selected and retrieve that Item from
	//  the EventList
	iPos = m_outputList.GetCurSel();
	iSize = m_outputList.GetCount();
	pPos = m_EventList.FindIndex((iSize - iPos - 1));
	void *pTmp = m_EventList.GetAt(pPos);

	//Look at the list text to see what kind of event we're about to get

	pTheItem = (CCIMOMEvent *)pTmp;

	wcscpy(wcBuffer, pTheItem->m_bstrServerNamespace);
	wcscat(wcBuffer, L":");
	wcscat(wcBuffer, pTheItem->m_bstrName);
    
	// Get the item name into a char[]
	WideCharToMultiByte(CP_OEMCP, 0, wcBuffer, (-1), cBuffer, iBufSize, NULL, NULL);

	m_Navigator.SetTreeRoot(cBuffer);

	m_iSelected = iPos;

	// If we're in demo mode, we've got some work to do
	if((g_bDemoRunning) && (0 == wcscmp(pTheItem->m_bstrName, g_bstrDemoObject)))
	{
		CString csPath = m_tcHtmlLocation;
		csPath += "\\dialog3.htm";
		m_Browser.Navigate(csPath, NULL, NULL, NULL, NULL);

		m_bStage3 = true;
	}
}

///////////////////////////////////////////////////////
//    BroadcastEvent                                 //
//---------------------------------------------------//
//  Inserts the root item of the treeview and calls  //
// an associators of {} query to create the remainder//
// of the tree.                                      //
///////////////////////////////////////////////////////
void CMcaDlg::BroadcastEvent(BSTR bstrServ, BSTR bstrPath, CString *clTheBuff,
							 void *pEvent)
{
	// Put this item in the magiclist for future reference
	m_outputList.InsertString(0, *clTheBuff);
	int iSize = m_outputList.GetCount();

	AddToObjectList(pEvent);

	// Create a timer item and add it to the timerlist
	TimerItem *pTheItem = new TimerItem;

	pTheItem->iPos = (iSize - 1);
	pTheItem->dTimeStamp = m_dTimeStamp;

	m_TimerList.AddTail(pTheItem);
	
	// Update the count for the graph pane
	if(!m_bPolling)
		m_iCount++;
	else
		m_iPollCount++;

	// If we're in demo mode, we've got some work to do
	if((g_bDemoRunning) && (0 == wcscmp(bstrPath, g_bstrDemoObject)))
	{
		if(m_bStage3)
			OnDemoButton();
		else
		{
		// Select the item again
			m_outputList.SetSel((-1), FALSE);
			m_outputList.SetSel(m_outputList.FindString((-1), *clTheBuff), TRUE);
			
			m_bDemoLoaded = false;
			m_bStage2 = true;

			CString csPath = m_tcHtmlLocation;
			csPath += "\\dialog2.htm";
			m_Browser.Navigate(csPath, NULL, NULL, NULL, NULL);
		}
		RECT sRect;
		this->GetClientRect(&sRect);
		
		LPARAM lParam = MAKELPARAM(LOWORD((sRect.right - sRect.left)),
								   LOWORD((sRect.bottom - sRect.top)));

		this->PostMessage(WM_SIZE, SIZE_RESTORED, lParam);
	}

}

HRESULT CMcaDlg::ActivateNotification()
{
	HRESULT hr;
	ULONG uReturned;
	VARIANT v;
	WCHAR wcBuffer[200];
	BSTR bstrTheQuery = SysAllocString(L"select * from Smpl_MCARegistration");
	BSTR bstrWQL = SysAllocString(L"WQL");

	VariantInit(&v);

	IWbemServices *pNamespace = NULL;
	IEnumWbemClassObject *pEnum = NULL;
	IWbemClassObject *pObj = NULL;

	pNamespace = CheckNamespace(SysAllocString(L"\\\\.\\root\\sampler"));
	if(pNamespace == NULL)
		return WBEM_E_FAILED;

	if(FAILED(hr = pNamespace->ExecQuery(SysAllocString(L"WQL"),
		SysAllocString(L"select * from Smpl_MCARegistration"), 0, NULL,
		&pEnum)))
		TRACE(_T("* Error Querying Enumerated NS: %s\n"), ErrorString(hr));

	WCHAR wcUser[50];
	char cBuf[50];
	DWORD dwSize = 50;

	GetComputerName(cBuf, &dwSize);
	MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcUser, 50);
	wcscat(wcUser, L"\\sampler");

	SetInterfaceSecurity(pEnum, NULL, SysAllocString(wcUser),
		SysAllocString(L"RelpMas1"));

	//This will eneumerate all the incident types we should register for
	while(S_OK == (hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)))
	{
		if(SUCCEEDED(hr = pObj->Get(SysAllocString(L"IncidentType"), 0, &v,
			NULL, NULL)))
		{
			wcscpy(wcBuffer, L"select * from Smpl_Incident where IncidentType=\"");
			wcscat(wcBuffer, V_BSTR(&v));
			wcscat(wcBuffer, L"\"");

			CNotificationSink *pTheSink = new CNotificationSink(this, V_BSTR(&v));

			AddToCancelList((void *)pTheSink);

			if(FAILED(hr = pNamespace->ExecNotificationQueryAsync(bstrWQL,
				SysAllocString(wcBuffer), 0, NULL, pTheSink)))
				TRACE(_T("* ExecNotification Failed: %s\n"),
					ErrorString(hr));
			else
				TRACE(_T("* ExecNotification Succeeded: %s\n"),
					ErrorString(hr));

			VariantClear(&v);
		}
		else
			TRACE(_T("* Unable to get IncidentType: %s\n"), ErrorString(hr));

		hr = pObj->Release();
		pObj = NULL;
	}

		hr = pEnum->Release();
		pEnum = NULL;

	return WBEM_NO_ERROR;
}

int CMcaDlg::GetNamespaceCount(void)
{
	return m_NamespaceList.GetCount();
}

NamespaceItem * CMcaDlg::GetNamespaceItem(int iPos)
{
	POSITION pPos;
	void *pTmp;

	pPos = m_NamespaceList.FindIndex(iPos);
	pTmp = m_NamespaceList.GetAt(pPos);
	return (NamespaceItem *)pTmp;
}

void CMcaDlg::AddToObjectList(void *pObj)
{
	m_EventList.AddTail(pObj);
}

void CMcaDlg::AddToCancelList(void *pObj)
{
	m_CancelList.AddTail(pObj);
}

///////////////////////////////////////////////////////
//    AddToNamespaceList                             //
//---------------------------------------------------//
//  Adds an item to the Namespace list for later     //
// retreival.  This is to reduce the number of       //
// Namespace pointer requests to a minimum.          //
///////////////////////////////////////////////////////
void CMcaDlg::AddToNamespaceList(BSTR bstrNamespace, IWbemServices *pNewNamespace)
{
	NamespaceItem *pTheItem = new NamespaceItem;

	pTheItem->bstrNamespace = SysAllocString(bstrNamespace);
	pTheItem->pNamespace = pNewNamespace;

	m_NamespaceList.AddTail(pTheItem);
}

///////////////////////////////////////////////////////
//    CheckNamespace                                 //
//---------------------------------------------------//
//  Checks to see if a namespace change is required, //
// and if it is performs the necessary change.       //
///////////////////////////////////////////////////////
IWbemServices * CMcaDlg::CheckNamespace(BSTR wcItemNS)
{
	int iSize;
	POSITION pPos;	
	NamespaceItem *pTheItem;
	BSTR bstrNamespace = SysAllocString(wcItemNS);
	WCHAR *pwcStart = wcItemNS;
	WCHAR *pwcEnd;
	WCHAR wcNewNS[200];
	BSTR bstrUser;
	char cBuffer[200];
	DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
	WCHAR wcTemp[MAX_COMPUTERNAME_LENGTH + 1];
	int iBufSize = 200;

	// Parse the namespace to get the user and get it in a consistent format
	while(*pwcStart == L'\\')
	{	pwcStart++;	}
	if(*pwcStart == L'.')
	{
		GetComputerName(cBuffer, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuffer, (-1),
								 wcTemp, 128);

		pwcStart++;
		wcscpy(wcNewNS, L"\\\\");
		wcscat(wcNewNS, wcTemp);
		wcscat(wcNewNS, pwcStart);
		bstrNamespace = SysAllocString(wcNewNS);

		wcscpy(wcItemNS, wcTemp);
		wcscat(wcItemNS, L"\\sampler");
		bstrUser = SysAllocString(wcItemNS);
	}
	else
	{
		pwcEnd = pwcStart;
		while(*pwcEnd != L'\\')
		{	pwcEnd++;	}
		*pwcEnd = NULL;
		wcscat(pwcStart, L"\\sampler");
		bstrUser = SysAllocString(pwcStart);
	}

	iSize = m_NamespaceList.GetCount();
	for(int iPos = 0; iPos < iSize; iPos++)
	{
		pPos = m_NamespaceList.FindIndex(iPos);
		void *pTmp = m_NamespaceList.GetAt(pPos);
		pTheItem = (NamespaceItem *)pTmp;

		if(0 == wcscmp(bstrNamespace, pTheItem->bstrNamespace))
			return pTheItem->pNamespace;
	}

	IWbemServices *pNamespace = NULL;

	pNamespace = ConnectNamespace(bstrNamespace, bstrUser);

	// If we succeeded add it to the list
	if(pNamespace != NULL)
		AddToNamespaceList(bstrNamespace, pNamespace);

	return pNamespace;

}

///////////////////////////////////////////////////////
//    ConnectNamespace                               //
//---------------------------------------------------//
//  Connects to the specified namespace using default//
// security.                                         //
///////////////////////////////////////////////////////
IWbemServices * CMcaDlg::ConnectNamespace(WCHAR *wcNamespace, WCHAR *wcUser)
{
	HRESULT hr = S_OK;
	IWbemServices *pNamespace = NULL;
	BSTR bstrNamespace = SysAllocString(wcNamespace);
	BSTR bstrUser = SysAllocString(wcUser);
	BSTR bstrPassword = SysAllocString(L"RelpMas1");
	char cBuffer[200];
	int iBufSize = 200;

	if(FAILED(hr = m_pLocator->ConnectServer(bstrNamespace, bstrUser,
		bstrPassword, NULL, 0, NULL, NULL, &pNamespace)))
	{
		WideCharToMultiByte(CP_OEMCP, 0, bstrNamespace, (-1), cBuffer,
			iBufSize, NULL, NULL);
		TRACE(_T("* Unable to connect to Namespace %s: %s\n"),
			cBuffer, ErrorString(hr));
		return NULL;
	}

	WideCharToMultiByte(CP_OEMCP, 0, bstrNamespace, (-1), cBuffer, iBufSize,
		NULL, NULL);
	TRACE(_T("* Connected to Namespace %s: %s\n"), cBuffer, ErrorString(hr));
	
	SetInterfaceSecurity(pNamespace, NULL, bstrUser, bstrPassword);

	return pNamespace;
}

//***************************************************************************
//
//  SCODE DetermineLoginType
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the 
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  ConnType            Returned with the connection type, ie wbem, ntlm
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CMcaDlg::DetermineLoginType(BSTR & AuthArg, BSTR & UserArg,
								  BSTR & Authority,BSTR & User)
{

    // Determine the connection type by examining the Authority string

    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return WBEM_E_INVALID_PARAMETER;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(Authority && wcslen(Authority) > 11) 
    {
        if(pSlashInUser)
            return WBEM_E_INVALID_PARAMETER;

        AuthArg = SysAllocString(Authority + 11);
        if(User) UserArg = SysAllocString(User);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        int iDomLen = pSlashInUser-User;
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);

    return S_OK;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pDomain             Input, domain
//  pUser               Input, user name
//  pPassword           Input, password.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT CMcaDlg::SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority,
									  LPWSTR pUser, LPWSTR pPassword)
{
    
    SCODE sc;
    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
        return SetInterfaceSecurity(pInterface, NULL);

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    
    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL;
    sc = DetermineLoginType(AuthArg, UserArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

    // Fill in the indentity structure

    if(UserArg)
    {
        wcstombs(szUser, UserArg, MAX_PATH);
        authident.UserLength = strlen(szUser);
        authident.User = (LPWSTR)szUser;
    }
    else
    {
        authident.UserLength = 0;
        authident.User = 0;
    }
    if(AuthArg)
    {
        wcstombs(szAuthority, AuthArg, MAX_PATH);
        authident.DomainLength = strlen(szAuthority);
        authident.Domain = (LPWSTR)szAuthority;
    }
    else
    {
        authident.DomainLength = 0;
        authident.Domain = 0;
    }
    if(pPassword)
    {
        wcstombs(szPassword, pPassword, MAX_PATH);
        authident.PasswordLength = strlen(szPassword);
        authident.Password = (LPWSTR)szPassword;
    }
    else
    {
        authident.PasswordLength = 0;
        authident.Password = 0;
    }
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    sc = SetInterfaceSecurity(pInterface, &authident);

    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    return sc;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pauthident          Structure with the identity info already set.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CMcaDlg::SetInterfaceSecurity(IUnknown * pInterface,
									  COAUTHIDENTITY * pauthident)
{

    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    SCODE sc;
    IClientSecurity * pCliSec = NULL;
    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
        return sc;

    sc = pCliSec->SetBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IDENTIFY, 
        pauthident,
        EOAC_NONE);
    pCliSec->Release();
    return sc;
}

void CMcaDlg::OnMiFileExit() 
{
	CDialog::OnOK();
}

void CMcaDlg::OnTimer(UINT nIDEvent) 
{
	if(nIDEvent == CHART_TIMER)
	{
		m_bPolling = true;

		CVcDataGrid dg = m_Graph.GetDataGrid();

		dg.DeleteRows(1, 1);
		dg.InsertRows(50, 1);

		dg.SetData(50, 1, m_iCount, 0);
		dg.SetData(50, 2, m_dTimeStamp, 0);
	
		m_iCount = 0;
		m_dTimeStamp += 1;
		m_bPolling = false;

		m_iCount += m_iPollCount;
		m_iPollCount = 0;
	}

	CDialog::OnTimer(nIDEvent);
}

void CMcaDlg::OnDestroy() 
{
	CDialog::OnDestroy();

	KillTimer(CHART_TIMER);

	void *pTmp;
	IWbemObjectSink *pSinkItem;
	IWbemServices *pSamplerCancelNamespace =
		CheckNamespace(SysAllocString(L"\\\\.\\root\\sampler"));

	if(pSamplerCancelNamespace != NULL)
	{
		// Cleanup Cancel List
		while(!m_CancelList.IsEmpty())
		{
			pTmp = m_CancelList.RemoveTail();
			pSinkItem = (IWbemObjectSink *)pTmp;

			pSamplerCancelNamespace->CancelAsyncCall(pSinkItem);
			pSinkItem->Release();

			delete pSinkItem;
		}
	}

	void *pTheItem;

	// Cleanup Timer List
	while(!m_TimerList.IsEmpty())
	{
		pTheItem = m_TimerList.RemoveTail();
		delete pTheItem;
	}

	// Cleanup Namespace List
	while(!m_NamespaceList.IsEmpty())
	{
		pTheItem = m_NamespaceList.RemoveTail();
		NamespaceItem *pNItem = (NamespaceItem *)pTheItem;

		pNItem->pNamespace->Release();
		delete pNItem;
	}

	// Cleanup Event List
	while(!m_EventList.IsEmpty())
	{
		pTheItem = m_EventList.RemoveTail();
		delete pTheItem;
	}

	m_pLocator->Release();
}

BEGIN_EVENTSINK_MAP(CMcaDlg, CDialog)
    //{{AFX_EVENTSINK_MAP(CMcaDlg)
	ON_EVENT(CMcaDlg, IDC_MSCHART1, 9 /* PointSelected */, OnPointSelectedMschart1, VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2)
	ON_EVENT(CMcaDlg, IDC_NAVIGATORCTRL1, 2 /* ViewObject */, OnViewObjectNavigatorctrl1, VTS_BSTR)
	ON_EVENT(CMcaDlg, IDC_NAVIGATORCTRL1, 3 /* ViewInstances */, OnViewInstancesNavigatorctrl1, VTS_BSTR VTS_VARIANT)
	ON_EVENT(CMcaDlg, IDC_NAVIGATORCTRL1, 5 /* GetIWbemServices */, OnGetIWbemServicesNavigatorctrl1, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT(CMcaDlg, IDC_HMMVCTRL1, 1 /* GetIWbemServices */, OnGetIWbemServicesHmmvctrl1, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT(CMcaDlg, IDC_NAVIGATORCTRL1, 4 /* QueryViewInstances */, OnQueryViewInstancesNavigatorctrl1, VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR)
	ON_EVENT(CMcaDlg, IDC_NAVIGATORCTRL1, 1 /* NotifyOpenNameSpace */, OnNotifyOpenNameSpaceNavigatorctrl1, VTS_BSTR)
	ON_EVENT(CMcaDlg, IDC_HMMVCTRL1, 3 /* RequestUIActive */, OnRequestUIActiveHmmvctrl1, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CMcaDlg::OnPointSelectedMschart1(short FAR* Series, short FAR* DataPoint, short FAR* MouseFlags, short FAR* Cancel) 
{
	short iSize = 0;
	double lTmp = 0;
	POSITION pPos;
	void *pTmp;
	TimerItem *pTheItem;

	CVcDataGrid dg = m_Graph.GetDataGrid();
	dg.GetData(*DataPoint, 2, &lTmp, &iSize);

	m_outputList.SetSel((-1), FALSE);
	m_bChart = true;

	pPos = m_TimerList.GetTailPosition();
	pTmp = m_TimerList.GetAt(pPos);
	while(pPos != NULL)
	{
		pTheItem = (TimerItem *)pTmp;

		if(pTheItem->dTimeStamp == lTmp)
			m_outputList.SetSel((m_outputList.GetCount() - pTheItem->iPos - 1),
								TRUE);

		pTmp = m_TimerList.GetPrev(pPos);
	}
	m_bChart = false;
}

void CMcaDlg::OnMiOptQuery() 
{
	// Create a dialog to enter a query
	CQueryDlg *queryDlg = new CQueryDlg(this);
	queryDlg->DoModal();

	delete queryDlg;
}

void CMcaDlg::OnMiOptNotify() 
{
	// TODO: Add your command handler code here
	
}

void CMcaDlg::OnMiFileRegister() 
{
	CRegDialog *regDlg = new CRegDialog(NULL, NULL,
										CheckNamespace(
										SysAllocString(L"\\\\.\\root\\sampler")),
										this);
	regDlg->DoModal();

	delete regDlg;	
}

void CMcaDlg::OnMiFileMsaReg() 
{
	CMSARegDialog *regDlg = new CMSARegDialog(this,
									CheckNamespace(
									SysAllocString(L"\\\\.\\root\\sampler")),
									m_pLocator);
	regDlg->DoModal();

	delete regDlg;	
}

void CMcaDlg::OnMiHelpAbout() 
{
	CAboutDlg dlgAbout;
	dlgAbout.DoModal();	
}

void CMcaDlg::OnSelchangeOutputlist() 
{
	if(!m_bChart)
		m_outputList.SetSel((-1), FALSE);
}

void CMcaDlg::OnDemoButton() 
{
	if(g_bDemoRunning)
	{
		g_bDemoRunning = false;
		m_bStage2 = false;
		m_bStage3 = false;
		m_bDemoLoaded = false;

		m_DemoButton.SetWindowText("Demo");

		RECT sRect;
		this->GetClientRect(&sRect);
		LPARAM lParam = MAKELPARAM(LOWORD((sRect.right - sRect.left)),
								   LOWORD((sRect.bottom - sRect.top)));

		this->PostMessage(WM_SIZE, SIZE_RESTORED, lParam);
	}
	else
	{
		if(!m_bDemoLoaded)
			LoadDemo();
		else
		{
			g_bDemoRunning = true;

			system("net stop W3SVC");

			m_DemoButton.SetWindowText("End Demo");
		}
	}
}

void CMcaDlg::OnMiOptRundemo() 
{
		OnDemoButton();
}

void CMcaDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);

	if(m_bDemoLoaded)
	{
	// Set the browser
		m_Browser.SetWindowPos(&wndTop, 0, 0, (cx - 271), (cy - 10),
			SWP_NOOWNERZORDER);

		m_Viewer.ShowWindow(SW_HIDE);
		m_Navigator.ShowWindow(SW_HIDE);
		m_Browser.SetVisible(TRUE);
	}
	else if(g_bDemoRunning)
	{
		if(m_bStage2)
		{
		// Set the browser
			m_Browser.SetWindowPos(&wndTop, 0, 0, (cx - 271), 140, SWP_NOOWNERZORDER);

		// Set the viewer
			m_Viewer.SetWindowPos(&wndTop, 0, (((cy - 144) / 2) + 141), (cx - 265),
				((cy - 144) / 2), SWP_NOOWNERZORDER);

		// Set the navigator
			m_Navigator.SetWindowPos(&wndTop, 0, 144, (cx - 263),
				((cy - 144) / 2), SWP_NOOWNERZORDER);

			m_Viewer.ShowWindow(SW_SHOWNORMAL);
			m_Navigator.ShowWindow(SW_SHOWNORMAL);
			m_Browser.SetVisible(TRUE);
		}
	}
	else if(m_bShowViewer)
	{
	// Set the browser
		m_Browser.SetWindowPos(&wndTop, 5, 5, 20, 20, SWP_NOOWNERZORDER);

	// Set the viewer
		m_Viewer.SetWindowPos(&wndTop, 0, (cy / 2), (cx - 265),
			(cy / 2), SWP_NOOWNERZORDER);

	// Set the navigator
		m_Navigator.SetWindowPos(&wndTop, 0, 0, (cx - 263), (cy / 2),
			SWP_NOOWNERZORDER);

		m_Viewer.ShowWindow(SW_SHOWNORMAL);
		m_Navigator.ShowWindow(SW_SHOWNORMAL);
		m_Browser.SetVisible(FALSE);
	}
	else
	{
	// Set the browser
		m_Browser.SetWindowPos(&wndTop, 5, 5, 20, 20, SWP_NOOWNERZORDER);

	// Set the navigator
		m_Navigator.SetWindowPos(&wndTop, 0, 0, (cx - 263), (cy - 8),
			SWP_NOOWNERZORDER);

		m_Viewer.ShowWindow(SW_HIDE);
		m_Navigator.ShowWindow(SW_SHOWNORMAL);
		m_Browser.SetVisible(FALSE);
	}

	// Position graph in lower right corner
	m_Graph.SetWindowPos(&wndTop, (cx - 266), (cy - 199), 265, 169,
		SWP_NOOWNERZORDER);

	m_ActiveStatic.SetWindowPos(&wndTop, (cx - 267), (cy - 217), 125, 18,
		SWP_NOOWNERZORDER);

	// Set the IncidentList size
	m_outputList.SetWindowPos(&wndTop, (cx - 267), 18, 266, (cy - 238),
		SWP_NOOWNERZORDER);

	m_IncidStatic.SetWindowPos(&wndTop, (cx - 267), 1, 40, 18,
		SWP_NOOWNERZORDER);

	// The Buttons
	m_DemoButton.SetWindowPos(&wndTop, (cx - 156), (cy - 26), 75, 25,
		SWP_NOOWNERZORDER);

	m_OKButton.SetWindowPos(&wndTop, (cx - 77), (cy - 26), 75, 25,
		SWP_NOOWNERZORDER);

	CWnd::RedrawWindow();
}

void CMcaDlg::OnMiOptLoaddemo() 
{
	LoadDemo();
}

void CMcaDlg::OnMiOptProps() 
{
	m_bShowViewer = !m_bShowViewer;
	
	RECT sRect;

	this->GetClientRect(&sRect);

	LPARAM lParam = MAKELPARAM(LOWORD((sRect.right - sRect.left)),
							   LOWORD((sRect.bottom - sRect.top)));

	this->PostMessage(WM_SIZE, SIZE_RESTORED, lParam);
}

void CMcaDlg::LoadDemo(void)
{
	
	SC_HANDLE hManager;
	SC_HANDLE hService;
	// We'll be using the NT Alerter service for it's rich associations
	TCHAR csService[20] = _T("w3svc");
	
	hManager = OpenSCManager(NULL, NULL, STANDARD_RIGHTS_REQUIRED);
	if(hManager == NULL)
		TRACE(_T("*Unable to Open SCManager: %d\n"), GetLastError());

	hService = OpenService(hManager, csService,
							 (SERVICE_INTERROGATE | SERVICE_STOP |
							 SERVICE_START));
	if(hService == NULL)
		TRACE(_T("*Unable to Open Service: %d\n"), GetLastError());

	CloseServiceHandle(hManager);

	if(StartService(hService, NULL, NULL))
	{
		TRACE(_T("*Service Started\n"));
		m_bDemoLoaded = true;
	}
	else if(ERROR_SERVICE_ALREADY_RUNNING == GetLastError())
	{
		TRACE(_T("*Service Already Running\n"));
		m_bDemoLoaded = true;
	}
	else
		TRACE(_T("*StartService Failed: %d\n"), GetLastError());

	CloseServiceHandle(hService);

	m_bDemoLoaded = true;
	
	RECT sRect;
	this->GetClientRect(&sRect);

	CString csPath = m_tcHtmlLocation;
	csPath += "\\dialog1.htm";
	m_Browser.Navigate(csPath, NULL, NULL, NULL, NULL);

	LPARAM lParam = MAKELPARAM(LOWORD((sRect.right - sRect.left)),
							   LOWORD((sRect.bottom - sRect.top)));

	this->PostMessage(WM_SIZE, SIZE_RESTORED, lParam);
}

// **************************************************************************
//
//	ErrorString()
//
// Description:
//		Converts an HRESULT to a displayable string.
//
// Parameters:
//		hRes (in) - HRESULT to be converted.
//
// Returns:
//		ptr to displayable string.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
LPCTSTR CMcaDlg::ErrorString(HRESULT hRes)
{
    TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

    switch(hRes) 
    {
    case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
    case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
    case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
    case WBEM_S_ALREADY_EXISTS:
        psz = _T("WBEM_S_ALREADY_EXISTS");
        break;
    case WBEM_S_RESET_TO_DEFAULT:
        psz = _T("WBEM_S_RESET_TO_DEFAULT");
        break;
    case WBEM_S_DIFFERENT:
        psz = _T("WBEM_S_DIFFERENT");
        break;
    case WBEM_E_OVERRIDE_NOT_ALLOWED:
        psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
        break;
    case WBEM_E_PROPAGATED_QUALIFIER:
        psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
        break;
    case WBEM_E_PROPAGATED_PROPERTY:
        psz = _T("WBEM_E_PROPAGATED_PROPERTY");
        break;
    case WBEM_E_UNEXPECTED:
        psz = _T("WBEM_E_UNEXPECTED");
        break;
    case WBEM_E_ILLEGAL_OPERATION:
        psz = _T("WBEM_E_ILLEGAL_OPERATION");
        break;
    case WBEM_E_CANNOT_BE_KEY:
        psz = _T("WBEM_E_CANNOT_BE_KEY");
        break;
    case WBEM_E_INCOMPLETE_CLASS:
        psz = _T("WBEM_E_INCOMPLETE_CLASS");
        break;
    case WBEM_E_INVALID_SYNTAX:
        psz = _T("WBEM_E_INVALID_SYNTAX");
        break;
    case WBEM_E_NONDECORATED_OBJECT:
        psz = _T("WBEM_E_NONDECORATED_OBJECT");
        break;
    case WBEM_E_READ_ONLY:
        psz = _T("WBEM_E_READ_ONLY");
        break;
    case WBEM_E_PROVIDER_NOT_CAPABLE:
        psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
        break;
    case WBEM_E_CLASS_HAS_CHILDREN:
        psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
        break;
    case WBEM_E_CLASS_HAS_INSTANCES:
        psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
        break;
    case WBEM_E_QUERY_NOT_IMPLEMENTED:
        psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
        break;
    case WBEM_E_ILLEGAL_NULL:
        psz = _T("WBEM_E_ILLEGAL_NULL");
        break;
    case WBEM_E_INVALID_QUALIFIER_TYPE:
        psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
        break;
    case WBEM_E_INVALID_PROPERTY_TYPE:
        psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
        break;
    case WBEM_E_VALUE_OUT_OF_RANGE:
        psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
        break;
    case WBEM_E_CANNOT_BE_SINGLETON:
        psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
        break;
	default:
        _itot(hRes, szBuffer2, 16);
        _tcscat(szBuffer, szBuffer2);
        psz = szBuffer;
	    break;
	}
	return psz;
}

void CMcaDlg::OnViewObjectNavigatorctrl1(LPCTSTR bstrPath) 
{
	VARIANT v;
	VariantInit(&v);
	WCHAR wcBuffer[500];
	int iBufSize = 500;

	TRACE(_T("* OnViewObjectNavigatorctrl1 Called\n"));

	v = m_Viewer.GetObjectPath();

	VariantClear(&v);

	MultiByteToWideChar(CP_OEMCP, 0, bstrPath, (-1), wcBuffer, iBufSize);
	V_BSTR(&v) = SysAllocString(wcBuffer);

	m_Viewer.SetObjectPath(v);

}

void CMcaDlg::OnViewInstancesNavigatorctrl1(LPCTSTR bstrLabel, const VARIANT FAR& vsapaths) 
{
	TRACE(_T("* OnViewInstancesNavigatorctrl1 Called\n"));
	m_Viewer.ShowInstances(bstrLabel, vsapaths);
}

void CMcaDlg::OnGetIWbemServicesNavigatorctrl1(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) 
{
	TRACE(_T("* OnGetIWbemServicesNavigatorctrl1 Called\n"));
	m_Security.GetIWbemServices(lpctstrNamespace, pvarUpdatePointer, pvarServices, 
								pvarSC, pvarUserCancel);
}

void CMcaDlg::OnGetIWbemServicesHmmvctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel) 
{
	TRACE(_T("* OnGetIWbemServicesHmmvctrl1 Called\n"));
	m_Security.GetIWbemServices(szNamespace, pvarUpdatePointer, pvarServices, 
								pvarSc, pvarUserCancel);
}

void CMcaDlg::OnQueryViewInstancesNavigatorctrl1(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass) 
{
	TRACE(_T("* OnQueryViewInstancesNavigatorctrl1 Called\n"));
	m_Viewer.QueryViewInstances(pLabel, pQueryType, pQuery, pClass);
}

void CMcaDlg::OnNotifyOpenNameSpaceNavigatorctrl1(LPCTSTR lpcstrNameSpace) 
{
	TRACE(_T("* OnNotifyOpenNameSpaceNavigatorctrl1 Called\n"));
	m_Viewer.SetNameSpace(lpcstrNameSpace);
	
}

void CMcaDlg::OnRequestUIActiveHmmvctrl1() 
{
	UpdateWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\mca.cpp ===
// mca.cpp : Defines the class behaviors for the application.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "mca.h"
#include "mcadlg.h"
#include "factory.h"
#include <objbase.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMcaApp

BEGIN_MESSAGE_MAP(CMcaApp, CWinApp)
	//{{AFX_MSG_MAP(CMcaApp)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMcaApp construction

CMcaApp::CMcaApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMcaApp object

CMcaApp theApp;

// {3106F710-628B-11d1-A9A8-0060081EBBAD}
static const GUID CLSID_McaConsumer = 
{ 0x3106f710, 0x628b, 0x11d1, { 0xa9, 0xa8, 0x0, 0x60, 0x8, 0x1e, 0xbb, 0xad } };

/////////////////////////////////////////////////////////////////////////////
// CMcaApp initialization

BOOL CMcaApp::InitInstance()
{
	HRESULT hr;
	BOOL regEmpty = FALSE; // did a self-unregister happen?

	AfxEnableControlContainer();

	if(SUCCEEDED(CoInitialize(NULL)))
	{
		if(FAILED(hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
			RPC_C_AUTHN_LEVEL_CONNECT,
			RPC_C_IMP_LEVEL_IDENTIFY, NULL, 0, 0)))
			AfxMessageBox(_T("CoInitializeSecurity Failed"));
	}
	else
	{
		AfxMessageBox(_T("CoInitialize Failed"));
		return FALSE;
	}

	// Check the command line
	TCHAR tcTemp[128];
	TCHAR seps[] = _T(" ");
	TCHAR *token = NULL;
	WCHAR wcTemp[128];
	BSTR wcpConnect = SysAllocString(L"\\\\.\\root\\sampler");

	_tcscpy(tcTemp, (LPCTSTR)m_lpCmdLine);
	token = _tcstok( tcTemp, seps );
	while( token != NULL )
	{
		if((_tcscmp(token, _T("/CONNECT")) == 0) ||
			(_tcscmp(token, _T("/connect")) == 0))
		{
			token = _tcstok( NULL, seps );
			MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, token, (-1),
								 wcTemp, 128);
			SysFreeString(wcpConnect);
			wcpConnect = SysAllocString(wcTemp);
		}
		/* Get next token: */
		token = _tcstok( NULL, seps );
	}

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Create a dialog to appease the user durring log on
	CDialog *ldlg = new CDialog(IDD_LOAD_DIALOG, NULL);
	m_pMainWnd = ldlg;
	int bWorked = ldlg->Create(IDD_LOAD_DIALOG, NULL);


	if(FAILED(hr = CreateUser()))
		TRACE(_T("* Error creating user: %s\n"), ErrorString(hr));

	m_dlg = new CMcaDlg(NULL, wcpConnect);

	m_pMainWnd = NULL;
	delete ldlg;

	m_pMainWnd = m_dlg;
	int nResponse = m_dlg->DoModal();

	delete m_dlg;

	CoRevokeClassObject(m_clsReg);

	CoUninitialize();

	return FALSE;
}

HRESULT CMcaApp::CreateUser(void)
{
	HRESULT hr;
	VARIANT v;
	IWbemServices *pSecurity = NULL;
	IWbemClassObject *pClass = NULL;
	IWbemLocator *pLocator = NULL;
	IWbemClassObject *pObj = NULL;

	VariantInit(&v);

	// Get a namespace pointer
	// We aren't using CheckNamespace because we don't know if the user
	// has been created.  If not, CheckNamespace will break.
	if(SUCCEEDED(CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
				 IID_IWbemLocator, (void **)&pLocator)))
	{
		if(FAILED(hr = pLocator->ConnectServer(
			SysAllocString(L"\\\\.\\root\\security"), NULL, NULL, NULL,
			0, NULL, NULL, &pSecurity)))
		{
			TRACE(_T("* Unable to connect to Namespace root\\security: %s\n"),
				ErrorString(hr));
			return hr;
		}
		pLocator->Release();
	}
	else
	{	
		TRACE(_T("* Failed to create Locator object: %s\n"), ErrorString(hr));
		return hr;
	}

	// Now we will create th user
	if(SUCCEEDED(hr = pSecurity->GetObject(SysAllocString(L"__NTLMUser"),
		0, NULL, &pClass, NULL)))
	{
		hr = pClass->Get(SysAllocString(L"__SERVER"), 0, &v, NULL, NULL);

		hr = pClass->SpawnInstance(0, &pObj);
		pClass->Release();

		// We still have the server name in here
		hr = pObj->Put(SysAllocString(L"Domain"), 0, &v, NULL);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v) = SysAllocString(L"sampler");
		hr = pObj->Put(SysAllocString(L"Name"), 0, &v, NULL);

		V_VT(&v) = VT_I4;
		V_I4(&v) = 2;
		hr = pObj->Put(SysAllocString(L"Permissions"), 0, &v, NULL);

		V_VT(&v) = VT_BOOL;
		V_BOOL(&v) = TRUE;
		hr = pObj->Put(SysAllocString(L"Enabled"), 0, &v, NULL);

		V_VT(&v) = VT_BOOL;
		V_BOOL(&v) = TRUE;
		hr = pObj->Put(SysAllocString(L"ExecuteMethods"), 0, &v, NULL);

		if(FAILED(pSecurity->PutInstance(pObj, WBEM_FLAG_CREATE_OR_UPDATE,
			NULL, NULL)))
			AfxMessageBox(_T("Error: Unable to create user account\nOnly local access will be possible"));
		
		pObj->Release();
	}

	return hr;
}

#define TCHAR_LEN_IN_BYTES(str)	 _tcslen(str)*sizeof(TCHAR)+sizeof(TCHAR)

// **************************************************************************
//
//	ErrorString()
//
// Description:
//		Converts an HRESULT to a displayable string.
//
// Parameters:
//		hr (in) - HRESULT to be converted.
//
// Returns:
//		ptr to displayable string.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
LPCTSTR CMcaApp::ErrorString(HRESULT hRes)
{
    TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

    switch(hRes) 
    {
    case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
    case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
    case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
    case WBEM_S_ALREADY_EXISTS:
        psz = _T("WBEM_S_ALREADY_EXISTS");
        break;
    case WBEM_S_RESET_TO_DEFAULT:
        psz = _T("WBEM_S_RESET_TO_DEFAULT");
        break;
    case WBEM_S_DIFFERENT:
        psz = _T("WBEM_S_DIFFERENT");
        break;
    case WBEM_E_OVERRIDE_NOT_ALLOWED:
        psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
        break;
    case WBEM_E_PROPAGATED_QUALIFIER:
        psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
        break;
    case WBEM_E_PROPAGATED_PROPERTY:
        psz = _T("WBEM_E_PROPAGATED_PROPERTY");
        break;
    case WBEM_E_UNEXPECTED:
        psz = _T("WBEM_E_UNEXPECTED");
        break;
    case WBEM_E_ILLEGAL_OPERATION:
        psz = _T("WBEM_E_ILLEGAL_OPERATION");
        break;
    case WBEM_E_CANNOT_BE_KEY:
        psz = _T("WBEM_E_CANNOT_BE_KEY");
        break;
    case WBEM_E_INCOMPLETE_CLASS:
        psz = _T("WBEM_E_INCOMPLETE_CLASS");
        break;
    case WBEM_E_INVALID_SYNTAX:
        psz = _T("WBEM_E_INVALID_SYNTAX");
        break;
    case WBEM_E_NONDECORATED_OBJECT:
        psz = _T("WBEM_E_NONDECORATED_OBJECT");
        break;
    case WBEM_E_READ_ONLY:
        psz = _T("WBEM_E_READ_ONLY");
        break;
    case WBEM_E_PROVIDER_NOT_CAPABLE:
        psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
        break;
    case WBEM_E_CLASS_HAS_CHILDREN:
        psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
        break;
    case WBEM_E_CLASS_HAS_INSTANCES:
        psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
        break;
    case WBEM_E_QUERY_NOT_IMPLEMENTED:
        psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
        break;
    case WBEM_E_ILLEGAL_NULL:
        psz = _T("WBEM_E_ILLEGAL_NULL");
        break;
    case WBEM_E_INVALID_QUALIFIER_TYPE:
        psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
        break;
    case WBEM_E_INVALID_PROPERTY_TYPE:
        psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
        break;
    case WBEM_E_VALUE_OUT_OF_RANGE:
        psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
        break;
    case WBEM_E_CANNOT_BE_SINGLETON:
        psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
        break;
	default:
        _itot(hRes, szBuffer2, 16);
        _tcscat(szBuffer, szBuffer2);
        psz = szBuffer;
	    break;
	}
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\hmmv.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_HMMV_H__707E3243_98EE_11D1_AA0A_0060081EBBAD__INCLUDED_)
#define AFX_HMMV_H__707E3243_98EE_11D1_AA0A_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CHmmv wrapper class

class CHmmv : public CWnd
{
protected:
	DECLARE_DYNCREATE(CHmmv)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x5b3572ab, 0xd344, 0x11cf, { 0x99, 0xcb, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	VARIANT GetObjectPath();
	void SetObjectPath(const VARIANT&);
	SCODE GetSc();
	void SetSc(SCODE);
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	// property 'StudioModeEnabled' not emitted because of invalid type
	long GetReadyState();

// Operations
public:
	void ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray);
	// method 'SaveState' not emitted because of invalid return type or parameter type
	void QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMMV_H__707E3243_98EE_11D1_AA0A_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\msaregdialog.cpp ===
// MSARegDialog.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "mca.h"
#include "MSARegDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSARegDialog dialog


CMSARegDialog::CMSARegDialog(CWnd* pParent /*=NULL*/,
							 IWbemServices *pNamespace /*=NULL*/,
							 IWbemLocator *pLocator /*=NULL*/)
	: CDialog(CMSARegDialog::IDD, pParent)
{
	m_pParent = (CMcaDlg *)pParent;
	m_pNamespace = pNamespace;
	m_pLocator = pLocator;

	//{{AFX_DATA_INIT(CMSARegDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CMSARegDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMSARegDialog)
	DDX_Control(pDX, IDC_EDIT1, m_Edit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMSARegDialog, CDialog)
	//{{AFX_MSG_MAP(CMSARegDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSARegDialog message handlers

void CMSARegDialog::OnOK() 
{
	HRESULT hr;
	IWbemServices *pNamespace = NULL;
	IWbemClassObject *pClass = NULL;
	IWbemClassObject *pObj = NULL;
	CString csMachine;
	WCHAR wcBuffer[200];
	WCHAR wcMachine[200];
	int iBufSize = 200;
	char cBuffer[200];
	DWORD dwSize = 200;
	VARIANT v;

	VariantInit(&v);

	m_Edit.GetWindowText(csMachine);

	MultiByteToWideChar(CP_OEMCP, 0, csMachine, (-1), wcBuffer, iBufSize);
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v) = SysAllocString(wcBuffer);

	//Local registration
	if(SUCCEEDED(m_pNamespace->GetObject(SysAllocString(L"Smpl_RecieveFrom"), 0,
		NULL, &pClass, NULL)))
	{
		if(SUCCEEDED(pClass->SpawnInstance(0, &pObj)))
		{
			pClass->Release();
			pClass = NULL;

			if(SUCCEEDED(pObj->Put(SysAllocString(L"ServerNamespace"), 0, &v,
				NULL)))
			{
				if(FAILED(m_pNamespace->PutInstance(pObj,
					WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
					AfxMessageBox(_T("Error: Unable to create MSA registration"));
			}
			pObj->Release();
			pObj = NULL;
		}
		else
			AfxMessageBox(_T("Error: Unable to create local registration object\nRegistration cannot be completed"));
	}
	else
		AfxMessageBox(_T("Error: Unable to get local registration object\nRegistration cannot be completed"));

	VariantClear(&v);

	csMachine += "\\root\\sampler";
	iBufSize = 200;
	MultiByteToWideChar(CP_OEMCP, 0, csMachine, (-1), wcBuffer, iBufSize);

	//Server registration
	if(SUCCEEDED(hr = m_pLocator->ConnectServer(SysAllocString(wcBuffer), NULL, NULL,
		NULL, 0, NULL, NULL, &pNamespace)))
	{
		if(SUCCEEDED(hr = pNamespace->GetObject(SysAllocString(L"Smpl_MSARegistration"),
			0, NULL, &pClass, NULL)))
		{
			if(SUCCEEDED(hr = pClass->SpawnInstance(0, &pObj)))
			{
				pClass->Release();

				GetComputerName(cBuffer, &dwSize);
				MultiByteToWideChar(CP_OEMCP, 0, cBuffer, (-1), wcMachine,
					iBufSize);
				wcscpy(wcBuffer, L"\\\\");
				wcscat(wcBuffer, wcMachine);
				wcscat(wcBuffer, L"\\root\\sampler");
				V_VT(&v) = VT_BSTR;
				V_BSTR(&v) = SysAllocString(wcBuffer);

			// We need to stick our current machine\namespace in v
				if(SUCCEEDED(hr = pObj->Put(SysAllocString(L"TargetNamespace"), 0, &v,
					NULL)))
				{
					if(FAILED(pNamespace->PutInstance(pObj,
						WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
						AfxMessageBox(_T("Error: Unable to create MSA registration"));
					else
						AfxMessageBox(_T("Changes will take effect when the MSA restarts"));
				}
				else
				{
					TRACE(_T("Error: putting TargetNamespace: %s\n"), m_pParent->ErrorString(hr));
					AfxMessageBox(_T("Error: Unable to write server registration information\nRegistration cannot be completed"));
				}
				pObj->Release();
			}
			else
				AfxMessageBox(_T("Error: Unable to create server registration class\nRegistration cannot be completed"));
		}
		else
			AfxMessageBox(_T("Error: Unable to get registration class from server\nRegistration cannot be completed"));
	}
	else
		AfxMessageBox(_T("Error: Unable to connect to requested Namespace\nRegistration cannot be completed"));
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\navigator.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "navigator.h"

/////////////////////////////////////////////////////////////////////////////
// CNavigator

IMPLEMENT_DYNCREATE(CNavigator, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNavigator properties

CString CNavigator::GetTreeRoot()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNavigator::SetTreeRoot(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

CString CNavigator::GetNameSpace()
{
	CString result;
	GetProperty(0x2, VT_BSTR, (void*)&result);
	return result;
}

void CNavigator::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x2, VT_BSTR, propVal);
}

long CNavigator::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CNavigator operations

void CNavigator::OnReadySignal()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CNavigator::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\nsdialog.cpp ===
// nsdialog.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "mca.h"
#include "nsdialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNSDialog dialog


CNSDialog::CNSDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CNSDialog::IDD, pParent)
{
	m_pParent = (CCustomQueryDialog *)pParent;

	//{{AFX_DATA_INIT(CNSDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CNSDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNSDialog)
	DDX_Control(pDX, IDC_NS_EDIT, m_NSEdit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNSDialog, CDialog)
	//{{AFX_MSG_MAP(CNSDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNSDialog message handlers

void CNSDialog::OnOK() 
{
	char cBuffer[200];
	WCHAR wcBuffer[200];
	int iBufSize = 200;

	m_NSEdit.GetLine(NULL, cBuffer, iBufSize);
	MultiByteToWideChar(CP_OEMCP, 0, cBuffer, (-1), wcBuffer, 200);

	m_pParent->m_pParent->CheckNamespace(SysAllocString(wcBuffer));

	m_pParent->m_CmbBox.AddString(cBuffer);
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\mschart.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "mschart.h"

// Dispatch interfaces referenced by this interface
#include "VcDataGrid.h"

/////////////////////////////////////////////////////////////////////////////
// CMSChart

IMPLEMENT_DYNCREATE(CMSChart, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CMSChart properties

/////////////////////////////////////////////////////////////////////////////
// CMSChart operations

BOOL CMSChart::GetAutoIncrement()
{
	BOOL result;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetAutoIncrement(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSChart::GetRandomFill()
{
	BOOL result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetRandomFill(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSChart::GetChartType()
{
	long result;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSChart::SetChartType(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSChart::GetColumn()
{
	short result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetColumn(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSChart::GetColumnCount()
{
	short result;
	InvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetColumnCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CMSChart::GetColumnLabel()
{
	CString result;
	InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSChart::SetColumnLabel(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

short CMSChart::GetColumnLabelCount()
{
	short result;
	InvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetColumnLabelCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSChart::GetColumnLabelIndex()
{
	short result;
	InvokeHelper(0x8, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetColumnLabelIndex(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x8, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CMSChart::GetData()
{
	CString result;
	InvokeHelper(0x9, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSChart::SetData(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

CString CMSChart::GetFootnoteText()
{
	CString result;
	InvokeHelper(0xa, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSChart::SetFootnoteText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0xa, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

BOOL CMSChart::GetRepaint()
{
	BOOL result;
	InvokeHelper(0xb, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetRepaint(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0xb, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

short CMSChart::GetRow()
{
	short result;
	InvokeHelper(0xc, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetRow(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0xc, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSChart::GetRowCount()
{
	short result;
	InvokeHelper(0xd, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetRowCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0xd, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CMSChart::GetRowLabel()
{
	CString result;
	InvokeHelper(0xe, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSChart::SetRowLabel(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0xe, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

short CMSChart::GetRowLabelCount()
{
	short result;
	InvokeHelper(0xf, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetRowLabelCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0xf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSChart::GetRowLabelIndex()
{
	short result;
	InvokeHelper(0x10, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetRowLabelIndex(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x10, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSChart::GetSeriesColumn()
{
	short result;
	InvokeHelper(0x11, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSChart::SetSeriesColumn(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x11, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSChart::GetSeriesType()
{
	long result;
	InvokeHelper(0x12, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSChart::SetSeriesType(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x12, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CMSChart::GetShowLegend()
{
	BOOL result;
	InvokeHelper(0x13, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetShowLegend(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x13, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSChart::GetDrawMode()
{
	long result;
	InvokeHelper(0x17, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSChart::SetDrawMode(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x17, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSChart::GetBorderStyle()
{
	long result;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSChart::SetBorderStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CMSChart::GetEnabled()
{
	BOOL result;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetEnabled(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSChart::GetHWnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH CMSChart::GetTitle()
{
	LPDISPATCH result;
	InvokeHelper(0x1a, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CMSChart::GetFootnote()
{
	LPDISPATCH result;
	InvokeHelper(0x1b, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

CString CMSChart::GetTitleText()
{
	CString result;
	InvokeHelper(0x1c, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSChart::SetTitleText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1c, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

BOOL CMSChart::GetStacking()
{
	BOOL result;
	InvokeHelper(0x1d, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetStacking(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x1d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSChart::GetTextLengthType()
{
	long result;
	InvokeHelper(0x1e, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSChart::SetTextLengthType(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1e, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CMSChart::GetAllowSelections()
{
	BOOL result;
	InvokeHelper(0x20, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetAllowSelections(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x20, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSChart::GetAllowSeriesSelection()
{
	BOOL result;
	InvokeHelper(0x21, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetAllowSeriesSelection(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x21, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSChart::GetAllowDynamicRotation()
{
	BOOL result;
	InvokeHelper(0x22, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetAllowDynamicRotation(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

short CMSChart::GetActiveSeriesCount()
{
	short result;
	InvokeHelper(0x23, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

LPDISPATCH CMSChart::GetBackdrop()
{
	LPDISPATCH result;
	InvokeHelper(0x24, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CMSChart::GetLegend()
{
	LPDISPATCH result;
	InvokeHelper(0x26, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

CVcDataGrid CMSChart::GetDataGrid()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x27, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return CVcDataGrid(pDispatch);
}

LPDISPATCH CMSChart::GetPlot()
{
	LPDISPATCH result;
	InvokeHelper(0x28, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

BOOL CMSChart::GetAllowDithering()
{
	BOOL result;
	InvokeHelper(0x2b, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetAllowDithering(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x2b, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSChart::GetDoSetCursor()
{
	BOOL result;
	InvokeHelper(0x2d, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSChart::SetDoSetCursor(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x2d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSChart::GetChart3d()
{
	BOOL result;
	InvokeHelper(0x2f, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

VARIANT CMSChart::GetChartData()
{
	VARIANT result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_VARIANT, (void*)&result, NULL);
	return result;
}

void CMSChart::SetChartData(const VARIANT& newValue)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 &newValue);
}

long CMSChart::GetMousePointer()
{
	long result;
	InvokeHelper(0x4a, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSChart::SetMousePointer(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void CMSChart::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSChart::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSChart::EditPaste()
{
	InvokeHelper(0x31, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSChart::EditCopy()
{
	InvokeHelper(0x32, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSChart::Layout()
{
	InvokeHelper(0x34, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSChart::ToDefaults()
{
	InvokeHelper(0x35, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSChart::SelectPart(short part, short index1, short index2, short index3, short index4)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x38, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 part, index1, index2, index3, index4);
}

void CMSChart::GetSelectedPart(short* part, short* index1, short* index2, short* index3, short* index4)
{
	static BYTE parms[] =
		VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2;
	InvokeHelper(0x39, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 part, index1, index2, index3, index4);
}

void CMSChart::TwipsToChartPart(long xVal, long yVal, short* part, short* index1, short* index2, short* index3, short* index4)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2 VTS_PI2;
	InvokeHelper(0x3b, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 xVal, yVal, part, index1, index2, index3, index4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\notificationsink.cpp ===
// notificationsink.cpp: implementation of the CNotificationSink class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "notificationsink.h"
#include "cimomevent.h"
#include "extrinsicevent.h"
#include "registryevent.h"
#include <objbase.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CNotificationSink::CNotificationSink(CMcaDlg *pTheApp, BSTR bstrType)
{
	m_pParent = pTheApp;
	m_bstrType = SysAllocString(bstrType);
}

CNotificationSink::~CNotificationSink()
{

}


STDMETHODIMP CNotificationSink::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CNotificationSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CNotificationSink::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CNotificationSink::Indicate(long lObjectCount,
												   IWbemClassObject** pObjArray)
{
	// walk though the classObjects...
	for (int i = 0; i < lObjectCount; i++)
	{
		pObjArray[i]->AddRef();

		if((wcscmp(L"registryKeyChange", m_bstrType) == 0) ||
			(wcscmp(L"registryTreeChange", m_bstrType) == 0) ||
			(wcscmp(L"registryValueChange", m_bstrType) == 0))
		{
			CRegistryEvent *pEvent = new CRegistryEvent();
			pEvent->PopulateObject(pObjArray[i], m_bstrType);
			pEvent->Publish((void *)m_pParent);
		}
		else
		{
			CCIMOMEvent *pEvent = new CCIMOMEvent();
			pEvent->PopulateObject(pObjArray[i], m_bstrType);
			pEvent->Publish((void *)m_pParent);
		}

		pObjArray[i]->Release();
	}

	return WBEM_NO_ERROR;
}

LPCTSTR CNotificationSink::HandleRegistryEvent(IWbemClassObject *pObj, BSTR bstrType)
{
	HRESULT hr;
	CString csReturn;
	VARIANT v;

	VariantInit(&v);
	csReturn.Empty();

	if(wcscmp(L"RegistryKeyChangeEvent", bstrType) == 0)
	{
		if(SUCCEEDED(hr = pObj->Get(L"KeyPath", 0L, &v, NULL, NULL)))
		{
			csReturn = " - RegistryKeyChange for ";
			csReturn += V_BSTR(&v);
		}
		else
			TRACE(_T("*Get(KeyPath) Item failed %s\n"), 
				m_pParent->ErrorString(hr));
	}
	else if(wcscmp(L"RegistryTreeChangeEvent", bstrType) == 0)
	{
		if(SUCCEEDED(hr = pObj->Get(L"RootPath", 0L, &v, NULL, NULL)))
		{
			csReturn = " - RegistryTreeChange for ";
			csReturn += V_BSTR(&v);
		}
		else
			TRACE(_T("*Get(RootPath) Item failed %s\n"), 
				m_pParent->ErrorString(hr));
	}
	else if(wcscmp(L"RegistryValueChangeEvent", bstrType) == 0)
	{
		if(SUCCEEDED(hr = pObj->Get(L"KeyPath", 0L, &v, NULL, NULL)))
		{
			csReturn = " - RegistryValueChange for ";
			csReturn += V_BSTR(&v);

			VariantClear(&v);
			if(SUCCEEDED(hr = pObj->Get(L"ValueName", 0L, &v, NULL, NULL)))
			{
				csReturn += " Value: ";
				csReturn += V_BSTR(&v);
			}
			else
				TRACE(_T("*Get(ValueName) Item failed %s\n"), 
					m_pParent->ErrorString(hr));
		}
		else
			TRACE(_T("*Get(KeyPath) Item failed %s\n"), 
				m_pParent->ErrorString(hr));
	}
	else
		TRACE(_T("*Error: Non-registry event sent to HandleRegistryEvent()\n"));

	return csReturn;
}

LPCTSTR CNotificationSink::HandleSNMPEvent(IWbemClassObject *pObj, BSTR bstrType)
{
	CString csReturn;
	VARIANT v;

	VariantInit(&v);
	csReturn.Empty();

	return csReturn;
}

LPCTSTR CNotificationSink::HandleWMIEvent(IWbemClassObject *pObj, BSTR bstrType)
{
	CString csReturn;
	VARIANT v;

	VariantInit(&v);
	csReturn.Empty();

	return csReturn;
}
STDMETHODIMP CNotificationSink::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{
	m_pErrorObj = pObjParam;
	if(pObjParam)
		pObjParam->AddRef();

	return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\nsdialog.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_NSDIALOG_H__7D47B3C6_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
#define AFX_NSDIALOG_H__7D47B3C6_8618_11D1_A9E0_0060081EBBAD__INCLUDED_

#include "querydialog.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// nsdialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNSDialog dialog

class CNSDialog : public CDialog
{
// Construction
public:
	CNSDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNSDialog)
	enum { IDD = IDD_ADD_NS_DIALOG };
	CEdit	m_NSEdit;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNSDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CCustomQueryDialog *m_pParent;

	// Generated message map functions
	//{{AFX_MSG(CNSDialog)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSDIALOG_H__7D47B3C6_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\mschart.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_MSCHART_H__BD8F08FB_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
#define AFX_MSCHART_H__BD8F08FB_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class CVcDataGrid;

/////////////////////////////////////////////////////////////////////////////
// CMSChart wrapper class

class CMSChart : public CWnd
{
protected:
	DECLARE_DYNCREATE(CMSChart)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x31291e80, 0x728c, 0x11cf, { 0x93, 0xd5, 0x0, 0x20, 0xaf, 0x99, 0x50, 0x4a } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	BOOL GetAutoIncrement();
	void SetAutoIncrement(BOOL bNewValue);
	BOOL GetRandomFill();
	void SetRandomFill(BOOL bNewValue);
	long GetChartType();
	void SetChartType(long nNewValue);
	short GetColumn();
	void SetColumn(short nNewValue);
	short GetColumnCount();
	void SetColumnCount(short nNewValue);
	CString GetColumnLabel();
	void SetColumnLabel(LPCTSTR lpszNewValue);
	short GetColumnLabelCount();
	void SetColumnLabelCount(short nNewValue);
	short GetColumnLabelIndex();
	void SetColumnLabelIndex(short nNewValue);
	CString GetData();
	void SetData(LPCTSTR lpszNewValue);
	CString GetFootnoteText();
	void SetFootnoteText(LPCTSTR lpszNewValue);
	BOOL GetRepaint();
	void SetRepaint(BOOL bNewValue);
	short GetRow();
	void SetRow(short nNewValue);
	short GetRowCount();
	void SetRowCount(short nNewValue);
	CString GetRowLabel();
	void SetRowLabel(LPCTSTR lpszNewValue);
	short GetRowLabelCount();
	void SetRowLabelCount(short nNewValue);
	short GetRowLabelIndex();
	void SetRowLabelIndex(short nNewValue);
	short GetSeriesColumn();
	void SetSeriesColumn(short nNewValue);
	long GetSeriesType();
	void SetSeriesType(long nNewValue);
	BOOL GetShowLegend();
	void SetShowLegend(BOOL bNewValue);
	long GetDrawMode();
	void SetDrawMode(long nNewValue);
	long GetBorderStyle();
	void SetBorderStyle(long nNewValue);
	BOOL GetEnabled();
	void SetEnabled(BOOL bNewValue);
	long GetHWnd();
	LPDISPATCH GetTitle();
	LPDISPATCH GetFootnote();
	CString GetTitleText();
	void SetTitleText(LPCTSTR lpszNewValue);
	BOOL GetStacking();
	void SetStacking(BOOL bNewValue);
	long GetTextLengthType();
	void SetTextLengthType(long nNewValue);
	BOOL GetAllowSelections();
	void SetAllowSelections(BOOL bNewValue);
	BOOL GetAllowSeriesSelection();
	void SetAllowSeriesSelection(BOOL bNewValue);
	BOOL GetAllowDynamicRotation();
	void SetAllowDynamicRotation(BOOL bNewValue);
	short GetActiveSeriesCount();
	LPDISPATCH GetBackdrop();
	LPDISPATCH GetLegend();
	CVcDataGrid GetDataGrid();
	LPDISPATCH GetPlot();
	BOOL GetAllowDithering();
	void SetAllowDithering(BOOL bNewValue);
	BOOL GetDoSetCursor();
	void SetDoSetCursor(BOOL bNewValue);
	BOOL GetChart3d();
	VARIANT GetChartData();
	void SetChartData(const VARIANT& newValue);
	long GetMousePointer();
	void SetMousePointer(long nNewValue);
	void AboutBox();
	void Refresh();
	void EditPaste();
	void EditCopy();
	void Layout();
	void ToDefaults();
	void SelectPart(short part, short index1, short index2, short index3, short index4);
	void GetSelectedPart(short* part, short* index1, short* index2, short* index3, short* index4);
	void TwipsToChartPart(long xVal, long yVal, short* part, short* index1, short* index2, short* index3, short* index4);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSCHART_H__BD8F08FB_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\navigator.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_NAVIGATOR_H__707E3242_98EE_11D1_AA0A_0060081EBBAD__INCLUDED_)
#define AFX_NAVIGATOR_H__707E3242_98EE_11D1_AA0A_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNavigator wrapper class

class CNavigator : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNavigator)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc7eadeb3, 0xecab, 0x11cf, { 0x8c, 0x9e, 0x0, 0xaa, 0x0, 0x6d, 0x1, 0xa } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetTreeRoot();
	void SetTreeRoot(LPCTSTR);
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();

// Operations
public:
	void OnReadySignal();
	// method 'ChangeRootOrNamespace' not emitted because of invalid return type or parameter type
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NAVIGATOR_H__707E3242_98EE_11D1_AA0A_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\notificationsink.h ===
// notificationsink.h: interface for the CNotificationSink class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NOTIFICATIONSINK_H__DCFF7692_9CC3_11D1_AA14_0060081EBBAD__INCLUDED_)
#define AFX_NOTIFICATIONSINK_H__DCFF7692_9CC3_11D1_AA14_0060081EBBAD__INCLUDED_

#include <wbemidl.h>
#include "mca.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CNotificationSink : public IWbemObjectSink  
{
public:
	CNotificationSink(CMcaDlg *pTheApp, BSTR bstrType);
	virtual ~CNotificationSink();

	// IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);
private:
	DWORD m_cRef;
    HRESULT m_hres;
    IWbemClassObject *m_pErrorObj;
	CMcaDlg *m_pParent;
	BSTR m_bstrType;

	IWbemServices *m_pNamespace;

//	LPCTSTR ErrorString(HRESULT hRes);
	LPCTSTR HandleRegistryEvent(IWbemClassObject *pObj, BSTR bstrType);
	LPCTSTR HandleSNMPEvent(IWbemClassObject *pObj, BSTR bstrType);
	LPCTSTR HandleWMIEvent(IWbemClassObject *pObj, BSTR bstrType);
};

#endif // !defined(AFX_NOTIFICATIONSINK_H__DCFF7692_9CC3_11D1_AA14_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\registryevent.h ===
// RegistryEvent.h: interface for the CRegistryEvent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGISTRYEVENT_H__2E3AD8B2_A8C4_11D1_AA31_0060081EBBAD__INCLUDED_)
#define AFX_REGISTRYEVENT_H__2E3AD8B2_A8C4_11D1_AA31_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "extrinsicevent.h"

class CRegistryEvent : public CExtrinsicEvent  
{
public:
	CRegistryEvent();
	virtual ~CRegistryEvent();

	HRESULT PopulateObject(IWbemClassObject *pObj, BSTR bstrType);

};

#endif // !defined(AFX_REGISTRYEVENT_H__2E3AD8B2_A8C4_11D1_AA31_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\querysink.h ===
// querysink.h: interface for the CQuerySink class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_QUERYSINK_H__7D47B3C5_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
#define AFX_QUERYSINK_H__7D47B3C5_8618_11D1_A9E0_0060081EBBAD__INCLUDED_

#include <wbemidl.h>

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CQuerySink : public IWbemObjectSink  
{
public:
	CQuerySink(CListBox	*pList);
	virtual ~CQuerySink();

	// IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);
private:
	DWORD m_cRef;
	CListBox *m_pResultList;
    HRESULT m_hres;
    IWbemClassObject *m_pErrorObj;

};

#endif // !defined(AFX_QUERYSINK_H__7D47B3C5_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\registryevent.cpp ===
// RegistryEvent.cpp: implementation of the CRegistryEvent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mca.h"
#include "RegistryEvent.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegistryEvent::CRegistryEvent()
{

}

CRegistryEvent::~CRegistryEvent()
{

}

HRESULT CRegistryEvent::PopulateObject(IWbemClassObject *pObj, BSTR bstrType)
{
	HRESULT hr;
	VARIANT v;

	VariantInit(&v);

	m_bstrType = SysAllocString(bstrType);

	if (SUCCEEDED(hr = pObj->Get(SysAllocString(L"__CLASS"), 0L, &v, NULL, NULL))) 
	{
	// Do Title/Event
		m_bstrTitle = SysAllocString(V_BSTR(&v));
		m_bstrEvent = SysAllocString(V_BSTR(&v));

		VariantClear(&v);

	// Do ServerNamespace
		hr = pObj->Get(SysAllocString(L"ServerNamespace"), 0L, &v, NULL, NULL);
		m_bstrServerNamespace = SysAllocString(V_BSTR(&v));

		VariantClear(&v);

	// Do Time
		hr = pObj->Get(SysAllocString(L"TimeOfIncident"), 0L, &v, NULL, NULL);
		m_bstrTime = SysAllocString(V_BSTR(&v));
	}
	else
		TRACE(_T("* Get() __CLASS failed\n"));

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\regidialog.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_REGIDIALOG_H__79CF6B24_942E_11D1_AA01_0060081EBBAD__INCLUDED_)
#define AFX_REGIDIALOG_H__79CF6B24_942E_11D1_AA01_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// regidialog.h : header file
//
#include "mcadlg.h"

/////////////////////////////////////////////////////////////////////////////
// CRegDialog dialog

class CRegDialog : public CDialog
{
// Construction
public:
	CRegDialog::CRegDialog(CWnd* pParent =NULL, IWbemServices *pDefault =NULL,
			   IWbemServices *pSampler =NULL, CMcaDlg *pApp = NULL);
	// standard constructor

// Dialog Data
	//{{AFX_DATA(CRegDialog)
	enum { IDD = IDD_REG_DIALOG };
	CListBox	m_RegList;
	CListBox	m_AvailList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	IWbemServices *m_pDefault;
	IWbemServices *m_pSampler;
	CMcaDlg *m_pParent;
	bool bRemoved;

//	LPCTSTR ErrorString(HRESULT hRes);

	// Generated message map functions
	//{{AFX_MSG(CRegDialog)
	afx_msg void OnAddFilterButton();
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIDIALOG_H__79CF6B24_942E_11D1_AA01_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\querydialog.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_QUERYDIALOG_H__7D47B3C3_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
#define AFX_QUERYDIALOG_H__7D47B3C3_8618_11D1_A9E0_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// querydialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueryDialog dialog

class CCustomQueryDialog : public CDialog
{
// Construction
public:
	CCustomQueryDialog(CWnd* pParent = NULL);
	// standard constructor

	CMcaDlg *m_pParent;

//	LPCTSTR ErrorString(HRESULT hRes);

// Dialog Data
	//{{AFX_DATA(CQueryDialog)
	enum { IDD = IDD_CUSTOM_QUERY_DIALOG };
	CButton	m_NSButton;
	CEdit	m_QueryEdit;
	CComboBox	m_CmbBox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueryDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CQueryDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnAddNsButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CQueryDlg dialog

class CQueryDlg : public CDialog
{
// Construction
public:
	CQueryDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CQueryDlg)
	enum { IDD = IDD_QUERY_DIALOG };
	CComboBox	m_Combo;
	CEdit	m_Edit;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueryDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CMcaDlg *m_pParent;

	// Generated message map functions
	//{{AFX_MSG(CQueryDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButton1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QUERYDIALOG_H__7D47B3C3_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\querysink.cpp ===
// querysink.cpp: implementation of the CQuerySink class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mca.h"
#include "querysink.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CQuerySink::CQuerySink(CListBox	*pList)
{
	m_pResultList = pList;
}

CQuerySink::~CQuerySink()
{
}

STDMETHODIMP CQuerySink::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;
    
	if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CQuerySink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CQuerySink::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CQuerySink::Indicate(long lObjectCount,
								   IWbemClassObject **ppObjArray)
{
	HRESULT hr;
	BSTR bstrMethod = NULL;
	char cBuffer[200];
	int iBufSize = 200;
	VARIANT v;

	VariantInit(&v);

	for(int i = 0; i < lObjectCount; i++)
	{
		if(SUCCEEDED(hr = ppObjArray[i]->Get(L"__PATH", 0, &v, NULL, NULL))) 
		{
		// Get the item name into a char[]
			WideCharToMultiByte(CP_OEMCP, 0, V_BSTR(&v), (-1), cBuffer,
				iBufSize, NULL, NULL);

			m_pResultList->AddString(cBuffer);
		}
		else
			TRACE(_T("*Get() for Query Sink Failed\n"));
	}
	
	return WBEM_NO_ERROR;
}

STDMETHODIMP CQuerySink::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{
	m_hres = lParam;
	m_pErrorObj = pObjParam;
	if(pObjParam)
		pObjParam->AddRef();

	if(m_pResultList->GetCount() < 1)
		m_pResultList->AddString("No returned value(s) for this query");

	return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\querydialog.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "stdafx.h"
#include "mca.h"
#include "querydialog.h"
#include "nsdialog.h"
#include "resultdialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueryDialog dialog


CCustomQueryDialog::CCustomQueryDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CCustomQueryDialog::IDD, pParent)
{
	m_pParent = (CMcaDlg *)pParent;

	//{{AFX_DATA_INIT(CQueryDialog)
	//}}AFX_DATA_INIT
}


void CCustomQueryDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueryDialog)
	DDX_Control(pDX, IDC_ADD_NS_BUTTON, m_NSButton);
	DDX_Control(pDX, IDC_EDIT1, m_QueryEdit);
	DDX_Control(pDX, IDC_COMBO1, m_CmbBox);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCustomQueryDialog, CDialog)
	//{{AFX_MSG_MAP(CQueryDialog)
	ON_BN_CLICKED(IDC_ADD_NS_BUTTON, OnAddNsButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueryDialog message handlers

BOOL CCustomQueryDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	int iSize;
	NamespaceItem *pTheItem;
	CString clMyString;

	iSize = m_pParent->GetNamespaceCount();

	if((iSize == CB_ERR) || (iSize == CB_ERRSPACE))
	{
		AfxMessageBox(_T("An Error Occured While Accessing\nthe Namespace List"));
		return TRUE;
	}

	for(int iPos = 0; iPos < iSize; iPos++)
	{
		pTheItem = m_pParent->GetNamespaceItem(iPos);

		clMyString = pTheItem->bstrNamespace;

		// Put item in list
		m_CmbBox.InsertString(iPos, clMyString);
	}

	return TRUE;
}

void CCustomQueryDialog::OnOK() 
{
	int iPos;
	NamespaceItem *pTheItem;
	BSTR bstrMyQuery = NULL;
	char cBuffer[200];
	WCHAR wcBuffer[200];
	int iBufSize = 200;
	CString MyString;

	//Get the selected namespace and execute the query
	iPos = m_CmbBox.GetCurSel();

	if(iPos > (-1))
	{
		pTheItem = m_pParent->GetNamespaceItem(iPos);

	// Get the contents of the edit field and build the query
		MyString.Empty();
		iPos = m_QueryEdit.GetLineCount();
		for(int i = 0; i < iPos; i++)
		{
			int iBufAct = m_QueryEdit.GetLine(i, cBuffer, iBufSize);
			cBuffer[iBufAct] = NULL;
			MyString += cBuffer;
		}

		MultiByteToWideChar(CP_OEMCP, 0, MyString, (-1), wcBuffer, iBufSize);

		bstrMyQuery = SysAllocString(wcBuffer);

	// Create a dialog to recieve the query results
		CResultDialog *pResultDlg = new CResultDialog(NULL, pTheItem->pNamespace,
													  bstrMyQuery, m_pParent);
	
		int nResponse = pResultDlg->DoModal();
		delete pResultDlg;

		CDialog::OnOK();
	}
	else
		AfxMessageBox(_T("You must select a Namespace"));
}

void CCustomQueryDialog::OnAddNsButton() 
{
	CNSDialog *nsDlg = new CNSDialog(this);

	int iResponse = nsDlg->DoModal();

	delete nsDlg;
}

/////////////////////////////////////////////////////////////////////////////
// CQueryDlg dialog


CQueryDlg::CQueryDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CQueryDlg::IDD, pParent)
{
	m_pParent = (CMcaDlg *)pParent;

	//{{AFX_DATA_INIT(CQueryDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CQueryDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueryDlg)
	DDX_Control(pDX, IDC_COMBO1, m_Combo);
	DDX_Control(pDX, IDC_EDIT1, m_Edit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQueryDlg, CDialog)
	//{{AFX_MSG_MAP(CQueryDlg)
	ON_BN_CLICKED(IDC_BUTTON1, OnButton1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueryDlg message handlers

BOOL CQueryDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	VARIANT v;
	char cBuffer[200];
	int iBufSize = 200;
	
	VariantInit(&v);

	//Load our predefined queries
	m_Combo.AddString(_T("Dependents"));
	m_Combo.AddString(_T("Antecedents"));
	m_Combo.AddString(_T("Associators"));
	m_Combo.AddString(_T("Members"));
	m_Combo.AddString(_T("Groups"));

	//If an item is selected (obj brws or incdnt lst) then put it in the edit
	v = m_pParent->m_Viewer.GetObjectPath();

	WideCharToMultiByte(CP_OEMCP, 0, V_BSTR(&v), (-1), cBuffer, iBufSize,
		NULL, NULL);

	m_Edit.SetWindowText(cBuffer);
	
	return TRUE;
}

void CQueryDlg::OnOK() 
{
	CString csText;
	WCHAR wcBuffer[300];
	int iBufSize = 300;
	TCHAR csNSText[200];
	CString csItem;
	CString csQuery;

	//Get the edit and the selected query
	m_Combo.GetLBText(m_Combo.GetCurSel(), csText);

	m_Edit.GetWindowText(csItem);

	// Get the Namespace
	int iPos = csItem.Find(":");
	for(int i = 0; i < iPos; i++)
		csNSText[i] = csItem[i];
	csNSText[i] = NULL;

	// Create the query depending on the selection
	if(0 == strcmp(csText, "Select a query..."))
		AfxMessageBox(_T("You must first select a query"));
	else if(0 == strcmp(csText, "Dependents"))
	{
		csQuery = "associators of {";
		csQuery += csItem;
		csQuery += "} where resultrole=dependent";
	}
	else if(0 == strcmp(csText, "Antecedents"))
	{
		csQuery = "associators of {";
		csQuery += csItem;
		csQuery += "} where resultrole=antecedent";
	}
	else if(0 == strcmp(csText, "Associators"))
	{
		csQuery = "associators of {";
		csQuery += csItem;
		csQuery += "}";
	}
	else if(0 == strcmp(csText, "Decendents"))
	{
	// This should be done with __DERIVATION
		csQuery = "select * from * where __SUPERCLASS=\"";
		csQuery += csItem;
		csQuery += "\"";
	}
	else if(0 == strcmp(csText, "Superclass"))
	{
		csQuery = "select * from * where __CLASS=\"";
		csQuery += csItem;
		csQuery += ".__SUPERCLASS\"";
	}
	else if(0 == strcmp(csText, "Members"))
	{
		csQuery = "associators of {";
		csQuery += csItem;
		csQuery += "} where resultrole=partcomponent";
	}
	else if(0 == strcmp(csText, "Groups"))
	{
		csQuery = "associators of {";
		csQuery += csItem;
		csQuery += "} where resultrole=groupcomponent";
	}
	else
		AfxMessageBox(_T("Error: Query selection has failed"));

	//execute with resultdlg
	MultiByteToWideChar(CP_OEMCP, 0, csQuery, (-1), wcBuffer, iBufSize);
	BSTR bstrMyQuery = SysAllocString(wcBuffer);
	iBufSize = 300;

	MultiByteToWideChar(CP_OEMCP, 0, csNSText, (-1), wcBuffer, iBufSize);

	// Create a dialog to recieve the query results
	CResultDialog *pResultDlg = new CResultDialog(NULL,
		m_pParent->CheckNamespace(SysAllocString(wcBuffer)), bstrMyQuery,
		m_pParent);

	int nResponse = pResultDlg->DoModal();
	delete pResultDlg;
	
	CDialog::OnOK();
}

void CQueryDlg::OnButton1() 
{
	// Create a dialog to enter a query
	CCustomQueryDialog *queryDlg = new CCustomQueryDialog(m_pParent);
	queryDlg->DoModal();

	delete queryDlg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\regidialog.cpp ===
// regidialog.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "mca.h"
#include "regidialog.h"
#include "notificationsink.h"
#include <string.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegDialog dialog


CRegDialog::CRegDialog(CWnd* pParent /*=NULL*/, IWbemServices *pDefault /*=NULL*/,
			   IWbemServices *pSampler /*=NULL*/, CMcaDlg* pApp /*=NULL*/)
	: CDialog(CRegDialog::IDD, pParent)
{
	m_pParent = pApp;
	bRemoved = false;

	m_pDefault = pDefault;

	m_pSampler = pSampler;

	//{{AFX_DATA_INIT(CRegDialog)
	//}}AFX_DATA_INIT
}


void CRegDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegDialog)
	DDX_Control(pDX, IDC_REG_LIST, m_RegList);
	DDX_Control(pDX, IDC_AVAIL_LIST, m_AvailList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegDialog, CDialog)
	//{{AFX_MSG_MAP(CRegDialog)
	ON_BN_CLICKED(IDC_ADD_FILTER_BUTTON, OnAddFilterButton)
	ON_BN_CLICKED(IDC_ADD_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_BUTTON, OnRemoveButton)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegDialog message handlers

void GetUserFromPath(BSTR bstrPath, WCHAR *wcUser)
{
	WCHAR *pStart = bstrPath;
	char cBuf[50];
	int iPos = 0;
	DWORD dwSize = 50;

	while(*pStart == L'\\')
		pStart++;
	if(*pStart == L'.')
	{
		GetComputerName(cBuf, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcUser, 50);
		wcscat(wcUser, L"\\sampler");
	}
	else
	{
		while(*pStart != L'\\')
		{
			wcUser[iPos] = *pStart;
			iPos++;
		}
		wcUser[iPos] = NULL;
		wcscat(wcUser, L"\\sampler");
	}
}

BOOL CRegDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	HRESULT hr;
	char cBuffer[200];
	int iBufSize = 200;
	CString csReg;
	WCHAR wcBuffer[200];
	IWbemServices *pNamespace = NULL;
	IWbemServices *pObservedNamespace = NULL;
	IEnumWbemClassObject *pEnum = NULL;
	IEnumWbemClassObject *pNSEnum = NULL;
	IEnumWbemClassObject *pServerEnum = NULL;
	IWbemClassObject *pObj = NULL;
    ULONG uReturned;
	VARIANT v;

	if(m_pSampler == NULL)
	{
		AfxMessageBox(_T("Unable to connect to Sampler namespace"));
		return FALSE;
	}

	VariantInit(&v);

	// Initialize The BSTR's
	BSTR bstrWQL = SysAllocString(L"WQL");
	BSTR bstrServerQuery = SysAllocString(L"Smpl_RecieveFrom");
	BSTR bstrNamespaceQuery = SysAllocString(L"Smpl_Observation");
	BSTR bstrTheQuery = SysAllocString(L"SamplerConsumer");
	BSTR bstrIncidentType = SysAllocString(L"IncidentType");

	//Get all the registered servers
	if(SUCCEEDED(hr = m_pSampler->CreateInstanceEnum(bstrServerQuery, 0, NULL,
		&pServerEnum)))
	{
		WCHAR wcUser[50];
		char cBuf[50];
		DWORD dwSize = 50;

		GetComputerName(cBuf, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcUser, 50);
		wcscat(wcUser, L"\\sampler");

		m_pParent->SetInterfaceSecurity(pServerEnum, NULL, SysAllocString(wcUser),
			SysAllocString(L"RelpMas1"));

		while(S_OK == (pServerEnum->Next(INFINITE, 1, &pObj, &uReturned)))
		{
			hr = pObj->Get(SysAllocString(L"ServerNamespace"), 0, &v, NULL, NULL);

			wcscpy(wcBuffer, V_BSTR(&v));
			wcscat(wcBuffer, L"\\root\\sampler");

			if(0 == wcscmp(V_BSTR(&v), L"\\\\."))
			{
				GetComputerName(cBuf, &dwSize);
				MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1),
					wcUser, 50);
			}
			else
			{
				WCHAR *pWc = V_BSTR(&v);
				while(*pWc == L'\\')
					pWc++;
				wcscpy(wcUser, pWc);
			}

			wcscat(wcUser, L"\\sampler");

			BSTR bstrNamespace = SysAllocString(wcBuffer);
			pNamespace = m_pParent->CheckNamespace(bstrNamespace);
			SysFreeString(bstrNamespace);

			if(pNamespace != NULL)
			{
			//Get all the Nodes this server observes
				if(SUCCEEDED(hr = pNamespace->CreateInstanceEnum(bstrNamespaceQuery,
					0, NULL, &pNSEnum)))
				{
					m_pParent->SetInterfaceSecurity(pNSEnum, NULL, SysAllocString(wcUser),
						SysAllocString(L"RelpMas1"));

					while(S_OK == (pNSEnum->Next(INFINITE, 1, &pObj, &uReturned)))
					{
						hr = pObj->Get(SysAllocString(L"ConnectNamespace"), 0, &v,
							NULL, NULL);

						BSTR bstrPath = SysAllocString(V_BSTR(&v));
						pObservedNamespace = m_pParent->CheckNamespace(bstrPath);

						//Get all the incident types on monitored on this Node
						if(SUCCEEDED(hr = pObservedNamespace->CreateInstanceEnum(
							bstrTheQuery, 0, NULL, &pEnum)))
						{
							GetUserFromPath(V_BSTR(&v), wcUser);

							m_pParent->SetInterfaceSecurity(pServerEnum, NULL,
								SysAllocString(wcUser),
								SysAllocString(L"RelpMas1"));

							while(S_OK == (pEnum->Next(INFINITE, 1, &pObj, &uReturned)))
							{
								hr = pObj->Get(bstrIncidentType, 0, &v, NULL, NULL);

								WideCharToMultiByte(CP_OEMCP, 0, V_BSTR(&v), (-1),
									cBuffer, iBufSize, NULL, NULL);

								m_AvailList.DeleteString(m_AvailList.FindString((-1),
									cBuffer));
								m_AvailList.AddString(cBuffer);

								VariantClear(&v);
								pObj->Release();
							}
							pEnum->Release();
						}
					}
					pNSEnum->Release();
				}
			}
		}
		pServerEnum->Release();
	}
	else
	{
		AfxMessageBox(_T("Error: Unable To Aquire List of Available Events"));
		TRACE(_T("*Error: %s\n"), m_pParent->ErrorString(hr));
	}

	// Initialize RegList
	bstrTheQuery = SysAllocString(L"smpl_mcaregistration");

	if(SUCCEEDED(hr = m_pSampler->CreateInstanceEnum(bstrTheQuery, 0, NULL,
		&pEnum)))
	{
		while(S_OK == (pEnum->Next(INFINITE, 1, &pObj, &uReturned)))
		{

		    hr = pObj->Get(bstrIncidentType, 0, &v, NULL, NULL);

			WideCharToMultiByte(CP_OEMCP, 0, V_BSTR(&v), (-1), cBuffer,
				iBufSize, NULL, NULL);

		// Add the item to the registered list box and
		//  delete it from the available list box
			m_RegList.AddString(cBuffer);
			m_AvailList.DeleteString(m_AvailList.FindString((-1), cBuffer));

		    pObj->Release();

			VariantClear(&v);
	    }
		pEnum->Release();
	}
	else
	{
		AfxMessageBox(_T("Error: Unable To Aquire List of Registered Events"));
		TRACE(_T("*Error: %s\n"), m_pParent->ErrorString(hr));
	}

	return TRUE;
}

void CRegDialog::OnAddFilterButton() 
{

}

void CRegDialog::OnAddButton() 
{
	HRESULT hr;
	CString csType;
	WCHAR wcBuffer[200];
	WCHAR wcType[100];
	int iBufSize = 100;
	int iPos;
	bool bSuccess = false;
	VARIANT v;
	IWbemClassObject *pClass= NULL;
	IWbemClassObject *pObj= NULL;

	VariantInit(&v);

	// Construct smpl_mcaregistration
	if(SUCCEEDED(hr = m_pSampler->GetObject(SysAllocString(L"smpl_mcaregistration"),
		0, NULL, &pClass, NULL)))
	{
		if(SUCCEEDED(hr = pClass->SpawnInstance(0, &pObj)))
		{
			pClass->Release();

		// Set the Query
			iPos = m_AvailList.GetCurSel();

			if(iPos > (-1))
				m_AvailList.GetText(iPos, csType);
			else
			{
				AfxMessageBox(_T("You must select an item to add"));
				return;
			}

			MultiByteToWideChar(CP_OEMCP, 0, csType, (-1), wcType, iBufSize);

			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = SysAllocString(wcType);
			if(FAILED(hr = pObj->Put(SysAllocString(L"IncidentType"), 0, &v, NULL)))
				TRACE(_T("*Error: Unable to Put(Query) %s\n"),
					m_pParent->ErrorString(hr));

			if(SUCCEEDED(hr = m_pSampler->PutInstance(pObj,
				WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
				bSuccess = true;
			else
			{
				AfxMessageBox(_T("Error: Unable to Create Registration"));
				TRACE(_T("*Error: Unable to PutInstance(smpl_mcaregistration) %s\n"),
					m_pParent->ErrorString(hr));
			}

			pObj->Release();

		// Create the Notification
			wcscpy(wcBuffer, L"select * from Smpl_Incident where IncidentType=\"");
			wcscat(wcBuffer, wcType);
			wcscat(wcBuffer, L"\"");

			BSTR bstrTheQuery = SysAllocString(wcBuffer);
			BSTR bstrWQL = SysAllocString(L"WQL");

			CNotificationSink *pTheSink = new CNotificationSink(m_pParent,
				V_BSTR(&v));

			VariantClear(&v);

			m_pParent->AddToCancelList((void *)pTheSink);

			if(SUCCEEDED(hr = m_pSampler->ExecNotificationQueryAsync(bstrWQL,
				bstrTheQuery, 0, NULL, pTheSink)))
			{
			// Update the lists
				m_RegList.AddString(csType);
				m_AvailList.DeleteString(m_AvailList.GetCurSel());
			}
			else
				TRACE(_T("*ExecNotification Failed: %s\n"),
					m_pParent->ErrorString(hr));

			VariantClear(&v);
		}
		else
			TRACE(_T("*Error: Unable to SpawnInstance(smpl_mcaregistration) %s\n"),
				m_pParent->ErrorString(hr));
	}
	else
		TRACE(_T("*Error: Unable to Get(smpl_mcaregistration) %s\n"),
			m_pParent->ErrorString(hr));
}

void CRegDialog::OnRemoveButton() 
{
	HRESULT hr;
	CString csType;
	WCHAR wcBuffer[200];
	WCHAR wcType[100];
	int iBufSize = 100;
	VARIANT v;
	BSTR bstrQuery = NULL;
	BSTR bstrStorage = NULL;
	BSTR bstrWQL = SysAllocString(L"WQL");
	ULONG uReturned;
	IWbemClassObject *pObj1 = NULL;
	IEnumWbemClassObject *pEnum = NULL;
	
	IWbemClassObject *pObj= NULL;

	m_RegList.GetText(m_RegList.GetCurSel(), csType);

	MultiByteToWideChar(CP_OEMCP, 0, csType, (-1), wcType, iBufSize);

	wcscpy(wcBuffer, L"select * from smpl_mcaregistration where IncidentType=\"");
	wcscat(wcBuffer, wcType);
	wcscat(wcBuffer, L"\"");

	bstrQuery = SysAllocString(wcBuffer);

	// Get the __EventFilter
	if(SUCCEEDED(hr = m_pSampler->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum)))
	{
		WCHAR wcUser[50];
		char cBuf[50];
		DWORD dwSize = 50;

		GetComputerName(cBuf, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcUser, 50);
		wcscat(wcUser, L"\\sampler");

		m_pParent->SetInterfaceSecurity(pEnum, NULL, SysAllocString(wcUser),
			SysAllocString(L"RelpMas1"));

		while(S_OK == (pEnum->Next(INFINITE, 1, &pObj1, &uReturned)))
		{
			hr = pObj1->Get(L"__RELPATH", 0, &v, NULL, NULL);

			pObj1->Release();

		// Delete the Instance
			if(SUCCEEDED(hr = m_pSampler->DeleteInstance(V_BSTR(&v), 0, NULL, NULL)))
			{
			// Update the lists
				m_RegList.DeleteString(m_RegList.GetCurSel());
				m_AvailList.AddString(csType);

				bRemoved = true;
			}
			else
			{
				TRACE(_T("*Error: Unable to DeleteInstance %s\n"),
					m_pParent->ErrorString(hr));
				AfxMessageBox(_T("Error: Unable to Remove Registration"));
			}
			
			VariantClear(&v);
	    }
		pEnum->Release();
	}
	else
		TRACE(_T("*Error: Unable to ExecQuery(1) %s\n"),
			m_pParent->ErrorString(hr));
	
}

void CRegDialog::OnDestroy() 
{
	CDialog::OnDestroy();
}

void CRegDialog::OnOK() 
{
	if(bRemoved)
		AfxMessageBox(_T("Removed registrations will take effect the next\ntime MCA is launched."));

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\security.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "security.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurity

IMPLEMENT_DYNCREATE(CSecurity, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSecurity properties

CString CSecurity::GetLoginComponent()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSecurity::SetLoginComponent(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSecurity operations

void CSecurity::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace, pvarUpdateNamespace, pvarServices, pvarSC, pvarUserCancel);
}

void CSecurity::PageUnloading()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSecurity::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\resource.h ===
//{{NO_DEPENDENCIES}}

// Microsoft Developer Studio generated include file.

// Used by mca.rc

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MSA_DIALOG                  102
#define IDD_MCA_DIALOG                  103
#define IDR_MAINFRAME                   128
#define IDR_MENU1                       131
#define IDI_ICON1                       132
#define IDD_LOAD_DIALOG                 133
#define IDD_METHOD_DIALOG               134
#define IDD_TEST_DIALOG                 135
#define IDD_REG_DIALOG                  138
#define IDD_CUSTOM_QUERY_DIALOG         139
#define IDD_RESULT_DIALOG               140
#define IDD_ADD_NS_DIALOG               142
#define IDD_BROWSE_DIALOG               149
#define IDD_MSA_REG_DIALOG              211
#define IDD_QUERY_DIALOG                212
#define IDC_OUTPUTLIST                  1000
#define IDC_TREE1                       1001
#define IDC_METHOD_LIST                 1009
#define IDTEST                          1012
#define IDC_PROP                        1014
#define IDC_VALUE                       1015
#define IDC_MSCHART1                    1017
#define IDC_COMBO1                      1018
#define IDC_EDIT1                       1019
#define IDC_LIST1                       1020
#define IDC_ADD_NS_BUTTON               1021
#define IDC_NS_EDIT                     1022
#define IDC_ADD_FILTER_BUTTON           1025
#define IDC_REG_LIST                    1026
#define IDC_ADD_BUTTON                  1027
#define IDC_REMOVE_BUTTON               1028
#define IDC_AVAIL_LIST                  1029
#define IDC_INCID_STATIC                1032
#define IDC_ACTIVE_STATIC               1033
#define IDC_NAVIGATORCTRL1              1035
#define IDC_HMMVCTRL1                   1037
#define IDC_EVENTREGEDITCTRL1           1038
#define IDC_EXPLORER1                   1039
#define IDC_SECURITYCTRL1               1040
#define IDC_DEMO_BUTTON                 1041
#define IDC_BUTTON1                     1042
#define ID_MI_FILE_EXIT                 32771
#define ID_MENUITEM32773                32773
#define ID_MENUITEM32774                32774
#define ID_EDIT_DELETE                  32775
#define ID_MENUITEM32777                32777
#define ID_MENUITEM32778                32778
#define ID_MENUITEM32780                32780
#define ID_MI_HELP_ABOUT                32780
#define ID_MENUITEM32781                32781
#define ID_MI_OPT_TEST                  32782
#define ID_MI_OPT_METHODS               32783
#define ID_MI_OPT_QUERY                 32784
#define ID_MENUITEM32785                32785
#define ID_MENUITEM32786                32786
#define ID_MENUITEM32787                32787
#define ID_MI_FILE_REGISTER             32788
#define ID_MI_OPT_NOTIFY                32789
#define ID_MI_OPT_RUNDEMO               32791
#define ID_MI_FILE_MSAREG               32792
#define ID_MI_OPT_LOADDEMO              32793
#define ID_MI_OPT_PROPS                 32794

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        213
#define _APS_NEXT_COMMAND_VALUE         32797
#define _APS_NEXT_CONTROL_VALUE         1043
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\resultdialog.cpp ===
// resultdialog.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "mca.h"
#include "resultdialog.h"
#include "querysink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResultDialog dialog


CResultDialog::CResultDialog(CWnd* pParent /*=NULL*/, IWbemServices *pNamespace,
							 BSTR bstrTheQuery, CMcaDlg *pDlg)
	: CDialog(CResultDialog::IDD, pParent)
{
	m_pParent = pDlg;
	m_bstrTheQuery = bstrTheQuery;
	m_pNamespace = pNamespace;

	//{{AFX_DATA_INIT(CResultDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CResultDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CResultDialog)
	DDX_Control(pDX, IDC_LIST1, m_ResultList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CResultDialog, CDialog)
	//{{AFX_MSG_MAP(CResultDialog)
	ON_WM_DESTROY()
	ON_LBN_DBLCLK(IDC_LIST1, OnDblclkList1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResultDialog message handlers

BOOL CResultDialog::OnInitDialog() 
{
	HRESULT hr;
	BSTR bstrWQL = SysAllocString(L"WQL");

	CDialog::OnInitDialog();
	
	// Create our sink for the upcoming query and add it to the list
	CQuerySink *pTheSink = new CQuerySink(&m_ResultList);
	m_SinkList.AddTail(pTheSink);

	hr = m_pNamespace->ExecQueryAsync(bstrWQL, m_bstrTheQuery, 0, NULL,
									  pTheSink);

	SysFreeString(bstrWQL);

	if(FAILED(hr))
	{
		AfxMessageBox(_T("Query Execution Error"));
		TRACE(_T("*Query Execution Error: %s\n"), m_pParent->ErrorString(hr));
		CDialog::OnOK();
	}

	return TRUE;
}

void CResultDialog::OnDestroy() 
{
	CDialog::OnDestroy();
	
	void *pTheItem;

	// Cleanup Sink List
	while(!m_SinkList.IsEmpty())
	{
		pTheItem = m_SinkList.RemoveTail();
		delete pTheItem;
	}	
}

void CResultDialog::OnDblclkList1() 
{
	CString csBuffer;

	m_ResultList.GetText(m_ResultList.GetCurSel(), csBuffer);
	m_pParent->m_Navigator.SetTreeRoot(csBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\resultdialog.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_RESULTDIALOG_H__7D47B3C4_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
#define AFX_RESULTDIALOG_H__7D47B3C4_8618_11D1_A9E0_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// resultdialog.h : header file
//
#include "mcadlg.h"

/////////////////////////////////////////////////////////////////////////////
// CResultDialog dialog

class CResultDialog : public CDialog
{
// Construction
public:
	CResultDialog(CWnd* pParent = NULL, IWbemServices *pNamespace = NULL,
							 BSTR bstrTheQuery = NULL, CMcaDlg *pDlg = NULL);
	// standard constructor

// Dialog Data
	//{{AFX_DATA(CResultDialog)
	enum { IDD = IDD_RESULT_DIALOG };
	CListBox	m_ResultList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResultDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CMcaDlg *m_pParent;
	CPtrList m_SinkList;
	BSTR m_bstrTheQuery;
	IWbemServices *m_pNamespace;

//	LPCTSTR ErrorString(HRESULT hRes);

	// Generated message map functions
	//{{AFX_MSG(CResultDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnDblclkList1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESULTDIALOG_H__7D47B3C4_8618_11D1_A9E0_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes

//	mca.pch will be the pre-compiled header

//	stdafx.obj will contain the pre-compiled type information

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\security.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_SECURITY_H__BB9B72F2_A3CA_11D1_AA26_0060081EBBAD__INCLUDED_)
#define AFX_SECURITY_H__BB9B72F2_A3CA_11D1_AA26_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSecurity wrapper class

class CSecurity : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSecurity)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x9c3497d6, 0xed98, 0x11d0, { 0x96, 0x47, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetLoginComponent();
	void SetLoginComponent(LPCTSTR);

// Operations
public:
	void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel);
	void PageUnloading();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITY_H__BB9B72F2_A3CA_11D1_AA26_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\sinkobject.cpp ===
// sinkobject.cpp: implementation of the CSinkObject class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "sinkobject.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

TreeNode * NewTreeNode(void)
{	
	TreeNode *pTheNode = new TreeNode;

	pTheNode->bstrName = NULL;
	pTheNode->pFirstChild = NULL;
	pTheNode->pNextSibling = NULL;

	return pTheNode;
}

CSinkObject::CSinkObject(TreeNode *pTheNode, IWbemServices *pNS,
						 CPtrList *pHistoryList, int iIcon /*=0*/)
{
	m_cRef = 0;
	m_pParentNode = pTheNode;
	m_pNamespace = pNS;
	m_pHist = CopyPtrList(pHistoryList);
	m_iIcon = iIcon;
}

CSinkObject::~CSinkObject()
{

}

STDMETHODIMP CSinkObject::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSinkObject::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSinkObject::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CSinkObject::Indicate(long lObjectCount,
								   IWbemClassObject **ppObjArray)
{
	VARIANT vPath, vServ, vName, vClass;
	HRESULT hr;
	WCHAR wcBuffer[200];
	int iBufSize = 200;
	BSTR bstrMyQuery = NULL;
	WCHAR* wcpTheQuery = wcBuffer;

	VariantInit(&vPath);
	VariantInit(&vServ);
	VariantInit(&vName);
	VariantInit(&vClass);

	for(int i = 0; i < lObjectCount; i++)
	{
		if(SUCCEEDED(hr = ppObjArray[i]->Get(L"__RELPATH", 0, &vPath, NULL,
			NULL)))
		{			
			if(!IsInHistory(V_BSTR(&vPath)))
			{
			// Do the history entry
				TreeNode *pAddNode = NewTreeNode();
				pAddNode->bstrName = SysAllocString(V_BSTR(&vPath));
				m_pHist->AddTail(pAddNode);

				hr = ppObjArray[i]->Get(L"__SERVER", 0, &vServ, NULL, NULL);
				hr = ppObjArray[i]->Get(L"__NAMESPACE", 0, &vName, NULL, NULL);
				hr = ppObjArray[i]->Get(L"__CLASS", 0, &vClass, NULL, NULL);

				wcscpy(wcBuffer, L"\\\\");
				wcscat(wcBuffer, V_BSTR(&vServ));
				wcscat(wcBuffer, L"\\");
				wcscat(wcBuffer, V_BSTR(&vName));
				wcscat(wcBuffer, L":");
				wcscat(wcBuffer, V_BSTR(&vPath));

			// Create the new TreeNode and place it in the treelist
				TreeNode *pTheNode = NewTreeNode();

				pTheNode->bstrName = SysAllocString(wcBuffer);

			// Set the item image
			// This should depend on what type of association it is
				pTheNode->iImage = m_iIcon;
				
				if(m_pParentNode->pFirstChild == NULL)
					m_pParentNode->pFirstChild = pTheNode;
				else if(m_pParentNode->pFirstChild->pNextSibling == NULL)
					m_pParentNode->pFirstChild->pNextSibling = pTheNode;
				else
				{
					pTheNode->pNextSibling =
						m_pParentNode->pFirstChild->pNextSibling;
					m_pParentNode->pFirstChild->pNextSibling = pTheNode;
				}

			// If this a Win32_ComputerSystem we do not want to get it's
			//  associators because _EVERYTHING_ is associated with the
			//  system.
				if(wcscmp(V_BSTR(&vClass), L"Win32_ComputerSystem") != 0)
				{
					WCHAR wcTheQuery[300];
					BSTR bstrWQL = SysAllocString(L"WQL");

				// Create our sink for the upcoming ComponentPart query
					CSinkObject *pTheSinkCompOf = new CSinkObject(pTheNode,
																  m_pNamespace,
																  m_pHist, 2);

					wcscpy(wcTheQuery, L"associators of {");
					wcscat(wcTheQuery, V_BSTR(&vPath));
					wcscat(wcTheQuery, L"} where assocclass=CIM_Component");
					bstrMyQuery = SysAllocString(wcTheQuery);

					hr = m_pNamespace->ExecQueryAsync(bstrWQL, bstrMyQuery, 0,
													  NULL, pTheSinkCompOf);
					if(FAILED(hr))
						TRACE(_T("*Indicate Component Query Failed\n"));

					SysFreeString(bstrMyQuery);

				// Create our sink for the upcoming ComponentGroup query
					CSinkObject *pTheSinkOwnerOf = new CSinkObject(pTheNode,
																   m_pNamespace,
																   m_pHist, 3);

					wcscpy(wcTheQuery, L"associators of {");
					wcscat(wcTheQuery, V_BSTR(&vPath));
					wcscat(wcTheQuery, L"} where assocclass=CIM_ElementSetting");
					bstrMyQuery = SysAllocString(wcTheQuery);

					hr = m_pNamespace->ExecQueryAsync(bstrWQL, bstrMyQuery, 0,
													  NULL, pTheSinkOwnerOf);
					if(FAILED(hr))
						TRACE(_T("*Indicate ElementSetting Query Failed\n"));

					SysFreeString(bstrMyQuery);

				// Create our sink for the upcoming Dependency query
					CSinkObject *pTheSinkDepend = new CSinkObject(pTheNode,
																  m_pNamespace,
																  m_pHist, 4);

					wcscpy(wcTheQuery, L"associators of {");
					wcscat(wcTheQuery, V_BSTR(&vPath));
					wcscat(wcTheQuery, L"} where assocclass=CIM_Dependency");
					bstrMyQuery = SysAllocString(wcTheQuery);

					hr = m_pNamespace->ExecQueryAsync(bstrWQL, bstrMyQuery, 0,
													  NULL, pTheSinkDepend);
					if(FAILED(hr))
						TRACE(_T("*Indicate Dependency Query Failed\n"));

				// Create our sink for the upcoming SettingContext query
					CSinkObject *pTheSinkSetCont = new CSinkObject(pTheNode, m_pNamespace,
																  m_pHist, 3);

					wcscpy(wcTheQuery, L"associators of {");
					wcscat(wcTheQuery, V_BSTR(&vPath));
					wcscat(wcTheQuery, L"} where assocclass=CIM_SettingContext");
					bstrMyQuery = SysAllocString(wcTheQuery);

					hr = m_pNamespace->ExecQueryAsync(bstrWQL, bstrMyQuery, 0, NULL,
													pTheSinkSetCont);

					SysFreeString(bstrMyQuery);

				// Create our sink for the upcoming DependencyContext query
					CSinkObject *pTheSinkDepCont = new CSinkObject(pTheNode, m_pNamespace,
																   m_pHist, 4);

					wcscpy(wcTheQuery, L"associators of {");
					wcscat(wcTheQuery, V_BSTR(&vPath));
					wcscat(wcTheQuery, L"} where assocclass=CIM_DependencyContext");
					bstrMyQuery = SysAllocString(wcTheQuery);

					hr = m_pNamespace->ExecQueryAsync(bstrWQL, bstrMyQuery, 0, NULL,
															  pTheSinkDepCont);

					SysFreeString(bstrMyQuery);
					SysFreeString(bstrWQL);
				}
			}
		}
	}

	return WBEM_NO_ERROR;
}

STDMETHODIMP CSinkObject::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{
	m_pErrorObj = pObjParam;
	if(pObjParam)
		pObjParam->AddRef();

	return WBEM_NO_ERROR;
}

bool CSinkObject::IsInHistory(BSTR bstrNewObj)
{
	POSITION pPos;
	void *pTmp;
	TreeNode *pTheItem;

	if((!m_pHist->IsEmpty()) && ((pPos = m_pHist->GetHeadPosition()) != NULL))
	{
		while(pPos != NULL)
		{
			pTmp = m_pHist->GetNext(pPos);
			pTheItem = (TreeNode *)pTmp;

			if(0 == wcscmp(pTheItem->bstrName, bstrNewObj))
				return true;
		}
	}
	
	return false;
}

CPtrList * CSinkObject::CopyPtrList(CPtrList *pList)
{
	POSITION pPos;
	void *pTmp;
	CPtrList *pNewList = new CPtrList();

	if((!pList->IsEmpty()) && ((pPos = pList->GetHeadPosition()) != NULL))
	{
		while(pPos != NULL)
		{
			pTmp = pList->GetNext(pPos);
			pNewList->AddTail(pTmp);
		}
	}

	return pNewList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\sinkobject.h ===
// sinkobject.h: interface for the CSinkObject class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SINKOBJECT_H__C78740E1_6CD3_11D1_A9B7_0060081EBBAD__INCLUDED_)
#define AFX_SINKOBJECT_H__C78740E1_6CD3_11D1_A9B7_0060081EBBAD__INCLUDED_

#include <wbemidl.h>

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

struct TreeNode
{
	BSTR bstrName;
	int iImage;
	TreeNode *pFirstChild;
	TreeNode *pNextSibling;
};

// Function to create/initialize TreeNode
TreeNode * NewTreeNode(void);

class CSinkObject : public IWbemObjectSink
{
public:
	CSinkObject(TreeNode *pTheNode, IWbemServices *pNS,
				CPtrList *pHistoryList, int iIcon = 0);
	virtual ~CSinkObject();

	// IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);
private:
	DWORD m_cRef;
    HRESULT m_hres;
    IWbemClassObject *m_pErrorObj;
	int m_iIcon;
	bool IsInHistory(BSTR bstrNewObj);
	CPtrList * CopyPtrList(CPtrList *pList);

	IWbemServices *m_pNamespace;
	CPtrList *m_pHist;
	TreeNode *m_pParentNode;
};

#endif // !defined(AFX_SINKOBJECT_H__C78740E1_6CD3_11D1_A9B7_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\stdafx.h ===
// stdafx.h : include file for standard system include files,

//  or project specific include files that are used frequently, but

//      are changed infrequently

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#if !defined(AFX_STDAFX_H__BD8F08F5_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
#define AFX_STDAFX_H__BD8F08F5_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_

#if !defined(_WIN32_DCOM)
#define _WIN32_DCOM
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <winsvc.h>

#include <wbemcli_i.c>
#include <wbemprov_i.c>
//#include <cominit.cpp>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BD8F08F5_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\vcdatagrid.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_VCDATAGRID_H__BD8F08FC_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
#define AFX_VCDATAGRID_H__BD8F08FC_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CVcDataGrid wrapper class

class CVcDataGrid : public COleDispatchDriver
{
public:
	CVcDataGrid() {}		// Calls COleDispatchDriver default constructor
	CVcDataGrid(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	CVcDataGrid(const CVcDataGrid& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	short GetColumnCount();
	void SetColumnCount(short nNewValue);
	short GetColumnLabelCount();
	void SetColumnLabelCount(short nNewValue);
	short GetRowLabelCount();
	void SetRowLabelCount(short nNewValue);
	short GetRowCount();
	void SetRowCount(short nNewValue);
	void DeleteColumns(short Column, short Count);
	void InsertColumns(short Column, short Count);
	void DeleteColumnLabels(short LabelIndex, short Count);
	void InsertColumnLabels(short LabelIndex, short Count);
	void DeleteRows(short Row, short Count);
	void InsertRows(short Row, short Count);
	void DeleteRowLabels(short LabelIndex, short Count);
	void InsertRowLabels(short LabelIndex, short Count);
	void RandomDataFill();
	void SetSize(short RowLabelCount, short ColumnLabelCount, short DataRowCount, short DataColumnCount);
	void InitializeLabels();
	void RandomFillColumns(short Column, short Count);
	void RandomFillRows(short Row, short Count);
	void MoveData(short Top, short Left, short Bottom, short Right, short OverOffset, short DownOffset);
	void GetData(short Row, short Column, double* DataPoint, short* nullFlag);
	void SetData(short Row, short Column, double DataPoint, short nullFlag);
	CString GetColumnLabel(short Column, short LabelIndex);
	void SetColumnLabel(short Column, short LabelIndex, LPCTSTR lpszNewValue);
	CString GetCompositeColumnLabel(short Column);
	CString GetCompositeRowLabel(short Row);
	CString GetRowLabel(short Row, short LabelIndex);
	void SetRowLabel(short Row, short LabelIndex, LPCTSTR lpszNewValue);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VCDATAGRID_H__BD8F08FC_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\webbrowser.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_WEBBROWSER_H__25BB0893_9286_11D1_A9F6_0060081EBBAD__INCLUDED_)
#define AFX_WEBBROWSER_H__25BB0893_9286_11D1_A9F6_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser wrapper class

class CWebBrowser : public CWnd
{
protected:
	DECLARE_DYNCREATE(CWebBrowser)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x8856f961, 0x340a, 0x11d0, { 0xa9, 0x6b, 0x0, 0xc0, 0x4f, 0xd7, 0x5, 0xa2 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void GoBack();
	void GoForward();
	void GoHome();
	void GoSearch();
	void Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
	void Refresh();
	void Refresh2(VARIANT* Level);
	void Stop();
	LPDISPATCH GetApplication();
	LPDISPATCH GetParent();
	LPDISPATCH GetContainer();
	LPDISPATCH GetDocument();
	BOOL GetTopLevelContainer();
	CString GetType();
	long GetLeft();
	void SetLeft(long nNewValue);
	long GetTop();
	void SetTop(long nNewValue);
	long GetWidth();
	void SetWidth(long nNewValue);
	long GetHeight();
	void SetHeight(long nNewValue);
	CString GetLocationName();
	CString GetLocationURL();
	BOOL GetBusy();
	void Quit();
	void ClientToWindow(long* pcx, long* pcy);
	void PutProperty(LPCTSTR Property_, const VARIANT& vtValue);
	VARIANT GetProperty_(LPCTSTR Property_);
	CString GetName();
	long GetHwnd();
	CString GetFullName();
	CString GetPath();
	BOOL GetVisible();
	void SetVisible(BOOL bNewValue);
	BOOL GetStatusBar();
	void SetStatusBar(BOOL bNewValue);
	CString GetStatusText();
	void SetStatusText(LPCTSTR lpszNewValue);
	long GetToolBar();
	void SetToolBar(long nNewValue);
	BOOL GetMenuBar();
	void SetMenuBar(BOOL bNewValue);
	BOOL GetFullScreen();
	void SetFullScreen(BOOL bNewValue);
	void Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
	long QueryStatusWB(long cmdID);
	void ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);
	void ShowBrowserBar(VARIANT* pvaClsid, VARIANT* pvarShow, VARIANT* pvarSize);
	long GetReadyState();
	BOOL GetOffline();
	void SetOffline(BOOL bNewValue);
	BOOL GetSilent();
	void SetSilent(BOOL bNewValue);
	BOOL GetRegisterAsBrowser();
	void SetRegisterAsBrowser(BOOL bNewValue);
	BOOL GetRegisterAsDropTarget();
	void SetRegisterAsDropTarget(BOOL bNewValue);
	BOOL GetTheaterMode();
	void SetTheaterMode(BOOL bNewValue);
	BOOL GetAddressBar();
	void SetAddressBar(BOOL bNewValue);
	BOOL GetResizable();
	void SetResizable(BOOL bNewValue);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WEBBROWSER_H__25BB0893_9286_11D1_A9F6_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\webbrowser.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "webbrowser.h"

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser

IMPLEMENT_DYNCREATE(CWebBrowser, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser properties

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser operations

void CWebBrowser::GoBack()
{
	InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoForward()
{
	InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoHome()
{
	InvokeHelper(0x66, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoSearch()
{
	InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

void CWebBrowser::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Refresh2(VARIANT* Level)
{
	static BYTE parms[] =
		VTS_PVARIANT;
	InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Level);
}

void CWebBrowser::Stop()
{
	InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH CWebBrowser::GetApplication()
{
	LPDISPATCH result;
	InvokeHelper(0xc8, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetParent()
{
	LPDISPATCH result;
	InvokeHelper(0xc9, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetContainer()
{
	LPDISPATCH result;
	InvokeHelper(0xca, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetDocument()
{
	LPDISPATCH result;
	InvokeHelper(0xcb, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetTopLevelContainer()
{
	BOOL result;
	InvokeHelper(0xcc, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetType()
{
	CString result;
	InvokeHelper(0xcd, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser::GetLeft()
{
	long result;
	InvokeHelper(0xce, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetLeft(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xce, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetTop()
{
	long result;
	InvokeHelper(0xcf, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetTop(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xcf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetWidth()
{
	long result;
	InvokeHelper(0xd0, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetWidth(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetHeight()
{
	long result;
	InvokeHelper(0xd1, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetHeight(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CWebBrowser::GetLocationName()
{
	CString result;
	InvokeHelper(0xd2, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetLocationURL()
{
	CString result;
	InvokeHelper(0xd3, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetBusy()
{
	BOOL result;
	InvokeHelper(0xd4, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::Quit()
{
	InvokeHelper(0x12c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::ClientToWindow(long* pcx, long* pcy)
{
	static BYTE parms[] =
		VTS_PI4 VTS_PI4;
	InvokeHelper(0x12d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pcx, pcy);
}

void CWebBrowser::PutProperty(LPCTSTR Property_, const VARIANT& vtValue)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x12e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Property_, &vtValue);
}

VARIANT CWebBrowser::GetProperty_(LPCTSTR Property_)
{
	VARIANT result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x12f, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
		Property_);
	return result;
}

CString CWebBrowser::GetName()
{
	CString result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser::GetHwnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetFullName()
{
	CString result;
	InvokeHelper(0x190, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetPath()
{
	CString result;
	InvokeHelper(0x191, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetVisible()
{
	BOOL result;
	InvokeHelper(0x192, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetVisible(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x192, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetStatusBar()
{
	BOOL result;
	InvokeHelper(0x193, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetStatusBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x193, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

CString CWebBrowser::GetStatusText()
{
	CString result;
	InvokeHelper(0x194, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetStatusText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x194, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long CWebBrowser::GetToolBar()
{
	long result;
	InvokeHelper(0x195, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetToolBar(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x195, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CWebBrowser::GetMenuBar()
{
	BOOL result;
	InvokeHelper(0x196, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetMenuBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x196, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetFullScreen()
{
	BOOL result;
	InvokeHelper(0x197, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetFullScreen(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x197, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

void CWebBrowser::Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

long CWebBrowser::QueryStatusWB(long cmdID)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f5, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		cmdID);
	return result;
}

void CWebBrowser::ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 cmdID, cmdexecopt, pvaIn, pvaOut);
}

void CWebBrowser::ShowBrowserBar(VARIANT* pvaClsid, VARIANT* pvarShow, VARIANT* pvarSize)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pvaClsid, pvarShow, pvarSize);
}

long CWebBrowser::GetReadyState()
{
	long result;
	InvokeHelper(DISPID_READYSTATE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetOffline()
{
	BOOL result;
	InvokeHelper(0x226, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetOffline(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x226, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetSilent()
{
	BOOL result;
	InvokeHelper(0x227, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetSilent(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x227, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetRegisterAsBrowser()
{
	BOOL result;
	InvokeHelper(0x228, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetRegisterAsBrowser(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x228, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetRegisterAsDropTarget()
{
	BOOL result;
	InvokeHelper(0x229, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetRegisterAsDropTarget(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x229, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetTheaterMode()
{
	BOOL result;
	InvokeHelper(0x22a, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetTheaterMode(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetAddressBar()
{
	BOOL result;
	InvokeHelper(0x22b, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetAddressBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22b, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetResizable()
{
	BOOL result;
	InvokeHelper(0x22c, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetResizable(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22c, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\activatesink.h ===
// activatesink.h: interface for the CActivateSink class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIVATESINK_H__92923B02_9823_11D1_AA03_0060081EBBAD__INCLUDED_)
#define AFX_ACTIVATESINK_H__92923B02_9823_11D1_AA03_0060081EBBAD__INCLUDED_

#include <wbemidl.h>
#include "msa.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CActiveSink : public IWbemObjectSink  
{
public:
	CActiveSink(CMsaApp *pTheApp, IWbemServices *pNamespace, CMsaDlg *dlg);
	virtual ~CActiveSink();

	// IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);
private:
	DWORD m_cRef;
    HRESULT m_hr;

	CMsaApp *m_pParent;
	CMsaDlg *m_dlg;
	IWbemServices *m_pSampler;
};

#endif // !defined(AFX_ACTIVATESINK_H__92923B02_9823_11D1_AA03_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\mca\vcdatagrid.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "vcdatagrid.h"


/////////////////////////////////////////////////////////////////////////////
// CVcDataGrid properties

/////////////////////////////////////////////////////////////////////////////
// CVcDataGrid operations

short CVcDataGrid::GetColumnCount()
{
	short result;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CVcDataGrid::SetColumnCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CVcDataGrid::GetColumnLabelCount()
{
	short result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CVcDataGrid::SetColumnLabelCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CVcDataGrid::GetRowLabelCount()
{
	short result;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CVcDataGrid::SetRowLabelCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CVcDataGrid::GetRowCount()
{
	short result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CVcDataGrid::SetRowCount(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void CVcDataGrid::DeleteColumns(short Column, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Column, Count);
}

void CVcDataGrid::InsertColumns(short Column, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Column, Count);
}

void CVcDataGrid::DeleteColumnLabels(short LabelIndex, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LabelIndex, Count);
}

void CVcDataGrid::InsertColumnLabels(short LabelIndex, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LabelIndex, Count);
}

void CVcDataGrid::DeleteRows(short Row, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Row, Count);
}

void CVcDataGrid::InsertRows(short Row, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Row, Count);
}

void CVcDataGrid::DeleteRowLabels(short LabelIndex, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LabelIndex, Count);
}

void CVcDataGrid::InsertRowLabels(short LabelIndex, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 LabelIndex, Count);
}

void CVcDataGrid::RandomDataFill()
{
	InvokeHelper(0xd, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CVcDataGrid::SetSize(short RowLabelCount, short ColumnLabelCount, short DataRowCount, short DataColumnCount)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 RowLabelCount, ColumnLabelCount, DataRowCount, DataColumnCount);
}

void CVcDataGrid::InitializeLabels()
{
	InvokeHelper(0xf, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CVcDataGrid::RandomFillColumns(short Column, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Column, Count);
}

void CVcDataGrid::RandomFillRows(short Row, short Count)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Row, Count);
}

void CVcDataGrid::MoveData(short Top, short Left, short Bottom, short Right, short OverOffset, short DownOffset)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Top, Left, Bottom, Right, OverOffset, DownOffset);
}

void CVcDataGrid::GetData(short Row, short Column, double* DataPoint, short* nullFlag)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_PR8 VTS_PI2;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Row, Column, DataPoint, nullFlag);
}

void CVcDataGrid::SetData(short Row, short Column, double DataPoint, short nullFlag)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_R8 VTS_I2;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Row, Column, DataPoint, nullFlag);
}

CString CVcDataGrid::GetColumnLabel(short Column, short LabelIndex)
{
	CString result;
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x15, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		Column, LabelIndex);
	return result;
}

void CVcDataGrid::SetColumnLabel(short Column, short LabelIndex, LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_BSTR;
	InvokeHelper(0x15, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 Column, LabelIndex, lpszNewValue);
}

CString CVcDataGrid::GetCompositeColumnLabel(short Column)
{
	CString result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x16, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		Column);
	return result;
}

CString CVcDataGrid::GetCompositeRowLabel(short Row)
{
	CString result;
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x17, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		Row);
	return result;
}

CString CVcDataGrid::GetRowLabel(short Row, short LabelIndex)
{
	CString result;
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x18, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		Row, LabelIndex);
	return result;
}

void CVcDataGrid::SetRowLabel(short Row, short LabelIndex, LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_BSTR;
	InvokeHelper(0x18, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 Row, LabelIndex, lpszNewValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\activatesink.cpp ===
// activatesink.cpp: implementation of the CActivateSink class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "msa.h"
#include "activatesink.h"
#include "sinkobject.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActiveSink::CActiveSink(CMsaApp *pTheApp, IWbemServices *pNamespace, CMsaDlg *dlg)
{
	m_pParent = pTheApp;
	m_pSampler = pNamespace;
	m_dlg = dlg;
}

CActiveSink::~CActiveSink()
{

}

STDMETHODIMP CActiveSink::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CActiveSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CActiveSink::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CActiveSink::Indicate(long lObjectCount, IWbemClassObject **ppObjArray)
{
	HRESULT hr;
	ULONG uReturned;
	VARIANT v;
	BSTR bstrTheQuery = SysAllocString(L"SamplerConsumer");
	BSTR bstrTarget = SysAllocString(L"ConnectNamespace");
	BSTR bstrIncidentType = SysAllocString(L"IncidentType");
	BSTR bstrWQL = SysAllocString(L"WQL");
	BSTR bstrPwd = SysAllocString(L"Relmas1");
	BSTR bstrQuery = SysAllocString(L"Query");
	BSTR bstrName;

	TRACE(_T("* Activate.Indicate called\n"));

	VariantInit(&v);

	for(int i = 0; i < lObjectCount; i++)
	{
		ppObjArray[i]->AddRef();

		if(SUCCEEDED(hr = ppObjArray[i]->Get(bstrTarget, 0, &v, NULL, NULL)))
		{
			IWbemServices *pNamespace = NULL;
			IEnumWbemClassObject *pEnum = NULL;
			IWbemClassObject *pObj = NULL;

			WCHAR wcTemp[50];
			char cBuf[50];
			DWORD dwSize = 50;

		// Parse the user and get it in a consistent format
			BSTR bstrNamespace = SysAllocString(V_BSTR(&v));
			WCHAR *pwcStart = V_BSTR(&v);
			WCHAR *pwcEnd;
			BSTR bstrUser;
	
			while(*pwcStart == L'\\')
			{	pwcStart++;	}
			if(*pwcStart == L'.')
			{
				GetComputerName(cBuf, &dwSize);
				MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcTemp, 128);

				wcscat(wcTemp, L"\\sampler");
				bstrUser = SysAllocString(wcTemp);
			}
			else
			{
				pwcEnd = pwcStart;
				while(*pwcEnd != L'\\')
				{	pwcEnd++;	}
				*pwcEnd = NULL;
				wcscat(pwcStart, L"\\sampler");
				bstrUser = SysAllocString(pwcStart);
			}

			bstrName = SysAllocString(V_BSTR(&v));

			pNamespace = m_pParent->CheckNamespace(bstrNamespace);
			if(pNamespace == NULL)
				return WBEM_E_FAILED;

			if(FAILED(hr = pNamespace->CreateInstanceEnum(bstrTheQuery, 0, NULL, &pEnum)))
			{
				TRACE(_T("* Error Querying Enumerated NS: %s\n"), m_pParent->ErrorString(hr));
				return WBEM_E_FAILED;
			}

			m_pParent->SetInterfaceSecurity(pEnum, NULL, bstrUser, bstrPwd);

			while(S_OK == (hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)))
			{
				VariantClear(&v);

				if(SUCCEEDED(hr = pObj->Get(bstrQuery, 0, &v, NULL, NULL)))
				{
					SysFreeString(bstrTheQuery);
					bstrTheQuery = SysAllocString(V_BSTR(&v));

					VariantClear(&v);

					if(SUCCEEDED(hr = pObj->Get(bstrIncidentType, 0, &v, NULL, NULL)))
					{
						CSinkObject *pTheSink = new CSinkObject(
							&(m_dlg->m_outputList), m_pParent, V_BSTR(&v));

						CancelItem *pCI = new CancelItem;

						pCI->bstrNamespace = SysAllocString(bstrName);
						pCI->pSink = pTheSink;

						m_pParent->AddToCancelList((void *)pCI);
			
						if(FAILED(hr = pNamespace->ExecNotificationQueryAsync(
							bstrWQL, bstrTheQuery, 0, NULL, pTheSink)))
							TRACE(_T("* Activate.ExecNotification Failed: %s\n"), m_pParent->ErrorString(hr));
						else
							TRACE(_T("* Activate.ExecNotification Succeeded: %s\n"), m_pParent->ErrorString(hr));
					}
					else
						TRACE(_T("* Unable to get IncidentType: %s\n"), m_pParent->ErrorString(hr));

					VariantClear(&v);

				}
				else
					TRACE(_T("* Unable to get Query: %s\n"), m_pParent->ErrorString(hr));

				VariantClear(&v);
				hr = pObj->Release();
			}

			SysFreeString(bstrNamespace);
			SysFreeString(bstrUser);

			hr = pEnum->Release();
		}
		else
			TRACE(_T("* Unable to get Namespace: %s\n"), m_pParent->ErrorString(hr));

		ppObjArray[i]->Release();
	}

	SysFreeString(bstrTarget);
	SysFreeString(bstrTheQuery);
	SysFreeString(bstrWQL);
	SysFreeString(bstrPwd);
	SysFreeString(bstrName);
	SysFreeString(bstrIncidentType);
	SysFreeString(bstrQuery);

	return WBEM_NO_ERROR;
}

STDMETHODIMP CActiveSink::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{
	m_hr = lParam;
	if(FAILED(m_hr))
		TRACE(_T("* rror in CActiveSink.SetStatus() %s\n"),
			m_pParent->ErrorString(m_hr));

	if(pObjParam)
		pObjParam->AddRef();

	return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\addfilter.cpp ===
// AddFilter.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "msa.h"
#include "AddFilter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddFilter dialog


CAddFilter::CAddFilter(CWnd* pParent /*=NULL*/, IWbemServices *pNamespace /*=NULL*/,
					   CConfigDialog *pDlg /*=NULL*/)
	: CDialog(CAddFilter::IDD, pParent)
{
	m_pNamespace = pNamespace;
	m_pDlg = pDlg;

	//{{AFX_DATA_INIT(CAddFilter)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAddFilter::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddFilter)
	DDX_Control(pDX, IDC_EDIT2, m_Type);
	DDX_Control(pDX, IDC_EDIT1, m_Edit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddFilter, CDialog)
	//{{AFX_MSG_MAP(CAddFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddFilter message handlers

void CAddFilter::OnOK() 
{
	HRESULT hr;
	CString csQuery;
	CString csType;
	WCHAR wcBuffer[300];
	IWbemClassObject *pObj = NULL;
	IWbemClassObject *pClass = NULL;
	VARIANT v;
	BSTR bstrIncidentType = SysAllocString(L"IncidentType");
	BSTR bstrQuery = SysAllocString(L"Query");

	VariantInit(&v);

	m_Edit.GetWindowText(csQuery);
	m_Type.GetWindowText(csType);

	if(SUCCEEDED(hr = m_pNamespace->GetObject(SysAllocString(L"SamplerConsumer"), 0,
		NULL, &pClass, NULL)))
	{
		if(SUCCEEDED(hr = pClass->SpawnInstance(0, &pObj)))
		{
			pClass->Release();

			MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, csType.GetBuffer(1), (-1),
				wcBuffer, 300);
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = SysAllocString(wcBuffer);
			if(FAILED(hr = pObj->Put(bstrIncidentType, 0, &v, NULL)))
				m_pDlg->m_pParent->InternalError(hr, 
					_T("* Error : Unable to put(IncidentType): %s\n"));

			VariantClear(&v);

			MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, csQuery.GetBuffer(1), (-1),
				wcBuffer, 300);
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = SysAllocString(wcBuffer);
			if(FAILED(hr = pObj->Put(bstrQuery, 0, &v, NULL)))
				m_pDlg->m_pParent->InternalError(hr, 
					_T("* Error : Unable to put(Query): %s\n"));

			VariantClear(&v);

			if(SUCCEEDED(hr = m_pNamespace->PutInstance(pObj, 0, NULL, NULL)))
			{
				CString csPost;
				csPost = "{";
				csPost += csType;
				csPost += "} ";
				csPost += csQuery;

				m_pDlg->m_FilterList.AddString(csPost.GetBuffer(1));
			}
			else
				m_pDlg->m_pParent->InternalError(hr, 
					_T("* Error: Unable to create SamplerConsumer %s\n"));
		}
		else
			m_pDlg->m_pParent->InternalError(hr, 
				_T("* Error: Unable to spawn SamplerConsumer: %s\n"));
	}
	else
		m_pDlg->m_pParent->InternalError(hr, 
			_T("* Error: Unable to get SamplerConsumer: %s\n"));
	
	SysFreeString(bstrIncidentType);
	SysFreeString(bstrQuery);

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\addfilter.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_ADDFILTER_H__26E808C4_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_)
#define AFX_ADDFILTER_H__26E808C4_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddFilter.h : header file
//
#include "configdialog.h"

/////////////////////////////////////////////////////////////////////////////
// CAddFilter dialog

class CAddFilter : public CDialog
{
// Construction
public:
	CAddFilter(CWnd* pParent = NULL, IWbemServices *pNamespace = NULL,
		CConfigDialog *pDlg = NULL);
	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAddFilter)
	enum { IDD = IDD_ADDFILTER_DIALOG };
	CEdit	m_Type;
	CEdit	m_Edit;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddFilter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	IWbemServices *m_pNamespace;
	CConfigDialog *m_pDlg;

	void CreateClass(IWbemClassObject *pClass, IWbemServices *pNamespace);

	// Generated message map functions
	//{{AFX_MSG(CAddFilter)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDFILTER_H__26E808C4_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\addnamespace.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_ADDNAMESPACE_H__26E808C3_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_)
#define AFX_ADDNAMESPACE_H__26E808C3_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddNamespace.h : header file
//
#include "configdialog.h"

/////////////////////////////////////////////////////////////////////////////
// CAddNamespace dialog

class CAddNamespace : public CDialog
{
// Construction
public:
	CAddNamespace(CWnd* pParent = NULL, CConfigDialog *pApp = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddNamespace)
	enum { IDD = IDD_ADDNS_DIALOG };
	CEdit	m_Edit;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddNamespace)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CConfigDialog *m_pParent;

//	void CreateObservation(IWbemClassObject *pClass, IWbemServices *pNamespace);
	void CreateConsumer(IWbemClassObject *pClass, IWbemServices *pNamespace);

	// Generated message map functions
	//{{AFX_MSG(CAddNamespace)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDNAMESPACE_H__26E808C3_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\addnamespace.cpp ===
// AddNamespace.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "msa.h"
#include "AddNamespace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddNamespace dialog


CAddNamespace::CAddNamespace(CWnd* pParent /*=NULL*/, CConfigDialog *pApp /*=NULL*/)
	: CDialog(CAddNamespace::IDD, pParent)
{
	m_pParent = pApp;

	//{{AFX_DATA_INIT(CAddNamespace)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAddNamespace::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddNamespace)
	DDX_Control(pDX, IDC_EDIT1, m_Edit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddNamespace, CDialog)
	//{{AFX_MSG_MAP(CAddNamespace)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddNamespace message handlers

void CAddNamespace::OnOK() 
{
	HRESULT hr;
	CString csNamespace;
	WCHAR wcBuffer[300];
	IWbemServices *pNamespace;
	IWbemClassObject *pObj = NULL;
	IWbemClassObject *pClass = NULL;
	VARIANT v;
	BSTR bstrObservation = SysAllocString(L"Smpl_Observation");
	BSTR bstrConnectNamespace = SysAllocString(L"ConnectNamespace");
	BSTR bstrNamespace = SysAllocString(L"\\\\.\\root\\sampler");

	VariantInit(&v);

	m_Edit.GetWindowText(csNamespace);

	pNamespace = m_pParent->m_pParent->CheckNamespace(bstrNamespace);

	if(pNamespace != NULL)
	{
		if(SUCCEEDED(hr = pNamespace->GetObject(bstrObservation, 0, NULL, &pClass, NULL)))
		{
			if(SUCCEEDED(hr = pClass->SpawnInstance(0, &pObj)))
			{
				pClass->Release();
				pClass = NULL;

				MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, csNamespace, (-1),
					wcBuffer, 300);
				V_VT(&v) = VT_BSTR;
				V_BSTR(&v) = SysAllocString(wcBuffer);
				if(FAILED(hr = pObj->Put(bstrConnectNamespace, 0, &v, NULL)))
					m_pParent->m_pParent->InternalError(hr, 
						_T("Error: Unable to put(ConnectNamespace): %s\n"));

				VariantClear(&v);

				if(SUCCEEDED(hr = pNamespace->PutInstance(pObj, 0, NULL, NULL)))
					m_pParent->m_ObserveList.AddString(csNamespace.GetBuffer(1));
				else
				{
					TRACE(_T("Error: Unable to create Smpl_Observation: %s\n"),
						m_pParent->m_pParent->ErrorString(hr));
					AfxMessageBox(_T("Error: Unable to register for namespace observation."));
				}

				if(SUCCEEDED(hr = pNamespace->GetObject(NULL, 0, NULL, &pClass, NULL)))
					CreateConsumer(pClass, m_pParent->m_pParent->CheckNamespace(
					SysAllocString(wcBuffer)));
				else
					AfxMessageBox(_T("Error: Unable to create filter registration class\nNo filters can be registered in this namespace."));
			}
			else
				m_pParent->m_pParent->InternalError(hr, 
					_T("Error: Unable to spawn Smpl_Observation: %s\n"));
		}
		else
			m_pParent->m_pParent->InternalError(hr, 
				_T("* Error: Unable to get(smpl_observation): %s\n"));
	}
	else
		AfxMessageBox(_T("Error: Unable to connect to root\\sampler namespace\nOperation cannot be completed"));

	SysFreeString(bstrObservation);
	SysFreeString(bstrConnectNamespace);
	SysFreeString(bstrNamespace);

	CDialog::OnOK();
}

void CAddNamespace::CreateConsumer(IWbemClassObject *pClass,
								IWbemServices *pNamespace)
{
	HRESULT hr;
	VARIANT v;
	BSTR bstrIncidentType = SysAllocString(L"IncidentType");
	BSTR bstrQuery = SysAllocString(L"Query");
	BSTR bstrKey = SysAllocString(L"Key");
	BSTR bstrSUPERCLASS = SysAllocString(L"__SUPERCLASS");
	BSTR bstrCLASS = SysAllocString(L"__CLASS");

	VariantInit(&v);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v) = SysAllocString(L"SamplerConsumer");
	hr = pClass->Put(bstrCLASS, 0, &v, NULL);
	VariantClear(&v);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v) = SysAllocString(L"__EventConsumer");
	hr = pClass->Put(bstrSUPERCLASS, 0, &v, NULL);
	VariantClear(&v);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v) = SysAllocString(L"<NULL>");
	hr = pClass->Put(bstrIncidentType, 0, &v, NULL);
	VariantClear(&v);

	IWbemQualifierSet *pQual = NULL;
	hr = pClass->GetPropertyQualifierSet(bstrIncidentType, &pQual);

	V_VT(&v) = VT_BOOL;
	V_BOOL(&v) = VARIANT_TRUE;
	pQual->Put(bstrKey, &v, 0);
	VariantClear(&v);
	pQual->Release();

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v) = SysAllocString(L"<NULL>");
	hr = pClass->Put(bstrQuery, 0, &v, NULL);
	VariantClear(&v);

	pNamespace->PutClass(pClass, 0, NULL, NULL);

	SysFreeString(bstrIncidentType);
	SysFreeString(bstrQuery);
	SysFreeString(bstrKey);
	SysFreeString(bstrSUPERCLASS);
	SysFreeString(bstrCLASS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\configdialog.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#if !defined(AFX_CONFIGDIALOG_H__26E808C2_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_)
#define AFX_CONFIGDIALOG_H__26E808C2_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ConfigDialog.h : header file
//
#include "msa.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigDialog dialog

class CConfigDialog : public CDialog
{
// Construction
public:
	CConfigDialog(CWnd* pParent = NULL, void *pVoid = NULL);   // standard constructor

	CMsaApp *m_pParent;

// Dialog Data
	//{{AFX_DATA(CConfigDialog)
	enum { IDD = IDD_CONFIG_DIALOG };
	CButton	m_AddFilter;
	CButton	m_RemoveFilter;
	CButton	m_RemoveNS;
	CButton	m_AddNS;
	CComboBox	m_ObserveList;
	CListBox	m_FilterList;
	CTabCtrl	m_Tab;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	IWbemServices *m_pCurNamespace;

	void ObserveTab();
	void FilterTab();

	// Generated message map functions
	//{{AFX_MSG(CConfigDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeNamespaceCombo();
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	afx_msg void OnNsAddButton();
	afx_msg void OnNsRemoveButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONFIGDIALOG_H__26E808C2_AEE8_11D1_AA3B_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\consfactory.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  consfactory.cpp
//
//	Description :
//				"WMI Provider" class factory
//
//	Part of :	WMI Tutorial.
//
//  History:	
//
//***************************************************************************

#include "stdafx.h"
#include "consfactory.h"

CConsumerFactory::CConsumerFactory(CListBox	*pOutputList, CMsaApp *pTheApp)
{
	m_pParent = pTheApp;
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CConsumerFactory::~CConsumerFactory()
{
}

//IUnknown methods

STDMETHODIMP CConsumerFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
		((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CConsumerFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CConsumerFactory::Release(void)
{
    int lNewRef = InterlockedDecrement(&m_cRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConsumerFactory::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CConsumerFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;
	CConsumerProvider * pConsumer;


    if(pUnkOuter)
        return E_FAIL;

    pConsumer = new CConsumerProvider(m_pOutputList, m_pParent);

    if (pConsumer == NULL)
		return E_FAIL;

    if(pConsumer)
        hr = pConsumer->QueryInterface(riid, ppv);
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConsumerFactory::LockServer
//
//  Synopsis:
//
//  Arguments:  [fLock]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP CConsumerFactory::LockServer(BOOL fLock)
{
    if (fLock)
        m_cRef++;
    else
        m_cRef--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\configdialog.cpp ===
// ConfigDialog.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "msa.h"
#include "ConfigDialog.h"
#include "addnamespace.h"
#include "addfilter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigDialog dialog


CConfigDialog::CConfigDialog(CWnd* pParent /*=NULL*/, void *pVoid /*=NULL*/)
	: CDialog(CConfigDialog::IDD, pParent)
{
	m_pParent = (CMsaApp *)pVoid;
	m_pCurNamespace = NULL;

	//{{AFX_DATA_INIT(CConfigDialog)
	//}}AFX_DATA_INIT
}


void CConfigDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigDialog)
	DDX_Control(pDX, IDC_ADD_BUTTON, m_AddFilter);
	DDX_Control(pDX, IDC_REMOVE_BUTTON, m_RemoveFilter);
	DDX_Control(pDX, IDC_NS_REMOVE_BUTTON, m_RemoveNS);
	DDX_Control(pDX, IDC_NS_ADD_BUTTON, m_AddNS);
	DDX_Control(pDX, IDC_NAMESPACE_COMBO, m_ObserveList);
	DDX_Control(pDX, IDC_FILTER_LIST, m_FilterList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigDialog, CDialog)
	//{{AFX_MSG_MAP(CConfigDialog)
	ON_CBN_SELCHANGE(IDC_NAMESPACE_COMBO, OnSelchangeNamespaceCombo)
	ON_BN_CLICKED(IDC_ADD_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_BUTTON, OnRemoveButton)
	ON_BN_CLICKED(IDC_NS_ADD_BUTTON, OnNsAddButton)
	ON_BN_CLICKED(IDC_NS_REMOVE_BUTTON, OnNsRemoveButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigDialog message handlers

BOOL CConfigDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	HRESULT hr;
	IEnumWbemClassObject *pEnum = NULL;
	IWbemClassObject *pObj = NULL;
	ULONG uReturned;
	VARIANT v;
	char cBuffer[200];
	int iBufSize = 200;
	BSTR bstrPwd = SysAllocString(L"Relmas1");
	BSTR bstrConnectNamespace = SysAllocString(L"ConnectNamespace");

	VariantInit(&v);

	//Load the Observe List
	if(FAILED(hr = m_pParent->m_pNamespace->CreateInstanceEnum(
		SysAllocString(L"Smpl_Observation"), 0, NULL, &pEnum)))
		TRACE(_T("* Error Querying Enumerated Observations\n"));

	WCHAR wcUser[100];
	WCHAR *pTmp = wcUser;
	BSTR bstrUser;

	wcscpy(wcUser, m_pParent->m_bstrNamespace);
	while(*pTmp == L'\\')
	{	pTmp++;	}
	if(*pTmp == L'.')
	{
		char cBuf[50];
		DWORD dwSize = 50;
		WCHAR wcUser[100];

		GetComputerName(cBuf, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcUser, 128);

		wcscat(wcUser, L"\\sampler");
		bstrUser = SysAllocString(wcUser);
	}
	else
	{
		WCHAR *pEnd = pTmp;
		while(*pEnd != L'\\')
		{	pEnd++;	}
		*pEnd = NULL;
		wcscat(pTmp, L"\\sampler");
		bstrUser = SysAllocString(pTmp);
	}

	m_pParent->SetInterfaceSecurity(pEnum, NULL, bstrUser, bstrPwd);

	while(S_OK == (hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)))
	{
		if(SUCCEEDED(hr = pObj->Get(bstrConnectNamespace, 0, &v, NULL, NULL)))
		{
			WideCharToMultiByte(CP_OEMCP, 0, V_BSTR(&v), (-1), cBuffer,
				iBufSize, NULL, NULL);
			m_ObserveList.AddString(cBuffer);
		}
		else
			TRACE(_T("* Unable to get \"ConnectNamespace\"\n"));

		hr = pObj->Release();
	}

	hr = pEnum->Release();

	SysFreeString(bstrPwd);
	SysFreeString(bstrConnectNamespace);
	SysFreeString(bstrUser);

	return TRUE;
}

void CConfigDialog::OnSelchangeNamespaceCombo() 
{
	HRESULT hr;
	CString csBuffer;
	WCHAR wcBuffer[200];
	IEnumWbemClassObject *pEnum = NULL;
	IWbemClassObject *pObj = NULL;
	ULONG uReturned;
	VARIANT v;
	BSTR bstrSamplerConsumer = SysAllocString(L"SamplerConsumer");
	BSTR bstrIncidentType = SysAllocString(L"IncidentType");
	BSTR bstrQuery = SysAllocString(L"Query");
	BSTR bstrPwd = SysAllocString(L"Relmas1");

	VariantInit(&v);

	while(0 < m_FilterList.GetCount())
		m_FilterList.DeleteString(0);

	m_ObserveList.GetLBText(m_ObserveList.GetCurSel(), csBuffer);
	MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, csBuffer, (-1),
								 wcBuffer, 200);
	WCHAR wcUser[100];
	wcscpy(wcUser, wcBuffer);

	m_pCurNamespace = m_pParent->CheckNamespace(SysAllocString(wcBuffer));

	// Select all of our event registrations
	if(FAILED(hr = m_pCurNamespace->CreateInstanceEnum(bstrSamplerConsumer,
		0, NULL, &pEnum)))
		TRACE(_T("* Error Querying Enumerated Consumers\n"));

	WCHAR *pTmp = wcUser;
	BSTR bstrUser;

	while(*pTmp == L'\\')
	{	pTmp++;	}
	if(*pTmp == L'.')
	{
		char cBuf[50];
		DWORD dwSize = 50;
		WCHAR wcUser[100];

		GetComputerName(cBuf, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcUser, 128);

		wcscat(wcUser, L"\\sampler");
		bstrUser = SysAllocString(wcUser);
	}
	else
	{
		WCHAR *pEnd = pTmp;
		while(*pEnd != L'\\')
		{	pEnd++;	}
		*pEnd = NULL;
		wcscat(pTmp, L"\\sampler");
		bstrUser = SysAllocString(pTmp);
	}

	m_pParent->SetInterfaceSecurity(pEnum, NULL, bstrUser, bstrPwd);

	while(S_OK == (hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)))
	{
		if(SUCCEEDED(hr = pObj->Get(bstrIncidentType, 0, &v, NULL, NULL)))
		{
			wcscpy(wcBuffer, L"{");
			wcscat(wcBuffer, V_BSTR(&v));
			wcscat(wcBuffer, L"} ");
			
			char cBuffer[200];
			int iBufSize = 200;

			if(SUCCEEDED(hr = pObj->Get(bstrQuery, 0, &v, NULL, NULL)))
			{
				wcscat(wcBuffer, V_BSTR(&v));

				WideCharToMultiByte(CP_OEMCP, 0, wcBuffer, (-1), cBuffer,
					iBufSize, NULL, NULL);
				m_FilterList.AddString(cBuffer);
			}
			else
				TRACE(_T("* Unable to get \"Query\"\n"));
		}
		else
			TRACE(_T("* Unable to get \"IncidentType\"\n"));

		hr = pObj->Release();
	}

	pEnum->Release();

	SysFreeString(bstrSamplerConsumer);
	SysFreeString(bstrIncidentType);
	SysFreeString(bstrQuery);
	SysFreeString(bstrUser);
	SysFreeString(bstrPwd);
}

void CConfigDialog::OnAddButton() 
{
	CAddFilter *pNewDlg = new CAddFilter(NULL, m_pCurNamespace, this);
	pNewDlg->DoModal();
}

void CConfigDialog::OnRemoveButton() 
{
	HRESULT hr;
	CString csBuffer;
	WCHAR wcBuffer[200];
	WCHAR wcQuery[300];
	char cBuffer[200];
	int i = 0;

	m_FilterList.GetText(m_FilterList.GetCurSel(), csBuffer);
	while(csBuffer[i] != '}')
	{
		if(i > 0)
			cBuffer[i - 1] = csBuffer[i];
		i++;
	}
	cBuffer[i - 1] = NULL;

	MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuffer, (-1), wcBuffer, 200);

	wcscpy(wcQuery, L"SamplerConsumer.IncidentType=\"");
	wcscat(wcQuery, wcBuffer);
	wcscat(wcQuery, L"\"");

	BSTR bstrQuery = SysAllocString(wcQuery);

	if(FAILED(hr = m_pCurNamespace->DeleteInstance(bstrQuery, 0, NULL, NULL)))
		TRACE(_T("* Error Deleting Consumers: %s\n"), m_pParent->ErrorString(hr));

	m_FilterList.DeleteString(m_FilterList.GetCurSel());

	SysFreeString(bstrQuery);
}

void CConfigDialog::OnNsAddButton() 
{
	CAddNamespace *pNewDlg = new CAddNamespace(NULL, this);
	pNewDlg->DoModal();
}

void CConfigDialog::OnNsRemoveButton() 
{
	HRESULT hr;
	CString csBuffer;
	WCHAR wcBuffer[200];
	WCHAR wcModBuffer[200];
	WCHAR wcQuery[300];
	IWbemServices *pNamespace;
	int i = 0;
	int j = 0;
	BSTR bstrNamespace = SysAllocString(L"\\\\.\\root\\sampler");

	m_ObserveList.GetLBText(m_ObserveList.GetCurSel(), csBuffer);
	MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, csBuffer, (-1),
		wcBuffer, 200);
	while(wcBuffer[i] != NULL)
	{
		if(wcBuffer[i] == L'\\')
		{
			wcModBuffer[j] = L'\\';
			j++;
		}
		wcModBuffer[j] = wcBuffer[i];
		i++;
		j++;
	}
	wcModBuffer[j] = NULL;

	wcscpy(wcQuery, L"Smpl_Observation.ConnectNamespace=\"");
	wcscat(wcQuery, wcModBuffer);
	wcscat(wcQuery, L"\"");

	BSTR bstrQuery = SysAllocString(wcQuery);

	pNamespace = m_pParent->CheckNamespace(bstrNamespace);

	if(pNamespace != NULL)
	{
		if(SUCCEEDED(hr = pNamespace->DeleteInstance(bstrQuery, 0, NULL, NULL)))
			m_ObserveList.DeleteString(m_ObserveList.GetCurSel());
		else
			TRACE(_T("* Error Deleting Consumer: %s\n"), m_pParent->ErrorString(hr));
	}
	else
		AfxMessageBox(_T("Error: Unable to connect to root\\sampler namespace\nOperation cannot be completed."));
	
	SysFreeString(bstrQuery);
	SysFreeString(bstrNamespace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\consfactory.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef _CONSFACTORY_H_INCLUDED_
#define _CONSFACTORY_H_INCLUDED_

#include <wbemidl.h>
#include "msa.h"
#include "clsid.h"
#include "distributor.h"

class CConsumerFactory : public IClassFactory
{
public:

	CConsumerFactory(CListBox	*pOutputList, CMsaApp *pTheApp);
	virtual ~CConsumerFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD_(SCODE, CreateInstance)(IUnknown * pUnkOuter, 
									REFIID riid, 
									void ** ppvObject);

    STDMETHOD_(SCODE, LockServer)(BOOL fLock);

private:
	LONG m_cRef;

	CMsaApp * m_pParent;
	CListBox	*m_pOutputList;

};
#endif //_CONSFACTORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\clsid.h ===
//clsid.h

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////

// {9FF1CFC1-E688-11d1-8B6C-00A0C9954921}
DEFINE_GUID(CLSID_MsaConsumer, 
0x9ff1cfc1, 0xe688, 0x11d1, 0x8b, 0x6c, 0x0, 0xa0, 0xc9, 0x95, 0x49, 0x21);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\consumer.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef _CONSUMER_H_INCLUDED_
#define _CONSUMER_H_INCLUDED_

#include <wbemidl.h>
#include "msa.h"
#include <objbase.h>

class CConsumer : public IWbemUnboundObjectSink
{
public:
	CConsumer(CListBox	*pOutputList, CMsaApp *pTheApp, BSTR bstrType);
	~CConsumer();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD(IndicateToConsumer)(IWbemClassObject *pLogicalConsumer,
									long lNumObjects,
									IWbemClassObject **ppObjects);

private:

	DWORD m_cRef;
	CListBox	*m_pOutputList;
	BSTR m_bstrIncidentType;
	CMsaApp *m_pParent;
};
#endif //_CONSUMER_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\distributor.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef _DISTRIBUTOR_H_INCLUDED_
#define _DISTRIBUTOR_H_INCLUDED_

#include <wbemidl.h>
#include "clsid.h"
#include "msa.h"
#include <objbase.h>

class CConsumerProvider : public IWbemEventConsumerProvider
{
public:
	CConsumerProvider(CListBox *pOutputList, CMsaApp *pTheApp);
	~CConsumerProvider();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	
	STDMETHODIMP FindConsumer(IWbemClassObject *pLogicalConsumer,
							  IWbemUnboundObjectSink **ppConsumer);

private:
	DWORD m_cRef;
	CListBox *m_pOutputList;
	CMsaApp *m_pParent;
};
#endif //_DISTRIBUTOR_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\distributor.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "stdafx.h"
#include "distributor.h"
#include "consumer.h"

CConsumerProvider::CConsumerProvider(CListBox *pOutputList, CMsaApp *pTheApp)
{
	m_pParent = pTheApp;
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CConsumerProvider::~CConsumerProvider()
{

}

STDMETHODIMP CConsumerProvider::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || IID_IWbemEventConsumerProvider == riid)
        *ppv=this;

    if (*ppv != NULL)
    {
		((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConsumerProvider::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConsumerProvider::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CConsumerProvider::FindConsumer(IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
	VARIANT v;

	TRACE(_T("* FindConsumer() called\n"));

	VariantInit(&v);

	pLogicalConsumer->Get(L"IncidentType", 0, &v, NULL, NULL);

    CConsumer* pSink = new CConsumer(m_pOutputList, m_pParent, V_BSTR(&v));
	
    return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                    (void**)ppConsumer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\msa.h ===
// msa.h : main header file for the WBEMPERMEVENTS application

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#if !defined(AFX_MSA_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
#define AFX_MSA_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include <wbemidl.h>
#include "msadlg.h"
#include "clsid.h"
#include <objbase.h>

struct NamespaceItem
{
	BSTR bstrNamespace;
	IWbemServices *pNamespace;
};

struct CancelItem
{
	BSTR bstrNamespace;
	IWbemObjectSink *pSink;
};

/////////////////////////////////////////////////////////////////////////////
// CMsaApp:
// See msa.cpp for the implementation of this class
//

class CMsaApp : public CWinApp
{
public:
	CMsaApp();

	IWbemServices *m_pNamespace;
	BSTR m_bstrNamespace;
	IWbemObjectSink *m_pObjSink[20];
	bool m_bRegistered;
	
	void InternalError(HRESULT hr, TCHAR *tcMsg);
	HRESULT ActivateNotification(CMsaDlg *dlg);
	IWbemServices * ConnectNamespace(WCHAR *wcNamespace, WCHAR *wcUser);
	IWbemServices * CheckNamespace(BSTR wcItemNS);
	HRESULT SelfProvideEvent(IWbemClassObject *pObj, WCHAR* wcServerNamespace, BSTR bstrType);
	void AddToCancelList(void *pTheItem);
	HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, LPWSTR pPassword);
	LPCTSTR ErrorString(HRESULT hRes);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsaApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

//	int ExitInstance();

// Implementation

	//{{AFX_MSG(CMsaApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Called by embedded classes to communicate events

private:
	DWORD m_clsConsReg;
	DWORD m_clsDistReg;
	CPtrList m_NamespaceList;
	CPtrList m_JunkList;
	CPtrList m_CancelList;

	void RegisterServer(void);
	void UnregisterServer(void);
	void LoadServerInfo(void);
	HRESULT CreateUser(void);
	void AddToNamespaceList(BSTR bstrNamespace, IWbemServices *pNewNamespace);
	void AddToJunkList(void *pTheItem);
	SCODE DetermineLoginType(BSTR & AuthArg, BSTR & UserArg, BSTR & Authority,BSTR & User);
	HRESULT SetInterfaceSecurity(IUnknown * pInterface, COAUTHIDENTITY * pauthident);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSA_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\consumer.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "stdafx.h"
#include "consumer.h"

CConsumer::CConsumer(CListBox	*pOutputList, CMsaApp *pTheApp, BSTR bstrType)
{
	m_pParent = pTheApp;
	m_cRef = 0L;
	m_pOutputList = pOutputList;
	m_bstrIncidentType = SysAllocString(bstrType);
}

CConsumer::~CConsumer()
{
	SysFreeString(m_bstrIncidentType);
}

STDMETHODIMP CConsumer::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConsumer::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConsumer::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CConsumer::IndicateToConsumer(IWbemClassObject *pLogicalConsumer,
											long lNumObjects,
											IWbemClassObject **ppObjects)
{
	HRESULT  hr;
	CString clMyBuff;
	VARIANT vType, vDisp, vClass, vName, vServ;
	IDispatch *pDisp = NULL;
	IWbemClassObject *tgtInst = NULL;
	LPVOID *ppObject = NULL;
	WCHAR wcServerNamespace[50];
	BSTR bstrNAMESPACE = SysAllocString(L"__NAMESPACE");
	BSTR bstrSERVER = SysAllocString(L"__SERVER");
	BSTR bstrCLASS = SysAllocString(L"__CLASS");
	BSTR bstrIncidentType = SysAllocString(L"IncidentType");

	VariantInit(&vType);
	VariantInit(&vClass);
	VariantInit(&vDisp);
	VariantInit(&vName);
	VariantInit(&vServ);

	TRACE(_T("* IndicateToConsumer() called\n"));

	// walk though the classObjects...
	for (int i = 0; i < lNumObjects; i++)
	{
		clMyBuff.Empty();

	// Get the server and namespace info
		hr = ppObjects[i]->Get(bstrNAMESPACE, 0, &vName, NULL, NULL);
		if(FAILED(hr))
			TRACE(_T("* Get(__NAMESPACE) Failed\n"));
		hr = ppObjects[i]->Get(bstrSERVER, 0, &vServ, NULL, NULL);
		if(FAILED(hr))
			TRACE(_T("* Get(__SERVER) Failed\n"));

		wcscpy(wcServerNamespace, L"\\\\");
		wcscat(wcServerNamespace, V_BSTR(&vServ));
		wcscat(wcServerNamespace, L"\\");
		wcscat(wcServerNamespace, V_BSTR(&vName));

		ppObjects[i]->AddRef();
		if(FAILED(hr))
			TRACE(_T("* ppObjects[i]->AddRef() Failed%s\n"), m_pParent->ErrorString(hr));

	// sent the object to CIMOM via the sink
		hr = m_pParent->SelfProvideEvent(ppObjects[i], wcServerNamespace, m_bstrIncidentType);
		TRACE(_T("* SelfProvideEvent completed %s\n"),
				m_pParent->ErrorString(hr));
		if(FAILED(hr))
			TRACE(_T("* SelfProvideEvent returned badness %s\n"),
				m_pParent->ErrorString(hr));

		if(SUCCEEDED(hr = ppObjects[i]->Get(bstrCLASS, 0L, &vClass, NULL, NULL)))
		{					
			if(SUCCEEDED(hr = pLogicalConsumer->Get(bstrIncidentType, 0, &vType, NULL, NULL)))
			{
			// compose a string for the listbox.
				clMyBuff = _T("{");
				clMyBuff += V_BSTR(&vType);
				clMyBuff += _T("}  ");
				clMyBuff += V_BSTR(&vClass);

				if(m_pOutputList->GetCount() > 50)
					m_pOutputList->DeleteString(m_pOutputList->GetCount() - 1);
	
				m_pOutputList->InsertString(0, clMyBuff);
			}
			else
				TRACE(_T("* Get(__PATH) Item failed %s\n"),
					m_pParent->ErrorString(hr));
		}
		else
			TRACE(_T("* Get(__CLASS) Item failed %s\n"),
				m_pParent->ErrorString(hr));
	
		VariantClear(&vType);
		VariantClear(&vClass);
		VariantClear(&vDisp);
		VariantClear(&vName);
		VariantClear(&vServ);
	} // endfor

	SysFreeString(bstrNAMESPACE);
	SysFreeString(bstrSERVER);
	SysFreeString(bstrCLASS);
	SysFreeString(bstrIncidentType);

	return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\msadlg.cpp ===
// msadlg.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "msadlg.h"
#include "ConfigDialog.h"
#include "msa.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsaDlg dialog

CMsaDlg::CMsaDlg(CWnd* pParent /*=NULL*/, void *pVoid /*=NULL*/)
	: CDialog(CMsaDlg::IDD, pParent)
{
	m_pVoidParent = pVoid;

	//{{AFX_DATA_INIT(CMsaDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
//	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMsaDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMsaDlg)
	DDX_Control(pDX, IDC_CONFIG_BUTTON, m_ConfigButton);
	DDX_Control(pDX, IDOK, m_OKButton);
	DDX_Control(pDX, IDC_OUTPUTLIST, m_outputList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMsaDlg, CDialog)
	//{{AFX_MSG_MAP(CMsaDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_SIZE()
	ON_BN_CLICKED(IDC_CONFIG_BUTTON, OnConfigButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsaDlg message handlers

BOOL CMsaDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	ASSERT(m_pVoidParent != NULL);

	HRESULT hr;
	CMsaApp *pApp = (CMsaApp *)m_pVoidParent;

	// Get our notification consumers working
	if(FAILED(hr = pApp->ActivateNotification(this)))
		AfxMessageBox(_T("Error Setting up notification queries\nStandard events will not be recieved"));
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMsaDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
		CDialog::OnSysCommand(nID, lParam);
}

void CMsaDlg::OnPaint() 
{
	if (IsIconic())
	{
	// device context for painting
		CPaintDC dc(this);

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

	// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

	// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMsaDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CMsaDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);
	
	m_OKButton.SetWindowPos(&wndTop, (cx - 77), (cy - 26), 75, 25,
		SWP_NOOWNERZORDER);

	m_ConfigButton.SetWindowPos(&wndTop, (cx - 154), (cy - 26), 75, 25,
		SWP_NOOWNERZORDER);

	m_outputList.SetWindowPos(&wndTop, 2, 18, (cx - 4), (cy - 46),
		SWP_NOOWNERZORDER);
	
}

void CMsaDlg::OnConfigButton() 
{
	CConfigDialog *pDlg = new CConfigDialog(NULL, m_pVoidParent);
	pDlg->DoModal();

	delete pDlg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\msa.cpp ===
// msa.cpp : Defines the class behaviors for the application.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <wbemidl.h>
#include "stdafx.h"
#include "msa.h"
#include "consfactory.h"
#include "sinkobject.h"
#include "activatesink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMsaApp

BEGIN_MESSAGE_MAP(CMsaApp, CWinApp)
	//{{AFX_MSG_MAP(CMsaApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsaApp construction

CMsaApp::CMsaApp()
{
	m_pNamespace = NULL;
	for(int i = 0; i < 20; i++)
		m_pObjSink[i] = NULL;

	m_bRegistered = false;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMsaApp object

CMsaApp theApp;
bool g_bProviding = false;

/////////////////////////////////////////////////////////////////////////////
// CMsaApp initialization

BOOL CMsaApp::InitInstance()
{
	HRESULT hr;
	BOOL regEmpty = FALSE; // did a self-unregister happen?
	CConsumerFactory *m_consumerFactory = NULL;

	if(SUCCEEDED(CoInitialize(NULL))) 
		hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
			RPC_C_AUTHN_LEVEL_CONNECT,
			RPC_C_IMP_LEVEL_IDENTIFY, NULL, 0, 0);
	else
	{
		AfxMessageBox(_T("CoInitialize Failed"));
		return FALSE;
	}

	// Check the command line
	TCHAR tcTemp[128];
	TCHAR seps[] = _T(" ");
	TCHAR *token = NULL;
	WCHAR wcTemp[128];
	BSTR bstrConnect = SysAllocString(L"\\\\.\\root\\sampler");

	_tcscpy(tcTemp, (LPCTSTR)m_lpCmdLine);
	token = _tcstok( tcTemp, seps );
	while( token != NULL )
	{
		if((_tcscmp(token, _T("/CONNECT")) == 0) || (_tcscmp(token, _T("/connect")) == 0))
		{
			token = _tcstok( NULL, seps );
			MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, token, (-1),
								 wcTemp, 128);
			SysFreeString(bstrConnect);
			bstrConnect = SysAllocString(wcTemp);
		}
		/* Get next token: */
		token = _tcstok( NULL, seps );
	}

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	IWbemServices *pNamespace = NULL;
	IWbemClassObject *pObj1 = NULL;
	IEnumWbemClassObject *pEnum = NULL;
	ULONG uReturned;
	BSTR bstrPassword = SysAllocString(L"RelpMas1");
	BSTR bstrTargetNamespace = SysAllocString(L"TargetNamespace");
	VARIANT v;

	VariantInit(&v);

	// Create a dialog to appease the user durring log on
	CDialog *ldlg = new CDialog(IDD_LOAD_DIALOG, NULL);
	m_pMainWnd = ldlg;
	int bWorked = ldlg->Create(IDD_LOAD_DIALOG, NULL);

	// Create our main window so we ca work with it
	CMsaDlg *dlg = new CMsaDlg(NULL, (void *)this);

	// Let's create our user account...
	if(FAILED(hr = CreateUser()))
		TRACE(_T("* Creating User: %s\n"), ErrorString(hr));

	// Get a namespace pointer
	m_pNamespace = CheckNamespace(bstrConnect);

	if(m_pNamespace != NULL)
		m_bstrNamespace = SysAllocString(bstrConnect);
	else
		TRACE(_T("* No Namespace Connection @ App\n"));

	BSTR bstrNSQuery = SysAllocString(L"smpl_msaregistration");

	m_pNamespace->CreateInstanceEnum(bstrNSQuery, 0, NULL, &pEnum);

	WCHAR wcUser[100];
	WCHAR *pwcTmp = wcUser;
	BSTR bstrUser;

	wcscpy(wcUser, m_bstrNamespace);
	while(*pwcTmp == L'\\')
	{	pwcTmp++;	}
	if(*pwcTmp == L'.')
	{
		char cBuf[50];
		DWORD dwSize = 50;
		WCHAR wcUser[100];

		GetComputerName(cBuf, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuf, (-1), wcUser, 128);

		wcscat(wcUser, L"\\sampler");
		bstrUser = SysAllocString(wcUser);
	}
	else
	{
		WCHAR *pEnd = pwcTmp;
		while(*pEnd != L'\\')
		{	pEnd++;	}
		*pEnd = NULL;
		wcscat(pwcTmp, L"\\sampler");
		bstrUser = SysAllocString(pwcTmp);
	}

	SetInterfaceSecurity(pNamespace, NULL, bstrUser, bstrPassword);

	int i = 0;
	while(S_OK == (hr = pEnum->Next(INFINITE, 1, &pObj1, &uReturned)))
	{
		if(FAILED(pObj1->Get(bstrTargetNamespace, 0, &v, NULL, NULL)))
			TRACE(_T("* SelfProvide.Unable to get namespace"));

		pNamespace = CheckNamespace(V_BSTR(&v));

		VariantClear(&v);

		if(pNamespace != NULL)
		{
		// Get an object sink
			if(SUCCEEDED(hr = pNamespace->QueryObjectSink(0, &m_pObjSink[i])))
			{
				m_bRegistered = true;
				i++;
			}
			else
				TRACE(_T("* Error retrieving sink %s\n"), ErrorString(hr));
		}
		else
			TRACE(_T("* No Namespace Connection @ App\n"));

		pNamespace = NULL;
	}

	m_pMainWnd = NULL;
	delete ldlg;

	m_pMainWnd = dlg;
	dlg->DoModal();

	delete dlg;

	void *pTmp;
	CancelItem *pSinkItem;
	IWbemServices *pTmpNS = NULL;
	IWbemServices *pSamplerCancelNamespace = NULL;

	// Cleanup Cancel List
	while(!m_CancelList.IsEmpty())
	{
		pTmp = m_CancelList.RemoveTail();
		pSinkItem = (CancelItem *)pTmp;

		pTmpNS = CheckNamespace(pSinkItem->bstrNamespace);
		if(pTmpNS != NULL)
		{
			pTmpNS->QueryInterface(IID_IWbemServices, (void **)&pSamplerCancelNamespace);
			pSamplerCancelNamespace->CancelAsyncCall(pSinkItem->pSink);
			pSamplerCancelNamespace->Release();
			pSamplerCancelNamespace = NULL;
		}

		delete pSinkItem;
	}
	
	// Cleanup The Magic List
	void *pTheItem;

	while(!m_JunkList.IsEmpty())
	{
		pTheItem = m_JunkList.RemoveTail();
		delete pTheItem;
	}

	while(!m_NamespaceList.IsEmpty())
	{
		pTheItem = m_NamespaceList.RemoveTail();
		delete pTheItem;
	}

	if(m_pNamespace != NULL)
		m_pNamespace->Release();
	i = 0;
	while(m_pObjSink[i] != NULL)
	{
		m_pObjSink[i]->Release();
		i++;
	}

	CoRevokeClassObject(m_clsConsReg);
	CoRevokeClassObject(m_clsDistReg);

	CoUninitialize();

	SysFreeString(bstrTargetNamespace);
	SysFreeString(bstrUser);
	SysFreeString(bstrPassword);

	return FALSE;
}

HRESULT CMsaApp::ActivateNotification(CMsaDlg *dlg)
{
	HRESULT hr = WBEM_E_FAILED;
	IWbemServices *pNSSampler = NULL;
	BSTR bstrNamespace = SysAllocString(L"\\\\.\\root\\sampler");

	// Get a namespace pointer
	pNSSampler = CheckNamespace(bstrNamespace);

	if(pNSSampler != NULL)
	{
		CActiveSink *pActSink = new CActiveSink(this, pNSSampler, dlg);

		hr = pNSSampler->ExecQueryAsync(SysAllocString(L"WQL"),
			SysAllocString(L"select * from Smpl_Observation"), 0, NULL, pActSink);
		TRACE(_T("* Notification Complete: %s\n"), ErrorString(hr));

		AddToJunkList(pActSink);
	}
	else
		TRACE(_T("* Skipping Notification\n"));

	SysFreeString(bstrNamespace);

	return hr;
}

HRESULT CMsaApp::CreateUser(void)
{
	HRESULT hr;
	VARIANT v;
	IWbemServices *pSecurity = NULL;
	IWbemClassObject *pClass = NULL;
	IWbemLocator *pLocator = NULL;
	IWbemClassObject *pObj = NULL;
	BSTR bstrNamespace = SysAllocString(L"\\\\.\\root\\security");
	BSTR bstrNTLMUser = SysAllocString(L"__NTLMUser");
	BSTR bstrSERVER = SysAllocString(L"__SERVER");
	BSTR bstrName = SysAllocString(L"Name");
	BSTR bstrDomain = SysAllocString(L"Domain");
	BSTR bstrPermissions = SysAllocString(L"Permissions");
	BSTR bstrEnabled = SysAllocString(L"Enabled");
	BSTR bstrExecuteMethods = SysAllocString(L"ExecuteMethods");

	VariantInit(&v);

	// Get a namespace pointer
	// We aren't using CheckNamespace because we don't know if the user
	// has been created.  If not, CheckNamespace will break.
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
				 IID_IWbemLocator, (void **)&pLocator)))
	{
		if(FAILED(hr = pLocator->ConnectServer(bstrNamespace, NULL, NULL, NULL,
			0, NULL, NULL, &pSecurity)))
		{
			TRACE(_T("* Unable to connect to Namespace root\\security: %s\n"),
				ErrorString(hr));
			return hr;
		}
		SetInterfaceSecurity(pSecurity, NULL, NULL, NULL);

		pLocator->Release();
	}
	else
	{	
		TRACE(_T("* Failed to create Locator object: %s\n"), ErrorString(hr));
		return hr;
	}

	// Now we will create th user
	if(SUCCEEDED(hr = pSecurity->GetObject(bstrNTLMUser, 0, NULL, &pClass, NULL)))
	{
		hr = pClass->Get(bstrSERVER, 0, &v, NULL, NULL);

		hr = pClass->SpawnInstance(0, &pObj);
		pClass->Release();

		// We still have the server name in here
		hr = pObj->Put(bstrDomain, 0, &v, NULL);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v) = SysAllocString(L"sampler");
		hr = pObj->Put(bstrName, 0, &v, NULL);
		VariantClear(&v);

		V_VT(&v) = VT_I4;
		V_I4(&v) = 2;
		hr = pObj->Put(bstrPermissions, 0, &v, NULL);
		VariantClear(&v);

		V_VT(&v) = VT_BOOL;
		V_BOOL(&v) = TRUE;
		hr = pObj->Put(bstrEnabled, 0, &v, NULL);
		VariantClear(&v);

		V_VT(&v) = VT_BOOL;
		V_BOOL(&v) = TRUE;
		hr = pObj->Put(bstrExecuteMethods, 0, &v, NULL);
		VariantClear(&v);

		if(FAILED(pSecurity->PutInstance(pObj, WBEM_FLAG_CREATE_OR_UPDATE,
			NULL, NULL)))
			AfxMessageBox(_T("Error: Unable to create user account\nOnly local access will be possible"));
		
		pObj->Release();
	}

	SysFreeString(bstrNamespace);
	SysFreeString(bstrNTLMUser);
	SysFreeString(bstrSERVER);
	SysFreeString(bstrName);
	SysFreeString(bstrDomain);
	SysFreeString(bstrPermissions);
	SysFreeString(bstrEnabled);
	SysFreeString(bstrExecuteMethods);

	return hr;
}

///////////////////////////////////////////////////////
//    AddToNamespaceList                             //
//---------------------------------------------------//
//  Adds an item to the Namespace list for later     //
// retreival.  This is to reduce the number of       //
// Namespace pointer requests to a minimum.          //
///////////////////////////////////////////////////////
void CMsaApp::AddToNamespaceList(BSTR bstrNamespace, IWbemServices *pNewNamespace)
{
	NamespaceItem *pTheItem = new NamespaceItem;
	pTheItem->bstrNamespace = SysAllocString(bstrNamespace);
	pNewNamespace->QueryInterface(IID_IWbemServices, (void **)&pTheItem->pNamespace);
	m_NamespaceList.AddTail(pTheItem);
}

///////////////////////////////////////////////////////
//    AddToJunkList                                  //
//---------------------------------------------------//
//  Adds an item to the Namespace list for later     //
// retreival.  This is to reduce the number of       //
// Namespace pointer requests to a minimum.          //
///////////////////////////////////////////////////////
void CMsaApp::AddToJunkList(void *pTheItem)
{
	m_JunkList.AddTail(pTheItem);
}

///////////////////////////////////////////////////////
//    AddToCancelList                                //
//---------------------------------------------------//
//  Adds an item to the Cancelation list for later   //
// retreival.                                        //
///////////////////////////////////////////////////////
void CMsaApp::AddToCancelList(void *pTheItem)
{
	m_CancelList.AddTail(pTheItem);
}

///////////////////////////////////////////////////////
//    CheckNamespace                                 //
//---------------------------------------------------//
//  Checks to see if a namespace change is required, //
// and if it is performs the necessary change.       //
///////////////////////////////////////////////////////
IWbemServices * CMsaApp::CheckNamespace(BSTR wcItemNS)
{
	int iSize;
	POSITION pPos;	
	NamespaceItem *pTheItem;
	BSTR bstrNamespace = SysAllocString(wcItemNS);
	WCHAR *pwcStart = wcItemNS;
	WCHAR *pwcEnd;
	WCHAR wcNewNS[200];
	BSTR bstrUser;
	char cBuffer[200];
	DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
	WCHAR wcTemp[MAX_COMPUTERNAME_LENGTH + 1];
	int iBufSize = 200;

	// Parse the namespace to get the user and get it in a consistent format
	while(*pwcStart == L'\\')
	{	pwcStart++;	}
	if(*pwcStart == L'.')
	{
		GetComputerName(cBuffer, &dwSize);
		MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, cBuffer, (-1),
								 wcTemp, 128);

		pwcStart++;
		wcscpy(wcNewNS, L"\\\\");
		wcscat(wcNewNS, wcTemp);
		wcscat(wcNewNS, pwcStart);
		bstrNamespace = SysAllocString(wcNewNS);

		wcscpy(wcItemNS, wcTemp);
		wcscat(wcItemNS, L"\\sampler");
		bstrUser = SysAllocString(wcItemNS);
	}
	else
	{
		pwcEnd = pwcStart;
		while(*pwcEnd != L'\\')
		{	pwcEnd++;	}
		*pwcEnd = NULL;
		wcscat(pwcStart, L"\\sampler");
		bstrUser = SysAllocString(pwcStart);
	}

	iSize = m_NamespaceList.GetCount();
	for(int iPos = 0; iPos < iSize; iPos++)
	{
		pPos = m_NamespaceList.FindIndex(iPos);
		void *pTmp = m_NamespaceList.GetAt(pPos);
		pTheItem = (NamespaceItem *)pTmp;

		if(0 == wcscmp(bstrNamespace, pTheItem->bstrNamespace))
			return pTheItem->pNamespace;
	}

	IWbemServices *pNamespace = NULL;

	pNamespace = ConnectNamespace(bstrNamespace, bstrUser);

	// If we succeeded add it to the list
	if(pNamespace != NULL)
		AddToNamespaceList(bstrNamespace, pNamespace);

	SysFreeString(bstrUser);
	SysFreeString(bstrNamespace);

	return pNamespace;

}

///////////////////////////////////////////////////////
//    ConnectNamespace                               //
//---------------------------------------------------//
//  Connects to the specified namespace using default//
// security.                                         //
///////////////////////////////////////////////////////
IWbemServices * CMsaApp::ConnectNamespace(WCHAR *wcNamespace, WCHAR *wcUser)
{
	HRESULT hr;
	IWbemLocator *pLocator = NULL;
	IWbemServices *pNamespace = NULL;
	BSTR bstrNamespace = SysAllocString(wcNamespace);
	BSTR bstrUser = SysAllocString(wcUser);
	BSTR bstrPassword = SysAllocString(L"RelpMas1");
	char cBuffer[100];
	int iBufSize = 100;

	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
				 IID_IWbemLocator, (void **)&pLocator)))
	{
		if(FAILED(hr = pLocator->ConnectServer(bstrNamespace, 
			bstrUser, bstrPassword, NULL, 0, NULL, NULL, &pNamespace)))
		{
			WideCharToMultiByte(CP_OEMCP, 0, bstrNamespace, (-1), cBuffer,
				iBufSize, NULL, NULL);
			TRACE(_T("* Unable to connect to Namespace %s: %s\n"), cBuffer, ErrorString(hr));
			return NULL;
		}
		else
		{
			WideCharToMultiByte(CP_OEMCP, 0, bstrNamespace, (-1), cBuffer,
				iBufSize, NULL, NULL);
			TRACE(_T("* Connected to Namespace %s: %s\n"), cBuffer, ErrorString(hr));

			SetInterfaceSecurity(pNamespace, NULL, bstrUser, bstrPassword);
		}
		
		pLocator->Release();
	}
	else
	{	
		TRACE(_T("* Failed to create Locator object: %s\n"), ErrorString(hr));
		return NULL;
	}

	SysFreeString(bstrNamespace);
	SysFreeString(bstrUser);
	SysFreeString(bstrPassword);

	return pNamespace;
}

HRESULT CMsaApp::SelfProvideEvent(IWbemClassObject *pObj, WCHAR* wcServerNamespace,
								  BSTR bstrType)
{
	IWbemClassObject *pNewInst = NULL;
	IWbemClassObject *pClass = NULL;
	VARIANT v, vDisp;
	WCHAR dbuffer [9];
	WCHAR tbuffer [9];
	WCHAR wcTimeStamp[19];
	HRESULT hr;
	BSTR bstrSmplIncident = SysAllocString(L"Smpl_Incident");

	TRACE(_T("* SelfProvideEvent called\n"));

	VariantInit(&v);
	VariantInit(&vDisp);

	if(!m_bRegistered)
	{
		TRACE(_T("* Not connected to namespace\n"));
		return WBEM_E_FAILED;
	}

	_wstrdate(dbuffer);
	_wstrtime(tbuffer);

	wcscpy(wcTimeStamp, dbuffer);
	wcscat(wcTimeStamp, L" ");
	wcscat(wcTimeStamp, tbuffer);	

	// Get the Smpl_Incident class
	if(SUCCEEDED(hr = m_pNamespace->GetObject(bstrSmplIncident, 0, NULL, &pClass, NULL)))
	{	
	
	// Spawn an instance for population
		if(SUCCEEDED(hr = pClass->SpawnInstance(0, &pNewInst)))
		{
		// Put the Event (as an IDispatch *) into the new instance
			BSTR bstrEvt = SysAllocString(L"TheEvent");

			V_VT(&vDisp) = VT_DISPATCH;
			V_DISPATCH(&vDisp) = (IDispatch *)pObj;
			if(FAILED(hr = pNewInst->Put(bstrEvt, 0, &vDisp, NULL)))
				TRACE(_T("* Put(TheEvent) Failed %s\n"), ErrorString(hr));

			SysFreeString(bstrEvt);

		// Put the incident type into the new instance
			BSTR bstrIncTyp = SysAllocString(L"IncidentType");

			VariantClear(&v);
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = SysAllocString(bstrType);
			if(FAILED(hr = pNewInst->Put(bstrIncTyp, 0, &v, NULL)))
				TRACE(_T("* Put(IncidentType) Failed %s\n"), ErrorString(hr));

			SysFreeString(bstrIncTyp);

		// Get the time stamp and put it in the new instance
			BSTR bstrIncTim = SysAllocString(L"TimeOfIncident");

			VariantClear(&v);
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = wcTimeStamp;
			if(FAILED(hr = pNewInst->Put(bstrIncTim, 0L, &v, NULL)))
				TRACE(_T("* Put(TimeOfIncident) Failed %s\n"), ErrorString(hr));

			SysFreeString(bstrIncTim);

		// Put ServerNamespace
			BSTR bstrSrvNms = SysAllocString(L"ServerNamespace");

			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = SysAllocString(wcServerNamespace);
			if(FAILED(hr = pNewInst->Put(bstrSrvNms, 0, &v, NULL)))
				TRACE(_T("* Put(ServerNamespace) Failed %s\n"), ErrorString(hr));

			SysFreeString(bstrSrvNms);

			int i = 0;
			while(m_pObjSink[i] != NULL)
			{
			// Indicate and release the object
				if(FAILED(hr = m_pObjSink[i++]->Indicate(1, &pNewInst)))
					TRACE(_T("* Indicate() Failed %s\n"), ErrorString(hr));
			}

		// A little cleanup
			if(FAILED(hr = pNewInst->Release()))
				TRACE(_T("* pNewInst->Release() Failed %s\n"), ErrorString(hr));

			VariantClear(&v);
			VariantClear(&vDisp);
		}
		else
			TRACE(_T("* SpawnInstance(Smpl_Incident) Failed %s\n"), ErrorString(hr));

		if(FAILED(hr = pClass->Release()))
			TRACE(_T("* pClass->Release() Failed %s\n"), ErrorString(hr));
	}	
	else
		TRACE(_T("* Get(Smpl_Incident) Failed %s\n"), ErrorString(hr));

	SysFreeString(bstrSmplIncident);
	return WBEM_NO_ERROR;
}

void CMsaApp::InternalError(HRESULT hr, TCHAR *tcMsg)
{
	TRACE(tcMsg, ErrorString(hr));
	AfxMessageBox(_T("Error: An internal error has prevented this operation from completing."));
}

#define TCHAR_LEN_IN_BYTES(str)	 _tcslen(str)*sizeof(TCHAR)+sizeof(TCHAR)

//***************************************************************************
//
//  SCODE DetermineLoginType
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the 
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  ConnType            Returned with the connection type, ie wbem, ntlm
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CMsaApp::DetermineLoginType(BSTR & AuthArg, BSTR & UserArg,
								  BSTR & Authority,BSTR & User)
{

    // Determine the connection type by examining the Authority string

    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return WBEM_E_INVALID_PARAMETER;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(Authority && wcslen(Authority) > 11) 
    {
        if(pSlashInUser)
            return WBEM_E_INVALID_PARAMETER;

        AuthArg = SysAllocString(Authority + 11);
        if(User) UserArg = SysAllocString(User);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        int iDomLen = pSlashInUser-User;
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);

    return S_OK;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pDomain             Input, domain
//  pUser               Input, user name
//  pPassword           Input, password.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT CMsaApp::SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority,
									  LPWSTR pUser, LPWSTR pPassword)
{
    
    SCODE sc;
    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
        return SetInterfaceSecurity(pInterface, NULL);

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    
    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL;
    sc = DetermineLoginType(AuthArg, UserArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

    // Fill in the indentity structure

    if(UserArg)
    {
        wcstombs(szUser, UserArg, MAX_PATH);
        authident.UserLength = strlen(szUser);
        authident.User = (LPWSTR)szUser;
    }
    else
    {
        authident.UserLength = 0;
        authident.User = 0;
    }
    if(AuthArg)
    {
        wcstombs(szAuthority, AuthArg, MAX_PATH);
        authident.DomainLength = strlen(szAuthority);
        authident.Domain = (LPWSTR)szAuthority;
    }
    else
    {
        authident.DomainLength = 0;
        authident.Domain = 0;
    }
    if(pPassword)
    {
        wcstombs(szPassword, pPassword, MAX_PATH);
        authident.PasswordLength = strlen(szPassword);
        authident.Password = (LPWSTR)szPassword;
    }
    else
    {
        authident.PasswordLength = 0;
        authident.Password = 0;
    }
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    sc = SetInterfaceSecurity(pInterface, &authident);

    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    return sc;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pauthident          Structure with the identity info already set.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CMsaApp::SetInterfaceSecurity(IUnknown * pInterface,
									  COAUTHIDENTITY * pauthident)
{

    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    SCODE sc;
    IClientSecurity * pCliSec = NULL;
    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
        return sc;

    sc = pCliSec->SetBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IDENTIFY, 
        pauthident,
        EOAC_NONE);
    pCliSec->Release();
    return sc;
}


// **************************************************************************
//
//	ErrorString()
//
// Description:
//		Converts an HRESULT to a displayable string.
//
// Parameters:
//		hr (in) - HRESULT to be converted.
//
// Returns:
//		ptr to displayable string.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
LPCTSTR CMsaApp::ErrorString(HRESULT hr)
{
    TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

    switch(hr) 
    {
    case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
    case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
    case WBEM_S_ALREADY_EXISTS:
        psz = _T("WBEM_S_ALREADY_EXISTS");
        break;
    case WBEM_S_RESET_TO_DEFAULT:
        psz = _T("WBEM_S_RESET_TO_DEFAULT");
        break;
    case WBEM_S_DIFFERENT:
        psz = _T("WBEM_S_DIFFERENT");
        break;
    case WBEM_E_OVERRIDE_NOT_ALLOWED:
        psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
        break;
    case WBEM_E_PROPAGATED_QUALIFIER:
        psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
        break;
    case WBEM_E_PROPAGATED_PROPERTY:
        psz = _T("WBEM_E_PROPAGATED_PROPERTY");
        break;
    case WBEM_E_UNEXPECTED:
        psz = _T("WBEM_E_UNEXPECTED");
        break;
    case WBEM_E_ILLEGAL_OPERATION:
        psz = _T("WBEM_E_ILLEGAL_OPERATION");
        break;
    case WBEM_E_CANNOT_BE_KEY:
        psz = _T("WBEM_E_CANNOT_BE_KEY");
        break;
    case WBEM_E_INCOMPLETE_CLASS:
        psz = _T("WBEM_E_INCOMPLETE_CLASS");
        break;
    case WBEM_E_INVALID_SYNTAX:
        psz = _T("WBEM_E_INVALID_SYNTAX");
        break;
    case WBEM_E_NONDECORATED_OBJECT:
        psz = _T("WBEM_E_NONDECORATED_OBJECT");
        break;
    case WBEM_E_READ_ONLY:
        psz = _T("WBEM_E_READ_ONLY");
        break;
    case WBEM_E_PROVIDER_NOT_CAPABLE:
        psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
        break;
    case WBEM_E_CLASS_HAS_CHILDREN:
        psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
        break;
    case WBEM_E_CLASS_HAS_INSTANCES:
        psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
        break;
    case WBEM_E_QUERY_NOT_IMPLEMENTED:
        psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
        break;
    case WBEM_E_ILLEGAL_NULL:
        psz = _T("WBEM_E_ILLEGAL_NULL");
        break;
    case WBEM_E_INVALID_QUALIFIER_TYPE:
        psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
        break;
    case WBEM_E_INVALID_PROPERTY_TYPE:
        psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
        break;
    case WBEM_E_VALUE_OUT_OF_RANGE:
        psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
        break;
    case WBEM_E_CANNOT_BE_SINGLETON:
        psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
        break;
	case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
	default:
        _itot(hr, szBuffer2, 16);
        _tcscat(szBuffer, szBuffer2);
        psz = szBuffer;
	    break;
	}
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes

//	WBEMPermEvents.pch will be the pre-compiled header

//	stdafx.obj will contain the pre-compiled type information

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\msadlg.h ===
// msadlg.h : header file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#if !defined(AFX_MSADLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
#define AFX_MSADLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CMsaDlg dialog

class CMsaDlg : public CDialog
{
// Construction
public:
	CMsaDlg(CWnd* pParent = NULL, void *pVoid =NULL);	// standard constructor

	void *m_pVoidParent;

// Dialog Data
	//{{AFX_DATA(CMsaDlg)
	enum { IDD = IDD_MSA_DIALOG };
	CButton	m_ConfigButton;
	CButton	m_OKButton;
	CListBox	m_outputList;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsaDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMsaDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnConfigButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSADLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\resource.h ===
//{{NO_DEPENDENCIES}}

// Microsoft Developer Studio generated include file.

// Used by msa.rc

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MSA_DIALOG                  102
#define IDD_LOAD_DIALOG                 103
#define IDD_CONFIG_DIALOG               104
#define IDD_ADDFILTER_DIALOG            105
#define IDD_ADDNS_DIALOG                106
#define IDC_OUTPUTLIST                  107
#define IDC_CONFIG_BUTTON               108
#define IDC_NAMESPACE_COMBO             109
#define IDC_NS_ADD_BUTTON               110
#define IDC_NS_REMOVE_BUTTON            111
#define IDC_FILTER_LIST                 112
#define IDC_ADD_BUTTON                  113
#define IDC_REMOVE_BUTTON               114
#define IDC_EDIT2                       115
#define IDC_EDIT1                       116

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\stdafx.h ===
// stdafx.h : include file for standard system include files,

//  or project specific include files that are used frequently, but

//      are changed infrequently

//

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#if !defined(AFX_STDAFX_H__BD8F08F5_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
#define AFX_STDAFX_H__BD8F08F5_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_

#if !defined(_WIN32_DCOM)
#define _WIN32_DCOM
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <wbemcli_i.c>
#include <wbemprov_i.c>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BD8F08F5_77F0_11D1_A9D5_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\sinkobject.h ===
// sinkobject.h: interface for the CSinkObject class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SINKOBJECT_H__C78740E1_6CD3_11D1_A9B7_0060081EBBAD__INCLUDED_)
#define AFX_SINKOBJECT_H__C78740E1_6CD3_11D1_A9B7_0060081EBBAD__INCLUDED_

#include <wbemidl.h>
#include "msa.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CSinkObject : public IWbemObjectSink
{
public:
	CSinkObject(CListBox	*pOutputList, CMsaApp *pTheApp, BSTR bstrType);
	virtual ~CSinkObject();

	// IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);
private:
	DWORD m_cRef;
    HRESULT m_hres;
    IWbemClassObject *m_pErrorObj;

	CListBox	*m_pOutputList;
	BSTR m_bstrIncidentType;
	CMsaApp *m_pParent;
	IWbemServices *m_pNamespace;
};

#endif // !defined(AFX_SINKOBJECT_H__C78740E1_6CD3_11D1_A9B7_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\msa\sinkobject.cpp ===
// sinkobject.cpp: implementation of the CSinkObject class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "sinkobject.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSinkObject::CSinkObject(CListBox *pOutputList, CMsaApp *pTheApp, BSTR bstrType)
{
	m_pParent = pTheApp;
	m_cRef = 0;
	m_pOutputList = pOutputList;
	m_bstrIncidentType = SysAllocString(bstrType);
}

CSinkObject::~CSinkObject()
{

}

STDMETHODIMP CSinkObject::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSinkObject::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSinkObject::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CSinkObject::Indicate(long lObjectCount,
								   IWbemClassObject **ppObjArray)
{
	HRESULT  hRes;
	CString clMyBuff;
	VARIANT vType, vDisp, vClass, vName, vServ;
	IDispatch *pDisp = NULL;
	IWbemClassObject *tgtInst = NULL;
	LPVOID *ppObject = NULL;
	WCHAR wcServerNamespace[50];
	BSTR bstrNAMESPACE = SysAllocString(L"__NAMESPACE");
	BSTR bstrSERVER = SysAllocString(L"__SERVER");
	BSTR bstrCLASS = SysAllocString(L"__CLASS");

	VariantInit(&vType);
	VariantInit(&vClass);
	VariantInit(&vDisp);
	VariantInit(&vName);
	VariantInit(&vServ);

	TRACE(_T("* SinkObject.Indicate() called\n"));

	for(int i = 0; i < lObjectCount; i++)
	{
		clMyBuff.Empty();

	// Get the server and namespace info
		if(FAILED(hRes = ppObjArray[i]->Get(bstrNAMESPACE, 0, &vName, NULL, NULL)))
			TRACE(_T("* Get(__NAMESPACE) Failed\n"));
		if(FAILED(hRes = ppObjArray[i]->Get(bstrSERVER, 0, &vServ, NULL, NULL)))
			TRACE(_T("* Get(__SERVER) Failed\n"));

		wcscpy(wcServerNamespace, L"\\\\");
		wcscat(wcServerNamespace, V_BSTR(&vServ));
		wcscat(wcServerNamespace, L"\\");
		wcscat(wcServerNamespace, V_BSTR(&vName));

		if(FAILED(hRes = ppObjArray[i]->AddRef()))
			TRACE(_T("* ppObjArray[i]->AddRef() Failed%s\n"), m_pParent->ErrorString(hRes));

	// sent the object to CIMOM via the sink
		if(FAILED(hRes = m_pParent->SelfProvideEvent(ppObjArray[i], wcServerNamespace,
			m_bstrIncidentType)))
			TRACE(_T("* SelfProvideEvent returned badness %s\n"), m_pParent->ErrorString(hRes));

		if(SUCCEEDED(hRes = ppObjArray[i]->Get(bstrCLASS, 0L, &vClass, NULL, NULL)))
		{					
			clMyBuff = _T("{");
			clMyBuff += m_bstrIncidentType;
			clMyBuff += _T("}  ");
			clMyBuff += V_BSTR(&vClass);

			m_pOutputList->InsertString(0, clMyBuff);
		}
		else
			TRACE(_T("* Get(__CLASS) Item failed %s\n"), m_pParent->ErrorString(hRes));
	} // endfor

	SysFreeString(bstrNAMESPACE);
	SysFreeString(bstrSERVER);
	SysFreeString(bstrCLASS);


	return WBEM_NO_ERROR;
}

STDMETHODIMP CSinkObject::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{
	m_hres = lParam;
	if(FAILED(m_hres))
	{
		char cBuffer[100];
		int iBufSize = 100;

		WideCharToMultiByte(CP_OEMCP, 0, m_bstrIncidentType, (-1), cBuffer,
			iBufSize, NULL, NULL);
		TRACE(_T("* Error in SinkObject.SetStatus()\n\tfor %s: %s\n"),
			m_pParent->ErrorString(m_hres));
	}
	if(pObjParam)
		pObjParam->AddRef();

	return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\ethrex.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ethrex.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ethrex.h"
#include "ethrexDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEthrexApp

BEGIN_MESSAGE_MAP(CEthrexApp, CWinApp)
	//{{AFX_MSG_MAP(CEthrexApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEthrexApp construction

CEthrexApp::CEthrexApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEthrexApp object

CEthrexApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEthrexApp initialization

BOOL CEthrexApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CEthrexDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\ethrex.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ethrex.h : main header file for the ETHREX application
//

#if !defined(AFX_ETHREX_H__80D90C02_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_)
#define AFX_ETHREX_H__80D90C02_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CEthrexApp:
// See ethrex.cpp for the implementation of this class
//

class CEthrexApp : public CWinApp
{
public:
	CEthrexApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEthrexApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CEthrexApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ETHREX_H__80D90C02_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ethrex.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_ETHREX_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDB_BITMAP1                     129
#define IDC_NOTICE                      130
#define IDB_BITMAP2                     130
#define IDB_BITMAP3                     131
#define IDD_WAIT                        132
#define IDB_BITMAP4                     134
#define IDB_PANEL                       134
#define IDB_CONN                        135
#define IDB_DISC                        136
#define IDC_MINIMIZE                    1000
#define IDC_CONN_EVENT                  1001
#define IDC_DISC_EVENT                  1002
#define IDC_WINHEC                      1003
#define IDC_CUPNSTRING                  1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\ethrexdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ethrexDlg.h : header file
//

#if !defined(AFX_ETHREXDLG_H__80D90C04_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_)
#define AFX_ETHREXDLG_H__80D90C04_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "ndisstat.h"

/////////////////////////////////////////////////////////////////////////////
// CEthrexDlg dialog

class CEthrexDlg : public CDialog
{
// Construction
public:
	CEthrexDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CEthrexDlg)
	enum { IDD = IDD_ETHREX_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEthrexDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CEthrexDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnMinimize();
	afx_msg void OnConnEvent();
	afx_msg void OnDiscEvent();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CEventNotify *m_pEvtn;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ETHREXDLG_H__80D90C04_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\ndisstat.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//==============================================================================
//	NDISSTAT.H
//==============================================================================

#ifndef _NDISSTAT_H_
#define _NDISSTAT_H_

#include <wbemidl.h>


#define CONNECT_EVENT		0
#define DISCONNECT_EVENT	1

#define MAX_EVENTS			2

class CEventSink : public IWbemObjectSink
{
    UINT m_cRef;

public:
    CEventSink( ULONG ulContext1, ULONG ulContext2, ULONG ulContext3 ) \
		{ m_cRef = 1; m_ulContext1 = ulContext1; m_ulContext2 = ulContext2; m_ulContext3 = ulContext3; }
   ~CEventSink() { }

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Indicate(
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray
            );

    virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetStatus(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
            );
private:
	ULONG m_ulContext1;
	ULONG m_ulContext2;
	ULONG m_ulContext3;
};


class CEventNotify
{
	public:
		CEventNotify();
		~CEventNotify( );
		HRESULT InitWbemServices( BSTR Namespace );
		HRESULT EnableWbemEvent( ULONG ulEventId );
		HRESULT EnableWbemEvent( ULONG ulEventId, ULONG ulContext1, ULONG ulContext2 );
		HRESULT DisableWbemEvent( ULONG ulEventId );

	private:
		void InitSecurity( void );

	private:
		//IWbemLocator		*m_pLoc;
		IWbemServices		*m_pSvc;
		IWbemObjectSink		*m_pSink[MAX_EVENTS];

};

#endif // _NDISSTAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\ethrexdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ethrexDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ethrex.h"
#include "ethrexDlg.h"
#include "waitdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEthrexDlg dialog

CEthrexDlg::CEthrexDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEthrexDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEthrexDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_pEvtn = NULL;
}

void CEthrexDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEthrexDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CEthrexDlg, CDialog)
	//{{AFX_MSG_MAP(CEthrexDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_MINIMIZE, OnMinimize)
	ON_BN_CLICKED(IDC_CONN_EVENT, OnConnEvent)
	ON_BN_CLICKED(IDC_DISC_EVENT, OnDiscEvent)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEthrexDlg message handlers

BOOL CEthrexDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// Initialize WMI notification for NDIS connect events
	m_pEvtn = new CEventNotify;
	if ( m_pEvtn )
	{
		CWaitDlg wdlg;

		BSTR Namespace = SysAllocString( L"\\\\.\\root\\WMI" );

		wdlg.Create( IDD_WAIT, this );
		m_pEvtn->InitWbemServices( Namespace );
		wdlg.DestroyWindow();
		SysFreeString( Namespace );

		// create an auto-resetting event for a delay object
		HANDLE hNotice = CreateEvent( NULL, FALSE, FALSE, NULL );
		SetWindowLong( m_hWnd, DWL_USER, (long) hNotice );

		// enable notification for both events
		CheckDlgButton( IDC_CONN_EVENT, 1 );
		OnConnEvent( );
		CheckDlgButton( IDC_DISC_EVENT, 1 );
		OnDiscEvent( );
	}
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CEthrexDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CEthrexDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width()  - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CEthrexDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CEthrexDlg::OnMinimize() 
{
	ShowWindow( SW_MINIMIZE );
}

// set enablement for connect status
void CEthrexDlg::OnConnEvent() 
{
	if ( IsDlgButtonChecked( IDC_CONN_EVENT ) )
	{
		m_pEvtn->EnableWbemEvent( CONNECT_EVENT, (ULONG) m_hWnd, IDC_CUPNSTRING );
	}
	else
	{
		m_pEvtn->DisableWbemEvent( CONNECT_EVENT );
	}
}

// set enablement for disconnect status
void CEthrexDlg::OnDiscEvent() 
{
	if ( IsDlgButtonChecked( IDC_DISC_EVENT ) )
	{
		m_pEvtn->EnableWbemEvent( DISCONNECT_EVENT, (ULONG) m_hWnd, IDC_CUPNSTRING );
	}
	else
	{
		m_pEvtn->DisableWbemEvent( DISCONNECT_EVENT );
	}
}

// disable current WMI events and destroy notify object
BOOL CEthrexDlg::DestroyWindow() 
{
	if ( IsDlgButtonChecked( IDC_CONN_EVENT ) )
	{
		m_pEvtn->DisableWbemEvent( CONNECT_EVENT );
	}

	if ( IsDlgButtonChecked( IDC_DISC_EVENT ) )
	{
		m_pEvtn->DisableWbemEvent( DISCONNECT_EVENT );
	}

	if ( m_pEvtn )
	{
		delete m_pEvtn;
	}

	CloseHandle( (HANDLE) GetWindowLong( m_hWnd, DWL_USER ) );

	return CDialog::DestroyWindow();
}


BOOL CEthrexDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	if ( HIWORD( wParam ) == IDC_CUPNSTRING )
	{
		HBITMAP hPanel, hNotice;
	
		if ( IsIconic( ) )
		{
			ShowWindow( SW_SHOWNORMAL );
		}
		hNotice = LoadBitmap( GetModuleHandle( NULL ),
					MAKEINTRESOURCE( lParam == DISCONNECT_EVENT ? IDB_DISC : IDB_CONN ) );
		hPanel  = (HBITMAP) SendDlgItemMessage( IDC_CUPNSTRING, STM_GETIMAGE, IMAGE_BITMAP, 0 );
		SendDlgItemMessage( IDC_CUPNSTRING, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hNotice );
		MessageBeep( -1 );
		// Wait a second before restoring the banner picture
		WaitForSingleObject( (HANDLE) GetWindowLong( m_hWnd, DWL_USER ), 1000 );
		SendDlgItemMessage( IDC_CUPNSTRING, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hPanel );
		DeleteObject( hNotice );
		
		return TRUE;
	}
	
	return CDialog::OnCommand(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__80D90C06_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_)
#define AFX_STDAFX_H__80D90C06_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__80D90C06_AE24_11D1_B04C_00C04FB94FBD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\waitdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WaitDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ethrex.h"
#include "WaitDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg dialog


CWaitDlg::CWaitDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWaitDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWaitDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CWaitDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWaitDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWaitDlg, CDialog)
	//{{AFX_MSG_MAP(CWaitDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\ndisstat.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//==============================================================================
//
//  NDISSTAT.CPP
//
//  This contains two classes which implement a temporary event consumer for
//	the NDIS connect status events.
//
//==============================================================================

#include "stdafx.h"
#include "ndisstat.h"

// Query list to NdisStatus notifications
WCHAR *Queries[] =
{
	L"select * from NdisStatusMediaConnect",
	L"select * from NdisStatusMediaDisconnect"
};

//==============================================================================
//
//==============================================================================

STDMETHODIMP CEventSink::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if ( IID_IUnknown == riid || IID_IWbemObjectSink == riid )
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef( );
        return NOERROR;
    }

    return E_NOINTERFACE;
}


//==============================================================================
//
//==============================================================================

ULONG CEventSink::AddRef( )
{
    return ++m_cRef;
}


//==============================================================================
//
//==============================================================================

ULONG CEventSink::Release( )
{
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


//==============================================================================
//
//==============================================================================

HRESULT CEventSink::Indicate(
    long lObjectCount,
    IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray
    )
{
	if ( lObjectCount > 0 )
    {
		// Only expecting one, if more ignore them
        IWbemClassObject *pObj = ppObjArray[0];
        
		PostMessage( (HWND) m_ulContext1, WM_COMMAND, MAKELONG( 0, (WORD) m_ulContext2 ), m_ulContext3 );
    }

    return WBEM_NO_ERROR;
}


//==============================================================================
//
//==============================================================================

HRESULT CEventSink::SetStatus(
    long lFlags,
    HRESULT hResult,
    BSTR strParam,
    IWbemClassObject __RPC_FAR *pObjParam
    )
{
    // Not called during event delivery.
        
    return WBEM_NO_ERROR;
}


//==============================================================================
//
//==============================================================================

CEventNotify::CEventNotify( )
{
	long i;

	m_pSvc = NULL;
	for ( i = 0; i < MAX_EVENTS; i++ )
	{
		m_pSink[i] = NULL;
	}
}


//==============================================================================
//
//==============================================================================

CEventNotify::~CEventNotify( )
{
	long i;

	for ( i = 0; i < MAX_EVENTS; i++ )
	{
		DisableWbemEvent( i );
	}
	if ( m_pSvc )
	{
		m_pSvc->Release( );
	}

	CoUninitialize( );
}


//==============================================================================
//
//==============================================================================

HRESULT CEventNotify::EnableWbemEvent( ULONG ulEventId, ULONG ulContext1, ULONG ulContext2 )
{
	HRESULT hr = WBEM_E_FAILED;

    if ( m_pSvc && ulEventId < MAX_EVENTS )
	{
		m_pSink[ulEventId] = new CEventSink( ulContext1, ulContext2, ulEventId );
		if ( m_pSink[ulEventId] )
		{
			BSTR query = SysAllocString( Queries[ulEventId] );
			BSTR lang  = SysAllocString( L"WQL" );

		    hr = m_pSvc->ExecNotificationQueryAsync(
		    					lang,
								query,
								0L,
								NULL,
								m_pSink[ulEventId]
								);

			SysFreeString( lang );
			SysFreeString( query );
		}
	}

	return hr;
}


//==============================================================================
//
//==============================================================================

HRESULT CEventNotify::DisableWbemEvent( ULONG ulEventId )
{
	HRESULT hr = WBEM_E_FAILED;

    if ( m_pSvc && ulEventId < MAX_EVENTS )
	{
		if ( m_pSink[ulEventId] )
		{
			hr = m_pSvc->CancelAsyncCall( m_pSink[ulEventId] );
			m_pSink[ulEventId]->Release( );
			m_pSink[ulEventId] = NULL;
		}
	}

	return hr;
}


//==============================================================================
//
//==============================================================================

HRESULT CEventNotify::InitWbemServices( BSTR Namespace )
{
    HRESULT hr;

    hr = CoInitializeEx( 0, COINIT_MULTITHREADED );

    if ( hr == S_OK )
	{
		IWbemLocator *pLoc = NULL;

		InitSecurity( );

    	DWORD dwRes = CoCreateInstance( CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
        	    IID_IWbemLocator, (LPVOID *) &pLoc );

		if ( pLoc )
		{
		    hr = pLoc->ConnectServer(
		            Namespace,
		            NULL,
		            NULL,
		            0,
		            0,
		            0,
		            0,
		            &m_pSvc
		            );

			pLoc->Release( );
		}
	}

	return hr;
}


//==============================================================================
//
//==============================================================================

void CEventNotify::InitSecurity( void )
{
    UINT    uSize;
    BOOL    bRetCode = FALSE;

	// find the system directory.
    LPTSTR   pszSysDir = new TCHAR[MAX_PATH + 10];

    if(pszSysDir == NULL)
        return;

    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);

    if(uSize > MAX_PATH) 
	{
        delete[] pszSysDir;
        pszSysDir = new TCHAR[ uSize +10 ];
        if(pszSysDir == NULL)
            return;
        uSize = GetSystemDirectory(pszSysDir, uSize);
    }

	// manually load the ole32.dll
    lstrcat(pszSysDir, TEXT("\\ole32.dll"));

    HINSTANCE hOle32 = LoadLibraryEx(pszSysDir, NULL, 0);
	HRESULT (STDAPICALLTYPE *g_pfnCoInitializeSecurity)(PSECURITY_DESCRIPTOR pVoid,
														DWORD cAuthSvc,
														SOLE_AUTHENTICATION_SERVICE * asAuthSvc, 
														void * pReserved1,
														DWORD dwAuthnLevel,
														DWORD dwImpLevel,
														RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
														DWORD dwCapabilities,
														void * pvReserved2 );

    delete[] pszSysDir;

    if(hOle32 != NULL) 
	{
        (FARPROC&)g_pfnCoInitializeSecurity = GetProcAddress(hOle32, "CoInitializeSecurity");

		// if it exports CoInitializeSecurity then DCOM is installed.
        if(g_pfnCoInitializeSecurity != NULL) 
		{
			// NOTE: This is needed to work around a security problem
			// when using IWBEMObjectSink. The sink wont normally accept
			// calls when the caller wont identify themselves. This
			// adjusts that process.
			HRESULT hres = g_pfnCoInitializeSecurity(NULL, -1, NULL, NULL, 
														RPC_C_AUTHN_LEVEL_CONNECT, 
														RPC_C_IMP_LEVEL_IDENTIFY, 
														NULL, 0, 0);
        } 
        FreeLibrary(hOle32);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	ethrex.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#define _WIN32_WINNT    0x0400

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\perfservframeworkprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Framework Instance provider 

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>
#include <WBEMGlue.h>

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{9bd799c3-2664-11d2-a2b5-0080c7be7f99}";
CLSID CLSID_WIN32_PERFORMANCESERVICE;

//Count number of objects and number of locks.

long       g_cLock=0;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

	CLSIDFromString(GUIDSTRING, &CLSID_WIN32_PERFORMANCESERVICE);
    if (CLSID_WIN32_PERFORMANCESERVICE!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL("WIN32_PERFORMANCESERVICE"))
	{
		sc = S_OK;
	}
	else
	{
		sc = S_FALSE;
	}
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "";
    char * pModel;
    HKEY hKey1, hKey2;

	ghModule = GetModuleHandle("perfserv");

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

//    if(Is4OrMore())
//        pModel = "Both";
//    else
        pModel = "Apartment";

    // Create the path.

	CLSIDFromString(GUIDSTRING, &CLSID_WIN32_PERFORMANCESERVICE);
    StringFromGUID2(CLSID_WIN32_PERFORMANCESERVICE, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

	CLSIDFromString(GUIDSTRING, &CLSID_WIN32_PERFORMANCESERVICE);
    StringFromGUID2(CLSID_WIN32_PERFORMANCESERVICE, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

BOOL APIENTRY DllMain (	HINSTANCE hInstDLL,	// handle to dll module
						DWORD fdwReason,	// reason for calling function
						LPVOID lpReserved	)	// reserved
{
    BOOL bRet = TRUE;
	
	// Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
			bRet = CWbemProviderGlue::FrameworkLoginDLL("WIN32_PERFORMANCESERVICE");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\ndisstatus\waitdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_WAITDLG_H__F4188458_CB36_11D1_B080_00C04FB94FBD__INCLUDED_)
#define AFX_WAITDLG_H__F4188458_CB36_11D1_B080_00C04FB94FBD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WaitDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg dialog

class CWaitDlg : public CDialog
{
// Construction
public:
	CWaitDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWaitDlg)
	enum { IDD = IDD_WAIT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWaitDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWaitDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WAITDLG_H__F4188458_CB36_11D1_B080_00C04FB94FBD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\reindeerprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WBEM Framework Instance provider 

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>
#include <WBEMGlue.h>

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{9a5dd473-d410-11d1-b829-00c04f94c7c3}";
CLSID CLSID_CIM_STORAGEERROR;

//Count number of objects and number of locks.

long       g_cLock=0;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

	CLSIDFromString(GUIDSTRING, &CLSID_CIM_STORAGEERROR);
    if (CLSID_CIM_STORAGEERROR!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"ReindeerProv"))
	{
		sc = S_OK;
	}
	else
	{
		sc = S_FALSE;
	}
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "Sample provider using the Provider Framework";
    char * pModel;
    HKEY hKey1, hKey2;

	ghModule = GetModuleHandle("ReindeerProv");

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

//    if(Is4OrMore())
//        pModel = "Both";
//    else
        pModel = "Apartment";

    // Create the path.

	CLSIDFromString(GUIDSTRING, &CLSID_CIM_STORAGEERROR);
    StringFromGUID2(CLSID_CIM_STORAGEERROR, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

	CLSIDFromString(GUIDSTRING, &CLSID_CIM_STORAGEERROR);
    StringFromGUID2(CLSID_CIM_STORAGEERROR, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

BOOL APIENTRY DllMain (	HINSTANCE hInstDLL,	// handle to dll module
						DWORD fdwReason,	// reason for calling function
						LPVOID lpReserved	)	// reserved
{
    BOOL bRet = TRUE;
	
	// Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
			bRet = CWbemProviderGlue::FrameworkLoginDLL(L"ReindeerProv");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\perfservframeworkprov\win32_performanceservice.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Win32_PerformanceService.CPP -- WMI provider class implementation
//
// Generated by Microsoft WMI Code Generation Engine
//
// TO DO: See individual function headers
//
// Description: 
//
//=================================================================

#include <fwcommon.h>  // This must be the first include.
#include <provider.h>

#include "Win32_PerformanceService.h"

// TO DO:	REPLACE "NameSpace" with the appropriate namespace for your
// 		provider instance.   For instance:  "root\\default or "root\\cimv2"
// 		This code will compile, but it WILL NOT APPEAR in the correct 
//	 	namespace until this is changed.
//===================================================================
CWin32_PerformanceService MyWin32_PerformanceServiceSet (PROVIDER_NAME_WIN32_PERFORMANCESERVICE, "root\\cimv2") ;

// Property names
//===============

const char* pFirstCounter = "FirstCounter" ;
const char* pLastCounter = "LastCounter" ;
const char* pLibrary = "Library" ;
const char* pName = "Name";


/*****************************************************************************
 *
 *  FUNCTION    :	CWin32_PerformanceService::CWin32_PerformanceService
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CWin32_PerformanceService::CWin32_PerformanceService (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CWin32_PerformanceService::~CWin32_PerformanceService
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CWin32_PerformanceService::~CWin32_PerformanceService ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO:	All instances on the machine should be returned here.
*				If there are no instances, return WBEM_S_NO_ERROR.
*				It is not an error to have no instances
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
	CInstance* pInstance;
	HRESULT hRes = WBEM_S_NO_ERROR;
	HKEY hServices;
	long lRes;
    DWORD dwMaxLen;

// TO DO:	The following commented lines contain the 'set' methods for the
//		properties entered for this class.   They are commented because they
//		will NOT compile in their current form.   Each <Property Value> should be
//		replaced with an appropriate value.
//
//		If the expectation is that there is more than one instance on the machine
//		EnumerateInstances should loop through the instances and fill them accordingly.
//
//		Note that you must ALWAYS set ALL the key properties.  See the docs for
//		further details.
///////////////////////////////////////////////////////////////////////////////

    // Open the registry key for services
    // ==================================

    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    "SYSTEM\\CurrentControlSet\\Services",
                    0, KEY_READ, &hServices);
    if(lRes)
        return WBEM_E_FAILED;


    // Determine maximum subkey length
    // ===============================

    lRes = RegQueryInfoKey(hServices, NULL, NULL, NULL, NULL, &dwMaxLen,
                            NULL, NULL, NULL, NULL, NULL, NULL);
    if(lRes)
	{
		RegCloseKey(hServices);
        return WBEM_E_FAILED;
	}


    // Enumerate all the subkeys of the Services key
    // =============================================

    DWORD dwIndex = 0;
    TCHAR* szKeyName = new TCHAR[dwMaxLen+1];
    DWORD dwNameLen = dwMaxLen + 1;

    while(RegEnumKeyEx(hServices, dwIndex++, szKeyName, &dwNameLen, NULL,
                        NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        // Construct our instance (if any) for this service
        // ================================================

		pInstance = CreateNewInstance(pMethodContext);
		if (pInstance)
		{
			if(ConstructInstance(hServices, szKeyName, pInstance))
				hRes = Commit(pInstance);
		}
		else
			hRes = WBEM_E_OUT_OF_MEMORY;

        dwNameLen = dwMaxLen + 1;
    }

	RegCloseKey(hServices);

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    : 
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::GetObject ( CInstance* pInstance, long lFlags )
{
	// TO DO:	The GetObject function is used to search for an instance of this
	//		class on the machine based on the key properties.   Unlike
	//		EnumerateInstances which finds all instances on the machine, GetObject
	//		uses the key properties to find the matching single instance and 
	//		returns that instance.    
	//
	//		Use the CInstance Get functions (GetCHString, etc) against pInstance to see
	//		the key values the client app requested.
	
	HKEY hServices;
	CHString sName;
	long lRes;
	
	//Get the key value
	//=================

	pInstance->GetCHString(pName, sName);

    // Open the registry key for services
    // ==================================

    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    "SYSTEM\\CurrentControlSet\\Services",
                    0, KEY_READ, &hServices);
    if(lRes)
        return WBEM_E_FAILED;

	//Construct the instance for this service if applicable
	//=====================================================

	if(ConstructInstance(hServices, sName, pInstance))
		return WBEM_S_NO_ERROR;

	RegCloseKey(hServices);

    return WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_NOT_SUPPORTED);
}

/*****************************************************************************
*
*  FUNCTION    : CWin32_PerformanceService::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_NOT_SUPPORTED, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::PutInstance ( const CInstance &Instance, long lFlags)
{
	return (WBEM_E_NOT_SUPPORTED);
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_NOT_SUPPORTED from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from Win32_PerformanceService.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::DeleteInstance ( const CInstance &Instance, long lFlags )
{
	return (WBEM_E_NOT_SUPPORTED);
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
	return (WBEM_E_NOT_SUPPORTED);
}


//////////////////////////////////////////////////////////////////
BOOL CWin32_PerformanceService::ConstructInstance(HKEY hServices, LPCTSTR szServiceName, 
														CInstance* pInstance)
{
    // Locate the service
    // ==================

    HKEY hService;
    if(RegOpenKeyEx(hServices, szServiceName, 0, KEY_READ, &hService))
        return FALSE;

    // Open its performance data
    // =========================

    HKEY hPerformance;
    if(RegOpenKeyEx(hService, _T("Performance"), 0, KEY_READ, &hPerformance))
    {
        // No performance subkey --- not our service
        // =========================================

        RegCloseKey(hService);
        return FALSE;
    }
   
    RegCloseKey(hService);

    
	// Fill in the key
    // ===============

	pInstance->SetCHString(pName, szServiceName);
	
//			pInstance->SetDWORD(pFirstCounter, <Property Value>);
//			pInstance->SetDWORD(pLastCounter, <Property Value>);
//			pInstance->SetCHString(pLibrary, <Property Value>);


    // Get the library name
    // ====================

    TCHAR szLibraryName[MAX_PATH];
    DWORD dwValLen = MAX_PATH;
    if(RegQueryValueEx(hPerformance, _T("Library"), NULL, NULL, 
                        (LPBYTE)szLibraryName, &dwValLen) == 0)
	{

        // Fill in the property
        // ====================

		pInstance->SetCHString(pLibrary, szLibraryName);
	};


    // Get the FirstCounter index
    // ==========================

    dwValLen = sizeof(DWORD);
	DWORD dwVal;
    if(RegQueryValueEx(hPerformance, _T("First Counter"), NULL, NULL, 
                        (LPBYTE)&dwVal, &dwValLen) == 0)
    {
        // Fill in the property
        // ====================

        pInstance->SetDWORD(pFirstCounter, dwVal);

    }
    
    // Get the LastCounter index
    // ==========================

    dwValLen = sizeof(DWORD);
    if(RegQueryValueEx(hPerformance, _T("Last Counter"), NULL, NULL, 
                        (LPBYTE)&dwVal, &dwValLen) == 0)
    {
        // Fill in the property
        // ====================

        pInstance->SetDWORD(pLastCounter, dwVal);

    }
    
    // Clean up
    // ========

    RegCloseKey(hPerformance);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\perfservframeworkprov\win32_performanceservice.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Win32_PerformanceService.H -- WMI provider class definition
//
// Generated by Microsoft WMI Code Generation Engine
//
// Description: 
//
//=================================================================

// Property set identification
//============================

#define PROVIDER_NAME_WIN32_PERFORMANCESERVICE "Win32_PerformanceService"

// Property name externs -- defined in Win32_PerformanceService.cpp
//=================================================

extern const char* pFirstCounter ;
extern const char* pLastCounter ;
extern const char* pLibrary ;

class CWin32_PerformanceService : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CWin32_PerformanceService(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CWin32_PerformanceService();

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );

		// TO DO: Declare any additional functions and accessor
		// functions for private data used by this class
		//===========================================================

	private:
		// All data members for CWin32_PerformanceService should be included here.   
		// Each private member should have a protected accessor

		// Helper Functions
		//=================

		BOOL ConstructInstance(HKEY hServices, LPCTSTR szServiceName, CInstance* pInstance);


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\reindeerprov\reindeerprov.h ===
/******************************************************************

   ReindeerProv.H -- WBEM provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   Sample provider using the Provider Framework

*******************************************************************/

// Property set identification
//============================

#define PROVIDER_NAME_REINDEERPROV L"Reindeer"

// Property name externs -- defined in ReindeerProv.cpp
//=================================================

extern const WCHAR* pName ;
extern const WCHAR* pRedNose ;
extern const WCHAR* pWeight ;

class CReindeer : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CReindeer(LPCWSTR chsClassName, LPCWSTR lpszNameSpace);
		virtual ~CReindeer();

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );

		// TO DO: Declare any additional functions and accessor
		// functions for private data used by this class
		//===========================================================

	private:
		// All data members for CReindeer should be included here.   
        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);

} ;

// struct to hold instance information
struct Deers
{
	WCHAR*    m_name;	// name of Reindeer
	DWORD    m_weight;  // weight of reindeer
	bool     m_redNose; // does he have a red nose?
	bool     m_deleted; // has he been deleted?

	enum {NDeers = 9};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\reindeerprov\reindeerprov.cpp ===
/******************************************************************

 Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
   ReindeerProv.CPP -- WBEM provider class implementation

   Generated by Microsoft WBEM Code Generation Engine
  
   TO DO: See individual function headers
  
   Description: 
   Sample provider using the Provider Framework
  
******************************************************************/

#include <fwcommon.h>  // This must be the first include.
#include "ReindeerProv.h"

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.   For instance:  "root\\default or "root\\cimv2".
//===================================================================
CReindeer MyReindeerProvSet (PROVIDER_NAME_REINDEERPROV, L"root\\default") ;

// Property names
//===============
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRedNose = L"RedNose" ;
const static WCHAR* pWeight = L"Weight" ;

// Sample data
// ===========
Deers ohDeers[Deers::NDeers] =
{
    // Name     Weight  Red Nose    Deleted flag
    {L"Dasher",  200,    false,      false},
    {L"Dancer",  150,    false,      false},
    {L"Prancer", 162,    false,      false},
    {L"Vixen",   125,    false,      false},
    {L"Comet",   212,    false,      false},
    {L"Cupid",   196,    false,      false},
    {L"Donder",  255,    false,      false},
    {L"Blitzen", 145,    false,      false},
    {L"Rudolf",  123,    true,       false}
};

/*****************************************************************************
 *
 *  FUNCTION    :   CReindeer::CReindeer
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CReindeer::CReindeer (LPCWSTR pszName, LPCWSTR pszNameSpace ) :
    Provider(pszName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CReindeer::~CReindeer
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CReindeer::~CReindeer ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CReindeer::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

// TO DO: The following commented lines contain the 'set' methods for the
//        properties entered for this class.   They are commented because they
//        will NOT compile in their current form.   Each <Property Value> should be
//        replaced with the appropriate value.
//
//        If the expectation is that there is more than one instance on the machine
//        EnumerateInstances should loop through the instances and fill them accordingly.
//
//        Note that you must ALWAYS set ALL the key properties.  See the docs for
//        further details.
///////////////////////////////////////////////////////////////////////////////

    // create an instance for each reindeer
    for (int i = 0; (i < Deers::NDeers) && (SUCCEEDED(hRes)); i++)
    {
        // we don't want to return deleted deer
        if (!ohDeers[i].m_deleted)
        {
            CInstance *pInstance = CreateNewInstance(pMethodContext);
            if (pInstance)
            {
                pInstance->SetCHString(pName, CHString(ohDeers[i].m_name));
                pInstance->SetDWORD(pWeight,  ohDeers[i].m_weight);
                pInstance->Setbool(pRedNose,  ohDeers[i].m_redNose);

                hRes = Commit(pInstance);
            }
            else
            {
                // couldn't create new instance
                hRes = WBEM_E_OUT_OF_MEMORY;
                break;
            }
        }
    }

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*  COMMENTS    : 
*
*****************************************************************************/
HRESULT CReindeer::GetObject ( CInstance* pInstance, long lFlags )
{
    // TO DO: The GetObject function is used to search for an instance of this
    //        class on the machine based on the key properties.   Unlike
    //        EnumerateInstances which finds all instances on the machine, GetObject
    //        uses the key properties to find the matching single instance and 
    //        returns that instance.
    //
    //        Use the CInstance Get functions (GetCHString, etc) against pInstance to see
    //        the key values the client requested.
    HRESULT hr = WBEM_E_NOT_FOUND;

    // name is the key, we retrieve the name
    CHString name;
    pInstance->GetCHString(pName, name);

    // search the array for a Reindeer with the name we're given
    // (make sure he hasn't been deleted!)
    for (int i = 0; i < Deers::NDeers; i++) 
    {
        if (0 == name.CompareNoCase(CHString(ohDeers[i].m_name)) && !ohDeers[i].m_deleted)
        {
            // we found the one they're look for - fill in the data
            pInstance->SetDWORD(pWeight,  ohDeers[i].m_weight);
            pInstance->Setbool(pRedNose, ohDeers[i].m_redNose);

            hr = WBEM_S_NO_ERROR;
            break;
        }
    }

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  WinMgmt will post - 
*                   filter the query for you, so you may return more instances 
*                   or more properties than are requested and WinMgmt 
*                   will filter out any that do not apply.
*
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.
*
*****************************************************************************/
HRESULT CReindeer::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

// While this class is too small to really benefit from query processing, this method is
// being instrumented to show how it could be done.  There are two different ways query processing
// can be used to improve performance.  
// 
// Method 1 - Look at the fields that are being requested, and only return data for those fields.  This
//            can be a very big win for some classes if some properties are very expensive to retrieve.  In
//            our own LogicalDisk class, populating just the DeviceID field is very cheap.  However, populating
//            the FreeSpace property requires that we spin up the disk.  For floppy, cd, and network drives,
//            that is very expensive.
//
// Method 2 - Look at the where clause and only return the requested records.  Obviously, this also has the 
//            potential to be a big win.  For example, if the query is of the form 'Select Name, Size from 
//            CIM_Datafile where where drive="a:"', clearly this can be resolved much faster then doing the 
//            default behavior when no ExecQuery routine is specified (enumerating all directories on all 
//            drives and let Winmgmt pick out the matching entries).

//            On the other hand, just because a WHERE clause in included doesn't mean that the query can be 
//            processed any faster.  Consider a query of the form "Select * from CIM_Datafile where ReadOnly = TRUE"
//            By the time we have called FindFirstFile and examined the structure, the most expensive parts
//            of the processing is already done.  How about a query of the form 'Select * from CIM_Datafile
//            where Drive="a:" or ReadOnly = TRUE'?  Again, to satisfy this query, we're going to have to walk
//            all the instances on all the drives anyway since there is no way to specify to the Win32 API's that
//            you only want ReadOnly files.  Since Winmgmt already has a bunch of code to process instances 
//            against queries, there's no reason to add that complexity to our provider UNLESS we are getting
//            a big performance win.  If we send back a few too many instances, winmgmt will trim them out.

//            For most classes, there are a few (sometimes only 1) properties that it makes sense to try to 
//            optimize on (CIM_Datafile actually does a bunch, but many other classes that process queries 
//            only do 1-2).

//            So, there is a method that can be run against the CFrameworkQuery object where you pass it the name
//            of a property, and it will tell you all the values they requested.  For example, if the query is of 
//            the form 'Select * from Reindeer where name = "Dasher" or name = "Dancer" or name = "pickle"', 
//            GetValuesForProp(L"Name") would send back an array that contains {"Dasher", "Dancer", "pickle"}.  
//            Or if the query was of the form 'Select * from CIM_Datafile where Drive = "a:" AND ReadOnly = TRUE' 
//            (note that this query, unlike the one in the paragraph above, uses AND), then GetValuesForProp(L"Drive") 
//            would return {"a:"}.  Given this array, you can quickly return just the few instances they requested.  If
//            there are additional clauses on the query that you didn't process, (like the Drive AND ReadOnly example
//            above), don't worry.  Winmgmt will discard the instances that don't match.

// In your provider, you can use either, neither, or both of these methods.  In the code below, 
// both methods are illustrated.

   CHStringArray asNames;
   BOOL bGetAll, bSetName, bSetWeight, bSetNose;
   HRESULT hRes = WBEM_S_NO_ERROR;

   // Part of Method 2
   Query.GetValuesForProp(pName, asNames);

   bGetAll = asNames.GetSize() == 0;

   // Used by Method 1
   bSetName = Query.IsPropertyRequired(pName);
   bSetWeight = Query.IsPropertyRequired(pWeight);
   bSetNose = Query.IsPropertyRequired(pRedNose);

    // walk through all the reindeer
   for (int i = 0; (i < Deers::NDeers) && (SUCCEEDED(hRes)); i++)
   {
       // we don't want to return deleted deer
       if (!ohDeers[i].m_deleted)
       {
           // Method 2 - Check to see if the query CAN be processed by 'name', if so,
           // only return those names.
           if (bGetAll || IsInList(asNames, ohDeers[i].m_name))
           {
               CInstance *pInstance = CreateNewInstance(pMethodContext);
               if (pInstance)
               {
                   // Method 1
                   if (bSetName)
                       pInstance->SetCHString(pName, CHString(ohDeers[i].m_name));
                   
                   // Method 1
                   if (bSetWeight)
                       pInstance->SetDWORD(pWeight,  ohDeers[i].m_weight);
                   
                   // Method 1
                   if (bSetNose)
                       pInstance->Setbool(pRedNose,  ohDeers[i].m_redNose);
                   
                   hRes = Commit(pInstance);
               }
               else
               {
                   // couldn't create new instance
                   hRes = WBEM_E_OUT_OF_MEMORY;
                   break;
               }
           }
       }
   }

   return hRes;

}

/*****************************************************************************
*
*  FUNCTION    : CReindeer::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can write
*                   instance information back to the hardware or software.
*                   For example: Win32_Environment will allow a PutInstance of a new
*                   environment variable, because environment variables are "software"
*                   related.   However, a class like Win32_MotherboardDevice will not
*                   allow editing of the bus speed.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CReindeer::PutInstance ( const CInstance &Instance, long lFlags)
{
    HRESULT hresult = WBEM_E_INVALID_PARAMETER;

    // we do not create reindeer here.
    if (lFlags & WBEM_FLAG_CREATE_ONLY) 
        hresult = WBEM_E_UNSUPPORTED_PARAMETER;
    else
    {
        // get the key value so we can tell which reindeer we're operating on
        CHString name;
        Instance.GetCHString(pName, name);
        for (int i = 0; i < Deers::NDeers; i++) 
        {
            if (0 == name.CompareNoCase(CHString(ohDeers[i].m_name)) && !ohDeers[i].m_deleted)
            {
                // we found one, we can change the red nose and/or the weight properties
                DWORD weight;
                bool  redNoze;

                if (Instance.GetDWORD(pWeight,  weight))
                    ohDeers[i].m_weight = weight;

                if (Instance.Getbool(pRedNose, redNoze))
                    ohDeers[i].m_redNose = redNoze;

                hresult = WBEM_S_NO_ERROR;
                break;
            }
        }

        if (FAILED(hresult))
        {
            // If they said they wanted to update, but it wasn't there
            if (lFlags & WBEM_FLAG_UPDATE_ONLY)
            {
                hresult = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hresult; 
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.   For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CReindeer::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    HRESULT hresult = WBEM_E_NOT_FOUND;

    // get the key value so we can tell which reindeer we're operating on
    CHString name;
    Instance.GetCHString(pName, name);

    // see if we can find the deer we want,
    // note that we won't delete one that's already been deleted
    for (int i = 0; i < Deers::NDeers; i++) 
    {
        if (0 == name.CompareNoCase(CHString(ohDeers[i].m_name)) && !ohDeers[i].m_deleted)
        {
            // we found it - mark as deleted 
            ohDeers[i].m_deleted = true;
            hresult = WBEM_S_NO_ERROR;
            break;
        }
    }

    return hresult;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CReindeer::ExecMethod ( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags)
{
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

BOOL CReindeer::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\genlex.cpp ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include "precomp.h"

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\genlex.h ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
    {
        if (!m_pSrcBuf)
            return 0;
        else
            return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
    }

    void Pushback(wchar_t)
    {
        if (m_pSrcBuf)
            --m_pSrcBuf;
    }

    void Reset() { m_pSrcBuf = m_pStart; }
    void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servev\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "evprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CEventPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CEventPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servev\evprov.cpp ===
//***************************************************************************

//

//  EVPRO.CPP

//

//  Module: WMI Event provider sample code

//

//  Purpose: Defines the CEventPro class.  An object of this class is

//           created by the class factory for each connection.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include "evprov.h"
#define _MT
#include <process.h>
#include "servlist.h"

#define SERVICE_INSTALL_CLASS L"Win32_ServiceInstallationEvent"
#define SERVICE_DEINSTALL_CLASS L"Win32_ServiceDeinstallationEvent"
//***************************************************************************
//
// CEventPro::CEventPro
// CEventPro::~CEventPro
//
//***************************************************************************

CEventPro::CEventPro()
{
    m_pInstallClass = NULL;
    m_pDeinstallClass = NULL;
    m_hTerminateEvent = NULL;
    m_pSink = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CEventPro::~CEventPro(void)
{
    if(m_pInstallClass)
        m_pInstallClass->Release();
    if(m_pDeinstallClass)
        m_pDeinstallClass->Release();

    if(m_pSink)
        m_pSink->Release();

    SetEvent(m_hTerminateEvent);
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CEventPro::QueryInterface
// CEventPro::AddRef
// CEventPro::Release
//
// Purpose: IUnknown members for CEventPro object.
//***************************************************************************


STDMETHODIMP CEventPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemEventProvider)
       *ppv=(IWbemEventProvider*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CEventPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEventPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CEventPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CEventPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    HRESULT hres;

    // Retrieve our class definitions
    // ==============================

    BSTR strClassName = SysAllocString(SERVICE_INSTALL_CLASS);
    hres = pNamespace->GetObject(strClassName, 0, pCtx, &m_pInstallClass, NULL);
    SysFreeString(strClassName);

    if(FAILED(hres))
    {
        pInitSink->SetStatus(WBEM_E_FAILED, 0);
        return WBEM_S_NO_ERROR;
    }

    strClassName = SysAllocString(SERVICE_DEINSTALL_CLASS);
    hres = pNamespace->GetObject(strClassName, 0, pCtx, &m_pDeinstallClass, 
                                        NULL);
    SysFreeString(strClassName);

    if(FAILED(hres))
    {
        pInitSink->SetStatus(WBEM_E_FAILED, 0);
        return WBEM_S_NO_ERROR;
    }
   
    // There is no need to keep the namespace pointer --- we got all we needed
    // =======================================================================

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CEventPro::ProvideEvents(IWbemObjectSink* pSink, long)
{
    // AddRef the sink --- we will need it later
    // =========================================

    pSink->AddRef();
    m_pSink = pSink;

    // Create termination signal event
    // ===============================

    m_hTerminateEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // AddRef ourselves for the benefit of the thread
    // ==============================================

    AddRef();

    // Spawn the thread to do the job
    // ==============================

    DWORD dwId;
    HANDLE hEventThread = CreateThread(NULL, 0, 
                                    (LPTHREAD_START_ROUTINE)staticEventThread, 
                                    (void*)this, 0, &dwId);

    if(hEventThread == NULL)
    {
        CloseHandle(m_hTerminateEvent);
        return WBEM_E_FAILED;
    }

    CloseHandle(hEventThread);
    return WBEM_S_NO_ERROR;
}

DWORD CEventPro::staticEventThread(void* pv)
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // Locate our COM object
    // =====================

    CEventPro* pThis = (CEventPro*)pv;

    // Read all the necessary information from the COM object
    // ======================================================

    HANDLE hTerminateEvent = pThis->m_hTerminateEvent;
    IWbemObjectSink* pSink = pThis->m_pSink;
    IWbemClassObject* pInstallClass = pThis->m_pInstallClass;
    IWbemClassObject* pDeinstallClass = pThis->m_pDeinstallClass;
    pSink->AddRef();

    // Release the COM object
    // ======================

    pThis->Release();

    // Open the registry key to watch
    // ==============================

    HKEY hServices;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SYSTEM\\CurrentControlSet\\Services",
                    0, KEY_READ, &hServices);

    // Create an event to wait for notifications
    // =========================================

    HANDLE hRegChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
   
    // Register the event with the OS
    // ==============================

    lRes = RegNotifyChangeKeyValue(hServices, FALSE, 
            REG_NOTIFY_CHANGE_NAME, hRegChangeEvent, TRUE);

    // Compile a list of all the services installed on the machine
    // ===========================================================

    CServiceList* pCurrentList = CompileList(hServices);

    // In a loop, wait for either the termination event, or a registry change
    // ======================================================================

    HANDLE ahEvents[2] = {hRegChangeEvent, hTerminateEvent};
    while(WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE) == WAIT_OBJECT_0)
    {
        // Registry has changed.  Compile a new list of service names
        // ==========================================================

        CServiceList* pNewList = CompileList(hServices);

        // Compare the lists and fire all changes
        // ======================================

        CompareAndFire(pCurrentList, pNewList, pInstallClass, pDeinstallClass,
                        pSink);

        // Replace the old list with the new
        // =================================

        delete pCurrentList;
        pCurrentList = pNewList;

        // Register the event with the OS
        // ==============================
        
        lRes = RegNotifyChangeKeyValue(hServices, FALSE, 
                REG_NOTIFY_CHANGE_NAME, hRegChangeEvent, TRUE);

    }
        
    CloseHandle(hTerminateEvent);
    pSink->Release();
    CoUninitialize();

    return 0;
}

CServiceList* CEventPro::CompileList(HKEY hServices)
{
    CServiceList* pList = new CServiceList;

    // Determine maximum subkey length
    // ===============================

    DWORD dwMaxLen;
    long lRes = RegQueryInfoKey(hServices, NULL, NULL, NULL, NULL, &dwMaxLen,
                            NULL, NULL, NULL, NULL, NULL, NULL);

    // Enumerate all the subkeys of the Services key
    // =============================================

    DWORD dwIndex = 0;
    WCHAR* wszKeyName = new WCHAR[dwMaxLen+1];
    DWORD dwNameLen = dwMaxLen + 1;

    while(RegEnumKeyExW(hServices, dwIndex++, wszKeyName, &dwNameLen, NULL,
                        NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        pList->AddService(wszKeyName);
        dwNameLen = dwMaxLen + 1;
    }

    delete [] wszKeyName;

    // Sort it
    // =======

    pList->Sort();
    return pList;
}
    
BOOL CEventPro::CompareAndFire(CServiceList* pOld, CServiceList* pNew, 
                                IWbemClassObject* pInstallClass,
                                IWbemClassObject* pDeinstallClass,
                                IWbemObjectSink* pSink)
{
    // Walk the two lists
    // ==================

    long lOldIndex = 0;
    long lNewIndex = 0;

    while(lOldIndex < pOld->GetSize() && lNewIndex < pNew->GetSize())
    {
        // Compare the strings
        // ===================

        LPCWSTR wszOldName = pOld->GetService(lOldIndex);
        LPCWSTR wszNewName = pNew->GetService(lNewIndex);

        int nCompare = _wcsicmp(wszOldName, wszNewName);
        if(nCompare == 0)
        {
            // Same --- move on
            // ================

            lOldIndex++; lNewIndex++;
        }
        else if(nCompare > 0)
        {
            // Hole in old list --- creation
            // =============================

            CreateAndFire(pInstallClass, wszNewName, pSink);
            lNewIndex++;
        }
        else 
        {
            // Hole in new list --- deletion
            // =============================

            CreateAndFire(pDeinstallClass, wszOldName, pSink);
            lOldIndex++;
        }
    }

    // Handle outstanding tails
    // ========================

    while(lOldIndex < pOld->GetSize())
    {
        // Hole in new list --- deletion
        // =============================

        CreateAndFire(pDeinstallClass, pOld->GetService(lOldIndex), pSink);
        lOldIndex++;
    }

    while(lNewIndex < pNew->GetSize())
    {
        // Hole in old list --- deletion
        // =============================

        CreateAndFire(pInstallClass, pNew->GetService(lNewIndex), pSink);
        lNewIndex++;
    }

    return TRUE;
}
        
BOOL CEventPro::CreateAndFire(IWbemClassObject* pEventClass, 
                                LPCWSTR wszServiceName, 
                                IWbemObjectSink* pSink)
{
    // Spawn an instance
    // =================

    IWbemClassObject* pEvent;
    pEventClass->SpawnInstance(0, &pEvent);

    // Fill in the service name
    // ========================

    BSTR strPropName = SysAllocString(L"ServiceName");
    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(wszServiceName);

    pEvent->Put(strPropName, 0, &v, 0);

    VariantClear(&v);
    SysFreeString(strPropName);

    // Report to CIMOM
    // ===============

    pSink->Indicate(1, &pEvent);

    // Cleanup
    // =======

    pEvent->Release();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servev\evprov.h ===
//***************************************************************************

//

//  sample.h

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _sample_H_
#define _sample_H_

#include <wbemprov.h>
#include "servlist.h"

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CEventPro : public IWbemProviderInit, public IWbemEventProvider
{
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemClassObject *  m_pInstallClass;
        IWbemClassObject *  m_pDeinstallClass;
        HANDLE m_hTerminateEvent;
        IWbemObjectSink* m_pSink;
     public:
        CEventPro();
        ~CEventPro();

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        // Event provider methods

        HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink* pSink, long);

protected:
        static DWORD staticEventThread(void* pv);
        static CServiceList* CompileList(HKEY hServices);
        static BOOL CompareAndFire(CServiceList* pOld, CServiceList* pNew, 
                                        IWbemClassObject* pInstallClass,
                                        IWbemClassObject* pDeinstallClass,
                                        IWbemObjectSink* pSink);
        static BOOL CreateAndFire(IWbemClassObject* pEventClass, 
                                        LPCWSTR wszServiceName, 
                                        IWbemObjectSink* pSink);
};

typedef CEventPro *PCInstPro;

// This class is the class factory for CEventPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servev\servlist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SERV_LIST__H_
#define __SERV_LIST__H_

#include <windows.h>
class CServiceList
{
public:
    CServiceList();
    ~CServiceList();

    void AddService(LPCWSTR wszService);
    int GetSize();
    LPCWSTR GetService(int nIndex);
    void Sort();

private:
    int m_nSize;
    LPWSTR* m_awszServices;

    static int __cdecl compare(const void* arg1, const void* arg2);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servev\servlist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "servlist.h"

CServiceList::CServiceList() : m_nSize(0), m_awszServices(NULL)
{
}

CServiceList::~CServiceList()
{
    for(int i = 0; i < m_nSize; i++)
        delete [] m_awszServices[i];
    delete [] m_awszServices;
}

void CServiceList::AddService(LPCWSTR wszService)
{
    LPWSTR* awszNewServices = new LPWSTR[m_nSize+1];
    memcpy(awszNewServices, m_awszServices, sizeof(LPWSTR) * m_nSize);
    delete [] m_awszServices;
    m_awszServices = awszNewServices;

    m_awszServices[m_nSize] = new WCHAR[wcslen(wszService) + 1];
    wcscpy(m_awszServices[m_nSize], wszService);
    m_nSize++;
}

int CServiceList::GetSize()
{
    return m_nSize;
}

LPCWSTR CServiceList::GetService(int nIndex)
{
    return m_awszServices[nIndex];
}

void CServiceList::Sort()
{
    qsort((void*)m_awszServices, m_nSize, sizeof(LPWSTR), 
        CServiceList::compare);
}

int __cdecl CServiceList::compare(const void* arg1, const void* arg2)
{
    return _wcsicmp(*(WCHAR**)arg1, *(WCHAR**)arg2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servev\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Instance provider sample code

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "evprov.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_instprovider,0x688b0ed7, 0x24bb, 0x11d2, 0xad, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0xfd, 0xff);
// {688b0ed6-24bb-11d2-adc7-00c04fd8fdff}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_instprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Service Event Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\objpath.h ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <opathlex.h>
#include <Polarity.h>

#define DELETE_ME

struct POLARITY KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
};

struct POLARITY ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class POLARITY CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\opathlex.cpp ===
/*++



Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\opathlex.h ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    OPATHLEX.H

Abstract:

    Object Path DFA Tokens

History:

--*/

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "servprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CServExtPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CServExtPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Instance provider sample code

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "servprov.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_instprovider,0x688b0ed6, 0x24bb, 0x11d2, 0xad, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0xfd, 0xff);
// {688b0ed6-24bb-11d2-adc7-00c04fd8fdff}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_instprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Service Extention Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\mainfrm.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__EA280F8A_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
#define AFX_MAINFRM_H__EA280F8A_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:
	CSplitterWnd m_wndSplitter;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__EA280F8A_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\mainfrm.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "WbemBrowser.h"

#include "navigator.h"
#include "security.h"
#include "wbemviewcontainer.h"

#include "MainFrm.h"
#include "WbemBrowserDoc.h"
#include "WbemBrowserView.h"
#include "ObjectView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{
	// Calculate the size of half of the client area.
	CRect r;
	GetClientRect(&r);
	CSize size = CSize(r.Width()/2, r.Height());

	// Create a splitter with 1 row, 2 columns.
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
	{
		TRACE("Failed to create the static splitter\n");
		return FALSE;
	}
	// Add the first splitter pane -- the view in column 0.
	if (!m_wndSplitter.CreateView(0, 0,
		RUNTIME_CLASS(CWbemBrowserView), size, pContext))
	{
		TRACE("Failed to create the first pane\n");
		return FALSE;
	}
	// Add the second splitter pane -- the view in column 1.
	if (!m_wndSplitter.CreateView(0, 1,
		RUNTIME_CLASS(CObjectView), CSize(0, 0), pContext))
	{
		TRACE("Failed to create the second pane\n");
		return FALSE;
	}
	// Select the rightmost pane.
	SetActiveView((CView*) m_wndSplitter.GetPane(0,1));

	// Connect the two views together.
	CWbemBrowserView* pBrowserView;
	CObjectView* pObjectView;

	pBrowserView = (CWbemBrowserView*) m_wndSplitter.GetPane(0,0);
	pObjectView = (CObjectView*) m_wndSplitter.GetPane(0,1);

	pBrowserView->m_pViewContainer = &pObjectView->m_ViewContainer;
	pObjectView->m_pNavigator = &pBrowserView->m_Navigator;
	pObjectView->m_pSecurity  = &pBrowserView->m_Security;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\precomp.h ===
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\objpath.cpp ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#define Macro_CloneLPWSTR(x) \
    (x ? wcscpy(new wchar_t[wcslen(x) + 1], x) : 0)


ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
        m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    delete m_pServer;
    for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        delete m_paNamespaces[dwIx];
    delete m_paNamespaces;
    delete m_pClass;

    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        delete m_paKeys[dwIx];
    delete m_paKeys;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    delete [] m_pClass;
    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces++] = Macro_CloneLPWSTR(wszNamespace);

    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue );

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;

                VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    delete m_pName;
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];
    wcscpy(wszPath, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            swprintf(wszTemp, L"%u", V_UI4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            swprintf(wszTemp, L"%hd", V_I2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            swprintf(wszTemp, L"%hu", V_UI2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            swprintf(wszTemp, L"%d", V_I1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            swprintf(wszTemp, L"%u", V_UI1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];
                wcscpy(m_pOutput->m_pServer, pwcStart);

                *pOutput = m_pOutput;
                m_pOutput = 0;

                return NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            return SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef;
        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;

    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, char **argv)
{
    printf("Object Path Test\n");
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: objpath input-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

void main(int argc, char **argv)
{
        xmain(argc, argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\servprov.cpp ===
//***************************************************************************

//

//  INSTPRO.CPP

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Defines the CServExtPro class.  An object of this class is

//           created by the class factory for each connection.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include "servprov.h"
// #define _MT
#include <process.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#define PERFORMANCE_SERVICE_CLASS L"Win32_PerformanceService"
#define SERVICE_CLASS_KEY L"Name"
//***************************************************************************
//
// CServExtPro::CServExtPro
// CServExtPro::~CServExtPro
//
//***************************************************************************

CServExtPro::CServExtPro()
{
    m_pClass = NULL;
    m_hServices = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CServExtPro::~CServExtPro(void)
{
    if(m_pClass)
        m_pClass->Release();
    if(m_hServices)
        RegCloseKey(m_hServices);

    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CServExtPro::QueryInterface
// CServExtPro::AddRef
// CServExtPro::Release
//
// Purpose: IUnknown members for CServExtPro object.
//***************************************************************************


STDMETHODIMP CServExtPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CServExtPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CServExtPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CServExtPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CServExtPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    HRESULT hres;

    // Retrieve our class definition
    // =============================

    BSTR strClassName = SysAllocString(PERFORMANCE_SERVICE_CLASS);
    hres = pNamespace->GetObject(strClassName, 0, pCtx, &m_pClass, NULL);
    SysFreeString(strClassName);

    if(FAILED(hres))
    {
        pInitSink->SetStatus(WBEM_E_FAILED, 0);
        return WBEM_S_NO_ERROR;
    }

    // There is no need to keep the namespace pointer --- we got all we needed
    // =======================================================================

    // Open the registry key for services
    // ==================================

    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SYSTEM\\CurrentControlSet\\Services",
                    0, KEY_READ, &m_hServices);
    if(lRes)
    {
        pInitSink->SetStatus(WBEM_E_FAILED, 0);
        return WBEM_S_NO_ERROR;
    }
    
    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CServExtPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

STDMETHODIMP CServExtPro::CreateInstanceEnumAsync(const BSTR strClass, long lFlags, 
        IWbemContext *pCtx, IWbemObjectSink* pSink)
{
    CoImpersonateClient();
    BOOL bRes;
    HANDLE hOrigToken;
    long lRes;

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hOrigToken);

    lRes = GetLastError();

    HANDLE hNewToken;
    bRes = DuplicateTokenEx(hOrigToken, MAXIMUM_ALLOWED, NULL, 
                SecurityImpersonation, TokenPrimary, &hNewToken);
    lRes = GetLastError();

    STARTUPINFO si;
    memset((void*)&si, 0, sizeof(si));
    si.cb = sizeof(si);
    si.lpDesktop = "winsta0\\default";

    PROCESS_INFORMATION pi;
    bRes = CreateProcessAsUser(hNewToken, NULL, "c:\\winnt\\system32\\cmd.exe",
                NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
    lRes = GetLastError();

    // Check the class to ensure it is supported
    // =========================================

    if(strClass == NULL || _wcsicmp(strClass, PERFORMANCE_SERVICE_CLASS) ||
        pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hres;

    // Determine maximum subkey length
    // ===============================

    DWORD dwMaxLen;
    lRes = RegQueryInfoKey(m_hServices, NULL, NULL, NULL, NULL, &dwMaxLen,
                            NULL, NULL, NULL, NULL, NULL, NULL);
    if(lRes)
        return WBEM_E_FAILED;

    // Enumerate all the subkeys of the Services key
    // =============================================

    DWORD dwIndex = 0;
    WCHAR* wszKeyName = new WCHAR[dwMaxLen+1];
    DWORD dwNameLen = dwMaxLen + 1;

    while(RegEnumKeyExW(m_hServices, dwIndex++, wszKeyName, &dwNameLen, NULL,
                        NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        // Construct our instance (if any) for this service
        // ================================================

        IWbemClassObject* pInst = NULL;
        if(ConstructInstance(wszKeyName, &pInst))
        {
            // Report it to CIMOM using Indicate
            // =================================

            hres = pSink->Indicate(1, &pInst);
            pInst->Release();

            if(FAILED(hres))
            {
                // Operation must be cancelled
                // ===========================

                break;
            }
        }
        dwNameLen = dwMaxLen + 1;
    }

    // Report success to CIMOM
    // =======================

    pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
    delete [] wszKeyName;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CServExtPro::GetObjectByPath
// CServExtPro::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************



SCODE CServExtPro::GetObjectAsync(const BSTR strObjectPath, long lFlags,
                    IWbemContext  *pCtx, IWbemObjectSink* pSink)
{
    CoImpersonateClient();

    if(strObjectPath == NULL || pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Parse the object path
    // =====================

    BSTR strServiceName;
    if(!ParsePath(strObjectPath, &strServiceName))
        return WBEM_E_INVALID_OBJECT_PATH;

    // Construct the instance representing this service, if any
    // ========================================================

    IWbemClassObject* pInst = NULL;
    if(ConstructInstance(strServiceName, &pInst))
    {
        // Report it to CIMOM using Indicate
        // =================================

        pSink->Indicate(1, &pInst);
        pInst->Release();

        // Report success to CIMOM using SetStatus
        // =======================================

        pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
    }
    else
    {
        // No such instance: report failure to CIMOM
        // =========================================

        pSink->SetStatus(0, WBEM_E_NOT_FOUND, NULL, NULL);
    }

    SysFreeString(strServiceName);

    return WBEM_S_NO_ERROR;
}
 
//***************************************************************************
//
// CServExtPro::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

BOOL CServExtPro::ParsePath(const BSTR strObjectPath, BSTR* pstrServiceName)
{
    // Get the sample parser to parse it into a structure
    // ==================================================

    CObjectPathParser Parser;

    ParsedObjectPath* pOutput;
    if(Parser.Parse(strObjectPath, &pOutput) != CObjectPathParser::NoError)
        return FALSE;

    // Make sure the class name is the right one
    // =========================================

    if(_wcsicmp(pOutput->m_pClass, PERFORMANCE_SERVICE_CLASS))
    {
        Parser.Free(pOutput);
        return FALSE;
    }

    // Check the number of keys
    // ========================

    if(pOutput->m_dwNumKeys != 1)
    {
        Parser.Free(pOutput);
        return FALSE;
    }

    // Check key name
    // ==============

    if(pOutput->m_paKeys[0]->m_pName != NULL && 
        _wcsicmp(pOutput->m_paKeys[0]->m_pName, SERVICE_CLASS_KEY))
    {
        Parser.Free(pOutput);
        return FALSE;
    }

    // Return the value of the key
    // ===========================

    if(V_VT(&pOutput->m_paKeys[0]->m_vValue) != VT_BSTR)
    {
        Parser.Free(pOutput);
        return FALSE;
    }

    *pstrServiceName = SysAllocString(V_BSTR(&pOutput->m_paKeys[0]->m_vValue));
    Parser.Free(pOutput);
    return TRUE;
}
 
BOOL CServExtPro::ConstructInstance(LPCWSTR wszServiceName, 
                                    IWbemClassObject** ppInst)
{
    // Locate the service
    // ==================

    HKEY hService;
    if(RegOpenKeyExW(m_hServices, wszServiceName, 0, KEY_READ, &hService))
        return FALSE;

    // Open its performance data
    // =========================

    HKEY hPerformance;
    if(RegOpenKeyExW(hService, L"Performance", 0, KEY_READ, &hPerformance))
    {
        // No performance subkey --- not our service
        // =========================================

        RegCloseKey(hService);
        return FALSE;
    }
   
    RegCloseKey(hService);

    // Spawn an instance of the class
    // ==============================

    IWbemClassObject* pInst = NULL;
    m_pClass->SpawnInstance(0, &pInst);

    VARIANT v;
    VariantInit(&v);

    // Fill in the key
    // ===============

    BSTR strPropName = SysAllocString(SERVICE_CLASS_KEY);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(wszServiceName);
    
    pInst->Put(strPropName, 0, &v, 0);

    SysFreeString(strPropName);
    VariantClear(&v);

    // Get the library name
    // ====================

    WCHAR wszLibraryName[MAX_PATH];
    DWORD dwValLen = MAX_PATH;
    if(RegQueryValueExW(hPerformance, L"Library", NULL, NULL, 
                        (LPBYTE)wszLibraryName, &dwValLen) == 0)
    {
        // Fill in the property
        // ====================

        strPropName = SysAllocString(L"Library");
        V_VT(&v) = VT_BSTR;
        V_BSTR(&v) = SysAllocString(wszLibraryName);

        pInst->Put(strPropName, 0, &v, 0);

        SysFreeString(strPropName);
        VariantClear(&v);
    }

    // Get the FirstCounter index
    // ==========================

    dwValLen = sizeof(DWORD);
    V_VT(&v) = VT_I4;

    if(RegQueryValueExW(hPerformance, L"First Counter", NULL, NULL, 
                        (LPBYTE)&V_I4(&v), &dwValLen) == 0)
    {
        // Fill in the property
        // ====================

        strPropName = SysAllocString(L"FirstCounter");

        pInst->Put(strPropName, 0, &v, 0);

        SysFreeString(strPropName);
    }
    
    // Get the LastCounter index
    // ==========================

    dwValLen = sizeof(DWORD);
    V_VT(&v) = VT_I4;

    if(RegQueryValueExW(hPerformance, L"Last Counter", NULL, NULL, 
                        (LPBYTE)&V_I4(&v), &dwValLen) == 0)
    {
        // Fill in the property
        // ====================

        strPropName = SysAllocString(L"LastCounter");

        pInst->Put(strPropName, 0, &v, 0);

        SysFreeString(strPropName);
    }
    
    // Clean up
    // ========

    RegCloseKey(hPerformance);
    *ppInst = pInst;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\servext\servprov.h ===
//***************************************************************************

//

//  sample.h

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _sample_H_
#define _sample_H_

#include <wbemprov.h>

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CServExtPro : public IWbemServices, public IWbemProviderInit
{
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemClassObject *  m_pClass;
        HKEY                m_hServices;
     public:
        CServExtPro();
        ~CServExtPro();

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices  

		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

protected:
        BOOL ConstructInstance(LPCWSTR wszServiceName, 
                                IWbemClassObject** ppInst);
        BOOL ParsePath(const BSTR strObjectPath, BSTR* pstrServiceName);
};

typedef CServExtPro *PCServExtPro;

// This class is the class factory for CServExtPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\navigator.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "navigator.h"

/////////////////////////////////////////////////////////////////////////////
// CNavigator

IMPLEMENT_DYNCREATE(CNavigator, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNavigator properties

CString CNavigator::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNavigator::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CNavigator::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CNavigator operations

void CNavigator::OnReadySignal()
{
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CNavigator::ChangeRootOrNamespace(LPCTSTR lpctstrRootOrNamespace, long lMakeNamespaceCurrent, long lFireEvents)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR VTS_I4 VTS_I4;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpctstrRootOrNamespace, lMakeNamespaceCurrent, lFireEvents);
	return result;
}

void CNavigator::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\navigator.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNavigator wrapper class

class CNavigator : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNavigator)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc7eadeb3, 0xecab, 0x11cf, { 0x8c, 0x9e, 0x0, 0xaa, 0x0, 0x6d, 0x1, 0xa } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();

// Operations
public:
	void OnReadySignal();
	long ChangeRootOrNamespace(LPCTSTR lpctstrRootOrNamespace, long lMakeNamespaceCurrent, long lFireEvents);
	void AboutBox();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	WbemBrowser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\objectview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ObjectView.cpp : implementation file
//

#include "stdafx.h"

#include "wbemviewcontainer.h"

#include "WbemBrowser.h"
#include "ObjectView.h"
#include "navigator.h"
#include "security.h"

#define IDC_OBJVIEWERCTRL1              1001

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CObjectView

IMPLEMENT_DYNCREATE(CObjectView, CView)

CObjectView::CObjectView()
{
}

CObjectView::~CObjectView()
{
}


BEGIN_MESSAGE_MAP(CObjectView, CView)
	//{{AFX_MSG_MAP(CObjectView)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CObjectView drawing

void CObjectView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CObjectView diagnostics

#ifdef _DEBUG
void CObjectView::AssertValid() const
{
	CView::AssertValid();
}

void CObjectView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CObjectView message handlers
	// TODO: Add your specialized code here and/or call the base class
	
BOOL CObjectView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	BOOL bResult = 
	CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if (!bResult)  return FALSE;

	bResult = m_ViewContainer.Create(
		"Hmmv", 
		NULL, 
		WS_CHILD | WS_VISIBLE, 
		rect, 
		this, 
		IDC_OBJVIEWERCTRL1);

	m_ViewContainer.SetStudioModeEnabled(FALSE);

	return bResult;
}

void CObjectView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
	if (::IsWindow(m_ViewContainer.m_hWnd))
		m_ViewContainer.MoveWindow(CRect(CPoint(0,0), CSize(cx,cy))); 
}


BEGIN_EVENTSINK_MAP(CObjectView, CView)
    //{{AFX_EVENTSINK_MAP(CAboutDlg)
	ON_EVENT(CObjectView, IDC_OBJVIEWERCTRL1, 1 /* GetIWbemServices */, OnGetIWbemServicesObjviewerctrl1, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT(CObjectView, IDC_OBJVIEWERCTRL1, 2 /* NOTIFYChangeRootOrNamespace */, OnNOTIFYChangeRootOrNamespaceObjviewerctrl1, VTS_BSTR VTS_I4 VTS_I4)
	ON_EVENT(CObjectView, IDC_OBJVIEWERCTRL1, -609 /* ReadyStateChange */, OnReadyStateChangeObjviewerctrl1, VTS_NONE)
	ON_EVENT(CObjectView, IDC_OBJVIEWERCTRL1, 3 /* RequestUIActive */, OnRequestUIActiveObjviewerctrl1, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CObjectView::OnGetIWbemServicesObjviewerctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel) 
{
	m_pSecurity->GetIWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);	
}

void CObjectView::OnNOTIFYChangeRootOrNamespaceObjviewerctrl1(LPCTSTR szRootOrNamespace, long bChangeNamespace, long bEchoSelectObject) 
{
	// TODO: Add your control notification handler code here
	
}

void CObjectView::OnReadyStateChangeObjviewerctrl1() 
{
	// TODO: Add your control notification handler code here
	
}

void CObjectView::OnRequestUIActiveObjviewerctrl1() 
{
	// TODO: Add your control notification handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\objectview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_OBJECTVIEW_H__3AC8B2E2_12B3_11D2_BDFD_00C04F8F8B8D__INCLUDED_)
#define AFX_OBJECTVIEW_H__3AC8B2E2_12B3_11D2_BDFD_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ObjectView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CObjectView view

class CNavigator;
class CSecurity;

class CObjectView : public CView
{
protected:
	CObjectView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CObjectView)

// Attributes
public:
	CWBEMViewContainer m_ViewContainer;

	CNavigator* m_pNavigator;
	CSecurity*  m_pSecurity;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CObjectView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CObjectView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CObjectView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnGetIWbemServicesObjviewerctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	afx_msg void OnNOTIFYChangeRootOrNamespaceObjviewerctrl1(LPCTSTR szRootOrNamespace, long bChangeNamespace, long bEchoSelectObject);
	afx_msg void OnReadyStateChangeObjviewerctrl1();
	afx_msg void OnRequestUIActiveObjviewerctrl1();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OBJECTVIEW_H__3AC8B2E2_12B3_11D2_BDFD_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WbemBrowser.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_WBEMBRTYPE                  129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\security.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SECURITY_H__FBCE61D2_0AE7_11D2_BDF2_00C04F8F8B8D__INCLUDED_)
#define AFX_SECURITY_H__FBCE61D2_0AE7_11D2_BDF2_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSecurity wrapper class

class CSecurity : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSecurity)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x9c3497d6, 0xed98, 0x11d0, { 0x96, 0x47, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetLoginComponent();
	void SetLoginComponent(LPCTSTR);

// Operations
public:
	void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel);
	void PageUnloading();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITY_H__FBCE61D2_0AE7_11D2_BDF2_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\security.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "security.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurity

IMPLEMENT_DYNCREATE(CSecurity, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSecurity properties

CString CSecurity::GetLoginComponent()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSecurity::SetLoginComponent(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSecurity operations

void CSecurity::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace, pvarUpdateNamespace, pvarServices, pvarSC, pvarUserCancel);
}

void CSecurity::PageUnloading()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSecurity::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbembrowser.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WbemBrowser.h : main header file for the WBEMBROWSER application
//

#if !defined(AFX_WBEMBROWSER_H__EA280F86_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
#define AFX_WBEMBROWSER_H__EA280F86_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserApp:
// See WbemBrowser.cpp for the implementation of this class
//

class CWbemBrowserApp : public CWinApp
{
public:
	CWbemBrowserApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemBrowserApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWbemBrowserApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMBROWSER_H__EA280F86_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbembrowser.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WbemBrowser.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "WbemBrowser.h"

#include "navigator.h"
#include "security.h"

#include "MainFrm.h"
#include "WbemBrowserDoc.h"
#include "WbemBrowserView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserApp

BEGIN_MESSAGE_MAP(CWbemBrowserApp, CWinApp)
	//{{AFX_MSG_MAP(CWbemBrowserApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserApp construction

CWbemBrowserApp::CWbemBrowserApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWbemBrowserApp object

CWbemBrowserApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserApp initialization

BOOL CWbemBrowserApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CWbemBrowserDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CWbemBrowserView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWbemBrowserApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EA280F88_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
#define AFX_STDAFX_H__EA280F88_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__EA280F88_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbembrowserdoc.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WbemBrowserDoc.cpp : implementation of the CWbemBrowserDoc class
//

#include "stdafx.h"
#include "WbemBrowser.h"

#include "WbemBrowserDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserDoc

IMPLEMENT_DYNCREATE(CWbemBrowserDoc, CDocument)

BEGIN_MESSAGE_MAP(CWbemBrowserDoc, CDocument)
	//{{AFX_MSG_MAP(CWbemBrowserDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserDoc construction/destruction

CWbemBrowserDoc::CWbemBrowserDoc()
{
	// TODO: add one-time construction code here

}

CWbemBrowserDoc::~CWbemBrowserDoc()
{
}

BOOL CWbemBrowserDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserDoc serialization

void CWbemBrowserDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserDoc diagnostics

#ifdef _DEBUG
void CWbemBrowserDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWbemBrowserDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbembrowserdoc.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WbemBrowserDoc.h : interface of the CWbemBrowserDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WBEMBROWSERDOC_H__EA280F8C_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
#define AFX_WBEMBROWSERDOC_H__EA280F8C_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CWbemBrowserDoc : public CDocument
{
protected: // create from serialization only
	CWbemBrowserDoc();
	DECLARE_DYNCREATE(CWbemBrowserDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemBrowserDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWbemBrowserDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CWbemBrowserDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMBROWSERDOC_H__EA280F8C_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbembrowserview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WbemBrowserView.h : interface of the CWbemBrowserView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WBEMBROWSERVIEW_H__EA280F8E_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
#define AFX_WBEMBROWSERVIEW_H__EA280F8E_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CWBEMViewContainer;

class CWbemBrowserView : public CView
{
protected: // create from serialization only
	CWbemBrowserView();
	DECLARE_DYNCREATE(CWbemBrowserView)

// Attributes
public:
	CWbemBrowserDoc* GetDocument();

	CNavigator m_Navigator;
	CSecurity  m_Security;
	boolean m_bReady;

	CWBEMViewContainer* m_pViewContainer; 

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemBrowserView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWbemBrowserView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CWbemBrowserView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnNotifyOpenNameSpaceInstnavctrl1(LPCTSTR lpcstrNameSpace);
	afx_msg void OnViewObjectInstnavctrl1(LPCTSTR bstrPath);
	afx_msg void OnViewInstancesInstnavctrl1(LPCTSTR bstrLabel, const VARIANT FAR& vsapaths);
	afx_msg void OnQueryViewInstancesInstnavctrl1(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
	afx_msg void OnGetIWbemServicesInstnavctrl1(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in WbemBrowserView.cpp
inline CWbemBrowserDoc* CWbemBrowserView::GetDocument()
   { return (CWbemBrowserDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMBROWSERVIEW_H__EA280F8E_0A22_11D2_BDF1_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbembrowserview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WbemBrowserView.cpp : implementation of the CWbemBrowserView class
//

#include "stdafx.h"
#include "WbemBrowser.h"

#include "navigator.h"
#include "security.h"

#include "WbemBrowserDoc.h"
#include "WbemBrowserView.h"
#include "wbemviewcontainer.h"

#define IDC_INSTNAVCTRL1                1000

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserView

IMPLEMENT_DYNCREATE(CWbemBrowserView, CView)

BEGIN_MESSAGE_MAP(CWbemBrowserView, CView)
	//{{AFX_MSG_MAP(CWbemBrowserView)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserView construction/destruction

CWbemBrowserView::CWbemBrowserView()
{
	m_bReady = false;
}

CWbemBrowserView::~CWbemBrowserView()
{
}

BOOL CWbemBrowserView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserView drawing

void CWbemBrowserView::OnDraw(CDC* pDC)
{
	CWbemBrowserDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// Initialize the navigator.
	if (!m_bReady) {
		 m_bReady = true;
		 m_Navigator.OnReadySignal();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserView printing

BOOL CWbemBrowserView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CWbemBrowserView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CWbemBrowserView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserView diagnostics

#ifdef _DEBUG
void CWbemBrowserView::AssertValid() const
{
	CView::AssertValid();
}

void CWbemBrowserView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CWbemBrowserDoc* CWbemBrowserView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWbemBrowserDoc)));
	return (CWbemBrowserDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWbemBrowserView message handlers

BOOL CWbemBrowserView::Create(
	LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, 
	const RECT& rect, CWnd* pParentWnd, UINT nID, 
	CCreateContext* pContext) 
{
	int nReturn = CWnd::Create(
		lpszClassName, lpszWindowName, dwStyle, rect, 
		pParentWnd, nID, pContext);
	if (nReturn == 0)  return FALSE;

	// Create the instance navigator display window.
	BOOL bReturn = m_Navigator.Create(
		"Navigator", 
		NULL, 
		WS_CHILD | WS_VISIBLE, 
		CRect(CPoint(0,0), CSize(0,0)), 
		this, 
		IDC_INSTNAVCTRL1);

	if (!bReturn)  return FALSE;

	// Create the login control window.
	bReturn = m_Security.Create(
		"Security", 
		NULL, 
		WS_CHILD | WS_VISIBLE, 
		CRect(CPoint(0,0), CSize(0,0)), 
		this, 
		0);

	if (bReturn)
		m_Security.SetLoginComponent("Some Machine");

	return bReturn;
}

void CWbemBrowserView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
	if (::IsWindow(m_Navigator.m_hWnd))
		m_Navigator.MoveWindow(CRect(CPoint(0,0), CSize(cx,cy))); 
}

BEGIN_EVENTSINK_MAP(CWbemBrowserView, CView)
    //{{AFX_EVENTSINK_MAP(CWbemBrowserView)
	ON_EVENT(CWbemBrowserView, IDC_INSTNAVCTRL1, 1 /* NotifyOpenNameSpace */, OnNotifyOpenNameSpaceInstnavctrl1, VTS_BSTR)
	ON_EVENT(CWbemBrowserView, IDC_INSTNAVCTRL1, 2 /* ViewObject */, OnViewObjectInstnavctrl1, VTS_BSTR)
	ON_EVENT(CWbemBrowserView, IDC_INSTNAVCTRL1, 3 /* ViewInstances */, OnViewInstancesInstnavctrl1, VTS_BSTR VTS_VARIANT)
	ON_EVENT(CWbemBrowserView, IDC_INSTNAVCTRL1, 4 /* QueryViewInstances */, OnQueryViewInstancesInstnavctrl1, VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR)
	ON_EVENT(CWbemBrowserView, IDC_INSTNAVCTRL1, 5 /* GetIWbemServices */, OnGetIWbemServicesInstnavctrl1, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CWbemBrowserView::OnNotifyOpenNameSpaceInstnavctrl1(LPCTSTR lpcstrNameSpace) 
{
	m_pViewContainer->SetNameSpace(lpcstrNameSpace);
}

void CWbemBrowserView::OnViewObjectInstnavctrl1(LPCTSTR bstrPath) 
{
	// Convert LPCTSTR to VARIANT of type VT_BSTR
	COleVariant varPath(bstrPath);

	m_pViewContainer->SetObjectPath(varPath);
}

void CWbemBrowserView::OnViewInstancesInstnavctrl1(LPCTSTR bstrLabel, const VARIANT FAR& vsapaths) 
{
}

void CWbemBrowserView::OnQueryViewInstancesInstnavctrl1(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass) 
{
	m_pViewContainer->QueryViewInstances(pLabel, pQueryType, pQuery, pClass);	
}

void CWbemBrowserView::OnGetIWbemServicesInstnavctrl1(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) 
{
	m_Security.GetIWbemServices(
		lpctstrNamespace, 
		pvarUpdatePointer, 
		pvarServices, 
		pvarSC, 
		pvarUserCancel);		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbemviewcontainer.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_WBEMVIEWCONTAINER_H__CF8387C2_1504_11D2_BDFE_00C04F8F8B8D__INCLUDED_)
#define AFX_WBEMVIEWCONTAINER_H__CF8387C2_1504_11D2_BDFE_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainer wrapper class

class CWBEMViewContainer : public CWnd
{
protected:
	DECLARE_DYNCREATE(CWBEMViewContainer)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x5b3572ab, 0xd344, 0x11cf, { 0x99, 0xcb, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	VARIANT GetObjectPath();
	void SetObjectPath(const VARIANT&);
	long GetStatusCode();
	void SetStatusCode(long);
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetStudioModeEnabled();
	void SetStudioModeEnabled(long);
	long GetReadyState();

// Operations
public:
	void ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray);
	long SaveState(long bPromptUser, long bUserCanCancel);
	void QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMVIEWCONTAINER_H__CF8387C2_1504_11D2_BDFE_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\wbemviewcontainer.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "wbemviewcontainer.h"

/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainer

IMPLEMENT_DYNCREATE(CWBEMViewContainer, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainer properties

VARIANT CWBEMViewContainer::GetObjectPath()
{
	VARIANT result;
	GetProperty(0x2, VT_VARIANT, (void*)&result);
	return result;
}

void CWBEMViewContainer::SetObjectPath(const VARIANT& propVal)
{
	SetProperty(0x2, VT_VARIANT, &propVal);
}

long CWBEMViewContainer::GetStatusCode()
{
	long result;
	GetProperty(0x1, VT_I4, (void*)&result);
	return result;
}

void CWBEMViewContainer::SetStatusCode(long propVal)
{
	SetProperty(0x1, VT_I4, propVal);
}

CString CWBEMViewContainer::GetNameSpace()
{
	CString result;
	GetProperty(0x3, VT_BSTR, (void*)&result);
	return result;
}

void CWBEMViewContainer::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x3, VT_BSTR, propVal);
}

long CWBEMViewContainer::GetStudioModeEnabled()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

void CWBEMViewContainer::SetStudioModeEnabled(long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}

long CWBEMViewContainer::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainer operations

void CWBEMViewContainer::ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szTitle, &varPathArray);
}

long CWBEMViewContainer::SaveState(long bPromptUser, long bUserCanCancel)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bPromptUser, bUserCanCancel);
	return result;
}

void CWBEMViewContainer::QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pLabel, pQueryType, pQuery, pClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\advclient.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  HMMSamp.cpp
//
// Description:
//	This file implements the CHMMSampleApp class which 
//		is the main class for the tutorial.
// 
// History:
//
// **************************************************************************


#include "stdafx.h"
#include <objbase.h>
#include "AdvClient.h"
#include "AdvClientDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMMSampleApp

BEGIN_MESSAGE_MAP(CHMMSampleApp, CWinApp)
	//{{AFX_MSG_MAP(CHMMSampleApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMMSampleApp construction

CHMMSampleApp::CHMMSampleApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CHMMSampleApp object

CHMMSampleApp theApp;

// **************************************************************************
//
//	CHMMSampleApp::InitSecurity()
//
// Description:
//		Initializes COM security if DCOM is installed.
// Parameters:
//		None.
//
// Returns:
//		nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
// definition for call CoInitializeSecurity indirectly.
HRESULT (STDAPICALLTYPE *g_pfnCoInitializeSecurity)(PSECURITY_DESCRIPTOR pVoid,
													DWORD cAuthSvc,
													SOLE_AUTHENTICATION_SERVICE * asAuthSvc, 
													void * pReserved1,
													DWORD dwAuthnLevel,
													DWORD dwImpLevel,
													RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
													DWORD dwCapabilities,
													void * pvReserved2 );

BOOL CHMMSampleApp::InitSecurity(void)
{
    UINT    uSize;
    BOOL    bRetCode = FALSE;

	// find the system directory.
    LPTSTR   pszSysDir = new TCHAR[MAX_PATH + 10];

    if(pszSysDir == NULL)
        return FALSE;

    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);

    if(uSize > MAX_PATH) 
	{
        delete[] pszSysDir;
        pszSysDir = new TCHAR[ uSize +10 ];
        if(pszSysDir == NULL)
            return FALSE;
        uSize = GetSystemDirectory(pszSysDir, uSize);
    }

	// manually load the ole32.dll and see if CoInitializeSecurity() exists. This routine wont exist
	// on win95 OS's that dont have DCOM installed separately. If this routine doesn't exist, the 
	// async routines in this sample wont work because of mismatched security level problems. The
	// synchronous techniques will still work.
    lstrcat(pszSysDir, _T("\\ole32.dll"));

    HINSTANCE hOle32 = LoadLibraryEx(pszSysDir, NULL, 0);
    delete[] pszSysDir;

    HRESULT hres = S_OK;
    if(hOle32 != NULL) 
	{
        (FARPROC&)g_pfnCoInitializeSecurity = GetProcAddress(hOle32, "CoInitializeSecurity");

		// if it exports CoInitializeSecurity then DCOM is installed.
        if(g_pfnCoInitializeSecurity != NULL) 
		{			
			hres = g_pfnCoInitializeSecurity
											( NULL, -1, NULL, NULL, 
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE, 
											NULL, 
											EOAC_NONE, 
											NULL );


        } 
        FreeLibrary(hOle32);
    }
    return SUCCEEDED(hres);
}
// **************************************************************************
//
//	CHMMSampleApp::InitInstance()
//
// Description:
//		Initializes COM then initializes security in a way that allows
//		objectSink to be called.
// Parameters:
//		None.
//
// Returns:
//		whether or not it initialized everything.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
BOOL CHMMSampleApp::InitInstance()
{
	// OLE initialization. This is 'lighter' than OleInitialize()
	//  which also setups DnD, etc.
	if(SUCCEEDED(CoInitialize(NULL))) 
	{
		if(!InitSecurity())
		{
			AfxMessageBox(_T("CoInitializeSecurity Failed"));
			return FALSE;
		}
	}
	else // didnt CoInitialize()
	{
		AfxMessageBox(_T("CoInitialize Failed"));
		return FALSE;
	} // endif OleInitialize()

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CAdvClientDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
// **************************************************************************
//
//	CHMMSampleApp::ExitInstance()
//
// Description:
//		Uninitialize COM.
// Parameters:
//		None.
//
// Returns:
//		the value of the base class's routine.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
int CHMMSampleApp::ExitInstance()
{
	CoUninitialize();

	return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\advclient.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  HMMSamp.h
//
// Description:
//	This file declares the CHMMSampleApp class. It is the main
//		class for the tutorial
// 
// Part of: WMI Tutorial #1.
//
// Used by: Nobody.
//
// History:
//
// **************************************************************************

#if !defined(AFX_HMMENUM_H__6AC7FBF7_FE04_11D0_AD84_00AA00B8E05A__INCLUDED_)
#define AFX_HMMENUM_H__6AC7FBF7_FE04_11D0_AD84_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CHMMSampleApp:
// See WBEMEnum.cpp for the implementation of this class
//

class CHMMSampleApp : public CWinApp
{
public:
	CHMMSampleApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMMSampleApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

	BOOL InitSecurity(void);
	virtual int ExitInstance();
// Implementation

	//{{AFX_MSG(CHMMSampleApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMMENUM_H__6AC7FBF7_FE04_11D0_AD84_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\advclientdlg.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  AdvClientDlg.h
//
// Description:
//	This file declares the CAdvClientDlg dialog class. It is the main
//		dialog for the tutorial.
// 
// Part of: WMI Tutorial #1.
//
// Used by: CAdvClientleApp::InitInstance().
//
// History:
//
// **************************************************************************

#if !defined(AFX_HMMENUMDLG_H__6AC7FBF9_FE04_11D0_AD84_00AA00B8E05A__INCLUDED_)
#define AFX_HMMENUMDLG_H__6AC7FBF9_FE04_11D0_AD84_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wbemcli.h>     // WMI interface declarations
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CAdvClientDlg dialog
class CAsyncQuerySink;
class CEventSink;

class CAdvClientDlg : public CDialog
{
// Construction
public:
	CAdvClientDlg(CWnd* pParent = NULL);	// standard constructor
	virtual ~CAdvClientDlg();

// Dialog Data
	//{{AFX_DATA(CAdvClientDlg)
	enum { IDD = IDD_SAMPLE_DIALOG };
	CButton	m_diskDescriptions;
	CListBox	m_eventList;
	CButton	m_perm;
	CButton	m_temp;
	CButton	m_addEquipment;
	CButton	m_enumServicesAsync;
	CButton	m_enumServices;
	CButton	m_enumDisks;
	CButton	m_diskDetails;
	CButton	m_connect;
	CListBox	m_outputList;
	CString	m_namespace;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdvClientDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAdvClientDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnAddEquipment();
	afx_msg void OnConnect();
	afx_msg void OnEnumdisks();
	afx_msg void OnEnumservices();
	afx_msg void OnDiskdetails();
	afx_msg void OnEnumservicesasync();
	afx_msg void OnRegPerm();
	afx_msg void OnRegTemp();
	virtual void OnCancel();
	afx_msg void OnDiskPropsDescriptions();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:

	BOOL m_regPerm, m_regTemp;

	CAsyncQuerySink *m_pQueryCallback;
	IWbemServices *m_pIWbemServices;
	IWbemServices *m_pOfficeService;

	BOOL EnsureOfficeNamespace(void);
	BOOL CheckOfficeNamespace(void);

	void AssociateToMachine(IWbemClassObject *pEquipInst);
	HRESULT GetCompSysRef(VARIANT *v);

	// event related.
	CEventSink *m_pEventSink;
	BOOL PermRegistered();
	BOOL OnTempRegister();
	void OnTempUnregister();
	BOOL OnPermRegister();
	void OnPermUnregister();

	// SampleViewer.mof 'creates' the consumer.
	BOOL GetConsumer(IWbemClassObject **pConsumer);
	BOOL AddFilter(IWbemClassObject **pFilter);
	BOOL AddBinding(IWbemClassObject *pConsumer, 
					IWbemClassObject *pFilter);

};
LPWSTR ValueToString(VARIANT *pValue, WCHAR **pbuf);
LPCTSTR ErrorString(SCODE sc);


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMMENUMDLG_H__6AC7FBF9_FE04_11D0_AD84_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\advclientdlg.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  HMMSampDlg.cpp
//
// Description:
//	This file implements the CAdvClientDlg dialog class which 
//		is the main dialog for the tutorial.
// 
// History:
//
// **************************************************************************


#include "stdafx.h"
#include "AdvClient.h"
#include "AdvClientDlg.h"
#include "OnAsync.h"
#include "OnTemp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// **************************************************************************
//
//	CAdvClientDlg::CAdvClientDlg()
//
// Description:
//		Constructor for the main dialog. Puts the default namespace
//		in the edit box and initializes variables.	
// Parameters:
//		pParent (in) - parent window.
//
// Returns:
//		nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
CAdvClientDlg::CAdvClientDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAdvClientDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAdvClientDlg)
	m_namespace = _T("\\\\.\\root\\cimv2");
	//}}AFX_DATA_INIT

	m_pIWbemServices = NULL;
	m_pOfficeService = NULL;
	m_pQueryCallback = NULL;
	m_regPerm = TRUE;
	m_regTemp = TRUE;
	m_pEventSink = NULL;
}

// **************************************************************************
//
//	CAdvClientDlg::~CAdvClientDlg()
//
// Description:
//		Destructor. Releases COM interfaces for the dialog class.
// Parameters:
//		None.
//
// Returns:
//		nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
CAdvClientDlg::~CAdvClientDlg()
{
	// done with m_pQueryCallback sink. 
	if(m_pEventSink)
	{
		OnTempUnregister();
	}

	// done with m_pQueryCallback sink. 
	if(m_pQueryCallback)
	{
		m_pQueryCallback->Release();
		delete m_pQueryCallback;
		m_pQueryCallback = NULL;
	}

	// done with m_pIWbemServices. 
	if (m_pIWbemServices)
	{ 
		m_pIWbemServices->Release(); 
		m_pIWbemServices = NULL;
	}
	// done with m_pIWbemServices. 
	if (m_pOfficeService)
	{ 
		m_pOfficeService->Release(); 
		m_pOfficeService = NULL;
	}

}
void CAdvClientDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAdvClientDlg)
	DDX_Control(pDX, IDC_DISK_PROPS_DESCRIPTIONS, m_diskDescriptions);
	DDX_Control(pDX, IDC_EVENTLIST, m_eventList);
	DDX_Control(pDX, IDC_REGPERM, m_perm);
	DDX_Control(pDX, IDC_REGTEMP, m_temp);
	DDX_Control(pDX, IDC_ADDEQUIPMENT, m_addEquipment);
	DDX_Control(pDX, IDC_ENUMSERVICESASYNC, m_enumServicesAsync);
	DDX_Control(pDX, IDC_ENUMSERVICES, m_enumServices);
	DDX_Control(pDX, IDC_ENUMDISKS, m_enumDisks);
	DDX_Control(pDX, IDC_DISKDETAILS, m_diskDetails);
	DDX_Control(pDX, IDC_CONNECT, m_connect);
	DDX_Control(pDX, IDC_OUTPUTLIST, m_outputList);
	DDX_Text(pDX, IDC_NAMESPACE, m_namespace);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAdvClientDlg, CDialog)
	//{{AFX_MSG_MAP(CAdvClientDlg)
	ON_WM_SYSCOMMAND()
	ON_BN_CLICKED(IDC_ADDEQUIPMENT, OnAddEquipment)
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_ENUMDISKS, OnEnumdisks)
	ON_BN_CLICKED(IDC_ENUMSERVICES, OnEnumservices)
	ON_BN_CLICKED(IDC_ENUMSERVICESASYNC, OnEnumservicesasync)
	ON_BN_CLICKED(IDC_DISKDETAILS, OnDiskdetails)
	ON_BN_CLICKED(IDC_REGPERM, OnRegPerm)
	ON_BN_CLICKED(IDC_REGTEMP, OnRegTemp)
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_DISK_PROPS_DESCRIPTIONS, OnDiskPropsDescriptions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdvClientDlg message handlers

BOOL CAdvClientDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	//make scrollable horizontally by 5000 pixels
	m_outputList.SetHorizontalExtent(5000);


	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CAdvClientDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}


// **************************************************************************
//
//	ErrorString()
//
// Description:
//		Converts an HRESULT to a displayable string.
//
// Parameters:
//		hRes (in) - HRESULT to be converted.
//
// Returns:
//		ptr to displayable string.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
LPCTSTR ErrorString(HRESULT hRes)
{
   TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

   switch(hRes) 
   {
   case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
   case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
   case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
   case WBEM_S_ALREADY_EXISTS:
      psz = _T("WBEM_S_ALREADY_EXISTS");
      break;
   case WBEM_S_RESET_TO_DEFAULT:
      psz = _T("WBEM_S_RESET_TO_DEFAULT");
      break;
   case WBEM_S_DIFFERENT:
      psz = _T("WBEM_S_DIFFERENT");
      break;
   case WBEM_E_OVERRIDE_NOT_ALLOWED:
      psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
      break;
   case WBEM_E_PROPAGATED_QUALIFIER:
      psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
      break;
   case WBEM_E_PROPAGATED_PROPERTY:
      psz = _T("WBEM_E_PROPAGATED_PROPERTY");
      break;
   case WBEM_E_UNEXPECTED:
      psz = _T("WBEM_E_UNEXPECTED");
      break;
   case WBEM_E_ILLEGAL_OPERATION:
      psz = _T("WBEM_E_ILLEGAL_OPERATION");
      break;
   case WBEM_E_CANNOT_BE_KEY:
      psz = _T("WBEM_E_CANNOT_BE_KEY");
      break;
   case WBEM_E_INCOMPLETE_CLASS:
      psz = _T("WBEM_E_INCOMPLETE_CLASS");
      break;
   case WBEM_E_INVALID_SYNTAX:
      psz = _T("WBEM_E_INVALID_SYNTAX");
      break;
   case WBEM_E_NONDECORATED_OBJECT:
      psz = _T("WBEM_E_NONDECORATED_OBJECT");
      break;
   case WBEM_E_READ_ONLY:
      psz = _T("WBEM_E_READ_ONLY");
      break;
   case WBEM_E_PROVIDER_NOT_CAPABLE:
      psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
      break;
   case WBEM_E_CLASS_HAS_CHILDREN:
      psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
      break;
   case WBEM_E_CLASS_HAS_INSTANCES:
      psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
      break;
   case WBEM_E_QUERY_NOT_IMPLEMENTED:
      psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
      break;
   case WBEM_E_ILLEGAL_NULL:
      psz = _T("WBEM_E_ILLEGAL_NULL");
      break;
   case WBEM_E_INVALID_QUALIFIER_TYPE:
      psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
      break;
   case WBEM_E_INVALID_PROPERTY_TYPE:
      psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
      break;
   case WBEM_E_VALUE_OUT_OF_RANGE:
      psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
      break;
   case WBEM_E_CANNOT_BE_SINGLETON:
      psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
      break;
	default:
      _itot(hRes, szBuffer2, 16);
      _tcscat(szBuffer, szBuffer2);
	  psz = szBuffer;
	  break;
	}
	return psz;
}

// **************************************************************************
//
//	ValueToString()
//
// Description:
//		Converts a variant to a displayable string.
//
// Parameters:
//		pValue (in) - variant to be converted.
//		pbuf (out) - ptr to receive displayable string.
//
// Returns:
//		Same as pbuf.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop  (this size stolen from cvt.h in c runtime library) */

LPWSTR ValueToString(VARIANT *pValue, WCHAR **pbuf)
{
   DWORD iNeed = 0;
   DWORD iVSize = 0;
   DWORD iCurBufSize = 0;

   WCHAR *vbuf = NULL;
   WCHAR *buf = NULL;


   switch (pValue->vt) 
   {

   case VT_NULL: 
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<null>");
         break;

   case VT_BOOL: {
         VARIANT_BOOL b = pValue->boolVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);

         if (!b) {
            wcscpy(buf, L"FALSE");
         } else {
            wcscpy(buf, L"TRUE");
         }
         break;
      }

   case VT_UI1: {
         BYTE b = pValue->bVal;
	      buf = (WCHAR *)malloc(BLOCKSIZE);
         if (b >= 32) {
            swprintf(buf, L"'%c' (%d, 0x%X)", b, b, b);
         } else {
            swprintf(buf, L"%d (0x%X)", b, b);
         }
         break;
      }

   case VT_I2: {
         SHORT i = pValue->iVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", i, i);
         break;
      }

   case VT_I4: {
         LONG l = pValue->lVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", l, l);
         break;
      }

   case VT_R4: {
         float f = pValue->fltVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", f);
         break;
      }

   case VT_R8: {
         double d = pValue->dblVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", d);
         break;
      }

   case VT_BSTR: {
		 LPWSTR pWStr = pValue->bstrVal;
		 buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
	     swprintf(buf, L"\"%wS\"", pWStr);
		 break;
		}

	// the sample GUI is too simple to make it necessary to display
	// these 'complicated' types--so ignore them.
   case VT_DISPATCH:  // Currently only used for embedded objects
   case VT_BOOL|VT_ARRAY: 
   case VT_UI1|VT_ARRAY: 
   case VT_I2|VT_ARRAY: 
   case VT_I4|VT_ARRAY: 
   case VT_R4|VT_ARRAY: 
   case VT_R8|VT_ARRAY: 
   case VT_BSTR|VT_ARRAY: 
   case VT_DISPATCH | VT_ARRAY: 
         break;

   default:
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<conversion error>");

   }

   *pbuf = buf;   
   return buf;
}
// **************************************************************************
//
//	CAdvClientDlg::EnsureOfficeNamespace()
//
// Description:
//		Returns a pointer to root\cimv2\office namespace; creating
//		it if it doesn't already exist
// Parameters:
//		None.
//
// Returns:
//		COM interface to the namespace.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
BOOL CAdvClientDlg::EnsureOfficeNamespace(void)
{
	IWbemClassObject *pNSClass = NULL;
	IWbemClassObject *pNSInst = NULL;

	BSTR Prop = NULL;
	VARIANT v;
	HRESULT hRes;

	BSTR Namespace = SysAllocString(L"SAMPLE_Office");

	// avoid getting another pointer if you already one. Potential
	// leak if you do.
	if(m_pOfficeService != NULL)
	{
		return TRUE;
	}

	// if 'Office' namespace doesnt exists...
	if((hRes = m_pIWbemServices->OpenNamespace(Namespace, 0, NULL, &m_pOfficeService, NULL)) != S_OK)
	{ // create it.

		BSTR NamespaceClass = SysAllocString(L"__Namespace");

		//-----------------------------------
		// get the namespace class
		if((hRes = m_pIWbemServices->GetObject(NamespaceClass,
											0L,	NULL,
											&pNSClass,
											NULL)) == S_OK)
		{
			//-----------------------------------
			// spawn a new instance
			if((hRes = pNSClass->SpawnInstance(0, &pNSInst)) == S_OK)
			{
				TRACE(_T("SpawnInstance() worked\n"));

				// set the namespace's name.
				VariantInit(&v);
				V_VT(&v) = VT_BSTR;
				V_BSTR(&v) = Namespace;
				Prop = SysAllocString(L"Name");

				pNSInst->Put(Prop, 0, &v, 0);

				SysFreeString(Prop);
				VariantClear(&v);

				// create the instance.
				hRes = m_pIWbemServices->PutInstance(pNSInst, 0, NULL, NULL);
				pNSInst->Release();
				pNSInst = NULL;

				//-----------------------------------
				// open the new namespace.
				if((hRes = m_pIWbemServices->OpenNamespace(Namespace, 0, NULL, &m_pOfficeService, NULL)) != S_OK)
				{
					TRACE(_T("OpenNamespace() still failed: %s\n"), ErrorString(hRes));
				} // endif OpenNamespace() again
			}
			else
			{
				TRACE(_T("SpawnInstance() failed: %s\n"), ErrorString(hRes));

			} //endif SpawnInstance()

			pNSClass->Release();  // Don't need the class any more
			pNSClass = NULL;
		}

		SysFreeString(NamespaceClass);

	} //endif OpenNamespace()

	SysFreeString(Namespace);

	// NOTE: The caller needs to Release() it.
	return (m_pOfficeService != NULL);
}
//--------------------------------------------------------
BOOL CAdvClientDlg::CheckOfficeNamespace(void)
{
	IWbemServices *pOfficeService = NULL;
	HRESULT hRes;
	BOOL itsThere = FALSE;

	// lazy check first.
	if(m_pOfficeService != NULL) return TRUE;

	// do some real work now.
	BSTR Namespace = SysAllocString(L"SAMPLE_Office");

	// if 'Office' namespace doesnt exists...
	if((hRes = m_pIWbemServices->OpenNamespace(Namespace, 0, NULL, 
												&pOfficeService, NULL)) == S_OK)
	{ 
		itsThere = TRUE;
		pOfficeService->Release();
		pOfficeService = NULL;

	} //endif OpenNamespace()

	SysFreeString(Namespace);

	return itsThere;
}

//---------------------------------------------------------------
void CAdvClientDlg::OnCancel() 
{
	// make sure you unregister that sink.
	if(m_pEventSink != NULL)
	{
		OnTempUnregister();
	}
	
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\officedlg.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OfficeDlg.cpp
//
// Description:
//	This file implements the OfficeDlg dialog class which 
//		collects information for the OnAddEquipment() routine.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClient.h"
#include "OfficeDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COfficeDlg dialog


COfficeDlg::COfficeDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COfficeDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COfficeDlg)
	m_item = _T("");
	m_SKU = _T("");
	//}}AFX_DATA_INIT
}


void COfficeDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COfficeDlg)
	DDX_Text(pDX, IDC_ITEM, m_item);
	DDX_Text(pDX, IDC_SKU, m_SKU);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COfficeDlg, CDialog)
	//{{AFX_MSG_MAP(COfficeDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COfficeDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\officedlg.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OfficeDlg.h
//
// Description:
//	This file declares the COfficeDlg dialog class which 
//		collects information for the OnAddEquipment() routine.
// 
// Part of: WMI Tutorial #1.
//
// Used by: OnAddEquipment().
//
// History:
//
// **************************************************************************

#if !defined(AFX_OFFICEDLG_H__DE6FFC13_FF91_11D0_AD84_00AA00B8E05A__INCLUDED_)
#define AFX_OFFICEDLG_H__DE6FFC13_FF91_11D0_AD84_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// OfficeDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COfficeDlg dialog

class COfficeDlg : public CDialog
{
// Construction
public:
	COfficeDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(COfficeDlg)
	enum { IDD = IDD_OFFICEEQUIP };
	CString	m_item;
	CString	m_SKU;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COfficeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COfficeDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OFFICEDLG_H__DE6FFC13_FF91_11D0_AD84_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onaddequipment.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnAddEquipment.cpp
//
// Description:
//	This file implements the OnAddEquipment() routine which 
//		demonstrates how to create new classes and instances.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClientDlg.h"
#include "OfficeDlg.h"

#define TIMEOUT -1

// **************************************************************************
//
//	CAdvClientDlg::GetCompSysRef()
//
// Description:
//		Gets the name of the computer so that office equipment can be
//		associated with it.
// Parameters:
//		v (out) - ptr to variant receiving the computer name.
//
// Returns:
//		S_OK if succcessful, otherwise the HRESULT of the failed called.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
HRESULT CAdvClientDlg::GetCompSysRef(VARIANT *v)
{
	// these are for enumerating.
	DWORD uReturned;
	HRESULT  hRes;
	IWbemClassObject *pCompSys = NULL;
	IEnumWbemClassObject *pEnumCompSys = NULL;

	// these help get properties.
	BSTR propName = SysAllocString(L"__PATH");

	// here's what we're looking for.
	// NOTE: make sure you specify a class that has a Provider()
	//	specified for it in the mof file. All other classes are
	//	abstract and wont be found using HMM_FLAG_SHALLOW. They
	//	will be found using HMM_FLAG_DEEP.
	BSTR className = SysAllocString(L"Win32_ComputerSystem");

	TRACE(_T("Going for class\n"));

	// get the list of the computerSystems. There should only be one.
    if ((hRes = m_pIWbemServices->CreateInstanceEnum(className,
												WBEM_FLAG_SHALLOW, 
												NULL,
												&pEnumCompSys)) == S_OK) 
	{
		TRACE(_T("good enumerator\n"));

		// No need to actually loop since there should only be one instance
		// of 'Win32_ComputerSystem'.
		if((hRes = pEnumCompSys->Next(TIMEOUT,
									1,
									&pCompSys,
									&uReturned) == S_OK) && 
		   (uReturned == 1))
		{

			TRACE(_T("Got a device class\n"));


			// Add the path
			if ((hRes = pCompSys->Get(propName, 0L, 
								v, NULL, NULL)) == S_OK) 
			{
				TRACE(_T("Got the computer name %s\n"), V_BSTR(v));
			} 
			else
			{
				TRACE(_T("Get() comp name: %s\n"), ErrorString(hRes));
			} // endif Get()

			// Done with this object.
			if (pCompSys)
			{ 
				pCompSys->Release();
				pCompSys = NULL;
			} 
		}
		else
		{
			TRACE(_T("done looking up comp name: %s\n"), ErrorString(hRes));
		} // endif Next()

		// Done with the enumerator.
		if (pEnumCompSys)
		{ 
			pEnumCompSys->Release(); 
			pEnumCompSys = NULL;
		}
    } 
	else // CreateInstanceEnum() failed.
	{
		TRACE(_T("CreateInstanceEnum() failed: %s\n"), ErrorString(hRes));

	} // endif CreateInstanceEnum()

	SysFreeString(propName);

	TRACE(_T("returning\n"));

	return hRes;
}

// **************************************************************************
//
//	CAdvClientDlg::AssociateToMachine()
//
// Description:
//		Creates an association between the machine and the office equipment.
// Parameters:
//		pEquipInst (in) - the equipment to be associated.
//
// Returns:
//		nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::AssociateToMachine(IWbemClassObject *pEquipInst)
{
	IWbemClassObject *pAClass = NULL;
	IWbemClassObject *pAInst = NULL;
	IWbemQualifierSet *pQual = NULL;

	VARIANT v, vTRUE, ref, def;
	HRESULT hRes;

	BSTR AssocClassName = SysAllocString(L"SAMPLE_EquipmentToSystem");
	BSTR EquipProp = SysAllocString(L"Equipment");
	BSTR CompProp = SysAllocString(L"ComputerSystem");

	VariantInit(&v);
	VariantInit(&vTRUE);
	VariantInit(&ref);
	VariantInit(&def);

	// if association class doesn't exist yet...
	if((hRes = m_pOfficeService->GetObject(AssocClassName,
										0L,	NULL,
										&pAClass,
										NULL)) != S_OK)
	{
		// create new class. Parm1 == NULL gives a new, empty
		// class to load with property values.
		if((hRes = m_pOfficeService->GetObject(NULL, 0, NULL, 
											&pAClass, NULL)) == S_OK)
		{
			//-----------------------------------
			// name the class.
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = SysAllocString(L"SAMPLE_EquipmentToSystem");
			BSTR Class = SysAllocString(L"__CLASS");
			pAClass->Put(Class, 0, &v, 0);
			SysFreeString(Class);
			VariantClear(&v);

			//-----------------------------------
			// make it an association.
			pAClass->GetQualifierSet(&pQual);

			BSTR assoc = SysAllocString(L"Association");

			V_VT(&vTRUE) = VT_BOOL;
			V_BOOL(&vTRUE) = VARIANT_TRUE;

			pQual->Put(assoc, &vTRUE, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
								WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

			// cleanup.
			SysFreeString(assoc);
			pQual->Release();
			pQual = NULL;

			//-----------------------------------
			// common stuff for properties
			BSTR Key = SysAllocString(L"Key");
			BSTR CimType = SysAllocString(L"CIMTYPE");

			V_VT(&def) = VT_BSTR;
			V_BSTR(&def) = SysAllocString(L"");;

			//-----------------------------------
			// create the equipment property.
			pAClass->Put(EquipProp, 0, &def, 0);

			// make it a key.
			pAClass->GetPropertyQualifierSet(EquipProp, &pQual);
			pQual->Put(Key, &vTRUE, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
								WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

			// make it a strongly typed reference.
			V_VT(&ref) = VT_BSTR;
			V_BSTR(&ref) = SysAllocString(L"REF:SAMPLE_OfficeEquipment");
			pQual->Put(CimType, &ref, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
								WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

			// cleanup the property specific stuff.
			VariantClear(&ref);
			pQual->Release();
			pQual = NULL;

			//-----------------------------------
			// 'ComputerSystem' is the other key property.
			pAClass->Put(CompProp, 0, &def, 0);

			// make it a key.
			pAClass->GetPropertyQualifierSet(CompProp, &pQual);
			pQual->Put(Key, &vTRUE, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
								WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

			// make it a strongly typed reference.
			V_VT(&ref) = VT_BSTR;
			V_BSTR(&ref) = SysAllocString(L"REF:Win32_ComputerSystem");
			pQual->Put(CimType, &ref, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
								WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

			// cleanup the property specific stuff.
			VariantClear(&ref);
			pQual->Release();
			pQual = NULL;

			//-----------------------------------
			// cleanup the common stuff too.
			SysFreeString(Key);
			SysFreeString(CimType);
			VariantClear(&v);
			VariantClear(&vTRUE);
			VariantClear(&def);

			//-----------------------------------
			// register new class
			if((hRes = m_pOfficeService->PutClass(pAClass, 
												0, NULL, NULL)) != S_OK)
			{
				TRACE(_T("Second PutClass() failed: %s\n"), ErrorString(hRes));
			}
			
			pAClass->Release();
			pAClass = NULL;
		}
		else
		{
			TRACE(_T("GetObject() NULL failed: %s\n"), ErrorString(hRes));
		}

		// NOTE: now pAClass exists for sure but you have to go get a new pointer
		//  from CIMOM before you can spawnInstance() on it. You CANNOT continue to use
		//   the pAClass ptr from above.
		if((hRes = m_pOfficeService->GetObject(AssocClassName,
												0L,	NULL,
												&pAClass,
												NULL)) != S_OK)
		{
			TRACE(_T("Second GetObject() failed: %s\n"), ErrorString(hRes));
		} //endif GetObject()

	} // endif class doesnt exist.

	ASSERT(pAClass);

	// spawn a new instance.
	if((hRes = pAClass->SpawnInstance(0, &pAInst)) == S_OK)
	{
		TRACE(_T("Assoc SpawnInstance() worked\n"));

		BSTR PathProp = SysAllocString(L"__PATH");

		//-----------------------------------
		// set equipment reference
		if ((hRes = pEquipInst->Get(PathProp, 0L, 
							&v, NULL, NULL)) == S_OK) 
		{
			TRACE(_T("Got equipment ref\n"));
			pAInst->Put(EquipProp, 0, &v, 0);
			VariantClear(&v);
		}
		else
		{
			TRACE(_T("Get() equipment ref failed: %s\n"), ErrorString(hRes));
		} //endif Get()

		SysFreeString(PathProp);

		//-----------------------------------
		// set ComputerSystem reference
		if ((hRes = GetCompSysRef(&v)) == S_OK) 
		{
			TRACE(_T("Got the ComputerSystem ref\n"));
			pAInst->Put(CompProp, 0, &v, 0);
			VariantClear(&v);
		}
		else
		{
			TRACE(_T("Get() compSys ref failed: %s\n"), ErrorString(hRes));
		} //endif Get()

		//-----------------------------------
		// putInstance
		hRes = m_pOfficeService->PutInstance(pAInst, 0, NULL, NULL);
		pAInst->Release();
		pAInst = NULL;
	}
	else
	{
		TRACE(_T("SpawnInstance() failed: %s\n"), ErrorString(hRes));

	} //endif SpawnInstance()

	pAClass->Release();  // Don't need the class any more
	pAClass = NULL;

	SysFreeString(AssocClassName);
	SysFreeString(EquipProp);
	SysFreeString(CompProp);
}
// **************************************************************************
//
//	CAdvClientDlg::OnAddEquipment()
//
// Description:
//		Creates an SAMPLE_OfficeEquipment if necessary. Creates an OfficeEquipment 
//		instance. Associates the instance with the machine's instance.
// Parameters:
//		pEquipInst (in) - the equipment to be associated.
//
// Returns:
//		nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::OnAddEquipment() 
{
	IWbemClassObject *pEquipClass = NULL;
	IWbemClassObject *pEquipInst = NULL;
	IEnumWbemClassObject *pEnumEquipment = NULL;

	HRESULT hRes;
	CString buf;
	BSTR Prop = NULL;
	BSTR curInst = NULL;
	VARIANT v;
	DWORD uReturned;
	BSTR EquipClassName = SysAllocString(L"SAMPLE_OfficeEquipment");

	COfficeDlg dlg;

	VariantInit(&v);
	m_outputList.ResetContent();
	m_outputList.AddString(_T("working..."));

	// collect office equipment info.
	dlg.DoModal();

	// switch to the root\cimv2\office namespace.
	if(EnsureOfficeNamespace())
	{
		// the namespace exists now, allow user to register for its events.
		m_perm.EnableWindow(TRUE);
		m_temp.EnableWindow(TRUE);

		// if class doesn't exist yet...
		if((hRes = m_pOfficeService->GetObject(EquipClassName,
											0L,	NULL,
											&pEquipClass,
											NULL)) != S_OK)
		{

			//-----------------------------------
			// create new class. Parm1 == NULL gives a new, empty
			// class to load with property values.
			if((hRes = m_pOfficeService->GetObject(NULL, 0, NULL, 
												&pEquipClass, NULL)) == S_OK)
			{

				// name the class.
				V_VT(&v) = VT_BSTR;
				V_BSTR(&v) = SysAllocString(L"SAMPLE_OfficeEquipment");
				BSTR Class = SysAllocString(L"__CLASS");
				pEquipClass->Put(Class, 0, &v, 0);
				SysFreeString(Class);
				VariantClear(&v);

				// 'SKU' is the key property
				V_VT(&v) = VT_BSTR;
				V_BSTR(&v) = SysAllocString(L"<default>");
				Prop = SysAllocString(L"SKU");
				pEquipClass->Put(Prop, 0, &v, 0);
				VariantClear(&v);
				SysFreeString(Prop);

				// Mark the "OfficeNum" property as the 'key'.
				IWbemQualifierSet *pQual = NULL;
				pEquipClass->GetPropertyQualifierSet(Prop, &pQual);
				V_VT(&v) = VT_BOOL;
				V_BOOL(&v) = VARIANT_TRUE;
				BSTR Key = SysAllocString(L"Key");

				// NOTE: Qualifier flavors not required for KEY
				pQual->Put(Key, 
							&v, 
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);
				SysFreeString(Key);

				// No longer need the qualifier set for "SKU".
				pQual->Release();   
				VariantClear(&v);

				// add description of item.
				V_VT(&v) = VT_BSTR;
				V_BSTR(&v) = SysAllocString(L"<default>");
				
				Prop = SysAllocString(L"Item");
				pEquipClass->Put(Prop, 0, &v, 0);
				SysFreeString(Prop);
				
				// register new class
				if((hRes = m_pOfficeService->PutClass(pEquipClass, 0, NULL, NULL)) != S_OK)
				{
					TRACE(_T("equipment PutClass() failed: %s\n"), ErrorString(hRes));
				}
				
				pEquipClass->Release();
				pEquipClass = NULL;

				//-----------------------------------
				// NOTE: now pEquipClass exists for sure but you have to go get a new pointer
				//  from CIMOM before you can spawnInstance() on it. You CANNOT continue to use
				//   the pEquipClass ptr from above.
				if((hRes = m_pOfficeService->GetObject(EquipClassName,
														0L,	NULL,
														&pEquipClass,
														NULL)) != S_OK)
				{
					TRACE(_T("Second GetObject() failed: %s\n"), ErrorString(hRes));
				} //endif GetObject()
			}
			else
			{
				TRACE(_T("GetObject() NULL failed: %s\n"), ErrorString(hRes));
			} //endif GetObject() NULL

		} // endif class doesnt exist.
		VariantClear(&v);
		
		//-----------------------------------
		// spawn a new instance
		if((hRes = pEquipClass->SpawnInstance(0, &pEquipInst)) == S_OK)
		{
			TRACE(_T("SpawnInstance() worked\n"));

			// set the property values
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = dlg.m_item.AllocSysString();
			Prop = SysAllocString(L"Item");
			pEquipInst->Put(Prop, 0, &v, 0);
			SysFreeString(Prop);
			VariantClear(&v);

			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = dlg.m_SKU.AllocSysString();
			Prop = SysAllocString(L"SKU");
			pEquipInst->Put(Prop, 0, &v, 0);
			VariantClear(&v);

			// putInstance
			hRes = m_pOfficeService->PutInstance(pEquipInst, 0, NULL, NULL);

			pEquipInst->Release();
			pEquipInst = NULL;

			CString str("SAMPLE_OfficeEquipment.SKU=\"");
			str += dlg.m_SKU;
			str += _T("\"");

			curInst = str.AllocSysString();

			TRACE(_T("flushing instance for %s\n"), str);

			if((hRes = m_pOfficeService->GetObject(curInst,
													0L,	NULL,
													&pEquipInst,
													NULL)) != S_OK)
			{
				TRACE(_T("Second GetObject() pEquipInst failed: %s\n"), ErrorString(hRes));
			} //endif GetObject()

			SysFreeString(Prop);
			SysFreeString(curInst);

			//-----------------------------------
			// make the association.
			AssociateToMachine(pEquipInst);

			pEquipInst->Release();
			pEquipInst = NULL;
		}
		else
		{
			TRACE(_T("SpawnInstance() failed: %s\n"), ErrorString(hRes));

		} //endif SpawnInstance()

		pEquipClass->Release();  // Don't need the class any more
		pEquipClass = NULL;

		//-----------------------------------
		// enum the office equipment for display purposes.
		if ((hRes = m_pOfficeService->CreateInstanceEnum(EquipClassName,
													WBEM_FLAG_SHALLOW, 
													NULL,
													&pEnumEquipment)) == S_OK) 
		{
			TRACE(_T("good equip enum\n"));

			m_outputList.ResetContent();

			uReturned = 1;
			while(uReturned == 1)
			{
				// enumerate through the resultset.
				hRes = pEnumEquipment->Next(TIMEOUT,
											1,
											&pEquipInst,
											&uReturned);

				TRACE(_T("Next() %d:%s\n"), uReturned, ErrorString(hRes));

				// was one found?
				if((hRes == S_OK) && (uReturned == 1))
				{
					TRACE(_T("Got a device class\n"));

					// Get the "SKU" property.
					VariantClear(&v);
					SysFreeString(Prop);
					Prop = SysAllocString(L"SKU");

					if (pEquipInst->Get(Prop, 0L, 
										&v, NULL, NULL) == S_OK) 
					{
						TRACE(_T("Got the SKU\n"));
						 buf = V_BSTR(&v);
						buf += _T("=>");
					} 

					// Get the "Item" property.
					VariantClear(&v);
					SysFreeString(Prop);
					Prop = SysAllocString(L"Item");

					if (pEquipInst->Get(Prop, 0L, 
										&v, NULL, NULL) == S_OK) 
					{
						TRACE(_T("Got an item\n"));
						buf += V_BSTR(&v);
					} 

					// add to the output listbox.
					m_outputList.AddString(buf);

					// cleanup for next loop
					VariantClear(&v);
					SysFreeString(Prop);

					// Done with this object.
					if (pEquipInst)
					{ 
						pEquipInst->Release();

						// NOTE: pEquipInst MUST be set to NULL for the next all to Next().
						pEquipInst = NULL;
					} 

				} // endif (hRes == S_OK)

			} // endwhile

			TRACE(_T("done enumming: %s\n"), ErrorString(hRes));

			// Done with this enumerator.
			if (pEnumEquipment)
			{ 
				pEnumEquipment->Release(); 
				pEnumEquipment = NULL;
			}
		} 
		else // CreateInstanceEnum() failed.
		{
			TRACE(_T("CreateInstanceEnum() failed: %s\n"), ErrorString(hRes));

		} // endif CreateInstanceEnum()

		SysFreeString(EquipClassName);

	} // endif EnsureOfficeNamespace()
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onasync.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnAsync.h
//
// Description:
//	This file declares the CAsyncQuerySink class. It is the sink
//		object for ExecQueryAsync() calls.
// 
// Part of: WMI Tutorial #1.
//
// Used by: OnAsync().
//
// History:
//
// **************************************************************************

class CAsyncQuerySink : public IWbemObjectSink
{
public:
    CAsyncQuerySink(CListBox *output);
    ~CAsyncQuerySink();

    STDMETHOD_(SCODE, Indicate)(long lObjectCount,
								IWbemClassObject **pObjArray);

    STDMETHOD_(SCODE, SetStatus)(long lFlags,
									HRESULT hResult,
									BSTR strParam,
									IWbemClassObject *pObjParam);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
		{return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
		{return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
		{return E_NOTIMPL;}

private:
    long m_lRef;
	CListBox *m_pOutputList;
	BOOL m_SetStatusCalled;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onasync.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnAsync.cpp
//
// Description:
//	This file implements the ExecQueryAsync() routine and the 
//		CAsyncQuerySink class. 
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClientDlg.h"
#include "OnAsync.h"

// **************************************************************************
//
//	CAdvClientDlg::OnEnumservicesasync()
//
// Description:
//		Enumerate the services. Demonstrates ExecQueryAsync() using SQL1 and
//		begin/end enumeration through properties. The setup portion is the
//		same as OnEnumServices() but the 'enumerating' part is in the Object
//		Sink.
//
// Parameters:
//		None.
//
// Returns:
//		nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::OnEnumservicesasync() 
{
	HRESULT  hRes;

	//---------------------------
	// allocate the sink if its not already allocated.
	if(m_pQueryCallback == NULL)
	{
		m_pQueryCallback = new CAsyncQuerySink(&m_outputList);
		m_pQueryCallback->AddRef();
	}

	BSTR qLang = SysAllocString(L"WQL");
	BSTR query = SysAllocString(L"select * from Win32_Service");

	m_outputList.ResetContent();
	m_outputList.AddString(_T("working..."));

	//---------------------------
	// execute the query. For *Async, the last parm is a sink object
	// that will be sent the resultset instead of returning the normal
	// enumerator object.
	if((hRes = m_pIWbemServices->ExecQueryAsync(qLang, query,
											0L, NULL,              
											m_pQueryCallback)) == S_OK)
	{
		TRACE(_T("Executed query\n"));

		m_outputList.ResetContent();
	}
	else
	{
		TRACE(_T("ExecQuery() failed %s\n"), ErrorString(hRes));

	} //endif ExecQuery()

	SysFreeString(qLang);
	SysFreeString(query);
	
}
// **************************************************************************
//
//	CAsyncQuerySink::CAsyncQuerySink()
//
// Description:
//		This is the sink that gets called as a result of ExecQueryAsync().
//		It has the obligatory COM functions plus Indicate() and SetStatus()
//		which are documented in more detail below.
//===========================================================================
CAsyncQuerySink::CAsyncQuerySink(CListBox *output)
{
	m_pOutputList = output;
	m_SetStatusCalled = FALSE;
}
// ========================================================
CAsyncQuerySink::~CAsyncQuerySink()
{
	if(!m_SetStatusCalled)
	{
		// NOTE: This happening is indicative of a comm error
		// between the server and this client such as a security
		// violation. CoInitializeSecurity() needs to be called to
		// avoid the security problem.
		TRACE(_T("released before SetStatus() was called\n"));
	}
}
// ========================================================
STDMETHODIMP CAsyncQuerySink::QueryInterface(REFIID riid, LPVOID* ppv)
{
	// we're implementing the IID_IWbemObjectSink interface.
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = this;

		// you're handing out a copy of yourself so account for it.
        AddRef();
        return S_OK;
    }
    else 
	{
		return E_NOINTERFACE;
	}
}

// ========================================================
ULONG CAsyncQuerySink::AddRef()
{
	// InterlockedIncrement() helps with thread safety.
    return InterlockedIncrement(&m_lRef);
}

// ========================================================
ULONG CAsyncQuerySink::Release()
{
	// InterlockedDecrement() helps with thread safety.
    int lNewRef = InterlockedDecrement(&m_lRef);
	// when all the copies are released...
    if(lNewRef == 0)
    {
		// kill thyself.
        delete this;
    }

    return lNewRef;
}

// **************************************************************************
//
//	CAsyncQuerySink::Indicate()
//
// Description:
//		This method is called to handle the result of the ExecQueryAsync().
//		There are no assumtions about how many objects are passed on each
//		call or how many calls will be made.
// Parameters:
//		lObjectCount (in) - how many objects are being passed.
//		ppObjArray (in) - array of objects from the query.
//
// Returns:
//		S_OK if successful, otherwise the HRESULT of the failed called.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
STDMETHODIMP CAsyncQuerySink::Indicate(LONG lObjectCount,
									   IWbemClassObject **ppObjArray)
{
	HRESULT  hRes;
	WCHAR *pBuf;
	CString clMyBuff;
	BSTR propName = NULL, val = NULL;
	VARIANT varString, pVal;

	VariantInit(&varString);
	VariantInit(&pVal);

	TRACE(_T("Indicate() called\n"));

	//------------------------------
	// walk though the classObjects...
	for (int i = 0; i < lObjectCount; i++)
	{
		// clear my output buffer.
		clMyBuff.Empty();

		//------------------------------
		// enumerate properties.
		if((hRes = ppObjArray[i]->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)) == S_OK)
		{
			//------------------------------
			// try to get the next property.
			while(ppObjArray[i]->Next(0, &propName,   
										&pVal, NULL, NULL) == S_OK)
			{
				// is it one of the 'names' we want?
				if((wcsncmp(propName, L"Name", 4) == 0) ||
					(wcsncmp(propName, L"DisplayName", 11) == 0) ||
					(wcsncmp(propName, L"PathName", 8) == 0))
				{
					// format the property=value/
					clMyBuff += propName;
					clMyBuff += _T("=");
					clMyBuff += ValueToString(&pVal, &pBuf);
					clMyBuff += _T("/");
					free(pBuf); // allocated by ValueToString()

				} //endif wcsncmp()...

				// cleanup stuff used in the Next() loop.
				SysFreeString(propName);
				VariantClear(&pVal);

			} //endwhile

			// did the while loop exit due to an error?
			if(hRes != S_OK)
			{
				TRACE(_T("ppObjArray[i]->Next() failed %s\n"), ErrorString(hRes));
			}
		}
		else
		{
			TRACE(_T("BeginEnumeration() failed %s\n"), ErrorString(hRes));
		} //endif BeginEnumeration()

		// output the buffer.
		m_pOutputList->AddString(clMyBuff);

		//------------------------------
		// free the property iterator workspace.
		ppObjArray[i]->EndEnumeration();

		// no need to release because the caller does the
		// AddRef()/Release()

	} // endfor

	TRACE(_T("walked indication list\n"));

	return S_OK;
}
// **************************************************************************
//
//	CAsyncQuerySink::SetStatus()
//
// Description:
//		Called after all Indication()s have been called. This signals the
//		completion of the query.
//
// Parameters:
//		per WMI requirements.
//
// Returns:
//		S_OK if successful, otherwise the HRESULT of the failed called.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
STDMETHODIMP CAsyncQuerySink::SetStatus(long lFlags,
										HRESULT hResult,
										BSTR strParam,
										IWbemClassObject *pObjParam)
{
	TRACE(_T("SetStatus() called %s\n"), ErrorString(hResult));

	m_SetStatusCalled = TRUE;

	// all the Indication()s worked fine.
	if(hResult == WBEM_NO_ERROR)
	{
		m_pOutputList->AddString(_T("Done Enumerating"));
	}
	else // or not.
	{
		m_pOutputList->AddString(_T("Enumeration Error!!"));
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onenumdisks.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnEnumDisks.cpp
//
// Description:
//	This file implements the OnEnumDisks() routine which 
//		demonstrates simple instance enumeration.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClientDlg.h"

#define TIMEOUT -1
// **************************************************************************
//
//	CAdvClientDlg::OnEnumdisks()
//
// Description:
//		Enumerates all the disks on a machine. Demonstrates getting
//		known properties directly.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::OnEnumdisks() 
{
	// these are for enumerating.
	HRESULT  hRes;
	ULONG uReturned;
	IWbemClassObject *pStorageDev = NULL;
	IEnumWbemClassObject *pEnumStorageDevs = NULL;

	// these help get properties.
	VARIANT pVal;
	BSTR propName = NULL;
    CString buf;

	// here's what we're looking for.
	// NOTE: make sure you specify a class that has a Provider()
	//	specified for it in the mof file. All other classes are
	//	abstract and wont be found using HMM_FLAG_SHALLOW. They
	//	will be found using HMM_FLAG_DEEP.
	BSTR className = SysAllocString(L"Win32_LogicalDisk");

	VariantInit(&pVal);

	m_outputList.ResetContent();
	m_outputList.AddString(_T("working..."));

	TRACE(_T("Going for class\n"));

	//---------------------------
	// get the list of logical storage devices.
    if ((hRes = m_pIWbemServices->CreateInstanceEnum(className,
												WBEM_FLAG_SHALLOW, 
												NULL,
												&pEnumStorageDevs)) == S_OK) 
	{
		TRACE(_T("good enumerator\n"));

		m_outputList.ResetContent();

		uReturned = 1;
		while(uReturned == 1)
		{
			//---------------------------
			// enumerate through the resultset.
			hRes = pEnumStorageDevs->Next(TIMEOUT,
										1,
										&pStorageDev,
										&uReturned);

			TRACE(_T("Next() %d:%s\n"), uReturned, ErrorString(hRes));

			// was one found?
			if((hRes == S_OK) && (uReturned == 1))
			{

				TRACE(_T("Got a device class\n"));

				VariantClear(&pVal);

				//---------------------------
				// setup for the "__RELPATH" system property.
				propName = SysAllocString(L"__RELPATH");

				// Add the path
				if (pStorageDev->Get(propName, 
										0L, 
										&pVal, 
										NULL, NULL) == S_OK) 
				{
					TRACE(_T("Got a device path\n"));
					 buf = V_BSTR(&pVal);
				} 

				// add to the output listbox.
				m_outputList.AddString(buf);

				// cleanup for next loop
				VariantInit(&pVal);

				// Done with this object.
				if (pStorageDev)
				{ 
					pStorageDev->Release();

					// NOTE: pStorageDev MUST be set to NULL for the next all to Next().
					pStorageDev = NULL;
				} 

			} // endif (hRes == S_OK)

        } // endwhile

		TRACE(_T("done enumming: %s\n"), ErrorString(hRes));

		// Done with this enumerator.
		if (pEnumStorageDevs)
		{ 
			pEnumStorageDevs->Release(); 
			pEnumStorageDevs = NULL;
		}
    } 
	else // CreateInstanceEnum() failed.
	{
		TRACE(_T("CreateInstanceEnum() failed: %s\n"), ErrorString(hRes));

	} // endif CreateInstanceEnum()

	TRACE(_T("returning\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\ondiskdetails.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnDiskDetails.cpp
//
// Description:
//	This file implements the OnDiskDetails() routine which 
//		demonstrates how to enumerate properties on your C:
//		drive.
// 
// History:
//
// **************************************************************************


#include "stdafx.h"
#include "AdvClientDlg.h"

// **************************************************************************
//
//	CAdvClientDlg::OnDiskdetails()
//
// Description:
//		Enumerates the properties of the C: drive using the 'GetNames()'
//		technique. The technique uses safearrays.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::OnDiskdetails() 
{
	HRESULT  hRes;
	long lLower, lUpper, lCount; 
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	BSTR cimType = NULL;
	BSTR keyQual = NULL;
	VARIANT varString, pVal;
	WCHAR *pBuf;
	CString clMyBuff;

	IWbemClassObject *pDriveInst = NULL;
	IWbemQualifierSet *pQualSet = NULL;

	VariantInit(&varString);
	VariantInit(&pVal);

	m_outputList.ResetContent();
	m_outputList.AddString(_T("working..."));

	//-------------------------------
	// Get the instance for C: drive.
	BSTR driveName = SysAllocString(L"Win32_LogicalDisk.DeviceID=\"C:\"");

    if((hRes = m_pIWbemServices->GetObject(driveName,
										0L,
										NULL,
										&pDriveInst,
										NULL)) == S_OK)
	{

		m_outputList.ResetContent();

		//-------------------------------
		// Get the property names
		if((hRes = pDriveInst->GetNames(NULL, 
										WBEM_FLAG_ALWAYS | 
										WBEM_FLAG_NONSYSTEM_ONLY, 
										NULL, 
										&psaNames)) == S_OK)
		{
			//-------------------------------
			// Get the upper and lower bounds of the Names array
			if((hRes = SafeArrayGetLBound(psaNames, 1, &lLower)) != S_OK) 
			{
				TRACE(_T("Couldn't get safe array lbound\n"));
				SafeArrayDestroy(psaNames);
				return;
			}

			//-------------------------------
			if((hRes = SafeArrayGetUBound(psaNames, 1, &lUpper)) != S_OK) 
			{
				TRACE(_T("Couldn't get safe array ubound\n"));
				SafeArrayDestroy(psaNames);
				return;
			}

			// we'll need these inside the loop
			cimType = SysAllocString(L"CIMTYPE");
			keyQual = SysAllocString(L"key");

			//-------------------------------
			// For all properties...
			for (lCount = lLower; lCount <= lUpper; lCount++) 
			{
				//-----------------------------------------------
				// I'm formatting each property as:
				//   name (type) ==> value
				//-----------------------------------------------

				//-------------------------------
				// get the property name for this element
				if((hRes = SafeArrayGetElement(psaNames, 
												&lCount, 
												&PropName)) == S_OK)
				{
					clMyBuff = PropName;

					// print variable type for property value
					clMyBuff += _T(" (");

					// Get pointer to property qualifiers
					// this mess is due to the fact that system properties don't have qualifiers
					if ((pDriveInst->GetPropertyQualifierSet(PropName, &pQualSet)) == S_OK) 
					{
						// Get and print syntax attribute (if any)
						if ((pQualSet->Get(cimType, 0L, &pVal, NULL)) == S_OK) 
						{
						   clMyBuff += V_BSTR(&pVal);
						} 
						else if (hRes != WBEM_E_NOT_FOUND) 
						{  // some other error
						   TRACE(_T("Could not get syntax qualifier\n"));
						   break;
						}
						VariantClear(&pVal);

						//-------------------------------
						// If this is a key field, print an asterisk
						if(((hRes = pQualSet->Get(keyQual, 
												0L, 
												&pVal, 
												NULL)) == S_OK) && 
							(pVal.boolVal))
						{ // Yes, it's a key
						   clMyBuff += _T(")*");
						} 
						else if (hRes == WBEM_E_NOT_FOUND) 
						{  // not a key qualifier
						   clMyBuff += _T(")");
						} 
						else 
						{ // some other error
						   TRACE(_T("Could not get key qualifier\n"));
						   break;
						}
						// done with the qualifierSet.
						if (pQualSet)
						{ 
							pQualSet->Release(); 
							pQualSet = NULL;
						}
					} 
					else 
					{
						clMyBuff += _T(")");
					} //endif pDriveClass->GetPropertyQualifierSet()

					//-------------------------------
					// Get the value for the property.
					if((hRes = pDriveInst->Get(PropName, 
												0L, 
												&varString, 
												NULL, NULL)) == S_OK) 
					{
						// Print the value
						clMyBuff += _T("   ==> ");
						clMyBuff += ValueToString(&varString, &pBuf);
						
						m_outputList.AddString(clMyBuff);

						free(pBuf); // allocated by ValueToString()
					}
					else
					{
						TRACE(_T("Couldn't get Property Value\n"));
						break;
					} //endif pDriveClass->Get()

					VariantClear(&varString);
					VariantClear(&pVal);
				}
				else // SafeArrayGetElement() failed
				{
					TRACE(_T("Couldn't get safe array element\n"));
					break;
				} //endif SafeArrayGetElement()

			} // endfor

			// cleanup.
			SysFreeString(PropName);
			SysFreeString(keyQual);
			SysFreeString(cimType);
			SafeArrayDestroy(psaNames);
			VariantClear(&varString);
			VariantClear(&pVal);
		}
		else // pDriveClass->GetNames() failed
		{
			TRACE(_T("Couldn't GetNames\n"));
		} //endif pDriveClass->GetNames()

		// done with drive instance.
		if (pDriveInst)
		{ 
			pDriveInst->Release(); 
			pDriveInst = NULL;
		}
	} //endif GetObject()
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onconnect.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnConnect.cpp
//
// Description:
//	This file implements the OnConnect() routine which 
//		demonstrates how to connect to CIMOM and one if
//		its namespaces.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClientDlg.h"

// **************************************************************************
//
//	CAdvClientDlg::OnConnect()
//
// Description:
//		Connects to the namespace specified in the edit box.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::OnConnect() 
{
	IWbemLocator *pIWbemLocator = NULL;

	UpdateData();
	//------------------------
   // Create an instance of the WbemLocator interface.
   if(CoCreateInstance(CLSID_WbemLocator,
					  NULL,
					  CLSCTX_INPROC_SERVER,
					  IID_IWbemLocator,
					  (LPVOID *) &pIWbemLocator) == S_OK)
   {
		//------------------------
		// Use the pointer returned in step two to connect to
		//     the server using the passed in namespace.
		BSTR pNamespace = m_namespace.AllocSysString();
		HRESULT hr = S_OK;

		if((hr = pIWbemLocator->ConnectServer(pNamespace,
								NULL,   //using current account for simplicity
								NULL,	//using current password for simplicity
								0L,		// locale
								0L,		// securityFlags
								NULL,	// authority (domain for NTLM)
								NULL,	// context
								&m_pIWbemServices)) == S_OK) 
		{	
			// indicate success.
			m_outputList.ResetContent();
			m_outputList.AddString(_T("Connected To Namespace"));

			// its safe the hit the other buttons now.
			m_enumServices.EnableWindow(TRUE);
			m_enumServicesAsync.EnableWindow(TRUE);
			m_enumDisks.EnableWindow(TRUE);
			m_diskDetails.EnableWindow(TRUE);
			m_connect.EnableWindow(TRUE);
			m_addEquipment.EnableWindow(TRUE);
			m_diskDescriptions.EnableWindow(TRUE);

			// dont allow reconnection.
			m_connect.EnableWindow(FALSE);

			// since these guys register for the non-standard
			// root/default/office namespace, dont enable them unless 
			// that namespace exists.
			if(CheckOfficeNamespace())
			{
				m_perm.EnableWindow(TRUE);
				m_temp.EnableWindow(TRUE);
			}

			// initialize the Register Perm button.
			if(PermRegistered())
			{
				// init for UNregistering.
				m_regPerm = FALSE;
				m_perm.SetWindowText(_T("Unregister &Perm"));
			}
			else // its not registered...
			{
				// init for registering.
				m_regPerm = TRUE;
				m_perm.SetWindowText(_T("Register &Perm"));
			}
		}
		else
		{	
			// failed ConnectServer()
			AfxMessageBox(_T("Bad namespace"));
		}

		// done with pNamespace.
		if(pNamespace) 
		{
			SysFreeString(pNamespace);
		}

		//------------------------
		// done with pIWbemLocator. 
		if (pIWbemLocator)
		{ 
			pIWbemLocator->Release(); 
			pIWbemLocator = NULL;
		}
	}
	else // failed CoCreateInstance()
	{	
		AfxMessageBox(_T("Failed to create IWbemLocator object"));

	} // endif CoCreateInstance()
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\ondiskpropsdescriptions.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnDiskPropsDescriptions.cpp
//
// Description:
//	This file implements the OnDiskPropsDescriptions() routine which 
//		lists description qualifiers of a class and its properties.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClientDlg.h"

// **************************************************************************
//
//	CAdvClientDlg::OnDiskPropsDescriptions()
//
// Description:
//		OnDiskPropsDescriptions.cpp lists class description and property descriptions
//		for Win32_LogicalDisk class. Note that description qualifiers can be quite lengthy
//		and are normally not retrieved, unless WBEM_FLAG_USE_AMENDED_QUALIFIERS flag 
//		is specified in IWbemServices::GetObject(). 
//
//		Object qualifiers are retieved by IWbemClassObject::GetQualifierSet(). 
//		Property qualifiers are retrieved by IWbemClassObject::GetPropertyQualifierSet() 
//		- you need to supply property name as a parameter.
//
//		Get() method on the IWbemQualifierSet retrives specific qualifier values - 
//		in this case, descriptions.
//
//		Amended qualifiers (such as descriptions) are localizable and 
//		will be displayed in the language that corresponds to the current user 
//		locale on the client machine, as long as the server is able to provide
//		appropriate localized resources.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================


void CAdvClientDlg::OnDiskPropsDescriptions() 
{

	HRESULT  hRes;
	long lLower, lUpper, lCount; 
	SAFEARRAY *psaNames = NULL;
	VARIANT pVal;
	BSTR PropName = NULL;
	CString clMyBuff;

	VariantInit(&pVal);

	IWbemClassObject *pDriveClass = NULL;
	IWbemQualifierSet *pQualSet = NULL;

	m_outputList.ResetContent();
	m_outputList.AddString(_T("working..."));

	BSTR driveClassName = SysAllocString(L"Win32_LogicalDisk");
	BSTR descr = SysAllocString(L"Description");

    if((hRes = m_pIWbemServices->GetObject(driveClassName,
										WBEM_FLAG_USE_AMENDED_QUALIFIERS,	// this is necessary to retrieve descriptions
										NULL,
										&pDriveClass,
										NULL)) == S_OK)
	{

		m_outputList.ResetContent();

		//get class description
		hRes = pDriveClass->GetQualifierSet(&pQualSet);
		if (hRes == S_OK) 
		{
			hRes = pQualSet->Get(descr, 0L, &pVal, NULL);
			if (hRes == S_OK) 
			{
			   m_outputList.AddString(CString(V_BSTR(&pVal)));
			} 

			VariantClear(&pVal);
		}
		pQualSet->Release();

		//-------------------------------
		// Get the property names
		if((hRes = pDriveClass->GetNames(NULL, 
										WBEM_FLAG_ALWAYS | 
										WBEM_FLAG_NONSYSTEM_ONLY, 
										NULL, 
										&psaNames)) == S_OK)
		{
			//-------------------------------
			// Get the upper and lower bounds of the Names array
			if((hRes = SafeArrayGetLBound(psaNames, 1, &lLower)) != S_OK) 
			{
				TRACE(_T("Couldn't get safe array lbound\n"));
				SafeArrayDestroy(psaNames);
				return;
			}

			//-------------------------------
			if((hRes = SafeArrayGetUBound(psaNames, 1, &lUpper)) != S_OK) 
			{
				TRACE(_T("Couldn't get safe array ubound\n"));
				SafeArrayDestroy(psaNames);
				return;
			}


			//-------------------------------
			// For all properties...
			for (lCount = lLower; lCount <= lUpper; lCount++) 
			{

				//-------------------------------
				// get the property name for this element
				if((hRes = SafeArrayGetElement(psaNames, 
												&lCount, 
												&PropName)) == S_OK)
				{
				
					// Get pointer to property qualifiers
					// this mess is due to the fact that system properties don't have qualifiers
					if ((pDriveClass->GetPropertyQualifierSet(PropName, &pQualSet)) == S_OK) 
					{
						// Get and print description
						if ((pQualSet->Get(descr, 0L, &pVal, NULL)) == S_OK) 
						{
							m_outputList.AddString(CString(V_BSTR(&pVal)));
						} 
						VariantClear(&pVal);

						// done with the qualifierSet.
						if (pQualSet)
						{ 
							pQualSet->Release(); 
							pQualSet = NULL;
						}
					} 

				}
				else // SafeArrayGetElement() failed
				{
					TRACE(_T("Couldn't get safe array element\n"));
					break;
				} //endif SafeArrayGetElement()

			} // endfor

			// cleanup.
			SysFreeString(PropName);
			SysFreeString(descr);
			SafeArrayDestroy(psaNames);
			VariantClear(&pVal);
		}
		else // pDriveClass->GetNames() failed
		{
			TRACE(_T("Couldn't GetNames\n"));
		} //endif pDriveClass->GetNames()

		// done with drive instance.
		if (pDriveClass)
		{ 
			pDriveClass->Release(); 
			pDriveClass = NULL;
		}
	} //endif GetObject()

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onperm.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnPerm.cpp
//
// Description:
//	This file implements the register/unregister of permenant
//		event consumers. The actual consumer is the WBEMPermEvents
//		project.
// 
// History:
//
// **************************************************************************
#include "stdafx.h"
#include "AdvClientDlg.h"
#include <tchar.h>

// my specific class GUID.
// {1E069401-087E-11d1-AD85-00AA00B8E05A}
static const GUID CLSID_AdvClientConsumer = 
{ 0x1e069401, 0x87e, 0x11d1, { 0xad, 0x85, 0x0, 0xaa, 0x0, 0xb8, 0xe0, 0x5a } };

// ========================================================
BOOL CAdvClientDlg::PermRegistered()
{
	HRESULT hRes;
	BOOL retval = FALSE;
	IWbemClassObject *pConsumerInst = NULL;
	BSTR instName = SysAllocString(L"__EventFilter.Name=\"Sample Perm Query\"");

	// switch to the root\cimv2\office namespace.
	if(EnsureOfficeNamespace())
	{
		// if the EventFilter is there...
		if((hRes = m_pOfficeService->GetObject(instName,
												0L,	NULL,
												&pConsumerInst,
												NULL)) == S_OK)
		{
			pConsumerInst->Release();
			pConsumerInst = NULL;

			// assume the perm sink is registered.
			retval = TRUE;
		}
	}

	SysFreeString(instName);
	return retval;
}

// ========================================================
BOOL CAdvClientDlg::OnPermRegister() 
{
	BOOL retval = FALSE;
	IWbemClassObject *pConsumer = NULL;
	IWbemClassObject *pFilter = NULL;
	
	m_eventList.ResetContent();

	// switch to the root\cimv2\office namespace.
	if(EnsureOfficeNamespace())
	{
		if(GetConsumer(&pConsumer))
		{
			if(AddFilter(&pFilter))
			{
				if(AddBinding(pConsumer, pFilter))
				{
					retval = TRUE;
					m_eventList.AddString(_T("Permanent is ready"));
				}
				else
				{
					m_eventList.AddString(_T("Failed To Register"));
				} //endif AddBinding()
			}
			else
			{
			} //endif AddFilter()
		}
		else
		{
		} //endif AddConsumer()
	}
	return retval;
}
// ========================================================
void CAdvClientDlg::OnPermUnregister() 
{
	HRESULT hRes;
	BSTR instName;

	if(EnsureOfficeNamespace())
	{
		// delete the filter instance.
		instName = SysAllocString(L"__EventFilter.Name=\"Sample Perm Query\"");
		if((hRes = m_pOfficeService->DeleteInstance(instName,
													0L,	NULL,
													NULL)) != S_OK)
		{
			TRACE(_T("Cant delete filter, %s\n"), ErrorString(hRes));
		}
		SysFreeString(instName);

		// delete the association instance.
		// NOTE: Remember the triple backslashes on the inner quotes.
		instName = SysAllocString(L"__FilterToConsumerBinding.Consumer=\"SampleViewerConsumer.Name=\\\"Sample says:\\\"\",Filter=\"__EventFilter.Name=\\\"Sample Perm Query\\\"\"");
		if((hRes = m_pOfficeService->DeleteInstance(instName,
													0L,	NULL,
													NULL)) != S_OK)
		{
			TRACE(_T("Cant delete association, %s\n"), ErrorString(hRes));
		}

		SysFreeString(instName);
	}
	m_eventList.ResetContent();
	m_eventList.AddString(_T("Permanent is removed"));
}

//------------------------------------------------------------
BOOL CAdvClientDlg::GetConsumer(IWbemClassObject **ppConsumer)
{
	BOOL retval = FALSE;
	HRESULT hRes;
	BSTR curInst;
	CString str(L"SampleViewerConsumer.Name=\"Sample says:\"");
//	CString ConsumerCLSID(L"{1E069401-087E-11d1-AD85-00AA00B8E05A}");

	curInst = str.AllocSysString();

	//---------------------
	if((hRes = m_pOfficeService->GetObject(curInst, 0L, NULL,
											ppConsumer,	NULL)) == S_OK)
	{
		retval = TRUE;
	}
	else
	{
		TRACE(_T("Second GetObject() pConsumerInst failed: %s\n"), ErrorString(hRes));
	} //endif GetObject()

	SysFreeString(curInst);

	return retval;
}
// ========================================================
BOOL CAdvClientDlg::AddFilter(IWbemClassObject **ppFilter)
{
	BOOL retval = FALSE;

	CString FilterName(_T("Sample Perm Query"));
	CString FilterClass(L"__EventFilter");
	CString FilterClassKey(L"Name");
	CString QueryProp(L"Query");
	CString LangProp(L"QueryLanguage");
	CString theQuery(L"select * from __InstanceCreationEvent where TargetInstance isa \"SAMPLE_OfficeEquipment\"");
	BSTR FilterClassName = FilterClass.AllocSysString();
	BSTR Prop = NULL;
	BSTR curInst = NULL;

	IWbemClassObject *pFilterClass = NULL;
	IWbemClassObject *pFilterInst = NULL;

	HRESULT hRes;
	VARIANT v;

	//---------------------
	// if class exists...
	if((hRes = m_pOfficeService->GetObject(FilterClassName,
									0L,	NULL,
									&pFilterClass,
									NULL)) == S_OK)
	{
		//---------------------
		// spawn a new instance
		if((hRes = pFilterClass->SpawnInstance(0, &pFilterInst)) == S_OK)
		{
			TRACE(_T("SpawnInstance() worked\n"));

			// set the key property.
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = FilterName.AllocSysString();
			Prop = FilterClassKey.AllocSysString();
			pFilterInst->Put(Prop, 0, &v, 0);
			VariantClear(&v);
			SysFreeString(Prop);

			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = theQuery.AllocSysString();
			Prop = QueryProp.AllocSysString();
			pFilterInst->Put(Prop, 0, &v, 0);
			VariantClear(&v);
			SysFreeString(Prop);

			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = SysAllocString(L"WQL");
			Prop = LangProp.AllocSysString();
			pFilterInst->Put(Prop, 0, &v, 0);
			VariantClear(&v);
			SysFreeString(Prop);

			//---------------------
			// putInstance
			hRes = m_pOfficeService->PutInstance(pFilterInst, 0, NULL, NULL);

			pFilterInst->Release();
			pFilterInst = NULL;

			CString str = FilterClass + _T(".") + FilterClassKey;
			str += _T("=\"");
			str += FilterName;
			str += _T("\"");

			curInst = str.AllocSysString();

			TRACE(_T("flushing instance for %s\n"), str);

			//---------------------
			if((hRes = m_pOfficeService->GetObject(curInst, 0L, NULL,
											ppFilter, NULL)) == S_OK)
			{
				retval = TRUE;
			}
			else
			{
				TRACE(_T("Second GetObject() pFilterInst failed: %s\n"), ErrorString(hRes));
			} //endif GetObject()

			SysFreeString(curInst);
		}
		else
		{
			TRACE(_T("SpawnInstance() failed: %s\n"), ErrorString(hRes));

		} //endif SpawnInstance()

		pFilterClass->Release();  // Don't need the class any more
		pFilterClass = NULL;

	} // endif class doesnt exist.
	
	SysFreeString(FilterClassName);
	return retval;
}
// ========================================================
BOOL CAdvClientDlg::AddBinding(IWbemClassObject *pConsumer, 
								IWbemClassObject *pFilter)
{
	BOOL retval = FALSE;
	HRESULT hRes;
	VARIANT v;
	
	IWbemClassObject *pAClass = NULL;
	IWbemClassObject *pAInst = NULL;

	BSTR AssocClassName = SysAllocString(L"__FilterToConsumerBinding");
	BSTR ConsumerProp = SysAllocString(L"Consumer");
	BSTR FilterProp = SysAllocString(L"Filter");

	VariantInit(&v);

	// if association class exists...
	if((hRes = m_pOfficeService->GetObject(AssocClassName,
										0L,	NULL,
										&pAClass,
										NULL)) == S_OK)
	{
		//------------------------------
		// spawn a new instance.
		if((hRes = pAClass->SpawnInstance(0, &pAInst)) == S_OK)
		{
			TRACE(_T("Assoc SpawnInstance() worked\n"));

			BSTR PathProp = SysAllocString(L"__RELPATH");

			//-----------------------------------
			// set consumer instance name
			if ((hRes = pConsumer->Get(PathProp, 0L, 
									&v, NULL, NULL)) == S_OK) 
			{
				hRes = pAInst->Put(ConsumerProp, 0, &v, 0);
				TRACE(_T("Got Consumer ref: %s\n"), ErrorString(hRes));
				VariantClear(&v);
			}
			else
			{
				TRACE(_T("Get() consumer ref failed: %s\n"), ErrorString(hRes));
			} //endif Get()

			//-----------------------------------
			// set Filter ref
			if ((hRes = pFilter->Get(PathProp, 0L, 
									&v, NULL, NULL)) == S_OK) 
			{
				hRes = pAInst->Put(FilterProp, 0, &v, 0);
				TRACE(_T("Got filter ref: %s\n"), ErrorString(hRes));
				VariantClear(&v);
			}
			else
			{
				TRACE(_T("Get() filter ref failed: %s\n"), ErrorString(hRes));
			} //endif Get()

			SysFreeString(PathProp);

			//-----------------------------------
			// putInstance
			if((hRes = m_pOfficeService->PutInstance(pAInst, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)) == S_OK)
			{
				retval = TRUE;
			}
			else
			{
				TRACE(_T("PutInstance() __FilterToConsumerBinding failed: %s\n"), ErrorString(hRes));
			}
			
			pAInst->Release();
			pAInst = NULL;
		}
		else
		{
			TRACE(_T("SpawnInstance() failed: %s\n"), ErrorString(hRes));

		} //endif SpawnInstance()
	}
	else
	{
		TRACE(_T("GetObject() class failed: %s\n"), ErrorString(hRes));

	} // endif GetObject() class.
	

	if(pAClass)
	{
		pAClass->Release();
		pAClass = NULL;
	}

	SysFreeString(AssocClassName);
	SysFreeString(ConsumerProp);
	SysFreeString(FilterProp);

	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onregister.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnAddUser.cpp
//
// Description:
//	This file implements the OnAddUser() routine which 
//		demonstrates how to add WMI user accounts, user
//		groups and NTLM authenticator instances.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClientDlg.h"
#include <objbase.h>

// **************************************************************************
//
//	CAdvClientDlg::OnRegPerm()
//
// Description:
//		Handles the GUI aspects of the Register Perm button
//		and calls the right worker routine.
//
// Parameters:
//		none.
//
// Returns:
//		nothing
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================

void CAdvClientDlg::OnRegPerm() 
{
	// if registered.
	if(m_regPerm)
	{
		if(OnPermRegister())
		{
			m_regPerm = FALSE;
			m_perm.SetWindowText(_T("Unregister &Perm"));
		}
	}
	else
	{
		m_regPerm = TRUE;
		OnPermUnregister();
		m_perm.SetWindowText(_T("Register &Perm"));
	}
	
}

// **************************************************************************
//
//	CAdvClientDlg::OnRegTemp()
//
// Description:
//		Handles the GUI aspects of the Register Temp button
//		and calls the right worker routine.
//
// Parameters:
//		none.
//
// Returns:
//		nothing
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::OnRegTemp() 
{
	if(m_regTemp)
	{
		if(OnTempRegister())
		{
			m_regTemp = FALSE;
			m_temp.SetWindowText(_T("Unregister &Temp"));
		}
	}
	else
	{
		m_regTemp = TRUE;
		OnTempUnregister();
		m_temp.SetWindowText(_T("Register &Temp"));
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\onenumsvcs.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnEnumSvcs.cpp
//
// Description:
//	This file implements the OnEnumservices() routine which 
//		demonstrates the ExecQuery() calls.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "AdvClientDlg.h"

#define TIMEOUT -1


// **************************************************************************
//
//	CAdvClientDlg::OnEnumservices()
//
// Description:
//		Enumerate the services. Demonstrates ExecQuery() using WQL and
//		begin/end enumeration through properties.
// Parameters:
//		None.
//
// Returns:
//		nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CAdvClientDlg::OnEnumservices() 
{
	HRESULT  hRes;
	BSTR propName = NULL, val = NULL;
	VARIANT pVal;
	WCHAR *pBuf;
	CString clMyBuff, prop;
	ULONG uReturned;

	IWbemClassObject *pService = NULL;
	IEnumWbemClassObject *pEnumServices = NULL;

	BSTR qLang = SysAllocString(L"WQL");
	BSTR query = SysAllocString(L"select * from Win32_Service");

	m_outputList.ResetContent();
	m_outputList.AddString(_T("working..."));

	//----------------------
	// execute the query.
	if((hRes = m_pIWbemServices->ExecQuery(qLang, query,
										0L, NULL,              
										&pEnumServices)) == S_OK)
	{
		TRACE(_T("Executed query\n"));

		m_outputList.ResetContent();

		//----------------------
		// enumerate through services.
		while(((hRes = pEnumServices->Next(TIMEOUT, 1,
										&pService, &uReturned)) == S_OK) &&
			  (uReturned == 1))
		{
			// clear my output buffer.
			clMyBuff.Empty();

			//----------------------
			// different way to enumerate properties.
			if((hRes = pService->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)) == S_OK)
			{
				//----------------------
				// try to get the next property.
				while(pService->Next(0, &propName,   
									&pVal, NULL, NULL) == S_OK)
				{
					// is it one of the 'names' we want?
					if((wcsncmp(propName, L"Name", 4) == 0) ||
						(wcsncmp(propName, L"DisplayName", 11) == 0) ||
						(wcsncmp(propName, L"PathName", 8) == 0))
					{
						// format the property=value/
						clMyBuff += propName;
						clMyBuff += _T("=");
						clMyBuff += ValueToString(&pVal, &pBuf);
						clMyBuff += _T("/");
						free(pBuf); // allocated by ValueToString()
					}

					// cleanup stuff used in the Next() loop.
					SysFreeString(propName);
					VariantClear(&pVal);
				}

				// did the while loop exit due to an error?
				if(hRes != S_OK)
				{
					TRACE(_T("pService->Next() failed %s\n"), ErrorString(hRes));
				}
			}
			else
			{
				TRACE(_T("BeginEnumeration() failed %s\n"), ErrorString(hRes));
			}

			// output the buffer.
			m_outputList.AddString(clMyBuff);

			//----------------------
			// free the iterator space.
			pService->EndEnumeration();

			// done with the ClassObject
			if (pService)
			{ 
				pService->Release(); 
				pService = NULL;
			}
		} //endwhile Next()

		TRACE(_T("walked query\n"));
		m_outputList.AddString(_T("Done Enumerating"));

		// did the while loop exit due to an error?
		if((hRes != S_OK) && 
		   (hRes != 1))
		{
			TRACE(_T("pEnumServices->Next() failed %s\n"), ErrorString(hRes));
		}

		if (pEnumServices)
		{ 
			pEnumServices->Release(); 
			pEnumServices = NULL;
		}
	}
	else
	{
		TRACE(_T("ExecQuery() failed %s\n"), ErrorString(hRes));

	} //endif ExecQuery()

	SysFreeString(qLang);
	SysFreeString(query);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\ontemp.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OnTemp.cpp
//
// Description:
//	This file implements the register/unregister of permenant
//		event consumers. The actual consumer is the CEventSink
//		object below.
// 
// History:
//
// **************************************************************************
#include "stdafx.h"
#include "AdvClientDlg.h"
#include "OnTemp.h"

BOOL CAdvClientDlg::OnTempRegister() 
{
	HRESULT  hRes;
	BOOL retval = FALSE;

	if(EnsureOfficeNamespace())
	{
		// allocate the sink if its not already allocated.
		if(m_pEventSink == NULL)
		{
			m_pEventSink = new CEventSink(&m_eventList);
			m_pEventSink->AddRef();
		}

		BSTR qLang = SysAllocString(L"WQL");
		BSTR query = SysAllocString(L"select * from __InstanceCreationEvent where TargetInstance isa \"SAMPLE_OfficeEquipment\"");

		m_eventList.ResetContent();

		// execute the query. For *Async, the last parm is a sink object
		// that will be sent the resultset instead of returning the normal
		// enumerator object.
		if((hRes = m_pOfficeService->ExecNotificationQueryAsync(
												qLang, query,
												0L, NULL,              
												m_pEventSink)) == S_OK)
		{
			TRACE(_T("Executed filter query\n"));
			retval = TRUE;
			m_eventList.AddString(_T("Ready for events"));
		}
		else
		{
			TRACE(_T("ExecQuery() failed %s\n"), ErrorString(hRes));
			m_eventList.AddString(_T("Failed To Register"));

		} //endif ExecQuery()

		SysFreeString(qLang);
		SysFreeString(query);
	}
	return retval;
}

void CAdvClientDlg::OnTempUnregister() 
{

	if(EnsureOfficeNamespace())
	{
		m_eventList.ResetContent();
		m_eventList.AddString(_T("unregistered"));
		m_pOfficeService->CancelAsyncCall(m_pEventSink);

		m_pEventSink->Release();
		m_pEventSink = NULL;
	}
}
// ========================================================
CEventSink::CEventSink(CListBox *output)
{
	m_pOutputList = output;
}
// ========================================================
CEventSink::~CEventSink()
{
}
// ========================================================
STDMETHODIMP CEventSink::QueryInterface(REFIID riid, LPVOID* ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = this;

		// you're handing out a copy of yourself so account for it.
        AddRef();
        return S_OK;
    }
    else 
	{
		return E_NOINTERFACE;
	}
}

// ========================================================
ULONG CEventSink::AddRef()
{
	// InterlockedIncrement() helps with thread safety.
    return InterlockedIncrement(&m_lRef);
}

// ========================================================
ULONG CEventSink::Release()
{
	// InterlockedDecrement() helps with thread safety.
    int lNewRef = InterlockedDecrement(&m_lRef);
	// when all the copies are released...
    if(lNewRef == 0)
    {
		// kill thyself.
        delete this;
    }

    return lNewRef;
}

// ========================================================
STDMETHODIMP CEventSink::Indicate(LONG lObjectCount,
								   IWbemClassObject **ppObjArray)
{
	HRESULT  hRes;
	CString clMyBuff;
	BSTR objName = NULL;
	BSTR propName = NULL;
	VARIANT pVal, vDisp;
	IDispatch *pDisp = NULL;
	IWbemClassObject *tgtInst = NULL;

	VariantInit(&pVal);
	VariantInit(&vDisp);

	TRACE(_T("Indicate() called\n"));

	objName = SysAllocString(L"TargetInstance");
	propName = SysAllocString(L"Item");

	// walk though the classObjects...
	for (int i = 0; i < lObjectCount; i++)
	{
		// clear my output buffer.
		clMyBuff.Empty();

		// get what was added. This will be an embedded object (VT_DISPATCH). All
		// WBEM interfaces are derived from IDispatch.
		if ((hRes = ppObjArray[i]->Get(objName, 0L, 
										&vDisp, NULL, NULL)) == S_OK) 
		{
			//--------------------------------
			// pull the IDispatch out of the various. Dont cast directly to to IWbemClassObject.
			// it MIGHT work now but a suptle change later will break your code. The PROPER 
			// way is to go through QueryInterface and do all the right Release()'s.
			pDisp = (IDispatch *)V_DISPATCH(&vDisp);

			//--------------------------------
			// ask for the IWbemClassObject which is the embedded object. This will be the
			// instance that was created.
			if(SUCCEEDED(pDisp->QueryInterface(IID_IWbemClassObject, (void **)&tgtInst)))
			{
				//--------------------------------
				// dont need the IDispatch anymore.
				pDisp->Release();

				//--------------------------------
				// get the 'Item' property out of the embedded object.
				if ((hRes = tgtInst->Get(propName, 0L, 
										&pVal, NULL, NULL)) == S_OK) 
				{
					//--------------------------------
					// done with it.
					tgtInst->Release();

					// compose a string for the listbox.
					clMyBuff = _T("SAMPLE_OfficeEquipment Instance added for: ");
					clMyBuff += V_BSTR(&pVal);
				
					// output the buffer.
					m_pOutputList->AddString(clMyBuff);
				}
				else
				{
					TRACE(_T("Get() Item failed %s\n"), ErrorString(hRes));
				}
			}
			else
			{
				TRACE(_T("QI() failed \n"));
			}
		}
		else
		{
			TRACE(_T("Get() targetInst failed %s\n"), ErrorString(hRes));
			m_pOutputList->AddString(_T("programming error"));
		} //endif Get()

	} // endfor

	SysFreeString(propName);
	SysFreeString(objName);
	VariantClear(&pVal);

	TRACE(_T("walked indication list\n"));

	return S_OK;
}
// ========================================================
STDMETHODIMP CEventSink::SetStatus(long lFlags,
										HRESULT hResult,
										BSTR strParam,
										IWbemClassObject *pObjParam)
{
	//--------------------------------
	// SetStatus() may be called to indicate that your query becomes
	// invalid or valid again  ussually caused by multithreading 'situations'.
	TRACE(_T("SetStatus() called %s\n"), ErrorString(hResult));

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\sampcli\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\ontemp.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  EventSink.h
//
// Description:
//	This file declares the CEventSink class. It is the sink
//		object for event indications.
// 
// Part of: WMI Tutorial #1.
//
// Used by: OnAsync().
//
// History:
//
// **************************************************************************
#include <wbemcli.h>

class CEventSink : public IWbemObjectSink
{
public:
    CEventSink(CListBox *output);
    ~CEventSink();

    STDMETHOD_(SCODE, Indicate)(long lObjectCount,
								IWbemClassObject **pObjArray);

    STDMETHOD_(SCODE, SetStatus)(long lFlags,
									HRESULT hResult,
									BSTR strParam,
									IWbemClassObject *pObjParam);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
		{return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
		{return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
		{return E_NOTIMPL;}

private:
    long m_lRef;
	CListBox *m_pOutputList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AdvClient.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WBEMSAMP_DIALOG             102
#define IDD_WBEMSAMPLE_DIALOG           102
#define IDD_SAMPLE_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_OFFICEEQUIP                 129
#define IDD_USERINFO                    130
#define IDC_ENUMDISKS                   1000
#define IDC_ADDEQUIPMENT                1001
#define IDC_ENUMSERVICES                1002
#define IDC_ADDUSER                     1003
#define IDC_CONNECT                     1004
#define IDC_NAMESPACE                   1005
#define IDC_OUTPUTLIST                  1006
#define IDC_ENUMSERVICESASYNC           1007
#define IDC_DISKDETAILS                 1008
#define IDC_ITEM                        1009
#define IDC_REGTEMP                     1009
#define IDC_ACCTNAME                    1010
#define IDC_REGPERM                     1010
#define IDC_DOMAIN                      1011
#define IDC_EVENTLIST                   1011
#define IDC_SKU                         1012
#define IDC_DISK_PROPS_DESCRIPTIONS     1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	AdvClientle.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\sampcli\refclint.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////
//
//	RefClint.h : Refresher client header file
//
//	Created by a-dcrews and sanjes
//
///////////////////////////////////////////////////////////////////

#ifndef _REFCLINT_H_
#define _REFCLINT_H_

#include <wbemcli.h>

///////////////////////////////////////////////////////////////////
//
//	Globals and constants
//
///////////////////////////////////////////////////////////////////

const WCHAR	cwcsObjectPath[]	= L"Win32_BasicHiPerf";	// The name of the sample object
const long	clNumInstances		= 5;					// The number of Win32_BasicHiPerf instances
const DWORD	cdwNumReps			= 100;					// The number of sample refreshes 

///////////////////////////////////////////////////////////////////
//
//	CRefresherMember
//
//	This class facilitates the management of objects or enumerators 
//	that have been added to the refresher and the unique ID assigned
//	to them.
//
///////////////////////////////////////////////////////////////////

template<class T>
class CRefresherMember
{
	T*		m_pMember;
	long	m_lID;

public:
	CRefresherMember() : m_pMember( NULL ), m_lID( 0 ) {}
	virtual ~CRefresherMember() { if ( NULL != m_pMember) m_pMember->Release(); }

	void Set(T* pMember, long lID);
	void Reset();

	T* GetMember();
	long GetID(){ return m_lID; }
};

template <class T> inline void CRefresherMember<T>::Set(T* pMember, long lID) 
{ 
	if ( NULL != pMember )
		pMember->AddRef();
	m_pMember = pMember;  
	m_lID = lID;
}

template <class T> inline void CRefresherMember<T>::Reset()
{
	if (NULL != m_pMember)
		m_pMember->Release();

	m_pMember = NULL;
	m_lID = 0;
}

template <class T> inline T* CRefresherMember<T>::GetMember()
{
	if ( NULL != m_pMember )
		m_pMember->AddRef();

	return m_pMember;
}


///////////////////////////////////////////////////////////////////
//
//	CRefClient
//
//	This class encapsulates the basic functionality of a WMI client
//	using the high performance refresher interface.
//
///////////////////////////////////////////////////////////////////

class CRefClient
{
	IWbemServices*				m_pNameSpace;		// A pointer to the namespace
	IWbemRefresher*				m_pRefresher;		// A pointer to the refresher
	IWbemConfigureRefresher*	m_pConfig;			// A pointer to the refresher's manager

	CRefresherMember<IWbemHiPerfEnum>	m_Enum;							// The enumerator added to the refresher
	CRefresherMember<IWbemObjectAccess>	m_Instances[clNumInstances];	// The instances added to the refreshrer

protected:
	HRESULT SetHandles();

public:
	CRefClient();
	virtual ~CRefClient();
	
	HRESULT Initialize(IWbemServices* pNameSpace);

	HRESULT AddObjects();
	HRESULT RemoveObjects();
	HRESULT ShowObjectData();

	HRESULT AddEnum();
	HRESULT RemoveEnum();
	HRESULT ShowEnumeratorData();

	HRESULT Refresh();
};

#endif	//_REFCLINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7DD9207B_0510_11D1_AD84_00AA00B8E05A__INCLUDED_)
#define AFX_STDAFX_H__7DD9207B_0510_11D1_AD84_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
//#undef _AFX_NO_BSTR_SUPPORT
#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7DD9207B_0510_11D1_AD84_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\src\basichiperf.cpp ===
////////////////////////////////////////////////////////////////////////

//

//	BasicHiPerf.cpp

//

//	Module:	WMI high performance provider sample code

//

//	This is the skeleton code implementation of a high performance 

//	provider.  This file includes the provider and refresher code.

//

//  History:

//	a-dcrews      12-Jan-99		Created

//

//	

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <process.h>

#include "BasicHiPerf.h"

#define _UNICODE
#define UNICODE

//////////////////////////////////////////////////////////////
//
//
//	Global, external and static variables
//
//
//////////////////////////////////////////////////////////////

// This structure quickly defines the properties and types of
// the counters.  It is used for simplicity; actual providers 
// should enumerate the property names and types
// ==========================================================

struct tagProperties
{
	_TCHAR	m_tcsPropertyName[128];
	DWORD	m_dwType;
} g_aCounterProps[] =
{
	_T("Counter1"),	PROP_DWORD,
	_T("Counter2"),	PROP_DWORD,
	_T("Counter3"),	PROP_DWORD,
	_T("Counter4"),	PROP_DWORD,
	_T("Counter5"),	PROP_DWORD
};

// The access handle for the object's ID
// =====================================

long g_hID;

// The COM object counter (declared in server.cpp)
// ===============================================

extern long g_lObjects;	

// The mock data source (declared as static in CHiPerfProvider)
// ============================================================

CSampleDataSource* CHiPerfProvider::m_pSampleDS = NULL;

// The unique ID generator in CCacheMap - values from 0 to 
// (MAX_ENUMERATORS - 1) are reserved for the enumerators
// =======================================================

long CCacheMapEl::m_lGenID = MAX_ENUMERATORS;


//////////////////////////////////////////////////////////////
//
//
//	Helper Functions
//
//
//////////////////////////////////////////////////////////////

HRESULT CloneAccess(IWbemObjectAccess* pOriginal, IWbemObjectAccess** ppClone)
//////////////////////////////////////////////////////////////
//
//	Returns a IWbemObjectAccess clone of an IWbemObjectAccess
//	object.
//
//	Parameters:
//		pOriginal	- the original object
//		ppClone		- the cloned object
//
//////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

	IWbemClassObject*	pOurClassObj = NULL;		
	IWbemClassObject*	pClonedClassObj = NULL;
	IWbemObjectAccess*	pClonedAccessObj = NULL;

	// Get the IWbemClassObject interface for the object
	// =================================================

	hRes = pOriginal->QueryInterface(IID_IWbemClassObject, (PVOID*)&pOurClassObj);
	if (FAILED(hRes))
		return hRes;

	// Clone the object
	// ================

	hRes = pOurClassObj->Clone(&pClonedClassObj);
	pOurClassObj->Release();
	if (FAILED(hRes))
		return hRes;

	// Get the IWbemObjectAccess interface for the cloned object
	// =========================================================

	hRes = pClonedClassObj->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&pClonedAccessObj);
	pClonedClassObj->Release();
	if (FAILED(hRes))
		return hRes;

	// Copy the cloned object into the returned parameter (refcount == 1)
	// ==================================================================

	*ppClone = pClonedAccessObj;

	return WBEM_NO_ERROR;
}


//////////////////////////////////////////////////////////////
//
//
//	CHiPerfProvider
//
//
//////////////////////////////////////////////////////////////

CHiPerfProvider::CHiPerfProvider() : m_lRef(0), m_pTemplate(NULL)
//////////////////////////////////////////////////////////////
//
//	Constructor
//
//////////////////////////////////////////////////////////////
//ok
{
	// Increment the global COM object counter
	// =======================================

	InterlockedIncrement(&g_lObjects);
}

CHiPerfProvider::~CHiPerfProvider()
//////////////////////////////////////////////////////////////
//
//	Destructor
//
//////////////////////////////////////////////////////////////
//ok
{
	long lObjCount = 0;

    // Release the template
	// ====================

	if (NULL != m_pTemplate)
            m_pTemplate->Release();

	// Decrement the global COM object counter
	// =======================================

	lObjCount = InterlockedDecrement(&g_lObjects);

	// If this is the last object, delete our data source
	// ==================================================

	if ((0 == lObjCount) && (NULL != m_pSampleDS))
	{
		delete m_pSampleDS;
		m_pSampleDS = NULL;
	}
}

//////////////////////////////////////////////////////////////
//
//					COM methods
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfProvider::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
//ok
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWbemProviderInit*)this;
    else if(riid == IID_IWbemProviderInit)
        *ppv = (LPVOID)(IWbemProviderInit*)this;
	else if (riid == IID_IWbemHiPerfProvider)
		*ppv = (LPVOID)(IWbemHiPerfProvider*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CHiPerfProvider::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
//ok
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CHiPerfProvider::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
//ok
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CHiPerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          long lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink)
//////////////////////////////////////////////////////////////////////
//
//  Called once during startup for any one-time initialization.  The 
//	final call to Release() is for any cleanup.
//	
//	The parameters indicate to the provider which namespace it is being 
//	invoked for and which User.  It also supplies a back pointer to 
//	WINMGMT so that class definitions can be retrieved.
//
//	Initialize will create a single template object that can be used 
//	by the provider to spawn instances for QueryInstances.  It will 
//	also initialize our mock data source and set the global ID access 
//	handle.
//	
//	Parameters:
//		wszUser			- The current user.
//		lFlags			- Reserved.
//		wszNamespace	- The namespace for which we are being activated.
//		wszLocale		- The locale under which we are to be running.
//		pNamespace		- An active pointer back into the current namespace
//							from which we can retrieve schema objects.
//		pCtx			- The user's context object.  We simply reuse this
//							during any reentrant operations into WINMGMT.
//		pInitSink		- The sink to which we indicate our readiness.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

    IWbemObjectAccess *pAccess = NULL;		
	BSTR strObject = NULL;
	BSTR strPropName = NULL;

	if (wszNamespace == 0 || pNamespace == 0 || pInitSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Get a sample class object for initialization purposes
	// =====================================================

	strObject = SysAllocString(SAMPLE_CLASS);

	hRes = pNamespace->GetObject(strObject, 0, pCtx, &m_pTemplate, 0);

	SysFreeString(strObject);

    if (FAILED(hRes))
        return hRes;


	// Initialize the datasource.  If the static member 
	// is not null, then it has already been setup.
	// ================================================

	if (NULL == m_pSampleDS)
	{
		m_pSampleDS = new CSampleDataSource;

		if (NULL == m_pSampleDS)
			return WBEM_E_OUT_OF_MEMORY;

		m_pSampleDS->Initialize(m_pTemplate);
	}

	// Initialize the global access handle for the object ID.  
	// If it is not null, then it has already been setup.
	// ======================================================

	if (NULL == g_hID)
	{
		// Get the IWbemObjectAccess interface to the object
		// =================================================

		hRes = m_pTemplate->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&pAccess);

		if (FAILED(hRes))
			return hRes;
		
		// Get the name property access handle
		// ===================================

		strPropName = SysAllocString(L"Name");

		hRes = pAccess->GetPropertyHandle(strPropName, 0, &g_hID);

		pAccess->Release();
		SysFreeString(strPropName);

		if (FAILED(hRes))
			return hRes;
	}

    // We now have all the instances ready to go and the name handle 
	// stored.  Tell WINMGMT that we're ready to start 'providing'
	// =============================================================
	
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

    return WBEM_NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  This
//							should not be AddRef'ed.
//		wszClass		- The class name for which instances are required.
//		lFlags			- Reserved.
//		pCtx			- The user-supplied context (not used here).
//		pSink			- The sink to which to deliver the objects.  The objects
//							can be delivered synchronously through the duration
//							of this call or asynchronously (assuming we
//							had a separate thread).  A IWbemObjectSink::SetStatus
//							call is required at the end of the sequence.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

	IWbemClassObject*	pObjectCopy = NULL;
	IWbemObjectAccess*	pAccessCopy = NULL;

    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

	// Loop through all instances, indicating an updated version
	// to the object sink
	// =========================================================

    for (int i = 0; i < NUM_INSTANCES; i++)
    {
		// Create a new instance from the template
		// =======================================

		hRes = m_pTemplate->SpawnInstance(0, &pObjectCopy);
		if (FAILED(hRes))
			break;

		// Obtain the IWbemObjectAccess interface
		// ======================================

		hRes = pObjectCopy->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&pAccessCopy);
		if (FAILED(hRes))
		{
			pObjectCopy->Release();
			break;
		}

		// Set the ID
		// ==========

		WCHAR wszName[20];
		swprintf(wszName, L"%i", i);
		pAccessCopy->WritePropertyValue(g_hID, (long)(wcslen(wszName)+1)*sizeof(WCHAR), (byte *)wszName);

		// Initialize the counters
		// =======================

		hRes = m_pSampleDS->UpdateInstance(pAccessCopy);

		// Release the IWbemObjectAccess handle (values are maintained in IWbemClassObject interface)
		// ==========================================================================================

		pAccessCopy->Release();

		if (FAILED(hRes))
		{
			pObjectCopy->Release();
			break;
		}

        // Send a copy back to the caller
		// ==============================

        pSink->Indicate(1, &pObjectCopy);

        pObjectCopy->Release();    // Don't need this any more
    }
    
    // Tell WINMGMT we are all finished supplying objects
	// ==================================================

    pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);

    return WBEM_NO_ERROR;
}    

STDMETHODIMP CHiPerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  Not used.
//		lFlags			- Reserved.
//		ppRefresher		- Receives the requested refresher.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Construct and initialize a new empty refresher
	// ==============================================

	CRefresher* pNewRefresher = new CRefresher(this, m_pSampleDS);
	pNewRefresher->Initialize(m_pTemplate);

    // Follow COM rules and AddRef() the thing before sending it back
	// ==============================================================

    pNewRefresher->AddRef();
    *ppRefresher = pNewRefresher;
    
    return WBEM_NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//
//	Note that the object returned in ppRefreshable is a clone of the 
//	actual instance maintained by the provider.  If refreshers shared
//	a copy of the same instance, then a refresh call on one of the 
//	refreshers would impact the state of both refreshers.  This would 
//	break the refresher rules.	Instances in a refresher are only 
//	allowed to be updated when 'Refresh' is called.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace in WINMGMT.
//		pTemplate		- A pointer to a copy of the object which is to be
//							added.  This object itself cannot be used, as
//							it not owned locally.        
//		pRefresher		- The refresher to which to add the object.
//		lFlags			- Not used.
//		pContext		- Not used here.
//		ppRefreshable	- A pointer to the internal object which was added
//							to the refresher.
//		plId			- The Object Id (for identification during removal).        
//
//////////////////////////////////////////////////////////////////////
//ok
{
    // Find out which instance is being requested for addition
	// =======================================================

	HRESULT hRes = WBEM_NO_ERROR;

    if (pNamespace == 0 || pTemplate == 0 || pRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// =========================================================

	CRefresher *pOurRefresher = (CRefresher *) pRefresher;

	// Add the object to the refresher. The ID is set by AddObject
	// ===========================================================

    hRes = pOurRefresher->AddObject(pTemplate, ppRefreshable, plId);

	if (FAILED(hRes))
		return hRes;

    return WBEM_NO_ERROR;
}
   
STDMETHODIMP CHiPerfProvider::CreateRefreshableEnum( 
	/* [in] */ IWbemServices* pNamespace,
	/* [in, string] */ LPCWSTR wszClass,
	/* [in] */ IWbemRefresher* pRefresher,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pContext,
	/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
	/* [out] */ long* plId )
//////////////////////////////////////////////////////////////////////
//
//  Called when an enumerator is being added to a refresher.  The 
//	enumerator will obtain a fresh set of instances of the specified 
//	class every time that refresh is called.
//     
//	Since this example provider only provides one class, then any 
//	enumerator in this refresher will only return instances from this 
//	class.  In the case where there is more than one class, then 
//	wszClass must be examined to determine which class the enumerator 
//	is being assigned.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		wszClass		- The class name for the requested enumerator.
//		pRefresher		- The refresher object for which we will add 
//							the enumerator
//		lFlags			- Reserved.
//		pContext		- Not used here.
//		pHiPerfEnum		- The enumerator to add to the refresher.
//		plId			- A provider specified ID for the enumerator.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.

	CRefresher *pOurRefresher = (CRefresher *) pRefresher;

	// Add the enumerator to the refresher  
	// The ID is generated by AddEnum.
	// ===================================

	return pOurRefresher->AddEnum(pHiPerfEnum, plId);
}

STDMETHODIMP CHiPerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//		pRefresher			- The refresher object from which we are to 
//								remove the perf object.
//		lId					- The ID of the object.
//		lFlags				- Not used.
//  
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// =========================================================

    CRefresher *pOurRefresher = (CRefresher *) pRefresher;

	// An ID that is less than MAX_ENUMERATORS is an enumerator ID.
	// Everything else is an object ID
	// ============================================================

	if (lId < MAX_ENUMERATORS)
		hRes = pOurRefresher->RemoveEnum(lId);
	else
		hRes = pOurRefresher->RemoveObject(lId);

	return hRes;
}

STDMETHODIMP CHiPerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
	/* [in] */ long lNumObjects,
	/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
//////////////////////////////////////////////////////////////////////
//
//  Called when a request is made to provide all instances currently 
//	being managed by the provider in the specified namespace.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		lNumObjects		- The number of instances being returned.
//		apObj			- The array of instances being returned.
//		lFlags			- Reserved.
//		pContext		- Not used here.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

	int	nIndex = 0;
	DWORD dwID = 0;

	IWbemObjectAccess*	pCurrObj;

	// Cycle through the list of objects, updating each one
	// ====================================================

	for (nIndex = 0; nIndex < lNumObjects; nIndex++)
	{
		pCurrObj = apObj[nIndex];

		hRes = m_pSampleDS->UpdateInstance(pCurrObj);
		if (FAILED(hRes))
			break;
	}

	return hRes;
}


//////////////////////////////////////////////////////////////
//
//
//	CRefresher
//
//
//////////////////////////////////////////////////////////////

CRefresher::CRefresher(CHiPerfProvider* pProvider, CSampleDataSource* pDS) : m_lRef(0), m_pDS(pDS)
//////////////////////////////////////////////////////////////////////
//
//	Constructor
//
//////////////////////////////////////////////////////////////////////
//ok
{
	int nIndex = 0;

	// Retain a copy of the provider
	// =============================

	m_pProvider = pProvider;
	if (m_pProvider)
		m_pProvider->AddRef();

	// Initialize the instance map
	// ===========================

	for (nIndex = 0; nIndex < MAX_INSTANCES; nIndex++)
		m_apInstMap[nIndex] = NULL;

	// Initialize the instance cache
	// =============================

	for (nIndex = 0; nIndex < NUM_INSTANCES; nIndex++)
		m_apInstances[nIndex] = NULL;

	// Initialize the enumerator cache
	// ===============================

	for (nIndex = 0; nIndex < MAX_ENUMERATORS; nIndex++)
		m_apEnumerator[nIndex] = NULL;

	// Increment the global COM object counter
	// =======================================

	InterlockedIncrement(&g_lObjects);
}

CRefresher::~CRefresher()
//////////////////////////////////////////////////////////////////////
//
//	Destructor
//
//////////////////////////////////////////////////////////////////////
//ok
{
	int nIndex = 0;

	// Delete the instance cache
	// =========================

	for (nIndex = 0; nIndex < MAX_INSTANCES; nIndex++)
	{
		if (NULL != m_apInstMap[nIndex])
			delete m_apInstMap[nIndex];
	}

    // Release the cached IWbemObjectAccess instances
	// ==============================================

    for (nIndex = 0; nIndex < NUM_INSTANCES; nIndex++)
    {
        if (NULL != m_apInstances[nIndex])
            m_apInstances[nIndex]->Release();
    }            

	// Release all of the enumerators
	// ==============================

	for (nIndex = 0; nIndex < MAX_ENUMERATORS; nIndex++)
	{
		if (NULL != m_apEnumerator[nIndex])
			m_apEnumerator[nIndex]->Release();
	}

	// Release the provider
	// ====================

	if (m_pProvider)
		m_pProvider->Release();

	// Decrement the global COM object counter
	// =======================================

	InterlockedDecrement(&g_lObjects);
}

DWORD CRefresher::Initialize(IWbemClassObject* pSampleClass)
//////////////////////////////////////////////////////////////////////
//
//  Initializes the instances cache.
//     
//  Parameters:
//		pSampleClass	- A template of the WMI object from which we 
//							will create our instances
//
//////////////////////////////////////////////////////////////////////
//ok
{
	DWORD dwRes = WBEM_NO_ERROR;

	int nIndex = 0;

    // Precreate and initialize 5 instances of our sample class, and store 
	// them in the m_apInstances array as IWbemObjectAccess pointers
	// =====================================================================

    for (DWORD dwIndex = 0; dwIndex < NUM_INSTANCES; dwIndex++)
    {
		IWbemClassObject*	pClone = NULL;
		IWbemObjectAccess*	pAccess = NULL;

		// Create the instance
		// ===================

		dwRes = pSampleClass->SpawnInstance(0, &pClone);
		if (FAILED(dwRes))
			return dwRes;

		// Get the IWbemObjectAccess interface
		// ===================================

        dwRes = pClone->QueryInterface(IID_IWbemObjectAccess, (LPVOID *)&pAccess);
        pClone->Release();

		if (FAILED(dwRes))
			return dwRes;

		// Set the ID
		// ==========

		WCHAR wszName[20];
		swprintf(wszName, L"%i", dwIndex);
		dwRes = pAccess->WritePropertyValue(g_hID, (long)(wcslen(wszName)+1)*sizeof(WCHAR), (byte *)wszName);
		if (FAILED(dwRes))
		{
			pAccess->Release();
			return dwRes;
		}

		// Initialize the counters
		// =======================

		dwRes = m_pDS->UpdateInstance(pAccess);
		if (FAILED(dwRes))
		{
			pAccess->Release();
			return dwRes;
		}

		// Add to the instance array (refcount == 1)
		// =========================================

        m_apInstances[dwIndex] = pAccess;
    }

	return WBEM_NO_ERROR;
}

DWORD CRefresher::AddObject(IWbemObjectAccess *pObj, IWbemObjectAccess **ppReturnObj, long *plId)
//////////////////////////////////////////////////////////////////////
//
//  Adds an object to the refresher.   This is a private mechanism
//  used by CHiPerfProvider and not part of the COM interface.
//
//	All of the objects are maintained by the m_apInstances array.  This
//	is set up during a call to Initialize.  Multiple additions of the same
//	object to a refresher is legal, so to optimize the refresh, the 
//	same object is passed back but with a different ID.  The ID:object
//	relationships are maintained by m_apInstMap.
//
//	Parameters:
//		pObj		- the object to add
//		lID			- the ID
//
//////////////////////////////////////////////////////////////////////
//ok
{
	DWORD	dwRes	= WBEM_NO_ERROR;
	
	DWORD	dwID	= 0;
	int		nIndex	= 0;
	bool	bDone	= false;

	if (NULL == pObj)
        return WBEM_E_INVALID_PARAMETER;

	// Grab the instance ID
	// ====================
	
	WCHAR wszName[20];
	long lNumBytes = 0;
	dwRes = pObj->ReadPropertyValue(g_hID, sizeof(wszName), &lNumBytes, (byte *)wszName);
	if (FAILED(dwRes))
		return dwRes;
	dwID = _wtoi(wszName);

	// Search the map array for an empty spot
	// ======================================

	for (nIndex = 0; (nIndex < MAX_INSTANCES) && !bDone; nIndex++)
	{
		if (NULL == m_apInstMap[nIndex])
		{
			// Create a new cache element
			// ==========================

			CCacheMapEl* pEl = new CCacheMapEl(dwID);

			// Set the return parameters
			// =========================

			*plId = pEl->GetUID();
			*ppReturnObj = m_apInstances[dwID];
			(*ppReturnObj)->AddRef();

			// Set the cache element
			// =====================

			m_apInstMap[nIndex] = pEl;

			bDone = true;
		}
	}

	// If array was full, report an error
	// ==================================

	if (!bDone)
		dwRes = WBEM_E_OUT_OF_MEMORY;

	return dwRes;
}

DWORD CRefresher::RemoveObject(long lId)
//////////////////////////////////////////////////////////////////////
//
//  Removes an object from the refresher.  This is a private mechanism 
//	used by CHiPerfProvider and not part of the COM interface.
//
//  Removes an object from the refresher by ID.   Use a simple linear
//	search to locate the unique ID in the m_apInstMap.  Leave the 
//	cache instance intact until the refrehser is destroyed.
//
//	Parameters:
//		plID		- the unique ID
//
//////////////////////////////////////////////////////////////////////
//ok
{
	DWORD	dwRes = WBEM_E_NOT_FOUND;

	int		nIndex = 0;
	bool	bDone = false;

	// Loop through the map array looking of the ID
	// ============================================

	for (nIndex = 0; (nIndex < MAX_INSTANCES) && !bDone; nIndex++)
	{
		CCacheMapEl* pEl = m_apInstMap[nIndex];

		if (NULL != pEl)
		{
			if (pEl->GetUID() == lId)
			{
				// Found!  So remove map element
				// =============================

				delete pEl;
				m_apInstMap[nIndex] = NULL;

				dwRes = WBEM_NO_ERROR;

				break;
			}
		}
	}

	return dwRes;
}

DWORD CRefresher::AddEnum(IWbemHiPerfEnum *pHiPerfEnum, long *plId)
//////////////////////////////////////////////////////////////////////
//
//  Adds an enumerator to the refresher.   This is a private mechanism
//  used by CHiPerfProvider and not part of the COM interface.
//
//  The ID we return for future identification is simply
//  the array index.
//
//	Note that the the refresher uses an array of enumerators.  For a 
//	hiperf provider that only supports one class, having more than one 
//	enumerator does not really make sense since a single enumerator will
//	manage all instances of a single class for a given refresher.  
//	NUM_ENUMERATORS may be set to reflect the number of classes if the 
//	proper class / enumerator management code is added.  The implementation
//	is up to the provider.
//
//	Parameters:
//		pHiPerfEnum	- the enumerator
//		plID		- the ID
//
//////////////////////////////////////////////////////////////////////
//ok
{
	DWORD dwRes = WBEM_E_FAILED;

	if (NULL == pHiPerfEnum)
        return WBEM_E_INVALID_PARAMETER;

	// Cycle through the enumerator array, and look for an empty slot
	// ==============================================================

	for (int nIndex = 0; nIndex < MAX_ENUMERATORS; nIndex++)
	{
		if (NULL == m_apEnumerator[nIndex])
		{
			// Add all the objects at once into the enumerator
			// ===============================================

			long alIDs[NUM_INSTANCES];

			for ( int nInst = 0; nInst < NUM_INSTANCES; nInst++ )
				alIDs[nInst] = nInst;

			dwRes = pHiPerfEnum->AddObjects( 0L, NUM_INSTANCES, alIDs, m_apInstances );
			if (FAILED(dwRes))
				return dwRes;

			// Add the enumerator to the refresher (released by the refresher's destructor)
			// ============================================================================

			m_apEnumerator[nIndex] = pHiPerfEnum;
			pHiPerfEnum->AddRef();

			*plId = nIndex;

			dwRes = WBEM_NO_ERROR;
			break;
		}
	}
	return dwRes;
}

DWORD CRefresher::RemoveEnum(long lId)
//////////////////////////////////////////////////////////////////////
//
//  Removes an enumerator from the refresher.  This is a private mechanism 
//	used by CHiPerfProvider and not part of the COM interface.
//
//  Removes an enumerator from the refresher by ID.   In our case, the ID
//  is actually the array index we used internally, so it is simple
//  to locate and remove the object.
//
//	Parameters:
//		plID		- the ID
//
//////////////////////////////////////////////////////////////////////
//ok
{
	// Verify the element
	// ==================

	if (NULL != m_apEnumerator[lId])
	{
		// And remove the enumerator
		// =========================

		m_apEnumerator[lId]->Release();
		m_apEnumerator[lId] = NULL;

		return WBEM_NO_ERROR;
	}
	return WBEM_E_FAILED;
}

STDMETHODIMP CRefresher::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////////////
//
//	Standard COM QueryInterface
//
//////////////////////////////////////////////////////////////////////
//ok
{
    if (riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
	else if (riid == IID_IWbemRefresher)
		*ppv = (LPVOID)(IWbemRefresher*)this;
    else return E_NOINTERFACE;

   	((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CRefresher::AddRef()
//////////////////////////////////////////////////////////////////////
//	
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////////////
//ok
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CRefresher::Release()
//////////////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////////////
//ok
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CRefresher::Refresh(/* [in] */ long lFlags)
//////////////////////////////////////////////////////////////////////
//
//  Executed to refresh a set of instances bound to the particular 
//  refresher.
//
//	In most situations the instance data, such as counter values and 
//	the set of current instances within any existing enumerators, would 
//	be updated whenever Refresh was called.  For this example, we are 
//	going to or data source to update the counter data.  Since we are 
//	using a fixed set of instances, we are not adding or removing anything
//	from the enumerator.
//
//	Parameters:
//		lFlags	- not used
//
//////////////////////////////////////////////////////////////////////
//ok
{

	HRESULT	hRes = WBEM_NO_ERROR;

	IWbemObjectAccess* pObj;
	DWORD	dwVal = 0;
	long	hCtr = 0;

	// A simple loop that iterates through all instances that have been
	// added to the refresher, and updates their counter values
	// ================================================================

	for (int nInst = 0; nInst < NUM_INSTANCES; nInst++)
	{
		pObj = m_apInstances[nInst];
		if (NULL != pObj)
		{
			hRes = m_pDS->UpdateInstance(pObj);
			if (FAILED(hRes))
				break;
		}
	}

	return hRes;
}

//////////////////////////////////////////////////////////////
//
//
//	CSampleDataSource
//
//
//////////////////////////////////////////////////////////////


CSampleDataSource::CSampleDataSource() : m_hThread(NULL)
//////////////////////////////////////////////////////////////////////
//
//	Constructor
//
//////////////////////////////////////////////////////////////////////
//ok
{
	m_hQuit = CreateEvent( NULL, TRUE, FALSE, NULL );
}

CSampleDataSource::~CSampleDataSource()
//////////////////////////////////////////////////////////////////////
//
//	Destructor
//
//////////////////////////////////////////////////////////////////////
//ok
{
	if (NULL != m_hThread)
	{
		// Signal the thread to terminate
		// ==============================

		SetEvent( m_hQuit );

		DWORD dwRet = WaitForSingleObject( m_hThread, 60000 );

		switch ( dwRet )
		{
		case WAIT_OBJECT_0:
			{
			}break;
		case WAIT_TIMEOUT:
			{
				// Something is wrong - handle appropriately
			}break;
		}

		m_hThread = NULL;
	}
}

DWORD CSampleDataSource::Initialize(IWbemClassObject* pSampleClass)
//////////////////////////////////////////////////////////////
//
//	Initializes the data source.
//
//	Set the access handles for the properties of the WMI objects
//	and create a thread that will independantly update the 
//	counter values. 
//
//	Parameters:
//		pSampleClass	- a template of the class for which
//							handles are required
//
//////////////////////////////////////////////////////////////
//ok
{
	DWORD dwRes = WBEM_E_FAILED;
	unsigned uThread = 0;

	// Set the handles for the object (valid for all instances)
	// ========================================================

	dwRes = SetHandles(pSampleClass);
	if (FAILED(dwRes))
		return dwRes;

	// Create the simulation thread
	// ============================

	m_hThread = (PVOID)_beginthreadex(NULL, 0, CSampleDataSource::ThreadEntry, this, 0, &uThread); 

	if (0 == m_hThread)
		return WBEM_E_FAILED;

	return WBEM_NO_ERROR;
}

DWORD CSampleDataSource::SetHandles(IWbemClassObject* pSampleClass)
//////////////////////////////////////////////////////////////
//
//	Called by the initialization method.
//
//	Get the access handles for the well-known properties in
//	the WMI object.  These handles are the same for all instances 
//	of the object.
//
//	If the method fails, the property handle values may be in 
//	an indeterminite state.
//
//	Parameters:
//		pSampleClass	- a template of the class for which
//							handles are required
//
//////////////////////////////////////////////////////////////
//ok
{
	DWORD dwRes = WBEM_NO_ERROR;

	IWbemObjectAccess *pAccess = NULL;
    BSTR strPropName	= NULL;

    if (NULL == pSampleClass)
        return WBEM_E_FAILED;

	// Get the IWbemAccess interface to the class
	// ==========================================

	dwRes = pSampleClass->QueryInterface(IID_IWbemObjectAccess, (LPVOID *)&pAccess);

	if (FAILED(dwRes))
		return dwRes;

	// Get the counter properties access handles
	// =========================================

	for (int i = ctr1; i < NumCtrs; i++)
	{
		strPropName = SysAllocString(g_aCounterProps[i].m_tcsPropertyName);    

		dwRes = pAccess->GetPropertyHandle(strPropName, 0, &m_alHandle[i]);

		SysFreeString(strPropName);

		if (FAILED(dwRes))
		{
			pAccess->Release();
			return dwRes;
		}
	}

	pAccess->Release();

	return WBEM_NO_ERROR;
}


DWORD CSampleDataSource::UpdateInstance(IWbemObjectAccess* pAccess)
//////////////////////////////////////////////////////////////
//
//	Updates a given instance with the stored counter values.
//
//	Fetched the ID of the object, retrieves the corresponding
//	CSampleInstance object, and copies the counter values
//	into the object counter properties.
//
//	Parameters:
//		pAccess		- the object to be updated
//
//////////////////////////////////////////////////////////////
//ok
{
	DWORD dwRes = WBEM_E_FAILED;

	DWORD dwID = 0;

	// Get the ID of the object
	// ========================

	WCHAR wszName[20];
	long lNumBytes = 0;
	dwRes = pAccess->ReadPropertyValue(g_hID, sizeof(wszName), &lNumBytes, (byte *)wszName);
	if (FAILED(dwRes))
		return dwRes;
	dwID = _wtoi(wszName);

	// Get the counter data
	// ====================

	CSampleInstance* pInst = &(m_aInstance[dwID]);

	// And set the counter properties
	// ==============================

	pInst->Lock(true);

	for (int nProp = ctr1; nProp < NumCtrs; nProp++)
	{
		DWORD dwVal = 0;
		dwRes = pInst->GetCounter(nProp, &dwVal);
		if (FAILED(dwRes))
			break;
		dwRes = pAccess->WriteDWORD(m_alHandle[nProp], dwVal);
		if (FAILED(dwRes))
			break;
	}

	pInst->Lock(false);

	return dwRes;
}

DWORD CSampleDataSource::Simulate()
//////////////////////////////////////////////////////////////
//
//	This will simulate real changes to the data set.  The 
//	thread will periodically cycle through the instances 
//	modifying their counter values.  The thread will be killed 
//	by the calling thread.
//
//////////////////////////////////////////////////////////////
//ok
{
	CSampleInstance* pCurrInst = NULL;
	DWORD dwVal = 0;

	// Loop until the thread is killed
	// ===============================

	while ( WaitForSingleObject( m_hQuit, 0 ) == WAIT_TIMEOUT )
	{
		// Loop through the instances
		// ==========================

		for (int nInst = 0; nInst < NUM_INSTANCES; nInst++)
		{
			// Get the current instance and lock it
			// ====================================

			pCurrInst = &(m_aInstance[nInst]);

			pCurrInst->Lock(true);

			// Update all of the counters
			// ==========================

			for (int nCtr = ctr1; nCtr < NumCtrs; nCtr++)
			{
				dwVal = GetTickCount() / (nCtr + 1);
				pCurrInst->SetCounter(nCtr, dwVal);
			}

			pCurrInst->Lock(false);
		}
		
		// Wait a while
		// ============

		Sleep(100);
	}

	return WBEM_NO_ERROR;
}

unsigned CSampleDataSource::ThreadEntry(void* pArgs)
//////////////////////////////////////////////////////////////
//
//	The entry point for the simulation.  Calls Simulate.
//
//	Parameters:
//		pArgs	- contains the this pointer of the calling 
//					object
//
//////////////////////////////////////////////////////////////
//ok
{
	CSampleDataSource* pThis = (CSampleDataSource*)pArgs;

	pThis->Simulate();

	return 0;
}

//////////////////////////////////////////////////////////////
//
//
//	CSampleInstance
//
//
//////////////////////////////////////////////////////////////

CSampleInstance::CSampleInstance()
//////////////////////////////////////////////////////////////
//
//	Constructor
//
//////////////////////////////////////////////////////////////
//ok
{
	InitializeCriticalSection(&CS);
}

CSampleInstance::CSampleInstance(const CSampleInstance &aInst)
//////////////////////////////////////////////////////////////
//
//	Copy Constructor
//
//////////////////////////////////////////////////////////////
//ok
{
	InitializeCriticalSection(&CS);

	for (int i = ctr1; i < NumCtrs; i++)
		m_aCounter[i] = aInst.m_aCounter[i];
}

CSampleInstance::~CSampleInstance()
//////////////////////////////////////////////////////////////
//
//	Destructor
//
//////////////////////////////////////////////////////////////
//ok
{
	DeleteCriticalSection(&CS);
}

DWORD CSampleInstance::Lock(bool bLock)
//////////////////////////////////////////////////////////////
//
//	Locks or unlocks the instance.    
//
//	Parameters:
//		bLock	- true = lock; false = unlock
//
//////////////////////////////////////////////////////////////
//ok
{
	if (bLock)
		EnterCriticalSection(&CS);
	else
		LeaveCriticalSection(&CS);

	return WBEM_NO_ERROR;
}

DWORD CSampleInstance::SetCounter(long lCtrIndex, DWORD dwVal)
//////////////////////////////////////////////////////////////
//
//	Sets the counter value for an indexed counter.
//
//	Parameters:
//		lCtrIndex	- the index of the counter
//		dwVal		- the value of the counter
//
//////////////////////////////////////////////////////////////
//ok
{
	DWORD dwRes = WBEM_E_FAILED;

	// Verify counter index
	// ====================

	if ((lCtrIndex >= 0) && (lCtrIndex < NumCtrs))
	{
		// Update the counter value
		// ========================
		m_aCounter[lCtrIndex] = dwVal;

		dwRes = WBEM_NO_ERROR;
	}

	return dwRes;
}

DWORD CSampleInstance::GetCounter(long lCtrIndex, DWORD* pdwVal)
//////////////////////////////////////////////////////////////
//
//	Returns the counter value for an indexed counter.
//
//	Parameters:
//		lCtrIndex	- the index of the counter
//		dwVal		- the return parameter for the value
//
//////////////////////////////////////////////////////////////
//ok
{
	DWORD dwRes = WBEM_E_FAILED;
	
	// Verify counter index
	// ====================

	if ((lCtrIndex >= 0) && (lCtrIndex < NumCtrs))
	{	
		// Set return values
		// =================

		*pdwVal = m_aCounter[lCtrIndex];
		dwRes = WBEM_NO_ERROR;
	}

	return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\src\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\sampcli\samplcli.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////
//
//	SamplCli.cpp : Refresher client implementation file
//
//	RefTest is a simple WMI client that demonstrates how to use a 
//	high performance refresher.  It will add a number of 
//	Win32_BasicHiPerf instances as well as a single Win32_BasicHiPerf
//	enumerator.  The optional command line argument specifies a remote
//	WMI connection.  The default is the local machine.  The syntax
//	is as follows:
//
//	refreshertest.exe <server name>
//
//	  server name: the name of the remote machine where the provider
//		id located. 
//
//	Notes: 
//	
//		1) Ensure that Win32_BasicHiPerf is properly set up.  See the
//			BasicHiPerf\BasicHiPerf.html file.
//
//		2) Error handling has been minimized in the sample code for 
//			the purpose of clarity.
//
///////////////////////////////////////////////////////////////////

#define _WIN32_WINNT 0x0400

#define UNICODE

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>

#include "RefClint.h"

void RefreshLoop();

///////////////////////////////////////////////////////////////////
//
//	Globals and constants
//
///////////////////////////////////////////////////////////////////

IWbemServices*	g_pNameSpace = NULL;		// A WMI namespace pointer 

///////////////////////////////////////////////////////////////////
//
//	Code
//
///////////////////////////////////////////////////////////////////

int main( int argc, char *argv[] )
///////////////////////////////////////////////////////////////////
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////
{
	HRESULT hRes = WBEM_NO_ERROR;

	WCHAR	wcsSvrName[256];
	wcscpy( wcsSvrName, L"." );

	// Initialize COM
	// ==============

	hRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
	if ( FAILED( hRes ) )
		return 0;

	// Setup default security parameters
	// =================================

	hRes = CoInitializeSecurity( NULL, -1, NULL, NULL, 
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE, 
											NULL, 
											EOAC_NONE, 
											NULL );
	if ( FAILED( hRes ) )
		return 0;


// Initialize the environment based on the command line arguments
// ==============================================================

	if ( argc > 1 )
	{
		// The remote server name
		// ======================

		MultiByteToWideChar( CP_ACP, 0L, argv[5], -1, wcsSvrName, 2048 );
	}


// Attach to WinMgmt
// =================

	// Get the local locator object
	// ============================

	IWbemLocator*	pWbemLocator = NULL;

	hRes = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );
	if (FAILED(hRes))
		return 0;

	// Connect to the desired namespace
	// ================================

	WCHAR	wszNameSpace[255];
	BSTR	bstrNameSpace;

	swprintf( wszNameSpace, L"\\\\%s\\root\\cimv2", wcsSvrName );

	bstrNameSpace = SysAllocString( wszNameSpace );

	hRes = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
										NULL,			// UserName
										NULL,			// Password
										NULL,			// Locale
										0L,				// Security Flags
										NULL,			// Authority
										NULL,			// Wbem Context
										&g_pNameSpace	// Namespace
										);

	SysFreeString( bstrNameSpace );

	if ( FAILED( hRes ) )
		return 0;

	// Start the refresh loop
	// ======================
	
	RefreshLoop();


// Cleanup
// =======

	if ( NULL != g_pNameSpace )
		g_pNameSpace->Release();

	if ( NULL != pWbemLocator )
		pWbemLocator->Release();

	CoUninitialize();

	return 0;
}

void RefreshLoop()
///////////////////////////////////////////////////////////////////
//
//	RefreshLoop will create a new refresher and configure it with
//	a set of instances and an enumerator.  It will then enter a loop
//	which refreshes and displays the counter data.  Once it has 
//	completed the loop, the members of the refresher are removed.
//
///////////////////////////////////////////////////////////////////
{
	HRESULT		hRes		= WBEM_NO_ERROR;
	long		lLoopCount	= 0;		// Refresh loop counter
	CRefClient	aRefClient;

// Initialize our container class
// ==============================

	aRefClient.Initialize(g_pNameSpace);

// Add items to the refresher
// ==========================

	// Add an enumerator
	// =================

	hRes = aRefClient.AddEnum();
	if ( FAILED( hRes ) )
		goto cleanup;

	// Add objects
	// ===========

	hRes = aRefClient.AddObjects();
	if ( FAILED( hRes ) )
		goto cleanup; 


// Begin the refreshing loop
// =========================

	for ( lLoopCount = 0; lLoopCount < cdwNumReps; lLoopCount++ )
	{
		// Refresh!!
		// =========

		hRes = aRefClient.Refresh();
		if ( FAILED ( hRes ) )
		{
			printf("Refresh failed: 0x%X\n", hRes);
			goto cleanup;
		}

		printf( "Refresh number: %d\n", lLoopCount );

		aRefClient.ShowObjectData();
		aRefClient.ShowEnumeratorData();

		printf( "\n" );

	}	// FOR Refresh

// Cleanup
// =======
cleanup:

	aRefClient.RemoveEnum();
	aRefClient.RemoveObjects();

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\sampcli\refclint.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////
//
//	RefClint.cpp : Refresher client implementation file
//
//	CRefClient encapsulates the basic functionality of using a 
//	WMI high performance refresher.
//
///////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>

#include "RefClint.h"

///////////////////////////////////////////////////////////////////
//
//	Counter data
//
//	These structures are used as a matter of convienience and 
//	clarity.  A real client should enumerate the properties
//	of an object in order to determine the number and names
//	of the counter properties.
//
///////////////////////////////////////////////////////////////////

// The number of counter properties for Win32_BasicHiPerf

enum 
{
	Ctr1,
	Ctr2,
	Ctr3,
	Ctr4,
	Ctr5,
	NumCtrs
};

// The names and handles (set by SetHandles()) for a Win32_BasicHiPerf object

struct CCounterData
{
	WCHAR	m_wcsName[256];
	long	m_lHandle;
} g_aCounters[] =
{
	L"Counter1", 0,
	L"Counter2", 0,
	L"Counter3", 0,
	L"Counter4", 0,
	L"Counter5", 0,
};


///////////////////////////////////////////////////////////////////
//
//	CRefClient
//
///////////////////////////////////////////////////////////////////


CRefClient::CRefClient() : 
	m_pNameSpace(NULL), m_pRefresher(NULL), m_pConfig(NULL)
{
}

CRefClient::~CRefClient()
{
	// Release the COM interfaces (if refresher members have not been manually
	// removed, the refresher destructor should do so automatically)
	// =======================================================================

	if (NULL != m_pNameSpace)
		m_pNameSpace->Release();

	if (NULL != m_pRefresher)
		m_pRefresher->Release();

	if (NULL != m_pConfig)
		m_pConfig->Release();
}

///////////////////////////////////////////////////////////////////
//
//	Helper methods
//
///////////////////////////////////////////////////////////////////

HRESULT CRefClient::SetHandles()
///////////////////////////////////////////////////////////////////
//
//	SetHandles will initialize the IWbemObjectAccess handle values 
//	in the counter array.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

	IWbemClassObject*	pObj = NULL;
	IWbemObjectAccess*	pAccess = NULL;
	
	long lIndex;

// Get an IWbemObjectAccess interface to one of the sample objects
// ===============================================================

	// Create a sample object 
	// ======================

	BSTR strObj = SysAllocString( cwcsObjectPath );

	hRes = m_pNameSpace->GetObject( strObj, 0, NULL, &pObj, NULL );

	SysFreeString( strObj );

	if ( FAILED( hRes ) ) 
		goto cleanup;

	// Get the alternate interface
	// ===========================

	hRes = pObj->QueryInterface( IID_IWbemObjectAccess, ( LPVOID* )&pAccess );

	if ( FAILED( hRes ) ) 
		goto cleanup;

// Set the access handles for all of the counter properties
// ========================================================

	for ( lIndex = Ctr1; lIndex < NumCtrs; lIndex++ )
	{	
		long lHandle;

		hRes = pAccess->GetPropertyHandle( g_aCounters[lIndex].m_wcsName, NULL, &lHandle );
		
		if ( FAILED( hRes ) )
			goto cleanup;
	
		g_aCounters[lIndex].m_lHandle = lHandle;
	}			

// Cleanup the object pointers
// ===========================

cleanup:
	if ( NULL != pObj )
	{
		pObj->Release();
		pObj = NULL;
	}

	if ( NULL != pAccess )
	{
		pAccess->Release();
		pAccess = NULL;
	}

	if ( FAILED( hRes ) )
	{
		printf( "SetHandles() failed, 0x%x\n", hRes );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////
//
//	Class method API
//
///////////////////////////////////////////////////////////////////

HRESULT CRefClient::Initialize(IWbemServices* pNameSpace)
///////////////////////////////////////////////////////////////////
//
//	Initialize will create the refresher and configuration manager
//	and set the IWbemObjectAccess handles which are used to access
//	property values of the instances.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
{
	HRESULT hRes = WBEM_NO_ERROR;

	// Copy the namespace pointer
	// ==========================

	if ( NULL == pNameSpace )
		return WBEM_E_INVALID_PARAMETER;

	m_pNameSpace = pNameSpace;
	m_pNameSpace->AddRef();

	// Create the refresher and refresher manager
	// ==========================================

	hRes = CoCreateInstance( CLSID_WbemRefresher, 
							 NULL, 
							 CLSCTX_INPROC_SERVER, 
							 IID_IWbemRefresher, 
							 (void**) &m_pRefresher );
	if ( FAILED( hRes ) )
		return hRes;

	hRes = m_pRefresher->QueryInterface( IID_IWbemConfigureRefresher, 
										 (void**) &m_pConfig );
	if ( FAILED( hRes ) )
		return hRes;

	// Set the access handles
	// ======================

	hRes = SetHandles();

	return hRes;
}

HRESULT CRefClient::AddObjects()
///////////////////////////////////////////////////////////////////
//
//	AddObject will add a set of objects to the refresher.  The 
//	method will update m_aInstances with the instance data. 
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

	long	lIndex = 0;
	WCHAR	wcsObjName[256];

// Loop through all instances of Win32_BasicHiPerf and add them to the refresher
// =============================================================================

	for ( lIndex = 0; lIndex < clNumInstances; lIndex++ )
	{
		IWbemClassObject*	pObj = NULL;
		IWbemObjectAccess*	pAccess = NULL;
		long lID;

		// Set the object path (e.g. Win32_BasicHiPerf=1)
		// ==============================================

		swprintf( wcsObjName, L"%s=%i", cwcsObjectPath, lIndex );
	
		// Add the object
		// ==============

		hRes = m_pConfig->AddObjectByPath( m_pNameSpace, wcsObjName, 0, NULL, &pObj, &lID );

		if ( FAILED( hRes ) )
		{
			printf( "AddObjectByPath() failed, 0x%x\n", hRes );
			return hRes;
		}

		// Save the IWbemObjectAccess interface
		// ====================================
		
		hRes = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );
		hRes = pObj->Release();

		m_Instances[lIndex].Set(pAccess, lID);

		// Set does it's own AddRef()
		// ==========================

		pAccess->Release();
	}
	
	return hRes;
}

HRESULT CRefClient::RemoveObjects()
///////////////////////////////////////////////////////////////////
//
//	RemoveObjects calls Remove() on the refresher's configuration 
//	manager to remove all of the objects from the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
{
	HRESULT hRes = WBEM_NO_ERROR;

	long lInstance = 0;

	// Remove the instances
	// ====================

	for ( lInstance = 0; lInstance < clNumInstances; lInstance++ )
	{
		m_pConfig->Remove( m_Instances[lInstance].GetID(), 0L );

		m_Instances[lInstance].Reset();
	}

	return hRes;
}

HRESULT CRefClient::ShowObjectData()
///////////////////////////////////////////////////////////////////
//
//	ShowInstanceData will output all of the counter data for all
//	of the instances within the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
{
	HRESULT hRes = WBEM_NO_ERROR;

	long lInstance;
	long lCounter;

// Cycle through all of the instances and print all the counter data
// =================================================================

	// Instance loop
	// =============

	for (lInstance = 0; lInstance < clNumInstances; lInstance++)
	{
		printf("  Instance %i:\n", lInstance);
	
		// Counter loop
		// ============

		for (lCounter = Ctr1; lCounter < NumCtrs; lCounter++)
		{
			DWORD dwVal;
			IWbemObjectAccess* pAccess = m_Instances[lInstance].GetMember();

			// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
			// NOTE: Remember to never to this while a refresh is in process!
			// ==========================================================================================

			hRes = pAccess->ReadDWORD( g_aCounters[lCounter].m_lHandle, &dwVal);
			if (FAILED(hRes))
			{
				printf("ShowInstanceData() failed, 0x%x", hRes);
				return hRes;
			}

			printf("    %i ", dwVal);

			pAccess->Release();
		}

		printf("\n");
	}

	return hRes;
}

HRESULT CRefClient::AddEnum()
///////////////////////////////////////////////////////////////////
//
//	AddEnum will add an enumerator to the refresher.  The 
//	function will return a status code.  The enumerator class member 
//	will updated.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hRes = WBEM_NO_ERROR;

	IWbemHiPerfEnum*	pEnum = NULL;
	long lID;

// Add an enumerator to the refresher
// ==================================

	hRes = m_pConfig->AddEnum( m_pNameSpace, cwcsObjectPath, 0, NULL, &pEnum, &lID );

	m_Enum.Set(pEnum, lID);

	// Set does it's own AddRef
	// ========================

	pEnum->Release();

	if ( FAILED(hRes) )
	{
		printf( "AddEnum() failed, 0x%x\n", hRes );
	}

	return hRes;
}

HRESULT CRefClient::RemoveEnum()
///////////////////////////////////////////////////////////////////
//
//	RemoveEnum calls Remove() on the refresher's configuration 
//	manager to remove the enumerator from the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
{
	HRESULT hRes = WBEM_NO_ERROR;

	// Remove the enumerator
	// =====================

	hRes = m_pConfig->Remove( m_Enum.GetID(), 0L );

	m_Enum.Reset();

	return hRes;
}

HRESULT CRefClient::ShowEnumeratorData()
///////////////////////////////////////////////////////////////////
//
//	ShowEnumeratorData will output the number of instances within 
//	an enumerator.  Property values from the instances may obtained
//	using the standard WMI methods.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
{
	HRESULT hRes = WBEM_NO_ERROR;

	DWORD	dwNumReturned = clNumInstances;
	DWORD	dwNumObjects = 0;

	IWbemObjectAccess**	apEnumAccess = NULL;

	IWbemHiPerfEnum*	pEnum = m_Enum.GetMember();

// Fetch the instances from the enumerator
// =======================================

	// Try to get the instances from the enumerator
	// ============================================

	hRes = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );

	// Is the buffer too small?
	// ========================

	if ( WBEM_E_BUFFER_TOO_SMALL == hRes )
	{
		// Increase the buffer size
		// ========================

		delete [] apEnumAccess;

		apEnumAccess = new IWbemObjectAccess*[dwNumReturned];
		dwNumObjects = dwNumReturned; 
		memset( apEnumAccess, 0, sizeof( apEnumAccess ));

		if ( NULL != apEnumAccess )
		{
			hRes = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );
		}
		else
		{
			hRes = WBEM_E_OUT_OF_MEMORY;
		}

	}	

	// Print the result
	// ================

	if ( SUCCEEDED( hRes ) )
	{
		printf( "\tThe enumerator returned %i instances\n", dwNumReturned );
	}
	else
	{
		printf( "ShowEnumeratorData failed, 0x%x\n", hRes );
	}

	// Release the objects from the enumerator's object array
	// ======================================================
	
	for ( DWORD nCtr = 0; nCtr < dwNumReturned; nCtr++ )
	{
		if (NULL != apEnumAccess[nCtr])
		{
			apEnumAccess[nCtr]->Release();
			apEnumAccess[nCtr] = NULL;
		}
	}

	if ( NULL != apEnumAccess )
		delete [] apEnumAccess;

	pEnum->Release();

	return hRes;
}

HRESULT CRefClient::Refresh()
///////////////////////////////////////////////////////////////////
//
//	Refresh simply calls the IWbemRefresher->Refresh() method to 
//	update all members of the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
{
	return m_pRefresher->Refresh( 0L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\src\factory.h ===
////////////////////////////////////////////////////////////////////////

//

//	Factory.h

//

//	Module:	WMI high performance provider sample code

//

//	This is a standard class factory implementation for the CHiPerfProvider

//	object.  

//

//  History:

//	a-dcrews      12-Jan-99		Created

//

//	

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
//
//	CClassFactory
//
//////////////////////////////////////////////////////////////

class CClassFactory : public IClassFactory
{
protected:
	long	m_lRef;

public:
	CClassFactory() : m_lRef(0) {}

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IClassFactory COM interfaces
	// ============================

	STDMETHODIMP CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv);	

	STDMETHODIMP LockServer(
		/* [in] */ BOOL bLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\src\factory.cpp ===
////////////////////////////////////////////////////////////////////////

//

//	Factory.cpp

//

//	Module:	WMI high performance provider sample code

//

//	This is a standard class factory implementation for the CHiPerfProvider

//	object.  

//

//  History:

//	a-dcrews      12-Jan-99		Created

//

//	

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>

#include "BasicHiPerf.h"
#include "Factory.h"

#define _UNICODE
#define UNICODE

extern long g_lObjects;
extern long g_lLocks;

//////////////////////////////////////////////////////////////
//
//
//	CClassFactory
//
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
    else if(riid == IID_IClassFactory)
        *ppv = (LPVOID)(IClassFactory*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CClassFactory::CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv)
//////////////////////////////////////////////////////////////
//
//	Standard COM CreateInstance
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;
	CHiPerfProvider *pProvider = NULL;

	*ppv = NULL;

	// We do not support aggregation
	// =============================

	if (pUnknownOuter)
		return CLASS_E_NOAGGREGATION;

	// Create the provider object
	// ==========================

	pProvider = new CHiPerfProvider;

	if (!pProvider)
		return E_OUTOFMEMORY;

	// Retrieve the requested interface
	// ================================

	hRes = pProvider->QueryInterface(iid, ppv);
	if (FAILED(hRes))
	{
		delete pProvider;
		return hRes;
	}

	return S_OK;
}

STDMETHODIMP CClassFactory::LockServer(
		/* [in] */ BOOL bLock)
//////////////////////////////////////////////////////////////
//
//	Standard COM LockServer
//
//////////////////////////////////////////////////////////////
{
	if (bLock)
		InterlockedIncrement(&g_lLocks);
	else
		InterlockedDecrement(&g_lLocks);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WMI Class provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CClassPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CClassPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\src\basichiperf.h ===
//////////////////////////////////////////////////////////////////////

//

//	BasicHiPerf.h

//

//	Module:	WMI high performance provider sample code

//

//	This is the skeleton code implementation of a high performance 

//	provider.  This file includes the provider and refresher code

//

//	In this example, we are using a single object scenario.  The 

//	provider provides one type of object called Win32_BasicHiPerf.

//	There is a static number of instances available, specified by

//	NUM_INSTANCES and maintained by the CHiPerfProvider class.

//	When a refresher is created, it has two local caches: one

//	for the instances that it contains, and another for the 

//	enumerators.  Since there is only one class, only one enumerator 

//	should be necessary, but there can be up to MAX_ENUMERATORS 

//	enumerators added to a given refresher.  The members of a refresher

//	are given IDs.  The IDs for the enumerators are essentially array 

//	indecies into the enumerator array.  The IDs for the objects are

//	stored in an array that maps the unique ID to one of the cached 

//	objects.  The enumerator IDs are within the range of 0 to 

//	MAX_ENUMERATORS - 1, and the objects will have IDs equal or greater 

//	than MAX_ENUMERATORS.

//

//	The actual counter data is simulated by the CSampleDataSource 

//	which maintains a set of CSampleInstances.  Periodically, the 

//	CSampleInstance counter values are updated.  The objects in the 

//	refresher are only updated on a refresh.

//

//  History:

//	a-dcrews	12-Jan-99		Created

//	a-dcrews	10-Mar-99		Added data source simulation	

//

//	

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////

#ifndef _HIPERFPROV_H_
#define _HIPERFPROV_H_

#define UNICODE
#define _UNICODE

#include <tchar.h> 
#include <wbemprov.h>

class CRefresher;
class CRefCacheElement;

//////////////////////////////////////////////////////////////
//
//
//	Constants and globals
//
//	
//////////////////////////////////////////////////////////////

#define NUM_OBJECTS				1
#define NUM_INSTANCES			5
#define MAX_INSTANCES			128
#define MAX_ENUMERATORS			10

#define SAMPLE_CLASS			_T("Win32_BasicHiPerf")

#define PROP_DWORD	0x0001L
#define PROP_QWORD	0x0002L
#define PROP_VALUE	0x0004L

//	This enumeration is used to reference the counters.  It  
//	matchs the number of counters in the mof definition of
//	the Win32_BasicHiPerf object.

const enum CounterHandles
{
	ctr1 = 0,
	ctr2,
	ctr3,
	ctr4,
	ctr5,
	NumCtrs
};

//////////////////////////////////////////////////////////////
//
//	CCacheMapEl
//
//	The IDs assigned to objects added to the refresher are 
//	mapped to the actual object cache index using an array
//	of CCacheMapEls.  The generation of unique IDs is controlled
//	by the static member m_lGenID.
//
//////////////////////////////////////////////////////////////

class CCacheMapEl
{
	static long	m_lGenID;

	// The unique ID of the object passed back to the caller
	// =====================================================
	long	m_lUID;

	// The index of the object in the instance cache
	// =============================================
	long	m_lIndex;

public:
	CCacheMapEl(long lIndex) : m_lIndex(lIndex), m_lUID(m_lGenID++)
	{}

	long GetUID() {return m_lUID;}
};

//////////////////////////////////////////////////////////////
//
//	CSampleInstance
//
//	This class is a representation of a real data instance.  
//	The counter values correspond directly to WMI object 
//	parameters.
//
//////////////////////////////////////////////////////////////

class CSampleInstance
{
	// The counter values
	// ==================
	DWORD	m_aCounter[NumCtrs];

	// The lock mechanism
	// ==================
	CRITICAL_SECTION	CS;

public:
	CSampleInstance();
	CSampleInstance(const CSampleInstance &aInst);
	~CSampleInstance();

	DWORD	Lock(bool bLock);

	DWORD	SetCounter(long lCtr, DWORD dwVal);
	DWORD	GetCounter(long lCtr, DWORD* pdwVal);
};

//////////////////////////////////////////////////////////////
//
//	CSampleDataSource
//
//	This class is a representation of a real data source.  
//	Instance data counters are periodically updated, and their 
//	values may be retrieved to update the refresher.
//
//////////////////////////////////////////////////////////////

class CSampleDataSource
{
	// The IWbemObjectAccess counter handles
	// =====================================
	long	m_alHandle[NumCtrs];

	// The array of instances
	// ======================
	CSampleInstance m_aInstance[NUM_INSTANCES];

	// The data source control members (mocks changes in counter values)
	// =================================================================
	HANDLE	m_hThread;

	// The thread termination event
	// ============================
	HANDLE	m_hQuit;


	DWORD	SetHandles(IWbemClassObject* pSampleClass);

	DWORD	Simulate();

	static unsigned __stdcall CSampleDataSource::ThreadEntry(void* pArgs);

public:
	CSampleDataSource();
	virtual ~CSampleDataSource();

	DWORD Initialize(IWbemClassObject* pSampleClass);

	DWORD UpdateInstance(IWbemObjectAccess* pObj);
};

//////////////////////////////////////////////////////////////
//
//	CHiPerfProvider
//
//	The provider maintains a single IWbemClassObject to be used 
//	as a template to spawn instances for the Refresher as well
//	as QueryInstances.  It also maintains the static sample 
//	data source which provides all data to the instances.
//
//////////////////////////////////////////////////////////////

class CHiPerfProvider : public IWbemProviderInit, public IWbemHiPerfProvider
{
	long m_lRef;

	// Our mock data source
	// ====================

	static CSampleDataSource* m_pSampleDS;

	// An instance template (used for QueryInstances)
	// ==============================================

	IWbemClassObject*	m_pTemplate;

public:
	CHiPerfProvider();
	~CHiPerfProvider();

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWbemProviderInit COM interface
	// ===============================

	STDMETHODIMP Initialize( 
		/* [unique][in] */ LPWSTR wszUser,
		/* [in] */ long lFlags,
		/* [in] */ LPWSTR wszNamespace,
		/* [unique][in] */ LPWSTR wszLocale,
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink );

	// IWbemHiPerfProvider COM interfaces
	// ==================================

	STDMETHODIMP QueryInstances( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [string][in] */ WCHAR __RPC_FAR *wszClass,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pSink );
    
	STDMETHODIMP CreateRefresher( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ long lFlags,
		/* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
    
	STDMETHODIMP CreateRefreshableObject( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pContext,
		/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		/* [out] */ long __RPC_FAR *plId );
    
	STDMETHODIMP StopRefreshing( 
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lId,
		/* [in] */ long lFlags );

	STDMETHODIMP CreateRefreshableEnum(
		/* [in] */ IWbemServices* pNamespace,
		/* [in, string] */ LPCWSTR wszClass,
		/* [in] */ IWbemRefresher* pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext* pContext,
		/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
		/* [out] */ long* plId);

	STDMETHODIMP GetObjects(
        /* [in] */ IWbemServices* pNamespace,
		/* [in] */ long lNumObjects,
		/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext* pContext);
};


//////////////////////////////////////////////////////////////
//
//	CRefresher
//
//	The refresher maintains an object and an enumerator cache.
//	When an enumerator is added to the refrehser, it is added 
//	to the enumerator cache, and the index of the array is
//	passed back as a unique ID.  The refresher creates a cache
//	of all instances during its initialization.  When an object 
//	is added to the refresher, a mapping to the object is 
//	created between the unique ID and the index of the object
//	in the cache.  This allows the objects to be reused and 
//	facilitates the management of objects that have been added 
//	multiple times.
//
//////////////////////////////////////////////////////////////

class CRefresher : public IWbemRefresher
{
	// COM reference counter
	// =====================

	long	m_lRef;

	// A pointer to the sample data source
	// ===================================

	CSampleDataSource*	m_pDS;

	// The enumerators that have been added to the refresher
	// =====================================================

	IWbemHiPerfEnum*	m_apEnumerator[MAX_ENUMERATORS];

	// The instances that have been added to the refresher
	// ===================================================

	CCacheMapEl*		m_apInstMap[MAX_INSTANCES];
	IWbemObjectAccess*	m_apInstances[NUM_INSTANCES];

	// The parent provider
	// ===================

	CHiPerfProvider* m_pProvider;

public:
	CRefresher(CHiPerfProvider* pProvider, CSampleDataSource* pDS);
	virtual ~CRefresher();

	DWORD Initialize(IWbemClassObject* pSampleClass);

	// Instance management functions
	// =============================

	DWORD AddObject(IWbemObjectAccess *pObj, IWbemObjectAccess **ppReturnObj, long *plId);
	DWORD RemoveObject(long lId);

	// Enumerator management functions
	// ===============================

	DWORD AddEnum(IWbemHiPerfEnum *pHiPerfEnum, long *plId);
	DWORD RemoveEnum(long lId);

	// COM methods
	// ===========

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	STDMETHODIMP Refresh(/* [in] */ long lFlags);
};


#endif // _HIPERFPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\src\server.cpp ===
////////////////////////////////////////////////////////////////////////

//

//  Server.cpp

//

//	Module:	WMI high performance provider sample code

//

//  Generic COM server framework, adapted for the BasicHiPerf provider 

//	sample.  This module contains nothing specific to the BasicHiPerf 

//	provider except what is defined in the section bracketed by the 

//	CLSID SPECIFIC comments below.

//

//  History:

//  raymcc        25-Nov-97     Created.

//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.

//	a-dcrews      12-Jan-99		Adapted for BasicHiPerf.dll

//

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>

#include "Factory.h"

/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

// For new providers, this is the only area that needs to be modified in this
// file.  Include any appropriate header files, a unique CLSID and update 
// the macros.

#include "wbemprov.h"
#include "BasicHiPerf.h"

// {B56B1D80-AA4F-11d2-B348-00105A1469B7}
DEFINE_GUID(CLSID_BasicHiPerf_v1,
0xb56b1d80, 0xaa4f, 0x11d2, 0xb3, 0x48, 0x0, 0x10, 0x5a, 0x14, 0x69, 0xb7);

#define IMPLEMENTED_CLSID           CLSID_BasicHiPerf_v1
#define SERVER_REGISTRY_COMMENT     L"WMI Basic HiPerf Provider"
#define CPP_CLASS_NAME              CHiPerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider*)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////


HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CClassFactory *pClassFactory = NULL;
	HRESULT hRes;

    //  Verify the caller is asking for our type of object
	// ===================================================

    if (IMPLEMENTED_CLSID == rclsid) 
	{
		// Create the class factory
		// ========================

		pClassFactory = new CClassFactory;

		if (!pClassFactory)
			return E_OUTOFMEMORY;
		
		hRes = pClassFactory->QueryInterface(riid, ppv);
		if (FAILED(hRes))
		{
			delete pClassFactory;
			return hRes;
		}
		hRes = S_OK;
	}
	else 
		hRes = CLASS_E_CLASSNOTAVAILABLE;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hRes = S_FALSE;

    if (0 == g_lLocks && 0 == g_lObjects)
        hRes = S_OK;

    return hRes;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Get the dll's filename
    // ======================

    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, (DWORD)(wcslen(pName) * 2 + 2));

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, (DWORD)(wcslen(Path) * 2 + 2));
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", (DWORD)(wcslen(L"Both") * 2 + 2));

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WINMGMT class provider sample code

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "sample.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_classprovider,0x22cb8799, 0x914a, 0x11cf, 0xb7, 0x5, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);
// {22CB8799-914A-11cf-B705-00AA0062CBB7}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_classprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WINMGMT Sample Class Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_classprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_classprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\classprov.cpp ===
//***************************************************************************

//

//  CLASSPRO.CPP

//

//  Module: WINMGMT class provider sample code

//

//  Purpose: Defines the CClassPro class.  An object of this class is

//           created by the class factory for each connection.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"
#include <process.h>

InstDef MyDefs[] = {{L"a", 1}, {L"b", 2}, {L"c", 3}};

long glNumInst = sizeof(MyDefs)/sizeof(InstDef);

#define SAMPLE_CLASS_NAME L"ClassProvSamp"

//***************************************************************************
//
// CClassPro::CClassPro
// CClassPro::~CClassPro
//
//***************************************************************************

CClassPro::CClassPro(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
{
    m_pNamespace = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CClassPro::~CClassPro(void)
{
    if(m_pNamespace)
        m_pNamespace->Release();
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CClassPro::QueryInterface
// CClassPro::AddRef
// CClassPro::Release
//
// Purpose: IUnknown members for CClassPro object.
//***************************************************************************


STDMETHODIMP CClassPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CClassPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CClassPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CClassPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CClassPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CClassPro::CreateClassEnumAsync
//
// Purpose: Asynchronously enumerates the classes this provider supports.  
// Note that this sample only supports one.  
//
//***************************************************************************

SCODE CClassPro::CreateClassEnumAsync(const BSTR Superclass, long lFlags, 
									  IWbemContext  *pCtx, IWbemObjectSink *pHandler)
{
    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

	SCODE sc = S_OK;

	if(Superclass == NULL || wcslen(Superclass) == 0)
	{
		IWbemClassObject * pNewClass = NULL;
		sc = CreateClass(m_pNamespace, &pNewClass, SAMPLE_CLASS_NAME, pCtx);
 
		if(sc == S_OK)
		{
			// Send the object to the caller

			pHandler->Indicate(1,&pNewClass);
			pNewClass->Release();
		}
	}
    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);
	return S_OK;
}

//***************************************************************************
//
// CClassPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CClassPro::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc;
    int iCnt;
    IWbemClassObject FAR* pNewInst;
  
    // Do a check of arguments and make sure we have pointer to Namespace

    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    for(iCnt=0; iCnt < glNumInst; iCnt++)
    {
        sc = CreateInst(m_pNamespace,MyDefs[iCnt].pwcKey,
                    MyDefs[iCnt].lValue, &pNewInst, RefStr, pCtx);
 
        if(sc != S_OK)
            break;

        // Send the object to the caller

        pHandler->Indicate(1,&pNewInst);
        pNewInst->Release();
    }

    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);

    return sc;
}


//***************************************************************************
//
// CClassPro::GetObjectByPathAsync
//
// Purpose: Returns either an instance or a class.
//
//***************************************************************************



SCODE CClassPro::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc;
    IWbemClassObject FAR* pObj;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// If we are being asked for our class, get that
	size_t i1 = wcslen(ObjectPath);
	size_t i2 = wcslen(SAMPLE_CLASS_NAME);
	if(i1 >= i2 && !_wcsicmp(&ObjectPath[i1-i2], SAMPLE_CLASS_NAME) )
	{
		IWbemClassObject * pNewClass = NULL;
		sc = CreateClass(m_pNamespace, &pNewClass, SAMPLE_CLASS_NAME, pCtx);
 
		if(sc == S_OK)
		{
			// Send the object to the caller

			pHandler->Indicate(1,&pNewClass);
			pNewClass->Release();
		}
	}
	else if(S_OK ==GetByPath(ObjectPath,&pObj, pCtx))
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
        bOK = TRUE;
		sc = S_OK;
    }
	else
		sc = WBEM_E_NOT_FOUND;

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);

    return sc;
}
 
//***************************************************************************
//
// CClassPro::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CClassPro::GetByPath(BSTR ObjectPath, IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx)
{
    SCODE sc = S_OK;
    
    int iCnt;

    // do a simple path parse.  The path will look something like
    // ClassProvSamp.MyKey="a"
    // Create a test string with just the part between quotes.

    WCHAR wcTest[MAX_PATH+1];
    wcscpy(wcTest,ObjectPath);
    WCHAR * pwcTest, * pwcCompare = NULL;
    int iNumQuotes = 0;
    for(pwcTest = wcTest; *pwcTest; pwcTest++)
        if(*pwcTest == L'\"')
        {
            iNumQuotes++;
            if(iNumQuotes == 1)
            {
                pwcCompare = pwcTest+1;
            }
            else if(iNumQuotes == 2)
            {
                *pwcTest = NULL;
                break;
            }
        }
        else if(*pwcTest == L'.')
            *pwcTest = NULL;    // issolate the class name.
    if(iNumQuotes != 2)
        return WBEM_E_FAILED;

    // check the instance list for a match.

    for(iCnt = 0; iCnt < glNumInst; iCnt++)
    {
        if(!_wcsicmp(MyDefs[iCnt].pwcKey, pwcCompare))
        {
            sc = CreateInst(m_pNamespace,MyDefs[iCnt].pwcKey,
                    MyDefs[iCnt].lValue, ppObj, wcTest, pCtx);
            return sc;
        }
    }

    return WBEM_E_NOT_FOUND;
}
 
SCODE CClassPro::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{

	VARIANT var;
	VariantInit(&var);
	pObject->Get(L"__Class", 0, &var, NULL, NULL);
	if(!_wcsicmp(SAMPLE_CLASS_NAME, var.bstrVal))
		pResponseHandler->SetStatus(0,S_OK,NULL, NULL);
	else
		pResponseHandler->SetStatus(0,WBEM_E_NOT_FOUND,NULL, NULL);
	return S_OK;
}
 
SCODE CClassPro::DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!_wcsicmp(SAMPLE_CLASS_NAME, Class))
		pResponseHandler->SetStatus(0,S_OK,NULL, NULL);
	else
		pResponseHandler->SetStatus(0,WBEM_E_NOT_FOUND,NULL, NULL);

	return S_OK;
}
SCODE CClassPro::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    pResponseHandler->SetStatus(0,S_OK,NULL, NULL);
	return S_OK;
}
SCODE CClassPro::DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    pResponseHandler->SetStatus(0,S_OK,NULL, NULL);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\utils.cpp ===
//***************************************************************************

//

//  UTILS.CPP

//

//  Module: WINMGMT class provider sample code

//

//  Purpose: General purpose utilities.  

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"


//***************************************************************************
//
// CreateInst
//
// Purpose: Creates a new instance and sets
//          the inital values of the properties.
//
// Return:   S_OK if all is well, otherwise an error code is returned
//
//***************************************************************************

SCODE CreateInst(IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
                                        IWbemClassObject ** pNewInst,
                                        WCHAR * pwcClassName,
										IWbemContext  *pCtx)
{   
    SCODE sc;
    IWbemClassObject * pClass = NULL;
    sc = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
        return WBEM_E_FAILED;
    sc = pClass->SpawnInstance(0, pNewInst);
    pClass->Release();
    if(FAILED(sc))
        return sc;
    VARIANT v;

    // Set the key property value.

    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(pKey);
    sc = (*pNewInst)->Put(L"MyKey", 0, &v, 0);
    VariantClear(&v);

    // Set the number property value.

    v.vt = VT_I4;
    v.lVal = lVal;
    sc = (*pNewInst)->Put(L"MyValue", 0, &v, 0);
    return sc;
}

SCODE CreateClass( IWbemServices * pNamespace, IWbemClassObject ** pNewClass,
                                             WCHAR * pwcClassName,
											 IWbemContext  *pCtx)
{

    SCODE sc;
    sc = pNamespace->GetObject(NULL, 0, pCtx, pNewClass, NULL);
    if(sc != S_OK)
        return sc;

    VARIANT v;

    // Set the class name.

    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(pwcClassName);
    sc = (*pNewClass)->Put(L"__class", 0, &v, 0);
    VariantClear(&v);


    // Set the key property value.

    v.vt = VT_NULL;
    sc = (*pNewClass)->Put(L"MyKey", 0, &v, CIM_STRING);

    // Set the number property value.

    sc = (*pNewClass)->Put(L"MyValue", 0, &v, CIM_SINT32);

	// Set the key qualifier

	IWbemQualifierSet* pQualSet = NULL;

	sc = (*pNewClass)->GetPropertyQualifierSet(L"MyKey", &pQualSet);
	if(pQualSet)
	{
	    v.vt = VT_BOOL;
		v.boolVal = VARIANT_TRUE;
		sc = pQualSet->Put(L"Key", &v, 0);
		pQualSet->Release();
	}

	// Set the dynamic qualifier

	sc = (*pNewClass)->GetQualifierSet(&pQualSet);
	if(pQualSet)
	{
	    v.vt = VT_BOOL;
		v.boolVal = VARIANT_TRUE;
		sc = pQualSet->Put(L"Dynamic", &v, 0);

	    v.vt = VT_BSTR;
		v.bstrVal = SysAllocString(L"ClassProvSamp");
		sc = pQualSet->Put(L"Provider", &v, 0);
		VariantClear(&v);

		pQualSet->Release();
	}

    return sc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\sample.h ===
//***************************************************************************

//

//  sample.h

//

//  Module: WINMGMT class provider sample code

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _sample_H_
#define _sample_H_

#include <wbemprov.h>

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CClassPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pNamespace;
     public:
        CClassPro(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        ~CClassPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

        //IWbemServices  

		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

};

typedef CClassPro *PCClassPro;

// This class is the class factory for CClassPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

// General purpose utilities.  

             
SCODE CreateInst( IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
                                             IWbemClassObject ** pNewInst,
                                             WCHAR * pwcClassName,
											 IWbemContext  *pCtx); 
SCODE CreateClass( IWbemServices * pNamespace, IWbemClassObject ** pNewInst,
                                             WCHAR * pwcClassName,
											 IWbemContext  *pCtx); 

typedef struct {
   WCHAR * pwcKey;
   long lValue;
   } InstDef;

extern InstDef MyDefs[];
extern long glNumInst;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\cmdlineconsumerdlg.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  CmdLineConsumerDlg.h
//
// Description:
//			Defines the class for the consumer's dialog
//
// History:
//
// **************************************************************************

#if !defined(AFX_CMDLINECONSUMERDLG_H__EF85AEB9_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
#define AFX_CMDLINECONSUMERDLG_H__EF85AEB9_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerDlg dialog

class CCmdLineConsumerDlg : public CDialog
{
// Construction
public:
	CCmdLineConsumerDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CCmdLineConsumerDlg)
	enum { IDD = IDD_CMDLINECONSUMER_DIALOG };
	CListBox	m_output;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCmdLineConsumerDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CCmdLineConsumerDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMDLINECONSUMERDLG_H__EF85AEB9_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\cmdlineconsumer.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  CmdLineConsumer.h
//
// Description:
//			main header file for the CMDLINECONSUMER application
//
// History:
//
// **************************************************************************

#if !defined(AFX_CMDLINECONSUMER_H__EF85AEB7_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
#define AFX_CMDLINECONSUMER_H__EF85AEB7_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include "factory.h"

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp:
// See CmdLineConsumer.cpp for the implementation of this class
//

class CCmdLineConsumerApp : public CWinApp
{
public:
	CCmdLineConsumerApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCmdLineConsumerApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CCmdLineConsumerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	int ExitInstance();

private:
	DWORD m_clsReg;
	CProviderFactory *m_factory;

	void RegisterServer(void);
	void UnregisterServer(void);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMDLINECONSUMER_H__EF85AEB7_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\consumer.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Consumer.cpp
//
// Description:
//			Event consumer class implementation
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Consumer.h"
#include <objbase.h>

CConsumer::CConsumer(CListBox	*pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CConsumer::~CConsumer()
{
}

STDMETHODIMP CConsumer::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConsumer::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConsumer::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CConsumer::IndicateToConsumer(IWbemClassObject *pLogicalConsumer,
											long lNumObjects,
											IWbemClassObject **ppObjects)
{
/* for easy reference.
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
*/

	// NOTE: If this routine returns a failure code, including 
	// GPFs from called routines, CIMOM will recreate the object 
	// and call here again. If you see this routine being called 
	// twice for every indication, it means this routine is 
	// returning a failure code somehow. Especially watch the 
	// AddRef()/Release() semantics for the embedded object.
	// If they're too low, you'll return a GPF.
	CString clMyBuff;
	BSTR tgtProp = NULL;
	BSTR showProp = NULL;
	BSTR tgt = NULL;
	UINT showWindow = SW_SHOWNORMAL;
	VARIANT pVal, pVal1;

#define BUFSIZE 256
	char buffer[BUFSIZE];

	// WideCharToMultiByte wont null terminate its result so 
	// if its not initialized to nulls, you'll get junk after 
	// the converted command line and it wont run the command.
	memset(buffer, 0, BUFSIZE);

	VariantInit(&pVal);
	VariantInit(&pVal1);

	TRACE(_T("Indicate() called\n"));

	tgtProp = SysAllocString(L"cmdLine");
	showProp = SysAllocString(L"ShowWindow");

	// clear my output buffer.
	clMyBuff.Empty();

	//--------------------------------
	// NOTICE that I only call once per call, not once per object passed since
	//  I dont care what object caused the event anyway.

	// get the 'Item' property out of the embedded object.
	if((pLogicalConsumer->Get(tgtProp, 0L, &pVal, NULL, NULL) == S_OK) &&
		(pLogicalConsumer->Get(showProp, 0L, &pVal1, NULL, NULL) == S_OK))
	{
		// pull out the command.
		clMyBuff = _T("cmdLine will run: ");

		// take onto the display line.
		tgt = V_BSTR(&pVal);
		clMyBuff += tgt;

		// how to run the program.
		showWindow = (UINT)V_UI1(&pVal1);

		// convert the original to ascii for the WinExec() call.
        WideCharToMultiByte(CP_ACP, 0, 
							tgt, SysStringLen(tgt), 
							buffer, BUFSIZE,
							NULL, NULL);

		TRACE(buffer);

		// call winExec.
		UINT ret = WinExec(buffer, showWindow);

		if(ret <= 31)
		{
			WCHAR msg[100];
			wcscpy(msg, _itow(ret, &msg[0], 10));
			AfxMessageBox((LPCTSTR)&msg[0]);
		}

		// output the buffer.
		m_pOutputList->AddString(clMyBuff);
	}
	else
	{
		TRACE(_T("Get() cmdLine failed\n"));
	}

	SysFreeString(tgtProp);
	VariantClear(&pVal);

	TRACE(_T("walked indication list\n"));

	return S_OK;
}

// **************************************************************************
//
//	ErrorString()
//
// Description:
//		Converts an HRESULT to a displayable string.
//
// Parameters:
//		hRes (in) - HRESULT to be converted.
//
// Returns:
//		ptr to displayable string.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
LPCTSTR CConsumer::ErrorString(HRESULT hRes)
{
    TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

    switch(hRes) 
    {
    case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
    case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
    case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
    case WBEM_S_ALREADY_EXISTS:
        psz = _T("WBEM_S_ALREADY_EXISTS");
        break;
    case WBEM_S_RESET_TO_DEFAULT:
        psz = _T("WBEM_S_RESET_TO_DEFAULT");
        break;
    case WBEM_S_DIFFERENT:
        psz = _T("WBEM_S_DIFFERENT");
        break;
    case WBEM_E_OVERRIDE_NOT_ALLOWED:
        psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
        break;
    case WBEM_E_PROPAGATED_QUALIFIER:
        psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
        break;
    case WBEM_E_PROPAGATED_PROPERTY:
        psz = _T("WBEM_E_PROPAGATED_PROPERTY");
        break;
    case WBEM_E_UNEXPECTED:
        psz = _T("WBEM_E_UNEXPECTED");
        break;
    case WBEM_E_ILLEGAL_OPERATION:
        psz = _T("WBEM_E_ILLEGAL_OPERATION");
        break;
    case WBEM_E_CANNOT_BE_KEY:
        psz = _T("WBEM_E_CANNOT_BE_KEY");
        break;
    case WBEM_E_INCOMPLETE_CLASS:
        psz = _T("WBEM_E_INCOMPLETE_CLASS");
        break;
    case WBEM_E_INVALID_SYNTAX:
        psz = _T("WBEM_E_INVALID_SYNTAX");
        break;
    case WBEM_E_NONDECORATED_OBJECT:
        psz = _T("WBEM_E_NONDECORATED_OBJECT");
        break;
    case WBEM_E_READ_ONLY:
        psz = _T("WBEM_E_READ_ONLY");
        break;
    case WBEM_E_PROVIDER_NOT_CAPABLE:
        psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
        break;
    case WBEM_E_CLASS_HAS_CHILDREN:
        psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
        break;
    case WBEM_E_CLASS_HAS_INSTANCES:
        psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
        break;
    case WBEM_E_QUERY_NOT_IMPLEMENTED:
        psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
        break;
    case WBEM_E_ILLEGAL_NULL:
        psz = _T("WBEM_E_ILLEGAL_NULL");
        break;
    case WBEM_E_INVALID_QUALIFIER_TYPE:
        psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
        break;
    case WBEM_E_INVALID_PROPERTY_TYPE:
        psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
        break;
    case WBEM_E_VALUE_OUT_OF_RANGE:
        psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
        break;
    case WBEM_E_CANNOT_BE_SINGLETON:
        psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
        break;
	default:
        _itot(hRes, szBuffer2, 16);
        _tcscat(szBuffer, szBuffer2);
        psz = szBuffer;
	    break;
	}
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\cmdlineconsumer.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  CmdLineConsumer.cpp
//
// Description:
//	This file defines the class behaviors for the command-line
//	event consumer application.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "CmdLineConsumer.h"
#include "CmdLineConsumerDlg.h"
#include <objbase.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp

BEGIN_MESSAGE_MAP(CCmdLineConsumerApp, CWinApp)
	//{{AFX_MSG_MAP(CCmdLineConsumerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp construction

CCmdLineConsumerApp::CCmdLineConsumerApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	m_clsReg = 0;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCmdLineConsumerApp object

CCmdLineConsumerApp theApp;

// {31704FFF-6B85-11d1-ADAD-00AA00B8E05A}
static const GUID CLSID_CmdLineConsumer = 
{ 0x31704fff, 0x6b85, 0x11d1, { 0xad, 0xad, 0x0, 0xaa, 0x0, 0xb8, 0xe0, 0x5a } };

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp initialization

BOOL CCmdLineConsumerApp::InitInstance()
{
	HRESULT hRes;
	BOOL regEmpty = FALSE; // did a self-unregister happen?

	// OLE initialization. This is 'lighter' than OleInitialize()
	//  which also setups DnD, etc.
	if(SUCCEEDED(CoInitialize(NULL))) 
	{
		
		hRes = CoInitializeSecurity( NULL, -1, NULL, NULL, 
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE, 
											NULL, 
											EOAC_NONE, 
											NULL );
	}
	else // didnt CoInitialize()
	{
		AfxMessageBox(_T("CoInitialize Failed"));
		return FALSE;
	} // endif OleInitialize()

	// NOTE: To advertise that we can self-register, put 'OLESelfRegister'
	// in the version resource.

	// see if this is a self-Unregister call.
	TCHAR temp[128];
	TCHAR seps[] = _T(" ");
	TCHAR *token = NULL;

	_tcscpy(temp, (LPCTSTR)m_lpCmdLine);
	token = _tcstok( temp, seps );
	while( token != NULL )
	{
		/* While there are tokens in "string" */
		if(_tcscmp(token, _T("/UNREGSERVER")) == 0)
		{
			UnregisterServer();
			return FALSE;		// no use doing any more.
		}
		/* Get next token: */
		token = _tcstok( NULL, seps );
	}

	// if we got here, the unregister didn't return out and we should
	// make sure we're registered now.
	RegisterServer();

	// creating the dlg earlier than usual so the class factory 
	//	can pass m_outputList.
	CCmdLineConsumerDlg dlg;

	m_factory = new CProviderFactory(&(dlg.m_output));

	if((hRes = CoRegisterClassObject(CLSID_CmdLineConsumer,
							(IUnknown *)m_factory,
							CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
							REGCLS_MULTIPLEUSE,
							&m_clsReg)) == S_OK)
	{
		TRACE(_T("registered\n"));
	}
	else
	{
		TRACE(_T("not registered\n"));
	}

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

//-----------------------------------------------------------
int CCmdLineConsumerApp::ExitInstance()
{
	if(m_clsReg)
	{
		HRESULT hres = CoRevokeClassObject(m_clsReg);

		CoUninitialize();
	}

	return CWinApp::ExitInstance();
}

#define TCHAR_LEN_IN_BYTES(str)	 (unsigned long)(_tcslen(str)*sizeof(TCHAR)+sizeof(TCHAR))

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
// Note: Key setups are:
//		HKCR\CLSID\[guid]= friendly name
//		HKCR\CLSID\[guid]\LocalServer32 = exe's path.
//		HKCR\CLSID\AppID = [guid]
//		HKCR\AppID\[guid] = friendly name
//		HKCR\AppID\[guid] = 'RunAs' = "Interactive User"
//			'RunAs' is a value name; not a subkey.
//***************************************************************************
void CCmdLineConsumerApp::RegisterServer(void)
{   
	HKEY hKey1, hKey2;

	TCHAR       wcConsID[] = _T("{31704FFF-6B85-11d1-ADAD-00AA00B8E05A}");
    TCHAR       wcCLSID[] = _T("CLSID\\{31704FFF-6B85-11d1-ADAD-00AA00B8E05A}");
    TCHAR       wcAppID[] = _T("AppID\\{31704FFF-6B85-11d1-ADAD-00AA00B8E05A}");
    TCHAR      wcModule[128];	// this will hold the exe's path.
	TCHAR ConsumerTextForm[] = _T("Microsoft Cmd Line Consumer");

	// this will allow the server to display its windows on the active desktop instead
	// of the hidden desktop where services run.
	TCHAR Interactive[] = _T("Interactive User");


	GetModuleFileName(NULL, wcModule,  128);

	//Set the "default" text under CLSID
	//==========================
	RegCreateKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
					(LPBYTE)ConsumerTextForm, 
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// create the LocalServer32 key so the server can be found.
	RegCreateKey(hKey1, _T("LocalServer32"), &hKey2);
	RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)wcModule, TCHAR_LEN_IN_BYTES(wcModule));
	RegSetValueEx(hKey1, _T("AppID"), 0, REG_SZ, (LPBYTE)wcConsID, TCHAR_LEN_IN_BYTES(wcConsID));

	CloseHandle(hKey2);
	CloseHandle(hKey1);

	// now do the AppID keys.
	RegCreateKey(HKEY_CLASSES_ROOT, wcAppID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
					(LPBYTE)ConsumerTextForm, 
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// this makes the local server run on the active desktop (the one you're seeing) 
	// instead of the hidden desktop that services run on (which doesn't have UI)
	RegSetValueEx(hKey1, _T("RunAs"), 0, REG_SZ, (LPBYTE)Interactive, TCHAR_LEN_IN_BYTES(Interactive));
	CloseHandle(hKey1);
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
void CCmdLineConsumerApp::UnregisterServer(void)
{
 
	TCHAR       wcConsID[] = _T("{31704FFF-6B85-11d1-ADAD-00AA00B8E05A}");
    TCHAR       wcCLSID[] = _T("CLSID\\{31704FFF-6B85-11d1-ADAD-00AA00B8E05A}");
    TCHAR       wcAppID[] = _T("AppID\\{31704FFF-6B85-11d1-ADAD-00AA00B8E05A}");
    HKEY hKey1;
	DWORD dwRet;

	// delete the keys under CLSID\[guid]
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, _T("LocalServer32"));
        CloseHandle(hKey1);
    }

	// delete CLSID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1,wcConsID);
        CloseHandle(hKey1);
    }

	// delete AppID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("AppID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, wcConsID);
        CloseHandle(hKey1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\cmdlineconsumerdlg.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  CmdLineConsumerDlg.cpp
//
// Description:
//			Implementation file for command-line event consumer dialog boxes
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "CmdLineConsumer.h"
#include "CmdLineConsumerDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerDlg dialog

CCmdLineConsumerDlg::CCmdLineConsumerDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCmdLineConsumerDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCmdLineConsumerDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CCmdLineConsumerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCmdLineConsumerDlg)
	DDX_Control(pDX, IDC_LIST, m_output);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCmdLineConsumerDlg, CDialog)
	//{{AFX_MSG_MAP(CCmdLineConsumerDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerDlg message handlers

BOOL CCmdLineConsumerDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// this controls the app's main dialog box.
	ShowWindow(SW_MINIMIZE);

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CCmdLineConsumerDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CCmdLineConsumerDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CCmdLineConsumerDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\factory.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  factory.h
//
// Description:
//			Definition for command-line event consumer provider class factory
//
// History:
//
// **************************************************************************

#include <wbemcli.h>

class CProviderFactory : public IClassFactory
{
public:

	CProviderFactory(CListBox	*pOutputList);
	virtual ~CProviderFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD_(SCODE, CreateInstance)(IUnknown * pUnkOuter, 
									REFIID riid, 
									void ** ppvObject);

    STDMETHOD_(SCODE, LockServer)(BOOL fLock);

private:
	LONG m_cRef;
	CListBox	*m_pOutputList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\consumer.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Consumer.h
//
// Description:
//			Command-line event consumer class definition
//
// History:
//
// **************************************************************************

#include <wbemcli.h>
#include <wbemprov.h>

class CConsumer : public IWbemUnboundObjectSink
{
public:
	CConsumer(CListBox	*pOutputList);
	~CConsumer();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// This routine ultimately receives the event.
    STDMETHOD(IndicateToConsumer)(IWbemClassObject *pLogicalConsumer,
									long lNumObjects,
									IWbemClassObject **ppObjects);

private:

	DWORD m_cRef;
	LPCTSTR ErrorString(HRESULT hRes);
	CListBox	*m_pOutputList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\factory.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  factory.cpp
//
//	Description :
//			Class factory implementation for the command-line event
//			consumer provider
//
//  History:	
//
//***************************************************************************

#include "stdafx.h"
#include "factory.h"
#include "Provider.h"

CProviderFactory::CProviderFactory(CListBox	*pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CProviderFactory::~CProviderFactory()
{
}

//IUnknown methods
STDMETHODIMP CProviderFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CProviderFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CProviderFactory::Release(void)
{
    int lNewRef = InterlockedDecrement(&m_cRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CProviderFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;
    CProvider *pProvider = NULL;

    if (pUnkOuter)
        return E_FAIL;

	// create the provider.
    pProvider = new CProvider(m_pOutputList);

    if (pProvider == NULL)
	{
		return E_FAIL;
	}

	// get the interface asked for.
    if (pProvider)
    {
        hr = pProvider->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::LockServer
//
//  Synopsis:
//
//  Arguments:  [fLock]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProviderFactory::LockServer(BOOL fLock)
{
    if (fLock)
        m_cRef++;
    else
        m_cRef--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\provider.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Provider.h
//
// Description:
//			Definition of command-line event consumer provider class
//
// History:
//
// **************************************************************************

#include <wbemcli.h>
#include <wbemprov.h>

class CProvider : public IWbemEventConsumerProvider
{
public:
	CProvider(CListBox	*pOutputList);
	~CProvider();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// This routine allows you to map the 1 physical consumer
	// to potentially multiple logical consumers.
    STDMETHOD(FindConsumer)(
				IWbemClassObject* pLogicalConsumer,
				IWbemUnboundObjectSink** ppConsumer);

private:

	DWORD m_cRef;
	CListBox	*m_pOutputList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\provider.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Provider.cpp
//
// Description:
//			Implementation for the command-line event consumer provider class
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Provider.h"
#include "Consumer.h"
#include <objbase.h>

CProvider::CProvider(CListBox *pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CProvider::~CProvider()
{
}

STDMETHODIMP CProvider::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemEventConsumerProvider)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvider::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvider::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

//-----------------------------------------------------------
STDMETHODIMP CProvider::FindConsumer(
						IWbemClassObject* pLogicalConsumer,
						IWbemUnboundObjectSink** ppConsumer)
{
	// create the logical consumer.
	CConsumer* pSink = new CConsumer(m_pOutputList);
    
	// return it's "sink" interface.
	return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	CmdLineConsumer.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CmdLineConsumer.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CMDLINECONSUMER_DIALOG      102
#define IDR_MAINFRAME                   128
#define IDC_LIST                        1000
#define IDC_CUSTOM1                     1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EF85AEBB_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
#define AFX_STDAFX_H__EF85AEBB_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__EF85AEBB_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\bar.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  bar.cpp
//
// Description:
//	This file implements an a single bar in the barchart used to display
//	the amount of "used" and "free" disk space.  
//
//	This file does not contain any WMI specific information and is not
//  very interesting if you are trying to understand how to write a custom
//  view.  Most of the interesting stuff is in Win32LogicalDiskCtl.cpp and 
//  DiskView.cpp.   
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "bar.h"


CBar::CBar()
{
	m_iMax = 0;
	m_iValue = 0;
	m_rcBar.SetRectEmpty();
	m_colorFg = RGB(0, 0, 0);
	m_colorBg = RGB(0, 0, 0);
	m_colorLabel = RGB(0, 0, 0);
	m_colorFrame = RGB(0, 0, 0);
}

CBar::~CBar()
{
}

// Set the foregound, background, and frame colors for this bar in the barchart.
void CBar::SetColor(COLORREF colorFg, COLORREF colorBg, COLORREF colorFrame)
{
	m_colorFg = colorFg;
	m_colorBg = colorBg;
	m_colorFrame = colorFrame;
}


// Draw this bar in the barchart.
void CBar::Draw(CDC* pdc)
{
	__int64 iPercentFull;
	if (m_iMax != 0) {
		iPercentFull = (m_iValue * (__int64)100) / m_iMax;
	}
	else {
		iPercentFull = 0;
	}
	
	CRect rcValue;
	rcValue.top = (long) (m_rcBar.bottom - (((__int64)m_rcBar.Height()) * iPercentFull) / (__int64) 100);
	rcValue.bottom = m_rcBar.bottom;
	rcValue.left = m_rcBar.left;
	rcValue.right = m_rcBar.right;

	CBrush brFg(m_colorFg);
	CBrush brBg(m_colorBg);
	CBrush brFrame(m_colorFrame);


	pdc->FillRect(m_rcBar, &brBg);
	pdc->FillRect(rcValue, &brFg);
	pdc->FrameRect(m_rcBar, &brFrame);


	UINT ta = pdc->SetTextAlign(TA_CENTER);
	COLORREF colorBg = m_colorLabelBg;
	COLORREF colorBgSave = pdc->SetBkColor( m_colorLabelBg );
	COLORREF colorTextSave = pdc->SetTextColor(m_colorLabel);
	pdc->ExtTextOut((m_rcLabel.left + m_rcLabel.right) / 2, 
					m_rcLabel.top, 
					ETO_CLIPPED, 
					&m_rcLabel, 
					m_sLabel,
					m_sLabel.GetLength(),
					NULL);
	pdc->SetTextColor(colorTextSave);
	pdc->SetBkColor(colorBgSave);
	pdc->SetTextAlign(ta);



}


// Set the maximum and the current value of this bar in the barchart.
void CBar::SetValue(__int64 iMax, __int64 iValue)
{
	m_iMax = iMax;
	m_iValue = iValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\bar.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  bar.h
//
// Description:
//	This file declares the class used to represent a single bar in 
//  a barchart.     
//
//	This file does not contain any WMI specific information and is not
//  very interesting if you are trying to understand how to write a custom
//  view.  Most of the interesting stuff is in Win32LogicalDiskCtl.cpp and 
//  DiskView.cpp.
//
// History:
//
// **************************************************************************


#ifndef _bar_h
#define _bar_h

class CBar
{
public:
	CBar();
	~CBar();
	void SetLabel(LPCTSTR pszLabel) {m_sLabel = pszLabel; }
	LPCTSTR GetLabel() {return m_sLabel; }
	void SetLabelColor(COLORREF colorLabel, COLORREF colorLabelBg) {m_colorLabel = colorLabel; m_colorLabelBg = colorLabelBg; }
	void SetColor(COLORREF colorFg, COLORREF colorBg, COLORREF colorFrame);
	void SetValue(__int64 iMax, __int64 iValue);
	void SetBarRect(CRect& rcBar) {m_rcBar = rcBar; }
	void SetLabelRect(CRect& rcLabel) {m_rcLabel = rcLabel; }
	void Draw(CDC* pdc);

private:
	CRect m_rcBar;
	CRect m_rcLabel;
	__int64 m_iMax;
	__int64 m_iValue;
	COLORREF m_colorFrame;
	COLORREF m_colorBg;
	COLORREF m_colorFg;
	COLORREF m_colorLabel;
	COLORREF m_colorLabelBg;
	CString m_sLabel;

};


#endif //_bar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\coloredit.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  ColorEdit.cpp
//
// Description:
//	This file implements an edit box that allows you to specify the 
//	background color.  This is useful when placing an edit box on top
//	of non-white backgrounds.
//
//
//	This file does not contain any WMI specific information and is not
//  very interesting if you are trying to understand how to write a custom
//  view.
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "ColorEdit.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColorEdit

CColorEdit::CColorEdit()
{
}

CColorEdit::~CColorEdit()
{
}

void CColorEdit::SetColor(COLORREF colorBg, COLORREF colorText)
{
	m_colorText = colorText;
	m_colorBg = colorBg;
	m_brBackground.CreateSolidBrush(colorBg);
}

BEGIN_MESSAGE_MAP(CColorEdit, CEdit)
	//{{AFX_MSG_MAP(CColorEdit)
	ON_WM_CTLCOLOR_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CColorEdit message handlers

HBRUSH CColorEdit::CtlColor(CDC* pDC, UINT nCtlColor) 
{
	pDC->SetTextColor(m_colorText);
	pDC->SetBkColor(m_colorBg);
	pDC->SetBkMode(OPAQUE);
	return m_brBackground;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\barchart.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  BarChart.cpp
//
// Description:
//	This file implements the CBarChart class.  This class is used by CDiskView
//  to display the amount of "free" and "used" disk space.
//
//	This file does not contain any WMI specific information and is not
//  very interesting if you are trying to understand how to write a custom
//  view.  Most of the interesting stuff is in Win32LogicalDiskCtl.cpp and 
//  DiskView.cpp.
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "BarChart.h"
#include "bar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CX_MARGIN 8
#define CY_MARGIN 16

#define CY_LABEL_MARGIN 4
#define CY_LABEL_LEADING 8

/////////////////////////////////////////////////////////////////////////////
// CBarChart

CBarChart::CBarChart()
{
	m_colorFrame = RGB(0, 0, 0);
	m_colorBg = RGB(0x0ff, 0x0ff, 0x0ff);
	m_bHasFrame = FALSE;

}

CBarChart::~CBarChart()
{
}

// Set the number of bars in the barchart.
void CBarChart::SetBarCount(int nBars, BOOL bRedraw)
{
	int iBar;

	// First remove all the bars that currently exist
	int nBarsDelete = m_aBars.GetSize();
	for (iBar=0; iBar<nBarsDelete; ++iBar) {
		CBar* pbar = (CBar*) m_aBars[iBar];
		delete pbar;
	}
	m_aBars.RemoveAll();
	
	// Now add in correct number of bars.
	for (iBar=0; iBar<nBars; ++iBar) {
		CBar* pbar = new CBar;
		m_aBars.SetAtGrow(iBar, pbar);
	}

	// Layout the barchart and redraw it.
	LayoutChart();
	if (bRedraw && ::IsWindow(m_hWnd)) {
		RedrawWindow();
	}

}

BEGIN_MESSAGE_MAP(CBarChart, CWnd)
	//{{AFX_MSG_MAP(CBarChart)
	ON_WM_PAINT()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBarChart message handlers

// Draw the barchart.
void CBarChart::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

	// Fill the backgound with the background color.
	CBrush brBg(m_colorBg);
	dc.FillRect(&dc.m_ps.rcPaint, &brBg);

	// Draw each of the bars.
	const int nBars = m_aBars.GetSize();
	for (int iBar=0; iBar<nBars; ++iBar) {
		CBar* pbar = (CBar*) m_aBars[iBar];
		pbar->Draw(&dc);
	}
	
	// Draw the frame around the bar.
	CRect rcClient;
	GetClientRect(rcClient);
	if (m_bHasFrame) {
		CBrush brFrame(m_colorFrame);
		dc.FrameRect(&rcClient, &brFrame);
	}

	// Do not call CWnd::OnPaint() for painting messages
}




// Layout the bar chart by setting the rectangles for each bar and label.
void CBarChart::LayoutChart()
{
	if (!::IsWindow(m_hWnd)) {
		return;
	}

	const int nBars = m_aBars.GetSize();
	if (nBars == 0) {
		return;
	}

	CRect rcClient;
	GetClientRect(rcClient);

	int cxClient = rcClient.Width();
	cxClient -= 2 * CX_MARGIN;

	// Compute the spacing between bars and the width of each bar 
	// by dividing the total with by the number of bars and adjusting for margins
	const int cxDelta = (cxClient - 2 * CX_MARGIN) / nBars;  
	const int cxBar = (cxDelta  * 2) / 3;

	// Compute the offset so that the blank space to the left of the first bar
	// and to the right of the last bar is evenly distributed.
	CRect rcBar;
	const int cyLabel = 12;
	int cxOffset = (cxDelta - cxBar) / 2;

	rcBar.top = rcClient.top + CY_MARGIN;
	rcBar.bottom = rcClient.bottom - CY_MARGIN - (cyLabel + CY_LABEL_MARGIN + CY_LABEL_LEADING);
	rcBar.left = rcClient.left + CX_MARGIN + cxOffset;
	rcBar.right = rcBar.left + cxBar;

	CRect rcLabel = rcBar;
	rcLabel.left -= CX_MARGIN / 3;
	rcLabel.right += CX_MARGIN /3;
	rcLabel.top = rcBar.bottom + CY_LABEL_LEADING;
	rcLabel.bottom = rcClient.bottom - CY_LABEL_MARGIN;


	// Position each bar and label.
	for (int iBar=0; iBar<nBars; ++iBar) {
		CBar* pbar = (CBar*) m_aBars[iBar];
		pbar->SetBarRect(rcBar);
		pbar->SetLabelRect(rcLabel);
		rcBar.left += cxDelta;
		rcBar.right += cxDelta;
		rcLabel.left += cxDelta;
		rcLabel.right += cxDelta;
	}

}




void CBarChart::SetLabelColor(int iBar, COLORREF colorLabel, COLORREF colorLabelBg)
{
	CBar* pbar = (CBar*) m_aBars[iBar];
	pbar->SetLabelColor(colorLabel, colorLabelBg);
}

void CBarChart::SetLabel(int iBar, LPCTSTR pszLabel)
{
	CBar* pbar = (CBar*) m_aBars[iBar];
	pbar->SetLabel(pszLabel);
}	
	

void CBarChart::SetBarColor(int iBar, COLORREF colorFg, COLORREF colorBg)
{
	CBar* pbar = (CBar*) m_aBars[iBar];
	
	COLORREF colorFrame = RGB(0, 0, 0);
	pbar->SetColor(colorFg, colorBg, colorFrame);
}


void CBarChart::SetValue(int iBar, __int64 iMax, __int64 iValue)
{
	CBar* pbar = (CBar*) m_aBars[iBar];
	pbar->SetValue(iMax, iValue);
}


void CBarChart::SetBgColor(COLORREF colorBg, BOOL bRedraw)
{
	m_colorBg = colorBg;
	if (bRedraw && ::IsWindow(m_hWnd)) {
		RedrawWindow();
	}
}

void CBarChart::SetFrameColor(COLORREF colorFrame, BOOL bRedraw)
{
	m_colorFrame = colorFrame;
	if (bRedraw && ::IsWindow(m_hWnd)) {
		RedrawWindow();
	}
}


void CBarChart::SetStyle(BOOL bHasFrame, BOOL bRedraw)
{
	m_bHasFrame = bHasFrame;
	if (bRedraw && ::IsWindow(m_hWnd)) {
		RedrawWindow();
	}
}


void CBarChart::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	LayoutChart();
	RedrawWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\diskview.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  DiskView.cpp
//
// Description:
//	This file implements the CDiskView class.  This class gets several properties
//  from a Win32_LogicalDisk instance and displays them.  
//
//  A barchart of the free and used disk space is shown on the left and an 
//  edit box on the right displays several other properties such as the object
//  path, filesystem type, etc.
//
//
// History:
//
// **************************************************************************


#include "stdafx.h"
#include <wbemidl.h>
#include "diskview.h"
#include "barchart.h"
#include "coloredit.h"



// Colors for various things in the display.
#define COLOR_SPACE_USED RGB(255, 0, 0)		// Used disk space.
#define COLOR_SPACE_AVAILABLE RGB(64, 255, 0)	// Available disk space
#define COLOR_BG RGB(0, 96, 129)				// Background color
#define COLOR_TEXT RGB(255, 128, 128)
#define COLOR_TEXT_BOX RGB(255, 255, 128)
#define COLOR_BLACK RGB(0, 0, 0)
#define COLOR_WHITE RGB(255, 255, 255)
#define COLOR_WARNING_TEXT RGB(96, 96, 255)

// Definitions for laying out the view.
#define CX_BAR  32
#define CX_BAR_SPACING 50
#define CX_LEFT_MARGIN 50
#define CX_RIGHT_MARGIN 50
#define CY_TOP_MARGIN 50
#define CY_BOTTOM_MARGIN 50
#define CY_LEADING 5
#define CX_CHART_MARGIN 16
#define CY_CHART_MARGIN 16

CDiskView::CDiskView()
{
	m_pedit = new CColorEdit;
	m_pedit->SetColor(COLOR_BG, COLOR_TEXT);
	m_pchart = new CBarChart;
	m_pchart->SetBarCount(1);
	m_pchart->SetBgColor(COLOR_BG);
	m_pchart->SetBarColor(0, COLOR_SPACE_USED, COLOR_SPACE_AVAILABLE);
	m_pchart->SetLabelColor(0, COLOR_WHITE, COLOR_BG);
	m_bEditNeedsRefresh = FALSE;
	m_bNeedsInitialLayout = TRUE;
}

CDiskView::~CDiskView()
{
	delete m_pedit;
	delete m_pchart;
}


BEGIN_MESSAGE_MAP(CDiskView, CWnd)
	//{{AFX_MSG_MAP(CDiskView)
	ON_WM_SIZE()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDiskView message handlers





BOOL CDiskView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{	
	BOOL bDidCreate = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if (!bDidCreate) {
		return bDidCreate;
	}


	CRect rcEmpty;
	rcEmpty.SetRectEmpty();

	bDidCreate = m_pchart->Create(NULL, "CBarChart", WS_CHILD | WS_VISIBLE, rcEmpty, this, 100, NULL);
	if (!bDidCreate) {
		return FALSE;
	}

	bDidCreate = m_pedit->Create(WS_CHILD | WS_VISIBLE | ES_MULTILINE, rcEmpty, this, 101);
	if (!bDidCreate) {
		return FALSE;
	}

	LayoutChildren();
	return TRUE;
}



//******************************************************************
// CDiskView::SetObject
//
// This method is called to select a new instance of the CIMOM Win32_LogicalDisk
// class into this view. 
//
// This method gets several properties from the object instance including
// the size, freespace, and so on.
//
// Parameters:
//		[in] LPCTSTR pszObjectPath
//			The CIMOM object path used used to load the object instance
//			"pco" from CIMOM.
//
//		[in] IWbemClassObject* pco
//			A pointer to a CIMOM Win32_LogicalDisk class object.
//
// Returns:
//		Nothing.
//
//**************************************************************************
void CDiskView::SetObject(LPCTSTR pszObjectPath, IWbemClassObject* pco)
{
	// Clear the current values of the properties that we will load from
	// from the class object.
	m_sDescription.Empty();
	m_sFileSystem.Empty();
	m_sProviderName.Empty();
	m_sDeviceID.Empty();
	m_uiFreeSpace = 0;
	m_uiSize = 0;
	m_bEditNeedsRefresh = TRUE;


	// Store the object path so that we can display it later.
	m_sObjectPath = pszObjectPath;


	// Load each of the properties that we're interested in from the "pco" class object.
	//
	// The parameters that I chose to load are rather arbitrary.  I just chose
	// a few to demonstrate that this custom view works with live data from CIMOM.
	//
	if (pco != NULL) {
		long lFlags  = 0;
		long lFlavor = 0;
		CIMTYPE cimtype;
		COleVariant varPropValue;
		COleVariant varPropName;
		CString sValue;

		
		// Get Property: Size
		SCODE sc;
		varPropName = "Size";
		sc =  pco->Get(varPropName.bstrVal, lFlags, &varPropValue, &cimtype, &lFlavor);
		if (FAILED(sc)) {
			ReportFailedToGetProperty(varPropName.bstrVal, sc);
			return;
		}

		if (cimtype==CIM_UINT64 && varPropValue.vt==VT_BSTR) {
			sValue = varPropValue.bstrVal;
			m_uiSize = _atoi64(sValue);
		}

		
		// Get Property:FreeSpace
		lFlags = 0;
		lFlavor = 0;
		varPropValue.Clear();
		varPropName = "FreeSpace";
		sc =  pco->Get(varPropName.bstrVal, lFlags, &varPropValue, &cimtype, &lFlavor);
		if (FAILED(sc)) {
			ReportFailedToGetProperty(varPropName.bstrVal, sc);
			return;
		}

		if (cimtype==CIM_UINT64 && varPropValue.vt==VT_BSTR) {
			sValue = varPropValue.bstrVal;
			m_uiFreeSpace = _atoi64(sValue);
		}


		// Get Property: Description
		lFlags = 0;
		lFlavor = 0;
		varPropValue.Clear();
		varPropName = "Description";
		sc =  pco->Get(varPropName.bstrVal, lFlags, &varPropValue, &cimtype, &lFlavor);
		if (FAILED(sc)) {
			ReportFailedToGetProperty(varPropName.bstrVal, sc);
			return;
		}

		if (cimtype==CIM_STRING && varPropValue.vt==VT_BSTR) {
			m_sDescription = varPropValue.bstrVal;
		}



		// Get Property: FileSystem
		lFlags = 0;
		lFlavor = 0;
		varPropValue.Clear();
		varPropName = "FileSystem";
		sc =  pco->Get(varPropName.bstrVal, lFlags, &varPropValue, &cimtype, &lFlavor);
		if (FAILED(sc)) {
			ReportFailedToGetProperty(varPropName.bstrVal, sc);
			return;
		}

		if (cimtype==CIM_STRING && varPropValue.vt==VT_BSTR) {
			m_sFileSystem = varPropValue.bstrVal;
		}


		// Get Property: DeviceID
		lFlags = 0;
		lFlavor = 0;
		varPropValue.Clear();
		varPropName = "DeviceID";
		sc =  pco->Get(varPropName.bstrVal, lFlags, &varPropValue, &cimtype, &lFlavor);
		if (FAILED(sc)) {
			ReportFailedToGetProperty(varPropName.bstrVal, sc);
			return;
		}

		if (cimtype==CIM_STRING && varPropValue.vt==VT_BSTR) {
			m_sDeviceID = varPropValue.bstrVal;
		}

		
		// Get Property: ProviderName
		lFlags = 0;
		lFlavor = 0;
		varPropValue.Clear();
		varPropName = "ProviderName";
		sc =  pco->Get(varPropName.bstrVal, lFlags, &varPropValue, &cimtype, &lFlavor);
		if (FAILED(sc)) {
			ReportFailedToGetProperty(varPropName.bstrVal, sc);
			return;
		}

		if (cimtype==CIM_STRING && varPropValue.vt==VT_BSTR) {
			m_sProviderName = varPropValue.bstrVal;
		}
	
	}

	// Set the value of the only bar in the barchart to represent
	// the total size and the amount of freespace on the disk.  
	m_pchart->SetValue(0, m_uiSize, m_uiSize - m_uiFreeSpace);
	m_pchart->SetLabel(0, m_sDeviceID);
}

// This method is called when an attempt to get a property value fails.
void CDiskView::ReportFailedToGetProperty(BSTR bstrPropName, SCODE sc)
{
	CString sPropName;
	sPropName = bstrPropName;

	char szMessage[256];
	sprintf(szMessage, "Failed to get property \"%s\". SC = 0x%08lx", sPropName, sc);
	::MessageBox(NULL, szMessage, "Property Get Error", MB_OK);
}



// Layout the positions of the child windows and move the children to
// their new positions.
void CDiskView::LayoutChildren()
{
	if (!::IsWindow(m_pchart->m_hWnd) || !::IsWindow(m_pedit->m_hWnd))  {
		return;
	}

	m_bNeedsInitialLayout = FALSE;
	CRect rcClient;
	GetClientRect(rcClient);


	// The barchart goes on the left and consumes one third of the total width less 
	// the margin width.
	int cxChart = rcClient.Width() / 3 - 2 * CX_CHART_MARGIN;
	int cyChart = rcClient.Height() - 2 * CY_CHART_MARGIN;

	if (cxChart < 0 || cyChart < 0) {
		m_rcChart.SetRectEmpty();
	}
	else {
		m_rcChart.left = rcClient.left + CX_CHART_MARGIN;
		m_rcChart.top = rcClient.top + CY_CHART_MARGIN;
		m_rcChart.right = m_rcChart.left + cxChart;
		m_rcChart.bottom = m_rcChart.top + cyChart;
	}
	m_pchart->MoveWindow(m_rcChart);


	// The edit box goes just inside of the legend box inset by a 5 unit
	// margin.
	CRect rcLegend;
	GetLegendRect(rcLegend);

	CRect rcEdit;
	rcEdit.left = rcLegend.left + 5;
	rcEdit.right = rcLegend.right - 5;
	rcEdit.top = rcLegend.top + 5;
	rcEdit.bottom = rcLegend.bottom - 5;

	m_pedit->MoveWindow(rcEdit);
	m_pedit->RedrawWindow();

}



// Get rectangle that is used to help place the chart legend and the edit box.
void CDiskView::GetLegendRect(CRect& rcLegend)
{
	CRect rcClient;
	GetClientRect(rcClient);

	rcLegend.left = CX_LEFT_MARGIN + 2 * CX_BAR + 2 * CX_BAR_SPACING;
	rcLegend.right = rcClient.right - CX_RIGHT_MARGIN;
	rcLegend.top = rcClient.top + CY_TOP_MARGIN;
	rcLegend.bottom = rcClient.bottom - CY_BOTTOM_MARGIN;
}



void CDiskView::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	if (m_bNeedsInitialLayout) {
		LayoutChildren();
	}

	// Fill the backgound with the backgound color.
	CBrush brBackground(COLOR_BG);
	dc.FillRect(&dc.m_ps.rcPaint, &brBackground);

	// Draw the chart legend.
	DrawLegend(&dc);

	// The edit control is a child window, so it will redraw itself, but
	// first we want to load it with the values of several properties that
	// we got earlier in CDiskView::SetObject.  
	if (m_bEditNeedsRefresh && ::IsWindow(m_pedit->m_hWnd)) {
		m_bEditNeedsRefresh = FALSE;
		CString sEditText;
		char szBuffer[1024];
		sprintf(szBuffer, "ObjectPath = %s\r\n\r\n", m_sObjectPath);
		sEditText += szBuffer;

		sprintf(szBuffer, "Description = %s\r\n\r\n", m_sDescription);
		sEditText += szBuffer;

		sprintf(szBuffer, "FileSystem = %s\r\n\r\n", m_sFileSystem);
		sEditText += szBuffer;

		if (!m_sProviderName.IsEmpty()) {
			sprintf(szBuffer, "ProviderName = %s\r\n\r\n", m_sProviderName);
			sEditText += szBuffer;
		}

		m_pedit->SetWindowText(sEditText);
	}


	// The barchart is a child window, so it will redraw itself.

	// Do not call CWnd::OnPaint() for painting messages
}



// Draw the chart legend so that the user can tell what color
// means full and what color means empty.
void CDiskView::DrawLegend(CDC* pdc)
{
	if (m_bNeedsInitialLayout) {
		LayoutChildren();
	}

	CRect rcLegend;
	GetLegendRect(rcLegend);

	if (m_pedit->m_hWnd) {
		CRect rcEdit;
		rcEdit.left = rcLegend.left + 5;
		rcEdit.right = rcLegend.right - 5;
		rcEdit.top = rcLegend.top + 5;
		rcEdit.bottom = rcLegend.bottom - 5;

		m_pedit->MoveWindow(rcEdit);
		m_pedit->RedrawWindow();
	}


	CBrush brWhite(COLOR_WHITE);
	pdc->FrameRect(rcLegend, &brWhite);


	pdc->SetTextColor(COLOR_WHITE);		// text foreground = black
	pdc->SetBkColor(COLOR_BG);	// text bkgnd = yellow



	CRect rcFull;
	rcFull.left = rcLegend.left;
	rcFull.top = rcLegend.bottom + 10;
	rcFull.right = rcFull.left + 10;
	rcFull.bottom = rcFull.top + 10;

	CBrush brFull(COLOR_SPACE_USED);
	pdc->FillRect(rcFull, &brFull);


	CSize sizeText;
	CString sText;
	sText = "Used";
	sizeText = pdc->GetTextExtent(sText);
	pdc->TextOut(rcFull.right + 10, rcFull.top, sText);


	CRect rcAvailable = rcFull;
	rcAvailable.OffsetRect(rcFull.Width() + sizeText.cx + 20, 0);

	CBrush brAvailable(COLOR_SPACE_AVAILABLE);
	pdc->FillRect(rcAvailable, &brAvailable);

	sText = "Available";
	sizeText = pdc->GetTextExtent(sText);
	pdc->TextOut(rcAvailable.right + 10, rcAvailable.top, sText);	
}


void CDiskView::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	LayoutChildren();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\coloredit.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  ColorEdit.h
//
// Description:
//	This file declares the CColorEdit class.  This class implements a
//	an edit box with a colored background.
//
//	This file does not contain any WMI specific information and is not
//  very interesting if you are trying to understand how to write a custom
//  view.  Most of the interesting stuff is in Win32LogicalDiskCtl.cpp and 
//  DiskView.cpp.
//
// History:
//
// **************************************************************************

#ifndef _ColorEdit_h
#define _ColorEdit_h

// ColorEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CColorEdit window

class CColorEdit : public CEdit
{
// Construction
public:
	CColorEdit();

	void SetColor(COLORREF colorBg, COLORREF colorText);
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CColorEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CColorEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CColorEdit)
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
private:
	CBrush m_brBackground;
	COLORREF m_colorText;
	COLORREF m_colorBg;
};

/////////////////////////////////////////////////////////////////////////////

#endif _ColorEdit_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\barchart.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  BarChart.h
//
// Description:
//	This file declares the CBarChart class.  This class is used by CDiskView
//  to display the amount of "free" and "used" disk space.
//
//	This file does not contain any WMI specific information and is not
//  very interesting if you are trying to understand how to write a custom
//  view.  Most of the interesting stuff is in Win32LogicalDiskCtl.cpp and 
//  DiskView.cpp.
//
// History:
//
// **************************************************************************

#if !defined(AFX_BARCHART_H__7BCA0D43_FCA4_11D1_853C_00C04FD7BB08__INCLUDED_)
#define AFX_BARCHART_H__7BCA0D43_FCA4_11D1_853C_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// BarChart.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// BarChart window

class CBarChart : public CWnd
{
// Construction
public:
	CBarChart();
	void SetBarCount(int nBars, BOOL bRedraw=TRUE);
	int GetBarCount() {return m_aBars.GetSize(); }
	void SetFrameColor(COLORREF colorFrame, BOOL bRedraw);
	void SetBgColor(COLORREF colorBg, BOOL bRedraw=TRUE);
	void SetValue(int iBar, __int64 iMax, __int64 iValue);
	void SetBarColor(int iBar, COLORREF colorFg, COLORREF colorBg);
	void SetLabelColor(int iBar, COLORREF colorLabel, COLORREF colorLabelBg);
	void SetLabel(int iBar, LPCTSTR pszLabel);
	void SetStyle(BOOL bHasFrame, BOOL bRedraw=TRUE);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBarChart)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBarChart();
	void LayoutChart();

	// Generated message map functions
protected:
	//{{AFX_MSG(CBarChart)
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CPtrArray m_aBars;
	COLORREF m_colorBg;
	COLORREF m_colorFrame;
	BOOL m_bHasFrame;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BARCHART_H__7BCA0D43_FCA4_11D1_853C_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\diskview.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  DiskView.h
//
// Description:
//	This file declares the CDiskView class.  This class gets several properties
//  from a Win32_LogicalDisk instance and displays them.  
//
//  A barchart of the free and used disk space is shown on the left and an 
//  edit box on the right displays several other properties such as the object
//  path, filesystem type, etc.
//
//
// History:
//
// **************************************************************************


#ifndef _diskview_h
#define _diskview_h

/////////////////////////////////////////////////////////////////////////////
// CDiskView window

class CBarChart;
class CColorEdit;
class CDiskView : public CWnd
{
// Construction
public:
	CDiskView();

// Attributes
public:

// Operations
public:
	void SetObject(LPCTSTR pszObjectPath, IWbemClassObject* pco);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDiskView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDiskView();

	// Generated message map functions
protected:
	//{{AFX_MSG(CDiskView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void LayoutChildren();
	void DrawLegend(CDC* pdc);
	void GetLegendRect(CRect& rcLegend);
	void ReportFailedToGetProperty(BSTR bstrPropName, SCODE sc);

	CBarChart* m_pchart;
	CRect m_rcChart;
	CColorEdit* m_pedit;
	BOOL m_bEditNeedsRefresh;
	BOOL m_bHideBarchart;
	BOOL m_bNeedsInitialLayout;

	CString m_sObjectPath;

	// The values of properties retrieved from the WIN32_LogicalDisk instance
	CString m_sDescription;
	CString m_sFileSystem;
	CString m_sDeviceID;
	CString m_sProviderName;
	unsigned __int64 m_uiFreeSpace;
	unsigned __int64 m_uiSize;
};

/////////////////////////////////////////////////////////////////////////////

#endif // _diskview_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Win32LogicalDisk.rc
//

#define IDS_WIN32LOGICALDISK               1
#define IDS_WIN32LOGICALDISK_PPG           2

#define IDS_WIN32LOGICALDISK_PPG_CAPTION   200

#define IDD_PROPPAGE_WIN32LOGICALDISK      200

#define IDD_ABOUTBOX_WIN32LOGICALDISK      1

#define IDB_WIN32LOGICALDISK               1

#define IDI_ABOUTDLL				1

#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#define _APS_NEXT_COMMAND_VALUE         32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\win32logicaldisk.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Win32LogicalDisk.h
//
// Description:
//
// History:
//
// **************************************************************************

#if !defined(AFX_WIN32LOGICALDISK_H__D5FF188C_0191_11D2_853D_00C04FD7BB08__INCLUDED_)
#define AFX_WIN32LOGICALDISK_H__D5FF188C_0191_11D2_853D_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Win32LogicalDisk.h : main header file for WIN32LOGICALDISK.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskApp : See Win32LogicalDisk.cpp for implementation.

class CWin32LogicalDiskApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIN32LOGICALDISK_H__D5FF188C_0191_11D2_853D_00C04FD7BB08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\win32logicaldisk.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Win32LogicalDisk.cpp 
//
// Description:
//    Implementation of CWin32LogicalDiskApp and DLL registration.
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Win32LogicalDisk.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CWin32LogicalDiskApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xd5ff1882, 0x191, 0x11d2, { 0x85, 0x3d, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskApp::InitInstance - DLL initialization

BOOL CWin32LogicalDiskApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskApp::ExitInstance - DLL termination

int CWin32LogicalDiskApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return SELFREG_E_TYPELIB;

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return SELFREG_E_CLASS;

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return SELFREG_E_TYPELIB;

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return SELFREG_E_CLASS;

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__D5FF188A_0191_11D2_853D_00C04FD7BB08__INCLUDED_)
#define AFX_STDAFX_H__D5FF188A_0191_11D2_853D_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D5FF188A_0191_11D2_853D_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\win32logicaldiskctl.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Win32LogicalDiskCtl.h
//
// Description:
//
// History:
//
// **************************************************************************

#if !defined(AFX_WIN32LOGICALDISKCTL_H__D5FF1894_0191_11D2_853D_00C04FD7BB08__INCLUDED_)
#define AFX_WIN32LOGICALDISKCTL_H__D5FF1894_0191_11D2_853D_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Win32LogicalDiskCtl.h : Declaration of the CWin32LogicalDiskCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl : See Win32LogicalDiskCtl.cpp for implementation.

class CDiskView;

class CWin32LogicalDiskCtrl : public COleControl
{
	DECLARE_DYNCREATE(CWin32LogicalDiskCtrl)

// Constructor
public:
	CWin32LogicalDiskCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWin32LogicalDiskCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CWin32LogicalDiskCtrl();

	DECLARE_OLECREATE_EX(CWin32LogicalDiskCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CWin32LogicalDiskCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CWin32LogicalDiskCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CWin32LogicalDiskCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CWin32LogicalDiskCtrl)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CWin32LogicalDiskCtrl)
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg long QueryNeedsSave();
	afx_msg long AddContextRef(long lCtxtHandle);
	afx_msg long GetContext(long FAR* plCtxthandle);
	afx_msg long GetEditMode();
	afx_msg void ExternInstanceCreated(LPCTSTR szObjectPath);
	afx_msg void ExternInstanceDeleted(LPCTSTR szObjectPath);
	afx_msg long RefreshView();
	afx_msg long ReleaseContext(long lCtxtHandle);
	afx_msg long RestoreContext(long lCtxtHandle);
	afx_msg long SaveData();
	afx_msg void SetEditMode(long lMode);
	afx_msg long SelectObjectByPath(LPCTSTR szObjectPath);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CWin32LogicalDiskCtrl)
	void FireJumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray)
		{FireEvent(eventidJumpToMultipleInstanceView,EVENT_PARAM(VTS_BSTR  VTS_VARIANT), szTitle, &varPathArray);}
	void FireNotifyContextChanged()
		{FireEvent(eventidNotifyContextChanged,EVENT_PARAM(VTS_NONE));}
	void FireNotifySaveRequired()
		{FireEvent(eventidNotifySaveRequired,EVENT_PARAM(VTS_NONE));}
	void FireNotifyViewModified()
		{FireEvent(eventidNotifyViewModified,EVENT_PARAM(VTS_NONE));}
	void FireGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);}
	void FireRequestUIActive()
		{FireEvent(eventidRequestUIActive,EVENT_PARAM(VTS_NONE));}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CWin32LogicalDiskCtrl)
	dispidNameSpace = 1L,
	dispidQueryNeedsSave = 2L,
	dispidAddContextRef = 3L,
	dispidGetContext = 4L,
	dispidGetEditMode = 5L,
	dispidExternInstanceCreated = 6L,
	dispidExternInstanceDeleted = 7L,
	dispidRefreshView = 8L,
	dispidReleaseContext = 9L,
	dispidRestoreContext = 10L,
	dispidSaveData = 11L,
	dispidSetEditMode = 12L,
	dispidSelectObjectByPath = 13L,
	eventidJumpToMultipleInstanceView = 1L,
	eventidNotifyContextChanged = 2L,
	eventidNotifySaveRequired = 3L,
	eventidNotifyViewModified = 4L,
	eventidGetIWbemServices = 5L,
	eventidRequestUIActive = 6L,
	//}}AFX_DISP_ID
	};

private:
	SCODE ConnectServer();
	SCODE GetServerAndNamespace(CString& sServerAndNamespace);	

    IWbemServices* m_pwbemService;
	IWbemClassObject* m_pco;

	CString m_sObjectPath;
	CString m_sNamespace;
	CString m_sObjectPathDefault;

	CDiskView* m_pDiskView;
	CRect m_rcDiskView;
	SCODE m_sc;

	// The Edit mode property.
	long m_lEditMode;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIN32LOGICALDISKCTL_H__D5FF1894_0191_11D2_853D_00C04FD7BB08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\diskperfwbem\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\win32logicaldiskppg.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Win32LogicalDiskPpg.cpp 
//
// Description:
//    Implementation of the CWin32LogicalDiskPropPage property page class.
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Win32LogicalDisk.h"
#include "Win32LogicalDiskPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CWin32LogicalDiskPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWin32LogicalDiskPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CWin32LogicalDiskPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWin32LogicalDiskPropPage, "WIN32LOGICALDISK.Win32LogicalDiskPropPage.1",
	0xd5ff1887, 0x191, 0x11d2, 0x85, 0x3d, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8)


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskPropPage::CWin32LogicalDiskPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CWin32LogicalDiskPropPage

BOOL CWin32LogicalDiskPropPage::CWin32LogicalDiskPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_WIN32LOGICALDISK_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskPropPage::CWin32LogicalDiskPropPage - Constructor

CWin32LogicalDiskPropPage::CWin32LogicalDiskPropPage() :
	COlePropertyPage(IDD, IDS_WIN32LOGICALDISK_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CWin32LogicalDiskPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskPropPage::DoDataExchange - Moves data between page and properties

void CWin32LogicalDiskPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CWin32LogicalDiskPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\win32logicaldiskctl.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Win32LogicalDiskCtl.h
//
// Description:
//	This file implements a sample custom view of the CIMOM Win32_LogicalDisk
//  class.  The CIMOM SingleView control will allow users to display this
//  custom view when the user selects an instance of the Win32_LogicalDisk
//  class in the WMI DevStudio or WMI ObjectBrowser applications.
//
//  Custom views offer third parties a way to add value to their products by
//  providing more sophisticated views of objects in the CIMOM database than
//  what is provided by the generic object view.
//
//  To see this custom view work, first use mofcomp to compile the "CustomView.mof"
//  file located in this directory.  Then start WMI DeveloperStudio, login to
//  the \\root\cimv2 namespace and search for the Win32_LogicalDisk class.  After the 
//  class is selected, flip to the multiple instance view and select an instance
//  by double clicking the desired row.  Once an instance of Win32_LogicalDisk is
//  selected, click the "Views" button and select the "views" menu item from
//  the popup menu.  The dialog that is then display will allow you to switch
//  from the generic object view to this custom view.
//
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include <wbemcli.h>
#include "Win32LogicalDisk.h"
#include "Win32LogicalDiskCtl.h"
#include "Win32LogicalDiskPpg.h"
#include "DiskView.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CWin32LogicalDiskCtrl, COleControl)



/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWin32LogicalDiskCtrl, COleControl)
	//{{AFX_MSG_MAP(CWin32LogicalDiskCtrl)
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CWin32LogicalDiskCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CWin32LogicalDiskCtrl)
	DISP_PROPERTY_EX(CWin32LogicalDiskCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "QueryNeedsSave", QueryNeedsSave, VT_I4, VTS_NONE)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "AddContextRef", AddContextRef, VT_I4, VTS_I4)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "GetContext", GetContext, VT_I4, VTS_PI4)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "GetEditMode", GetEditMode, VT_I4, VTS_NONE)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "ExternInstanceCreated", ExternInstanceCreated, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "ExternInstanceDeleted", ExternInstanceDeleted, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "RefreshView", RefreshView, VT_I4, VTS_NONE)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "ReleaseContext", ReleaseContext, VT_I4, VTS_I4)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "RestoreContext", RestoreContext, VT_I4, VTS_I4)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "SaveData", SaveData, VT_I4, VTS_NONE)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "SetEditMode", SetEditMode, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CWin32LogicalDiskCtrl, "SelectObjectByPath", SelectObjectByPath, VT_I4, VTS_BSTR)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CWin32LogicalDiskCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CWin32LogicalDiskCtrl, COleControl)
	//{{AFX_EVENT_MAP(CWin32LogicalDiskCtrl)
	EVENT_CUSTOM("JumpToMultipleInstanceView", FireJumpToMultipleInstanceView, VTS_BSTR  VTS_VARIANT)
	EVENT_CUSTOM("NotifyContextChanged", FireNotifyContextChanged, VTS_NONE)
	EVENT_CUSTOM("NotifySaveRequired", FireNotifySaveRequired, VTS_NONE)
	EVENT_CUSTOM("NotifyViewModified", FireNotifyViewModified, VTS_NONE)
	EVENT_CUSTOM("GetWbemServices", FireGetWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CWin32LogicalDiskCtrl, 1)
	PROPPAGEID(CWin32LogicalDiskPropPage::guid)
END_PROPPAGEIDS(CWin32LogicalDiskCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWin32LogicalDiskCtrl, "WIN32LOGICALDISK.Win32LogicalDiskCtrl.1",
	0xd5ff1886, 0x191, 0x11d2, 0x85, 0x3d, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CWin32LogicalDiskCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DWin32LogicalDisk =
		{ 0xd5ff1884, 0x191, 0x11d2, { 0x85, 0x3d, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
const IID BASED_CODE IID_DWin32LogicalDiskEvents =
		{ 0xd5ff1885, 0x191, 0x11d2, { 0x85, 0x3d, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwWin32LogicalDiskOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CWin32LogicalDiskCtrl, IDS_WIN32LOGICALDISK, _dwWin32LogicalDiskOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl::CWin32LogicalDiskCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CWin32LogicalDiskCtrl

BOOL CWin32LogicalDiskCtrl::CWin32LogicalDiskCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_WIN32LOGICALDISK,
			IDB_WIN32LOGICALDISK,
			afxRegApartmentThreading,
			_dwWin32LogicalDiskOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl::CWin32LogicalDiskCtrl - Constructor

CWin32LogicalDiskCtrl::CWin32LogicalDiskCtrl()
{
	InitializeIIDs(&IID_DWin32LogicalDisk, &IID_DWin32LogicalDiskEvents);


	m_pwbemService = NULL;
	m_pco = NULL;

	m_pDiskView = new CDiskView;
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl::~CWin32LogicalDiskCtrl - Destructor

CWin32LogicalDiskCtrl::~CWin32LogicalDiskCtrl()
{
	delete m_pDiskView;

	if (m_pco) {
		m_pco->Release();
	}

	if (m_pwbemService) {
		m_pwbemService->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl::OnDraw - Drawing function

void CWin32LogicalDiskCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	if (!::IsWindow(m_pDiskView->m_hWnd)) {
		// Fill the entire window with the DiskView.
		CRect rcClient;
		GetClientRect(rcClient);
		m_pDiskView->Create(NULL, "ChartWindow", WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN, rcClient, this, 120);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl::DoPropExchange - Persistence support

void CWin32LogicalDiskCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl::OnResetState - Reset control to default state

void CWin32LogicalDiskCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl::AboutBox - Display an "About" box to the user

void CWin32LogicalDiskCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_WIN32LOGICALDISK);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskCtrl message handlers


//*********************************************************************
// CSingleViewCtrl::SelectObjectByPath
//
// Select the specified object. 
//
// First the object is retrieved from CIMOM and then IWbemClassobject
// pointer is passed to the CDiskView object that that it can display
// a few properties that it gets from the object.
// 
//
// Parameters:
//		[in] LPCTSTR szObjectPath
//			The WBEM object path.
//
// Returns:
//		long 
//			S_OK if the object is selected, a failure code
//			otherwise.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::SelectObjectByPath(LPCTSTR szObjectPath) 
{
	// Release the previously selected object if it exists.
	if (m_pco != NULL) {
		m_pco->Release();
		m_pco = NULL;
	}

	SCODE sc;

	m_sObjectPath = szObjectPath;
	sc = ConnectServer();
	if (SUCCEEDED(sc)) {
		BSTR bstrObjectPath = m_sObjectPath.AllocSysString();

		HRESULT hr = m_pwbemService->GetObject(bstrObjectPath, 0, NULL, &m_pco, NULL);
		::SysFreeString(bstrObjectPath);
	}

	m_pDiskView->SetObject(m_sObjectPath, m_pco);

	InvalidateControl();
	return sc;
}





//*********************************************************************
// CWin32LogicalDiskCtrl::QueryNeedsSave
//
// Query to determine whether the currently selected object has
// been modified and needs to be saved. If the object has been
// modified, it can be saved by calling "SaveData".
// 
//
// Parameters:
//		None.
//
// Returns:
//		long
//			TRUE if there is something that needs to be saved.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::QueryNeedsSave() 
{
	// We never modify the object, so it never needs to be saved.
	return FALSE;
}


//*********************************************************************
// CWin32LogicalDiskCtrl::AddContextRef
//
// Increment the reference count for the specified context handle.
//
// Parameters:
//		[out] long lCtxtHandle
//			The context handle.
//
// Returns:
//		long
//			S_OK if the reference count was successfully incremented,
//			a failure code otherwise.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::AddContextRef(long lCtxtHandle) 
{
	return S_OK;
}

//*********************************************************************
// GetContext
//
// Take a snapshot of the current state of this SingleView control,
// save the state in a context object and return a handle to the
// context object.  The intial reference count to the context object
// will be one.  The context object will be deleted when its reference
// count is decremented to zero.
//
// Parameters:
//		[out] long FAR* plCtxtHandle
//			This is a pointer to the place to return the context
//			handle.
//
// Returns:
//		long
//			S_OK if the context was returned successfully, E_FAIL
//			if not.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::GetContext(long FAR* plCtxthandle) 
{
	// There is no context to save.
	*plCtxthandle = NULL;
	return S_OK;
}




//**************************************************************
// CWin32LogicalDiskCtrl::GetNameSpace
//
// Get the current namespace.
//
// Parameters:
//		None.
//
// Returns:
//		BSTR
//			The namespace string.
//
//**************************************************************
BSTR CWin32LogicalDiskCtrl::GetNameSpace() 
{
	return m_sNamespace.AllocSysString();
}



//********************************************************
// CWin32LogicalDiskCtrl::SetNameSpace
//
// Set the current namespace.  The namespace is used as a hint 
// to the view as to how it should display paths.  Paths in
// the same namespace should be displayed as relative paths.
//
// Parameters:
//		[in] LPCTSTR lpszNamespace
//			The namespace string.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CWin32LogicalDiskCtrl::SetNameSpace(LPCTSTR lpszNamespace) 
{
	m_sNamespace = lpszNamespace;
	SetModifiedFlag();
}




//*********************************************************************
// CWin32LogicalDiskCtrl::ExternInstanceCreated
//
// The container calls this method whenever it creates a new CIMOM 
// object instance. This allows a custom view to easily reflect the
// existance of the new object if desired.
//
// Parameters:
//		[in] LPCTSTR szObjectPath
//			The WBEM object path.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CWin32LogicalDiskCtrl::ExternInstanceCreated(LPCTSTR szObjectPath) 
{

}

//*********************************************************************
// CWin32LogicalDiskCtrl::ExternInstanceDeleted
//
// The container calls this method whenever it deletes a CIMOM 
// object instance. This allows a custom view to easily reflect the
// non-existance of the specified object if desired.
//
// Parameters:
//		[in] LPCTSTR szObjectPath
//			The WBEM object path.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CWin32LogicalDiskCtrl::ExternInstanceDeleted(LPCTSTR szObjectPath) 
{

}


//*********************************************************************
// CWin32LogicalDiskCtrl::RefreshView
//
// This method causes the contents of the view to be re-loaded from
// the database.

//
// Parameters:
//		None.
//
// Returns:
//		long
//			S_OK if successful, a failure code if some error occurred.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::RefreshView() 
{
	return S_OK;
}


//*********************************************************************
// CSingleViewCtrl::ReleaseContext
//
// Decrement the reference count for the specified context handle.
//
// Parameters:
//		[out] long lCtxtHandle
//			The context handle.
//
// Returns:
//		long
//			S_OK if the reference count was successfully decremented,
//			a failure code otherwise.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::ReleaseContext(long lCtxtHandle) 
{
	// This sample does not save any context, so there is nothing to do.
	return S_OK;
}


//*********************************************************************
// CWin32LogicalDiskCtrl::RestoreContext
//
// Restore the state of this SingleView control to the previously saved
// context.
//
//
// Parameters:
//		long lCtxtHandle
//			This is the handle of the context to restore to.
//
// Returns:
//		long 
//			S_OK if the view's context could be restored, a failure code
//			otherwise.  
//
//*********************************************************************
long CWin32LogicalDiskCtrl::RestoreContext(long lCtxtHandle) 
{
	// This sample does not save any context, so there is nothing to do.
	return S_OK;
}


//*********************************************************************
// CWin32LogicalDiskCtrl::SaveData
//
// Save changes to current object.
// 
// Parameters:
//		None
//
// Returns:
//		long
//			S_OK if successful, otherwise a failure code.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::SaveData() 
{
	// There is nothing to save since we don't modify the WBEM class object
	// in this sample, so just return S_OK.
	return S_OK;
}


//*********************************************************************
// CSingleViewCtrl::GetEditMode
//
// Get the current state of the edit mode flag.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			0 if the view's data is for browsing only.
//			1 if the view's data can be edited.
//
//*********************************************************************
long CWin32LogicalDiskCtrl::GetEditMode() 
{
	return m_lEditMode;
}

//*********************************************************************
// CWin32LogicalDiskCtrl::SetEditMode
//
// Set the view's edit mode flag.  
//
// Parameters:
//		[in] long lMode
//			0 if the view's data is for browsing only.
//			1 if the view's data can be edited.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CWin32LogicalDiskCtrl::SetEditMode(long lMode) 
{
	m_lEditMode = lMode;
}





//*****************************************************************
// CWin32LogicalDiskCtrl::GetServerAndNamespace
//
// Call this method to parse m_sObjectPath and to retun the server and
// namespace portion of the path.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE 
//			S_OK if successful, otherwise the HMOM status code.
//
//******************************************************************
SCODE CWin32LogicalDiskCtrl::GetServerAndNamespace(CString& sServerAndNamespace)
{
	if (m_sObjectPath.IsEmpty()) {
		return E_FAIL;
	}

	int iColonPos = m_sObjectPath.Find(':');
	SCODE sc;
	if (iColonPos <= 0) {
		sServerAndNamespace.Empty();
		sc = E_FAIL;
	}
	else {
		sServerAndNamespace = m_sObjectPath.Left(iColonPos);
		sc = S_OK;
	}

	return sc;
}




//*****************************************************************
// CWin32LogicalDiskCtrl::ConnectServer
//
// Call this method to connect to the CIMOM Server.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE 
//			S_OK if successful, otherwise the HMOM status code.
//
//******************************************************************
SCODE CWin32LogicalDiskCtrl::ConnectServer()
{
	if (m_pwbemService) {
		m_pwbemService->Release();
		m_pwbemService = NULL;
	}


	SCODE sc;
	CString sServicesPath;
	sc = GetServerAndNamespace(sServicesPath);
	if (FAILED(sc)) {
		return sc;
	}


	COleVariant varUpdatePointer;
	COleVariant varService;
	COleVariant varSC;
	COleVariant varUserCancel;

	// Fire an event to get the WBEM services pointer.  The control containing
	// this custom view control miust catch this event and return the IWbemServices
	// pointer.
	varUpdatePointer.ChangeType(VT_I4);
	varUpdatePointer.lVal = FALSE;
	FireGetIWbemServices((LPCTSTR) sServicesPath,  &varUpdatePointer, &varService, &varSC, &varUserCancel);


	sc = E_FAIL;
	if (varSC.vt & VT_I4)
	{
		sc = varSC.lVal;
	}


	BOOL bCanceled = FALSE;
	if (varUserCancel.vt & VT_BOOL)
	{
		bCanceled  = varUserCancel.boolVal;
	}


	if ((sc == S_OK) &&
		!bCanceled &&
		(varService.vt & VT_UNKNOWN)){
		m_pwbemService = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}
	varService.punkVal = NULL;
	VariantClear(&varService);
	return sc;
}






void CWin32LogicalDiskCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);

	if (::IsWindow(m_pDiskView->m_hWnd)) {
		CRect rcClient;
		GetClientRect(rcClient);
		m_pDiskView->MoveWindow(rcClient);
	}
}



void CWin32LogicalDiskCtrl::OnSetFocus(CWnd* pOldWnd) 
{
	COleControl::OnSetFocus(pOldWnd);
	OnActivateInPlace(TRUE,NULL);
	FireRequestUIActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\win32logicaldiskppg.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Win32LogicalDiskPpg.h
//
// Description:
//
// History:
//
// **************************************************************************

#if !defined(AFX_WIN32LOGICALDISKPPG_H__D5FF1896_0191_11D2_853D_00C04FD7BB08__INCLUDED_)
#define AFX_WIN32LOGICALDISKPPG_H__D5FF1896_0191_11D2_853D_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Win32LogicalDiskPpg.h : Declaration of the CWin32LogicalDiskPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CWin32LogicalDiskPropPage : See Win32LogicalDiskPpg.cpp.cpp for implementation.

class CWin32LogicalDiskPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CWin32LogicalDiskPropPage)
	DECLARE_OLECREATE_EX(CWin32LogicalDiskPropPage)

// Constructor
public:
	CWin32LogicalDiskPropPage();

// Dialog Data
	//{{AFX_DATA(CWin32LogicalDiskPropPage)
	enum { IDD = IDD_PROPPAGE_WIN32LOGICALDISK };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CWin32LogicalDiskPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIN32LOGICALDISKPPG_H__D5FF1896_0191_11D2_853D_00C04FD7BB08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\consumer.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Consumer.h
//
// Description: Event consumer class definition
//    
//
// History:
//
// **************************************************************************

#include <wbemcli.h>
#include <wbemprov.h>

class CConsumer : public IWbemUnboundObjectSink
{
public:
	CConsumer(CListBox      *pOutputList);
	~CConsumer();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD(IndicateToConsumer)(IWbemClassObject *pLogicalConsumer,
									long lNumObjects,
									IWbemClassObject **ppObjects);

private:

	DWORD m_cRef;
	LPCTSTR ErrorString(HRESULT hRes);
	LPWSTR ValueToString(VARIANT *pValue, WCHAR **pbuf);
	CListBox        *m_pOutputList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\consumer.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Consumer.cpp
//
// Description:
//		  Event consumer implementation
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Consumer.h"
#include <objbase.h>

CConsumer::CConsumer(CListBox	*pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CConsumer::~CConsumer()
{
}

STDMETHODIMP CConsumer::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConsumer::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConsumer::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CConsumer::IndicateToConsumer(IWbemClassObject *pLogicalConsumer,
											long lNumObjects,
											IWbemClassObject **ppObjects)
{

	// NOTE: If this routine returns a failure code, including GPFs from called routines,
	// CIMOM will recreate the object and call here again. If you see this routine being
	// called twice for every indication, it means this routine is returning a failure code
	// somehow. Especially watch the AddRef()/Release() semantics for the embedded object.
	// If they're too low, you'll return a GPF.
	HRESULT  hRes;
	CString clMyBuff;
	BSTR objName = NULL;
	BSTR propName = NULL;
	VARIANT pVal, vUnk;
	IUnknown *pUnk = NULL;
	IWbemClassObject *tgtInst = NULL;

	VariantInit(&pVal);
	VariantInit(&vUnk);

	TRACE(_T("Indicate() called\n"));

	objName = SysAllocString(L"TargetInstance");
	propName = SysAllocString(L"Item");

	// walk though the classObjects...
	for (int i = 0; i < lNumObjects; i++)
	{
		// clear my output buffer.
		clMyBuff.Empty();

		// get what was added. This will be an embedded object (VT_UNKNOWN). All
		// WMI interfaces are derived from IUnknown.
		if ((hRes = ppObjects[i]->Get(objName, 0L, 
										&vUnk, NULL, NULL)) == S_OK) 
		{
			//--------------------------------
			// pull the IUnknown out of the various. Dont cast directly to to IWbemClassObject.
			// it MIGHT work now but a suptle change later will break your code. The PROPER 
			// way is to go through QueryInterface and do all the right Release()'s.
			pUnk = (IUnknown *)V_UNKNOWN(&vUnk);

			//--------------------------------
			// Even though you didn't use QI(), you just made a copy of a COM ptr so you 
			// better do the AddRef() that QI() would otherwise do for you.
			pUnk->AddRef();

			//--------------------------------
			// ask for the IWbemClassObject which is the embedded object. This will be the
			// instance that was created.
			if(SUCCEEDED(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&tgtInst)))
			{
				//--------------------------------
				// done with it.
				pUnk->Release();

				//--------------------------------
				// get the 'Item' property out of the embedded object.
				if ((hRes = tgtInst->Get(propName, 0L, 
										&pVal, NULL, NULL)) == S_OK) 
				{
					//--------------------------------
					// done with it.
					tgtInst->Release();

					// compose a string for the listbox.
					clMyBuff = _T("OfficeEquipment Instance added for: ");
					clMyBuff += V_BSTR(&pVal);
				
					// output the buffer.
					m_pOutputList->AddString(clMyBuff);
				}
				else
				{
					TRACE(_T("Get() Item failed %s\n"), ErrorString(hRes));
				}
			}
			else
			{
				TRACE(_T("QI() failed \n"));
			}
		}
		else
		{
			TRACE(_T("Get() targetInst failed %s\n"), ErrorString(hRes));
			m_pOutputList->AddString(_T("programming error"));
		} //endif Get()

	} // endfor

	SysFreeString(propName);
	SysFreeString(objName);
	VariantClear(&pVal);
	VariantClear(&vUnk);

	TRACE(_T("walked indication list\n"));

	return S_OK;
}

// **************************************************************************
//
//	ErrorString()
//
// Description:
//		Converts an HRESULT to a displayable string.
//
// Parameters:
//		hRes (in) - HRESULT to be converted.
//
// Returns:
//		ptr to displayable string.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
LPCTSTR CConsumer::ErrorString(HRESULT hRes)
{
    TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

    switch(hRes) 
    {
    case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
    case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
    case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
    case WBEM_S_ALREADY_EXISTS:
        psz = _T("WBEM_S_ALREADY_EXISTS");
        break;
    case WBEM_S_RESET_TO_DEFAULT:
        psz = _T("WBEM_S_RESET_TO_DEFAULT");
        break;
    case WBEM_S_DIFFERENT:
        psz = _T("WBEM_S_DIFFERENT");
        break;
    case WBEM_E_OVERRIDE_NOT_ALLOWED:
        psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
        break;
    case WBEM_E_PROPAGATED_QUALIFIER:
        psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
        break;
    case WBEM_E_PROPAGATED_PROPERTY:
        psz = _T("WBEM_E_PROPAGATED_PROPERTY");
        break;
    case WBEM_E_UNEXPECTED:
        psz = _T("WBEM_E_UNEXPECTED");
        break;
    case WBEM_E_ILLEGAL_OPERATION:
        psz = _T("WBEM_E_ILLEGAL_OPERATION");
        break;
    case WBEM_E_CANNOT_BE_KEY:
        psz = _T("WBEM_E_CANNOT_BE_KEY");
        break;
    case WBEM_E_INCOMPLETE_CLASS:
        psz = _T("WBEM_E_INCOMPLETE_CLASS");
        break;
    case WBEM_E_INVALID_SYNTAX:
        psz = _T("WBEM_E_INVALID_SYNTAX");
        break;
    case WBEM_E_NONDECORATED_OBJECT:
        psz = _T("WBEM_E_NONDECORATED_OBJECT");
        break;
    case WBEM_E_READ_ONLY:
        psz = _T("WBEM_E_READ_ONLY");
        break;
    case WBEM_E_PROVIDER_NOT_CAPABLE:
        psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
        break;
    case WBEM_E_CLASS_HAS_CHILDREN:
        psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
        break;
    case WBEM_E_CLASS_HAS_INSTANCES:
        psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
        break;
    case WBEM_E_QUERY_NOT_IMPLEMENTED:
        psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
        break;
    case WBEM_E_ILLEGAL_NULL:
        psz = _T("WBEM_E_ILLEGAL_NULL");
        break;
    case WBEM_E_INVALID_QUALIFIER_TYPE:
        psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
        break;
    case WBEM_E_INVALID_PROPERTY_TYPE:
        psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
        break;
    case WBEM_E_VALUE_OUT_OF_RANGE:
        psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
        break;
    case WBEM_E_CANNOT_BE_SINGLETON:
        psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
        break;
	default:
        _itot(hRes, szBuffer2, 16);
        _tcscat(szBuffer, szBuffer2);
        psz = szBuffer;
	    break;
	}
	return psz;
}

// **************************************************************************
//
//	ValueToString()
//
// Description:
//		Converts a variant to a displayable string.
//
// Parameters:
//		pValue (in) - variant to be converted.
//		pbuf (out) - ptr to receive displayable string.
//
// Returns:
//		Same as pbuf.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop */

LPWSTR CConsumer::ValueToString(VARIANT *pValue, WCHAR **pbuf)
{
   DWORD iNeed = 0;
   DWORD iVSize = 0;
   DWORD iCurBufSize = 0;

   WCHAR *vbuf = NULL;
   WCHAR *buf = NULL;

   switch (pValue->vt) 
   {
   case VT_NULL: 
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<null>");
         break;

   case VT_BOOL: {
         VARIANT_BOOL b = pValue->boolVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);

         if (!b) {
            wcscpy(buf, L"FALSE");
         } else {
            wcscpy(buf, L"TRUE");
         }
         break;
      }

   case VT_UI1: {
         BYTE b = pValue->bVal;
	      buf = (WCHAR *)malloc(BLOCKSIZE);
         if (b >= 32) {
            swprintf(buf, L"'%c' (%d, 0x%X)", b, b, b);
         } else {
            swprintf(buf, L"%d (0x%X)", b, b);
         }
         break;
      }

   case VT_I2: {
         SHORT i = pValue->iVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", i, i);
         break;
      }

   case VT_I4: {
         LONG l = pValue->lVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", l, l);
         break;
      }

   case VT_R4: {
         float f = pValue->fltVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", f);
         break;
      }

   case VT_R8: {
         double d = pValue->dblVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", d);
         break;
      }

   case VT_BSTR: {
		 LPWSTR pWStr = pValue->bstrVal;
		 buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
	     swprintf(buf, L"\"%wS\"", pWStr);
		 break;
		}

	// the sample GUI is too simple to make it necessary to display
	// these 'complicated' types--so ignore them.
   case VT_DISPATCH:  // Currently only used for embedded objects
   case VT_BOOL|VT_ARRAY: 
   case VT_UI1|VT_ARRAY: 
   case VT_I2|VT_ARRAY: 
   case VT_I4|VT_ARRAY: 
   case VT_R4|VT_ARRAY: 
   case VT_R8|VT_ARRAY: 
   case VT_BSTR|VT_ARRAY: 
   case VT_DISPATCH | VT_ARRAY: 
         break;

   default:
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<conversion error>");
   }

   *pbuf = buf;   
   return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\factory.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  File:  factory.cpp
//
//	Description :
//			Event consumer provider class factory implementation
//
//	Part of :	WMI Tutorial.
//
//  History:	
//
//***************************************************************************

#include "stdafx.h"
#include "factory.h"
#include "Provider.h"

CProviderFactory::CProviderFactory(CListBox	*pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CProviderFactory::~CProviderFactory()
{
}

//IUnknown methods

STDMETHODIMP CProviderFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CProviderFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CProviderFactory::Release(void)
{
    int lNewRef = InterlockedDecrement(&m_cRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CProviderFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;
    CProvider *pProvider = NULL;

    if (pUnkOuter)
        return E_FAIL;

    pProvider = new CProvider(m_pOutputList);

    if (pProvider == NULL)
	{
		return E_FAIL;
	}

    if (pProvider)
    {
        hr = pProvider->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::LockServer
//
//  Synopsis:
//
//  Arguments:  [fLock]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProviderFactory::LockServer(BOOL fLock)
{
    if (fLock)
        m_cRef++;
    else
        m_cRef--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\diskperfwbem\dpwbem.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	File:  dpwbem.cpp
//
//	Description:
//		Connects to the WMI server and calls DiskPerfDetails( ) to
//		retrieve partition properties.
//
//	Part of :	DiskPerfWbem
//
//  History:	
//
//***************************************************************************


#include <objbase.h>
#include <wbemcli.h>
#include <lmcons.h>
#include <stdio.h>


void			DiskPerfDetails( IWbemServices * pIWbemServices );
BOOL			InitSecurity( void );
DWORD WINAPI	WaitThread( HANDLE hWait );


//==============================================================================
//	main( )
//==============================================================================
int main( int argc, char **argv )
{
	HRESULT	hr;
	DWORD	ThreadId;
	HANDLE	hWait;
	TCHAR	szSysName[UNCLEN + 3];

	IWbemLocator	*pIWbemLocator  = NULL;
	IWbemServices	*pIWbemServices = NULL;

	if ( !SUCCEEDED( CoInitialize( NULL ) ) || !InitSecurity( ) ) 
	{
		printf( "COM stuff is hosed!\r\n" );

		return 0;
	}

	// Create an instance of the WbemLocator interface.
	if ( CoCreateInstance( CLSID_WbemLocator,
	                       NULL,
	                       CLSCTX_INPROC_SERVER,
	                       IID_IWbemLocator,
	                       (LPVOID *) &pIWbemLocator) == S_OK )
	{
		// setup BSTRs for namespace and authentication
				
		BSTR pNamespace = SysAllocStringLen( NULL, UNCLEN + sizeof( "\\root\\WMI" ) + 3 );
		BSTR pUserName  = NULL;
		BSTR pPassWord  = NULL;
		BSTR pDomain    = NULL;

		// format namespace and security strings
		if ( argc < 2 )
		{
			DWORD dwLen = sizeof( szSysName );

			wcscpy( pNamespace, L"\\\\.\\root\\WMI" );
			szSysName[0] = '\\';
			szSysName[1] = '\\';
			GetComputerName( szSysName + 2, &dwLen );
		}
		else
		{
			strcpy( szSysName, argv[1] );
			MultiByteToWideChar( CP_ACP, NULL, szSysName, UNCLEN + 3, pNamespace, UNCLEN + 3 );
			if ( argc > 3 )
			{
				if ( ( pUserName  = SysAllocStringLen( NULL, UNLEN + 1 ) ) )
				{
					MultiByteToWideChar( CP_ACP, NULL, argv[2], UNLEN, pUserName, UNLEN );
				}
				if ( ( pPassWord  = SysAllocStringLen( NULL, PWLEN + 1 ) ) )
				{
					MultiByteToWideChar( CP_ACP, NULL, argv[3], PWLEN, pPassWord, PWLEN );
				}
		
				if ( argc > 4 )
				{
					if ( ( pDomain = SysAllocStringLen( NULL, DNLEN + 1 ) ) )
					{
						MultiByteToWideChar( CP_ACP, NULL, argv[4], DNLEN, pDomain, DNLEN );
					}
				}
			}
			wcscat( pNamespace, L"\\root\\WMI" );
		}

		// Display connect message and start wait feedback thread
		printf( "Connecting to %s WMI server at ", szSysName );
		wprintf( L"%s...", pNamespace );

		// make a wait event and kick off wait thread
		hWait = CreateEvent( NULL, TRUE, FALSE, NULL );
		CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) WaitThread, hWait, 0, &ThreadId );

		// connect and get the IWbemServices pointer
		hr = pIWbemLocator->ConnectServer( pNamespace,
		                                   pUserName,
		                                   pPassWord,
		                                   0L,
		                                   0L,
		                                   pDomain,
		                                   NULL,
		                                   &pIWbemServices );

		// kill wait feedback thread
		SetEvent( hWait );
		CloseHandle( hWait );

		// See what WBEM/WMI says about DiskPerf
		if ( hr == WBEM_NO_ERROR )
		{	
			printf( "\nCool!  Connected with %s\n", szSysName );

		
			DiskPerfDetails( pIWbemServices );
		}
		else
		{	
			printf( "\nBummer, failed to connect with %s, Error: 0x%8lX\n", szSysName, hr );
		}

		if ( pIWbemServices )
		{
			pIWbemServices->Release( );
		}

		// free up connect BSTRs
		if( pNamespace ) 
		{
			SysFreeString( pNamespace );
		}
		if( pUserName ) 
		{
			SysFreeString( pUserName );
		}
		if( pPassWord ) 
		{
			SysFreeString( pPassWord );
		}
		if( pDomain ) 
		{
			SysFreeString( pDomain );
		}

		if ( pIWbemLocator )
		{ 
			pIWbemLocator->Release( ); 
		}
	}
	else
	{	
		printf( "WMI services not present or unavailable!\n" );
	}

	CoUninitialize( );

	return 0;
}


//==============================================================================
//	WaitThread( HANDLE hWait )
//==============================================================================
DWORD WINAPI WaitThread( HANDLE hWait )
{
	while ( WaitForSingleObject( hWait, 300 ) == WAIT_TIMEOUT )
	{
		printf(".");
	}
	printf("\n");

	return 0;
}


//==============================================================================
//	InitSecurity( void )
//	Initialize COM security for DCOM services.
//==============================================================================
BOOL InitSecurity( void )
{
	// Adjust the security to allow client impersonation.
	HRESULT hres = CoInitializeSecurity
								( NULL, -1, NULL, NULL, 
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE, 
											NULL, 
											EOAC_NONE, 
											NULL );

	return SUCCEEDED( hres );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\factory.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  factory.h
//
// Description: Event consumer provider class factory definition
//    
//
// History:
//
// **************************************************************************

#include <wbemcli.h>

class CProviderFactory : public IClassFactory
{
public:

	CProviderFactory(CListBox	*pOutputList);
	virtual ~CProviderFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD_(SCODE, CreateInstance)(IUnknown * pUnkOuter, 
									REFIID riid, 
									void ** ppvObject);

    STDMETHOD_(SCODE, LockServer)(BOOL fLock);

private:
	LONG m_cRef;
	CListBox	*m_pOutputList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\diskperfwbem\dpdetail.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	File:  dpdetail.cpp
//
//	Description:
//		This file implements the DiskPerfDetails() routine which 
//		demonstrates how to enumerate properties for the DiskPerf
//		class and instances.
//
//	Part of :	DiskPerfWbem
//
//  History:	
//
//***************************************************************************

#include <objbase.h>
#include <wbemcli.h>
#include <stdio.h>

char PropListHeader[] =
	"DiskPerf Property Descriptions:\n\n"
	"WMI Data ID\tProperty\tDescription\n"
	"======================================="
	"=======================================\n"
	"";


//==============================================================================
//
//	DiskPerfDetails( IWbemServices * pIWbemServices ) 
//
//==============================================================================
void DiskPerfDetails( IWbemServices * pIWbemServices ) 
{
	HRESULT		hr;
	long		lLower, lUpper, lCount; 
	SAFEARRAY	*psaNames = NULL;
	BSTR		PropName  = NULL;
	VARIANT		pVal;
	ULONG		uReturned;

	IEnumWbemClassObject	*pEnum     = NULL;
	IWbemClassObject		*pPerfInst = NULL;
	IWbemQualifierSet		*pQualSet  = NULL;

	VariantInit( &pVal );

	// Alloc class name string for DiskPerf
	BSTR PerfClass = SysAllocString( L"DiskPerf" );

	// Here the object info for the Class - DiskPerf is retrieved and displayed

	// Collect object information for PerfClass
    if ( ( pIWbemServices->GetObject( PerfClass,
	                                  0L,
	                                  NULL,
	                                  &pPerfInst,
                                      NULL ) ) == WBEM_NO_ERROR )
	{
		// show the property description list header
		printf( PropListHeader );

		// Load up a safearray of property names
		if ( ( pPerfInst->GetNames( NULL,
		                            WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY,
		                            NULL, 
		                            &psaNames ) ) == WBEM_NO_ERROR )
		{
			// Get the upper and lower bounds of the Names array
			if ( ( hr = SafeArrayGetLBound( psaNames, 1, &lLower ) ) == S_OK ) 
			{
				hr = SafeArrayGetUBound( psaNames, 1, &lUpper );
			}

			if ( hr != S_OK ) 
			{
				printf( "Problem with property name array.\n" );
			}
			else
			{
				BSTR WmiQual  = SysAllocString( L"WmiDataId" );
				BSTR DescQual = SysAllocString( L"Description" );
				UINT uWmiId;

				for ( lCount = lLower; lCount <= lUpper; lCount++ ) 
				{
					// get the property name for this element
					if ( ( SafeArrayGetElement( psaNames, 
					                            &lCount, 
					                            &PropName)) == S_OK )
					{
						if ( ( pPerfInst->GetPropertyQualifierSet( PropName, &pQualSet ) ) == WBEM_NO_ERROR ) 
						{
							// check to see if the property is a WMI data Item and save its description
							// these are the DiskPerf counters
							if ( ( pQualSet->Get( WmiQual, 0L, &pVal, NULL ) ) == WBEM_NO_ERROR )
							{
								uWmiId = pVal.lVal;

								VariantClear( &pVal );
								if ( ( pQualSet->Get( DescQual, 0L, &pVal, NULL ) ) == WBEM_NO_ERROR )
								{
									wprintf( L"( %d )\t\t%s\t%s\n", uWmiId, PropName, pVal.bstrVal );
									VariantClear( &pVal );
								}
							}
							else
							{
								// knock out the properties I want to get explicitly
								wcscpy( PropName, L"" );
								SafeArrayPutElement( psaNames, &lCount, PropName );
							}
							if ( pQualSet )
							{
								pQualSet->Release( ); 
								pQualSet = NULL;
							}
						}
						SysFreeString( PropName );
					}
				}
				SysFreeString( WmiQual );
				SysFreeString( DescQual );
			}
		}
	}

	// Now that the object info is displayed, go get the values for all the
	// partition instances

	// Create enumerator for all partition instances
    hr = pIWbemServices->CreateInstanceEnum( PerfClass,
	                                         WBEM_FLAG_SHALLOW,
	                                         NULL,
	                                         &pEnum );

	if ( hr == WBEM_NO_ERROR )
	{
        while ( pEnum->Next( INFINITE,
		                     1,
                             &pPerfInst,
                             &uReturned ) == WBEM_NO_ERROR )
		{
			// Explicitly get the properties of InstanceName and Active state
			PropName = SysAllocString( L"InstanceName" );
			if ( ( pPerfInst->Get( PropName, 
			                       0L, 
			                       &pVal, 
			                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				wprintf( L"\n%s\n", pVal.bstrVal );
				VariantClear( &pVal );
			}

			PropName = wcscpy( PropName, L"Active" );
			if ( ( pPerfInst->Get( PropName, 
			                       0L, 
			                       &pVal, 
			                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				wprintf( L"\t%s\t\t= %s\n", PropName, pVal.boolVal ? L"TRUE" : L"FALSE" );
				VariantClear( &pVal );
			}
			SysFreeString( PropName );
			PropName = NULL;

			// Iterate through the properties again getting values only for WmiData items
			for ( lCount = lLower; lCount <= lUpper; lCount++ ) 
			{
				// get the property name for this element
				if ( ( SafeArrayGetElement( psaNames, 
				                            &lCount, 
				                            &PropName ) ) == WBEM_NO_ERROR )
				{
					// Get the value for the property.
					if ( ( pPerfInst->Get( PropName, 
					                       0L, 
					                       &pVal, 
					                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
					{
						if ( pVal.vt == VT_I4 )
						{
							wprintf( L"\t%s\t= %d\n", PropName, pVal.lVal );
						}
						else if ( pVal.vt == VT_BSTR )
						{
							wprintf( L"\t%s\t= %s\n", PropName, pVal.bstrVal );
						}
						else
						{
							wprintf( L"\t%s\t= NULL\n", PropName );
						}
						VariantClear( &pVal );
					}
				}
			}
			if ( pPerfInst )
			{ 
				pPerfInst->Release( );
				pPerfInst = NULL;
			}
		}
		pEnum->Release( );
	}
	else
	{
		printf( "Can't enumerate DiskPerf instances!\n" );
	}

	if ( psaNames )
	{
		SafeArrayDestroy( psaNames );
	}
	if ( PerfClass )
	{
		SysFreeString( PerfClass );
	}
}


#if 0
// This is useful for formatting unknown property values.

// **************************************************************************
//
//	ValueToString()
//
// Description:
//		Converts a variant to a displayable string.
//
// Parameters:
//		pValue (in) - variant to be converted.
//		pbuf (out) - ptr to receive displayable string.
//
// Returns:
//		Same as pbuf.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop  (this size stolen from cvt.h in c runtime library) */

LPWSTR ValueToString(VARIANT *pValue, WCHAR **pbuf)
{
   DWORD iNeed = 0;
   DWORD iVSize = 0;
   DWORD iCurBufSize = 0;

   WCHAR *vbuf = NULL;
   WCHAR *buf = NULL;


   switch (pValue->vt) 
   {

   case VT_NULL: 
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<null>");
         break;

   case VT_BOOL: {
         VARIANT_BOOL b = pValue->boolVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);

         if (!b) {
            wcscpy(buf, L"FALSE");
         } else {
            wcscpy(buf, L"TRUE");
         }
         break;
      }

   case VT_UI1: {
         BYTE b = pValue->bVal;
	      buf = (WCHAR *)malloc(BLOCKSIZE);
         if (b >= 32) {
            swprintf(buf, L"'%c' (%d, 0x%X)", b, b, b);
         } else {
            swprintf(buf, L"%d (0x%X)", b, b);
         }
         break;
      }

   case VT_I2: {
         SHORT i = pValue->iVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", i, i);
         break;
      }

   case VT_I4: {
         LONG l = pValue->lVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", l, l);
         break;
      }

   case VT_R4: {
         float f = pValue->fltVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", f);
         break;
      }

   case VT_R8: {
         double d = pValue->dblVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", d);
         break;
      }

   case VT_BSTR: {
		 LPWSTR pWStr = pValue->bstrVal;
		 buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
	     swprintf(buf, L"%wS", pWStr);
		 break;
		}

	// the sample GUI is too simple to make it necessary to display
	// these 'complicated' types--so ignore them.
   case VT_DISPATCH:  // Currently only used for embedded objects
   case VT_BOOL|VT_ARRAY: 
   case VT_UI1|VT_ARRAY: 
   case VT_I2|VT_ARRAY: 
   case VT_I4|VT_ARRAY: 
   case VT_R4|VT_ARRAY: 
   case VT_R8|VT_ARRAY: 
   case VT_BSTR|VT_ARRAY: 
   case VT_DISPATCH | VT_ARRAY: 
         break;

   default:
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<conversion error>");

   }

   *pbuf = buf;   
   return buf;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\permevents.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  PermEvents.h 
//
// Description:
//    main header file for the PermEvents application
//
// History:
//
// **************************************************************************

#if !defined(AFX_PermEvents_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
#define AFX_PermEvents_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include "factory.h"

/////////////////////////////////////////////////////////////////////////////
// CPermEventsApp:
// See PermEvents.cpp for the implementation of this class
//

class CPermEventsApp : public CWinApp
{
public:
	CPermEventsApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPermEventsApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

	int ExitInstance();

// Implementation

	//{{AFX_MSG(CPermEventsApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	DWORD m_clsReg;
	CProviderFactory *m_factory;

	void RegisterServer(void);
	void UnregisterServer(void);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PermEvents_H__E8685698_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\permevents.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  PermEvents.cpp
//
// Description:
//    Defines the class behaviors for the application.
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "PermEvents.h"
#include "PermEventsDlg.h"
#include <objbase.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPermEventsApp

BEGIN_MESSAGE_MAP(CPermEventsApp, CWinApp)
	//{{AFX_MSG_MAP(CPermEventsApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPermEventsApp construction

CPermEventsApp::CPermEventsApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	m_clsReg = 0;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CPermEventsApp object

CPermEventsApp theApp;

// {1E069401-087E-11d1-AD85-00AA00B8E05A}
static const GUID CLSID_WBEMSampleConsumer = 
{ 0x1e069401, 0x87e, 0x11d1, { 0xad, 0x85, 0x0, 0xaa, 0x0, 0xb8, 0xe0, 0x5a } };

/////////////////////////////////////////////////////////////////////////////
// CPermEventsApp initialization

BOOL CPermEventsApp::InitInstance()
{
	HRESULT hRes;
	BOOL regEmpty = FALSE; // did a self-unregister happen?

	// OLE initialization. This is 'lighter' than OleInitialize()
	//  which also setups DnD, etc.
	if(SUCCEEDED(CoInitialize(NULL))) 
	{
	
		hRes = CoInitializeSecurity( NULL, -1, NULL, NULL, 
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE, 
											NULL, 
											EOAC_NONE, 
											NULL );
	}
	else // didnt CoInitialize()
	{
		AfxMessageBox(_T("CoInitialize Failed"));
		return FALSE;
	} // endif OleInitialize()

	// NOTE: To advertise that we can self-register, put 'OLESelfRegister'
	// in the version resource.

	// see if this is a self-Unregister call.
	TCHAR temp[128];
	TCHAR seps[] = _T(" ");
	TCHAR *token = NULL;

	_tcscpy(temp, (LPCTSTR)m_lpCmdLine);
	token = _tcstok( temp, seps );
	while( token != NULL )
	{
		/* While there are tokens in "string" */
		if(_tcscmp(token, _T("/UNREGSERVER")) == 0)
		{
			UnregisterServer();
			return FALSE;		// no use doing any more.
		}
		/* Get next token: */
		token = _tcstok( NULL, seps );
	}

	// if we got here, the unregister didn't return out and we should
	// make sure we're registered now.
	RegisterServer();

	// creating the dlg earlier than usual so the class factory 
	//	can pass m_outputList.
	CPermEventsDlg dlg;

	m_factory = new CProviderFactory(&(dlg.m_outputList));

	if((hRes = CoRegisterClassObject(CLSID_WBEMSampleConsumer,
							(IUnknown *)m_factory,
							CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
							REGCLS_MULTIPLEUSE,
							&m_clsReg)) == S_OK)
	{
		TRACE(_T("registered\n"));
	}
	else
	{
		TRACE(_T("not registered\n"));
	}

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

int CPermEventsApp::ExitInstance()
{
	if(m_clsReg)
	{
		HRESULT hres = CoRevokeClassObject(m_clsReg);

		CoUninitialize();
	}

	return CWinApp::ExitInstance();
}

#define TCHAR_LEN_IN_BYTES(str)	 (unsigned long)(_tcslen(str)*sizeof(TCHAR)+sizeof(TCHAR))

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
// Note: Key setups are:
//		HKCR\CLSID\[guid]= friendly name
//		HKCR\CLSID\[guid]\LocalServer32 = exe's path.
//		HKCR\CLSID\AppID = [guid]
//		HKCR\AppID\[guid] = friendly name
//		HKCR\AppID\[guid] = 'RunAs' = "Interactive User"
//			'RunAs' is a value name; not a subkey.
//***************************************************************************
void CPermEventsApp::RegisterServer(void)
{   
	HKEY hKey1, hKey2;

	TCHAR       wcConsID[] = _T("{1E069401-087E-11d1-AD85-00AA00B8E05A}");
    TCHAR       wcCLSID[] = _T("CLSID\\{1E069401-087E-11d1-AD85-00AA00B8E05A}");
    TCHAR       wcAppID[] = _T("AppID\\{1E069401-087E-11d1-AD85-00AA00B8E05A}");
    TCHAR      wcModule[128];	// this will hold the exe's path.
	TCHAR ConsumerTextForm[] = _T("WMI Sample Permanent Consumer Object");

	// this will allow the server to display its windows on the active desktop instead
	// of the hidden desktop where services run.
	TCHAR Interactive[] = _T("Interactive User");

	GetModuleFileName(NULL, wcModule,  128);

	//Set the "default" text under CLSID
	//==========================
	RegCreateKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
					(LPBYTE)ConsumerTextForm, 
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// create the LocalServer32 key so the server can be found.
	RegCreateKey(hKey1, _T("LocalServer32"), &hKey2);
	RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)wcModule, TCHAR_LEN_IN_BYTES(wcModule));
	RegSetValueEx(hKey1, _T("AppID"), 0, REG_SZ, (LPBYTE)wcConsID, TCHAR_LEN_IN_BYTES(wcConsID));

	CloseHandle(hKey2);
	CloseHandle(hKey1);

	// now do the AppID keys.
	RegCreateKey(HKEY_CLASSES_ROOT, wcAppID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
					(LPBYTE)ConsumerTextForm, 
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// this makes the local server run on the active desktop (the one you're seeing) 
	// instead of the hidden desktop that services run on (which doesn't have UI)
	RegSetValueEx(hKey1, _T("RunAs"), 0, REG_SZ, (LPBYTE)Interactive, TCHAR_LEN_IN_BYTES(Interactive));
	CloseHandle(hKey1);
}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
void CPermEventsApp::UnregisterServer(void)
{
 
	TCHAR       wcConsID[] = _T("{1E069401-087E-11d1-AD85-00AA00B8E05A}");
    TCHAR       wcCLSID[] = _T("CLSID\\{1E069401-087E-11d1-AD85-00AA00B8E05A}");
    TCHAR       wcAppID[] = _T("AppID\\{1E069401-087E-11d1-AD85-00AA00B8E05A}");
    HKEY hKey1;
	DWORD dwRet;

	// delete the keys under CLSID\[guid]
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, _T("LocalServer32"));
        CloseHandle(hKey1);
    }

	// delete CLSID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1,wcConsID);
        CloseHandle(hKey1);
    }

	// delete AppID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("AppID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, wcConsID);
        CloseHandle(hKey1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\permeventsdlg.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  PermEventsDlg.cpp 
//
// Description:
//    implementation file for event consumer sample dialog box
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "PermEvents.h"
#include "PermEventsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPermEventsDlg dialog

CPermEventsDlg::CPermEventsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPermEventsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPermEventsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CPermEventsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPermEventsDlg)
	DDX_Control(pDX, IDC_OUTPUTLIST, m_outputList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPermEventsDlg, CDialog)
	//{{AFX_MSG_MAP(CPermEventsDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPermEventsDlg message handlers

BOOL CPermEventsDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CPermEventsDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CPermEventsDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CPermEventsDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\provider.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Provider.cpp
//
// Description: Event consumer provider class implementation
//    
//
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Provider.h"
#include "Consumer.h"
#include <objbase.h>

CProvider::CProvider(CListBox *pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CProvider::~CProvider()
{
}

STDMETHODIMP CProvider::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemEventConsumerProvider)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvider::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvider::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CProvider::Initialize(LPWSTR wszUser, LONG lFlags,
								   LPWSTR wszNamespace, LPWSTR wszLocale,
								   IWbemServices __RPC_FAR *pNamespace,
								   IWbemContext __RPC_FAR *pCtx,
								   IWbemProviderInitSink __RPC_FAR *pInitSink)
{

    // Tell CIMOM that we are initialized
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_S_NO_ERROR;
}

//-----------------------------------------------------------
STDMETHODIMP CProvider::FindConsumer(
						IWbemClassObject* pLogicalConsumer,
						IWbemUnboundObjectSink** ppConsumer)
{
	CConsumer* pSink = new CConsumer(m_pOutputList);
    
	return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\provider.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  Provider.cpp
//
// Description: Event consumer provider class definition
//    
//
// History:
//
// **************************************************************************

#include <wbemcli.h>
#include <wbemprov.h>

class CProvider : public IWbemEventConsumerProvider
{
public:
	CProvider(CListBox	*pOutputList);
	~CProvider();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHOD(Initialize)( 
			LPWSTR pszUser,
			LONG lFlags,
			LPWSTR pszNamespace,
			LPWSTR pszLocale,
			IWbemServices __RPC_FAR *pNamespace,
			IWbemContext __RPC_FAR *pCtx,
			IWbemProviderInitSink __RPC_FAR *pInitSink);

    STDMETHOD(FindConsumer)(
			IWbemClassObject* pLogicalConsumer,
			IWbemUnboundObjectSink** ppConsumer);

private:

	DWORD m_cRef;
	CListBox	*m_pOutputList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\permeventsdlg.h ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  PermEventsDlg.h 
//
// Description:
//    header file for event consumer sample dialog box
//
// History:
//
// **************************************************************************

#if !defined(AFX_PermEventsDLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
#define AFX_PermEventsDLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CPermEventsDlg dialog

class CPermEventsDlg : public CDialog
{
// Construction
public:
	CPermEventsDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CPermEventsDlg)
	enum { IDD = IDD_PERMEVENTS_DIALOG };
	CListBox	m_outputList;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPermEventsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CPermEventsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PermEventsDLG_H__E868569A_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventprovider\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PermEvents.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WBEMPERMEVENTS_DIALOG       102
#define IDD_PERMEVENTS_DIALOG           102
#define IDR_MAINFRAME                   128
#define IDC_OUTPUTLIST                  1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__E868569C_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
#define AFX_STDAFX_H__E868569C_0774_11D1_AD85_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E868569C_0774_11D1_AD85_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	WBEMPermEvents.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkabr\assoc.h ===
//=================================================================

//

// assoc.h -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#pragma once

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class CAssociation : public Provider
{
    public:

        CAssociation(
        LPCWSTR pwszClassName,
        LPCWSTR pwszNamespaceName,

        LPCWSTR pwszLeftClassName,
        LPCWSTR pwszRightClassName,

        LPCWSTR pwszLeftPropertyName,
        LPCWSTR pwszRightPropertyName
        );

        virtual ~CAssociation();

        HRESULT ExecQuery(

            MethodContext* pMethodContext, 
            CFrameworkQuery &pQuery, 
            long lFlags 
        );

        HRESULT GetObject(

            CInstance* pInstance, 
            long lFlags,
            CFrameworkQuery &pQuery
        );

        HRESULT EnumerateInstances(

            MethodContext *pMethodContext,
            long lFlags /*= 0L*/
        );

    protected:
        
        bool IsInstance(const CInstance *pInstance);

        static HRESULT WINAPI StaticEnumerationCallback(

            Provider* pThat,
            CInstance* pInstance,
            MethodContext* pContext,
            void* pUserData
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT EnumerationCallback(

            CInstance *pRight, 
            MethodContext *pMethodContext, 
            void *pUserData
        );

        virtual HRESULT ValidateLeftObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT ValidateRightObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return IsInstance(pLeft) && IsInstance(pRight);
        }

        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
        )
        {
        }

        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts,
            const CHStringArray &sRightValues
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts,
            const CHStringArray &sLeftWheres
        );

        bool IsDerivedFrom(
                              
            LPCWSTR pszBaseClassName, 
            LPCWSTR pszDerivedClassName, 
            MethodContext *pMethodContext
        );

        CHString m_sLeftClassName;
        CHString m_sRightClassName;

        CHString m_sLeftPropertyName;
        CHString m_sRightPropertyName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventprovider\evprov.h ===
// **************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  EVPROV.H
//
// Description:
//        Sample event provider - header file defines event provider class
//
// History:
//
// **************************************************************************

#ifndef _EVPROV_H_
#define _EVPROV_H_

// {3CD5248E-14F9-11d1-AE9C-00C04FB68820}
DEFINE_GUID(CLSID_MyEventProvider, 