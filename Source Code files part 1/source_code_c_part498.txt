szPath[MAX_PATH];
            LPTSTR         lpszFileName;
                        
            // The file doesn't contain anything. Fill the file
            // from the stream

            if (FAILED(hr = MimeOleGetBodyPropA(pMsg, rghAttach[ulCount], PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &lpszFileName)))
                goto exit;

            if (!FBuildTempPath (lpszFileName, lpszPath, MAX_PATH, FALSE))
                goto exit;

            SafeMimeOleFree(lpszFileName);

            hr=pMsg->BindToObject(rghAttach[ulCount], IID_IMimeBody, (LPVOID *)&pBody);
            if (FAILED(hr))
                goto exit;

            hr=pBody->SaveToFile(IET_INETCSET, lpszPath);
            if (FAILED(hr))
                goto exit;

            ULONG cchPath = lstrlen(lpszPath) + 1;
            if (FAILED(hr = SMAPIAllocateMore(cchPath, rgMessage, (LPVOID*)&rgFiles[ulCount+nBody].lpszPathName)))
                goto exit;
            if (FAILED(hr = SMAPIAllocateMore(cchPath, rgMessage, (LPVOID*)&rgFiles[ulCount+nBody].lpszFileName)))
                goto exit;

            StrCpyN(rgFiles[ulCount+nBody].lpszPathName, lpszPath, cchPath);
            StrCpyN(rgFiles[ulCount+nBody].lpszFileName, lpszPath, cchPath);
            rgFiles[ulCount+nBody].ulReserved = 0;
            rgFiles[ulCount+nBody].flFlags = 0;
            rgFiles[ulCount+nBody].nPosition = 0;
            rgFiles[ulCount+nBody].lpFileType = NULL;

            ReleaseObj(pBody);           
        }
    }
    else
    {   // else condition added in response to bug# 2716 (v-snatar)
        if ((flFlags & MAPI_SUPPRESS_ATTACH) && !(flFlags & MAPI_ENVELOPE_ONLY))
        {
            if (cAttach)
            {
                // Allocate memory for rgFiles
                if (FAILED(hr = SMAPIAllocateMore(cAttach * sizeof(MapiFileDesc), rgMessage, (LPVOID*)&rgFiles)))
                    goto exit;

                // This is important as we don't fill any other structure
                // member apart from lpszFileName

                ZeroMemory((LPVOID)rgFiles,cAttach * sizeof(MapiFileDesc));

                for (ulCount = 0; ulCount < cAttach; ulCount++)
                {
                    LPTSTR lpszFileName;

                    if (FAILED(hr = MimeOleGetBodyPropA(pMsg, rghAttach[ulCount], PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &lpszFileName)))
                        goto exit;

                    // Allocate memory for the filename
                    ULONG cchFileName = lstrlen(lpszFileName)+1;
                    if (FAILED(hr = SMAPIAllocateMore(cchFileName, rgMessage, (LPVOID*)&rgFiles[ulCount].lpszFileName)))
                        goto exit;

                    StrCpyN(rgFiles[ulCount].lpszFileName, lpszFileName, cchFileName);

                    SafeMimeOleFree(lpszFileName);
                }        
            }
        }
    }

    // Set other parameters of MapiMessage
    rgMessage->ulReserved = 0;
    rgMessage->lpszMessageType = NULL;
    rgMessage->lpszConversationID = NULL;

    rgMessage->lpFiles = rgFiles;
    rgMessage->nFileCount = rgFiles ? cAttach + nBody : 0;

    bRet = TRUE;

    *lppMessage = rgMessage;

    // Mark the message as Read
    
    if (!(flFlags & MAPI_PEEK))
    {
        MESSAGEIDLIST List;
        ADJUSTFLAGS Flags;

        List.cMsgs = 1;
        List.prgidMsg = &MsgInfo.idMessage;

        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = 0;

        pFolder->SetMessageFlags(&List, &Flags, NULL, NOSTORECALLBACK);
    }
          
exit:
    SafeRelease(pStreamHTML);
    if (pFolder)
        pFolder->FreeRecord(&MsgInfo);
    SafeMimeOleFree(rghAttach);

    if (FAILED(hr))
        SafeRelease((pMsg));

    if (pMsg)
        pMsg->Release();

    if (pAddrTable)
        pAddrTable->Release();

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////////
// This function is used to check if the parameters in the MapiMessage structure
// are sufficient to Send a mail using the structure details.
//
//  Parameters:
//      lpMessage       in     pointer to MapiMessage structure/      
//
//  Result
//      BOOL - 0 if successful or appropriate error message
///////////////////////////////////////////////////////////////////////////////////

ULONG HrValidateMessage(lpMapiMessage lpMessage)
{
    ULONG           ulCount=0;

    if (lpMessage->lpszSubject && IsBadStringPtr(lpMessage->lpszSubject, (UINT)0xFFFF))
        return MAPI_E_FAILURE;

    if (lpMessage->lpszNoteText && IsBadStringPtr(lpMessage->lpszNoteText, (UINT)0xFFFF))
        return MAPI_E_FAILURE;
  
    if (lpMessage->nFileCount > 0)
    {
        for (ulCount=0; ulCount<lpMessage->nFileCount; ulCount++)
        {
            if (!lpMessage->lpFiles[ulCount].lpszPathName)
                return MAPI_E_FAILURE;
        }
    }

    return SUCCESS_SUCCESS;
}



BOOL HrSMAPISend(HWND hWnd, IMimeMessage *pMsg)
{
    BOOL                    bRet = FALSE;
    HRESULT                 hr;
    ISpoolerEngine          *pSpooler = NULL;
    BOOL                    fSendImmediate = FALSE;

    if (!g_pSpooler)
        {
        if (FAILED(hr = CreateThreadedSpooler(NULL, &pSpooler, TRUE)))
            goto error;
        g_pSpooler = pSpooler;
        }

    fSendImmediate = DwGetOption(OPT_SENDIMMEDIATE);
    
    if (FAILED(hr = HrSendMailToOutBox(hWnd, pMsg, fSendImmediate, TRUE)))
        goto error;

    if (pSpooler)
        {
        CloseThreadedSpooler(pSpooler);
        pSpooler = NULL;
        g_pSpooler = NULL;
        }
       
    bRet = TRUE;

error:
    
    if (pSpooler)
        pSpooler->Release();

    return bRet;
}


HRESULT HrFromIDToNameAndAddress(LPTSTR *ppszLocalName, LPTSTR *ppszLocalAddress, ULONG cbEID, LPENTRYID lpEID)
{
    ULONG           ulObjType = 0, ulcValues;
    IMailUser       *lpMailUser = NULL;
    HRESULT         hr = NOERROR;
    SizedSPropTagArray(2, ptaEid) = { 2, {PR_DISPLAY_NAME, PR_EMAIL_ADDRESS} };
    SPropValue      *spValue = NULL;

    // Validate the parameters - Begin

    if (0 == cbEID || NULL == lpEID || ppszLocalName == NULL || ppszLocalAddress == NULL)
        return E_INVALIDARG;
    
    *ppszLocalName = NULL;
    *ppszLocalAddress = NULL;

    // Validate the parameters - End
   
    if (NULL == s_lpAddrBook)
        {
        hr = MAPI_E_FAILURE;
        goto error;
        }
    
    if FAILED(hr = s_lpAddrBook->OpenEntry(cbEID, (LPENTRYID)lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpMailUser))
        goto error;

    if FAILED(hr = lpMailUser->GetProps((LPSPropTagArray)&ptaEid, NULL, &ulcValues, &spValue))
        goto error;

    if (ulcValues != 2)
        {
        hr = MAPI_E_FAILURE;
        goto error;
        }

    if (spValue[0].ulPropTag == PR_DISPLAY_NAME)
        {
        ULONG cchLocalName = lstrlen(spValue[0].Value.lpszA) + 1;
        if (!MemAlloc((LPVOID*)ppszLocalName, cchLocalName))
            goto error;
        StrCpyN(*ppszLocalName, spValue[0].Value.lpszA, cchLocalName);
        }

    if (spValue[1].ulPropTag == PR_EMAIL_ADDRESS)
        {
        ULONG cchLocalAddress = lstrlen(spValue[1].Value.lpszA) + 1;
        if (!MemAlloc((LPVOID*)ppszLocalAddress, cchLocalAddress))
            goto error;
        StrCpyN(*ppszLocalAddress, spValue[1].Value.lpszA, cchLocalAddress);
        }

    hr = NOERROR;
 
error:
    ReleaseObj(lpMailUser);
    
    if ((spValue) && (NULL != s_lpWabObject))
        s_lpWabObject->FreeBuffer(spValue);
        
    return hr;
}
  
  

//  Fix for Bug #62129 (v-snatar)
HRESULT HrSendAndRecv()
{
    HRESULT             hr=E_FAIL;
    ISpoolerEngine      *pSpooler = NULL;

    if (!g_pSpooler)
    {
        if (FAILED(hr = CreateThreadedSpooler(NULL, &pSpooler, TRUE)))
            goto error;
        g_pSpooler = pSpooler;
    }
    
   
    g_pSpooler->StartDelivery(NULL, NULL, FOLDERID_INVALID, DELIVER_MAIL_RECV | DELIVER_NOUI );

    WaitForSingleObject(hSmapiEvent, INFINITE);    

    if (pSpooler)
    {
        CloseThreadedSpooler(pSpooler);
        pSpooler = NULL;
        g_pSpooler = NULL;
    }     
    
error:    
    if (pSpooler)
        pSpooler->Release();        

    return hr;
}

/*
    This code was taken from OLK2000's RTM source code

    Debug code was removed, the allocator was switched over to g_pMalloc,
    the name was changed from IsServiceAnExe, and the static s_isState was
    added.
*/
BOOL WINAPI IsProcessInteractive( VOID )
{
    static INTERACTIVESTATE s_isState = IS_UNINIT;
    
    HANDLE hProcessToken = NULL;
    HANDLE hThreadToken = NULL;
    DWORD groupLength = 50;
    DWORD dw;

    PTOKEN_GROUPS groupInfo = NULL;

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid = NULL;
    PSID ServiceSid = NULL;
    DWORD i;
    BOOL fServiceSID = FALSE;
    BOOL fInteractiveSID = FALSE;

    // Start with assumption that process is a Service, not an EXE.
    // This is the conservative assumption. If there's an error, we
    // have to return an answer based on incomplete information. The
    // consequences are less grave if we assume we're in a service:
    // an interactive app might fail instead of putting up UI, but if
    // a service mistakenly tries to put up UI it will hang.
    BOOL fExe = FALSE;

    // Bail out early if we have already been here
    if (s_isState != IS_UNINIT)
    {
        return (IS_INTERACTIVE == s_isState);
    }

    //  If we're not running on NT, the high bit of the version is set.
    //  In this case, it's always an EXE.
    DWORD dwVersion = GetVersion();
    if (dwVersion >= 0x80000000)
    {
        fExe = TRUE;
        goto ret;
    }

    // The information we need is on the process token.
    // If we're impersonating, we probably won't be able to open the process token.
    // Revert now; we'll re-impersonate when we're done.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hThreadToken))
    {
        RevertToSelf();
    }
    else
    {
        dw = GetLastError();
        if (dw != ERROR_NO_TOKEN)
        {
            goto ret;
        }
    }

    // Now open the process token.
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        goto ret;
    }

    groupInfo = (PTOKEN_GROUPS)g_pMalloc->Alloc(groupLength);
    if (groupInfo == NULL)
        goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
        groupLength, &groupLength))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            goto ret;
        }

        g_pMalloc->Free(groupInfo);
        groupInfo = NULL;
    
        groupInfo = (PTOKEN_GROUPS)g_pMalloc->Alloc(groupLength);
    
        if (groupInfo == NULL)
            goto ret;
    
        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
            groupLength, &groupLength))
        {
            goto ret;
        }
    }

    //
    //  We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //  The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
        0, 0, 0, 0, 0, &InteractiveSid))
    {
        goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
        0, 0, 0, 0, &ServiceSid))
    {
        goto ret;
    }

    for (i = 0; i < groupInfo->GroupCount ; i += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
        PSID Sid = sanda.Sid;
    
        //
        //  Check to see if the group we're looking at is one of
        //  the 2 groups we're interested in.
        //  We should never see both groups.
        //
    
        if (EqualSid(Sid, InteractiveSid))
        {
            //
            //  This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  an EXE.
            //
            fInteractiveSID = TRUE;
            break;
        }
        else if (EqualSid(Sid, ServiceSid))
        {
            //
            //  This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account.
            //
            fServiceSID = TRUE;
            break;
        }
    }

    /////// Truth table /////// 
    //
    //  1. fServiceSID && !fInteractiveSID
    //  This process has the Service SID in its token.
    //  This means that the process is running as a service running in
    //  a user account.
    //
    //  2. !fServiceSID && fInteractiveSID
    //  This process has the Interactive SID in its token.
    //  This means that the process is running as an EXE.
    //
    //  3. !fServiceSID && !fInteractiveSID
    //  Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //
    //  4. fServiceSID && fInteractiveSID
    //  This shouldn't happen.
    //
    if (fServiceSID)
    {
        if (fInteractiveSID)
        {
            AssertSz(FALSE, "IsServiceAnExe: fServiceSID && fInteractiveSID - wha?");
        }
        fExe = FALSE;
    }
    else if (fInteractiveSID)
    {
        fExe = TRUE;
    }
    else // !fServiceSID && !fInteractiveSID
    {
        fExe = FALSE;
    }

ret:

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    if (ServiceSid)
        FreeSid(ServiceSid);

    if (groupInfo)
        g_pMalloc->Free(groupInfo);

    if (hThreadToken)
    {
        if (!ImpersonateLoggedOnUser(hThreadToken))
        {
            AssertSz(FALSE, "ImpersonateLoggedOnUser failed!");
        }
        CloseHandle(hThreadToken);
    }

    if (hProcessToken)
        CloseHandle(hProcessToken);

    // Avoid the overhead for future calls
    s_isState = (fExe) ? IS_INTERACTIVE : IS_NOTINTERACTIVE;
    
    return(fExe);
}

const static HELPMAP g_rgCtxVirus[] = 
{
    {IDC_TO_TEXT,               IDH_MAIL_VIRUS_TO},
    {IDC_SUBJECT_TEXT,          IDH_MAIL_VIRUS_SUBJECT},
    {IDOK,                      IDH_MAIL_VIRUS_SEND},
    {IDCANCEL,                  IDH_MAIL_VIRUS_DONT_SEND},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};

INT_PTR CALLBACK WarnSendMailDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            lpMapiMessage lpMessage = (lpMapiMessage)lParam;

            if (lpMessage)
            {
                if (lpMessage->lpszSubject)
                    SetDlgItemText(hwnd, IDC_SUBJECT_TEXT, lpMessage->lpszSubject);

                if (lpMessage->nRecipCount)
                {
                    TCHAR *szTo = NULL;
                    int cTo = MAX_PATH;
                    int cch = 0;

                    if (MemAlloc((void**)&szTo, cTo*sizeof(TCHAR)))
                    {
                        szTo[0] = (TCHAR)0;
                        for (ULONG i = 0; i < lpMessage->nRecipCount; i++)
                        {
                            int cLen = lstrlen(lpMessage->lpRecips[i].lpszAddress); 
                            if ((cch + cLen + 1) > cTo)
                            {
                                cTo += cLen + MAX_PATH;
                                if (!MemRealloc((void **)&szTo, cTo*sizeof(TCHAR)))
                                    break;
                            }
                            if (i > 0)
                            {
                                StrCatBuff(szTo, ";", cTo);
                                cch++;
                            }
                            StrCatBuff(szTo, lpMessage->lpRecips[i].lpszAddress, cTo);
                            cch += cLen;
                        }
                        SetDlgItemText(hwnd, IDC_TO_TEXT, szTo);
                        MemFree(szTo);
                    }
                }
            }

            SetFocus(GetDlgItem(hwnd, IDOK));
            CenterDialog(hwnd);
            return(FALSE);
        }
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgCtxVirus);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);
            }
            break; // wm_command

    } // message switch
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\shell\smapi16.cpp ===
//
//  SMAPI16.CPP - Simple MAPI implementation, 16bit Version
//

#include "pch.hxx"
#include <mapi.h>
#include <note.h>
#include <mimeutil.h>
#include <resource.h>
#include <ipab.h>
#include <error.h>

ASSERTDATA


#define WriteVar2File( hf, v )    _lwrite( (hf), &(v), sizeof(v) );
#define ReadVarFromFile( hf, v )  _lread( (hf), &(v), sizeof(v) );


static const char  s_cszMailMsgCmd[] = "msimn.exe /mailmsg:%s";

inline void  WriteStr2File( HFILE hFile, LPCSTR cszText )
{
   UINT  uText = ( cszText == NULL ) ? 0 : lstrlen( cszText ) + 1;
   _lwrite( hFile, &uText, sizeof( uText ) );
   if ( uText > 0 )
      _lwrite( hFile, cszText, uText );
}

inline void  WriteMRD2File( HFILE hFile, lpMapiRecipDesc lpMRD )
{
   WriteVar2File( hFile, lpMRD->ulReserved );
   WriteVar2File( hFile, lpMRD->ulRecipClass );
   WriteStr2File( hFile, lpMRD->lpszName );
   WriteStr2File( hFile, lpMRD->lpszAddress );
   WriteVar2File( hFile, lpMRD->ulEIDSize );
   _lwrite( hFile, lpMRD->lpEntryID, lpMRD->ulEIDSize );
}

inline LPSTR  ReadStrFromFile( HFILE hFile )
{
   UINT  uText;
   LPSTR  szText;

   ReadVarFromFile( hFile, uText );
   if ( uText > 0 )
   {
      szText = (LPSTR)malloc( uText );
      _lread( hFile, szText, uText );
   }
   else
      szText = NULL;

   return( szText );
}

inline lpMapiRecipDesc  ReadMRDFromFile( HFILE hFile )
{
   lpMapiRecipDesc  lpMRD = new MapiRecipDesc;

   ReadVarFromFile( hFile, lpMRD->ulReserved );
   ReadVarFromFile( hFile, lpMRD->ulRecipClass );
   lpMRD->lpszName = ReadStrFromFile( hFile );
   lpMRD->lpszAddress = ReadStrFromFile( hFile );
   ReadVarFromFile( hFile, lpMRD->ulEIDSize );
   if ( lpMRD->ulEIDSize > 0 )
   {
      lpMRD->lpEntryID = malloc( lpMRD->ulEIDSize );
      _lread( hFile, lpMRD->lpEntryID, lpMRD->ulEIDSize );
   }
   else
      lpMRD->lpEntryID = NULL;

   return( lpMRD );
}

inline lpMapiFileDesc  ReadMFDFromFile( HFILE hFile )
{
   lpMapiFileDesc  lpMFD = new MapiFileDesc;

   ReadVarFromFile( hFile, lpMFD->ulReserved );
   ReadVarFromFile( hFile, lpMFD->flFlags );
   ReadVarFromFile( hFile, lpMFD->nPosition );
   lpMFD->lpszPathName = ReadStrFromFile( hFile );
   lpMFD->lpszFileName = ReadStrFromFile( hFile );
   lpMFD->lpFileType = NULL;

   return( lpMFD );
}

#define FreeMemSafe( lp ) \
           if ( (lp) != NULL ) \
           {                   \
              free( lp );      \
              lp = NULL;       \
           }

inline void  FreeMRDSafe( lpMapiRecipDesc &lpMRD )
{
   if ( lpMRD != NULL )
   {
      FreeMemSafe( lpMRD->lpszName );
      FreeMemSafe( lpMRD->lpszAddress );
      FreeMemSafe( lpMRD->lpEntryID );
      free( lpMRD );
      lpMRD = NULL;
   }
}

inline void  FreeMFDSafe( lpMapiFileDesc &lpMFD )
{
   if ( lpMFD != NULL )
   {
      FreeMemSafe( lpMFD->lpszPathName );
      FreeMemSafe( lpMFD->lpszFileName );
      free( lpMFD );
      lpMFD = NULL;
   }
}


///////////////////////////////////////////////////////////////////////
// 
// MAPISendMail
// 
///////////////////////////////////////////////////////////////////////

EXTERN_C ULONG STDAPICALLTYPE
MAPISENDMAIL(
   LHANDLE lhSession,   // ignored
   ULONG ulUIParam,
   lpMapiMessage lpMessage,
   FLAGS flFlags,
   ULONG ulReserved
   )
{
   // validate parameters
   if ( NULL == lpMessage || IsBadReadPtr( lpMessage, sizeof( MapiMessage ) ) )
      return MAPI_E_INVALID_MESSAGE;

   // $BUGBUG - We do not support sendmail without UI yet.  This is a big
   //           hole that we need to fix.
   if (!(flFlags & MAPI_DIALOG))
      return MAPI_E_NOT_SUPPORTED;

   // Create Temporary File Storage
   //
   char  szTmpDir[_MAX_PATH], szTmpFile[_MAX_PATH];
   OFSTRUCT  of;
   HFILE  hTmp;

   if ( GetTempPath( _MAX_PATH, szTmpDir ) == 0 )
      return( MAPI_E_FAILURE );
   if ( GetTempFileName( szTmpDir, "msm", 0, szTmpFile ) == 0 )
      return( MAPI_E_FAILURE );
   hTmp = OpenFile( szTmpFile, &of, OF_CREATE | OF_WRITE );
   if ( hTmp == HFILE_ERROR )
      return( MAPI_E_FAILURE );

   // lhSession is intentionally ignored because it is impossible to support it
   WriteVar2File( hTmp, lhSession );
   WriteVar2File( hTmp, ulUIParam );
   WriteVar2File( hTmp, flFlags );
   WriteVar2File( hTmp, ulReserved );

   // Write lpMapiMessage into Temporary File
   //
   int  i;

   WriteVar2File( hTmp, lpMessage->ulReserved );
   WriteStr2File( hTmp, lpMessage->lpszSubject );
   WriteStr2File( hTmp, lpMessage->lpszNoteText );
   WriteStr2File( hTmp, lpMessage->lpszMessageType );
   WriteStr2File( hTmp, lpMessage->lpszDateReceived );
   WriteStr2File( hTmp, lpMessage->lpszConversationID );
   WriteVar2File( hTmp, lpMessage->flFlags );
   WriteVar2File( hTmp, lpMessage->lpOriginator );
   if ( lpMessage->lpOriginator != NULL )
      WriteMRD2File( hTmp, lpMessage->lpOriginator );
   WriteVar2File( hTmp, lpMessage->nRecipCount );
   for ( i = 0;  i < lpMessage->nRecipCount;  i++ )
      WriteMRD2File( hTmp, lpMessage->lpRecips+i );
   WriteVar2File( hTmp, lpMessage->nFileCount );
   for ( i = 0;  i < lpMessage->nFileCount;  i++ )
   {
      lpMapiFileDesc  lpMFD = lpMessage->lpFiles+i;
      WriteVar2File( hTmp, lpMFD->ulReserved );
      WriteVar2File( hTmp, lpMFD->flFlags );
      WriteVar2File( hTmp, lpMFD->nPosition );
      WriteStr2File( hTmp, lpMFD->lpszPathName );
      WriteStr2File( hTmp, lpMFD->lpszFileName );

      Assert( lpMFD->lpFileType == NULL );
   }
#ifdef DEBUG
   WriteStr2File( hTmp, szTmpFile );
#endif

   if ( hTmp != NULL && hTmp != HFILE_ERROR )
      _lclose( hTmp );

   // Execute MSIMN.EXE
   //
   char  szFmt[256], szCmd[256];
   LPSTR  szLastDirSep = NULL;

   if ( GetModuleFileName( g_hInst, szFmt, sizeof( szFmt ) ) == 0 )
      return( MAPI_E_FAILURE );
   for ( LPSTR szPtr = szFmt;  *szPtr != '\0';  szPtr = AnsiNext( szPtr ) )
      if ( *szPtr == '\\' )
         szLastDirSep = szPtr;
   if ( szLastDirSep == NULL )
      return( MAPI_E_FAILURE );
   StrCpyN( szLastDirSep+1, s_cszMailMsgCmd, ARRAYSIZE(szFmt)-(szLastDirSep-szFmt)-1);
   wnsprintf( szCmd, ARRAYSIZE(szCmd), szFmt, szTmpFile );

   return( ( WinExec( szCmd, SW_SHOW ) < 32 ) ? MAPI_E_FAILURE : SUCCESS_SUCCESS );
}


HRESULT  HandleMailMsg( LPSTR szCmd )
{
   OFSTRUCT            of;
   HFILE               hTmp;
   ULONG               ulRet = MAPI_E_FAILURE;
   NCINFO              nci = { 0 };
   LPMIMEMESSAGE       pMsg = NULL;
   LPSTREAM            pStream = NULL;
   LPMIMEADDRESSTABLE  pAddrTable = NULL;
   HRESULT             hr;
   LPSTR               szText = NULL;
   lpMapiRecipDesc     lpMRD = NULL;
   lpMapiFileDesc      lpMFD = NULL;
   ULONG               ulTmp;
   BOOL                fBody = FALSE;

   // Open Tmp File
   //
   LPSTR  szSpace = strchr( szCmd, ' ' );
   if ( szSpace != NULL )
      *szSpace = '\0';
   hTmp = OpenFile( szCmd, &of, OF_READ );
   if ( hTmp == HFILE_ERROR )
      goto error;

   LHANDLE  lhSession;
   ULONG  ulUIParam;
   FLAGS  flFlags;
   ULONG  ulReserved;

   ReadVarFromFile( hTmp, lhSession );
   ReadVarFromFile( hTmp, ulUIParam );
   ReadVarFromFile( hTmp, flFlags );
   ReadVarFromFile( hTmp, ulReserved );

   hr = HrCreateMessage( &pMsg );
   if ( FAILED( hr ) )
      goto error;

   nci.ntNote = ntSendNote;
   nci.dwFlags = NCF_SENDIMMEDIATE | NCF_MODAL;
   nci.pMsg = pMsg;
   nci.hwndOwner = (HWND)ulUIParam;

   ReadVarFromFile( hTmp, ulTmp );

   // set the subject on the message
   szText = ReadStrFromFile( hTmp );
   if ( szText != NULL )
   {
      hr = MimeOleSetBodyPropA( pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT),
                                NOFLAGS, szText );
      if ( FAILED( hr ) )
         goto error;
      FreeMemSafe( szText );
   }

   // set the body on the message
   szText = ReadStrFromFile( hTmp );
   if ( szText != NULL )
   {
      if ( szText[0] != '\0' )
      {
         fBody = TRUE;
         hr = MimeOleCreateVirtualStream( &pStream );
         if ( FAILED( hr ) )
            goto error;
         hr = pStream->Write( szText, lstrlen( szText ), NULL );
         if ( FAILED( hr ) )
            goto error;
         hr = pMsg->SetTextBody( TXT_PLAIN, IET_DECODED, NULL, pStream, NULL );
         if ( FAILED( hr ) )
            goto error;
      }
      FreeMemSafe( szText );
   }

   // ignore lpMessage->lpszMessageType
   szText = ReadStrFromFile( hTmp );
   FreeMemSafe( szText );
   // ignore lpMessage->lpszDateReceived
   szText = ReadStrFromFile( hTmp );
   FreeMemSafe( szText );
   // ignore lpMessage->lpszConversationID
   szText = ReadStrFromFile( hTmp );
   FreeMemSafe( szText );
   // ignore lpMessage->flFlags
   ReadVarFromFile( hTmp, ulTmp );
   // ignore lpMessage->lpOriginator
   lpMRD = ReadMRDFromFile( hTmp );
   FreeMRDSafe( lpMRD );

   // set the recipients on the message
   ReadVarFromFile( hTmp, ulTmp );
   if ( ulTmp > 0 )
   {
      hr = pMsg->GetAddressTable( &pAddrTable );
      if ( FAILED( hr ) )
         goto error;
      for ( ULONG i = 0;  i < ulTmp;  i++ )
      {
         lpMRD = ReadMRDFromFile( hTmp );
         hr = pAddrTable->Append( MapiRecipToMimeOle( lpMRD->ulRecipClass ),
                                  IET_DECODED,
                                  lpMRD->lpszName, lpMRD->lpszAddress, NULL );
         if ( FAILED( hr ) )
            goto error;
         FreeMRDSafe( lpMRD );
      }
   }

   // set the attachments on the message
   ReadVarFromFile( hTmp, ulTmp );
   if ( ulTmp > 0 )
   {
      lpMFD = ReadMFDFromFile( hTmp );
      // special case: no body & one .HTM file - inline the HTML
      if ( fBody && ulTmp == 1 &&
           ( ( lpMFD->flFlags & ( MAPI_OLE | MAPI_OLE_STATIC ) ) == 0 ) &&
           FIsHTMLFile( lpMFD->lpszPathName ) )
      {
         Assert( pStream == NULL );
         hr = CreateStreamOnHFile( lpMFD->lpszPathName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL,
                                   &pStream );
         if ( FAILED( hr ) )
            goto error;
         hr = pMsg->SetTextBody( TXT_HTML, IET_DECODED, NULL, pStream, NULL );
         if ( FAILED( hr ) )
            goto error;
         nci.ntNote = ntWebPage;
      }
      else
      {
         for ( ULONG i = 0;  i < ulTmp;  i++ )
         {
            if ( i > 0 )
            {
               FreeMFDSafe( lpMFD );
               lpMFD = ReadMFDFromFile( hTmp );
            }

            // $BUGBUG - should we error this out, or send anyway?
            if ( lpMFD->flFlags & MAPI_OLE )
               continue;
            if ( lpMFD->lpszPathName != NULL && lpMFD->lpszPathName[0] != '\0' )
            {
               hr = pMsg->AttachFile( lpMFD->lpszPathName, NULL, NULL );
               if ( FAILED( hr ) )
                  goto error;
            }
         }
         FreeMFDSafe( lpMFD );
      }
   }
#ifdef DEBUG
   {
   LPSTR  szTmpFile = ReadStrFromFile( hTmp );
   free( szTmpFile );
   }
#endif

   // this is redundant, but need to close file before opening Note window
   if ( hTmp != NULL && hTmp != HFILE_ERROR )
   {
      _lclose( hTmp );
      hTmp = NULL;
   }

   if ( Initialize_RunDLL( TRUE ) )
   {
      hr = HrCreateNote( &nci );
      if ( SUCCEEDED( hr ) )
         ulRet = SUCCESS_SUCCESS;
      Uninitialize_RunDLL();
   }

error:
   if ( hTmp != NULL && hTmp != HFILE_ERROR )
      _lclose( hTmp );
   OpenFile( szCmd, &of, OF_DELETE );

   FreeMemSafe( szText );
   FreeMRDSafe( lpMRD );
   FreeMFDSafe( lpMFD );
   if ( pMsg )
      pMsg->Release();
   if ( pAddrTable )
      pAddrTable->Release();
   if ( pStream )
      pStream->Release();

   if ( FAILED( ulRet ) )
      AthMessageBoxW( GetDesktopWindow(),
                     MAKEINTRESOURCEW( idsAthenaMail ),
                     MAKEINTRESOURCEW( idsMailRundllFailed ),
                     0,
                     MB_ICONEXCLAMATION | MB_OK );
   return( ulRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\httptask.cpp ===
// --------------------------------------------------------------------------------
// h t t p t a s k . h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg S. Friedman
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "httptask.h"
#include "taskutil.h"
#include "acctcach.h"
#include "xputil.h"
#include "useragnt.h"
#include "..\http\httputil.h"

// --------------------------------------------------------------------------------
// Data Types
// --------------------------------------------------------------------------------
typedef enum tagHTTPEVENTTYPE
{ 
    EVENT_HTTPSEND
} HTTPEVENTTYPE;

#define CURRENTHTTPEVENT  ((LPHTTPEVENTINFO)m_psaEvents->GetItemAt(m_iEvent))

//----------------------------------------------------------------------
// FreeNewMessageInfo
//----------------------------------------------------------------------
static void __cdecl _FreeHTTPEventInfo(LPVOID pei)
{
    Assert(NULL != pei);
    SafeMemFree(pei);
}

// --------------------------------------------------------------------------------
// CHTTPTask::CHTTPTask
// --------------------------------------------------------------------------------
CHTTPTask::CHTTPTask(void) :
    m_cRef(1),
    m_dwFlags(NOFLAGS),
    m_dwState(NOFLAGS),
    m_cbTotal(0),
    m_cbSent(0),
    m_cbStart(0),
    m_cCompleted(0),
    m_wProgress(0),
    m_pSpoolCtx(NULL),
    m_pAccount(NULL),
    m_pOutbox(NULL),
    m_pSentItems(NULL),
    m_psaEvents(NULL),
    m_iEvent(0),
    m_pszSubject(NULL),
    m_pBody(NULL),
    m_pTransport(NULL),
    m_pUI(NULL),
    m_idSendEvent(INVALID_EVENT),
    m_pszAccountId(NULL),
    m_pszSendMsgUrl(NULL)
{
    InitializeCriticalSection(&m_cs);

    ZeroMemory(&m_rServer, sizeof(m_rServer));
}

// --------------------------------------------------------------------------------
// CHTTPTask::~CHTTPTask
// --------------------------------------------------------------------------------
CHTTPTask::~CHTTPTask(void)
{
    ZeroMemory(&m_rServer, sizeof(m_rServer));        // Done for security.
    _Reset();
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPTask::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerTask *)this;
    else if (IID_ISpoolerTask == riid)
        *ppv = (ISpoolerTask *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPTask::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CHTTPTask::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPTask::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// ---------------------------------------------------------------------------
// ISpoolerTask Methods
// ---------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPTask::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Invalid Arg
    if (NULL == pBindCtx)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Save the Activity Flags - DELIVER_xxx
    m_dwFlags = dwFlags;

    // Hold onto the bind context
    Assert(NULL == m_pSpoolCtx);
    m_pSpoolCtx = pBindCtx;
    m_pSpoolCtx->AddRef();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::BuildEvents
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::BuildEvents(ISpoolerUI *pSpoolerUI, 
                                    IImnAccount *pAccount, 
                                    FOLDERID idFolder)
{
    HRESULT         hr = S_OK;
    HROWSET	        hRowset=NULL;
    MESSAGEINFO     mi = {0};
    CHAR            szAccount[CCHMAX_ACCOUNT_NAME];
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    CHAR            szMessage[255];
    CHAR            szRes[255];
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    LPSTR           pszUserAgent = GetOEUserAgentString();
    LPSTR           pszCachedPass = NULL;
    FOLDERID        idServer;

    // Invalid Arg
    if (NULL == pSpoolerUI || NULL == pAccount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Get the Account Name
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount)));
    
    // Get the account ID
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));
    m_pszAccountId = PszDupA(szAccountId);

    // Get the outbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&m_pOutbox));

    // Get the sent items. Don't fail if it doesn't exist.
    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        if (SUCCEEDED(g_pStore->FindServerId(m_pszAccountId, &idServer)))
            g_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_SENT, &m_pSentItems);
    }

    // Create a Rowset
    CHECKHR(hr = m_pOutbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

	// Loop
	while (S_OK == m_pOutbox->QueryRowset(hRowset, 1, (LPVOID *)&mi, NULL))
	{
        CHECKHR(hr = _HrAppendOutboxMessage(szAccount, &mi));

        // Free Current
        m_pOutbox->FreeRecord(&mi);
    } 

    if (NULL == m_psaEvents || 0 == m_psaEvents->GetLength())
        goto exit;

    // create the transport object
    CHECKHR(hr = CoCreateInstance(CLSID_IHTTPMailTransport, NULL, CLSCTX_INPROC_SERVER, IID_IHTTPMailTransport, (LPVOID *)&m_pTransport));

    // Init the Transport
    CHECKHR(hr = m_pTransport->InitNew(pszUserAgent, NULL, this));

    // Fill an INETSERVER structure from the account object
    CHECKHR(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rServer));

    // looked for a cached password and, if one exists, use it
    GetAccountPropStrA(m_pszAccountId, CAP_PASSWORD, &pszCachedPass);
    if (NULL != pszCachedPass)
        StrCpyN(m_rServer.szPassword, pszCachedPass, sizeof(m_rServer.szPassword));

    // connect to the server. the transport won't
    // actually connect until a command is issued
    CHECKHR(hr = m_pTransport->Connect(&m_rServer, TRUE, FALSE));

    LOADSTRING(IDS_SPS_SMTPEVENT, szRes);
    wnsprintf(szMessage, ARRAYSIZE(szMessage), szRes, m_psaEvents->GetLength(), m_rServer.szAccount);

    CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, EVENT_HTTPSEND, m_pAccount, &m_idSendEvent));

    // If this account is set to always prompt for password and password isn't
    // already cached, show UI so we can prompt user for password
    if (ISFLAGSET(m_rServer.dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) && NULL == pszCachedPass)
    {
        m_pUI->ShowWindow(SW_SHOW);
    }

exit:
    // Cleanup
    SafeMemFree(pszUserAgent);
    SafeMemFree(pszCachedPass);

    if (m_pOutbox)
    {
        m_pOutbox->CloseRowset(&hRowset);
        m_pOutbox->FreeRecord(&mi);
    }

    LeaveCriticalSection(&m_cs);

    return hr;
}
    
// --------------------------------------------------------------------------------
// CHTTPTask::Execute
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    HRESULT hr = E_FAIL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    if (EVENT_HTTPSEND == dwTwinkie)
        hr = _HrExecuteSend(eid, dwTwinkie);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::CancelEvent
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::Cancel(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    m_dwState |= HTTPSTATE_CANCELED;

    // Simply drop the connection
    if (m_pTransport)    
        m_pTransport->DropConnection();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::IsDialogMessage(LPMSG pMsg)
{
    return S_FALSE;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnFlagsChanged
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnFlagsChanged(DWORD dwFlags)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnLogonPrompt(
                                LPINETSERVER            pInetServer,
                                IInternetTransport     *pTransport)
{
    HRESULT     hr = S_OK;
    LPSTR       pszCachedPass = NULL;

    EnterCriticalSection(&m_cs);
    // pull password out of the cache
    GetAccountPropStrA(m_pszAccountId, CAP_PASSWORD, &pszCachedPass);
    if (NULL != pszCachedPass && 0 != lstrcmp(pszCachedPass, pInetServer->szPassword))
    {
        StrCpyN(pInetServer->szPassword, pszCachedPass, ARRAYSIZE(pInetServer->szPassword));
        goto exit;
    }

    if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
    {
        hr = S_FALSE;
        goto exit;
    }

    hr = TaskUtil_OnLogonPrompt(m_pAccount, m_pUI, NULL, pInetServer, AP_HTTPMAIL_USERNAME, 
                                AP_HTTPMAIL_PASSWORD, AP_HTTPMAIL_PROMPT_PASSWORD, TRUE);
    
    // cache the password
    if (S_OK == hr)
        HrCacheAccountPropStrA(m_pszAccountId, CAP_PASSWORD, pInetServer->szPassword);
    
exit:
    LeaveCriticalSection(&m_cs);
    SafeMemFree(pszCachedPass);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CHTTPTask::OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    // Locals
    EVENTCOMPLETEDSTATUS tyEventStatus = EVENT_SUCCEEDED;

    // Invalid State
    Assert(m_pUI && m_pSpoolCtx);
    if (!m_pUI || !m_pSpoolCtx)
    {
        return E_FAIL;
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Feed the the IXP status to the UI object
    m_pUI->SetSpecificProgress(MAKEINTRESOURCE(XPUtil_StatusToString(ixpstatus)));

    // Disconnected
    if (ixpstatus == IXP_DISCONNECTED)
    {
        HRESULT hrDisconnect = _OnDisconnectComplete();
        
        // TODO: update progress state and deal with errors

        // Set the animation
        m_pUI->SetAnimation(idanOutbox, FALSE);

        if (!ISFLAGSET(m_dwState, HTTPSTATE_EVENTSUCCESS) || (NULL != m_cCompleted && m_cCompleted < m_psaEvents->GetLength()))
        {
            if (ISFLAGSET(m_dwState, HTTPSTATE_CANCELED))
                tyEventStatus = EVENT_CANCELED;
            else if (ISFLAGSET(m_dwState, HTTPSTATE_EVENTSUCCESS))
                tyEventStatus = EVENT_WARNINGS;
            else
                tyEventStatus = EVENT_FAILED;
        }

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

        // Hands Off my callback
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);

        // This task is complete
        m_pSpoolCtx->EventDone(m_idSendEvent, tyEventStatus);
    }

    LeaveCriticalSection(&m_cs);

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport)

{
    return E_NOTIMPL;
}
// --------------------------------------------------------------------------------
// CHTTPTask::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// IHTTPMailCallback methods
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
// CHTTPTask::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnResponse(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT     hr = S_OK;
    HRESULT     hrCatch;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // if the send message url couldn't be retrieved, convert the error into
    // a more informative error code.
    if (SP_E_HTTP_SERVICEDOESNTWORK == pResponse->rIxpResult.hrResult)
    {
        _CatchResult(SP_E_HTTP_NOSENDMSGURL);
        goto exit;
    }
    
        // Handle the Error
    if (TASKRESULT_SUCCESS != _CatchResult(&pResponse->rIxpResult))
        goto exit;

    switch (pResponse->command)
    {
        case HTTPMAIL_GETPROP:
            if (SUCCEEDED(_HrAdoptSendMsgUrl(pResponse->rGetPropInfo.pszProp)))
            {
                pResponse->rGetPropInfo.pszProp = NULL;
                // build the message and post it
                hr = _HrPostCurrentMessage();
            }
            break;

        case HTTPMAIL_SENDMESSAGE:
            _UpdateSendMessageProgress(pResponse);
            if (pResponse->fDone)
                _CatchResult(_HrFinishCurrentEvent(S_OK, pResponse->rSendMessageInfo.pszLocation));
            break;

        default:
            Assert(FALSE);
            break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::GetParentWindow
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::GetParentWindow(HWND *phwndParent)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// Private Implementation
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
// CHTTPTask::_Reset
// --------------------------------------------------------------------------------
void CHTTPTask::_Reset(void)
{
    SafeRelease(m_pSpoolCtx);
    SafeRelease(m_pAccount);
    SafeRelease(m_pOutbox);
    SafeRelease(m_pSentItems);

    delete m_psaEvents;
    m_iEvent = 0;

    SafeMemFree(m_pszSubject);

    SafeRelease(m_pBody);

    SafeRelease(m_pTransport);
    SafeRelease(m_pUI);

    SafeMemFree(m_pszAccountId);
    SafeMemFree(m_pszSendMsgUrl);
}

// --------------------------------------------------------------------------------
// CHTTPTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CHTTPTask::_CatchResult(HRESULT hr)
{
    // Locals
    IXPRESULT   rResult;

    // Build an IXPRESULT
    ZeroMemory(&rResult, sizeof(rResult));
    rResult.hrResult = hr;

    // Get the HTTPMail Result Type
    return _CatchResult(&rResult);
}

// --------------------------------------------------------------------------------
// CHTTPTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CHTTPTask::_CatchResult(LPIXPRESULT pResult)
{
    HWND            hwndParent;
    TASKRESULTTYPE  tyTaskResult = TASKRESULT_FAILURE;

    // If Succeeded
    if (SUCCEEDED(pResult->hrResult))
        return TASKRESULT_SUCCESS;

    // Get Window
    if (NULL == m_pUI || FAILED(m_pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    // Process generic protocol error
    tyTaskResult = TaskUtil_FBaseTransportError(IXP_HTTPMail, m_idSendEvent, pResult, &m_rServer, m_pszSubject, m_pUI,
                                                !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

    // Have a Transport
    if (m_pTransport)
    {
        // If Task Failure, drop the connection
        if (TASKRESULT_FAILURE == tyTaskResult)
        {
            // Roast the current connection
            m_pTransport->DropConnection();
        }

        // If Event Failure...
        else if (TASKRESULT_EVENTFAILED == tyTaskResult)
        {
            // Goto Next Event
            if (FAILED(_HrFinishCurrentEvent(pResult->hrResult, NULL)))
            {
                // Roast the current connection
                m_pTransport->DropConnection();
            }
        }
    }

    return tyTaskResult;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrAppendOutboxMessage
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pmi)
{
    HRESULT         hr = S_OK;
    IImnAccount     *pAccount = NULL;
    LPHTTPEVENTINFO pEvent = NULL;

    Assert(NULL != pszAccount && NULL != pmi);

    // handle empty account id
    if (NULL == pmi->pszAcctId || FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pmi->pszAcctId, &pAccount)))
    {
        // do some special junk with default accounts
        goto exit;
    }
    else if (lstrcmpi(pmi->pszAcctName, pszAccount) != 0)
        goto exit;

    if (NULL == m_psaEvents)
        CHECKHR(hr = CSortedArray::Create(NULL, _FreeHTTPEventInfo, &m_psaEvents));

    // build the event object and append it into the event array
    if (!MemAlloc((void **)&pEvent, sizeof(HTTPEVENTINFO)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    CHECKHR(hr = m_psaEvents->Add(pEvent));

    pEvent->idMessage = pmi->idMessage;
    pEvent->fComplete = FALSE;

    m_cbTotal += (pmi->cbMessage + 175);
    pEvent->cbSentTotal = m_cbTotal;    // running total

    pEvent = NULL;

exit:
    SafeMemFree(pEvent);
    SafeRelease(pAccount);

    return hr;
}


// --------------------------------------------------------------------------------
// CHTTPTask::_HrCreateSendProps
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrCreateSendProps(IMimeMessage *pMessage,
                                      LPSTR *ppszFrom,
                                      LPHTTPTARGETLIST *ppTargets)
{
    HRESULT                 hr = S_OK;
    IMimeAddressTable       *pAdrTable = NULL;
    IMimeEnumAddressTypes   *pAdrEnum = NULL;
    ADDRESSPROPS            rAddress;
    ULONG                   c;
    LPSTR                   pszFrom = NULL;
    LPSTR                   pszTemp = NULL;
    LPHTTPTARGETLIST        pTargets = NULL;
    DWORD                   dwTargetCapacity = 0;

    Assert(NULL != ppszFrom && NULL != ppTargets);
    if (NULL == ppszFrom || NULL == ppTargets)
        return E_INVALIDARG;

    *ppszFrom = NULL;
    *ppTargets = NULL;
    
    // allocate a targetlist
    if (!MemAlloc((void **)&pTargets, sizeof(HTTPTARGETLIST)))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    pTargets->cTarget = 0;
    pTargets->prgTarget = NULL;

    ZeroMemory(&rAddress, sizeof(rAddress));

    // Get the recipients...
    CHECKHR(hr = pMessage->GetAddressTable(&pAdrTable));

    // Get Enumerator
    CHECKHR(hr = pAdrTable->EnumTypes(IAT_KNOWN, IAP_ADRTYPE | IAP_EMAIL, &pAdrEnum));

    // Walk the enumerator
    while (SUCCEEDED(pAdrEnum->Next(1, &rAddress, &c)) && c == 1)
    {
        if (NULL != rAddress.pszEmail)
        {
            // Get Type
            if (ISFLAGSET(IAT_RECIPS, rAddress.dwAdrType))
            {
                // copy the address
                pszTemp = PszDupA(rAddress.pszEmail);
                if (NULL == pszTemp)
                {
                    hr = TraceResult(E_OUTOFMEMORY);
                    goto exit;
                }

                // add it to the collection of addresses we are building
                if (pTargets->cTarget == dwTargetCapacity)
                {
                    if (!MemRealloc((void **)&pTargets->prgTarget, (dwTargetCapacity + 4) * sizeof(LPSTR)))
                    {
                        hr = TraceResult(E_OUTOFMEMORY);
                        goto exit;
                    }
                    dwTargetCapacity += 4;
                }

                pTargets->prgTarget[pTargets->cTarget++] = pszTemp;
                pszTemp = NULL;

            }
            else if (NULL == pszFrom && IAT_FROM == rAddress.dwAdrType)
            {
                pszFrom = PszDupA(rAddress.pszEmail);
                if (NULL == pszFrom)
                {
                    hr = TraceResult(E_OUTOFMEMORY);
                    goto exit;
                }
            }
        }

        // Release
        g_pMoleAlloc->FreeAddressProps(&rAddress);
    }

    // success. transfer ownership of the params to the caller
    *ppszFrom = pszFrom;
    pszFrom = NULL;
    *ppTargets = pTargets;
    pTargets = NULL;

exit:
    if (pTargets)
        Http_FreeTargetList(pTargets);
    SafeMemFree(pszTemp);
    SafeRelease(pAdrTable);
    SafeRelease(pAdrEnum);
    SafeMemFree(pszFrom);

    return hr;
}

// ------------------------------------------------------------------------------------
// CHTTPTask::_HrOpenMessage
// ------------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrOpenMessage(MESSAGEID idMessage, IMimeMessage **ppMessage)
{
    // Locals
    HRESULT         hr=S_OK;

    // Check Params
    Assert(ppMessage && m_pOutbox);

    // Init
    *ppMessage = NULL;

    // Stream in message
    CHECKHR(hr = m_pOutbox->OpenMessage(idMessage, OPEN_MESSAGE_SECURE, ppMessage, NOSTORECALLBACK));

    // remove an X-Unsent headers before sending
    (*ppMessage)->DeleteBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT));

exit:
    // Failure
    if (FAILED(hr))
        SafeRelease((*ppMessage));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrPostCurrentMessage
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrPostCurrentMessage(void)
{
    HRESULT             hr = S_OK;
    IMimeMessage        *pMessage = NULL;
    LPHTTPEVENTINFO     pEvent = NULL;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    LPSTR               pszFrom = NULL;
    LPHTTPTARGETLIST    pTargets = NULL;

    Assert(NULL != m_psaEvents);
    Assert(m_iEvent <= m_psaEvents->GetLength());

    pEvent = CURRENTHTTPEVENT;
    Assert(NULL != pEvent);

    LOADSTRING(IDS_SPS_SMTPPROGRESS, szRes);
    wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_iEvent + 1, m_psaEvents->GetLength());

    // Set Specific Progress
    m_pUI->SetSpecificProgress(szMsg);

    // Open Store Message
    if (FAILED(_HrOpenMessage(pEvent->idMessage, &pMessage)))
    {
        hr = TrapError(SP_E_SMTP_CANTOPENMESSAGE);
        goto exit;
    }

    CHECKHR(hr = _HrCreateSendProps(pMessage, &pszFrom, &pTargets));

    CHECKHR(hr = pMessage->GetMessageSource(&m_pBody, 0));

    hr = m_pTransport->SendMessage(m_pszSendMsgUrl, pszFrom, pTargets, DwGetOption(OPT_SAVESENTMSGS), m_pBody, 0);

exit:
    SafeRelease(pMessage);
    SafeMemFree(pszFrom);
    if (pTargets)
        Http_FreeTargetList(pTargets);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrExecuteSend
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrExecuteSend(EVENTID eid, DWORD_PTR dwTwinkie)
{
    HRESULT     hr = S_OK;
    LPSTR       pszSendMsgUrl = NULL;
    CHAR        szRes[CCHMAX_RES];
    CHAR        szBuf[CCHMAX_RES + CCHMAX_SERVER_NAME];


        // Set the animation
    m_pUI->SetAnimation(idanOutbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    // Connecting to ...
    LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CONNECTING, 0);

    Assert(NULL == m_pszSendMsgUrl);

    // look for the sendmsg url in the cache
    if (!GetAccountPropStrA(m_pszAccountId, CAP_HTTPMAILSENDMSG, &m_pszSendMsgUrl))
    {
        hr = m_pTransport->GetProperty(HTTPMAIL_PROP_SENDMSG, &pszSendMsgUrl);
        if (E_PENDING == hr)
        {
            hr = S_OK;
            goto exit;
        }
        CHECKHR(hr);
        CHECKHR(hr = _HrAdoptSendMsgUrl(pszSendMsgUrl));
    }

    Assert(NULL != m_pszSendMsgUrl);

    CHECKHR(hr = _HrPostCurrentMessage());

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrAdoptSendMsgUrl
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrAdoptSendMsgUrl(LPSTR pszSendMsgUrl)
{
    Assert(NULL == m_pszSendMsgUrl);

    if (NULL == pszSendMsgUrl)
        return E_INVALIDARG;

    m_pszSendMsgUrl = pszSendMsgUrl ;

    // add it to the account data cache
    HrCacheAccountPropStrA(m_pszAccountId, CAP_HTTPMAILSENDMSG, m_pszSendMsgUrl);

    return S_OK;
}


// --------------------------------------------------------------------------------
// CHTTPTask::_HrFinishCurrentEvent
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrFinishCurrentEvent(HRESULT hrResult, LPSTR pszLocationUrl)
{
    // Locals
    HRESULT             hr = S_OK;
    LPHTTPEVENTINFO     pEvent;
    MESSAGEID           idMessage;

    if (FAILED(hrResult))
        goto exit;

    // save in sent items
    if (m_pSentItems && m_pBody && pszLocationUrl)
    {
        // add the message to the sent items folder
        CHECKHR(hr = Http_AddMessageToFolder(m_pSentItems, m_pszAccountId, NULL, ARF_READ, pszLocationUrl, &idMessage));
        
        // write the message body out
        CHECKHR(hr = Http_SetMessageStream(m_pSentItems, idMessage, m_pBody, NULL, TRUE));
    }

    // Get the current http event
    pEvent = CURRENTHTTPEVENT;

    pEvent->fComplete = TRUE;
    m_dwState |= HTTPSTATE_EVENTSUCCESS;

    ++m_cCompleted;

exit:
    // go to the next event
    hr = _HrStartNextEvent();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrStartNextEvent
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrStartNextEvent(void)
{
    // Locals
    HRESULT     hr = S_OK;

    // free the previous subject
    SafeMemFree(m_pszSubject);

    // free the previous body
    SafeRelease(m_pBody);

    // Fixup m_cbSent to be correct
    m_cbSent = (CURRENTHTTPEVENT)->cbSentTotal;
    m_cbStart = m_cbSent;

    // Are we done yet ?
    if (m_iEvent + 1 == m_psaEvents->GetLength())
    {
        // Update progress
        _DoProgress();

        // Disconnect from the server
        CHECKHR(hr = m_pTransport->Disconnect());
    }

    // otherwise, increment the event count and send the next message
    else
    {
        // Next Event
        m_iEvent++;

        // Update progress
        //_DoProgress();
        // Send Reset Command
        hr = _HrPostCurrentMessage();
        if (hr == E_PENDING)
            hr = S_OK;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_OnDisconnectComplete
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_OnDisconnectComplete(void)
{
    // Locals
    HRESULT             hr = S_OK;
    LPDWORD             prgdwIds = NULL;
    DWORD               cIdsAlloc = 0;
    DWORD               i;
    LPHTTPEVENTINFO     pEvent;
    ADJUSTFLAGS         Flags;
    DWORD               cEvents;
    MESSAGEIDLIST       rList;

    rList.cMsgs = 0;
    rList.prgidMsg = NULL;

    // Invalid State
    Assert(m_pOutbox);
    Assert(m_psaEvents);

    cEvents = m_psaEvents->GetLength();

    // Walk through the list of events
    for (i=0; i < cEvents; i++)
    {
        // Readability
        pEvent = (LPHTTPEVENTINFO)m_psaEvents->GetItemAt(i);

        // If this event was in the outbox
        if (0 != pEvent->idMessage && pEvent->fComplete)
        {
            // Insert into my array of message ids
            if (rList.cMsgs + 1 > cIdsAlloc)
            {
                // Realloc
                CHECKHR(hr = HrRealloc((LPVOID *)&rList.prgidMsg, sizeof(DWORD) * (cIdsAlloc + 10)));

                // Increment cIdsAlloc
                cIdsAlloc += 10;
            }

            // Set Message Id
            rList.prgidMsg[rList.cMsgs++] = pEvent->idMessage;
        }
    }

    if (rList.cMsgs)
    {
        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;

        if (m_idSendEvent != INVALID_EVENT)
        {
            // Delete the messages.
            // Messages are never copied to the local outbox for httpmail
            CHECKHR(hr = m_pOutbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &rList, NULL, NOSTORECALLBACK));
        }
        else
        {
            // Raid-7639: OE sends message over and over when runs out of disk space.
            m_pOutbox->SetMessageFlags(&rList, &Flags, NULL, NOSTORECALLBACK);
        }
    }

exit:
    // Cleanup
    SafeMemFree(rList.prgidMsg);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_UpdateSendMessageProgress
// --------------------------------------------------------------------------------
void CHTTPTask::_UpdateSendMessageProgress(LPHTTPMAILRESPONSE pResponse)
{
    // the transport is attempting to resend the stream..
    // reset our progress indicator
    if (pResponse->rSendMessageInfo.fResend)
    {
        m_cbSent = m_cbStart;
    }
    else
    {
        // Increment Status
        m_cbSent += pResponse->rSendMessageInfo.cbIncrement;
    }

     // Do Progress
    _DoProgress();
}

// --------------------------------------------------------------------------------
// CHTTPTask::_DoProgress
// --------------------------------------------------------------------------------
void CHTTPTask::_DoProgress(void)
{
    // Locals
    WORD            wProgress = 0;
    WORD            wDelta;

    // Invalid Arg
    Assert(m_cbTotal > 0 && m_pUI);

    if (m_cbSent > 0)
    {
        // Compute Current Progress Index
        wProgress = (WORD)((m_cbSent * 100) / m_cbTotal);

        // Compute Delta
        wDelta = wProgress - m_wProgress;

        // Progress Delta
        if (wDelta > 0)
        {
            // Incremenet Progress
            m_pUI->IncrementProgress(wDelta);

            // Increment my wProgress
            m_wProgress += wDelta;

            // Don't go over 100 percent
            Assert(m_wProgress <= 100);
        }
    }
    else if (m_wProgress != 0)
    {
        m_pUI->SetProgressPosition(0);
        m_wProgress = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\httptask.h ===
// --------------------------------------------------------------------------------
// h t t p t a s k . h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg S. Friedman
// --------------------------------------------------------------------------------
#ifndef __HTTPTASK_H
#define __HTTPTASK_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "srtarray.h"
#include "taskutil.h"

// --------------------------------------------------------------------------------
// State
// --------------------------------------------------------------------------------
#define HTTPSTATE_CANCELED      FLAG01
#define HTTPSTATE_EVENTSUCCESS  FLAG02  // one or more events succeeded

// --------------------------------------------------------------------------------
// HTTPEVENTINFO
// --------------------------------------------------------------------------------
typedef struct tagHTTPEVENTINFO {
    DWORD               dwFlags;                // Flags
    MESSAGEID           idMessage;              // Store Information
    BOOL                fComplete;              // has event been completed
    DWORD               cbSentTotal;            // running total of sent bytes
} HTTPEVENTINFO, *LPHTTPEVENTINFO;

// --------------------------------------------------------------------------------
// CHTTPTask
// --------------------------------------------------------------------------------
class CHTTPTask: public ISpoolerTask, IHTTPMailCallback
{
public:
    // ----------------------------------------------------------------------------
    // CHTTPTask
    // ----------------------------------------------------------------------------
    CHTTPTask(void);
private:
    ~CHTTPTask(void);
    
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // ---------------------------------------------------------------------------
    // ISpoolerTask
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) { return TrapError(E_NOTIMPL); }
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) { return TrapError(E_NOTIMPL); }
    STDMETHODIMP Cancel(void);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // IHTTPMailCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(LPHTTPMAILRESPONSE pResponse);

    STDMETHODIMP GetParentWindow(HWND *phwndParent);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    void _Reset(void);

    TASKRESULTTYPE _CatchResult(HRESULT hr);
    TASKRESULTTYPE _CatchResult(LPIXPRESULT pResult);

    HRESULT _HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pmi);
    HRESULT _HrCreateSendProps(IMimeMessage *pMessage, LPSTR *ppszFrom, LPHTTPTARGETLIST *ppTargets);
    HRESULT _HrCreateHeaderStream(IMimeMessage *pMessage, IStream **ppStream);
    HRESULT _HrOpenMessage(MESSAGEID idMessage, IMimeMessage **ppMessage);
    HRESULT _HrPostCurrentMessage(void);
    HRESULT _HrExecuteSend(EVENTID eid, DWORD_PTR dwTwinkie);
    HRESULT _HrAdoptSendMsgUrl(LPSTR pszSendMsgUrl);
    HRESULT _HrFinishCurrentEvent(HRESULT hrResult, LPSTR pszLocationUrl);
    HRESULT _HrStartNextEvent(void);
    HRESULT _OnDisconnectComplete(void);
    void    _UpdateSendMessageProgress(LPHTTPMAILRESPONSE pResponse);
    void    _DoProgress(void);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                    m_cRef;             // Reference counting
    CRITICAL_SECTION        m_cs;               // thread safety
    DWORD                   m_dwFlags;          // flags
    DWORD                   m_dwState;          // state flags
    DWORD                   m_cbTotal;          // total bytes to send
    DWORD                   m_cbSent;           // number of bytes sent
    DWORD                   m_cbStart;          // number of bytes sent at event start
    long                    m_cCompleted;       // number of messages successfully sent
    WORD                    m_wProgress;        // Current progress index
    ISpoolerBindContext     *m_pSpoolCtx;       // spooler bind context
    IImnAccount             *m_pAccount;        // account
    IMessageFolder          *m_pOutbox;         // The outbox
    IMessageFolder          *m_pSentItems;      // Sent items folder
    CSortedArray            *m_psaEvents;       // array of queued events
    long                    m_iEvent;           // Current Event
    LPSTR                   m_pszSubject;       // subject of current message
    IStream                 *m_pBody;            // current message body
    IHTTPMailTransport      *m_pTransport;      // http data transport
    ISpoolerUI              *m_pUI;             // SpoolerUI
    EVENTID                 m_idSendEvent;      // EventId for message send
    INETSERVER              m_rServer;          // Server information
    LPSTR                   m_pszAccountId;     // Account Id
    LPSTR                   m_pszSendMsgUrl;    // Url to post outbound messages to
};

#endif // __HTTPTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\imaptask.cpp ===
//***************************************************************************
// IMAP4 Spooler Task Object
// Written by Raymond Cheng, 6/27/97
//***************************************************************************

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include "resource.h"
#include "imaptask.h"
#include "imnact.h"
#include "conman.h"
#include "imapfmgr.h"
#include "thormsgs.h"
#include "imaputil.h"
#include "xpcomm.h"
#include "ourguid.h"


//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------


//***************************************************************************
// Function: CIMAPTask (Constructor)
//***************************************************************************
CIMAPTask::CIMAPTask(void)
{
    m_lRefCount = 1;
    m_pBindContext = NULL;
    m_pSpoolerUI = NULL;
    m_szAccountName[0] = '\0';
    m_pszFolder = NULL;
    m_pIMAPFolderMgr = NULL;
    m_hwnd = NULL;
    m_CurrentEID = 0;
    m_fFailuresEncountered = FALSE;
    m_dwTotalTicks = 0;
    m_dwFlags = 0;
} // CIMAPTask (constructor)



//***************************************************************************
// Function: ~CIMAPTask (Destructor)
//***************************************************************************
CIMAPTask::~CIMAPTask(void)
{
    if (NULL != m_pIMAPFolderMgr) {
        m_pIMAPFolderMgr->Close();
        m_pIMAPFolderMgr->Release();
    }

    if (NULL != m_pSpoolerUI)
        m_pSpoolerUI->Release();

    if (NULL != m_pBindContext)
        m_pBindContext->Release();

    if (NULL != m_hwnd)
        DestroyWindow(m_hwnd);
} // ~CIMAPTask (destructor)



//***************************************************************************
// Function: QueryInterface
//
// Purpose:
//   Read the Win32SDK OLE Programming References (Interfaces) about the
// IUnknown::QueryInterface function for details. This function returns a
// pointer to the requested interface.
//
// Arguments:
//   REFIID iid [in] - an IID identifying the interface to return.
//   void **ppvObject [out] - if successful, this function returns a pointer
//     to the requested interface in this argument.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppvObject);

    // Init variables, arguments
    hrResult = E_NOINTERFACE;
    if (NULL == ppvObject)
        goto exit;

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid) {
        *ppvObject = (IUnknown *) this;
        ((IUnknown *) this)->AddRef();
    }

    if (IID_ISpoolerTask == iid) {
        *ppvObject = (ISpoolerTask *) this;
        ((ISpoolerTask *) this)->AddRef();
    }

    // If we returned an interface, return success
    if (NULL != *ppvObject)
        hrResult = S_OK;

exit:
    return hrResult;
} // QueryInterface



//***************************************************************************
// Function: AddRef
//
// Purpose:
//   This function should be called whenever someone makes a copy of a
// pointer to this object. It bumps the reference count so that we know
// there is one more pointer to this object, and thus we need one more
// release before we delete ourselves.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CIMAPTask::AddRef(void)
{
    Assert(m_lRefCount > 0);

    m_lRefCount += 1;

    DOUT ("CIMAPTask::AddRef, returned Ref Count=%ld", m_lRefCount);
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release
//
// Purpose:
//   This function should be called when a pointer to this object is to
// go out of commission. It knocks the reference count down by one, and
// automatically deletes the object if we see that nobody has a pointer
// to this object.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CIMAPTask::Release(void)
{
    Assert(m_lRefCount > 0);
    
    m_lRefCount -= 1;
    DOUT("CIMAPTask::Release, returned Ref Count = %ld", m_lRefCount);

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release

static const char c_szIMAPTask[] = "IMAP Task";

//***************************************************************************
// Function: Init
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::Init(DWORD dwFlags,
                                          ISpoolerBindContext *pBindCtx)
{
    WNDCLASSEX wc;
    HRESULT hrResult;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != pBindCtx);

    // Initialize variables
    hrResult = S_OK;

    // Save pBindCtx to module var
    m_pBindContext = pBindCtx;
    pBindCtx->AddRef();
    m_dwFlags = dwFlags;

    // Create a hidden window to process WM_IMAP_* messages
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szIMAPTask, &wc)) {
        wc.style            = 0;
        wc.lpfnWndProc      = IMAPTaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szIMAPTask;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    m_hwnd = CreateWindow(c_szIMAPTask, NULL, WS_POPUP, 10, 10, 10, 10,
                          GetDesktopWindow(), NULL, g_hInst, this);
    if (NULL == m_hwnd) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    return hrResult;
} // Init



//***************************************************************************
// Function: BuildEvents
// Purpose: ISpoolerTask implementation.
// Arguments:
//   LPCTSTR pszFolder [in] - currently this argument is taken to mean the
//     currently selected IMAP folder. Set this argument to NULL if no
//     IMAP folder is currently selected. This argument is used to avoid
//     polling the currently selected folder for its unread count.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::BuildEvents(ISpoolerUI *pSpoolerUI,
                                                 IImnAccount *pAccount,
                                                 LPCTSTR pszFolder)
{
    HRESULT hrResult;
    char szFmt[CCHMAX_STRINGRES], szEventDescription[CCHMAX_STRINGRES];
    EVENTID eidThrowaway;

    Assert(m_lRefCount > 0);
    Assert(NULL != pSpoolerUI);
    Assert(NULL != pAccount);

    // Copy spooler UI pointer
    m_pSpoolerUI = pSpoolerUI;
    pSpoolerUI->AddRef();

    // Find and save account name
    hrResult = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccountName,
        sizeof(m_szAccountName));
    if (FAILED(hrResult))
        goto exit;

    // Keep ptr to current folder name (we want to SKIP it during unread poll!)
    m_pszFolder = pszFolder;

#ifndef WIN16   // No RAS support in Win16
    // Create and initialize CIMAPFolderMgr to poll unread
    hrResult = g_pConMan->CanConnect(m_szAccountName);
    if (FAILED(hrResult))
        goto exit;
#endif
    
    m_pIMAPFolderMgr = new CIMAPFolderMgr(m_hwnd);
    if (NULL == m_pIMAPFolderMgr) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    hrResult = m_pIMAPFolderMgr->HrInit(m_szAccountName, 'i', fCREATE_FLDR_CACHE);
    if (FAILED(hrResult))
        goto exit;

    m_pIMAPFolderMgr->SetOnlineOperation(TRUE);
    m_pIMAPFolderMgr->SetUIMode(!(m_dwFlags & DELIVER_BACKGROUND));

    // This CIMAPFolderMgr is ready. Register our one and only event
    LoadString(g_hLocRes, IDS_SPS_POP3CHECKING, szFmt, ARRAYSIZE(szFmt));
    wnsprintf(szEventDescription, ARRAYSIZE(szEventDescription), szFmt, m_szAccountName);
    hrResult = m_pBindContext->RegisterEvent(szEventDescription, this, NULL,
        pAccount, &eidThrowaway);

    if (SUCCEEDED(hrResult))
        TaskUtil_CheckForPasswordPrompt(pAccount, SRV_IMAP, m_pSpoolerUI);

exit:
    return hrResult;
} // BuildEvents



//***************************************************************************
// Function: Execute
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::Execute(EVENTID eid, DWORD dwTwinkie)
{
    HRESULT hrResult;
    char szFmt[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    Assert(m_lRefCount > 0);
    Assert(NULL == dwTwinkie); // I'm not currently using this

    // Initialize progress indication
    m_pSpoolerUI->SetProgressRange(1);
    LoadString(g_hLocRes, IDS_SPS_POP3CHECKING, szFmt, ARRAYSIZE(szFmt));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szFmt, m_szAccountName);
    m_pSpoolerUI->SetGeneralProgress(szBuf);
    m_pSpoolerUI->SetAnimation(idanDownloadNews, TRUE);

    // Start the unread count poll
    Assert(NULL != m_pIMAPFolderMgr);
    hrResult = m_pIMAPFolderMgr->PollUnreadCounts(m_hwnd, m_pszFolder);
    if (FAILED(hrResult))
        goto exit;

    m_CurrentEID = eid;

exit:
    return hrResult;
} // Execute



//***************************************************************************
// Function: ShowProperties
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::ShowProperties(HWND hwndParent,
                                                    EVENTID eid,
                                                    DWORD dwTwinkie)
{
    Assert(m_lRefCount > 0);
    return E_NOTIMPL;
} // ShowProperties



//***************************************************************************
// Function: GetExtendedDetails
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::GetExtendedDetails(EVENTID eid,
                                                        DWORD dwTwinkie,
                                                        LPSTR *ppszDetails)
{
    Assert(m_lRefCount > 0);
    return E_NOTIMPL;
} // GetExtendedDetails



//***************************************************************************
// Function: Cancel
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::Cancel(void)
{
    Assert(m_lRefCount > 0);
    return m_pIMAPFolderMgr->Disconnect();
} // Cancel



//***************************************************************************
// Function: IsDialogMessage
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::IsDialogMessage(LPMSG pMsg)
{
    Assert(m_lRefCount > 0);
    return S_FALSE;
} // IsDialogMessage



//***************************************************************************
// Function: OnFlagsChanged
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::OnFlagsChanged(DWORD dwFlags)
{
    Assert(m_lRefCount > 0);
    m_dwFlags = dwFlags;

    if (m_pIMAPFolderMgr)
        m_pIMAPFolderMgr->SetUIMode(!(m_dwFlags & DELIVER_BACKGROUND));

    return S_OK;
} // OnFlagsChanged



//***************************************************************************
// Function: IMAPTaskWndProc
//
// Purpose:
//   This function handles WM_IMAP_* messages which result from polling for
// unread counts on the IMAP server. The various WM_IMAP_* messages are
// translated into spooler UI events to inform the user of the progress of
// the operation.
//***************************************************************************
LRESULT CALLBACK CIMAPTask::IMAPTaskWndProc(HWND hwnd, UINT uMsg,
                                            WPARAM wParam, LPARAM lParam)
{
    CIMAPTask *pThis = (CIMAPTask *) GetProp(hwnd, _T("this"));

    switch (uMsg) {
        case WM_CREATE:
            pThis = (CIMAPTask *) ((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetProp(hwnd, _T("this"), (LPVOID) pThis);
            return 0;

        case WM_IMAP_ERROR: {
            HRESULT hrResult;
            LPSTR pszErrorStr;

            pThis->m_fFailuresEncountered = TRUE;
            hrResult = ImapUtil_WMIMAPERRORToString(lParam, &pszErrorStr, NULL);
            if (FAILED(hrResult)) {
                AssertSz(FALSE, "Could not construct full error str for WM_IMAP_ERROR");
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID,
                    ((INETMAILERROR *)lParam)->pszMessage);
            }
            else {
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID,
                    pszErrorStr);
                MemFree(pszErrorStr);
            }
            return 0;
        } // case WM_IMAP_ERROR

        case WM_IMAP_SIMPLEERROR: {
            char sz[CCHMAX_STRINGRES];

            pThis->m_fFailuresEncountered = TRUE;
            Assert(0 == HIWORD(lParam)); // Can't handle two text strings
            LoadString(g_hLocRes, LOWORD(lParam), sz, ARRAYSIZE(sz));
            pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID, sz);
        } // case WM_IMAP_SIMPLEERROR
            return 0;

        case WM_IMAP_POLLUNREAD_DONE: {
            HRESULT hrResult;
            EVENTCOMPLETEDSTATUS ecs;

            Assert((0 == wParam || 1 == wParam) && 0 == lParam);
            ecs = EVENT_SUCCEEDED; // Let's be optimistic
            if (pThis->m_fFailuresEncountered) {
                char sz[CCHMAX_STRINGRES], szFmt[CCHMAX_STRINGRES];

                LoadString(g_hLocRes, idsIMAPPollUnreadFailuresFmt, szFmt, ARRAYSIZE(szFmt));
                wnsprintf(sz, ARRAYSIZE(sz), szFmt, pThis->m_szAccountName);
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID, sz);
                ecs = EVENT_WARNINGS;
            }

            if (0 == wParam)
                ecs = EVENT_FAILED;

            hrResult = pThis->m_pBindContext->EventDone(pThis->m_CurrentEID, ecs);
            Assert(SUCCEEDED(hrResult));
            return 0;
        } // case WM_IMAP_POLLUNREAD_DONE

        case WM_IMAP_POLLUNREAD_TICK:
            Assert(0 == lParam);
            if (0 == wParam)
                pThis->m_fFailuresEncountered = TRUE;
            else if (1 == wParam) {
                char sz[CCHMAX_STRINGRES], szFmt[CCHMAX_STRINGRES];

                LoadString(g_hLocRes, idsIMAPPollUnreadIMAP4Fmt, szFmt, ARRAYSIZE(szFmt));
                wnsprintf(sz, ARRAYSIZE(sz), szFmt, pThis->m_szAccountName);
                pThis->m_fFailuresEncountered = TRUE;
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID, sz);
            }
            else {
                Assert(2 == wParam);
                if (pThis->m_dwTotalTicks > 0)
                    pThis->m_pSpoolerUI->IncrementProgress(1);
            }
            return 0;

        case WM_IMAP_POLLUNREAD_TOTAL:
            Assert(0 == lParam);
            pThis->m_dwTotalTicks = wParam;
            pThis->m_pSpoolerUI->SetProgressRange(wParam);
            return 0;
    } // switch (uMsg)

    // If we reached this point, we didn't process the msg: DefWindowProc it
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
} // IMAPTaskWndProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\imaptask.h ===
//***************************************************************************
// IMAP4 Spooler Task Object Header File
// Written by Raymond Cheng, 6/27/97
//***************************************************************************

#ifndef __IMAPTASK_H
#define __IMAPTASK_H

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnact.h"


//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------
class CIMAPFolderMgr;


//---------------------------------------------------------------------------
// CIMAPTask Class Definition
//---------------------------------------------------------------------------
class CIMAPTask : public ISpoolerTask
{
public:
    // Constructor, Destructor
    CIMAPTask(void);
    ~CIMAPTask(void);

    // IUnknown Methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // ISpoolerTask Methods
    HRESULT STDMETHODCALLTYPE Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    HRESULT STDMETHODCALLTYPE BuildEvents(ISpoolerUI *pSpoolerUI,
        IImnAccount *pAccount, LPCTSTR pszFolder);
    HRESULT STDMETHODCALLTYPE Execute(EVENTID eid, DWORD dwTwinkie);
    HRESULT STDMETHODCALLTYPE ShowProperties(HWND hwndParent, EVENTID eid, DWORD dwTwinkie);
    HRESULT STDMETHODCALLTYPE GetExtendedDetails(EVENTID eid, DWORD dwTwinkie,
        LPSTR *ppszDetails);
    HRESULT STDMETHODCALLTYPE Cancel(void);
    HRESULT STDMETHODCALLTYPE IsDialogMessage(LPMSG pMsg);
    HRESULT STDMETHODCALLTYPE OnFlagsChanged(DWORD dwFlags);

private:
    // Module variables
    long m_lRefCount;
    ISpoolerBindContext *m_pBindContext;
    ISpoolerUI *m_pSpoolerUI;
    char m_szAccountName[CCHMAX_ACCOUNT_NAME];
    LPCSTR m_pszFolder;
    CIMAPFolderMgr *m_pIMAPFolderMgr;
    HWND m_hwnd;
    EVENTID m_CurrentEID;
    BOOL m_fFailuresEncountered;
    DWORD m_dwTotalTicks;
    DWORD m_dwFlags;

    // Functions
    static LRESULT CALLBACK IMAPTaskWndProc(HWND hwnd, UINT uMsg,
        WPARAM wParam, LPARAM lParam);

}; // class CIMAPTask

#endif // __IMAPTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\newstask.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     newstask.cpp
//
//  PURPOSE:    Implements a task object to take care of news posts.
//

#include "pch.hxx"
#include "resource.h"
#include "imagelst.h"
#include "storfldr.h"
#include "mimeutil.h"
#include "newstask.h"
#include "goptions.h"
#include "thormsgs.h"
#include "spoolui.h"
#include "xputil.h"
#include "ourguid.h"
#include "demand.h"
#include "msgfldr.h"
#include "taskutil.h"
#include <storsync.h>
#include <ntverp.h>

ASSERTDATA

const static char c_szThis[] = "this";

static const PFNSTATEFUNC g_rgpfnState[NTS_MAX] = 
    {
    NULL,                               // Idle
    NULL,                               // Connecting
    &CNewsTask::Post_Init,
    &CNewsTask::Post_NextMsg,
    NULL,                               // Post_OnResp
    &CNewsTask::Post_Dispose,
    &CNewsTask::Post_Done,
    &CNewsTask::NewMsg_Init,
    &CNewsTask::NewMsg_NextGroup,
    NULL,                               // NewMsg_OnResp
    &CNewsTask::NewMsg_HttpSyncStore,
    NULL,                               // NewMsg_OnHttpResp
    &CNewsTask::NewMsg_Done
    };

static const TCHAR c_szXNewsReader[] = "Microsoft Outlook Express " VER_PRODUCTVERSION_STRING;

//
//  FUNCTION:   CNewsTask::CNewsTask()
//
//  PURPOSE:    Initializes the member variables of the object.
//
CNewsTask::CNewsTask()
{
    m_cRef = 1;

    m_fInited = FALSE;
    m_dwFlags = 0;
    m_state = NTS_IDLE;
    m_eidCur = 0;
    m_pInfo = NULL;
    m_fConnectFailed = FALSE;
    m_szAccount[0] = 0;
    m_szAccountId[0] = 0;
    m_idAccount = FOLDERID_INVALID;
    m_pAccount  = NULL;
    m_cEvents = 0;
    m_fCancel = FALSE;

    m_pBindCtx = NULL;
    m_pUI = NULL;

    m_pServer = NULL;
    m_pOutbox = NULL;
    m_pSent = NULL;

    m_hwnd = 0;

    m_cMsgsPost = 0;
    m_cCurPost = 0;
    m_cFailed = 0;
    m_cCurParts = 0;
    m_cPartsCompleted = 0;
    m_fPartFailed = FALSE;
    m_rgMsgInfo = NULL;
    m_pSplitInfo = NULL;
    
    m_cGroups = 0;
    m_cCurGroup = -1;
    m_rgidGroups = NULL;
    m_dwNewInboxMsgs = 0;

    m_pCancel = NULL;
    m_hTimeout = NULL;
    m_tyOperation = SOT_INVALID;
}

//
//  FUNCTION:   CNewsTask::~CNewsTask()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
CNewsTask::~CNewsTask()    
{
    DestroyWindow(m_hwnd);

    FreeSplitInfo();

    SafeMemFree(m_pInfo);

    SafeRelease(m_pBindCtx);
    SafeRelease(m_pUI);
    SafeRelease(m_pAccount);

    if (m_pServer)
    {
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
    }

    Assert(NULL == m_pOutbox);
    Assert(NULL == m_pSent);

    SafeMemFree(m_rgMsgInfo);

    CallbackCloseTimeout(&m_hTimeout);
    SafeRelease(m_pCancel);
}


HRESULT CNewsTask::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (NULL == *ppvObj)
        return (E_INVALIDARG);

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID)(ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_ISpoolerTask))
        *ppvObj = (LPVOID)(ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (LPVOID)(IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (LPVOID)(ITimeoutCallback *) this;
    
    if (NULL == *ppvObj)
        return (E_NOINTERFACE);

    AddRef();
    return (S_OK);
}


ULONG CNewsTask::AddRef(void)
{
    ULONG cRefT;

    cRefT = ++m_cRef;

    return (cRefT);
}


ULONG CNewsTask::Release(void)
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if (0 == cRefT)
        delete this;

    return (cRefT);
}

static const char c_szNewsTask[] = "News Task";

//
//  FUNCTION:   CNewsTask::Init()
//
//  PURPOSE:    Called by the spooler engine to tell us what type of task to 
//              execute and to provide us with a pointer to our bind context.
//
//  PARAMETERS:
//      <in> dwFlags  - Flags to tell us what types of things to do
//      <in> pBindCtx - Pointer to the bind context interface we are to use
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_ALREADYINITIALIZED
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT CNewsTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    HRESULT hr = S_OK;

    // Validate the arguments
    if (NULL == pBindCtx)
        return (E_INVALIDARG);

    // Check to see if we've been initialzed already 
    if (m_fInited)
    {
        hr = SP_E_ALREADYINITIALIZED;
        goto exit;
    }

    // Copy the flags
    m_dwFlags = dwFlags;

    // Copy the bind context pointer
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();

    // Create the window
    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szNewsTask, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = TaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szNewsTask;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    m_hwnd = CreateWindow(c_szNewsTask, NULL, WS_POPUP, 10, 10, 10, 10,
                          GetDesktopWindow(), NULL, g_hInst, this);
    if (!m_hwnd)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_fInited = TRUE;

exit:
    return (hr);
}


//
//  FUNCTION:   CNewsTask::BuildEvents()
//
//  PURPOSE:    This method is called by the spooler engine telling us to create
//              and event list for the account specified.  
//
//  PARAMETERS:
//      <in> pAccount - Account object to build the event list for
//
//  RETURN VALUE:
//      SP_E_UNINITALIZED
//      E_INVALIDARG
//      S_OK
//
HRESULT CNewsTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    HRESULT         hr;
    BOOL            fIMAP;
    BOOL            fHttp;
    FOLDERINFO      fiFolderInfo;
    DWORD           dw                        = 0;
    ULARGE_INTEGER  uhLastFileTime64          = {0};
    ULARGE_INTEGER  uhCurFileTime64           = {0};
    ULARGE_INTEGER  uhMinPollingInterval64    = {0};
    FILETIME        CurFileTime               = {0};
    DWORD           cb                        = 0;

    Assert(pAccount != NULL);
    Assert(pSpoolerUI != NULL);
    Assert(m_fInited);

    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccount, ARRAYSIZE(m_szAccount))))
        return(hr);

    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId))))
        return(hr);

    if (FAILED(hr = g_pStore->FindServerId(m_szAccountId, &m_idAccount)))
        return(hr);

    // Copy the UI object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Create the server object
    hr = g_pStore->GetFolderInfo(m_idAccount, &fiFolderInfo);
    if (FAILED(hr))
        return(hr);

    fIMAP = (fiFolderInfo.tyFolder == FOLDER_IMAP);
    fHttp = (fiFolderInfo.tyFolder == FOLDER_HTTPMAIL);

    hr = CreateMessageServerType(fiFolderInfo.tyFolder, &m_pServer);
    g_pStore->FreeRecord(&fiFolderInfo);
    
    if (FAILED(hr))
        return(hr);

    hr = m_pServer->Initialize(g_pLocalStore, m_idAccount, NULL, FOLDERID_INVALID);
    if (FAILED(hr))
        return(hr);

    if (!fIMAP & !fHttp)
    {
        // Add posts to upload
        if (DELIVER_SEND & m_dwFlags)
            InsertOutbox(m_szAccountId, pAccount);
    }

    if (fHttp)
    {
        if (!!(m_dwFlags & DELIVER_AT_INTERVALS))
        {
            //If this is background polling make sure that HTTP's maxpolling interval has elapsed before
            //polling again.

            cb = sizeof(uhMinPollingInterval64);
            IF_FAILEXIT(hr = pAccount->GetProp(AP_HTTPMAIL_MINPOLLINGINTERVAL, (LPBYTE)&uhMinPollingInterval64, &cb));

            cb = sizeof(uhLastFileTime64);
            IF_FAILEXIT(hr = pAccount->GetProp(AP_HTTPMAIL_LASTPOLLEDTIME, (LPBYTE)&uhLastFileTime64, &cb));

            GetSystemTimeAsFileTime(&CurFileTime);
            uhCurFileTime64.QuadPart = CurFileTime.dwHighDateTime;
            uhCurFileTime64.QuadPart = uhCurFileTime64.QuadPart << 32;
            uhCurFileTime64.QuadPart += CurFileTime.dwLowDateTime;

            //We do not want to do background polling if the last time we polled this http mail
            //account was less than maximum polling interval specified by the server.
            //We should only poll if the time elapsed is greater than or equal to the max polling interval
            if ((uhCurFileTime64.QuadPart - uhLastFileTime64.QuadPart) < uhMinPollingInterval64.QuadPart)
            {
                goto exit;
            }

            //Mark the last polled time.
            hr = pAccount->SetProp(AP_HTTPMAIL_LASTPOLLEDTIME, (LPBYTE)&uhCurFileTime64, sizeof(uhCurFileTime64));
        }
    }
    // Check for new msgs
    if ((DELIVER_POLL & m_dwFlags) && (fIMAP || fHttp || !(m_dwFlags & DELIVER_NO_NEWSPOLL)))
    {
        if (ISFLAGSET(m_dwFlags, DELIVER_NOSKIP) ||
            (!fIMAP && !fHttp && (FAILED(pAccount->GetPropDw(AP_NNTP_POLL, &dw)) || dw != 0)) ||
            (fIMAP  && (FAILED(pAccount->GetPropDw(AP_IMAP_POLL, &dw)) || dw != 0)) ||
            (fHttp  && (FAILED(pAccount->GetPropDw(AP_HTTPMAIL_POLL, &dw)) || dw != 0)))
        {
            InsertNewMsgs(m_szAccountId, pAccount, fHttp);
        }
    }

exit:

    return (hr);
}


//
//  FUNCTION:   CNewsTask::Execute()
//
//  PURPOSE:    This signals our task to start executing an event.
//
//  PARAMETERS:
//      <in> pSpoolerUI - Pointer of the UI object we'll display progress through
//      <in> eid        - ID of the event to execute
//      <in> dwTwinkie - Our extra information we associated with the event
//
//  RETURN VALUE:
//      SP_E_EXECUTING
//      S_OK
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//
HRESULT CNewsTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    
    // Make sure we're already idle
    Assert(m_state == NTS_IDLE);
    
    // Make sure we're initialized
    Assert(m_fInited);

    // Copy the event id and event info
    m_eidCur = eid;
    m_pInfo = (EVENTINFO *) dwTwinkie;
    
    // Update the event UI to an executing state
    Assert(m_pUI);
    m_pUI->SetProgressRange(1);

    // Set up the progress
    AthLoadString(idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    m_pUI->SetAnimation(idanDownloadNews, TRUE);

    // Depending on the type of event, set the state machine info
    switch (((EVENTINFO*) dwTwinkie)->type)
    {
        case EVENT_OUTBOX:            
            m_state = NTS_POST_INIT;
            break;

        case EVENT_NEWMSGS:
            m_state = NTS_NEWMSG_INIT;
            break;
    }

    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return(S_OK);
}

HRESULT CNewsTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Make sure we're initialized
    Assert(m_fInited);

    Assert(dwTwinkie != 0);
    MemFree((EVENTINFO *)dwTwinkie);

    return(S_OK);
}

//
//  FUNCTION:   CNewsTask::ShowProperties
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT CNewsTask::ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CNewsTask::GetExtendedDetails
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT CNewsTask::GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, 
                                      LPSTR *ppszDetails)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CNewsTask::Cancel
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT CNewsTask::Cancel(void)
{
    // this can happen if user cancels out of connect dlg
    if (m_state == NTS_IDLE)
        return(S_OK);

    // Drop the server connection
    if (m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_fCancel = TRUE;

    if (m_pInfo->type == EVENT_OUTBOX)
        m_state = NTS_POST_END;
    else
        m_state = NTS_NEWMSG_END;
    
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return (S_OK);
}


//
//  FUNCTION:   CNewsTask::InsertOutbox()
//
//  PURPOSE:    Checks the outbox for news posts destine for this news account.
//
//  PARAMETERS:
//      <in> pszAcctId - ID of the account to check the outbox for.
//
//  RETURN VALUE:
//      E_UNEXECTED 
//      E_OUTOFMEMORY 
//      S_OK
//
HRESULT CNewsTask::InsertOutbox(LPTSTR pszAcctId, IImnAccount *pAccount)
{
    HRESULT            hr = S_OK;
    IMessageFolder    *pOutbox = NULL;
    MESSAGEINFO        MsgInfo={0};
    HROWSET            hRowset=NULL;

    // Get the outbox
    if (FAILED(hr = m_pBindCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *) &pOutbox)))
        goto exit;

    // Loop through the outbox looking for posts to this server
    m_cMsgsPost = 0;

    // Create a Rowset
    if (FAILED(hr = pOutbox->CreateRowset(IINDEX_PRIMARY, 0, &hRowset)))
        goto exit;

    // Get the first message
	while (S_OK == pOutbox->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        // Has this message been submitted and is it a news message?
        if ((MsgInfo.dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) == (ARF_SUBMITTED | ARF_NEWSMSG))
        {
            // Is the account the same as the account we're looking for
            if (MsgInfo.pszAcctId && 0 == lstrcmpi(MsgInfo.pszAcctId, pszAcctId))
                m_cMsgsPost++;
        }

        // Free the header info
        pOutbox->FreeRecord(&MsgInfo);
    }

    // Release Lock
    pOutbox->CloseRowset(&hRowset);

    // Good to go
    hr = S_OK;

    // If there were any messages then add the event
    if (m_cMsgsPost)
    {
        EVENTINFO *pei = NULL;
        TCHAR      szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        EVENTID    eid;

        // Allocate a structure to set as our cookie
        if (!MemAlloc((LPVOID*) &pei, sizeof(EVENTINFO)))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Fill out the event info
        pei->szGroup[0] = 0;
        pei->type = EVENT_OUTBOX;

        // Create the event description
        AthLoadString(idsNewsTaskPost, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_cMsgsPost, m_szAccount);

        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid);
        if (FAILED(hr))
            goto exit;

        m_cEvents++;

    } // if (m_cMsgsPost)

exit:
    // Release Lock
    if (pOutbox)
        pOutbox->CloseRowset(&hRowset);
    SafeRelease(pOutbox);
    return (hr);
}


//
//  FUNCTION:   CNewsTask::TaskWndProc()
//
//  PURPOSE:    Hidden window that processes messages for this task.
//
LRESULT CALLBACK CNewsTask::TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam)
{
    CNewsTask *pThis = (CNewsTask *) GetProp(hwnd, c_szThis);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
            pThis = (CNewsTask *) pcs->lpCreateParams;
            SetProp(hwnd, c_szThis, (LPVOID) pThis);
            return (0);
        }

        case NTM_NEXTSTATE:
            if (pThis)
            {
                pThis->AddRef();
                pThis->NextState();
                pThis->Release();
            }
            return (0);

        case WM_DESTROY:
            RemoveProp(hwnd, c_szThis);
            break;
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CNewsTask::Post_Init()
//
//  PURPOSE:    Called when we're in a NTS_POST_INIT state.  The task is 
//              initialized to execute the posting event.
//
//  RETURN VALUE:
//      E_OUTOFMEMORY
//      E_UNEXPECTED
//      S_OK
//
HRESULT CNewsTask::Post_Init(void)
{
    HRESULT     hr = S_OK;
    DWORD       dwCur = 0;
    MESSAGEINFO MsgInfo={0};
    HROWSET     hRowset=NULL;
    BOOL        fInserted = FALSE;
    TCHAR      *pszAcctName = NULL;

    // Open the outbox
    Assert(m_pBindCtx);
    if (FAILED(hr = m_pBindCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *) &m_pOutbox)))
        goto exit;

    Assert(m_pSent == NULL);

    // If we use sent items, get that pointer too
    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        if (FAILED(hr = TaskUtil_OpenSentItemsFolder(m_pAccount, &m_pSent)))
            goto exit;
        Assert(m_pSent != NULL);
    }

    // Allocate an array of header pointers for the messages we're going to post
    if (!MemAlloc((LPVOID*) &m_rgMsgInfo, m_cMsgsPost * sizeof(MESSAGEINFO)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Zero out the array
    ZeroMemory(m_rgMsgInfo, m_cMsgsPost * sizeof(MESSAGEINFO));

    // Create Rowset
    if (FAILED(hr = m_pOutbox->CreateRowset(IINDEX_PRIMARY, 0, &hRowset)))
        goto exit;

    // While we have stuff
    while (S_OK == m_pOutbox->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        // Has this message been submitted and is it a news message?
        if ((MsgInfo.dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) == (ARF_SUBMITTED | ARF_NEWSMSG))
        {
            // Is the account the same as the account we're looking for
            if (MsgInfo.pszAcctId && 0 == lstrcmpi(MsgInfo.pszAcctId, m_szAccountId))
            {
                if (NULL == pszAcctName && MsgInfo.pszAcctName)
                    pszAcctName  = PszDup(MsgInfo.pszAcctName);

                CopyMemory(&m_rgMsgInfo[dwCur++], &MsgInfo, sizeof(MESSAGEINFO));
                ZeroMemory(&MsgInfo, sizeof(MESSAGEINFO));
            }
        }

        if (dwCur >= (DWORD)m_cMsgsPost)
     	{
     		Assert(0);
     		break;
      	}

        // Free the header info
        m_pOutbox->FreeRecord(&MsgInfo);
    }

    // Release Lock
    m_pOutbox->CloseRowset(&hRowset);

    // Good to go
    hr = S_OK;

    //Assert(dwCur);

    // Update the UI to an executing state
    Assert(m_pUI);

    // Set up the progress
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    AthLoadString(idsProgDLPostTo, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, (LPTSTR) pszAcctName ? pszAcctName : "");

    Assert(m_pUI);
    m_pUI->SetGeneralProgress(szBuf);
    m_pUI->SetProgressRange((WORD) m_cMsgsPost);

    m_pUI->SetAnimation(idanOutbox, TRUE);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_SENDING_NEWS, 0);

    // Reset the counter to post the first message
    m_cCurPost = -1;
    m_cFailed = 0;
    m_state = NTS_POST_NEXT;

exit:
    
    SafeMemFree(pszAcctName);

    if (m_pOutbox)
        m_pOutbox->CloseRowset(&hRowset);

    // If something failed, then update the UI
    if (FAILED(hr))
    {
        m_pUI->InsertError(m_eidCur, MAKEINTRESOURCE(idshrCantOpenOutbox));
        m_cFailed = m_cMsgsPost;

        // Move to a terminating state
        m_state = NTS_POST_END;        
    }
        
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    return (hr);
}

void CNewsTask::FreeSplitInfo()
{
    if (m_pSplitInfo != NULL)
    {
        if (m_pSplitInfo->pEnumParts != NULL)
            m_pSplitInfo->pEnumParts->Release();
        if (m_pSplitInfo->pMsgParts != NULL)
            m_pSplitInfo->pMsgParts->Release();
        MemFree(m_pSplitInfo);
        m_pSplitInfo = NULL;
    }
}

HRESULT CNewsTask::Post_NextPart(void)
{
    LPMIMEMESSAGE pMsgSplit;
    HRESULT hr;
    LPSTREAM pStream;
    LPMESSAGEINFO pInfo;
    DWORD dwLines;
    char rgch[12];
    PROPVARIANT rUserData;

    Assert(m_pSplitInfo->pEnumParts != NULL);

    pInfo = &m_rgMsgInfo[m_cCurPost];

    hr = m_pSplitInfo->pEnumParts->Next(1, &pMsgSplit, NULL);
    if (hr == S_OK)
    {
        Assert(pMsgSplit);

        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = (LPSTR)pInfo->pszAcctName;
        pMsgSplit->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);
        rUserData.pszVal = pInfo->pszAcctId;;
        pMsgSplit->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);

        // since this is a new message it doesn't have a line
        // count yet, so we need to do it before we stick it
        // in the outbox
        HrComputeLineCount(pMsgSplit, &dwLines);
        wnsprintf(rgch, ARRAYSIZE(rgch), "%d", dwLines);
        MimeOleSetBodyPropA(pMsgSplit, HBODY_ROOT, PIDTOSTR(PID_HDR_LINES), NOFLAGS, rgch);
		MimeOleSetBodyPropA(pMsgSplit, HBODY_ROOT, PIDTOSTR(PID_HDR_XNEWSRDR), NOFLAGS, c_szXNewsReader);
        // Final Parameter: fSaveChange = TRUE since messsage is dirty

        hr = pMsgSplit->GetMessageSource(&pStream, 0);
        if (SUCCEEDED(hr) && pStream != NULL)
        {
            hr = m_pServer->PutMessage(m_pSplitInfo->idFolder, pInfo->dwFlags, &pInfo->ftReceived, pStream, this);

            m_cCurParts++;

            pStream->Release();
        }
        
        pMsgSplit->Release();
    }

    return(hr);
}

//
//  FUNCTION:   CNewsTask::Post_NextMsg()
//
//  PURPOSE:    Posts the next message in our outbox.
//
//  RETURN VALUE:
//      <???>
//
HRESULT CNewsTask::Post_NextMsg(void)
{
    LPMESSAGEINFO   pInfo;
    FOLDERID        idFolder;
    char            szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    DWORD           dw, cbSize, cbMaxSendMsgSize;
    IImnAccount    *pAcct;
    LPMIMEMESSAGE   pMsg = 0;
    HRESULT         hr = S_OK;
    IStream        *pStream = NULL;

    if (m_pSplitInfo != NULL)
    {
        hr = Post_NextPart();
        Assert(hr != S_OK);
        if (hr == E_PENDING)
        {
            m_state = NTS_POST_RESP;
            return(S_OK);
        }
        
        FreeSplitInfo();

        if (FAILED(hr))
        {
            m_cFailed++;
            m_fPartFailed = TRUE;
        }

        Assert(m_pUI);
        m_pUI->IncrementProgress(1);
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

        return(S_OK);
    }

    m_cCurPost++;
    m_cCurParts = 0;
    m_cPartsCompleted = 0;
    m_fPartFailed = FALSE;

    // Check to see if we're already done
    if (m_cCurPost >= m_cMsgsPost)
    {
        // If so, move to a cleanup state
        m_state = NTS_POST_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }

    // Update the progress UI
    AthLoadString(idsProgDLPost, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_cCurPost + 1, m_cMsgsPost);

    Assert(m_pUI);
    m_pUI->SetSpecificProgress(szBuf);

    pInfo = &m_rgMsgInfo[m_cCurPost];

    // Load the message stream from the store
    if (SUCCEEDED(hr = m_pOutbox->OpenMessage(pInfo->idMessage, OPEN_MESSAGE_SECURE, &pMsg, this)))
    {
        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pInfo->pszAcctId, &pAcct);
        if (SUCCEEDED(hr))
        {
            hr = g_pStore->FindServerId(pInfo->pszAcctId, &idFolder);
            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_SPLIT_MESSAGES, &dw)) &&
                    dw != 0 &&
                    SUCCEEDED(pAcct->GetPropDw(AP_NNTP_SPLIT_SIZE, &dw)))
                {
                    cbMaxSendMsgSize = dw;
                }
                else
                {
                    cbMaxSendMsgSize = 0xffffffff;
                }

                SideAssert(pMsg->GetMessageSize(&cbSize, 0)==S_OK);
                if (cbSize < (cbMaxSendMsgSize * 1024))
                {
                    hr = pMsg->GetMessageSource(&pStream, 0);
                    if (SUCCEEDED(hr) && pStream != NULL)
                    {
                        hr = m_pServer->PutMessage(idFolder,
                                        pInfo->dwFlags,
                                        &pInfo->ftReceived,
                                        pStream,
                                        this);
                        m_cCurParts ++;
                        pStream->Release();
                    }
                }
                else
                {
                    Assert(m_pSplitInfo == NULL);
                    if (!MemAlloc((void **)&m_pSplitInfo, sizeof(SPLITMSGINFO)))
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        ZeroMemory(m_pSplitInfo, sizeof(SPLITMSGINFO));
                        m_pSplitInfo->idFolder = idFolder;

                        hr = pMsg->SplitMessage(cbMaxSendMsgSize * 1024, &m_pSplitInfo->pMsgParts);
                        if (hr == S_OK)
                        {
                            hr = m_pSplitInfo->pMsgParts->EnumParts(&m_pSplitInfo->pEnumParts);
                            if (hr == S_OK)
                            {
                                hr = Post_NextPart();
                            }
                        }

                        if (hr != E_PENDING)
                            FreeSplitInfo();
                    }
                }
            }

            pAcct->Release();
        }

        if (hr == E_PENDING)
        {
            m_state = NTS_POST_RESP;
            hr = S_OK;
            goto exit;
        }
    }

    // If we get here, something failed.
    m_cFailed++;
    Assert(m_pUI);
    m_pUI->IncrementProgress(1);
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

exit:
    SafeRelease(pMsg);
    return (hr);
}

HRESULT CNewsTask::Post_Dispose()
{
    HRESULT hr;

    hr = DisposeOfPosting(m_rgMsgInfo[m_cCurPost].idMessage);

    if (hr == E_PENDING)
        return(S_OK);

    // TODO: handle error

    // Update the progress bar
    Assert(m_pUI);
    m_pUI->IncrementProgress(1);

    // Move on to the next post
    m_state = NTS_POST_NEXT;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return(hr);
}

//
//  FUNCTION:   CNewsTask::Post_Done()
//
//  PURPOSE:    Allows the posting event to clean up and finalize the UI.
//
//  RETURN VALUE:
//      S_OK
//
HRESULT CNewsTask::Post_Done(void)
{
    // Free the header array
    if (m_rgMsgInfo && m_cMsgsPost)
    {
        for (LONG i=0; i<m_cMsgsPost; i++)
            m_pOutbox->FreeRecord(&m_rgMsgInfo[i]);
        MemFree(m_rgMsgInfo);
    }

    // Free the folder pointers we're hanging on to
    SafeRelease(m_pOutbox);
    SafeRelease(m_pSent);

    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_dwNewInboxMsgs);

    if (m_fCancel)
    {
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
        m_fCancel = FALSE;
    }
    else if (m_cFailed == m_cMsgsPost)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_cFailed == 0)
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);

    m_cMsgsPost = 0;
    m_cCurPost = 0;
    m_cFailed = 0;
    m_rgMsgInfo = NULL;
    SafeMemFree(m_pInfo);

    m_eidCur = 0;

    m_cEvents--;
    if (m_cEvents == 0 && m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_state = NTS_IDLE;

    return (S_OK);
}

HRESULT CNewsTask::DisposeOfPosting(MESSAGEID dwMsgID)
{
    MESSAGEIDLIST MsgIdList;
    ADJUSTFLAGS AdjustFlags;
    HRESULT hrResult = E_FAIL;
    
    MsgIdList.cAllocated = 0;
    MsgIdList.cMsgs = 1;
    MsgIdList.prgidMsg = &dwMsgID;

    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        // If we've reached this point, it's time to try local Sent Items folder
        Assert(m_pSent != NULL);

        // change msg flags first, so if copy fails, the user doesn't get
        // messed up by us posting the message every time they do a send
        AdjustFlags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;
        AdjustFlags.dwAdd = ARF_READ;

        hrResult = m_pOutbox->SetMessageFlags(&MsgIdList, &AdjustFlags, NULL, NULL);
        Assert(hrResult != E_PENDING);
        if (SUCCEEDED(hrResult))
            hrResult = m_pOutbox->CopyMessages(m_pSent, COPY_MESSAGE_MOVE, &MsgIdList, NULL, NULL, this);
    }
    else
    {
        // If we've reached this point, it's time to delete the message from the Outbox
        hrResult = m_pOutbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &MsgIdList, NULL, this);
    }

    return hrResult;
}

//
//  FUNCTION:   CNewsTask::NextState()
//
//  PURPOSE:    Executes the function for the current state
//
void CNewsTask::NextState(void)
{
    if (NULL != g_rgpfnState[m_state])
        (this->*(g_rgpfnState[m_state]))();
}

HRESULT CNewsTask::InsertNewMsgs(LPSTR pszAccountId, IImnAccount *pAccount, BOOL fHttp)
    {
    HRESULT hr = S_OK;
    ULONG cSub = 0;
    IEnumerateFolders *pEnum = NULL;

    if (fHttp)
        m_cGroups = 1;
    else
    {
        // Load the sublist for this server
        Assert(m_idAccount != FOLDERID_INVALID);
        hr = g_pStore->EnumChildren(m_idAccount, TRUE, &pEnum);
        if (FAILED(hr))
            goto exit;

        hr = pEnum->Count(&cSub);
        if (FAILED(hr))
            goto exit;

        m_cGroups = (int)cSub;
    }

    // If there were any groups then add the event
    if (m_cGroups)
        {
        EVENTINFO *pei;
        char       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        EVENTID    eid;

        // Allocate a structure to set as our cookie
        if (!MemAlloc((LPVOID*) &pei, sizeof(EVENTINFO)))
            {
            hr = E_OUTOFMEMORY;
            goto exit;
            }

        // Fill out the event info
        pei->szGroup[0] = 0;
        pei->type = EVENT_NEWMSGS;

        // Create the event description
        AthLoadString(idsCheckNewMsgsServer, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_szAccount);

        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid); 
        m_cEvents++;
        }

exit:
    SafeRelease(pEnum);
    return (hr);
    }


HRESULT CNewsTask::NewMsg_InitHttp(void)
{
    HRESULT         hr = S_OK;

    // Set up the progress
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    AthLoadString(IDS_SPS_POP3CHECKING, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, (LPTSTR) m_szAccount);
 
    Assert(m_pUI);
    m_pUI->SetGeneralProgress(szBuf);
    m_pUI->SetProgressRange(1);
    
    m_pUI->SetAnimation(idanInbox, TRUE);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING, 0);

    // set the to generate correct success/failure message
    m_cGroups = 1;

    m_state = NTS_NEWMSG_HTTPSYNCSTORE;

    return hr;
}

HRESULT CNewsTask::NewMsg_Init(void)
    {
    const       BOOL    fDONT_INCLUDE_PARENT    = FALSE;
    const       BOOL    fSUBSCRIBED_ONLY        = TRUE;
    FOLDERINFO          FolderInfo              = {0};
    HRESULT             hr                      = S_OK;
    DWORD               dwAllocated;
    DWORD               dwUsed;
    BOOL                fImap                   = FALSE;
    DWORD               dwIncludeAll            = 0;
    DWORD               dwDone                  = FALSE;

    Assert(m_idAccount != FOLDERID_INVALID);

    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idAccount, &FolderInfo)))
    {
        // httpmail updates folder counts differently
        if (FOLDER_HTTPMAIL == FolderInfo.tyFolder)
        {
            g_pStore->FreeRecord(&FolderInfo);

            IF_FAILEXIT(hr = m_pAccount->GetPropDw(AP_HTTPMAIL_GOTPOLLINGINTERVAL, &dwDone));
            if (!dwDone)
            {
                //We need to get the polling interval from the server
                //This is an asynchrnous call. The value gets updated in OnComplete. 
                //Meanwhile we go ahead and poll for new messages
                hr = m_pServer->GetMinPollingInterval((IStoreCallback*)this);
            }

            hr = NewMsg_InitHttp();
            goto exit;
        }

        fImap = (FolderInfo.tyFolder == FOLDER_IMAP);
        if (fImap)
        {
            if (FAILED(hr = m_pAccount->GetPropDw(AP_IMAP_POLL_ALL_FOLDERS, &dwIncludeAll)))
            {
                dwIncludeAll = 0;
            }
        }

        g_pStore->FreeRecord(&FolderInfo);
    }

    if (fImap && (!dwIncludeAll))
    {
        dwUsed = 0;
        if (FAILED(GetInboxId(g_pStore, m_idAccount, &m_rgidGroups, &dwUsed)))
            goto exit;
    }
    else
    {
        // Get an array of all subscribed folders
        hr = FlattenHierarchy(g_pStore, m_idAccount, fDONT_INCLUDE_PARENT,
            fSUBSCRIBED_ONLY, &m_rgidGroups, &dwAllocated, &dwUsed);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    m_cGroups = dwUsed;

    // Set up the progress
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    AthLoadString(IDS_SPS_POP3CHECKING, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, (LPTSTR) m_szAccount);

    Assert(m_pUI);
    m_pUI->SetGeneralProgress(szBuf);
    m_pUI->SetProgressRange((WORD) m_cGroups);

    if (fImap)
    {
        m_pUI->SetAnimation(idanInbox, TRUE);
        m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING, 0);
    }
    else
    {
        m_pUI->SetAnimation(idanDownloadNews, TRUE);
        m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING_NEWS, 0);
    }

    // Reset the counters for the first group
    m_cCurGroup = -1;
    m_cFailed = 0;
    m_state = NTS_NEWMSG_NEXTGROUP;

exit:
    // If something failed, update the UI
    if (FAILED(hr))
        {
        m_pUI->InsertError(m_eidCur, MAKEINTRESOURCE(idsErrNewMsgsFailed));
        m_cFailed = m_cGroups;

        // Move to a terminating state
        m_state = NTS_NEWMSG_END;
        }

    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    return (hr);
    }

HRESULT CNewsTask::NewMsg_NextGroup(void)
    {
    HRESULT hr = E_FAIL;

    do
    {
        FOLDERINFO info;

        // Keep looping until we find a folder that's selectable and exists
        m_cCurGroup++;

        // Check to see if we're already done
        if (m_cCurGroup >= m_cGroups)
        {
            m_state = NTS_NEWMSG_END;
            hr = S_OK;
            PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
            break;
        }

        if (SUCCEEDED(hr = g_pStore->GetFolderInfo(m_rgidGroups[m_cCurGroup], &info)))
        {
            if (0 == (info.dwFlags & (FOLDER_NOSELECT | FOLDER_NONEXISTENT)))
            {
                // Update the progress UI
                TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
                AthLoadString(idsLogCheckingNewMessages, szRes, ARRAYSIZE(szRes));
                wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, info.pszName);

                g_pStore->FreeRecord(&info);

                Assert(m_pUI);
                m_pUI->SetSpecificProgress(szBuf);

                // Send the group command to the server
                if (E_PENDING == (hr = m_pServer->GetFolderCounts(m_rgidGroups[m_cCurGroup], (IStoreCallback *)this)))
                {
                    m_state = NTS_NEWMSG_RESP;
                    hr = S_OK;
                }

                break;
            }
            else
            {
                g_pStore->FreeRecord(&info);
            }
        }
    } while (1);


    if (FAILED(hr))
    {
        // If we get here, something failed
        m_cFailed++;
        Assert(m_pUI);
        m_pUI->IncrementProgress(1);
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }

    return (hr);
    }

HRESULT CNewsTask::NewMsg_HttpSyncStore(void)
{
    HRESULT     hr = S_OK;

    // send the command to the server
    hr = m_pServer->SynchronizeStore(FOLDERID_INVALID, NOFLAGS, (IStoreCallback  *)this);
    if (E_PENDING == hr)
    {
        m_state = NTS_NEWMSG_HTTPRESP;
        hr = S_OK;
    }

    return hr;
}

HRESULT CNewsTask::NewMsg_Done(void)
    {
    HRESULT hr = S_OK;

    // Free the group array
    if (m_rgidGroups)
        {
        MemFree(m_rgidGroups);
        m_rgidGroups = NULL;
        }

    SafeMemFree(m_pInfo);

    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_dwNewInboxMsgs);

    if (m_fCancel)
        {
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
        m_fCancel = FALSE;
        }
    else if (m_cFailed == m_cGroups)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_cFailed == 0)
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);

    m_cGroups = 0;
    m_cCurGroup = 0;
    m_cFailed = 0;
    m_dwNewInboxMsgs = 0;

    m_eidCur = 0;

    m_cEvents--;
    if (m_cEvents == 0 && m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_state = NTS_IDLE;

    return (S_OK);
    }

// --------------------------------------------------------------------------------
// CNewsTask::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CNewsTask::IsDialogMessage(LPMSG pMsg)
{
    return S_FALSE;
}


STDMETHODIMP CNewsTask::OnFlagsChanged(DWORD dwFlags)
{
    m_dwFlags = dwFlags;

    return (S_OK);
}


STDMETHODIMP CNewsTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    // Hold onto this
    Assert(m_tyOperation == SOT_INVALID);

    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }
    m_tyOperation = tyOperation;

    // Party On
    return(S_OK);
}

STDMETHODIMP CNewsTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // NOTE: that you can get more than one type of value for tyOperation.
    //       Most likely, you will get SOT_CONNECTION_STATUS and then the
    //       operation that you might expect. See HotStore.idl and look for
    //       the STOREOPERATION enumeration type for more info.

    switch (tyOperation)
    {
        case SOT_NEW_MAIL_NOTIFICATION:
            m_dwNewInboxMsgs = dwCurrent;
            break;
    }

    // Done
    return(S_OK);
}

STDMETHODIMP CNewsTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

STDMETHODIMP CNewsTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;

    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}

STDMETHODIMP CNewsTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) &&
        !(ISFLAGSET(pServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pServer->szPassword[0]))
        return(S_FALSE);

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

STDMETHODIMP CNewsTask::OnComplete(STOREOPERATIONTYPE   tyOperation, HRESULT        hrComplete, 
                                   LPSTOREOPERATIONINFO pOpInfo,     LPSTOREERROR   pErrorInfo)
{
    char            szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES * 2], szSubject[64];
    NEWSTASKSTATE   ntsNextState = NTS_MAX;
    LPSTR           pszSubject = NULL;
    LPSTR           pszOpDescription = NULL;
    BOOL            fInsertError = FALSE;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    IxpAssert(m_tyOperation != SOT_INVALID);
    if (m_tyOperation != tyOperation)
        return(S_OK);

    switch (tyOperation)
    {
        case SOT_PUT_MESSAGE:
            m_cPartsCompleted ++;

            // Figure out if we succeeded or failed
            if (FAILED(hrComplete))
            {
                if (!m_fPartFailed )
                {
                    Assert(m_pUI);

                    // Set us up to display the error
                    pszOpDescription = MAKEINTRESOURCE(idsNewsTaskPostError);
                    pszSubject = m_rgMsgInfo[m_cCurPost].pszSubject;
                    if (pszSubject == NULL || *pszSubject == 0)
                    {
                        AthLoadString(idsNoSubject, szSubject, ARRAYSIZE(szSubject));
                        pszSubject = szSubject;
                    }
                    fInsertError = TRUE;

                    m_cFailed++;
                    m_fPartFailed = TRUE;
                }
            }

            if (m_cPartsCompleted == m_cCurParts)
            {
                if (m_fPartFailed)
                {
                    // Update the progress bar
                    Assert(m_pUI);
                    m_pUI->IncrementProgress(1);

                    // Move on to the next post
                    ntsNextState = NTS_POST_NEXT;
                }
                else
                {
                    ntsNextState = NTS_POST_DISPOSE;
                }
            }

            break; // case SOT_PUT_MESSAGE


        case SOT_UPDATE_FOLDER:
            if (FAILED(hrComplete))
                {
                FOLDERINFO  fiFolderInfo;

                Assert(m_pUI);

                LoadString(g_hLocRes, idsUnreadCountPollErrorFmt, szRes, sizeof(szRes));
                if (SUCCEEDED(g_pStore->GetFolderInfo(m_rgidGroups[m_cCurGroup], &fiFolderInfo)))
                {
                    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, fiFolderInfo.pszName);
                    g_pStore->FreeRecord(&fiFolderInfo);
                }
                else
                {
                    LoadString(g_hLocRes, idsUnknown, szSubject, sizeof(szSubject));
                    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, szSubject);
                }
                pszOpDescription = szBuf;
                fInsertError = TRUE;

                m_cFailed++;
                }

            // Update the progress bar
            m_pUI->IncrementProgress(1);

            // Move on to the next group
            ntsNextState = NTS_NEWMSG_NEXTGROUP;

            break; // case SOT_UPDATE_FOLDER

        case SOT_SYNCING_STORE:
            if (( IXP_E_HTTP_NOT_MODIFIED != hrComplete) && (FAILED(hrComplete)))
            {  
                LoadString(g_hLocRes, idsHttpPollFailed, szBuf, sizeof(szBuf));
                pszOpDescription = szBuf;
                fInsertError = TRUE;

                m_cFailed++;
            }

            // update the progress bar
            m_pUI->IncrementProgress(1);

            // we're done
            ntsNextState = NTS_NEWMSG_END;

            break; // case SOT_SYNCING_STORE

        case SOT_COPYMOVE_MESSAGE:
            // Update the progress bar
            Assert(m_pUI);
            m_pUI->IncrementProgress(1);

            // Move on to the next post
            ntsNextState = NTS_POST_NEXT;

            if (FAILED(hrComplete))
            {
                Assert(m_pUI);

                pszOpDescription = MAKEINTRESOURCE(IDS_SP_E_CANT_MOVETO_SENTITEMS);
                fInsertError = TRUE;
            }
            break; // case SOT_COPYMOVE_MESSAGE

        case SOT_GET_HTTP_MINPOLLINGINTERVAL:
            if (SUCCEEDED(hrComplete) && pOpInfo)
            {
                ULARGE_INTEGER  uhMinPollingInterval64 = {0};
                
                //Convert it to seconds.
                uhMinPollingInterval64.QuadPart = pOpInfo->dwMinPollingInterval * 60;

                //FILETIME is intervals of 100 nano seconds. Need to convert to 100 nanoseconds
                uhMinPollingInterval64.QuadPart *= HUNDRED_NANOSECONDS;

                m_pAccount->SetProp(AP_HTTPMAIL_MINPOLLINGINTERVAL, (LPBYTE)&uhMinPollingInterval64, sizeof(uhMinPollingInterval64));

                m_pAccount->SetPropDw(AP_HTTPMAIL_GOTPOLLINGINTERVAL, TRUE);

                break;
            }

        default:
            if (IXP_E_HTTP_NOT_MODIFIED == hrComplete)
            {
                hrComplete   = S_OK;
                fInsertError = FALSE;
            }
            else
            {
                if (FAILED(hrComplete))
                {
                    Assert(m_pUI);

                    pszOpDescription = MAKEINTRESOURCE(idsGenericError);
                    fInsertError = TRUE;

                    m_cFailed++;
                }
            }
            break; // default case

    } // switch

    if (fInsertError && NULL != pErrorInfo) 
    {
        Assert(pErrorInfo->hrResult == hrComplete); // These two should not be different
        TaskUtil_InsertTransportError(ISFLAGCLEAR(m_dwFlags, DELIVER_NOUI), m_pUI, m_eidCur,
            pErrorInfo, pszOpDescription, pszSubject);
    }

    // Move on to next state
    if (IXP_E_USER_CANCEL == hrComplete)
    {
        // User cancelled logon prompt, so just abort everything
        Cancel();
    }
    else if (NTS_MAX != ntsNextState)
    {
        m_state = ntsNextState;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }

    // Release your cancel object
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;

    // Done
    return(S_OK);
}

STDMETHODIMP CNewsTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

STDMETHODIMP CNewsTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

STDMETHODIMP CNewsTask::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr;

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    if (m_pUI)
    {
        hr = m_pUI->GetWindow(phwndParent);
    }
    else
    {
        *phwndParent = NULL;
        hr = E_FAIL;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\ontask.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     ontask.cpp
//
//  PURPOSE:    Implements the offline news task.
//

#include "pch.hxx"
#include "resource.h"
#include "ontask.h"
#include "thormsgs.h"
#include "xputil.h"
#include "mimeutil.h"
#include <stdio.h>
#include "strconst.h"
#include <newsstor.h>
#include "ourguid.h"
#include "taskutil.h"

ASSERTDATA

const static char c_szThis[] = "this";

const PFNONSTATEFUNC COfflineTask::m_rgpfnState[ONTS_MAX] = 
{
    NULL,
    NULL,
    &COfflineTask::Download_Init,
    NULL,
    &COfflineTask::Download_AllMsgs,
    &COfflineTask::Download_NewMsgs,
    &COfflineTask::Download_MarkedMsgs,
    &COfflineTask::Download_Done,
};

const PFNARTICLEFUNC COfflineTask::m_rgpfnArticle[ARTICLE_MAX] = 
{
    &COfflineTask::Article_GetNext,
    NULL,
    &COfflineTask::Article_Done
};

#define GROUP_DOWNLOAD_FLAGS(flag) (((flag) & FOLDER_DOWNLOADHEADERS) || \
				    ((flag) & FOLDER_DOWNLOADNEW) || \
				    ((flag) & FOLDER_DOWNLOADALL))

#define CMSGIDALLOC     512
//
//  FUNCTION:   COfflineTask::COfflineTask()
//
//  PURPOSE:    Initializes the member variables of the object.
//
COfflineTask::COfflineTask()
{
    m_cRef = 1;
    
    m_fInited = FALSE;
    m_dwFlags = 0;
    m_state = ONTS_IDLE;
    m_eidCur = 0;
    m_pInfo = NULL;
    m_szAccount[0] = 0;
    m_cEvents = 0;
    m_fDownloadErrors = FALSE;
    m_fFailed = FALSE;
    m_fNewHeaders = FALSE;
    m_fCancel = FALSE;
    
    m_pBindCtx = NULL;
    m_pUI = NULL;
    
    m_pFolder = NULL;
    
    m_hwnd = 0;
    
    m_dwLast = 0;
    m_dwPrev = 0;
    m_cDownloaded = 0;
    m_dwPrevHigh = 0;
    m_dwNewInboxMsgs = 0;
    m_pList = NULL;

    m_pCancel = NULL;
    m_hTimeout = NULL;
    m_tyOperation = SOT_INVALID;
}

//
//  FUNCTION:   COfflineTask::~COfflineTask()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
COfflineTask::~COfflineTask()    
{
    DestroyWindow(m_hwnd);
    
    SafeMemFree(m_pInfo);
    SafeMemFree(m_pList);

    SafeRelease(m_pBindCtx);
    SafeRelease(m_pUI);
    
    CallbackCloseTimeout(&m_hTimeout);
    SafeRelease(m_pCancel);

    if (m_pFolder)
    {
	    m_pFolder->Close();
	    SideAssert(0 == m_pFolder->Release());
    }
}


HRESULT COfflineTask::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (NULL == *ppvObj)
	    return (E_INVALIDARG);
    
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
	    *ppvObj = (LPVOID)(ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_ISpoolerTask))
	    *ppvObj = (LPVOID)(ISpoolerTask *) this;
    
    if (NULL == *ppvObj)
	    return (E_NOINTERFACE);
    
    AddRef();
    return (S_OK);
}


ULONG COfflineTask::AddRef(void)
{
    ULONG cRefT;
    
    cRefT = ++m_cRef;
    
    return (cRefT);
}


ULONG COfflineTask::Release(void)
{
    ULONG cRefT;
    
    cRefT = --m_cRef;
    
    if (0 == cRefT)
        delete this;
    
    return (cRefT);
}

static const char c_szOfflineTask[] = "Offline Task";

//
//  FUNCTION:   COfflineTask::Init()
//
//  PURPOSE:    Called by the spooler engine to tell us what type of task to 
//              execute and to provide us with a pointer to our bind context.
//
//  PARAMETERS:
//      <in> dwFlags  - Flags to tell us what types of things to do
//      <in> pBindCtx - Pointer to the bind context interface we are to use
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_ALREADYINITIALIZED
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT COfflineTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Validate the arguments
    Assert(pBindCtx != NULL);
    
    // Check to see if we've been initialzed already 
    Assert(!m_fInited);
    
    // Copy the flags
    m_dwFlags = dwFlags;
    
    // Copy the bind context pointer
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();
    
    // Create the window
    WNDCLASSEX wc;
    
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szOfflineTask, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = TaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szOfflineTask;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;
        
        RegisterClassEx(&wc);
    }
    
    m_hwnd = CreateWindow(c_szOfflineTask, NULL, WS_POPUP, 10, 10, 10, 10,
        GetDesktopWindow(), NULL, g_hInst, this);
    if (!m_hwnd)
        return(E_OUTOFMEMORY);
    
    m_fInited = TRUE;
    
    return(S_OK);
}


//
//  FUNCTION:   COfflineTask::BuildEvents()
//
//  PURPOSE:    This method is called by the spooler engine telling us to create
//              and event list for the account specified.  
//
//  PARAMETERS:
//      <in> pAccount - Account object to build the event list for
//
//  RETURN VALUE:
//      SP_E_UNINITALIZED
//      E_INVALIDARG
//      S_OK
//
HRESULT COfflineTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    HRESULT hr;
    
    // Validate the arguments
    Assert(pAccount != NULL);
    Assert(pSpoolerUI != NULL);
    
    // Check to see if we've been initalized
    Assert(m_fInited);
    
    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccount, ARRAYSIZE(m_szAccount))))
        return(hr);
    
    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId))))
        return(hr);
    
    if (FAILED(hr = g_pStore->FindServerId(m_szAccountId, &m_idAccount)))
        return(hr);
    
    // Copy the UI object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();
    
    hr = InsertGroups(pAccount, idFolder);
    
    return(hr);
}


//
//  FUNCTION:   COfflineTask::InsertGroups()
//
//  PURPOSE:    Scans the specified account for groups that have an update 
//              property or marked messages.
//
//  PARAMETERS:
//      <in> szAccount - Name of the account to check
//      <in> pAccount  - Pointer to the IImnAccount object for szAccount
//
//  RETURN VALUE:
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT COfflineTask::InsertGroups(IImnAccount *pAccount, FOLDERID idFolder)
{
    FOLDERINFO  info = { 0 };
    HRESULT     hr = S_OK;
    DWORD       dwFlags = 0;
    DWORD       ids;
    TCHAR       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    EVENTID     eid;
    ONEVENTINFO *pei = NULL;
    BOOL        fIMAP = FALSE;
    DWORD       dwServerFlags;
    
    
    // Figure out if this is NNTP or IMAP
    if (SUCCEEDED(pAccount->GetServerTypes(&dwServerFlags)) && (dwServerFlags & (SRV_IMAP | SRV_HTTPMAIL)))
        fIMAP = TRUE;
    
    if (FOLDERID_INVALID != idFolder)
    {
        // Fill Folder
        hr = g_pStore->GetFolderInfo(idFolder, &info);
        if (FAILED(hr))
            return hr;
        
        // Figure out what we're downloading
        ids = 0;
        if (m_dwFlags & DELIVER_OFFLINE_HEADERS)
        {
            dwFlags = FOLDER_DOWNLOADHEADERS;
            if (m_dwFlags & DELIVER_OFFLINE_MARKED)
                ids = idsDLHeadersAndMarked;
            else
                ids = idsDLHeaders;
        }
        else if (m_dwFlags & DELIVER_OFFLINE_NEW)
        {
            dwFlags = FOLDER_DOWNLOADNEW;
            if (m_dwFlags & DELIVER_OFFLINE_MARKED)
                ids = idsDLNewMsgsAndMarked;
            else
                ids = idsDLNewMsgs;
        }
        else if (m_dwFlags & DELIVER_OFFLINE_ALL)
        {
            dwFlags = FOLDER_DOWNLOADALL;
            ids = idsDLAllMsgs;
        }
        else if (m_dwFlags & DELIVER_OFFLINE_MARKED)
        {
            ids = idsDLMarkedMsgs;
        }
        
        // Create the event description
        Assert(ids);                
        AthLoadString(ids, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, info.pszName);
        
        // Allocate a structure to save as our twinkie
        if (!MemAlloc((LPVOID *) &pei, sizeof(ONEVENTINFO)))
        {
            g_pStore->FreeRecord(&info);
            return(E_OUTOFMEMORY);
        }
        StrCpyN(pei->szGroup, info.pszName, ARRAYSIZE(pei->szGroup));
        pei->idGroup = info.idFolder;
        pei->dwFlags = dwFlags;
        pei->fMarked = m_dwFlags & DELIVER_OFFLINE_MARKED;
        pei->fIMAP = fIMAP;
        
        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid);
        if (SUCCEEDED(hr))
            m_cEvents++;
        
        g_pStore->FreeRecord(&info);
    }
    else
    {
        //Either Sync All or Send & Receive
        
        Assert(m_idAccount != FOLDERID_INVALID);
        
        BOOL        fInclude = FALSE;
        
        if (!(m_dwFlags & DELIVER_OFFLINE_SYNC) && !(m_dwFlags & DELIVER_NOSKIP))
        {
            DWORD   dw;
            if (dwServerFlags & SRV_IMAP)
            {
                if (SUCCEEDED(pAccount->GetPropDw(AP_IMAP_POLL, &dw)) && dw)
                {
                    fInclude = TRUE;
                }   
            }
            else
            {
                if (dwServerFlags & SRV_HTTPMAIL)
                {
                    if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_POLL, &dw)) && dw)
                    {
                        fInclude = TRUE;
                    }
                }
            }
        }
        else
            fInclude = TRUE;
        
        if (fInclude)
            hr = InsertAllGroups(m_idAccount, pAccount, fIMAP);
    }
    
    return (hr);
}


HRESULT COfflineTask::InsertAllGroups(FOLDERID idParent, IImnAccount *pAccount, BOOL fIMAP)
{
    FOLDERINFO  info = { 0 };
    IEnumerateFolders *pEnum = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwFlags = 0;
    BOOL        fMarked;
    DWORD       ids;
    TCHAR       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    EVENTID     eid;
    ONEVENTINFO *pei = NULL;
    BOOL        fSubscribedOnly = TRUE;
    
    if (fIMAP)
        fSubscribedOnly = FALSE;
    
    Assert(idParent != FOLDERID_INVALID);
    hr = g_pStore->EnumChildren(idParent, fSubscribedOnly, &pEnum);
    if (FAILED(hr))
        return(hr);
    
    // Walk the list of groups and add them to the queue as necessary
    while (S_OK == pEnum->Next(1, &info, NULL))
    {
        // If the download flags are set for this group, insert it
        dwFlags = info.dwFlags;
        
        HasMarkedMsgs(info.idFolder, &fMarked);
        
        if (GROUP_DOWNLOAD_FLAGS(dwFlags) || fMarked)
        {
            // Figure out what we're downloading
            ids = 0;
            if (dwFlags & FOLDER_DOWNLOADHEADERS)
            {
                if (fMarked)
                    ids = idsDLHeadersAndMarked;
                else
                    ids = idsDLHeaders;
            }
            else if (dwFlags & FOLDER_DOWNLOADNEW)
            {
                if (fMarked)
                    ids = idsDLNewMsgsAndMarked;
                else
                    ids = idsDLNewMsgs;
            }
            else if (dwFlags & FOLDER_DOWNLOADALL)
            {
                ids = idsDLAllMsgs;
            }
            else if (fMarked)
            {
                ids = idsDLMarkedMsgs;
            }
            
            // Create the event description
            Assert(ids);                
            AthLoadString(ids, szRes, ARRAYSIZE(szRes));
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, info.pszName);
            
            // Allocate a structure to save as our twinkie
            if (!MemAlloc((LPVOID *) &pei, sizeof(ONEVENTINFO)))
            {
                g_pStore->FreeRecord(&info);
                
                hr = E_OUTOFMEMORY;
                break;
            }
            StrCpyN(pei->szGroup, info.pszName, ARRAYSIZE(pei->szGroup));
            pei->idGroup = info.idFolder;
            pei->dwFlags = dwFlags;
            pei->fMarked = fMarked;
            pei->fIMAP = fIMAP;
            
            // Insert the event into the spooler
            hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid);
            if (FAILED(hr))
            {
                g_pStore->FreeRecord(&info);
                break;
            }
            
            m_cEvents++;
        }
        
        // Recurse on any children
        if (info.dwFlags & FOLDER_HASCHILDREN)
        {
            hr = InsertAllGroups(info.idFolder, pAccount, fIMAP);
            if (FAILED(hr))
                break;
        }
        
        g_pStore->FreeRecord(&info);
    }
    
    pEnum->Release();
    return hr;
}
    
    
//
//  FUNCTION:   COfflineTask::Execute()
//
//  PURPOSE:    This signals our task to start executing an event.
//
//  PARAMETERS:
//      <in> pSpoolerUI - Pointer of the UI object we'll display progress through
//      <in> eid        - ID of the event to execute
//      <in> dwTwinkie  - Our extra information we associated with the event
//
//  RETURN VALUE:
//      SP_E_EXECUTING
//      S_OK
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//
HRESULT COfflineTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Make sure we're already idle
    Assert(m_state == ONTS_IDLE)
        
        // Make sure we're initialized
        Assert(m_fInited);
    Assert(m_pInfo == NULL);
    
    // Copy the event id and event info
    m_eidCur = eid;
    m_pInfo = (ONEVENTINFO *) dwTwinkie;
    
    // Forget UI stuff if we're just going to cancel everything
    if (FALSE == m_fCancel)
    {
        // Update the event UI to an executing state
        Assert(m_pUI);
        m_pUI->UpdateEventState(m_eidCur, -1, NULL, MAKEINTRESOURCE(idsStateExecuting));
        m_pUI->SetProgressRange(1);
        
        // Set up the progress
        SetGeneralProgress((LPSTR)idsInetMailConnectingHost, m_szAccount);
        if (m_pInfo->fIMAP)
            m_pUI->SetAnimation(idanInbox, TRUE);
        else
            m_pUI->SetAnimation(idanDownloadNews, TRUE);
    }
    
    m_state = ONTS_INIT;
    
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return(S_OK);
}

HRESULT COfflineTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Make sure we're initialized
    Assert(m_fInited);
    
    Assert(dwTwinkie != 0);
    MemFree((ONEVENTINFO *)dwTwinkie);
    
    return(S_OK);
}

//
//  FUNCTION:   <???>
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT COfflineTask::ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   <???>
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT COfflineTask::GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, 
    LPSTR *ppszDetails)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   <???>
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT COfflineTask::Cancel(void)
{
    Assert(m_state != ONTS_IDLE);
    
    m_fCancel = TRUE;
    
    m_state = ONTS_END;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return (S_OK);
}


//
//  FUNCTION:   COfflineTask::TaskWndProc()
//
//  PURPOSE:    Hidden window that processes messages for this task.
//
LRESULT CALLBACK COfflineTask::TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COfflineTask *pThis = (COfflineTask *) GetProp(hwnd, c_szThis);
    
    switch (uMsg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
            pThis = (COfflineTask *) pcs->lpCreateParams;
            SetProp(hwnd, c_szThis, (LPVOID) pThis);
            return (0);
        }
        
        case NTM_NEXTSTATE:
            if (pThis)
            {
                pThis->AddRef();
                pThis->NextState();
                pThis->Release();
            }
            return (0);
        
        case NTM_NEXTARTICLESTATE:
            if (pThis)
            {
                pThis->AddRef();
                if (m_rgpfnArticle[pThis->m_as])
                    (pThis->*(m_rgpfnArticle[pThis->m_as]))();
                pThis->Release();
            }
            return (0);
        
        case WM_DESTROY:
            RemoveProp(hwnd, c_szThis);
            break;
    }
    
    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   COfflineTask::NextState()
//
//  PURPOSE:    Executes the function for the current state
//
void COfflineTask::NextState(void)
{
    if (m_fCancel)
        m_state = ONTS_END;
    
    if (NULL != m_rgpfnState[m_state])
        (this->*(m_rgpfnState[m_state]))();
}

//
//  FUNCTION:   COfflineTask::Download_Init()
//
//  PURPOSE:    Does the initialization needed to download headers and messages
//              for a particular newsgroup.
//
HRESULT COfflineTask::Download_Init(void)
{
    HRESULT hr;
    SYNCFOLDERFLAGS flags = SYNC_FOLDER_DEFAULT;
    FOLDERINFO info;
    
    Assert(m_pFolder == NULL);
    Assert(0 == flags); // If this isn't 0, please verify correctness
    
    hr = g_pStore->OpenFolder(m_pInfo->idGroup, NULL, NOFLAGS, &m_pFolder);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    Assert(m_pFolder != NULL);
    
    hr = g_pStore->GetFolderInfo(m_pInfo->idGroup, &info);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    if (m_pInfo->fIMAP)
    {
        // Get highest Msg ID the brute-force way (IMAP doesn't set dwClientHigh)
        GetHighestCachedMsgID(m_pFolder, &m_dwPrevHigh);
    }
    else
        m_dwPrevHigh = info.dwClientHigh;
    
    g_pStore->FreeRecord(&info);
    
    // Update the UI to an executing state
    Assert(m_pUI);
    m_pUI->UpdateEventState(m_eidCur, -1, NULL, MAKEINTRESOURCE(idsStateExecuting));
    m_fDownloadErrors = FALSE;
    
    // Check to see if the user wants us to download new headers
    if (GROUP_DOWNLOAD_FLAGS(m_pInfo->dwFlags))
    {
        if (!(m_pInfo->dwFlags & FOLDER_DOWNLOADALL) || m_pInfo->fIMAP)
            flags = SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS;
        else
            flags = SYNC_FOLDER_ALLFLAGS;

        // Update Progress
        SetGeneralProgress((LPSTR)idsLogCheckingNewMessages, m_pInfo->szGroup);
    }
    else
    {
        m_state = ONTS_ALLMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        
        return(S_OK);
    }
    
    // Before we download any headers, we need to make a note of what the current
    // server high is so we know which articles are new.
    
    hr = m_pFolder->Synchronize(flags, 0, (IStoreCallback *)this);
    Assert(hr != S_OK);
    
    if (hr == E_PENDING)
        hr = S_OK;
    
    if (m_pInfo->fIMAP)
    {
        m_pUI->SetAnimation(idanInbox, TRUE);    
        m_pBindCtx->Notify(DELIVERY_NOTIFY_RECEIVING, 0);
    }
    else
    {
        m_pUI->SetAnimation(idanDownloadNews, TRUE);    
        m_pBindCtx->Notify(DELIVERY_NOTIFY_RECEIVING_NEWS, 0);
    }
    
Failure:
    if (FAILED(hr))
    {
        // $$$$BUGBUG$$$$
        InsertError((LPSTR)idsLogErrorSwitchGroup, m_pInfo->szGroup, m_szAccount);
        m_fFailed = TRUE;
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    
    return (hr);
}

//
//  FUNCTION:   COfflineTask::Download_AllMsgs()
//
//  PURPOSE:    
//              
//
HRESULT COfflineTask::Download_AllMsgs(void)
{
    HRESULT hr;
    DWORD cMsgs, cMsgsBuf;
    LPMESSAGEID pMsgId;
    MESSAGEIDLIST list;
    MESSAGEINFO MsgInfo = {0};
    HROWSET hRowset = NULL;
    
    // Check to see if we even want to download all messages
    if (!(m_pInfo->dwFlags & FOLDER_DOWNLOADALL))
    {
        m_state = ONTS_NEWMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // We need to determine a list of messages to download.  What we're looking
    // to do is download all of the messages that we know about which are unread.
    // To do this, we need to find the intersection of the unread range list and
    // the known range list.
    
    // Create a Rowset
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    cMsgs = 0;
    cMsgsBuf = 0;
    pMsgId = NULL;
    
    // Get the first message
    while (S_OK == m_pFolder->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        if (0 == (MsgInfo.dwFlags & ARF_HASBODY) && 0 == (MsgInfo.dwFlags & ARF_IGNORE))
        {
            if (cMsgs == cMsgsBuf)
            {
                if (!MemRealloc((void **)&pMsgId, (cMsgsBuf + CMSGIDALLOC) * sizeof(MESSAGEID)))
                {
                    m_pFolder->FreeRecord(&MsgInfo);
                    
                    hr = E_OUTOFMEMORY;
                    break;
                }
                
                cMsgsBuf += CMSGIDALLOC;
            }
            
            pMsgId[cMsgs] = MsgInfo.idMessage;
            cMsgs++;
        }
        
        // Free the header info
        m_pFolder->FreeRecord(&MsgInfo);
    }
    
    // Release Lock
    m_pFolder->CloseRowset(&hRowset);
    
    // TODO: error handling
    Assert(!FAILED(hr));
    
    // Check to see if we found anything 
    if (cMsgs == 0)
    {
        // Nothing to download.  We should move on to the marked download 
        // state.
        Assert(pMsgId == NULL);
        
        m_state = ONTS_MARKEDMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // Update the general progress
    SetGeneralProgress((LPSTR)idsLogStartDownloadAll, m_pInfo->szGroup);
    
    list.cAllocated = 0;
    list.cMsgs = cMsgs;
    list.prgidMsg = pMsgId;
    
    // Ask for the first article
    hr = Article_Init(&list);
    
    if (pMsgId != NULL)
        MemFree(pMsgId);
    
Failure:
    if (FAILED(hr))
    {
        // $$$$BUGBUG$$$$
        InsertError((LPSTR)idsLogErrorSwitchGroup, m_pInfo->szGroup, m_szAccount);
        m_fFailed = TRUE;
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    
    return (hr);
}

//
//  FUNCTION:   COfflineTask::Download_NewMsgs()
//
//  PURPOSE:    This function determines if there are any new messages to be
//              downloaded.  If so, it creates a list of message numbers that
//              need to be downloaded.
//
HRESULT COfflineTask::Download_NewMsgs(void)
{
    HRESULT         hr;
    ROWORDINAL      iRow = 0;
    BOOL            fFound;
    HROWSET         hRowset;
    DWORD           cMsgs, cMsgsBuf;
    LPMESSAGEID     pMsgId;
    MESSAGEIDLIST   list;
    MESSAGEINFO     Message = {0};
    
    // Check to see if there are even new messages to download
    // Check to see if we even want to download all messages
    if (!(m_pInfo->dwFlags & FOLDER_DOWNLOADNEW) || !m_fNewHeaders)
    {
        // Move the next state
        m_state = ONTS_MARKEDMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // We've got new messages, build a range list of those message numbers.
    // This range list is essentially every number in the known range above
    // m_dwPrevHigh.
    
    hr = S_OK;
    
    cMsgs = 0;
    cMsgsBuf = 0;
    pMsgId = NULL;
    fFound = FALSE;
    
    // TODO: this method of figuring out if there are new msgs isn't going to work all
    // the time. if the previous high is removed from the store during syncing (cancelled
    // news post, deleted msg, expired news post, etc) and new headers are downloaded,
    // we won't pull down the new msgs. we need a better way of detecting new hdrs and
    // pulling down there bodies
    
    if (m_dwPrevHigh > 0)
    {
        Message.idMessage = (MESSAGEID)m_dwPrevHigh;
        
        // Find This Record.  If this fails, we go ahead and do a full scan which is less
        // efficient, but OK.
        if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, &iRow))
        {
            m_pFolder->FreeRecord(&Message);
        }
    }
    
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(m_pFolder->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iRow, NULL)))
        {
            // Get the first message
            while (S_OK == m_pFolder->QueryRowset(hRowset, 1, (void **)&Message, NULL))
            {
                if (cMsgs == cMsgsBuf)
                {
                    if (!MemRealloc((void **)&pMsgId, (cMsgsBuf + CMSGIDALLOC) * sizeof(MESSAGEID)))
                    {
                        m_pFolder->FreeRecord(&Message);
                        
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    
                    cMsgsBuf += CMSGIDALLOC;
                }
                
                // It's possible to have already downloaded the body if the message was
                // watched.  It's also possible for the message to be part of an ignored
                // thread.
                if (0 == (Message.dwFlags & ARF_HASBODY) && 0 == (Message.dwFlags & ARF_IGNORE) && (Message.idMessage >= (MESSAGEID) m_dwPrevHigh))
                {
                    pMsgId[cMsgs] = Message.idMessage;
                    cMsgs++;
                }
                
                // Free the header info
                m_pFolder->FreeRecord(&Message);
            }
            
        }
        
        // Release Lock
        m_pFolder->CloseRowset(&hRowset);
    }
    
    // TODO: error handling
    Assert(!FAILED(hr));
    
    // Check to see if there was anything added
    if (cMsgs == 0)
    {
        // Nothing to download.  We should move on to the marked download 
        // state.
        
        m_state = ONTS_MARKEDMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // Update the general progress
    SetGeneralProgress((LPSTR)idsLogStartDownloadAll, m_pInfo->szGroup);
    
    list.cAllocated = 0;
    list.cMsgs = cMsgs;
    list.prgidMsg = pMsgId;
    
    // Ask for the first article
    hr = Article_Init(&list);
    
    if (pMsgId != NULL)
        MemFree(pMsgId);
    
    return(hr);
}


//
//  FUNCTION:   COfflineTask::Download_MarkedMsgs()
//
//  PURPOSE:    
//              
//
HRESULT COfflineTask::Download_MarkedMsgs(void)
{
    HRESULT hr;
    HROWSET hRowset;
    DWORD cMsgs, cMsgsBuf;
    LPMESSAGEID pMsgId;
    MESSAGEIDLIST list;
    MESSAGEINFO MsgInfo;
    
    // Check to see if we even want to download marked messages
    if (!m_pInfo->fMarked)
    {
        // Move on to the next state
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // We need to determine a list of messages to download.  What we're looking
    // to do is download all of the messages that are marked which are unread.
    // To do this, we need to find the intersection of the unread range list and
    // the marked range list.
    
    // Create a Rowset
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    cMsgs = 0;
    cMsgsBuf = 0;
    pMsgId = NULL;
    
    // Get the first message
    while (S_OK == m_pFolder->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        if (((MsgInfo.dwFlags & ARF_DOWNLOAD) || (MsgInfo.dwFlags & ARF_WATCH)) && 0 == (MsgInfo.dwFlags & ARF_HASBODY))
        {
            if (cMsgs == cMsgsBuf)
            {
                if (!MemRealloc((void **)&pMsgId, (cMsgsBuf + CMSGIDALLOC) * sizeof(MESSAGEID)))
                {
                    m_pFolder->FreeRecord(&MsgInfo);
                    
                    hr = E_OUTOFMEMORY;
                    break;
                }
                
                cMsgsBuf += CMSGIDALLOC;
            }
            
            pMsgId[cMsgs] = MsgInfo.idMessage;
            cMsgs++;
        }
        
        // Free the header info
        m_pFolder->FreeRecord(&MsgInfo);
    }
    
    // Release Lock
    m_pFolder->CloseRowset(&hRowset);
    
    // TODO: error handling
    Assert(!FAILED(hr));
    
    // Check to see if we found anything 
    if (cMsgs == 0)
    {
        // Nothing to download.  We should move on to next state.
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // Update the general progress
    SetGeneralProgress((LPSTR)idsLogStartDownloadAll, m_pInfo->szGroup);
    
    list.cAllocated = 0;
    list.cMsgs = cMsgs;
    list.prgidMsg = pMsgId;
    
    // Ask for the first article
    hr = Article_Init(&list);
    
    if (pMsgId != NULL)
        MemFree(pMsgId);
    
Failure:
    if (FAILED(hr))
    {
        // $$$$BUGBUG$$$$
        InsertError((LPSTR)idsLogErrorSwitchGroup, m_pInfo->szGroup, m_szAccount);
        m_fFailed = TRUE;
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    
    return (hr);
}


//
//  FUNCTION:   COfflineTask::Download_Done()
//
//  PURPOSE:    
//              
//
HRESULT COfflineTask::Download_Done(void)
{
    // Make sure we don't get freed before we can clean up
    AddRef();
    
    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_dwNewInboxMsgs);
    
    if (m_fCancel)
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
    else if (m_fFailed)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_fDownloadErrors)
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    
    m_cEvents--;
    
    if (m_pFolder != NULL)
    {
        m_pFolder->Close();
        m_pFolder->Release();
        m_pFolder = NULL;
    }
    
    m_state = ONTS_IDLE;
    
    SafeMemFree(m_pInfo);
    
    Release();
    return (S_OK);
}


//
//  FUNCTION:   COfflineTask::InsertError()
//
//  PURPOSE:    This function is a wrapper for the ISpoolerUI::InsertError()
//              that takes the responsibility of loading the string resource
//              and constructing the error message.
//
void COfflineTask::InsertError(const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT; 
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       cbWritten;
    TCHAR       szBuf[2 * CCHMAX_STRINGRES];
    
    // If we were passed a string resource ID, then we need to load it
    if (IS_INTRESOURCE(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;
    
    // Format the string
    va_start(pArgs, pFmt);
    i = wvnsprintf(szBuf, ARRAYSIZE(szBuf), pszT, pArgs);
    va_end(pArgs);
    
    // Send the string to the UI
    m_pUI->InsertError(m_eidCur, szBuf);
}


//
//  FUNCTION:   COfflineTask::SetSpecificProgress()
//
//  PURPOSE:    This function is a wrapper for the ISpoolerUI::SetSpecificProgress()
//              that takes the responsibility of loading the string resource
//              and constructing the error message.
//
void COfflineTask::SetSpecificProgress(const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT; 
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       cbWritten;
    TCHAR       szBuf[2 * CCHMAX_STRINGRES];
    
    // If we were passed a string resource ID, then we need to load it
    if (IS_INTRESOURCE(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;
    
    // Format the string
    va_start(pArgs, pFmt);
    i = wvnsprintf(szBuf, ARRAYSIZE(szBuf), pszT, pArgs);
    va_end(pArgs);
    
    // Send the string to the UI
    m_pUI->SetSpecificProgress(szBuf);
}


//
//  FUNCTION:   COfflineTask::SetGeneralProgress()
//
//  PURPOSE:    This function is a wrapper for the ISpoolerUI::SetGeneralProgress()
//              that takes the responsibility of loading the string resource
//              and constructing the error message.
//
void COfflineTask::SetGeneralProgress(const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT; 
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       cbWritten;
    TCHAR       szBuf[2 * CCHMAX_STRINGRES];
    
    // If we were passed a string resource ID, then we need to load it
    if (IS_INTRESOURCE(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;
    
    // Format the string
    va_start(pArgs, pFmt);
    i = wvnsprintf(szBuf, ARRAYSIZE(szBuf), pszT, pArgs);
    va_end(pArgs);
    
    // Send the string to the UI
    m_pUI->SetGeneralProgress(szBuf);
}


//
//  FUNCTION:   COfflineTask::Article_Init()
//
//  PURPOSE:    Initializes the article download substate machine.
//
//  PARAMETERS:
//      <in> pRange - Range list of articles to download.
//
HRESULT COfflineTask::Article_Init(MESSAGEIDLIST *pList)
{
    HRESULT hr;
    
    Assert(pList != NULL);
    Assert(pList->cMsgs > 0);
    Assert(m_pList == NULL);
    
    hr = CloneMessageIDList(pList, &m_pList);
    if (FAILED(hr))
        return(hr);
    
    // Determine the first and the size
    m_cDownloaded = 0;
    m_cCur = 0;
    m_dwNewInboxMsgs = 0;
    
    // Set up the UI
    SetSpecificProgress((LPSTR)idsIMAPDnldProgressFmt, 0, m_pList->cMsgs);
    m_pUI->SetProgressRange((WORD)m_pList->cMsgs);        
    
    // Request the first one
    m_as = ARTICLE_GETNEXT;
    PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
    
    return(S_OK);
}


//
//  FUNCTION:   COfflineTask::Article_GetNext()
//
//  PURPOSE:    Determines the next article in the range of articles to
//              download and requests that article from the server.
//
HRESULT COfflineTask::Article_GetNext(void)
{
    HRESULT hr;
    LPMIMEMESSAGE pMsg = NULL;
    
    if (NULL == m_pFolder)
        return(S_OK);
    
    // Find out the next article number
    if (m_cCur == m_pList->cMsgs)
    {
        // We're done.  Exit.
        m_as = ARTICLE_END;
        PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
        return(S_OK);
    }
    
    m_cDownloaded++;
    // (YST) Bug 97397 We should send notification message from here too, because this is 
    // only one availble place for HTTP (fIMAP is set for HTTP).
    if(m_pInfo->fIMAP)
        OnProgress(SOT_NEW_MAIL_NOTIFICATION, 1, 0, NULL);
    
    // Update the progress UI
    SetSpecificProgress((LPSTR)idsIMAPDnldProgressFmt, m_cDownloaded, m_pList->cMsgs);
    m_pUI->IncrementProgress(1);
    
    // Ask for the article
    hr = m_pFolder->OpenMessage(m_pList->prgidMsg[m_cCur], 0, &pMsg, (IStoreCallback *)this);
    
    if (pMsg != NULL)
        pMsg->Release();
    m_cCur++;
    
    if (hr == E_PENDING)
    {
        m_as = ARTICLE_ONRESP;
    }
    else
    {
        // Whatever happened, we should move on to the next article.
        m_as = ARTICLE_GETNEXT;
        PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
    }
    
    return(S_OK);
}

//
//  FUNCTION:   COfflineTask::Article_Done()
//
//  PURPOSE:    When we've downloaded the last article, this function cleans
//              up and moves us to the next state.
//
HRESULT COfflineTask::Article_Done(void)
{
    // Free the range list we were working off of
    MemFree(m_pList);
    m_pList = NULL;
    
    // Move to the next state.  The next state is either get marked or done.
    if (m_state == ONTS_MARKEDMSGS)
        m_state = ONTS_END;
    else
        m_state = ONTS_MARKEDMSGS;
    
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return(S_OK);
}

STDMETHODIMP COfflineTask::IsDialogMessage(LPMSG pMsg)
{
    return S_FALSE;
}

STDMETHODIMP COfflineTask::OnFlagsChanged(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    
    return (S_OK);
}

STDMETHODIMP COfflineTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    // Hold onto this
    Assert(m_tyOperation == SOT_INVALID);
    
    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }
    m_tyOperation = tyOperation;
    
    m_dwPrev = 0;
    m_dwLast = 0;
    
    // Party On
    return(S_OK);
}

STDMETHODIMP COfflineTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    // NOTE: that you can get more than one type of value for tyOperation.
    //       Most likely, you will get SOT_CONNECTION_STATUS and then the
    //       operation that you might expect. See HotStore.idl and look for
    //       the STOREOPERATION enumeration type for more info.
    
    switch (tyOperation)
    {
        case SOT_CONNECTION_STATUS:
            break;
        
        case SOT_NEW_MAIL_NOTIFICATION:
            m_dwNewInboxMsgs += dwCurrent;
            break;
        
        default:
            if (m_state == ONTS_INIT)
            {
                // Update UI
                if (dwMax > m_dwLast)
                {
                    m_dwLast = dwMax;
                    m_pUI->SetProgressRange((WORD)m_dwLast);
                }
            
                SetSpecificProgress((LPSTR)idsDownloadingHeaders, dwCurrent, m_dwLast);
                m_pUI->IncrementProgress((WORD) (dwCurrent - m_dwPrev));
                m_dwPrev = dwCurrent;            
            }
    } // switch
    
    // Done
    return(S_OK);
}

STDMETHODIMP COfflineTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
    
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

STDMETHODIMP COfflineTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;
    
    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;
    
    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;
    
    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}

STDMETHODIMP COfflineTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;
    
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) &&
        !(ISFLAGSET(pServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pServer->szPassword[0]))
        return(S_FALSE);
    
    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;
    
    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

STDMETHODIMP COfflineTask::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete,
                                      LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    HRESULT hr;
    DWORD dw;
    BOOL fUserCancel = FALSE;
    
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    Assert(m_tyOperation != SOT_INVALID);
    if (m_tyOperation != tyOperation)
        return(S_OK);
    
    switch (hrComplete)
    {
        case STORE_E_EXPIRED:
        case IXP_E_HTTP_NOT_MODIFIED:
            // Completely ignore errors due to expired/deleted messages
            hrComplete = S_OK;
            break;
        
        case STORE_E_OPERATION_CANCELED:
        case HR_E_USER_CANCEL_CONNECT:
        case IXP_E_USER_CANCEL:
            fUserCancel = TRUE;
            break;
    }
    
    if (FAILED(hrComplete))
    {
        LPSTR       pszOpDescription = NULL;
        LPSTR       pszSubject = NULL;
        MESSAGEINFO Message;
        BOOL        fFreeMsgInfo = FALSE;
        char        szBuf[CCHMAX_STRINGRES], szFmt[CCHMAX_STRINGRES];
        
        switch (tyOperation)
        {
            case SOT_GET_MESSAGE:
                // we've already incremented m_cCur by the time we get this
                Assert((m_cCur - 1) < m_pList->cMsgs);
                Message.idMessage = m_pList->prgidMsg[m_cCur - 1];
            
                pszOpDescription = MAKEINTRESOURCE(idsNewsTaskArticleError);
                if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
                {
                    fFreeMsgInfo = TRUE;
                    pszSubject = Message.pszSubject;
                }
            
                break; // case SOT_GET_MESSAGE
            
            case SOT_SYNC_FOLDER:
                LoadString(g_hLocRes, idsHeaderDownloadFailureFmt, szFmt, sizeof(szFmt));
                wnsprintf(szBuf, ARRAYSIZE(szBuf), szFmt, (NULL == m_pInfo) ? c_szEmpty : m_pInfo->szGroup);
                pszOpDescription = szBuf;
                break;
            
            default:
                LoadString(g_hLocRes, idsMessageSyncFailureFmt, szFmt, sizeof(szFmt));
                wnsprintf(szBuf, ARRAYSIZE(szBuf), szFmt, (NULL == m_pInfo) ? c_szEmpty : m_pInfo->szGroup);
                pszOpDescription = szBuf;
                break; // default case
        } // switch
        
        m_fDownloadErrors = TRUE;
        if (NULL != pErrorInfo)
        {
            Assert(pErrorInfo->hrResult == hrComplete); // These two should not be different
            TaskUtil_InsertTransportError(ISFLAGCLEAR(m_dwFlags, DELIVER_NOUI), m_pUI, m_eidCur,
                pErrorInfo, pszOpDescription, pszSubject);
        }
        
        if (fFreeMsgInfo)
            m_pFolder->FreeRecord(&Message);
    }
    
    if (fUserCancel)
    {
        // User has cancelled the OnLogonPrompt dialog, so abort EVERYTHING
        Cancel();
    }
    else if (m_state == ONTS_INIT)
    {
        SetSpecificProgress((LPSTR)idsDownloadingHeaders, m_dwLast, m_dwLast);
        m_pUI->IncrementProgress((WORD) (m_dwLast - m_dwPrev));
        
        // Set a flag if we actually downloaded new headers
        m_fNewHeaders = (m_dwLast > 0);
        
        // Move to the next state
        m_state = ONTS_ALLMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    else
    {
        m_as = ARTICLE_GETNEXT;
        PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
    }
    
    // Release your cancel object
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;
    
    // Done
    return(S_OK);
}

STDMETHODIMP COfflineTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;
    
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif
    
    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;
    
    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

STDMETHODIMP COfflineTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

STDMETHODIMP COfflineTask::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
    
    if (m_pUI)
    {
        return m_pUI->GetWindow(phwndParent);
    }
    else
    {
        *phwndParent = NULL;
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\newstask.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     newstask.h
//
//  PURPOSE:    Implements a task object to take care of news downloads.
//

#ifndef __NEWSTASK_H__
#define __NEWSTASK_H__

#include "spoolapi.h"
#include "newsstor.h"
#include "StorUtil.h"

/////////////////////////////////////////////////////////////////////////////
// Types of events we support

#define HUNDRED_NANOSECONDS 10000000

typedef enum tagEVENTTYPE
    { 
    EVENT_OUTBOX,
    EVENT_NEWMSGS,
    EVENT_IMAPUPLOAD
    } EVENTTYPE;

typedef struct tagEVENTINFO 
    {
    TCHAR       szGroup[256];
    EVENTTYPE   type;
    } EVENTINFO;

typedef enum tagNEWSTASKSTATE
    {
    NTS_IDLE = 0,

    NTS_CONNECTING,

    NTS_POST_INIT,          
    NTS_POST_NEXT,          // Posting states
    NTS_POST_RESP,
    NTS_POST_DISPOSE,
    NTS_POST_END,

    NTS_NEWMSG_INIT,
    NTS_NEWMSG_NEXTGROUP,   // Check for new messages
    NTS_NEWMSG_RESP,
    NTS_NEWMSG_HTTPSYNCSTORE,
    NTS_NEWMSG_HTTPRESP,
    NTS_NEWMSG_END,

    NTS_MAX
    } NEWSTASKSTATE;

typedef struct tagSPLITMSGINFO
{
    FOLDERID                idFolder;
    LPMIMEMESSAGEPARTS      pMsgParts;
    LPMIMEENUMMESSAGEPARTS  pEnumParts;
} SPLITMSGINFO;

class CNewsTask;
typedef HRESULT (CNewsTask::*PFNSTATEFUNC)(THIS_ void);

/////////////////////////////////////////////////////////////////////////////
// class CNewsTask
// 
// Overview:
// This object defines and implements the ISpoolerTask interface to handle
// uploading and downloading information from a news server.
//
class CNewsTask : public ISpoolerTask, public IStoreCallback, public ITimeoutCallback
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    CNewsTask();
    ~CNewsTask();    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // ISpoolerTask Interface
    STDMETHOD(Init)(THIS_ DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHOD(BuildEvents)(THIS_ ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHOD(Execute)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(CancelEvent)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(GetExtendedDetails)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails);
    STDMETHOD(Cancel)(THIS);
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg);
    STDMETHOD(OnFlagsChanged)(THIS_ DWORD dwFlags);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback Interface
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback Interface
    STDMETHODIMP  OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

protected:
    /////////////////////////////////////////////////////////////////////////
    // Window callback and message handling
    static LRESULT CALLBACK TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam);

    /////////////////////////////////////////////////////////////////////////
    // These functions build the event list
    HRESULT InsertOutbox(LPTSTR szAccount, IImnAccount *pAccount);
    HRESULT InsertNewMsgs(LPTSTR pszAccount, IImnAccount *pAccount, BOOL fHttp);

    /////////////////////////////////////////////////////////////////////////
    // State Machine Stuff
    void NextState(void);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    HRESULT DisposeOfPosting(MESSAGEID dwMsgID);

public:
    /////////////////////////////////////////////////////////////////////////
    // Functions that upload posts
    HRESULT Post_Init(void);
    HRESULT Post_NextPart(void);
    HRESULT Post_NextMsg(void);
    HRESULT Post_Dispose(void);
    HRESULT Post_Done(void);

    /////////////////////////////////////////////////////////////////////////
    // Functions that check for new messages
    HRESULT NewMsg_Init(void);
    HRESULT NewMsg_InitHttp(void);
    HRESULT NewMsg_NextGroup(void);
    HRESULT NewMsg_HttpSyncStore(void);
    HRESULT NewMsg_Done(void);

private:
    void FreeSplitInfo(void);

    /////////////////////////////////////////////////////////////////////////
    // Private member data
    ULONG                   m_cRef;         // Object reference count

    // State
    BOOL                    m_fInited;      // TRUE if we've been initialized
    DWORD                   m_dwFlags;      // Flags passed in from the spooler engine
    NEWSTASKSTATE           m_state;        // Current state of the task
    EVENTID                 m_eidCur;       // Currently executing event
    EVENTINFO              *m_pInfo;        // EVENTINFO for the current event
    BOOL                    m_fConnectFailed;
    TCHAR                   m_szAccount[256];
    TCHAR                   m_szAccountId[256];
    FOLDERID                m_idAccount;
    DWORD                   m_cEvents;      // Number of events left to execute
    BOOL                    m_fCancel;
    IImnAccount             *m_pAccount;

    // Spooler Interfaces
    ISpoolerBindContext    *m_pBindCtx;     // Interface to communicate with the spooler engine
    ISpoolerUI             *m_pUI;          // Interface to communicate with the UI

    // News Object Pointers
    IMessageServer         *m_pServer;      // Pointer to the transport object
    IMessageFolder         *m_pOutbox;      // Pointer to the outbox
    IMessageFolder         *m_pSent;        // Pointer to the sent items folder

    // Windows
    HWND                    m_hwnd;         // Handle that recieves transport messages

    // Posting
    int                     m_cMsgsPost;    // Number of messages to post
    int                     m_cCurPost;     // Message currently being posted
    int                     m_cFailed;      // Number of messages which failed to post
    int                     m_cCurParts;    // Number of parts the current message includes
    int                     m_cPartsCompleted;  // Number of parts whose post have completed.
    BOOL                    m_fPartFailed;  // Did one of the parts fail?
    LPMESSAGEINFO           m_rgMsgInfo;    // Array of headers for messages to post
    SPLITMSGINFO           *m_pSplitInfo;
    
    // New messages check
    int                     m_cGroups;      // Number of groups we're checking
    int                     m_cCurGroup;    // Current group we're checking
    FOLDERID               *m_rgidGroups;   // Array of group folderids we're checking
    DWORD                   m_dwNewInboxMsgs; // Number of new msgs detected in Inbox

    // Callback 
    HTIMEOUT                m_hTimeout;
    IOperationCancel       *m_pCancel;
    STOREOPERATIONTYPE      m_tyOperation;    
    };

#endif // __NEWSTASK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\ontask.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     ontask.h
//
//  PURPOSE:    Defines the Offline News task.
//

#ifndef __ONTASK_H__
#define __ONTASK_H__

#include "spoolapi.h"
#include <storutil.h>

/////////////////////////////////////////////////////////////////////////////
// Forward references
//
class CNewsStore;

/////////////////////////////////////////////////////////////////////////////
// Types of events we support
//

typedef struct tagONEVENTINFO
    {
    char  szGroup[256];
    FOLDERID idGroup;
    DWORD dwFlags;
    BOOL  fMarked;
    BOOL  fIMAP;
    } ONEVENTINFO;
    
typedef enum tagONTASKSTATE 
    {
    ONTS_IDLE = 0,          // Idle    
    ONTS_CONNECTING,        // Waiting for a connect response
    ONTS_INIT,              // Initializing
    ONTS_HEADERRESP,        // Waiting for the header download
    ONTS_ALLMSGS,           // Downloading all messages
    ONTS_NEWMSGS,           // Downloading new messages
    ONTS_MARKEDMSGS,        // Downloading marked messages    
    ONTS_END,               // Cleanup
    ONTS_MAX
    } ONTASKSTATE;

typedef enum tagARTICLESTATE
    {
    ARTICLE_GETNEXT,
    ARTICLE_ONRESP,
    ARTICLE_END,

    ARTICLE_MAX
    } ARTICLESTATE;


class COfflineTask;
typedef HRESULT (COfflineTask::*PFNONSTATEFUNC)(THIS_ void);
typedef HRESULT (COfflineTask::*PFNARTICLEFUNC)(THIS_ void);
    
/////////////////////////////////////////////////////////////////////////////
// class COfflineTask
//    
// Overview:
// This object defines and implements the ISpoolerTask interface to handle 
// offline news functions.  This is a separate object from CNewsTask to 
// provide a logical separation between what needs to be done online versus
// what is only done offline in news.
//
class COfflineTask : public ISpoolerTask, public IStoreCallback, public ITimeoutCallback
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    COfflineTask();
    ~COfflineTask();    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // ISpoolerTask Interface
    STDMETHOD(Init)(THIS_ DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHOD(BuildEvents)(THIS_ ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHOD(Execute)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(CancelEvent)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(GetExtendedDetails)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails);
    STDMETHOD(Cancel)(THIS);
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg);
    STDMETHOD(OnFlagsChanged)(THIS_ DWORD dwFlags);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback Interface
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback Interface
    STDMETHODIMP  OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

private:
    /////////////////////////////////////////////////////////////////////////
    // Window callback and message handling
    static LRESULT CALLBACK TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    /////////////////////////////////////////////////////////////////////////
    // These functions build the event list
    HRESULT InsertGroups(IImnAccount *pAccount, FOLDERID idFolder);
    HRESULT InsertAllGroups(FOLDERID idParent, IImnAccount *pAccount, BOOL fIMAP);

    /////////////////////////////////////////////////////////////////////////
    // State Machine Stuff
    void NextState(void);

    HRESULT Download_Init(void);
    HRESULT Download_AllMsgs(void);
    HRESULT Download_NewMsgs(void);
    HRESULT Download_MarkedMsgs(void);
    HRESULT Download_Done(void);

    HRESULT Article_Init(MESSAGEIDLIST *pList);
    HRESULT Article_GetNext(void);
    HRESULT Article_OnResp(WPARAM wParam, LPARAM lParam);
    HRESULT Article_OnError(WPARAM wParam, LPARAM lParam);
    HRESULT Article_Done(void);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions

    void SetGeneralProgress(const TCHAR *pFmt, ...);
    void SetSpecificProgress(const TCHAR *pFmt, ...);
    void InsertError(const TCHAR *pFmt, ...);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private member data
    ULONG                   m_cRef;

    // State
    BOOL                    m_fInited;
    DWORD                   m_dwFlags;
    ONTASKSTATE             m_state;
    ARTICLESTATE            m_as;
    EVENTID                 m_eidCur;
    ONEVENTINFO            *m_pInfo;
    char                    m_szAccount[CCHMAX_ACCOUNT_NAME];
    char                    m_szAccountId[CCHMAX_ACCOUNT_NAME];
    FOLDERID                m_idAccount;
    DWORD                   m_cEvents;
    BOOL                    m_fDownloadErrors;
    BOOL                    m_fFailed;
    DWORD                   m_fNewHeaders;
    BOOL                    m_fCancel;

    // Spooler Interfaces
    ISpoolerBindContext    *m_pBindCtx;
    ISpoolerUI             *m_pUI;

    IMessageFolder         *m_pFolder;

    // Windows
    HWND                    m_hwnd;

    // State table
    static const PFNONSTATEFUNC m_rgpfnState[ONTS_MAX];
    static const PFNARTICLEFUNC m_rgpfnArticle[ARTICLE_MAX];

    // Used during event execution
    DWORD                   m_dwLast;
    DWORD                   m_dwPrev;
    DWORD                   m_cDownloaded;
    DWORD                   m_cCur;
    DWORD_PTR               m_dwPrevHigh;
    DWORD                   m_dwNewInboxMsgs;
    LPMESSAGEIDLIST         m_pList;

    // Callback 
    HTIMEOUT                m_hTimeout;
    IOperationCancel       *m_pCancel;
    STOREOPERATIONTYPE      m_tyOperation;    
    };
     

    
#endif // __ONTASK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\pop3task.cpp ===
// --------------------------------------------------------------------------------
// Pop3task.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "pop3task.h"
#include "resource.h"
#include "xputil.h"
#include "goptions.h"
#include "strconst.h"
#include "mimeutil.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "options.h"
#include "xpcomm.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "storecb.h"
#include "mailutil.h"
#include "ruleutil.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Debug Modifiers
// --------------------------------------------------------------------------------
#ifdef DEBUG
BOOL g_fUidlByTop = FALSE;
BOOL g_fFailTopCommand = FALSE;
LONG g_ulFailNumber=-1;
#endif

// --------------------------------------------------------------------------------
// ISLASTPOPID
// --------------------------------------------------------------------------------
#define ISLASTPOPID(_dwPopId) \
    (_dwPopId == m_rTable.cItems)

// --------------------------------------------------------------------------------
// ISVALIDPOPID
// --------------------------------------------------------------------------------
#define ISVALIDPOPID(_dwPopId) \
    (_dwPopId - 1 < m_rTable.cItems)

// --------------------------------------------------------------------------------
// ITEMFROMPOPID
// --------------------------------------------------------------------------------
#define ITEMFROMPOPID(_dwPopId) \
    (&m_rTable.prgItem[_dwPopId - 1])

// --------------------------------------------------------------------------------
// CPop3Task::CPop3Task
// --------------------------------------------------------------------------------
CPop3Task::CPop3Task(void)
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwState = 0;
    m_dwExpireDays = 0;
    m_pSpoolCtx = NULL;
    m_pAccount = NULL;
    m_pTransport = NULL;
    m_pUI = NULL;
    m_pIExecRules = NULL;
    m_pIRuleSender = NULL;
    m_pIRuleJunk = NULL;
    m_pInbox = NULL;
    m_pOutbox = NULL;
    m_eidEvent = 0;
    m_pUidlCache = NULL;
    m_uidlsupport = UIDL_SUPPORT_NONE;
    m_dwProgressMax = 0;
    m_dwProgressCur = 0;
    m_wProgress = 0;
    m_eidEvent = 0;
    m_hrResult = S_OK;
    m_pStream = NULL;
    m_state = POP3STATE_NONE;
    m_hwndTimeout = NULL;
    m_pLogFile = NULL;
    m_pSmartLog = NULL;
    *m_szAccountId = '\0';
    ZeroMemory(&m_rMetrics, sizeof(POP3METRICS));
    ZeroMemory(&m_rFolder, sizeof(POP3FOLDERINFO));
    ZeroMemory(&m_rTable, sizeof(POP3ITEMTABLE));
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPop3Task::~CPop3Task
// --------------------------------------------------------------------------------
CPop3Task::~CPop3Task(void)
{
    ZeroMemory(&m_rServer, sizeof(m_rServer));        // Done for security.

    // Reset the Object
    _ResetObject(TRUE);

    // Kill the critical section
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPop3Task::_ResetObject
// --------------------------------------------------------------------------------
void CPop3Task::_ResetObject(BOOL fDeconstruct)
{
    // Release Folder Objects
    _ReleaseFolderObjects();

    // Make sure the transport is disconnect
    if (m_pTransport)
    {
        m_pTransport->Release();
        m_pTransport = NULL;
    }

    // Release the Outbox
    SafeRelease(m_pAccount);
    SafeRelease(m_pInbox);
    SafeRelease(m_pOutbox);
    SafeRelease(m_pIExecRules);
    SafeRelease(m_pIRuleSender);
    SafeRelease(m_pIRuleJunk);
    SafeRelease(m_pSpoolCtx);
    SafeRelease(m_pUI);
    SafeRelease(m_pUidlCache);
    SafeRelease(m_pStream);
    SafeRelease(m_pLogFile);

    // Kill the log file
    _FreeSmartLog();

    // Free the event table elements
    _FreeItemTableElements();

    // Deconstructing
    if (fDeconstruct)
    {
        // Free Event Table
        SafeMemFree(m_rTable.prgItem);
    }

    // Otherwise, reset some vars
    else
    {
        // Reset total byte count
        m_dwFlags = 0;
        m_dwState = 0;
        m_dwExpireDays = 0;
        m_eidEvent = 0;
        m_wProgress = 0;
        m_uidlsupport = UIDL_SUPPORT_NONE;
        m_state = POP3STATE_NONE;
        ZeroMemory(&m_rFolder, sizeof(POP3FOLDERINFO));
        ZeroMemory(&m_rMetrics, sizeof(POP3METRICS));
        ZeroMemory(&m_rServer, sizeof(INETSERVER));
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_ReleaseFolderObjects
// --------------------------------------------------------------------------------
void CPop3Task::_ReleaseFolderObjects(void)
{
    // m_rFolder should have been release
    _CloseFolder();

    // Force Inbox Rules to release folder objects
    if (m_pIExecRules)
    {
        m_pIExecRules->ReleaseObjects();
    }

    // Download only locks the inbox
    SafeRelease(m_pInbox);
}

// --------------------------------------------------------------------------------
// CPop3Task::_FreeItemTableElements
// --------------------------------------------------------------------------------
void CPop3Task::_FreeItemTableElements(void)
{
    // Loop the table of events
    for (ULONG i=0; i<m_rTable.cItems; i++)
    {
        // Free pszForwardTo
        SafeMemFree(m_rTable.prgItem[i].pszUidl);
        RuleUtil_HrFreeActionsItem(m_rTable.prgItem[i].pActList, m_rTable.prgItem[i].cActList);
        SafeMemFree(m_rTable.prgItem[i].pActList);
    }

    // No Events
    m_rTable.cItems = 0;
}

// --------------------------------------------------------------------------------
// CPop3Task::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerTask *)this;
    else if (IID_ISpoolerTask == riid)
        *ppv = (ISpoolerTask *)this;
    else if (IID_ITimeoutCallback == riid)
        *ppv = (ITimeoutCallback *) this;
    else if (IID_ITransportCallbackService == riid)
        *ppv = (ITransportCallbackService *) this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::CPop3Task
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPop3Task::AddRef(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = ++m_cRef;
    LeaveCriticalSection(&m_cs);
    return cRef;
}

// --------------------------------------------------------------------------------
// CPop3Task::CPop3Task
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPop3Task::Release(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = --m_cRef;
    LeaveCriticalSection(&m_cs);
    if (0 != cRef)
        return cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CPop3Task::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Invalid Arg
    if (NULL == pBindCtx)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset this object
    _ResetObject(FALSE);

    // Save the Activity Flags - DELIVER_xxx
    m_dwFlags = dwFlags;

    // Hold onto the bind context
    Assert(NULL == m_pSpoolCtx);
    m_pSpoolCtx = pBindCtx;
    m_pSpoolCtx->AddRef();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::BuildEvents
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    // Locals
    HRESULT       hr=S_OK;
    DWORD         dw;
    CHAR          szAccountName[CCHMAX_ACCOUNT_NAME];
    CHAR          szRes[CCHMAX_RES];
    CHAR          szMessage[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    LPSTR         pszLogFile=NULL;
    DWORD         dwState;
    PROPVARIANT   propvar = {0};

    // Invalid Arg
    if (NULL == pSpoolerUI || NULL == pAccount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(NULL == m_pTransport && NULL == m_pAccount && NULL == m_pInbox && 0 == m_rTable.cItems);

    // Save the UI Object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Release current Account
    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Leave mail on server
    if (SUCCEEDED(m_pAccount->GetPropDw(AP_POP3_LEAVE_ON_SERVER, &dw)) && TRUE == dw)
        FLAGSET(m_dwState, POP3STATE_LEAVEONSERVER);

    // Delete Expire
    if (SUCCEEDED(m_pAccount->GetPropDw(AP_POP3_REMOVE_EXPIRED, &dw)) && TRUE == dw)
        FLAGSET(m_dwState, POP3STATE_DELETEEXPIRED);

    // Days to Expire
    if (FAILED(m_pAccount->GetPropDw(AP_POP3_EXPIRE_DAYS, &m_dwExpireDays)))
        m_dwExpireDays = 5;

    // Delete From Server when deleted from Deleted Items Folder...
    if (SUCCEEDED(m_pAccount->GetPropDw(AP_POP3_REMOVE_DELETED, &dw)) && TRUE == dw)
        FLAGSET(m_dwState, POP3STATE_SYNCDELETED);

    // Get the inbox rules object
    Assert(g_pRulesMan);
    CHECKHR(hr = g_pRulesMan->ExecRules(EXECF_ALL, RULE_TYPE_MAIL, &m_pIExecRules));

    // Get the block sender rule
    Assert(NULL == m_pIRuleSender);
    (VOID) g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_MAIL, 0, &m_pIRuleSender);

    // Only use it if it there and enabled
    if (NULL != m_pIRuleSender)
    {
        if (FAILED(m_pIRuleSender->GetProp(RULE_PROP_DISABLED, 0, &propvar)))
        {
            m_pIRuleSender->Release();
            m_pIRuleSender = NULL;
        }
        else
        {
            Assert(VT_BOOL == propvar.vt);
            if (FALSE != propvar.boolVal)
            {
                m_pIRuleSender->Release();
                m_pIRuleSender = NULL;
            }

            PropVariantClear(&propvar);
        }
    }
    
    Assert(NULL == m_pIRuleJunk);
    (VOID) g_pRulesMan->GetRule(RULEID_JUNK, RULE_TYPE_MAIL, 0, &m_pIRuleJunk);
    
    // Only use it if it enabled
    if (NULL != m_pIRuleJunk)
    {
        if (FAILED(m_pIRuleJunk->GetProp(RULE_PROP_DISABLED, 0, &propvar)))
        {
            m_pIRuleJunk->Release();
            m_pIRuleJunk = NULL;
        }
        else
        {
            Assert(VT_BOOL == propvar.vt);
            if (FALSE != propvar.boolVal)
            {
                m_pIRuleJunk->Release();
                m_pIRuleJunk = NULL;
            }

            PropVariantClear(&propvar);
        }
    }
    
    // Predownload rules
    CHECKHR(hr = m_pIExecRules->GetState(&dwState));

    // Do we have server actions to do?
    if (0 != (dwState & ACT_STATE_SERVER))
        FLAGSET(m_dwState, POP3STATE_PDR);

    // No Post Download Rules
    if ((0 == (dwState & (ACT_STATE_LOCAL|CRIT_STATE_ALL))) && 
              (NULL == m_pIRuleSender) && 
              (NULL == m_pIRuleJunk))
        FLAGSET(m_dwState, POP3STATE_NOPOSTRULES);

    // No Body Rules
    if ((ISFLAGSET(dwState, CRIT_STATE_ALL)) || (NULL != m_pIRuleJunk))
        FLAGSET(m_dwState, POP3STATE_BODYRULES);

    // Get the outbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&m_pOutbox));

    // Get a pop3 log file
    m_pSpoolCtx->BindToObject(IID_CPop3LogFile, (LPVOID *)&m_pLogFile);

    // Get Account Id
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccountName, ARRAYSIZE(szAccountName)));

    // Register Event - Get new messages from '%s'.
    LOADSTRING(IDS_SPS_POP3EVENT, szRes);

    // Format the String
    wnsprintf(szMessage, ARRAYSIZE(szMessage), szRes, szAccountName);

    // Register for the event...
    CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, POP3EVENT_DOWNLOADMAIL, m_pAccount, &m_eidEvent));

exit:
    // Failure
    if (FAILED(hr))
    {
        _CatchResult(hr);
        _ResetObject(FALSE);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_DoSmartLog
// --------------------------------------------------------------------------------
void CPop3Task::_DoSmartLog(IMimeMessage *pMessage)
{
    // Don't make the function call if this is null...
    Assert(m_pSmartLog && m_pSmartLog->pStmFile && m_pSmartLog->pszProperty && m_pSmartLog->pszValue && pMessage);

    // Do a query property...
    if (lstrcmpi("all", m_pSmartLog->pszProperty) == 0 || S_OK == pMessage->QueryProp(m_pSmartLog->pszProperty, m_pSmartLog->pszValue, TRUE, FALSE))
    {
        // Locals
        LPSTR       psz=NULL;
        PROPVARIANT rVariant;
        IStream     *pStream=NULL;

        // Get IAT_FROM
        if (FAILED(pMessage->GetAddressFormat(IAT_FROM, AFT_DISPLAY_BOTH, &psz)))
        {
            // Try IAT_SENDER
            pMessage->GetAddressFormat(IAT_SENDER, AFT_DISPLAY_BOTH, &psz);
        }

        // Write the Sender
        if (psz)
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(psz, lstrlen(psz), NULL)));

            // Free psz
            SafeMemFree(psz);
        }

        // Otherwise, write Unknown
        else
        {
            CHAR sz[255];
            LoadString(g_hLocRes, idsUnknown, sz, ARRAYSIZE(sz));
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(sz, lstrlen(sz), NULL)));
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Get IAT_CC
        if (SUCCEEDED(pMessage->GetAddressFormat(IAT_CC, AFT_DISPLAY_BOTH, &psz)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(psz, lstrlen(psz), NULL)));

            // Free psz
            SafeMemFree(psz);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the X-Mailer just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_HDR_XMAILER), 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the X-MimeOLE just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp("X-MimeOLE", 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the Subject just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_HDR_DATE), 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the Subject just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Write the first line of the message body
        if (FAILED(pMessage->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
        {
            // Try to get the HTML body
            if (FAILED(pMessage->GetTextBody(TXT_HTML, IET_DECODED, &pStream, NULL)))
                pStream = NULL;
        }

        // Did we find a stream
        if (pStream)
        {
            // Locals
            BYTE        rgBuffer[1048];
            ULONG       cbRead;
            ULONG       i;
            ULONG       cGood=0;

            // Read a buffer
            if (SUCCEEDED(pStream->Read(rgBuffer, sizeof(rgBuffer), &cbRead)))
            {
                // Write until we hit a \r or \n
                for (i=0; i<cbRead; i++)
                {
                    // End of line
                    if ('\r' == rgBuffer[i] || '\n' == rgBuffer[i])
                    {
                        // If we found 3 or more non-space chars, we found the first line
                        if (cGood > 3)
                            break;

                        // Otherwise, continue...
                        else
                        {
                            rgBuffer[i] = ' ';
                            cGood = 0;
                            continue;
                        }
                    }

                    // Replace Tabs with spaces so that it doesn't mess up tab delimited file
                    if ('\t' == rgBuffer[i])
                        rgBuffer[i] = ' ';

                    // If not a space
                    if (FALSE == FIsSpaceA((LPSTR)(rgBuffer + i)))
                        cGood++;
                }

                // Write the character
                m_pSmartLog->pStmFile->Write(rgBuffer, ((i > 0) ? i - 1 : i), NULL);
            }

            // Free psz
            SafeRelease(pStream);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(g_szCRLF, lstrlen(g_szCRLF), NULL)));
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_FreeSmartLog
// --------------------------------------------------------------------------------
void CPop3Task::_FreeSmartLog(void)
{
    if (m_pSmartLog)
    {
        SafeMemFree(m_pSmartLog->pszAccount);
        SafeMemFree(m_pSmartLog->pszProperty);
        SafeMemFree(m_pSmartLog->pszValue);
        SafeMemFree(m_pSmartLog->pszLogFile);
        SafeRelease(m_pSmartLog->pStmFile);
        g_pMalloc->Free(m_pSmartLog);
        m_pSmartLog = NULL;
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_ReadSmartLogEntry
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_ReadSmartLogEntry(HKEY hKey, LPCSTR pszKey, LPSTR *ppszValue)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;

    // Read the pszKey
    if (RegQueryValueEx(hKey, pszKey, NULL, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate
    cb++;
    CHECKALLOC(*ppszValue = PszAllocA(cb));

    // Read the pszKey
    if (RegQueryValueEx(hKey, pszKey, NULL, NULL, (LPBYTE)*ppszValue, &cb) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_InitializeSmartLog
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_InitializeSmartLog(void)
{
    // Locals
    HRESULT         hr=S_OK;
    HKEY            hKey=NULL;
    ULARGE_INTEGER  uliPos = {0,0};
    LARGE_INTEGER   liOrigin = {0,0};

    // Get Advanced Logging Information
    if (AthUserOpenKey(c_szRegPathSmartLog, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate smart log
    CHECKALLOC(m_pSmartLog = (LPSMARTLOGINFO)g_pMalloc->Alloc(sizeof(SMARTLOGINFO)));

    // Zero Init
    ZeroMemory(m_pSmartLog, sizeof(SMARTLOGINFO));

    // Read the Account
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "Account", &m_pSmartLog->pszAccount));

    // Read the Property
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "Property", &m_pSmartLog->pszProperty));

    // Read the ContainsValue
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "ContainsValue", &m_pSmartLog->pszValue));

    // Read the LogFile
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "LogFile", &m_pSmartLog->pszLogFile));

    // Open the logfile
    CHECKHR(hr = OpenFileStream(m_pSmartLog->pszLogFile, OPEN_ALWAYS, GENERIC_WRITE | GENERIC_READ, &m_pSmartLog->pStmFile));

    // Seek to the end
    CHECKHR(hr = m_pSmartLog->pStmFile->Seek(liOrigin, STREAM_SEEK_END, &uliPos));

exit:
    // Failure
    if (FAILED(hr))
        _FreeSmartLog();

    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::Execute
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szRes[CCHMAX_RES];
    CHAR        szBuf[CCHMAX_RES + CCHMAX_SERVER_NAME];
    DWORD       cb;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check State
    Assert(eid == m_eidEvent && m_pAccount && m_pUI);

    // Create the Transport Object
    CHECKHR(hr = CreatePOP3Transport(&m_pTransport));

    // Init the Transport
    CHECKHR(hr = m_pTransport->InitNew(NULL, (IPOP3Callback *)this));

    // Fill an INETSERVER structure from the account object
    CHECKHR(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rServer));

    // Get Account Id
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId)));

    // Always connect using the most recently supplied password from the user
    hr = GetPassword(m_rServer.dwPort, m_rServer.szServerName, m_rServer.szUserName,
        m_rServer.szPassword, sizeof(m_rServer.szPassword));

    // If this account is set to always prompt for password and password isn't
    // already cached, show UI so we can prompt user for password
    if (m_pUI && ISFLAGSET(m_rServer.dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) && FAILED(hr))
    {
        m_pUI->ShowWindow(SW_SHOW);
    }

    // Get Smart Logging INformation
    _InitializeSmartLog();

    // Set the animation
    m_pUI->SetAnimation(idanInbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    // Connecting to ...
    LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CONNECTING, 0);

    // Connect
    CHECKHR(hr = m_pTransport->Connect(&m_rServer, TRUE, TRUE));

exit:
    // Failure
    if (FAILED(hr))
    {
        FLAGSET(m_dwState, POP3STATE_EXECUTEFAILED);
        _CatchResult(hr);

        // Tell the transport to release my callback: otherwise I leak
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CPop3Task::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CPop3Task::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Is there currently a timeout dialog
    if (m_hwndTimeout)
    {
        // Set foreground
        SetForegroundWindow(m_hwndTimeout);
    }
    else
    {
        // Not suppose to be showing UI ?
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Do Timeout Dialog
        m_hwndTimeout = TaskUtil_HwndOnTimeout(m_rServer.szServerName, m_rServer.szAccount, "POP3", m_rServer.dwTimeout, (ITimeoutCallback *) this);

        // Couldn't create the dialog
        if (NULL == m_hwndTimeout)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Always tell the transport to keep on trucking
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    // Locals
    HRESULT hr=S_FALSE;
    char szPassword[CCHMAX_PASSWORD];

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, sizeof(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        StrCpyN(pInetServer->szPassword, szPassword, ARRAYSIZE(pInetServer->szPassword));
        ZeroMemory(szPassword, sizeof(szPassword));        // Done for security.
        return S_OK;
    }

    hr = S_FALSE; // Re-initialize

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // NOERRORS...
    if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        goto exit;

    // TaskUtil_OnLogonPrompt
    hr = TaskUtil_OnLogonPrompt(m_pAccount, m_pUI, NULL, pInetServer, AP_POP3_USERNAME,
                                AP_POP3_PASSWORD, AP_POP3_PROMPT_PASSWORD, TRUE);

    // Cache the password for this session
    if (S_OK == hr)
        SavePassword(pInetServer->dwPort, pInetServer->szServerName,
            pInetServer->szUserName, pInetServer->szPassword);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    ZeroMemory(szPassword, sizeof(szPassword));        // Done for security.

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CPop3Task::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport)
{
    // Locals
    HWND        hwnd;
    INT         nAnswer;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI);

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;

    // I assume this is a critical prompt, so I will not check for no UI mode
    nAnswer = MessageBox(hwnd, pszText, pszCaption, uType);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return nAnswer;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI);

    // Insert Error Into UI
    _CatchResult(POP3_NONE, pResult);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport)
{
    // Logging
    if (m_pLogFile && pszLine)
    {
        // Response
        if (CMD_RESP == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_RX, pszLine);

        // Send
        else if (CMD_SEND == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_TX, pszLine);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CPop3Task::_CatchResult(HRESULT hr)
{
    // Locals
    IXPRESULT   rResult;

    // Build an IXPRESULT
    ZeroMemory(&rResult, sizeof(IXPRESULT));
    rResult.hrResult = hr;

    // Get the SMTP Result Type
    return _CatchResult(POP3_NONE, &rResult);
}

// --------------------------------------------------------------------------------
// CPop3Task::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CPop3Task::_CatchResult(POP3COMMAND command, LPIXPRESULT pResult)
{
    // Locals
    HWND            hwndParent;
    TASKRESULTTYPE  tyTaskResult=TASKRESULT_FAILURE;

    // If Succeeded
    if (SUCCEEDED(pResult->hrResult))
        return TASKRESULT_SUCCESS;

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    // Process generic protocol errro
    tyTaskResult = TaskUtil_FBaseTransportError(IXP_POP3, m_eidEvent, pResult, &m_rServer, NULL, m_pUI,
                                                !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

    // Save Result
    m_hrResult = pResult->hrResult;

    // If Task Failure, drop the connection
    if (NULL != m_pTransport)
        m_pTransport->DropConnection();

    // Return Result
    return tyTaskResult;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    // Locals
    EVENTCOMPLETEDSTATUS tyEventStatus=EVENT_SUCCEEDED;

    // Invalid State
    Assert(m_pUI && m_pSpoolCtx);
    if (!m_pUI || !m_pSpoolCtx)
    {
        return E_FAIL;
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Feed the the IXP status to the UI object
    m_pUI->SetSpecificProgress(MAKEINTRESOURCE(XPUtil_StatusToString(ixpstatus)));

    // Disconnected
    if (ixpstatus == IXP_DISCONNECTED)
    {
        // Locals
        BOOL fWarning=FALSE;

        // Note that OnDisconnect was called
        FLAGSET(m_dwState, POP3STATE_ONDISCONNECT);

        // If a UIDL Sync is in progress, then return now...
        if (POP3STATE_UIDLSYNC == m_state)
            goto exit;

        // Kill the timeout dialog
        if (m_hwndTimeout)
        {
            DestroyWindow(m_hwndTimeout);
            m_hwndTimeout = NULL;
        }

        // Cache Cleanup
        _CleanupUidlCache();

        // Reset the progress
        // m_pUI->SetProgressRange(100);

        // State
        m_state = POP3STATE_NONE;

        // Set the animation
        m_pUI->SetAnimation(idanInbox, FALSE);

        // Infinite Loop
        if (m_rMetrics.cInfiniteLoopAutoGens)
        {
            // Load the Warning
            CHAR szRes[CCHMAX_RES];
            LOADSTRING(idsReplyForwardLoop, szRes);

            // Format the Error
            CHAR szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_SERVER_NAME + CCHMAX_RES];
            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rMetrics.cInfiniteLoopAutoGens, m_rServer.szAccount, m_rServer.szServerName);

            // Insert the warning
            m_pUI->InsertError(m_eidEvent, szMsg);

            // Warning
            fWarning = TRUE;
        }

        // Nothing to download
        if (ISFLAGSET(m_dwState, POP3STATE_CANCELPENDING))
            tyEventStatus = EVENT_CANCELED;
        else if (FAILED(m_hrResult) || (m_rMetrics.cDownloaded == 0 && m_rMetrics.cDownload > 0))
            tyEventStatus = EVENT_FAILED;
        else if (!ISFLAGSET(m_dwState, POP3STATE_LOGONSUCCESS))
            tyEventStatus = EVENT_WARNINGS;
        else if (m_rMetrics.cDownloaded && m_rMetrics.cDownload && m_rMetrics.cDownloaded < m_rMetrics.cDownload)
            tyEventStatus = EVENT_WARNINGS;
        else if (fWarning)
            tyEventStatus = EVENT_WARNINGS;

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

        // Success and messages were downloaded
        if (EVENT_FAILED != tyEventStatus && m_rMetrics.cDownloaded && m_rMetrics.cPartials)
        {
            // Sitch Partials
            _HrStitchPartials();
        }

        // Notify
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_rMetrics.cDownloaded);

        // Tell the transport to release my callback
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);

        // This task is complete
        if (!ISFLAGSET(m_dwState, POP3STATE_EXECUTEFAILED))
            m_pSpoolCtx->EventDone(m_eidEvent, tyEventStatus);
    }

    // Authorizing
    else if (ixpstatus == IXP_AUTHORIZING)
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_AUTHORIZING, 0);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::_CleanupUidlCache
// --------------------------------------------------------------------------------
void CPop3Task::_CleanupUidlCache(void)
{
    // Locals
    ULONG       i;
    UIDLRECORD  UidlInfo={0};
    LPPOP3ITEM  pItem;

    // No Cache Objects
    if (NULL == m_pUidlCache)
        return;

    // Count the number of messages we will have to get a top for
    for (i=0; i<m_rTable.cItems; i++)
    {
        // Readability
        pItem = &m_rTable.prgItem[i];

        // Delete the Cached Uidl
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETED) && ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL))
        {
            // No UIDL
            if (pItem->pszUidl)
            {
                // Set Search Info
                UidlInfo.pszUidl = pItem->pszUidl;
                UidlInfo.pszServer = m_rServer.szServerName;
                UidlInfo.pszAccountId = m_szAccountId;

                // Set Props on the cached uidl message
                m_pUidlCache->DeleteRecord(&UidlInfo);
            }
        }
    }

    // Remove all traces of if the account from the uid cache
    if (ISFLAGSET(m_dwState, POP3STATE_CLEANUPCACHE))
    {
        // Locaks
        HROWSET hRowset=NULL;

        // Create a rowset
        if (SUCCEEDED(m_pUidlCache->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset)))
        {
            // Delete Enumeration
            while (S_OK == m_pUidlCache->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
            {
                // Delete this puppy ?
                if (lstrcmpi(UidlInfo.pszServer, m_rServer.szServerName) == 0 && 
                    UidlInfo.pszAccountId != NULL &&
                    lstrcmpi(UidlInfo.pszAccountId, m_szAccountId) == 0)
                {
                    // Delete this record
                    m_pUidlCache->DeleteRecord(&UidlInfo);
                }

                // Free
                m_pUidlCache->FreeRecord(&UidlInfo);
            }

            // Purge everthing that matches this
            m_pUidlCache->CloseRowset(&hRowset);
        }
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnResponse(LPPOP3RESPONSE pResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Testing UIDL Command
    if (m_uidlsupport == UIDL_SUPPORT_TESTING_UIDL_COMMAND && POP3_UIDL == pResponse->command)
    {
#ifdef DEBUG
        pResponse->rIxpResult.hrResult = g_fUidlByTop ? E_FAIL : pResponse->rIxpResult.hrResult;
#endif
        // Failure ?
        if (FAILED(pResponse->rIxpResult.hrResult))
        {
            // Set Specific Progress
            //CHAR szRes[CCHMAX_RES];
            //LOADSTRING(IDS_SPS_POP3UIDL_UIDL, szRes);
            //m_pUI->SetSpecificProgress(szRes);

            // Try to top command
            _CatchResult(m_pTransport->CommandTOP(POP3CMD_GET_POPID, 1, 0));

            // Testing by top command
            m_uidlsupport = UIDL_SUPPORT_TESTING_TOP_COMMAND;
        }

        // Otherwise
        else
        {
            // State
            m_state = POP3STATE_GETTINGUIDLS;

            // Using the UIDL command
            m_uidlsupport = UIDL_SUPPORT_USE_UIDL_COMMAND;

            // Set Specific Progress
            //CHAR szRes[CCHMAX_RES];
            //LOADSTRING(IDS_SPS_POP3UIDL_UIDL, szRes);
            //m_pUI->SetSpecificProgress(szRes);

            // Issue full UIDL command
            _CatchResult(m_pTransport->CommandUIDL(POP3CMD_GET_ALL, 0));
        }

        // Done
        goto exit;
    }

    // Testing Top Command
    else if (m_uidlsupport == UIDL_SUPPORT_TESTING_TOP_COMMAND && POP3_TOP == pResponse->command)
    {
#ifdef DEBUG
        pResponse->rIxpResult.hrResult = g_fFailTopCommand ? E_FAIL : pResponse->rIxpResult.hrResult;
#endif
        // Failure ?
        if (FAILED(pResponse->rIxpResult.hrResult))
        {
            // Disable the leave on server option in the account
            m_pAccount->SetPropDw(AP_POP3_LEAVE_ON_SERVER, FALSE);

            // Save the Changed
            m_pAccount->SaveChanges();

            // Failure
            _CatchResult(SP_E_CANTLEAVEONSERVER);

            // Done
            goto exit;
        }

        // Using the UIDL command
        else
        {
            // State
            m_state = POP3STATE_GETTINGUIDLS;

            // Set this and fall through to the switch...
            m_uidlsupport = UIDL_SUPPORT_USE_TOP_COMMAND;
        }
    }

#ifdef DEBUG
    if (POP3_RETR == pResponse->command && TRUE == pResponse->fDone && (ULONG)g_ulFailNumber == pResponse->rRetrInfo.dwPopId)
        pResponse->rIxpResult.hrResult = E_FAIL;
#endif

    // If Succeeded
    if (FAILED(pResponse->rIxpResult.hrResult))
    {
        // Get Window
        HWND hwndParent;
        if (FAILED(m_pUI->GetWindow(&hwndParent)))
            hwndParent = NULL;

        // Dont drop if working on POP3_PASS or POP3_USER
        if (POP3_PASS == pResponse->command || POP3_USER == pResponse->command)
        {
            // Log an Error ? If the user's password is not empty or they have fSavePassword enabled
            TaskUtil_FBaseTransportError(IXP_POP3, m_eidEvent, &pResponse->rIxpResult, &m_rServer, NULL, m_pUI, !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

            // Done
            goto exit;
        }

        // Command base Failure
        else if (POP3_RETR == pResponse->command)
        {
            // Message Number %d could not be retrieved."
            CHAR szRes[CCHMAX_RES];
            LoadString(g_hLocRes, IDS_SP_E_RETRFAILED, szRes, ARRAYSIZE(szRes));

            // Format the Error
            CHAR szMsg[CCHMAX_RES + CCHMAX_RES];
            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, pResponse->rRetrInfo.dwPopId);

            // Fill the IXPRESULT
            IXPRESULT rResult;
            CopyMemory(&rResult, &pResponse->rIxpResult, sizeof(IXPRESULT));
            rResult.pszProblem = szMsg;
            rResult.hrResult = SP_E_POP3_RETR;

            // Insert the Error
            TaskUtil_FBaseTransportError(IXP_POP3, m_eidEvent, &rResult, &m_rServer, NULL, m_pUI, !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

            // Close Current Folder
            _CloseFolder();

            // Retrieve the next message
            _CatchResult(_HrRetrieveNextMessage(pResponse->rRetrInfo.dwPopId));

            // Done
            goto exit;
        }

        // Default Error Handler
        else if (TASKRESULT_SUCCESS != _CatchResult(pResponse->command, &pResponse->rIxpResult))
            goto exit;
    }

    // Handle Command Type
    switch(pResponse->command)
    {
    case POP3_CONNECTED:
        // Notify
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CHECKING, 0);

        // Logon Success
        FLAGSET(m_dwState, POP3STATE_LOGONSUCCESS);

        // Issue the STAT command
        _CatchResult(m_pTransport->CommandSTAT());
        break;

    case POP3_STAT:
        // Process the StatCommand
        _CatchResult(_HrOnStatResponse(pResponse));
        break;

    case POP3_LIST:
        // Process the List Command
        _CatchResult(_HrOnListResponse(pResponse));
        break;

    case POP3_UIDL:
        // Process the Uidl Command
        _CatchResult(_HrOnUidlResponse(pResponse));
        break;

    case POP3_TOP:
        // Process the Top Command
        _CatchResult(_HrOnTopResponse(pResponse));
        break;

    case POP3_RETR:
        // Process Retreive Response
        _CatchResult(_HrOnRetrResponse(pResponse));
        break;

    case POP3_DELE:
        // Process Delete Response
        _CatchResult(_HrDeleteNextMessage(pResponse->dwPopId));
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrLockUidlCache
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrLockUidlCache(void)
{
    // Locals
    HRESULT hr=S_OK;

    // No Cache yet ?
    if (NULL == m_pUidlCache)
    {
        // Lets the the UID Cache
        CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CUidlCache, (LPVOID *)&m_pUidlCache));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnStatResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnStatResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szSize[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_RES];
    BOOL            fFound;

    // Progress
    LOADSTRING(IDS_SPS_POP3CHECKING, szRes);
    wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szMsg);

    // Update Event Status
    LOADSTRING(IDS_SPS_POP3TOTAL, szRes);
    StrFormatByteSizeA(pResponse->rStatInfo.cbMessages, szSize, ARRAYSIZE(szSize));
    wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rServer.szAccount, pResponse->rStatInfo.cMessages, szSize);
    m_pUI->UpdateEventState(m_eidEvent, -1, szMsg, NULL);

    // No New Messages ?
    if (0 == pResponse->rStatInfo.cMessages)
    {
        m_pTransport->Disconnect();
        goto exit;
    }

    // Save total byte count
    m_rMetrics.cbTotal = pResponse->rStatInfo.cbMessages;

    // Assume no clean cache
    FLAGCLEAR(m_dwState, POP3STATE_CLEANUPCACHE);

    // If Leave on Server, return TRUE
    if (ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER))
    {
        // Lock the tree
        CHECKHR(hr = _HrLockUidlCache());

        // We will need to get the uidls
        FLAGSET(m_dwState, POP3STATE_GETUIDLS);
    }

    // Okay, we may still need to get the uidls if
    else
    {
        // Locals
        UIDLRECORD  UidlInfo={0};
        HROWSET     hRowset=NULL;

        // Lock the tree
        CHECKHR(hr = _HrLockUidlCache());

        // Create a Rowset
        CHECKHR(hr = m_pUidlCache->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

        // Delete Enumeration
        while (S_OK == m_pUidlCache->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
        {
            // Delete this puppy ?
            if (lstrcmpi(UidlInfo.pszServer, m_rServer.szServerName) == 0 &&
                UidlInfo.pszAccountId != NULL && 
                lstrcmpi(UidlInfo.pszAccountId, m_szAccountId) == 0)
            {
                // Get Uidls from the server
                FLAGSET(m_dwState, POP3STATE_GETUIDLS);

                // Cleanup the uidl cache when complete
                FLAGSET(m_dwState, POP3STATE_CLEANUPCACHE);

                // Free
                m_pUidlCache->FreeRecord(&UidlInfo);

                // Done
                break;
            }

            // Free
            m_pUidlCache->FreeRecord(&UidlInfo);
        }

        // Purge everthing that matches this
        m_pUidlCache->CloseRowset(&hRowset);
    }

    // Allocate the Item Table
    CHECKALLOC(m_rTable.prgItem = (LPPOP3ITEM)g_pMalloc->Alloc(sizeof(POP3ITEM) * pResponse->rStatInfo.cMessages));

    // Set Counts
    m_rTable.cAlloc = m_rTable.cItems = pResponse->rStatInfo.cMessages;

    // Zeroinit Array
    ZeroMemory(m_rTable.prgItem, sizeof(POP3ITEM) * pResponse->rStatInfo.cMessages);

    // Initialize Progress
    m_dwProgressMax = m_rTable.cItems;

    // If we need to get the UIDL list, lets test for it...
    if (ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
        m_dwProgressMax += (m_rTable.cItems * 4);

    // Otherwise
    else
    {
        // Release the Uidl Cache Lock
        SafeRelease(m_pUidlCache);
    }

    // Progress Current
    m_dwProgressCur = 0;

    // Predownload rules increases mprogress
    if (ISFLAGSET(m_dwState, POP3STATE_PDR))
        m_dwProgressMax += m_rTable.cItems;

    // Set Specific Progress
    LOADSTRING(IDS_SPS_POP3STAT, szRes);
    m_pUI->SetSpecificProgress(szRes);

    // Set the uidl command to see if the user supports it
    CHECKHR(hr = m_pTransport->CommandLIST(POP3CMD_GET_ALL, 0));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnTopResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnTopResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwPopId=pResponse->rTopInfo.dwPopId;
    LPPOP3ITEM          pItem;
    IMimePropertySet   *pHeader=NULL;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES+CCHMAX_RES];

    // Validate the Item
    Assert(ISVALIDPOPID(dwPopId));

    // Get the current item
    pItem = ITEMFROMPOPID(dwPopId);

    // We should assume that were downloading this item at this point
    Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD));

    // No stream yet ?
    if (NULL == m_pStream)
    {
        // Create a Stream
        CHECKHR(hr = MimeOleCreateVirtualStream(&m_pStream));
    }

    // If this infor is valid
    if (TRUE == pResponse->fValidInfo)
    {
        // Write the data into the stream
        CHECKHR(hr = m_pStream->Write(pResponse->rTopInfo.pszLines, pResponse->rTopInfo.cbLines, NULL));
    }

    // Is the command done ?
    if (TRUE == pResponse->fDone)
    {
        // Commit the stream
        CHECKHR(hr = m_pStream->Commit(STGC_DEFAULT));

        // Getting UIDL
        if (POP3STATE_GETTINGUIDLS == m_state)
        {
            // Better not have a uidl yet
            Assert(NULL == pItem->pszUidl);

            // Increment Progress
            m_dwProgressCur+=2;

            // Set Specific Progress
            //LOADSTRING(IDS_SPS_POP3UIDL_TOP, szRes);
            //wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, dwPopId, m_rTable.cItems);
            //m_pUI->SetSpecificProgress(szMsg);

            // Get Uidl From HeaderStream
            CHECKHR(hr = _HrGetUidlFromHeaderStream(m_pStream, &pItem->pszUidl, &pHeader));
        }

        // Otherwise, just increment one
        else
            m_dwProgressCur++;

        // Show Progress
        _DoProgress();

        // If we plan on downloading this thing
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD) && ISFLAGSET(m_dwState, POP3STATE_PDR))
        {
            // Check Inbox Rule for this item
            _ComputeItemInboxRule(pItem, m_pStream, pHeader, NULL, TRUE);
        }

        // Release the current stream
        SafeRelease(m_pStream);

        // Totally Done ?
        if (ISLASTPOPID(dwPopId))
        {
            // Start the download process
            CHECKHR(hr = _HrStartDownloading());
        }

        // Otherwise, lets get the top of the next item
        else if (POP3STATE_GETTINGUIDLS == m_state)
        {
            // Next Top
            CHECKHR(hr = m_pTransport->CommandTOP(POP3CMD_GET_POPID, dwPopId + 1, 0));
        }

        // Otherwise, find next message marked for download to check against predownload rules
        else
        {
            // NextTopForInboxRule
            CHECKHR(hr = _HrNextTopForInboxRule(dwPopId));
        }
    }

exit:
    // Cleanup
    SafeRelease(pHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnUidlResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnUidlResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwPopId=pResponse->rUidlInfo.dwPopId;
    LPPOP3ITEM      pItem;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_RES];

    // Is the command done ?
    if (TRUE == pResponse->fDone)
    {
        // If there are pre-download rules that are not size only, get all the tops
        if (ISFLAGSET(m_dwState, POP3STATE_PDR))
        {
            // Clear the state
            m_state = POP3STATE_NONE;

            // NextTopForInboxRule
            CHECKHR(hr = _HrStartServerSideRules());
        }

        // Otherwise, do the list command
        else
        {
            // Start the download process
            CHECKHR(hr = _HrStartDownloading());
        }
    }

    // Otherwise
    else
    {
        // Make Sure PopId is on current iitem
        Assert(ISVALIDPOPID(dwPopId) && pResponse->rUidlInfo.pszUidl);

        // Get Current Item
        pItem = ITEMFROMPOPID(dwPopId);

        // Duplicate the Uidl
        CHECKALLOC(pItem->pszUidl = PszDupA(pResponse->rUidlInfo.pszUidl));

        // Increment Progress
        m_dwProgressCur+=1;

        // Do progress
        _DoProgress();
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnListResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnListResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwPopId=pResponse->rListInfo.dwPopId;
    LPPOP3ITEM      pItem;

    // Is the command done ?
    if (TRUE == pResponse->fDone)
    {
        // If we need to get the UIDL list, lets test for it...
        if (ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
        {
            // Set the uidl command to see if the user supports it
            CHECKHR(hr = m_pTransport->CommandUIDL(POP3CMD_GET_POPID, 1));

            // Set State
            m_uidlsupport = UIDL_SUPPORT_TESTING_UIDL_COMMAND;
        }

        // Otherwise
        else
        {
            // Predownload rules increases mprogress
            if (ISFLAGSET(m_dwState, POP3STATE_PDR))
            {
                // Clear the state
                m_state = POP3STATE_NONE;

                // NextTopForInboxRule
                CHECKHR(hr = _HrStartServerSideRules());
            }

            // Otherwise, do the list command
            else
            {
                // Start the download process
                CHECKHR(hr = _HrStartDownloading());
            }
        }
    }

    // Otherwise
    else
    {
        // Make Sure PopId is on current iitem
        if(!ISVALIDPOPID(dwPopId))
            return(E_FAIL);

        // Get Current Item
        pItem = ITEMFROMPOPID(dwPopId);

        // Duplicate the Uidl
        pItem->cbSize = pResponse->rListInfo.cbSize;

        // Assume we will download it
        FLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD | POP3ITEM_DELETEOFFSERVER);

        // Increment Progress
        m_dwProgressCur++;

        // Do progress
        _DoProgress();

        // This yields so that other threads can execute
        //Sleep(0);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrStartDownloading
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStartDownloading(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szSize1[CCHMAX_RES];
    CHAR            szSize2[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_RES];

    // State
    Assert(m_rMetrics.cLeftByRule == 0 && m_rMetrics.cDownload == 0 && m_rMetrics.cDelete == 0 && m_rMetrics.cbDownload == 0);

    // If we got uidls, then lets do the cache compare lookup
    if (!ISFLAGSET(m_dwState, POP3STATE_PDR) && ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
    {
        // Returns FALSE if user cancel
        CHECKHR(hr = _HrDoUidlSynchronize());
    }

    // Compute number of new messages to download
    for (i=0; i<m_rTable.cItems; i++)
    {
        // Download ?
        if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_DOWNLOAD))
        {
            // Increment total number of bytes we will download
            m_rMetrics.cbDownload += m_rTable.prgItem[i].cbSize;

            // Increment count of messages we will download
            m_rMetrics.cDownload++;

            // Set running total in pop3 item
            m_rTable.prgItem[i].dwProgressCur = m_rMetrics.cbDownload;
        }

        // Count Left By Rule in case we don't download anything
        else if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_LEFTBYRULE))
            m_rMetrics.cLeftByRule++;

        // Delete
        if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_DELETEOFFSERVER))
        {
            // Number of messages we will delete
            m_rMetrics.cDelete++;
        }
    }

    // Update Event Status
    LOADSTRING(IDS_SPS_POP3NEW, szRes);
    StrFormatByteSizeA(m_rMetrics.cbDownload, szSize1, ARRAYSIZE(szSize1));
    StrFormatByteSizeA(m_rMetrics.cbTotal, szSize2, ARRAYSIZE(szSize2));
    wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rServer.szAccount, m_rMetrics.cDownload, szSize1, m_rTable.cItems, szSize2);
    m_pUI->UpdateEventState(m_eidEvent, -1, szMsg, NULL);

    // New Messages ?
    if (m_rMetrics.cDownload > 0)
    {
        // Setup Progress
        m_rMetrics.iCurrent = 0;
        m_wProgress = 0;
        m_dwProgressCur = 0;
        m_dwProgressMax = m_rMetrics.cbDownload;
        m_pUI->SetProgressRange(100);
        m_rMetrics.cLeftByRule = 0;

        // Notify
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RECEIVING, 0);

        // State
        m_state = POP3STATE_DOWNLOADING;

        // Open the Inbox
        Assert(NULL == m_pInbox);
        CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreInbox, (LPVOID *)&m_pInbox));

        // Download the Next Message
        CHECKHR(hr = _HrRetrieveNextMessage(0));
    }

    // Otherwise if cDelete
    else if (m_rMetrics.cDelete > 0)
    {
        // Delete the Next Message
        CHECKHR(hr = _HrStartDeleteCycle());
    }

    // Otherwise, disconnect
    else
    {
        // Disconnect
        CHECKHR(hr = m_pTransport->Disconnect());
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_DoProgress
// --------------------------------------------------------------------------------
void CPop3Task::_DoProgress(void)
{
    // Compute Current Progress Index
    WORD wProgress;
    if (m_dwProgressMax > 0)
        wProgress = (WORD)((m_dwProgressCur * 100) / m_dwProgressMax);
    else
        wProgress = 0;

    // Only if greater than
    if (wProgress > m_wProgress)
    {
        // Compute Delta
        WORD wDelta = wProgress - m_wProgress;

        // Progress Delta
        if (wDelta > 0)
        {
            // Incremenet Progress
            m_pUI->IncrementProgress(wDelta);

            // Increment my wProgress
            m_wProgress += wDelta;

            // Don't go above 100
            if (m_wProgress > 100)
                m_wProgress = 100;
        }
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrGetUidlFromHeaderStream
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrGetUidlFromHeaderStream(IStream *pStream, LPSTR *ppszUidl, IMimePropertySet **ppHeader)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimePropertySet   *pHeader=NULL;

    // Invalid Arg
    Assert(pStream && ppszUidl);

    // Init
    *ppszUidl = NULL;
    *ppHeader = NULL;

    // Rewind Header Stream
    CHECKHR(hr = HrRewindStream(pStream));

    // Load the header
    CHECKHR(hr = MimeOleCreatePropertySet(NULL, &pHeader));

    // Load the header
    CHECKHR(hr = pHeader->Load(pStream));

    // Get the message Id...
    if (FAILED(MimeOleGetPropA(pHeader, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, ppszUidl)))
    {
        // Try to use the received headers...
        MimeOleGetPropA(pHeader, PIDTOSTR(PID_HDR_RECEIVED), NOFLAGS, ppszUidl);
    }

    // Returen the Header ?
    *ppHeader = pHeader;
    pHeader = NULL;

exit:
    // Release the text stream
    SafeRelease(pHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrDoUidlSynchronize
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrDoUidlSynchronize(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPOP3ITEM      pItem;
    ULONG           i,j;

#ifdef DEBUG
    DWORD dwTick = GetTickCount();
#endif

    // Uidl Sync
    m_state = POP3STATE_UIDLSYNC;

    // Compute number of new messages to download
    for (i=0,j=0; i<m_rTable.cItems; i++,j++)
    {
        // Readability
        pItem = &m_rTable.prgItem[i];

        // Get Uidl Falgs
        _GetItemFlagsFromUidl(pItem);

        // Progress
        m_dwProgressCur+=3;

        // Do Progress
        _DoProgress();

        // Pump Message
        if (j >= 10)
        {
            //Sleep(0);
            m_pSpoolCtx->PumpMessages();
            j = 0;
        }

        // Cancel
        if (ISFLAGSET(m_dwState, POP3STATE_CANCELPENDING))
        {
            // Change State
            m_state = POP3STATE_NONE;

            // Drop the connection
            if (m_pTransport)
                m_pTransport->DropConnection();

            // User Cancel
            hr = IXP_E_USER_CANCEL;

            // Done
            break;
        }

        // OnDisconnect has been called
        if (ISFLAGSET(m_dwState, POP3STATE_ONDISCONNECT))
        {
            // Change State
            m_state = POP3STATE_NONE;

            // Fake the call to OnStatus
            OnStatus(IXP_DISCONNECTED, NULL);

            // Done
            break;
        }
    }

    // Uidl Sync
    m_state = POP3STATE_NONE;

    // Cool tracing
#ifdef DEBUG
    DebugTrace("CPop3Task::_HrDoUidlSynchronize took %d Milli-Seconds\n", GetTickCount() - dwTick);
#endif // DEBUG

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_GetItemFlagsFromUidl
// --------------------------------------------------------------------------------
void CPop3Task::_GetItemFlagsFromUidl(LPPOP3ITEM pItem)
{
    // Locals
    UIDLRECORD rUidlInfo={0};

    // Invalid Arg
    Assert(pItem && m_pUidlCache);

    // If we are already not going to download this item, then return
    if (!ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD))
        return;

    // If there is no UIDL, we will download it...
    if (NULL == pItem->pszUidl || '\0' == *pItem->pszUidl)
        return;

    // If not leaving on server, mark for delete
    if (ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER))
        FLAGCLEAR(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);

    // Set Search Info
    rUidlInfo.pszUidl = pItem->pszUidl;
    rUidlInfo.pszServer = m_rServer.szServerName;
    rUidlInfo.pszAccountId = m_szAccountId;

    // This yields so that other threads can execute
    //Sleep(0);

    // Exist - if not, lets download it...
    if (DB_S_NOTFOUND == m_pUidlCache->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &rUidlInfo, NULL))
    {
        if (ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER))
            FLAGSET(pItem->dwFlags, POP3ITEM_CACHEUIDL);
        return;
    }

    // Don't download it again
    FLAGCLEAR(pItem->dwFlags, POP3ITEM_DOWNLOAD | POP3ITEM_DELETEOFFSERVER);

    // If the message has been download, lets decide if we should delete it
    if (rUidlInfo.fDownloaded)
    {
        // Expired or deleted from client, or remove when deleted from delete items folder.
        if (!ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER) || _FUidlExpired(&rUidlInfo) ||
            (ISFLAGSET(m_dwState, POP3STATE_SYNCDELETED) && rUidlInfo.fDeleted))
        {
            FLAGSET(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL);
            FLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);
        }
    }

    // Free The Dude
    m_pUidlCache->FreeRecord(&rUidlInfo);
}

// ------------------------------------------------------------------------------------
// CPop3Task::_FUidlExpired
// ------------------------------------------------------------------------------------
BOOL CPop3Task::_FUidlExpired(LPUIDLRECORD pUidlInfo)
{
    // Locals
    SYSTEMTIME          st;
    FILETIME            ft;
    ULONG               ulSeconds;

    // If not expiring, return FALSE
    if (!ISFLAGSET(m_dwState, POP3STATE_DELETEEXPIRED))
        return FALSE;

    // Get Current Time
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Convert st to seconds since Jan 1, 1996
    ulSeconds = UlDateDiff(&pUidlInfo->ftDownload, &ft);

    // Greater than expire days
    if ((ulSeconds / SECONDS_INA_DAY) >= m_dwExpireDays)
        return TRUE;

    // Done
    return FALSE;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_ComputeItemInboxRule
// ------------------------------------------------------------------------------------
void CPop3Task::_ComputeItemInboxRule(LPPOP3ITEM pItem, LPSTREAM pStream,
                IMimePropertySet *pHeaderIn, IMimeMessage * pIMMsg, BOOL fServerRules)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimePropertySet   *pHeader=NULL;
    ACT_ITEM           *pActions=NULL;
    ULONG               cActions=0;

    // We should not have checked the inbox rule for this item yet
    Assert(m_pIExecRules && pItem && (pStream || pHeaderIn || pIMMsg));
    Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE));

    // We've checked this inbox rule
    FLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE);

    // Assume we don't find an inbox rule for this item
    FLAGCLEAR(pItem->dwFlags, POP3ITEM_HASINBOXRULE);

    // Header was passed in ?
    if (pHeaderIn)
    {
        pHeader = pHeaderIn;
        pHeader->AddRef();
    }

    // Do we already have a Mime message?
    else if (pIMMsg)
    {
        CHECKHR(hr = pIMMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pHeader));
    }
    
    // Otherwise, load the stream in to a header
    else
    {
        // Rewind Header Stream
        CHECKHR(hr = HrRewindStream(pStream));

        // Load the header
        CHECKHR(hr = MimeOleCreatePropertySet(NULL, &pHeader));

        // Load the header
        CHECKHR(hr = pHeader->Load(pStream));
    }

    // Check the inbox rule

    // If we have pre-download rules,
    if ((FALSE != fServerRules) && ISFLAGSET(m_dwState, POP3STATE_PDR))
    {
        // Check to see if we have any actions
        hr = m_pIExecRules->ExecuteRules(ERF_ONLYSERVER | ERF_SKIPPARTIALS, m_szAccountId, NULL, NULL, pHeader, NULL, pItem->cbSize, &pActions, &cActions);

        // If we don't have any actions, or
        // this isn't a server side rule
        if ((S_OK != hr) ||
                    ((ACT_TYPE_DONTDOWNLOAD != pActions[0].type) && (ACT_TYPE_DELETESERVER != pActions[0].type)))
        {
            // Make sure we can check rules again
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE);
            hr = S_FALSE;
        }
        else
        {
            // _OnKnownRuleActions
            _OnKnownRuleActions(pItem, pActions, cActions, fServerRules);
        }
    }
    // If we don't have pre-download rules, then check rules normally.
    else
    {
        hr = S_FALSE;
        
        // Do block sender first
        if (m_pIRuleSender)
        {
            hr = m_pIRuleSender->Evaluate(m_szAccountId, NULL, NULL, pHeader, pIMMsg, pItem->cbSize, &pActions, &cActions);
        }

        // If we aren't blocking the sender
        if (S_OK != hr)
        {
            hr = m_pIExecRules->ExecuteRules(ERF_SKIPPARTIALS, m_szAccountId, NULL, NULL, pHeader, pIMMsg, pItem->cbSize, &pActions, &cActions);
        }
        
        // If we don't have a rule match
        if ((S_OK != hr) && (NULL != m_pIRuleJunk))
        {
            hr = m_pIRuleJunk->Evaluate(m_szAccountId, NULL, NULL, pHeader, pIMMsg, pItem->cbSize, &pActions, &cActions);
        }
        
        // Did we have some actions to perform...
        if (S_OK == hr)
        {
            // This item has an inbox rule
            FLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE);

            // Save off the actions list
            pItem->pActList = pActions;
            pActions = NULL;
            pItem->cActList = cActions;
        }
    }

exit:
    // Cleanup
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    SafeRelease(pHeader);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_OnKnownRuleActions
// ------------------------------------------------------------------------------------
void CPop3Task::_OnKnownRuleActions(LPPOP3ITEM pItem, ACT_ITEM * pActions, ULONG cActions, BOOL fServerRules)
{
    // This item has an inbox rule
    FLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE);

    // If Action is to delete off sever
    if ((FALSE != fServerRules) && (1 == cActions))
    {
        if (ACT_TYPE_DELETESERVER == pActions->type)
        {
            // Don't Cache the UIDL
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL | POP3ITEM_CACHEUIDL | POP3ITEM_DOWNLOAD);

            // Delete off the server
            FLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER | POP3ITEM_DELEBYRULE);
        }

        // Otherwise, don't download the message
        else if (ACT_TYPE_DONTDOWNLOAD == pActions->type)
        {
            // Download It and Don't download it and delete it
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_DOWNLOAD | POP3ITEM_DELETEOFFSERVER);

            // Set the Flag
            FLAGSET(pItem->dwFlags, POP3ITEM_LEFTBYRULE);
        }
    }
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrStartServerSideRules
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStartServerSideRules(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // If we got uidls, then lets do the cache compare lookup
    if (ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
    {
        // Returns FALSE if user cancel
        CHECKHR(hr = _HrDoUidlSynchronize());
    }

    // Check State
    m_rMetrics.cTopMsgs = 0;
    m_rMetrics.iCurrent = 0;

    // Count the number of messages we will have to get a top for
    for (i=0; i<m_rTable.cItems; i++)
    {
        if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_DOWNLOAD))
            m_rMetrics.cTopMsgs++;
    }

    // Adjust progress
    m_dwProgressMax -= m_rTable.cItems;

    // Add m_rMetrics.cTopMsgs back onto m_dwProgressMax
    m_dwProgressMax += m_rMetrics.cTopMsgs;

    // Do the first one
    CHECKHR(hr = _HrNextTopForInboxRule(0));

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrNextTopForInboxRule
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrNextTopForInboxRule(DWORD dwPopIdCurrent)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES+CCHMAX_RES];

    // State should be none
    Assert(POP3STATE_NONE == m_state);

    // Increment iCurrent
    m_rMetrics.iCurrent++;

    // Set Specific Progress
    //LOADSTRING(IDS_SPS_PREDOWNRULES, szRes);
    //wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rMetrics.iCurrent, m_rMetrics.cTopMsgs);
    //m_pUI->SetSpecificProgress(szMsg);

    // Loop until we find the next message that we are downloading
    while(1)
    {
        // Incremenet dwPopIdCurrent
        dwPopIdCurrent++;

        // Last PopId, start the download
        if (dwPopIdCurrent > m_rTable.cItems)
        {
            // Start the download process
            CHECKHR(hr = _HrStartDownloading());

            // Done
            break;
        }

        // If we are still downloading this item
        if (ISFLAGSET(m_rTable.prgItem[dwPopIdCurrent - 1].dwFlags, POP3ITEM_DOWNLOAD))
        {
            // Try to top command
            CHECKHR(hr = m_pTransport->CommandTOP(POP3CMD_GET_POPID, dwPopIdCurrent, 0));

            // Done
            break;
        }
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrRetrieveNextMessage
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrRetrieveNextMessage(DWORD dwPopIdCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_RES];
    LPPOP3ITEM      pItem;

    // Cancel Pending...
    if (ISFLAGSET(m_dwState, POP3STATE_CANCELPENDING))
    {
        // Start the Delete Cycle
        CHECKHR(hr = _HrStartDeleteCycle());

        // Done
        goto exit;
    }

    // Adjust progress
    if (dwPopIdCurrent > 0)
    {
        // Get current item
        pItem = ITEMFROMPOPID(dwPopIdCurrent);
        Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD));

        // Adjust progress Cur
        m_dwProgressCur = pItem->dwProgressCur;

        // Do progress
        _DoProgress();
    }

    // Loop until we find the next message that we are downloading
    while(1)
    {
        // Incremenet dwPopIdCurrent
        dwPopIdCurrent++;

        // Last PopId, start the download
        if (dwPopIdCurrent > m_rTable.cItems)
        {
            // Start the download process
            CHECKHR(hr = _HrStartDeleteCycle());

            // Done
            break;
        }

        // Readability
        pItem = ITEMFROMPOPID(dwPopIdCurrent);

        // Download this message ?
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD))
        {
            // Increment m_rMetrics.iCurrent
            m_rMetrics.iCurrent++;

            // Status
            LOADSTRING(idsInetMailRecvStatus, szRes);
            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rMetrics.iCurrent, m_rMetrics.cDownload);
            m_pUI->SetSpecificProgress(szMsg);

            // Retrieve this item
            CHECKHR(hr = m_pTransport->CommandRETR(POP3CMD_GET_POPID, dwPopIdCurrent));

            // Done
            break;
        }

        // Count Number of items left by rule
        else if (ISFLAGSET(pItem->dwFlags, POP3ITEM_LEFTBYRULE))
            m_rMetrics.cLeftByRule++;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrOnRetrResponse
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnRetrResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwPopId=pResponse->rRetrInfo.dwPopId;
    LPPOP3ITEM      pItem;

    // Get Current Item
    pItem = ITEMFROMPOPID(dwPopId);

    // Validate the item
    Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD));

    // Valid info
    if (TRUE == pResponse->fValidInfo)
    {
        // Progress...
        m_dwProgressCur += pResponse->rRetrInfo.cbLines;

        // Don't let progress grow beyond what we estimated the ceiling for this message
        if (m_dwProgressCur > pItem->dwProgressCur)
            m_dwProgressCur = pItem->dwProgressCur;

        // Show Progress
        _DoProgress();

        // Do we have a destination yet ?
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN))
        {
            // We better have a stream
            Assert(m_rFolder.pStream && m_rFolder.pFolder);

            // Simply write the data
            CHECKHR(hr = m_rFolder.pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
        }

        // Otherwise
        else
        {
            // If there are no inbox rules
            if (ISFLAGSET(m_dwState, POP3STATE_NOPOSTRULES))
            {
                // Use the Inbox
                CHECKHR(hr = _HrOpenFolder(m_pInbox));

                // Destination is known
                FLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN);

                // Simply write the data
                CHECKHR(hr = m_rFolder.pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
            }

            // else if we have only body rules...
            else if (ISFLAGSET(m_dwState, POP3STATE_BODYRULES))
            {
                // No stream yet ?
                if (NULL == m_pStream)
                {
                    // Create a Stream
                    CHECKHR(hr = MimeOleCreateVirtualStream(&m_pStream));
                }

                // Simply write the data
                CHECKHR(hr = m_pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
            }
            
            // Otherwise...
            else
            {
                // Have I checked the inbox rule for this item yet ?
                if (!ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE))
                {
                    // No stream yet ?
                    if (NULL == m_pStream)
                    {
                        // Create a Stream
                        CHECKHR(hr = MimeOleCreateVirtualStream(&m_pStream));
                    }

                    // Simply write the data
                    CHECKHR(hr = m_pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));

                    // If I have the header, check the inbox rule
                    if (TRUE == pResponse->rRetrInfo.fHeader)
                    {
                        // Commit the stream
                        CHECKHR(hr = m_pStream->Commit(STGC_DEFAULT));

                        // Check Inbox Rule for this item
                        _ComputeItemInboxRule(pItem, m_pStream, NULL, NULL, FALSE);
                    }
                }

                // Have I checked the inbox rule for this item yet ?
                if (ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE))
                {
                    // Locals
                    IMessageFolder *pFolder;

                    // We must have the header
                    IxpAssert(pResponse->rRetrInfo.fHeader);

                    // Did we find an Inbox Rule
                    if (ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE) && S_OK == _GetMoveFolder(pItem, &pFolder))
                    {
                        // Use the Inbox
                        CHECKHR(hr = _HrOpenFolder(pFolder));
                    }

                    // No Move To, just use the inbox
                    else
                    {
                        // Use the Inbox
                        CHECKHR(hr = _HrOpenFolder(m_pInbox));
                    }

                    // Destination is known
                    FLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN);

                    // If m_pStream, then copy this to the folder
                    if (m_pStream)
                    {
                        // Rewind the stream
                        CHECKHR(hr = HrRewindStream(m_pStream));

                        // Copy this stream to the folder
                        CHECKHR(hr = HrCopyStream(m_pStream, m_rFolder.pStream, NULL));

                        // Relase m_pStream
                        SafeRelease(m_pStream);
                    }

                    // Otherwise, store the data into the folder
                    else
                    {
                        IxpAssert(FALSE);
                        // Simply write the data
                        CHECKHR(hr = m_rFolder.pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
                    }
                }
            }
        }
    }

    // Done ?
    if (TRUE == pResponse->fDone)
    {
        // Finish this message download
        CHECKHR(hr = _HrFinishMessageDownload(dwPopId));
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrFinishMessageDownload
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrFinishMessageDownload(DWORD dwPopId)
{
    // Locals
    HRESULT         hr=S_OK;
    IMimeMessage   *pMessage=NULL;
    PROPVARIANT     rUserData;
    LPPOP3ITEM      pItem;
    SYSTEMTIME      st;
    UIDLRECORD      rUidlInfo={0};
    MESSAGEID       idMessage;
    DWORD           dwMsgFlags;
    IMessageFolder  *pFolder;
    ULONG           ulIndex = 0;
    IStream *       pIStm = NULL;
    BOOL            fDelete=FALSE;
    
    // Get Current Item
    pItem = ITEMFROMPOPID(dwPopId);

    // Create a New Mail Message
    CHECKHR(hr = HrCreateMessage(&pMessage));

    // Has Body rules
    if (ISFLAGSET(m_dwState, POP3STATE_BODYRULES))
    {
        // I should not have checked for a rule yet
        IxpAssert(!ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE));

        // Better have a current folder
        Assert(m_pStream);

        // Check Params
        CHECKHR(hr = m_pStream->Commit(STGC_DEFAULT));
        
        pIStm = m_pStream;
    }
    else
    {
        // Better have a current folder
        Assert(m_rFolder.pStream);

        // Check Params
        CHECKHR(hr = m_rFolder.pStream->Commit(STGC_DEFAULT));

        // Change the Lock Type
        CHECKHR(hr = m_rFolder.pFolder->ChangeStreamLock(m_rFolder.pStream, ACCESS_READ));
        
        pIStm = m_rFolder.pStream;
    }

    // Rewind
    CHECKHR(hr = HrRewindStream(pIStm));

    // Stream in
    CHECKHR(hr = pMessage->Load(pIStm));

    // Count Partials
    if (S_OK == pMessage->IsContentType(HBODY_ROOT, STR_CNT_MESSAGE, STR_SUB_PARTIAL))
        m_rMetrics.cPartials++;

    // Save Server
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_rServer.szServerName;
    pMessage->SetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &rUserData);

    // Save Account Name
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_rServer.szAccount;
    pMessage->SetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &rUserData);

    // Save Account Name
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_szAccountId;
    pMessage->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &rUserData);

    // Save UIDL
    if (pItem->pszUidl)
    {
        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = pItem->pszUidl;
        pMessage->SetProp(PIDTOSTR(PID_ATT_UIDL), NOFLAGS, &rUserData);
    }

    // Save User Name
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_rServer.szUserName;
    pMessage->SetProp(PIDTOSTR(PID_ATT_USERNAME), NOFLAGS, &rUserData);

    // Initialize dwMsgFlags
    dwMsgFlags = ARF_RECEIVED;

    // Has Body rules
    if (ISFLAGSET(m_dwState, POP3STATE_BODYRULES))
    {
        // I should not have checked for a rule yet
        IxpAssert(!ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE));

        // Compute the inbox rule
        _ComputeItemInboxRule(pItem, NULL, NULL, pMessage, FALSE);
        
        // Did we find an Inbox Rule
        if (ISFLAGCLEAR(pItem->dwFlags, POP3ITEM_HASINBOXRULE) || (S_OK != _GetMoveFolder(pItem, &pFolder)))
        {
            pFolder = m_pInbox;
        }

        // Destination is known
        FLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN);        
    }
    else
    {
        pFolder = m_rFolder.pFolder;
    }

    // Store the message into the folder
    IF_FAILEXIT(hr = pFolder->SaveMessage(&idMessage, SAVE_MESSAGE_GENID, dwMsgFlags, pIStm, pMessage, NOSTORECALLBACK));
    
    // Success
    m_rFolder.fCommitted = TRUE;

    // This message was successfully downloaded
    FLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOADED);

    // Do PostDownloadRule
    _DoPostDownloadActions(pItem, idMessage, pFolder, pMessage, &fDelete);
    
    // Release Folder Object
    SafeRelease(m_rFolder.pStream);
    
    // Relase m_pStream
    SafeRelease(m_pStream);

    // Release the Folder
    SafeRelease(m_rFolder.pFolder);

    // Clear the folder infor Struct
    ZeroMemory(&m_rFolder, sizeof(POP3FOLDERINFO));

    // If going to delete it...
    if (fDelete)
    {
        // Mark it for deletion
        FLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);

        // We will store its uidl, but lets delete it later
        FLAGSET(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL);
    }

    // Cached the UIDL for this message ?
    if (ISFLAGSET(pItem->dwFlags, POP3ITEM_CACHEUIDL))
    {
        // Should have a pszUidl
        Assert(pItem->pszUidl && m_pUidlCache);

        // Don't fault
        if (pItem->pszUidl)
        {
            // Set Key
            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &rUidlInfo.ftDownload);
            rUidlInfo.fDownloaded = TRUE;
            rUidlInfo.fDeleted = FALSE;
            rUidlInfo.pszUidl = pItem->pszUidl;
            rUidlInfo.pszServer = m_rServer.szServerName;
            rUidlInfo.pszAccountId = m_szAccountId;

            // Set Propgs
            m_pUidlCache->InsertRecord(&rUidlInfo);
        }
    }

    // Successful download
    m_rMetrics.cDownloaded++;

    // Do smart log
    if (m_pSmartLog && (lstrcmpi(m_pSmartLog->pszAccount, m_rServer.szAccount) == 0 || lstrcmpi("All", m_pSmartLog->pszAccount) == 0))
        _DoSmartLog(pMessage);

    // Retrieve the next message
    CHECKHR(hr = _HrRetrieveNextMessage(dwPopId));

exit:
    // Cleanup
    SafeRelease(pMessage);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_DoPostDownloadActions
// ------------------------------------------------------------------------------------
void CPop3Task::_DoPostDownloadActions(LPPOP3ITEM pItem, MESSAGEID idMessage,
    IMessageFolder *pFolder, IMimeMessage *pMessage, BOOL *pfDeleteOffServer)
{
    // Locals
    HRESULT         hr;
    MESSAGEINFO     Message = {0};
    HWND            hwnd = NULL;

    // Finish Applying the inbox rules
    if (!ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE))
    {
        goto exit;
    }

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;
        
    // Set the Id
    Message.idMessage = idMessage;

    // Get the message
    hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
    if (FAILED(hr) || DB_S_NOTFOUND == hr)
    {
        goto exit;
    }

    if (FAILED(RuleUtil_HrApplyActions(hwnd, m_pIExecRules, &Message, pFolder, pMessage, 0, pItem->pActList,
                        pItem->cActList, &(m_rMetrics.cInfiniteLoopAutoGens), pfDeleteOffServer)))
    {
        goto exit;
    }

exit:
    // Free
    if (NULL != pFolder)
    {
        pFolder->FreeRecord(&Message);
    }
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrOpenFolder
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOpenFolder(IMessageFolder *pFolder)
{
    // Locals
    HRESULT     hr=S_OK;

    // Current folder better be empty
    Assert(NULL == m_rFolder.pFolder && NULL == m_rFolder.pStream && 0 == m_rFolder.faStream);

    // Bad Arguments
    if (NULL == pFolder)
    {
        Assert(FALSE);
        return TrapError(E_INVALIDARG);
    }

    // Save the folder
    m_rFolder.pFolder = pFolder;

    // AddRef 
    m_rFolder.pFolder->AddRef();

    // Get a stream from the
    CHECKHR(hr = m_rFolder.pFolder->CreateStream(&m_rFolder.faStream));

    // Open the Stream
    CHECKHR(hr = m_rFolder.pFolder->OpenStream(ACCESS_WRITE, m_rFolder.faStream, &m_rFolder.pStream));

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_CloseFolder
// ------------------------------------------------------------------------------------
void CPop3Task::_CloseFolder(void)
{
    // Release the Stream
    SafeRelease(m_rFolder.pStream);

	// Release the reference to the stream. If the stream was reused,
	// it's refCount was incremented down below
    if (m_rFolder.faStream != 0)
    {
        // Must have a folder
        Assert(m_rFolder.pFolder);

        // Delete the Stream
        SideAssert(SUCCEEDED(m_rFolder.pFolder->DeleteStream(m_rFolder.faStream)));

        // Nill
        m_rFolder.faStream = 0;
    }

    // AddRef 
    SafeRelease(m_rFolder.pFolder);
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrStartDeleteCycle
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStartDeleteCycle(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;
    LPPOP3ITEM  pItem;

    // Release Folder Objects
    _ReleaseFolderObjects();

    // Check State
    m_rMetrics.cDelete = 0;
    m_rMetrics.iCurrent = 0;

    // Count the number of messages we will have to get a top for
    for (i=0; i<m_rTable.cItems; i++)
    {
        // Readability
        pItem = &m_rTable.prgItem[i];

        // If it was marked for download, and we didn't download it, don't delete it
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOADED))
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);

        // Is it marked for delete ?
        else if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER))
            m_rMetrics.cDelete++;
    }

    // Nothing to delete
    if (0 == m_rMetrics.cDelete)
    {
        // Disconnect
        m_pTransport->Disconnect();

        // Done
        goto exit;
    }

    // Setup Progress
    m_rMetrics.iCurrent = 0;
    m_wProgress = 0;
    m_dwProgressCur = 0;
    m_dwProgressMax = m_rMetrics.cDelete;
    m_pUI->SetProgressRange(100);

    // State
    m_state = POP3STATE_DELETING;

    // Do the first one
    CHECKHR(hr = _HrDeleteNextMessage(0));

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrDeleteNextMessage
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrDeleteNextMessage(DWORD dwPopIdCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_RES];
    LPPOP3ITEM      pItem;

    // Mark as deleted
    if (dwPopIdCurrent > 0)
    {
        // Get the item
        pItem = ITEMFROMPOPID(dwPopIdCurrent);

        // Mark as deleted
        FLAGSET(pItem->dwFlags, POP3ITEM_DELETED);
    }

    // Loop until we find the next message that we are downloading
    while(1)
    {
        // Incremenet dwPopIdCurrent
        dwPopIdCurrent++;

        // Last PopId, start the download
        if (dwPopIdCurrent > m_rTable.cItems)
        {
            // Disconnect
            m_pTransport->Disconnect();

            // Done
            break;
        }

        // Readability
        pItem = ITEMFROMPOPID(dwPopIdCurrent);

        // Download this message ?
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER))
        {
            // Increment m_rMetrics.iCurrent
            m_rMetrics.iCurrent++;

            // Status
            //LOADSTRING(IDS_SPS_POP3DELE, szRes);
            //wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rMetrics.iCurrent, m_rMetrics.cDelete);
            //m_pUI->SetSpecificProgress(szMsg);

            // Retrieve this item
            CHECKHR(hr = m_pTransport->CommandDELE(POP3CMD_GET_POPID, dwPopIdCurrent));

            // Count number of items deleted by rule
            if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELEBYRULE))
                m_rMetrics.cDeleByRule++;

            // Done
            break;
        }
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrBuildFolderPartialMsgs
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrBuildFolderPartialMsgs(IMessageFolder *pFolder, LPPARTIALMSG *ppPartialMsgs,
    ULONG *pcPartialMsgs, ULONG *pcTotalParts)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPARTIALMSG    pPartialMsgs=NULL;
    ULONG           cPartialMsgs=0,
                    iPartialMsg,
                    iMsgPart,
                    i,
                    cTotalParts=0;
    ULONG           cAlloc=0;
    MESSAGEINFO     MsgInfo={0};
    HROWSET         hRowset=NULL;
    BOOL            fKnownPartialId;

    // Check Params
    Assert(pFolder && ppPartialMsgs && pcPartialMsgs);

    // Init
    *ppPartialMsgs = NULL;
    *pcPartialMsgs = 0;
    *pcTotalParts = 0;

    // Create a Rowset
    CHECKHR(hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

	// Loop
	while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
	{
        // Is this a partial, i.e. does it have a partial id...
        if (!FIsEmptyA(MsgInfo.pszPartialId))
        {
            // Assume we don't know th id
            fKnownPartialId = FALSE;

            // See if I know this partial id
            for (iPartialMsg=0; iPartialMsg<cPartialMsgs; iPartialMsg++)
            {
                if (lstrcmp(MsgInfo.pszPartialId, pPartialMsgs[iPartialMsg].pszId) == 0)
                {
                    fKnownPartialId = TRUE;
                    break;
                }
            }

            // Did we know this message...
            if (fKnownPartialId == FALSE)
            {
                // Realloc my array ?
                if (cPartialMsgs + 1 >= cAlloc)
                {
                    // Realloc the array
                    if (!MemRealloc((LPVOID *)&pPartialMsgs, (cAlloc + 20) * sizeof(PARTIALMSG)))
                    {
                        hr = TrapError(hrMemory);
                        goto exit;
                    }

                    // Zero Init
                    ZeroMemory(pPartialMsgs + cAlloc, 20 * sizeof(PARTIALMSG));

                    // Realloc
                    cAlloc += 20;
                }

                // Set index into partial msgs lsit
                iPartialMsg = cPartialMsgs;

                // Set some stuff
                if (MsgInfo.pszAcctName)
                    StrCpyN(pPartialMsgs[iPartialMsg].szAccount, MsgInfo.pszAcctName, ARRAYSIZE(pPartialMsgs[iPartialMsg].szAccount));
                pPartialMsgs[iPartialMsg].pszId = PszDupA(MsgInfo.pszPartialId);
                pPartialMsgs[iPartialMsg].cTotalParts = LOWORD(MsgInfo.dwPartial);

                // Increment number of known partial messages
                cPartialMsgs++;
            }

            // Otherwise, we know the partial id already...
            else
            {
                // See if this message details the total number of parts
                if (pPartialMsgs[iPartialMsg].cTotalParts == 0)
                    pPartialMsgs[iPartialMsg].cTotalParts = LOWORD(MsgInfo.dwPartial);
            }

            // Can I add one more msgpart into this list
            if (pPartialMsgs[iPartialMsg].cMsgParts + 1 >= pPartialMsgs[iPartialMsg].cAlloc)
            {
                // Realloc the array
                if (!MemRealloc((LPVOID *)&pPartialMsgs[iPartialMsg].pMsgParts, (pPartialMsgs[iPartialMsg].cAlloc + 20) * sizeof(MSGPART)))
                {
                    hr = TrapError(hrMemory);
                    goto exit;
                }

                // Zero Init
                ZeroMemory(pPartialMsgs[iPartialMsg].pMsgParts + pPartialMsgs[iPartialMsg].cAlloc, 20 * sizeof(MSGPART));

                // Realloc
                pPartialMsgs[iPartialMsg].cAlloc += 20;
            }

            // Set Message Part
            iMsgPart = pPartialMsgs[iPartialMsg].cMsgParts;

            // Set Message Info
            pPartialMsgs[iPartialMsg].pMsgParts[iMsgPart].iPart = HIWORD(MsgInfo.dwPartial);
            pPartialMsgs[iPartialMsg].pMsgParts[iMsgPart].msgid = MsgInfo.idMessage;
            //pPartialMsgs[iPartialMsg].pMsgParts[iMsgPart].phi = phi;
            //phi = NULL;

            // Increment the number of parts in the list
            pPartialMsgs[iPartialMsg].cMsgParts++;
        }

        // Free
        pFolder->FreeRecord(&MsgInfo);
    }

    // Lets sort the list by pszId
    for (i=0; i<cPartialMsgs; i++)
    {
        if (pPartialMsgs[i].pMsgParts && pPartialMsgs[i].cMsgParts > 0)
            _QSortMsgParts(pPartialMsgs[i].pMsgParts, 0, pPartialMsgs[i].cMsgParts-1);
        cTotalParts += pPartialMsgs[i].cMsgParts;
    }

    // Success
    *pcPartialMsgs = cPartialMsgs;
    *ppPartialMsgs = pPartialMsgs;
    *pcTotalParts  = cTotalParts;

exit:
    // Cleanup
    if (pFolder)
    {
        pFolder->CloseRowset(&hRowset);
        pFolder->FreeRecord(&MsgInfo);
    }

    // If We failed, free stuff
    if (FAILED(hr))
    {
        _FreePartialMsgs(pPartialMsgs, cPartialMsgs);
        SafeMemFree(pPartialMsgs);
        *ppPartialMsgs = NULL;
        *pcPartialMsgs = 0;
        *pcTotalParts = 0;
    }

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_QSortMsgParts
// ------------------------------------------------------------------------------------
void CPop3Task::_QSortMsgParts(LPMSGPART pMsgParts, LONG left, LONG right)
{
    register    long i, j;
    WORD        k;
    MSGPART     y;

    i = left;
    j = right;
    k = pMsgParts[(left + right) / 2].iPart;

    do
    {
        while(pMsgParts[i].iPart < k && i < right)
            i++;
        while (pMsgParts[j].iPart > k && j > left)
            j--;

        if (i <= j)
        {
            CopyMemory(&y, &pMsgParts[i], sizeof(MSGPART));
            CopyMemory(&pMsgParts[i], &pMsgParts[j], sizeof(MSGPART));
            CopyMemory(&pMsgParts[j], &y, sizeof(MSGPART));
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _QSortMsgParts(pMsgParts, left, j);
    if (i < right)
        _QSortMsgParts(pMsgParts, i, right);
}


// ------------------------------------------------------------------------------------
// CPop3Task::_FreePartialMsgs
// ------------------------------------------------------------------------------------
void CPop3Task::_FreePartialMsgs(LPPARTIALMSG pPartialMsgs, ULONG cPartialMsgs)
{
    // Locals
    ULONG       i, j;

    // Nothing to free
    if (pPartialMsgs == NULL)
        return;

    // Loop the array
    for (i=0; i<cPartialMsgs; i++)
    {
        SafeMemFree(pPartialMsgs[i].pszId);
#if 0
        for (j=0; j<pPartialMsgs[i].cMsgParts; j++)
        {
            FreeHeaderInfo(pPartialMsgs[i].pMsgParts[j].phi);
        }
#endif
        SafeMemFree(pPartialMsgs[i].pMsgParts);
    }

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrStitchPartials
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStitchPartials(void)
{
    // Locals
    HRESULT             hr = S_OK;
    IMessageFolder     *pInbox=NULL,
                       *pDeletedItems=NULL;
    LPPARTIALMSG        pPartialMsgs=NULL;
    ULONG               cPartialMsgs=0,
                        i,
                        j,
                        cbCacheInfo,
                        cErrors=0,
                        cTotalParts;
    IMimeMessageParts  *pParts=NULL;
    LPMSGPART           pMsgParts;
    IMimeMessage       *pMailMsg=NULL,
                       *pMailMsgSingle=NULL;
    TCHAR               szRes[255];
    PROPVARIANT         rUserData;
    ULONG               cCombined=0;
    MESSAGEIDLIST       List;
    HWND                hwnd;

    // Progress
    AthLoadString(idsStitchingMessages, szRes, ARRAYSIZE(szRes));
    m_pUI->SetSpecificProgress(szRes);
    m_pUI->SetAnimation(idanDecode, TRUE);
    m_pUI->SetProgressRange(100);

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;

    // open the inbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreInbox, (LPVOID *)&pInbox));

    // deleted items folder
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreDeleted, (LPVOID *)&pDeletedItems));

    // Get array of message parts in this folder
    CHECKHR(hr = _HrBuildFolderPartialMsgs(pInbox, &pPartialMsgs, &cPartialMsgs, &cTotalParts));

    // If nothing, were done
    if (pPartialMsgs == NULL || cPartialMsgs == 0)
        goto exit;

    // Setup Progress
    m_rMetrics.iCurrent = 0;
    m_wProgress = 0;
    m_dwProgressCur = 0;
    m_dwProgressMax = cTotalParts;

    // Loop through partial messages list
    for (i=0; i<cPartialMsgs; i++)
    {
        // If we don't know all of the parts yet, continue
        if (pPartialMsgs[i].cTotalParts == 0)
            continue;

        // Or we don't have all of the parts yet...
        if (pPartialMsgs[i].cTotalParts != pPartialMsgs[i].cMsgParts)
            continue;

        // Lets create a mail message list
        Assert(pParts == NULL);

        // Create Parts Object
        CHECKHR(hr = MimeOleCreateMessageParts(&pParts));

        // Set pMsgParts
        pMsgParts = pPartialMsgs[i].pMsgParts;

        // Ok, lets build a message list by opening the messages up out of the store...
        for (j=0; j<pPartialMsgs[i].cMsgParts; j++)
        {
            // Progress
            if (j > 0)
            {
                m_dwProgressCur++;
                _DoProgress();
            }

            // Open this message
            if (FAILED(pInbox->OpenMessage(pMsgParts[j].msgid, NOFLAGS, &pMailMsg, NOSTORECALLBACK)))
            {
                cErrors++;
                hr = TrapError(E_FAIL);
                goto NextPartialMessage;
            }

            // Add into pmml
            pParts->AddPart(pMailMsg);

            // Release It
            SafeRelease(pMailMsg);
        }

        // Create a new message to combine everyting into
        Assert(pMailMsgSingle == NULL);

        // Create a Message
        hr = pParts->CombineParts(&pMailMsgSingle);
        if (FAILED(hr))
        {
            cErrors++;
            TrapError(hr);
            goto NextPartialMessage;
        }

        // Set Account
        HrSetAccount(pMailMsgSingle, pPartialMsgs[i].szAccount);

        // Set Combined Flag
        rUserData.vt = VT_UI4;
        rUserData.ulVal = MESSAGE_COMBINED;
        pMailMsgSingle->SetProp(PIDTOSTR(PID_ATT_COMBINED), NOFLAGS, &rUserData);

        // Save the message
        hr = pMailMsgSingle->Commit(0);
        if (FAILED(hr))
        {
            cErrors++;
            TrapError(hr);
            goto NextPartialMessage;
        }

        // Save It
        hr = pInbox->SaveMessage(NULL, SAVE_MESSAGE_GENID, ARF_RECEIVED, 0, pMailMsgSingle, NOSTORECALLBACK);
        if (FAILED(hr))
        {
            cErrors++;
            TrapError(hr);
            goto NextPartialMessage;
        }

        // Ok, now lets move those original messages to the deleted items folder...
        for (j=0; j<pPartialMsgs[i].cMsgParts; j++)
        {
            // Setup the msgidlsit
            List.cMsgs = 1;
            List.prgidMsg = &pMsgParts[j].msgid;

            // Move msgid to deleted items folder
            CopyMessagesProgress(hwnd, pInbox, pDeletedItems, COPY_MESSAGE_MOVE, &List, NULL);
        }

        // Count Combined
        cCombined++;

        // Cleanup
NextPartialMessage:
        SafeRelease(pMailMsg);
        SafeRelease(pMailMsgSingle);
        SafeRelease(pParts);
    }

    // If I combined parts, apply inbox rules to the inbox
    if (cCombined)
    {
        // Apply to the inbox
        RuleUtil_HrApplyRulesToFolder(RULE_APPLY_PARTIALS, 0, m_pIExecRules, pInbox, NULL, NULL);
    }

exit:
    // Cleanup
    m_pUI->SetSpecificProgress(c_szEmpty);
    m_pUI->SetProgressRange(100);
    SafeRelease(pInbox);
    SafeRelease(pDeletedItems);
    SafeRelease(pParts);
    SafeRelease(pMailMsg);
    SafeRelease(pMailMsgSingle);
    _FreePartialMsgs(pPartialMsgs, cPartialMsgs);
    SafeMemFree(pPartialMsgs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_GetMoveFolder
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_GetMoveFolder(LPPOP3ITEM pItem, IMessageFolder ** ppFolder)
{
    HRESULT             hr = S_OK;
    IMessageFolder *    pFolder = NULL;
    ULONG               ulIndex = 0;
    FOLDERID            idFolder = FOLDERID_INVALID;
    FOLDERINFO          infoFolder = {0};
    SPECIALFOLDER       tySpecial = FOLDER_NOTSPECIAL;
    RULEFOLDERDATA *    prfdData = NULL;

    // Check incoming params
    if ((NULL == pItem) || (NULL == ppFolder))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppFolder = NULL;

    // Search for a Move actions
    for (ulIndex = 0; ulIndex < pItem->cActList; ulIndex++)
    {
        switch (pItem->pActList[ulIndex].type)
        {
            case ACT_TYPE_MOVE:
                Assert(VT_BLOB == pItem->pActList[ulIndex].propvar.vt);
                if ((0 != pItem->pActList[ulIndex].propvar.blob.cbSize) && (NULL != pItem->pActList[ulIndex].propvar.blob.pBlobData))
                {
                    // Make life simpler
                    prfdData = (RULEFOLDERDATA *) (pItem->pActList[ulIndex].propvar.blob.pBlobData);
                    
                    // Validate the rule folder data
                    if (S_OK == RuleUtil_HrValidateRuleFolderData(prfdData))
                    {
                        idFolder = prfdData->idFolder;
                    }
                }
                break;
                
            case ACT_TYPE_DELETE:
            case ACT_TYPE_JUNKMAIL:
                Assert(VT_EMPTY == pItem->pActList[ulIndex].propvar.vt);

                tySpecial = (ACT_TYPE_JUNKMAIL == pItem->pActList[ulIndex].type) ? FOLDER_JUNK : FOLDER_DELETED;
                
                hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, tySpecial, &infoFolder);
                if (FAILED(hr))
                {
                    goto exit;;
                }

                idFolder = infoFolder.idFolder;
                break;
        }

        // Are we through?
        if (idFolder != FOLDERID_INVALID)
        {
            break;
        }
    }
    
    // Did we find anything?
    if (ulIndex >= pItem->cActList)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Get the message folder
    hr = m_pIExecRules->GetRuleFolder(idFolder, (DWORD_PTR *) (&pFolder));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Use the new folder
    *ppFolder = pFolder;
    pFolder = NULL;

    // NULL out the actions
    pItem->pActList[ulIndex].type = ACT_TYPE_NULL;

    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pFolder);
    g_pStore->FreeRecord(&infoFolder);
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::Cancel(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Canceled
    FLAGSET(m_dwState, POP3STATE_CANCELPENDING);

    // Am I in a state where I can drop the connection???
    if (POP3STATE_UIDLSYNC != m_state)
    {
        if (POP3STATE_UIDLSYNC != m_state && POP3STATE_DOWNLOADING != m_state && POP3STATE_DELETING != m_state)
        {
            // Simply drop the connection
            //If a dialer UI is not dismissed, before changing the identities or shutting down OE, 
            //the transport object would not have been created. This happens only when the dialer UI is not 
            //modal to the window. Right now IE dialer is modal and MSN dialer is not.
            //See Bug# 53679
            
            if (m_pTransport)
                m_pTransport->DropConnection();
        }

        // Otherwise, let the state handle the disconnect
        else
        {
            // Finishing last message...
            m_pUI->SetSpecificProgress(MAKEINTRESOURCE(idsSpoolerDisconnect));
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnTimeoutResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Should have a handle to the timeout window
    Assert(m_hwndTimeout);

    // No timeout window handle
    m_hwndTimeout = NULL;

    // Stop ?
    if (TIMEOUT_RESPONSE_STOP == eResponse)
    {
        // Canceled
        FLAGSET(m_dwState, POP3STATE_CANCELPENDING);

        // Report error and drop connection
        _CatchResult(IXP_E_TIMEOUT);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::IsDialogMessage(LPMSG pMsg)
{
    HRESULT hr=S_FALSE;
    EnterCriticalSection(&m_cs);
    if (m_hwndTimeout && IsWindow(m_hwndTimeout))
        hr = (TRUE == ::IsDialogMessage(m_hwndTimeout, pMsg)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}


// --------------------------------------------------------------------------------
// CPop3Task::OnFlagsChanged
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnFlagsChanged(DWORD dwFlags)
    {
    EnterCriticalSection(&m_cs);
    m_dwFlags = dwFlags;
    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\smtptask.cpp ===
// --------------------------------------------------------------------------------
// Smtptask.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "smtptask.h"
#include "mimeutil.h"
#include "goptions.h"
#include "strconst.h"
#include "xputil.h"
#include "resource.h"
#include "shlwapip.h" 
#include "spoolui.h"
#include "thormsgs.h"
#include "flagconv.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "storecb.h"
#include "demand.h"
#include "taskutil.h"

// --------------------------------------------------------------------------------
// Data Types
// --------------------------------------------------------------------------------
typedef enum tagSMTPEVENTTYPE
    { 
    EVENT_SMTP,
    EVENT_IMAPUPLOAD
    } SMTPEVENTTYPE;

// --------------------------------------------------------------------------------
// CURRENTSMTPEVENT
// --------------------------------------------------------------------------------
#define CURRENTSMTPEVENT(_rTable) (&_rTable.prgEvent[_rTable.iEvent])


// --------------------------------------------------------------------------------
// CMessageIdStream::CMessageIdStream
// --------------------------------------------------------------------------------
CMessageIdStream::CMessageIdStream(IStream *pStream) : m_pStream(pStream) 
{
    // Reference count
    m_cRef = 1;

    // Addref the source stream
    m_pStream->AddRef();

    // Format the string
    ULONG cchPrefix = wnsprintf(m_szMessageId, ARRAYSIZE(m_szMessageId), "%s: ", STR_HDR_MESSAGEID);

    // Generate a message Id
    if (FAILED(MimeOleGenerateMID(m_szMessageId + cchPrefix, sizeof(m_szMessageId) - cchPrefix, FALSE)))
    {
        Assert(FALSE);
        *m_szMessageId = '\0';
        m_cchMessageId = 0;
    }

    // Otherwise, fixup the message id so that <mid>\r\n
    else
    {
        StrCatBuff(m_szMessageId, "\r\n", ARRAYSIZE(m_szMessageId));
        m_cchMessageId = lstrlen(m_szMessageId);
    }

    // Iniailize Index
    m_cbIndex = 0;
}

// --------------------------------------------------------------------------------
// CMessageIdStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageIdStream::Seek(LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew) 
{ 
    // Only supported case
    if (STREAM_SEEK_SET != dwOrigin && 0 != liMove.LowPart && 0 != liMove.HighPart && 0 != m_cbIndex) 
    {
        Assert(FALSE);
        return E_NOTIMPL; 
    }

    // Otheriwse, set new position
    else if (pulNew)
    {
        pulNew->HighPart = 0;
        pulNew->LowPart = 0;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageIdStream::Read
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageIdStream::Read(LPVOID pv, ULONG cbWanted, ULONG *pcbRead) 
{
    // Locals
    HRESULT hr=S_OK;

    // Reading from m_szMessageId ?
    if (m_cbIndex < m_cchMessageId)
    {
        // Compute amount I can read from m_cchMessageId
        ULONG cbReadMsgId = min(m_cchMessageId - m_cbIndex, cbWanted);

        // Init pcbRead
        if (pcbRead)
            *pcbRead = 0;

        // If we have some ?
        if (cbReadMsgId)
        {
            // Copy memory
            CopyMemory(pv, m_szMessageId + m_cbIndex, cbReadMsgId);

            // Increment index
            m_cbIndex += cbReadMsgId;
        }

        // If there is still some left to read...
        if (cbReadMsgId < cbWanted)
            hr = m_pStream->Read(((LPBYTE)pv + cbReadMsgId), cbWanted - cbReadMsgId, pcbRead);

        // Fixup pcbRead
        if (pcbRead)
            (*pcbRead) += cbReadMsgId;
    }

    // Otherwise, read from source stream
    else
        hr = m_pStream->Read(pv, cbWanted, pcbRead);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::CSmtpTask
// --------------------------------------------------------------------------------
CSmtpTask::CSmtpTask(void)
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_pSpoolCtx = NULL;
    m_pAccount = NULL;
    m_pTransport = NULL;
    m_pOutbox = NULL;
    m_pSentItems = NULL;
    m_cbTotal = 0;
    m_cbSent = 0;
    m_wProgress = 0;
    m_idEvent = INVALID_EVENT;
    m_idEventUpload = INVALID_EVENT;
    m_pUI = NULL;
    m_dwState = 0;
    m_pAdrEnum = NULL;
    m_hwndTimeout = NULL;
    m_pLogFile = NULL;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    ZeroMemory(&m_rTable, sizeof(SMTPEVENTTABLE));
    ZeroMemory(&m_rList, sizeof(MESSAGEIDLIST));
    m_pCancel = NULL;
    m_tyOperation = SOT_INVALID;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSmtpTask::~CSmtpTask
// --------------------------------------------------------------------------------
CSmtpTask::~CSmtpTask(void)
{
    // Reset the Object
    _ResetObject(TRUE);

    // Kill the critical section
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSmtpTask::_ResetObject
// --------------------------------------------------------------------------------
void CSmtpTask::_ResetObject(BOOL fDeconstruct)
{
    // Make sure the transport is disconnect
    if (m_pTransport)
    {
        m_pTransport->Release();
        m_pTransport = NULL;
    }

    // Release the Outbox
    SafeRelease(m_pAccount);
    SafeRelease(m_pOutbox);
    SafeRelease(m_pSentItems);
    SafeRelease(m_pAdrEnum);
    SafeRelease(m_pSpoolCtx);
    SafeRelease(m_pUI);
    SafeRelease(m_pLogFile);
    SafeRelease(m_pCancel);
    SafeMemFree(m_rList.prgidMsg);
    ZeroMemory(&m_rList, sizeof(MESSAGEIDLIST));

    // Free the event table elements
    _FreeEventTableElements();

    // Deconstructing
    if (fDeconstruct)
    {
        // Free Event Table
        SafeMemFree(m_rTable.prgEvent);
    }

    // Otherwise, reset some vars
    else
    {
        // Reset total byte count
        m_cbTotal = 0;
        m_idEvent = INVALID_EVENT;
        m_cbSent = 0;
        m_wProgress = 0;
        ZeroMemory(&m_rServer, sizeof(INETSERVER));
    }
}

// --------------------------------------------------------------------------------
// CSmtpTask::Init
// --------------------------------------------------------------------------------
void CSmtpTask::_FreeEventTableElements(void)
{
    // Loop the table of events
    for (ULONG i=0; i<m_rTable.cEvents; i++)
    {
        // Release the Message
        SafeRelease(m_rTable.prgEvent[i].pMessage);
    }

    // No Events
    m_rTable.cEvents = 0;
}

// --------------------------------------------------------------------------------
// CSmtpTask::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerTask *)this;
    else if (IID_ISpoolerTask == riid)
        *ppv = (ISpoolerTask *)this;
    else if (IID_ITimeoutCallback == riid)
        *ppv = (ITimeoutCallback *) this;
    else if (IID_ITransportCallbackService == riid)
        *ppv = (ITransportCallbackService *) this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::CSmtpTask
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSmtpTask::AddRef(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = ++m_cRef;
    LeaveCriticalSection(&m_cs);
    return cRef;
}

// --------------------------------------------------------------------------------
// CSmtpTask::CSmtpTask
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSmtpTask::Release(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = --m_cRef;
    LeaveCriticalSection(&m_cs);
    if (0 != cRef)
        return cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CSmtpTask::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Invalid Arg
    if (NULL == pBindCtx)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset this object
    _ResetObject(FALSE);

    // Save the Activity Flags - DELIVER_xxx
    m_dwFlags = dwFlags;

    // Hold onto the bind context
    Assert(NULL == m_pSpoolCtx);
    m_pSpoolCtx = pBindCtx;
    m_pSpoolCtx->AddRef();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::BuildEvents
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       fSplitMsgs;
    FOLDERINFO  Folder;
    FOLDERID    id;
    DWORD       cbMaxPart;
    CHAR        szRes[255];
    CHAR        szMessage[255];
    CHAR        szAccount[CCHMAX_ACCOUNT_NAME];
    CHAR        szDefault[CCHMAX_ACCOUNT_NAME];
    MESSAGEINFO MsgInfo={0};
    HROWSET     hRowset=NULL;

    // Invalid Arg
    if (NULL == pSpoolerUI || NULL == pAccount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(NULL == m_pTransport && NULL == m_pAccount && NULL == m_pOutbox && 0 == m_rTable.cEvents);
    Assert(NULL == m_pSentItems);

    // Save the UI Object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Release current Account
    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Get the Account Name
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount)));

    // Split Messages ?
    if (FAILED(m_pAccount->GetPropDw(AP_SMTP_SPLIT_MESSAGES, &fSplitMsgs)))
        fSplitMsgs = FALSE;

    // Split Size
    if (FAILED(m_pAccount->GetPropDw(AP_SMTP_SPLIT_SIZE, &cbMaxPart)))
    {
        fSplitMsgs = FALSE;
        cbMaxPart = 0;
    }

    // Else, convert cbMaxPart for kilobytes to bytes
    else
        cbMaxPart *= 1024;

    // Get the default Account
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(ACCT_MAIL, szDefault, ARRAYSIZE(szDefault))))
    {
        if (lstrcmpi(szDefault, szAccount) == 0)
            FLAGSET(m_dwState, SMTPSTATE_DEFAULT);
    }

    // Get the outbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&m_pOutbox));

    // Create a Rowset
    CHECKHR(hr = m_pOutbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == m_pOutbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
    {
        // Process Store Header
        CHECKHR(hr = _HrAppendOutboxMessage(szAccount, &MsgInfo, fSplitMsgs, cbMaxPart));

        // Free Current
        m_pOutbox->FreeRecord(&MsgInfo);
    } 

    // If no messages, were done
    if (0 == m_rTable.cEvents)
        goto exit;

    // Get a SMTP log file
    m_pSpoolCtx->BindToObject(IID_CSmtpLogFile, (LPVOID *)&m_pLogFile);

    // Format the string
    LOADSTRING(IDS_SPS_SMTPEVENT, szRes);

    // Build the message
    wnsprintf(szMessage, ARRAYSIZE(szMessage), szRes, m_rTable.cEvents, szAccount);

    // Register the event
    CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, EVENT_SMTP, m_pAccount, &m_idEvent));

    // Get SentItems
    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        // Get Sent Items Folder
        CHECKHR(hr = TaskUtil_OpenSentItemsFolder(m_pAccount, &m_pSentItems));

        // Get the Folder Id
        m_pSentItems->GetFolderId(&id);

        // Get the folder information
        CHECKHR(hr = g_pStore->GetFolderInfo(id, &Folder));

        // If not a local folder, then we will need to do an upload
        if (Folder.tyFolder != FOLDER_LOCAL)
        {
            // Get event string
            LOADSTRING(IDS_SPS_MOVEEVENT, szRes);

            // Format the message
            wnsprintf(szMessage, ARRAYSIZE(szMessage), szRes, szAccount);

            // Register Upload Event
            CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, EVENT_IMAPUPLOAD, m_pAccount, &m_idEventUpload));
        }

        // Free the Record
        g_pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    if (m_pOutbox)
    {
        m_pOutbox->CloseRowset(&hRowset);
        m_pOutbox->FreeRecord(&MsgInfo);
    }

    // Failure
    if (FAILED(hr))
    {
        _CatchResult(hr, IXP_SMTP);
        _ResetObject(FALSE);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrAppendEventTable
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrAppendEventTable(LPSMTPEVENTINFO *ppEvent)
{
    // Locals
    HRESULT hr=S_OK;

    // Add an item to the event list
    if (m_rTable.cEvents + 1 > m_rTable.cAlloc)
    {
        // Realloc the table
        CHECKHR(hr = HrRealloc((LPVOID *)&m_rTable.prgEvent, sizeof(SMTPEVENTINFO) * (m_rTable.cAlloc + 10)));

        // Increment cAlloc
        m_rTable.cAlloc += 10;
    }

    // Readability
    *ppEvent = &m_rTable.prgEvent[m_rTable.cEvents];

    // ZeroInit
    ZeroMemory(*ppEvent, sizeof(SMTPEVENTINFO));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrAppendOutboxMessage
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pMsgInfo, 
    BOOL fSplitMsgs, DWORD cbMaxPart)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSMTPEVENTINFO pEvent;
    IImnAccount    *pAccount=NULL;

    // Invalid Arg
    Assert(pszAccount && pMsgInfo);

    // Has this message been submitted and is it a mail message
    if((pMsgInfo->dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) != ARF_SUBMITTED)
        goto exit;

    // Empty Account Name
    if (NULL == pMsgInfo->pszAcctId || FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pMsgInfo->pszAcctId, &pAccount)))
    {
        // Not the Default Account
        if (!ISFLAGSET(m_dwState, SMTPSTATE_DEFAULT) || ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            goto exit;

        // Have I asked the user if they want to use the default account
        if (!ISFLAGSET(m_dwState, SMTPSTATE_ASKEDDEFAULT))
        {
            // Get hwndParent
            HWND hwndParent;
            if (FAILED(m_pUI->GetWindow(&hwndParent)))
                hwndParent = NULL;

            // Message
            if (AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(IDS_SPS_SMTPUSEDEFAULT), NULL, MB_YESNO|MB_ICONEXCLAMATION ) == IDYES)
                FLAGSET(m_dwState, SMTPSTATE_USEDEFAULT);
            else
                goto exit;

            // I've Asked, don't ask again
            FLAGSET(m_dwState, SMTPSTATE_ASKEDDEFAULT);
        }

        // Not using default
        else if (!ISFLAGSET(m_dwState, SMTPSTATE_USEDEFAULT))
            goto exit;
    }

    // Use this account
    else if (lstrcmpi(pMsgInfo->pszAcctName, pszAccount) != 0)
        goto exit;

    // Split the Message ?
    if (TRUE == fSplitMsgs && pMsgInfo->cbMessage >= cbMaxPart)
    {
        // Make sure the total number of messages is less than 100
        if (100 <= (pMsgInfo->cbMessage / cbMaxPart))
        {
            HWND    hwndParent;
            CHAR    rgchBuff[CCHMAX_STRINGRES + 20];
            CHAR    rgchRes[CCHMAX_STRINGRES];
            DWORD   cbMaxPartCount;
            
            // Figure out the new message part size
            cbMaxPartCount = pMsgInfo->cbMessage / 100;

            // Round the new message part size to the
            // closest power of 2
            if (0x80000000 <= cbMaxPartCount)
            {
                // Can't round up any higher
                cbMaxPart = cbMaxPartCount;
            }
            else
            {
                cbMaxPart = 1;
                do
                {
                    cbMaxPart *= 2;
                } while ( 0 != (cbMaxPartCount /= 2));
            }

            // Get the UI window
            if (FAILED(m_pUI->GetWindow(&hwndParent)))
                hwndParent = NULL;

            if (NULL == AthLoadString(idsErrTooManySplitMsgs, rgchRes, sizeof(rgchRes)))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Display the warning string
            wnsprintf(rgchBuff, ARRAYSIZE(rgchBuff), rgchRes, cbMaxPart / 1024);
            if (AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthenaMail), rgchBuff, NULL, MB_YESNO|MB_ICONEXCLAMATION ) != IDYES)
                goto exit;
        }
        
        // Split and Add the message
        CHECKHR(hr = _HrAppendSplitMessage(pMsgInfo, cbMaxPart));
    }

    // Otherwise, simply add the message as normal
    else
    {
        // Append the Table
        CHECKHR(hr = _HrAppendEventTable(&pEvent));

        // Save the store message id
        pEvent->idMessage = pMsgInfo->idMessage;

        // Save Message Size + 100 which is the average MID that is added on
        pEvent->cbEvent = pMsgInfo->cbMessage;

        // Increment total send byte count
        m_cbTotal += pEvent->cbEvent;

        // Running Sent Total
        pEvent->cbSentTotal = m_cbTotal;

        // Increment Number of event
        m_rTable.cEvents++;
    }

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrAppendSplitMessage
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrAppendSplitMessage(LPMESSAGEINFO pMsgInfo, DWORD cbMaxPart)
{
    // Locals
    HRESULT                  hr=S_OK;
    ULONG                    c;
    ULONG                    iPart=1;
    ULONG                    cParts;
    IMimeMessage            *pMessage=NULL;
    IMimeMessage            *pMsgPart=NULL;
    IMimeMessageParts       *pParts=NULL;
    IMimeEnumMessageParts   *pEnum=NULL;
    LPSMTPEVENTINFO          pEvent;

    // Invalid Arg
    Assert(pMsgInfo);

    // Lets open the message from the Outbox
    CHECKHR(hr = _HrOpenMessage(pMsgInfo->idMessage, &pMessage));

    // Split the message
    CHECKHR(hr = pMessage->SplitMessage(cbMaxPart, &pParts));

    // Get Total Parts
    CHECKHR(hr = pParts->CountParts(&cParts));

    // Walk the list of messages
    CHECKHR(hr = pParts->EnumParts(&pEnum));

    // Walk the parts and add them into the event list
    while(SUCCEEDED(pEnum->Next(1, &pMsgPart, &c)) && 1 == c)
    {
        // Append the Table
        CHECKHR(hr = _HrAppendEventTable(&pEvent));

        // Event Type
        FLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART);

        // Split Information
        pEvent->iPart = iPart;
        pEvent->cParts = cParts;
        pEvent->cbParts = pMsgInfo->cbMessage;

        // Save the message part
        pEvent->pMessage = pMsgPart;
        pMsgPart = NULL;

        // Save Message Size
        pEvent->pMessage->GetMessageSize(&pEvent->cbEvent, 0);

        // Increment total send byte count
        m_cbTotal += pEvent->cbEvent;

        // Running Sent Total
        pEvent->cbSentTotal = m_cbTotal;

        // Increment Number of event
        m_rTable.cEvents++;

        // Increment iPart
        iPart++;
    }

    // Have the last split message free the header info
    pEvent->idMessage = pMsgInfo->idMessage;

exit:
    // Cleanup
    SafeRelease(pMessage);
    SafeRelease(pParts);
    SafeRelease(pMsgPart);
    SafeRelease(pEnum);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CSmtpTask::_HrOpenMessage
// ------------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrOpenMessage(MESSAGEID idMessage, IMimeMessage **ppMessage)
{
    // Locals
    HRESULT         hr=S_OK;

    // Check Params
    Assert(ppMessage && m_pOutbox);

    // Init
    *ppMessage = NULL;

    // Stream in message
    CHECKHR(hr = m_pOutbox->OpenMessage(idMessage, OPEN_MESSAGE_SECURE  , ppMessage, NOSTORECALLBACK));

    // remove an X-Unsent headers before sending
    (*ppMessage)->DeleteBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT));

exit:
    // Failure
    if (FAILED(hr))
        SafeRelease((*ppMessage));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::Execute
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    HRESULT hr = E_FAIL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // What is the event type
    if (EVENT_SMTP == dwTwinkie)
    {
        // Better not have a transport yet...
        Assert(NULL == m_pTransport);

        // Create the Transport Object
        CHECKHR(hr = CreateSMTPTransport(&m_pTransport));

        // Init the Transport
        CHECKHR(hr = m_pTransport->InitNew(NULL, (ISMTPCallback *)this));

        // Fill an INETSERVER structure from the account object
        CHECKHR(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rServer));

        // Use IP Address for HELO command ?
        if (DwGetOption(OPT_SMTPUSEIPFORHELO))
            FLAGSET(m_rServer.dwFlags, ISF_SMTP_USEIPFORHELO);

        // If this account is set to always prompt for password and password isn't already cached, show UI so we can prompt user for password
        if (ISFLAGSET(m_rServer.dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) && FAILED(GetPassword(m_rServer.dwPort, m_rServer.szServerName, m_rServer.szUserName, NULL, 0)))
            m_pUI->ShowWindow(SW_SHOW);

        // Execute SMTP Event
        hr = _ExecuteSMTP(eid, dwTwinkie);
    }

    // Otherwise, do IMAP Event
    else if (EVENT_IMAPUPLOAD == dwTwinkie)
        hr = _ExecuteUpload(eid, dwTwinkie);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CSmtpTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CSmtpTask::_ExecuteSMTP
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_ExecuteSMTP(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szRes[CCHMAX_RES];
    CHAR        szBuf[CCHMAX_RES + CCHMAX_SERVER_NAME];
    DWORD       cb;

    // I only handle on event
    Assert(m_pAccount && m_idEvent == eid && m_pUI && m_pTransport && m_rTable.cEvents > 0);

    // Set the animation
    m_pUI->SetAnimation(idanOutbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    // Connecting to ...
    LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CONNECTING, 0);

    // Connect
    CHECKHR(hr = m_pTransport->Connect(&m_rServer, TRUE, TRUE));

exit:
    // Failure
    if (FAILED(hr))
    {
        FLAGSET(m_dwState, SMTPSTATE_EXECUTEFAILED);
        _CatchResult(hr, IXP_SMTP);

        // Hands Off my callback: otherwise we leak like a stuck pig
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);
    }

    return hr;
} // _ExecuteSMTP

HRESULT CSmtpTask::_ExecuteUpload(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Locals
    HRESULT             hr=S_OK;
    ADJUSTFLAGS         Flags;

    // I only handle on event
    Assert(m_pAccount && m_idEventUpload == eid && m_pUI && m_pTransport && m_rTable.cEvents > 0);

    // Invalid State
    Assert(m_pOutbox);
    Assert(m_pSentItems != NULL);

    // Are the Ids
    if (m_rList.cMsgs)
    {
        // Setup Flags
        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;

        // Move the message from the sent items folder
        hr = m_pOutbox->CopyMessages(m_pSentItems, COPY_MESSAGE_MOVE, &m_rList, &Flags, NULL, this);
        Assert(FAILED(hr));
        if (hr == E_PENDING)
        {
            hr = S_OK;
        }
        else
        {
            IXPTYPE ixpType;

            FLAGSET(m_dwState, SMTPSTATE_EXECUTEFAILED);
    
            // Remap the Error Result
            hr = TrapError(SP_E_CANT_MOVETO_SENTITEMS);

            // Show an error in the spooler dialog
            ixpType = m_pTransport->GetIXPType();
            _CatchResult(hr, ixpType);
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
} // _ExecuteSMTP

// --------------------------------------------------------------------------------
// CSmtpTask::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Is there currently a timeout dialog
    if (m_hwndTimeout)
    {
        // Set foreground
        SetForegroundWindow(m_hwndTimeout);
    }
    else
    {
        // Not suppose to be showing UI ?
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Do Timeout Dialog
        m_hwndTimeout = TaskUtil_HwndOnTimeout(m_rServer.szServerName, m_rServer.szAccount, "SMTP", m_rServer.dwTimeout, (ITimeoutCallback *) this);

        // Couldn't create the dialog
        if (NULL == m_hwndTimeout)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Always tell the transport to keep on trucking
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    // Locals
    HRESULT hr=S_FALSE;
    SMTPAUTHTYPE authtype;
    char szPassword[CCHMAX_PASSWORD];

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, sizeof(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        StrCpyN(pInetServer->szPassword, szPassword, ARRAYSIZE(pInetServer->szPassword));
        ZeroMemory(szPassword, sizeof(szPassword));        // Done for security.
        return S_OK;
    }

    hr = S_FALSE; // Re-initialize

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // NOERRORS...
    if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        goto exit;

    // TaskUtil_OnLogonPrompt
    hr = TaskUtil_OnLogonPrompt(m_pAccount, m_pUI, NULL, pInetServer, AP_SMTP_USERNAME,
                                AP_SMTP_PASSWORD, AP_SMTP_PROMPT_PASSWORD, FALSE);

    // Cache the password if the user slected ok
    if (S_OK == hr)
    {
        // Save the password
        SavePassword(pInetServer->dwPort, pInetServer->szServerName,
            pInetServer->szUserName, pInetServer->szPassword);

        // Lets switch the account to using the logon information...
        authtype = SMTP_AUTH_USE_SMTP_SETTINGS;
        m_pAccount->SetPropDw(AP_SMTP_USE_SICILY, (DWORD)authtype);

        // Save the changes
        m_pAccount->SaveChanges();
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    ZeroMemory(szPassword, sizeof(szPassword));        // Done for security.

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CSmtpTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport)
{
    // Locals
    HWND        hwnd;
    INT         nAnswer;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(0);
#endif
        
    // Invalid State
    Assert(m_pUI);

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;

    // I assume this is a critical prompt, so I will not check for no UI mode
    nAnswer = MessageBox(hwnd, pszText, pszCaption, uType);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return nAnswer;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    // Locals
    EVENTCOMPLETEDSTATUS tyEventStatus=EVENT_SUCCEEDED;

    // Invalid State
    Assert(m_pUI && m_pSpoolCtx);
    if (!m_pUI || !m_pSpoolCtx)
    {
        return E_FAIL;
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Feed the the IXP status to the UI object
    m_pUI->SetSpecificProgress(MAKEINTRESOURCE(XPUtil_StatusToString(ixpstatus)));

    // Disconnected
    if (ixpstatus == IXP_DISCONNECTED)
    {
        // Kill the timeout dialog
        if (m_hwndTimeout)
        {
            DestroyWindow(m_hwndTimeout);
            m_hwndTimeout = NULL;
        }

        // _OnDisconnectComplete
        HRESULT hrDisconnect = _OnDisconnectComplete();

        // Reset the progress
        // m_pUI->SetProgressRange(100);

        // Set the animation
        m_pUI->SetAnimation(idanOutbox, FALSE);

        // Determine 
        if (ISFLAGSET(m_dwState, SMTPSTATE_CANCELED))
            tyEventStatus = EVENT_CANCELED;
        else if (m_rTable.cCompleted == 0 && m_rTable.cEvents > 0)
            tyEventStatus = EVENT_FAILED;
        else if (m_rTable.cCompleted && m_rTable.cEvents && m_rTable.cCompleted < m_rTable.cEvents)
            tyEventStatus = EVENT_WARNINGS;
        else if (FAILED(hrDisconnect))
            tyEventStatus = EVENT_WARNINGS;

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

        // Hands Off my callback
        if (m_pTransport)
            SideAssert(m_pTransport->HandsOffCallback() == S_OK);

        // This task is complete
        if (!ISFLAGSET(m_dwState, SMTPSTATE_EXECUTEFAILED))
            m_pSpoolCtx->EventDone(m_idEvent, tyEventStatus);
    }

    // Authorizing
    else if (ixpstatus == IXP_AUTHORIZING)
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_AUTHORIZING, 0);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport)
{
    INETSERVER  rServer;
    HRESULT     hrResult;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI);

    // Insert Error Into UI
    if (m_pTransport)
    {
        hrResult = pTransport->GetServerInfo(&rServer);
        if (FAILED(hrResult))
            CopyMemory(&rServer, &m_rServer, sizeof(rServer));
    }

    _CatchResult(pResult, &rServer, IXP_SMTP);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport)
{
    // Logging
    if (m_pLogFile && pszLine)
    {
        // Response
        if (CMD_RESP == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_RX, pszLine);

        // Send
        else if (CMD_SEND == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_TX, pszLine);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CSmtpTask::_CatchResult(HRESULT hr, IXPTYPE ixpType)
{
    // Locals
    IXPRESULT   rResult;

    // Build an IXPRESULT
    ZeroMemory(&rResult, sizeof(IXPRESULT));
    rResult.hrResult = hr;

    // Get the SMTP Result Type
    return _CatchResult(&rResult, &m_rServer, ixpType);
}

// --------------------------------------------------------------------------------
// CSmtpTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CSmtpTask::_CatchResult(LPIXPRESULT pResult, INETSERVER *pServer, IXPTYPE ixpType)
{
    // Locals
    HWND            hwndParent;
    TASKRESULTTYPE  tyTaskResult=TASKRESULT_FAILURE;
    LPSTR           pszSubject=NULL;

    // If Succeeded
    if (SUCCEEDED(pResult->hrResult))
        return TASKRESULT_SUCCESS;

    // Is there is a current event, get the subject
    if (m_rTable.prgEvent && m_rTable.prgEvent[m_rTable.iEvent].pMessage)
    {
        // Get the subject
        if (FAILED(MimeOleGetBodyPropA(m_rTable.prgEvent[m_rTable.iEvent].pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pszSubject)))
            pszSubject = NULL;
    }

    // Get Window
    if (NULL == m_pUI || FAILED(m_pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    // Process generic protocol errro
    tyTaskResult = TaskUtil_FBaseTransportError(ixpType, m_idEvent, pResult, pServer, pszSubject, m_pUI,
                                                !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

    // Have a Transport
    if (m_pTransport)
    {
        // If Task Failure, drop the connection
        if (TASKRESULT_FAILURE == tyTaskResult)
        {
            // Roast the current connection
            m_pTransport->DropConnection();
        }

        // If Event Failure...
        else if (TASKRESULT_EVENTFAILED == tyTaskResult)
        {
            // Goto Next Event
            if (FAILED(_HrFinishCurrentEvent(pResult->hrResult)))
            {
                // Roast the current connection
                m_pTransport->DropConnection();
            }
        }
    }

    // Cleanup
    SafeMemFree(pszSubject);

    // Return Result
    return tyTaskResult;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_DoProgress
// --------------------------------------------------------------------------------
void CSmtpTask::_DoProgress(void)
{
    // Locals
    WORD            wProgress;
    WORD            wDelta;
    LPSMTPEVENTINFO pEvent;

    // Invalid Arg
    Assert(m_cbTotal > 0 && m_pUI);

    // Compute Current Progress Index
    wProgress = (WORD)((m_cbSent * 100) / m_cbTotal);

    // Compute Delta
    wDelta = wProgress - m_wProgress;

    // Progress Delta
    if (wDelta > 0)
    {
        // Incremenet Progress
        m_pUI->IncrementProgress(wDelta);

        // Increment my wProgress
        m_wProgress += wDelta;

        // Don't go over 100 percent
        Assert(m_wProgress <= 100);
    }
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnResponse(LPSMTPRESPONSE pResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    if (pResponse)
    {
        // Handle the Error
        if (TASKRESULT_SUCCESS != _CatchResult(&pResponse->rIxpResult, &m_rServer, IXP_SMTP))
            goto exit;

        // Handle Command Type
        switch(pResponse->command)
        {
        case SMTP_CONNECTED:
            // CommandRSET
            _CatchResult(_HrOnConnected(), IXP_SMTP);

            // Done
            break;

        case SMTP_RSET:
            // Progress
            _DoProgress();

            // Send the current message
            _CatchResult(_HrStartCurrentEvent(), IXP_SMTP);

            // Done
            break;

        case SMTP_MAIL:
            // Reset the address enumerator
            Assert(m_pAdrEnum);
            m_pAdrEnum->Reset();

            // CommandRCPT
            _CatchResult(_HrCommandRCPT(), IXP_SMTP);

            // Done
            break;

        case SMTP_RCPT:
            // CommandRCPT -> CommandDATA
            _CatchResult(_HrCommandRCPT(), IXP_SMTP);

            // Done
            break;

        case SMTP_DATA:
            // Send the data stream
            _CatchResult(_HrSendDataStream(), IXP_SMTP);

            // Done
            break;

        case SMTP_SEND_STREAM:
            // Increment Current Progress
            _OnStreamProgress(&pResponse->rStreamInfo);

            // Done
            break;

        case SMTP_DOT:
            // Finish the Current Event
            _CatchResult(_HrFinishCurrentEvent(S_OK), IXP_SMTP);

            // Done
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrOnConnected
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrOnConnected(void)
{
    // Locals
    CHAR        szRes[CCHMAX_RES];
    CHAR        szMsg[CCHMAX_RES+CCHMAX_RES];

    // Progress
    LOADSTRING(IDS_SPS_SMTPPROGGEN, szRes);
    wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rServer.szAccount);

    // Set General Progress
    m_pUI->SetGeneralProgress(szMsg);

    // Progress
    _DoProgress();

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_SENDING, 0);

    // Send the current message
    _CatchResult(_HrStartCurrentEvent(), IXP_SMTP);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrStartCurrentEvent
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrStartCurrentEvent(void)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSMTPEVENTINFO     pEvent;
    IMimeAddressTable  *pAddrTable=NULL;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];

    // Invalid Arg
    Assert(m_rTable.iEvent < m_rTable.cEvents);

    // Get the current event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Is this a partial message
    if (ISFLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART))
    {
        LOADSTRING(IDS_SPS_SMTPPROGRESS_SPLIT, szRes);
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rTable.iEvent + 1, m_rTable.cEvents, pEvent->iPart, pEvent->cParts);
    }

    // Otherwise
    else
    {
        LOADSTRING(IDS_SPS_SMTPPROGRESS, szRes);
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, m_rTable.iEvent + 1, m_rTable.cEvents);
    }

    // Set Specific Progress
    m_pUI->SetSpecificProgress(szMsg);

    // If mail is coming from the outbox
    if (!ISFLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART))
    {
        // Open Store Message
        if (FAILED(_HrOpenMessage(pEvent->idMessage, &pEvent->pMessage)))
        {
            hr = TrapError(SP_E_SMTP_CANTOPENMESSAGE);
            goto exit;
        }
    }

    // We better have a message object at this point
    else if (NULL == pEvent->pMessage)
    {
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Catch Result
    CHECKHR(hr = _HrCommandMAIL());

exit:
    // Cleanup
    SafeRelease(pAddrTable);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CSmtpTask::_HrCommandMAIL
// ------------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrCommandMAIL(void)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrFind;
    IMimeAddressTable  *pAdrTable=NULL;
    ADDRESSPROPS        rAddress;
    ULONG               c;
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Init
    ZeroMemory(&rAddress, sizeof(ADDRESSPROPS));

    // Check State
    Assert(m_pTransport && pEvent->pMessage);

    // Release Current Enumerator
    SafeRelease(m_pAdrEnum);

    // Get the Sender...
    CHECKHR(hr = pEvent->pMessage->GetAddressTable(&pAdrTable));

    // Get Enumerator
    CHECKHR(hr = pAdrTable->EnumTypes(IAT_KNOWN, IAP_ADRTYPE | IAP_EMAIL, &m_pAdrEnum));

    // Loop Enumerator
    while (SUCCEEDED(m_pAdrEnum->Next(1, &rAddress, &c)) && c == 1)
    {
        // Not IAT_FROM
        if (NULL == rAddress.pszEmail || IAT_FROM != rAddress.dwAdrType)
        {
            g_pMoleAlloc->FreeAddressProps(&rAddress);
            continue;
        }

        // Send the command
        CHECKHR(hr = m_pTransport->CommandMAIL(rAddress.pszEmail));

        // Done
        goto exit;
    }

    // No Sender
    hr = TrapError(IXP_E_SMTP_NO_SENDER);

exit:
    // Cleanup
    SafeRelease(pAdrTable);
    g_pMoleAlloc->FreeAddressProps(&rAddress);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CSmtpTask::_HrCommandRCPT
// ------------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrCommandRCPT(void)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwAdrType;
    DWORD               c;
    LPSTR               pszEmail=NULL;
    ADDRESSPROPS        rAddress;
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Init
    ZeroMemory(&rAddress, sizeof(ADDRESSPROPS));

    // Check State
    Assert(m_pAdrEnum && m_pTransport && pEvent->pMessage);

    // Walk the enumerator for the next recipient
    while (SUCCEEDED(m_pAdrEnum->Next(1, &rAddress, &c)) && c == 1)
    {
        // Get Type
        if (rAddress.pszEmail && ISFLAGSET(IAT_RECIPS, rAddress.dwAdrType))
        {
            // Send the command
            CHECKHR(hr = m_pTransport->CommandRCPT(rAddress.pszEmail));

            // Count Recipients
            pEvent->cRecipients++;

            // Done
            goto exit;
        }

        // Release
        g_pMoleAlloc->FreeAddressProps(&rAddress);
    }

    // Release the Enumerator
    SafeRelease(m_pAdrEnum);

    // No Recipients
    if (0 == pEvent->cRecipients)
    {
        hr = TrapError(IXP_E_SMTP_NO_RECIPIENTS);
        goto exit;
    }

    // Send the Data Command
    CHECKHR(hr = m_pTransport->CommandDATA());

exit:
    // Cleanup
    g_pMoleAlloc->FreeAddressProps(&rAddress);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrSendDataStream
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrSendDataStream(void)
{
    // Locals
    HRESULT                 hr=S_OK;
    LPSTREAM                pStream=NULL;
    LPSTREAM                pStmActual;
    LPSTR                   pszBCC=NULL;
    LPSTR                   pszTo=NULL;
    LPSTR                   pszMessageId=NULL;
    LPSMTPEVENTINFO         pEvent;
    CMessageIdStream       *pStmWrapper=NULL;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Check State
    Assert(m_pTransport && pEvent->pMessage);

    // See if BCC is set
    if (SUCCEEDED(MimeOleGetBodyPropA(pEvent->pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_BCC), NOFLAGS, &pszBCC)))
    {
        // Locals
        LPSTR pszToAppend=NULL;

        // RAID-20750 - If the to line is not set, then we will set it to "Undisclosed Recipient"
        // or the SMTP gateways will put the BCC into the to line.
        if (FAILED(MimeOleGetBodyPropA(pEvent->pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, &pszTo)))
        {
            // Raid-9691: We were just putting <Undiscolsed Recipient>, which was an illegal email address (bad for Exchange Server)
            pszToAppend = "To: <Undisclosed-Recipient:;>\r\n";
        }

        // Raid-2705: If this fails, just get the message source
        if (FAILED(MimeOleStripHeaders(pEvent->pMessage, HBODY_ROOT, STR_HDR_BCC, pszToAppend, &pStream)))
        {
            // Get Message Stream
            CHECKHR(hr = pEvent->pMessage->GetMessageSource(&pStream, 0));
        }
    }

    // Otherwise, just get the message source
    else
    {
        // Get Message Stream
        CHECKHR(hr = pEvent->pMessage->GetMessageSource(&pStream, 0));
    }

    // Lets see if the message has a message-id already
    if (FAILED(MimeOleGetBodyPropA(pEvent->pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pszMessageId)))
    {
        // Create a wrapper for this stream that will output the messageid
        CHECKALLOC(pStmWrapper = new CMessageIdStream(pStream));

        // Adjust pEvent->cbEvent
        pEvent->cbEvent += pStmWrapper->CchMessageId();

        // Increment total
        m_cbTotal += pStmWrapper->CchMessageId();

        // Increment pEvent->cbSentTotal
        pEvent->cbSentTotal += pStmWrapper->CchMessageId();

        // Reset pStream
        pStmActual = (IStream *)pStmWrapper;
    }
    else
        pStmActual = pStream;

    // Send the stream
    CHECKHR(hr = m_pTransport->SendDataStream(pStmActual, pEvent->cbEvent));

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pStmWrapper);
    SafeMemFree(pszBCC);
    SafeMemFree(pszTo);
    SafeMemFree(pszMessageId);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_OnStreamProgress
// --------------------------------------------------------------------------------
void CSmtpTask::_OnStreamProgress(LPSMTPSTREAM pInfo)
{
    // Locals
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Increment Status
    pEvent->cbEventSent += pInfo->cbIncrement;
    Assert(pEvent->cbEventSent == pInfo->cbCurrent);

    // Increment total sent
    m_cbSent += pInfo->cbIncrement;

    // Do Progress
    _DoProgress();
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrFinishCurrentEvent
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrFinishCurrentEvent(HRESULT hrResult)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Save the Event Result
    pEvent->hrResult = hrResult;

    // If the Event Failed...
    if (FAILED(pEvent->hrResult))
    {
        // If this message was part of a split group, skip all pars in this group
        if (ISFLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART))
        {
            // Compute Next Event
            ULONG iNextEvent = m_rTable.iEvent + (pEvent->cParts - pEvent->iPart) + 1;

            // Increment to last part
            while(m_rTable.iEvent < iNextEvent && m_rTable.iEvent < m_rTable.cEvents)
            {
                // Goto next event
                m_rTable.iEvent++;

                // Fail this event
                _CatchResult(SP_E_SENDINGSPLITGROUP, IXP_SMTP);

                // Fixup m_cbSent to be correct
                m_cbSent = m_rTable.prgEvent[m_rTable.iEvent].cbSentTotal;

                // Update progress
                _DoProgress();
            }
        }
    }

    // Otherwise
    else
    {
        // Mark the event as complete
        FLAGSET(pEvent->dwFlags, SMTPEVENT_COMPLETE);

        // Increment number of completed events
        m_rTable.cCompleted++;
    }

    // Go to next message
    CHECKHR(hr = _HrStartNextEvent());

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrStartNextEvent
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrStartNextEvent(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Fixup m_cbSent to be correct
    m_cbSent = m_rTable.prgEvent[m_rTable.iEvent].cbSentTotal;

    // Are we done yet ?
    if (m_rTable.iEvent + 1 == m_rTable.cEvents)
    {
        // Update progress
        _DoProgress();

        // Disconnect from the server
        CHECKHR(hr = m_pTransport->Disconnect());
    }

    // Oterhwise, Increment Event and send rset
    else
    {
        // Next Event
        m_rTable.iEvent++;

        // Update progress
        _DoProgress();

        // Send Reset Command
        CHECKHR(hr = m_pTransport->CommandRSET());
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_OnDisconnectComplete
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_OnDisconnectComplete(void)
{
    // Locals
    HRESULT             hr=S_OK;
    PDWORD_PTR          prgdwIds=NULL;
    DWORD               cIds=0;
    DWORD               cIdsAlloc=0;
    DWORD               i;
    LPSMTPEVENTINFO     pEvent;
    ADJUSTFLAGS         Flags;

    // Invalid State
    Assert(m_pOutbox);

    // Walk through the list of events
    for (i=0; i<m_rTable.cEvents; i++)
    {
        // Readability
        pEvent = &m_rTable.prgEvent[i];

        // If this event was in the outbox
        if (0 != pEvent->idMessage && ISFLAGSET(pEvent->dwFlags, SMTPEVENT_COMPLETE))
        {
            // Insert into my array of message ids
            if (cIds + 1 > cIdsAlloc)
            {
                // Realloc
                CHECKHR(hr = HrRealloc((LPVOID *)&prgdwIds, sizeof(DWORD) * (cIdsAlloc + 10)));

                // Increment cIdsAlloc
                cIdsAlloc += 10;
            }

            // Set Message Id
            prgdwIds[cIds++] = (DWORD_PTR)pEvent->idMessage;
        }
    }

    // Setup List
    m_rList.cMsgs = cIds;
    m_rList.prgidMsg = (LPMESSAGEID)prgdwIds;
    prgdwIds = NULL;

    if (m_rList.cMsgs)
    {
        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;

        if (m_idEventUpload == INVALID_EVENT)
        {
            if (DwGetOption(OPT_SAVESENTMSGS))
            {
                Assert(m_pSentItems != NULL);

                // Move the message from the sent items folder
                CHECKHR(hr = m_pOutbox->CopyMessages(m_pSentItems, COPY_MESSAGE_MOVE, &m_rList, &Flags, NULL, NOSTORECALLBACK));
            }
            else
            {
                // Delete the messages
                CHECKHR(hr = m_pOutbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &m_rList, NULL, NOSTORECALLBACK));
            }
        }
        else
        {
            // Raid-7639: OE sends message over and over when runs out of disk space.
            m_pOutbox->SetMessageFlags(&m_rList, &Flags, NULL, NOSTORECALLBACK);
        }
    }

exit:
    // Cleanup
    SafeMemFree(prgdwIds);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CSmtpTask::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::Cancel(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Cancelled
    FLAGSET(m_dwState, SMTPSTATE_CANCELED);

    // Simply drop the connection
    if (m_pTransport)
        m_pTransport->DropConnection();

    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_ABORT);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnTimeoutResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Should have a handle to the timeout window
    Assert(m_hwndTimeout);

    // No timeout window handle
    m_hwndTimeout = NULL;

    // Stop ?
    if (TIMEOUT_RESPONSE_STOP == eResponse)
    {
        // Cancelled
        FLAGSET(m_dwState, SMTPSTATE_CANCELED);

        // Report error and drop connection
        _CatchResult(IXP_E_TIMEOUT, IXP_SMTP);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::IsDialogMessage(LPMSG pMsg)
{
    HRESULT hr=S_FALSE;
    EnterCriticalSection(&m_cs);
    if (m_hwndTimeout && IsWindow(m_hwndTimeout))
        hr = (TRUE == ::IsDialogMessage(m_hwndTimeout, pMsg)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnFlagsChanged
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnFlagsChanged(DWORD dwFlags)
    {
    EnterCriticalSection(&m_cs);
    m_dwFlags = dwFlags;
    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }

STDMETHODIMP CSmtpTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    // Hold onto this
    Assert(m_tyOperation == SOT_INVALID);

    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }
    m_tyOperation = tyOperation;

    // Set the animation
    m_pUI->SetAnimation(idanOutbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    m_wProgress = 0;

    LOADSTRING(IDS_SPS_MOVEPROGRESS, szRes);
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, 1, m_rList.cMsgs);

    m_pUI->SetSpecificProgress(szBuf);

    // Party On
    return(S_OK);
}

STDMETHODIMP CSmtpTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    WORD wProgress, wDelta;

    // NOTE: that you can get more than one type of value for tyOperation.
    //       Most likely, you will get SOT_CONNECTION_STATUS and then the
    //       operation that you might expect. See HotStore.idl and look for
    //       the STOREOPERATION enumeration type for more info.
 
    if (tyOperation == SOT_CONNECTION_STATUS)
    {
        // Connecting to ...
        LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_rServer.szAccount);
        m_pUI->SetGeneralProgress(szBuf);
    }
    else if (tyOperation == SOT_COPYMOVE_MESSAGE)
    {
        // Compute Current Progress Index
        wProgress = (WORD)((dwCurrent * 100) / dwMax);

        // Compute Delta
        wDelta = wProgress - m_wProgress;

        // Progress Delta
        if (wDelta > 0)
        {
            // Incremenet Progress
            m_pUI->IncrementProgress(wDelta);

            // Increment my wProgress
            m_wProgress += wDelta;

            // Don't go over 100 percent
            Assert(m_wProgress <= 100);
        }

        if (dwCurrent < dwMax)
        {
            LOADSTRING(IDS_SPS_MOVEPROGRESS, szRes);
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, dwCurrent + 1, dwMax);

            // Set Specific Progress
            m_pUI->SetSpecificProgress(szBuf);
        }
    }

    // Done
    return(S_OK);
}

STDMETHODIMP CSmtpTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Is there currently a timeout dialog
    if (m_hwndTimeout)
    {
        // Set foreground
        SetForegroundWindow(m_hwndTimeout);
    }
    else
    {
        LPCSTR pszProtocol;

        // Not suppose to be showing UI ?
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            return(S_FALSE);

        // Do Timeout Dialog
        GetProtocolString(&pszProtocol, ixpServerType);
        if (pServer)
        {
            m_hwndTimeout = TaskUtil_HwndOnTimeout(pServer->szServerName, pServer->szAccount,
                pszProtocol, pServer->dwTimeout, (ITimeoutCallback *) this);

            // Couldn't create the dialog
            if (NULL == m_hwndTimeout)
                return(S_FALSE);
        }
    }

    return(S_OK);
}

STDMETHODIMP CSmtpTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;

    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}

STDMETHODIMP CSmtpTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    if (m_hwndTimeout)
    {
        DestroyWindow(m_hwndTimeout);
        m_hwndTimeout = NULL;
    }

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

STDMETHODIMP CSmtpTask::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete,
                                   LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    HRESULT hr;
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES * 2], szSubject[64];
    EVENTCOMPLETEDSTATUS tyEventStatus;

    if (m_hwndTimeout)
    {
        DestroyWindow(m_hwndTimeout);
        m_hwndTimeout = NULL;
    }

    IxpAssert(m_tyOperation != SOT_INVALID);
    if (m_tyOperation != tyOperation)
        return(S_OK);

    Assert(tyOperation == SOT_COPYMOVE_MESSAGE);

    // Figure out if we succeeded or failed
    if (FAILED(hrComplete))
    {
        Assert(m_pUI);

        if (NULL != pErrorInfo)
        {
            IXPRESULT   ixpResult;
            INETSERVER  rServer;
            char        szProblem[CCHMAX_STRINGRES];
            int         iLen;

            // Prepend sent items text error text to supplied problem
            Assert(tyOperation == SOT_COPYMOVE_MESSAGE);
            iLen = LoadString(g_hLocRes, IDS_SP_E_CANT_MOVETO_SENTITEMS, szProblem, sizeof(szProblem));
            if (iLen < sizeof(szProblem) - 1)
            {
                szProblem[iLen] = ' ';
                iLen += 1;
                szProblem[iLen] = '\0';
            }
            if (NULL != pErrorInfo->pszProblem)
                StrCpyN(szProblem + iLen, pErrorInfo->pszProblem, ARRAYSIZE(szProblem) - iLen);

            TaskUtil_SplitStoreError(&ixpResult, &rServer, pErrorInfo);
            ixpResult.pszProblem = szProblem;

            _CatchResult(&ixpResult, &rServer, pErrorInfo->ixpType);
        }
        else
        {
            // Remap the Error Result
            hr = TrapError(SP_E_CANT_MOVETO_SENTITEMS);

            // Show an error in the spooler dialog
            _CatchResult(hr, IXP_IMAP); // Without a STOREERROR, we just have to guess
        }
    }

    m_pUI->SetAnimation(idanOutbox, FALSE);

    if (ISFLAGSET(m_dwState, SMTPSTATE_CANCELED))
        tyEventStatus = EVENT_CANCELED;
    else if (SUCCEEDED(hrComplete))
        tyEventStatus = EVENT_SUCCEEDED;
    else
        tyEventStatus = EVENT_FAILED;

    // Result
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

    // Result
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

    m_pSpoolCtx->EventDone(m_idEventUpload, tyEventStatus);

    // Release your cancel object
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;

    // Done
    return(S_OK);
}

STDMETHODIMP CSmtpTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    if (m_hwndTimeout)
    {
        DestroyWindow(m_hwndTimeout);
        m_hwndTimeout = NULL;
    }

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\smtptask.h ===
// --------------------------------------------------------------------------------
// Smtptask.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __SMTPTASK_H
#define __SMTPTASK_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnxport.h"
#include "taskutil.h"
#include "storutil.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagMAILMSGHDR *LPMAILMSGHDR;
interface ILogFile;
interface IMimeMessage;
interface IMimeEnumAddressTypes;

// --------------------------------------------------------------------------------
// State
// --------------------------------------------------------------------------------
#define SMTPSTATE_CANCELED      FLAG01
#define SMTPSTATE_DEFAULT       FLAG02
#define SMTPSTATE_ASKEDDEFAULT  FLAG03
#define SMTPSTATE_USEDEFAULT    FLAG04
#define SMTPSTATE_EXECUTEFAILED FLAG05


// --------------------------------------------------------------------------------
// SMTPTASKEVENT_xxx Flags
// --------------------------------------------------------------------------------
#define SMTPEVENT_SPLITPART     FLAG01          // Sending a split part
#define SMTPEVENT_COMPLETE      FLAG02          // The event was completed

// --------------------------------------------------------------------------------
// SMTPEVENTINFO
// --------------------------------------------------------------------------------
typedef struct tagSMTPEVENTINFO {
    DWORD               dwFlags;                // Flags
    MESSAGEID           idMessage;              // Store Information
    DWORD               cbEvent;                // Size of the message
    DWORD               cbEventSent;            // Size of the message
    DWORD               cbSentTotal;            // Where m_cbSent should be after this
    DWORD               cRecipients;            // Recipient
    IMimeMessage       *pMessage;               // Message to send
    DWORD               iPart;                  // Part dwPart of cTotalParts
    DWORD               cParts;                 // Part dwPart of cTotalParts
    DWORD               cbParts;                // Number of bytes of original message
    HRESULT             hrResult;               // Result of this event
} SMTPEVENTINFO, *LPSMTPEVENTINFO;

// --------------------------------------------------------------------------------
// SMTPEVENTTABLE
// --------------------------------------------------------------------------------
typedef struct tagSMTPEVENTTABLE {
    DWORD               iEvent;                 // Current Event
    DWORD               cCompleted;             // Number of events completed
    DWORD               cEvents;                // Number of events in prgEvent
    DWORD               cAlloc;                 // Number of items allocated in prgEvent
    LPSMTPEVENTINFO     prgEvent;               // Array of events
} SMTPEVENTTABLE, *LPSMTPEVENTTABLE;

// --------------------------------------------------------------------------------
// CSmtpTask
// --------------------------------------------------------------------------------
class CSmtpTask : public ISpoolerTask, 
                  public ISMTPCallback, 
                  public ITimeoutCallback,
                  public ITransportCallbackService,
                  public IStoreCallback
{
public:
    // ----------------------------------------------------------------------------
    // CSmtpTask
    // ----------------------------------------------------------------------------
    CSmtpTask(void);
    ~CSmtpTask(void);
    
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // ---------------------------------------------------------------------------
    // ISpoolerTask
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP Cancel(void);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);
    
    // --------------------------------------------------------------------------------
    // ITransportCallbackService Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) {
        TraceCall("CSmtpTask::GetParentWindow");
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            return TraceResult(E_FAIL);
        if (m_pUI)
            return m_pUI->GetWindow(phwndParent);
        return TraceResult(E_FAIL);
    }

    STDMETHODIMP GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount) {
        Assert(ppAccount && m_pAccount);
        *pdwServerType = SRV_SMTP;
        *ppAccount = m_pAccount;
        (*ppAccount)->AddRef();
        return(S_OK);
    }
    
    // --------------------------------------------------------------------------------
    // ITransportCallback Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport);
    STDMETHODIMP_(INT) OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    STDMETHODIMP OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport);
    STDMETHODIMP OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    STDMETHODIMP OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);
    
    // --------------------------------------------------------------------------------
    // ISMTPCallback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnResponse(LPSMTPRESPONSE pResponse);
    
    // --------------------------------------------------------------------------------
    // ITimeoutCallback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);
    
    // --------------------------------------------------------------------------------
    // IStoreCallback Interface
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    HRESULT _HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pMsgInfo, BOOL fSplitMsgs, DWORD cbMaxPart);
    HRESULT _HrAppendEventTable(LPSMTPEVENTINFO *ppEvent);
    HRESULT _HrAppendSplitMessage(LPMESSAGEINFO pMsgInfo, DWORD cbMaxPart);
    HRESULT _HrOpenMessage(MESSAGEID dwMsgId, IMimeMessage **ppMessage);
    HRESULT _ExecuteSMTP(EVENTID eid, DWORD_PTR dwTwinkie);
    HRESULT _ExecuteUpload(EVENTID eid, DWORD_PTR dwTwinkie);
    void _FreeEventTableElements(void);
    void _ResetObject(BOOL fDeconstruct);
    
    // ---------------------------------------------------------------------------
    // Error / Progress Methods
    // ---------------------------------------------------------------------------
    TASKRESULTTYPE _CatchResult(LPIXPRESULT pResult, INETSERVER *pServer, IXPTYPE ixpType);
    TASKRESULTTYPE _CatchResult(HRESULT hrResult, IXPTYPE ixpType);
    void _DoProgress(void);
    
    // ---------------------------------------------------------------------------
    // Event State Methods
    // ---------------------------------------------------------------------------
    HRESULT _HrStartCurrentEvent(void);
    HRESULT _HrCommandMAIL(void);
    HRESULT _HrCommandRCPT(void);
    HRESULT _HrSendDataStream(void);
    HRESULT _HrFinishCurrentEvent(HRESULT hrResult);
    HRESULT _HrStartNextEvent(void);
    HRESULT _HrOnConnected(void);
    HRESULT _OnDisconnectComplete(void);
    void _OnStreamProgress(LPSMTPSTREAM pInfo);
    
private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    DWORD                   m_cRef;              // Reference Coutning
    INETSERVER              m_rServer;           // Server information
    DWORD                   m_dwFlags;           // DELIVER_xxx flags
    ISpoolerBindContext    *m_pSpoolCtx;         // Spooler bind contexting
    IImnAccount            *m_pAccount;          // Internet Account
    ISMTPTransport         *m_pTransport;        // SMTP transport    
    IMessageFolder         *m_pOutbox;           // The outbox
    IMessageFolder         *m_pSentItems;
    SMTPEVENTTABLE          m_rTable;            // Event Table
    DWORD                   m_cbTotal;           // Total number of bytes to send
    DWORD                   m_cbSent;            // Total number of bytes to send
    WORD                    m_wProgress;         // Current progress index
    EVENTID                 m_idEvent;           // EventId for SMTP message send
    EVENTID                 m_idEventUpload;     // EventId for SMTP message send
    ISpoolerUI             *m_pUI;               // SpoolerUI
    DWORD                   m_dwState;           // State
    IMimeEnumAddressTypes  *m_pAdrEnum;          // Address Enumerator
    HWND                    m_hwndTimeout;       // Handle to timeout window
    ILogFile               *m_pLogFile;          // Logfile
    CRITICAL_SECTION        m_cs;                // Thread Safety

    // Callback 
    MESSAGEIDLIST           m_rList;
    IOperationCancel       *m_pCancel;
    STOREOPERATIONTYPE      m_tyOperation;    
};

// --------------------------------------------------------------------------------
// CMessageIdStream
// --------------------------------------------------------------------------------
class CMessageIdStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CMessageIdStream(IStream *pStream);
    ~CMessageIdStream(void) { m_pStream->Release(); }
    
    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP_(ULONG) AddRef(void) { return ++m_cRef; }
    STDMETHODIMP_(ULONG) Release(void) {
        if (0 != --m_cRef)
            return m_cRef;
        delete this;
        return 0;
    }
    
    // -------------------------------------------------------------------------
    // IStream Not implemented Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP Stat(STATSTG *, DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Write(const void *, ULONG, ULONG *)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP SetSize(ULARGE_INTEGER) { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Revert(void)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *)  { Assert(FALSE); return E_NOTIMPL; }
    
    STDMETHODIMP Read(LPVOID pv, ULONG cbWanted, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew);
    
    // -------------------------------------------------------------------------
    // CMessageIdStream - Returns the length of the messageid
    // -------------------------------------------------------------------------
    ULONG CchMessageId(void) { return m_cchMessageId; }
    
private:
    IStream             *m_pStream;
    CHAR                 m_szMessageId[512];
    ULONG                m_cchMessageId;
    ULONG                m_cbIndex;
    ULONG                m_cRef;
};

#endif // __SMTPTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\pop3task.h ===
// --------------------------------------------------------------------------------
// Pop3task.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __POP3TASK_H
#define __POP3TASK_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnxport.h"
#include "oerules.h"
#include "taskutil.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
interface ILogFile;

// --------------------------------------------------------------------------------
// POP3EVENT_xxx Types
// --------------------------------------------------------------------------------
typedef enum tagPOP3EVENTTYPE {
    POP3EVENT_CHECKMAIL,
    POP3EVENT_DOWNLOADMAIL,
    POP3EVENT_CLEANUP
} POP3EVENTTYPE;

// --------------------------------------------------------------------------------
// POP3STATE_xxxx
// --------------------------------------------------------------------------------
#define POP3STATE_LEAVEONSERVER     FLAG01      // Leave on server
#define POP3STATE_DELETEEXPIRED     FLAG02      // Delete expired messages
#define POP3STATE_SYNCDELETED       FLAG03      // Synchronized deleted items
#define POP3STATE_CLEANUPCACHE      FLAG04      // Cleanup cache when done
#define POP3STATE_GETUIDLS          FLAG05      // Get uidls for all messages
#define POP3STATE_PDR               FLAG06      // Pre-download rules
#define POP3STATE_PDRSIZEONLY       FLAG07      // Pre-download rules by size only
#define POP3STATE_NOPOSTRULES       FLAG08      // No post download rules
#define POP3STATE_CANCELPENDING     FLAG09      // There is a pending cacel
#define POP3STATE_ONDISCONNECT      FLAG10      // OnStatus(IXP_DISCONNECT) was called
#define POP3STATE_LOGONSUCCESS      FLAG11      // Logon was successful
#define POP3STATE_EXECUTEFAILED     FLAG12
#define POP3STATE_BODYRULES         FLAG13

// --------------------------------------------------------------------------------
// POP3ITEM_xxx Flags
// --------------------------------------------------------------------------------
#define POP3ITEM_DELETEOFFSERVER    FLAG01
#define POP3ITEM_DELETED            FLAG02
#define POP3ITEM_DELETECACHEDUIDL   FLAG03
#define POP3ITEM_CACHEUIDL          FLAG04
#define POP3ITEM_DOWNLOAD           FLAG05
#define POP3ITEM_DOWNLOADSUCCESS    FLAG06
#define POP3ITEM_CHECKEDINBOXRULE   FLAG07
#define POP3ITEM_HASINBOXRULE       FLAG08
#define POP3ITEM_DESTINATIONKNOWN   FLAG09
#define POP3ITEM_DOWNLOADED         FLAG10
#define POP3ITEM_DELEBYRULE         FLAG11
#define POP3ITEM_LEFTBYRULE         FLAG12

// --------------------------------------------------------------------------------
// POP3UIDLSUPPORT
// --------------------------------------------------------------------------------
typedef enum tagPOP3UIDLSUPPORT {
    UIDL_SUPPORT_NONE,
    UIDL_SUPPORT_TESTING_UIDL_COMMAND,
    UIDL_SUPPORT_USE_UIDL_COMMAND,
    UIDL_SUPPORT_TESTING_TOP_COMMAND,
    UIDL_SUPPORT_USE_TOP_COMMAND
} POP3UIDLSUPPORT;

// --------------------------------------------------------------------------------
// POP3STATE
// --------------------------------------------------------------------------------
typedef enum tagPOP3STATE {
    POP3STATE_NONE,
    POP3STATE_GETTINGUIDLS,
    POP3STATE_DOWNLOADING,
    POP3STATE_DELETING,
    POP3STATE_UIDLSYNC
} POP3STATE;

// --------------------------------------------------------------------------------
// POP3METRICS
// --------------------------------------------------------------------------------
typedef struct tagPOP3METRICS {
    DWORD               cbTotal;                // Total number of bytes on the server
    DWORD               cDownload;              // Number of messages to download
    DWORD               cbDownload;             // Number of bytes to download
    DWORD               cDelete;                // Number of messages to delete
    DWORD               cLeftByRule;            // Count of messages left on server due to inbox rule
    DWORD               cDeleByRule;            // Count of messages dele on server due to inbox rule
    DWORD               cTopMsgs;               // Server Side Rules
    DWORD               iCurrent;               // Current message number being downloaded
    DWORD               cDownloaded;            // Number of messages downloaded
    DWORD               cInfiniteLoopAutoGens;  // Number of auto-forward/replys rejected because of loop
    DWORD               cPartials;              // Number of Partial Seen for the download
} POP3METRICS, *LPPOP3METRICS;

// --------------------------------------------------------------------------------
// MSGPART
// --------------------------------------------------------------------------------
typedef struct tagMSGPART {
    WORD                iPart;
    MESSAGEID           msgid;
} MSGPART, *LPMSGPART;

// --------------------------------------------------------------------------------
// PARTIALMSG
// --------------------------------------------------------------------------------
typedef struct tagPARTIALMSG {
    TCHAR               szAccount[CCHMAX_ACCOUNT_NAME];
    LPSTR               pszId;
    WORD                cTotalParts;
    ULONG               cAlloc;
    ULONG               cMsgParts;
    LPMSGPART           pMsgParts;
} PARTIALMSG, *LPPARTIALMSG;

// --------------------------------------------------------------------------------
// POP3FOLDERINFO
// --------------------------------------------------------------------------------
typedef struct tagPOP3FOLDERINFO {
    IMessageFolder     *pFolder;                // Current Folder
    IStream            *pStream;                // Stream in which current message is going to must call EndMessageStreamIn...
    FILEADDRESS         faStream;               // Stream we created
    BOOL                fCommitted;             // Has the stream been comitted
} POP3FOLDERINFO, *LPPOP3FOLDERINFO;

// --------------------------------------------------------------------------------
// POP3ITEMINFO
// --------------------------------------------------------------------------------
typedef struct tagPOP3ITEM {
    DWORD               dwFlags;                // POP3ITEM_xxx Flags
    DWORD               cbSize;                 // Size of this item
    DWORD               dwProgressCur;          // Used to maintain perfect progress
    LPSTR               pszUidl;                // UIDL of this item
    ACT_ITEM *          pActList;               // Inbox Rule Actions that should be applied
    ULONG               cActList;
} POP3ITEM, *LPPOP3ITEM;

// --------------------------------------------------------------------------------
// POP3ITEMTABLE
// --------------------------------------------------------------------------------
typedef struct tagPOP3ITEMTABLE {
    DWORD               cItems;                 // Number of events in prgEvent
    DWORD               cAlloc;                 // Number of items allocated in prgEvent
    LPPOP3ITEM          prgItem;                // Array of events
} POP3ITEMTABLE, *LPPOP3ITEMTABLE;

// ------------------------------------------------------------------------------------
// New Mail Sound
// ------------------------------------------------------------------------------------
typedef BOOL (WINAPI * PFNSNDPLAYSOUND)(LPTSTR szSoundName, UINT fuOptions);

// --------------------------------------------------------------------------------
// SMARTLOGINFO
// --------------------------------------------------------------------------------
typedef struct tagSMARTLOGINFO {
    LPSTR               pszAccount;             // Account to log
    LPSTR               pszProperty;            // Property to query
    LPSTR               pszValue;               // Value to query for
    LPSTR               pszLogFile;             // Logfile to write from and CC to...
    IStream            *pStmFile;               // Stream to the file
} SMARTLOGINFO, *LPSMARTLOGINFO;

// --------------------------------------------------------------------------------
// CPop3Task
// --------------------------------------------------------------------------------
class CPop3Task : public ISpoolerTask, 
                  public IPOP3Callback, 
                  public ITimeoutCallback,
                  public ITransportCallbackService
{
public:
    // ----------------------------------------------------------------------------
    // CSmtpTask
    // ----------------------------------------------------------------------------
    CPop3Task(void);
    ~CPop3Task(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // ISpoolerTask
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP Cancel(void);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);

    // --------------------------------------------------------------------------------
    // ITransportCallbackService Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) {
        TraceCall("CPop3Task::GetParentWindow");
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            return TraceResult(E_FAIL);
        if (m_pUI)
            return m_pUI->GetWindow(phwndParent);
        return TraceResult(E_FAIL);
    }

    STDMETHODIMP GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount) {
        Assert(ppAccount && m_pAccount);
        *pdwServerType = SRV_POP3;
        *ppAccount = m_pAccount;
        (*ppAccount)->AddRef();
        return(S_OK);
    }

    // --------------------------------------------------------------------------------
    // ITransportCallback Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport);
    STDMETHODIMP_(INT) OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    STDMETHODIMP OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport);
    STDMETHODIMP OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    STDMETHODIMP OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);

    // --------------------------------------------------------------------------------
    // IPOP3Callback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnResponse(LPPOP3RESPONSE pResponse);

    // --------------------------------------------------------------------------------
    // ITimeoutCallback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    TASKRESULTTYPE _CatchResult(HRESULT hr);
    TASKRESULTTYPE _CatchResult(POP3COMMAND command, LPIXPRESULT pResult);
    HRESULT _HrLockUidlCache(void);
    HRESULT _HrOnStatResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrOnListResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrOnUidlResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrStartDownloading(void);
    HRESULT _HrOnTopResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrNextTopForInboxRule(DWORD dwPopIdCurrent);
    HRESULT _HrGetUidlFromHeaderStream(IStream *pStream, LPSTR *ppszUidl, IMimePropertySet **ppHeader);
    HRESULT _HrRetrieveNextMessage(DWORD dwPopIdCurrent);
    HRESULT _HrDeleteNextMessage(DWORD dwPopIdCurrent);
    HRESULT _HrOnRetrResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrFinishMessageDownload(DWORD dwPopId);
    HRESULT _HrStartDeleteCycle(void);
    HRESULT _HrOpenFolder(IMessageFolder *pFolder);
    HRESULT _HrStartServerSideRules(void);
    HRESULT _HrStitchPartials(void);
    HRESULT _HrBuildFolderPartialMsgs(IMessageFolder *pFolder, LPPARTIALMSG *ppPartialMsgs, ULONG *pcPartialMsgs, ULONG *pcTotalParts);
    BOOL _FUidlExpired(LPUIDLRECORD pUidlInfo);
    void _QSortMsgParts(LPMSGPART pMsgParts, LONG left, LONG right);
    void _CleanupUidlCache(void);
    void _DoPostDownloadActions(LPPOP3ITEM pItem, MESSAGEID idMessage, IMessageFolder *pFolder, IMimeMessage *pMessage, BOOL *pfDeleteOffServer);
    void _CloseFolder(void);
    void _ComputeItemInboxRule(LPPOP3ITEM pItem, LPSTREAM pStream, IMimePropertySet *pHeaderIn, IMimeMessage * pIMMsg, BOOL fServerRules);
    void _GetItemFlagsFromUidl(LPPOP3ITEM pItem);
    void _DoProgress(void);
    void _ResetObject(BOOL fDeconstruct);
    void _FreeItemTableElements(void);
    void _OnKnownRuleActions(LPPOP3ITEM pItem, ACT_ITEM * pActions, ULONG cActions, BOOL fServerRules);
    void _FreePartialMsgs(LPPARTIALMSG pPartialMsgs, ULONG cPartialMsgs);
    void _ReleaseFolderObjects(void);
    HRESULT _HrDoUidlSynchronize(void);
    void _FreeSmartLog(void);
    HRESULT _InitializeSmartLog(void);
    void _DoSmartLog(IMimeMessage *pMessage);
    HRESULT _ReadSmartLogEntry(HKEY hKey, LPCSTR pszKey, LPSTR *ppszValue);
    HRESULT _GetMoveFolder(LPPOP3ITEM pItem, IMessageFolder ** ppFolder);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    DWORD                   m_cRef;              // Reference Coutning
    INETSERVER              m_rServer;           // Server information
    DWORD                   m_dwFlags;           // DELIVER_xxx flags
    ISpoolerBindContext    *m_pSpoolCtx;         // Spooler bind contexting
    IImnAccount            *m_pAccount;          // Internet Account
    IPOP3Transport         *m_pTransport;        // SMTP transport    
    POP3ITEMTABLE           m_rTable;            // Item Table
    ISpoolerUI             *m_pUI;               // SpoolerUI
    IMessageFolder         *m_pInbox;            // The Inbox
    IMessageFolder         *m_pOutbox;           // The Inbox
    IOEExecRules           *m_pIExecRules;       // Inbox Rules
    IOERule                *m_pIRuleSender;      // Block Sender Rule
    IOERule                *m_pIRuleJunk;        // Junk Mail Rule
    IDatabase              *m_pUidlCache;        // POP3 uidl Cache
    DWORD                   m_dwState;           // State
    POP3UIDLSUPPORT         m_uidlsupport;       // How does the server support uidl
    DWORD                   m_dwExpireDays;      // Used with option POP3STATE_DELETEEXPIRED
    EVENTID                 m_eidEvent;          // Current Event Ids        
    DWORD                   m_dwProgressMax;     // Max Progress
    DWORD                   m_dwProgressCur;     // Current Progress
    WORD                    m_wProgress;         // Percentage progress
    HRESULT                 m_hrResult;          // Event Result
    IStream                *m_pStream;           // Temporary Stream object
    POP3STATE               m_state;             // Current State
    POP3METRICS             m_rMetrics;          // Poll/Download Metrics
    POP3FOLDERINFO          m_rFolder;           // Current foldering being written to
    HWND                    m_hwndTimeout;       // Timeout Prompt
    ILogFile               *m_pLogFile;          // LogFile
    LPSMARTLOGINFO          m_pSmartLog;         // Smart logging information
    CHAR                    m_szAccountId[CCHMAX_ACCOUNT_NAME];
    CRITICAL_SECTION        m_cs;                // Thread Safety
};

#endif // __POP3TASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\spengine.h ===
// --------------------------------------------------------------------------------
// Spengine.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __SPENGINE_H
#define __SPENGINE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnact.h"
#include "conman.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
interface ILogFile;
interface IImnAccountManager;

// --------------------------------------------------------------------------------
// Spooler State
// --------------------------------------------------------------------------------
#define SPSTATE_INIT            FLAG01      // The spooler has been initialized
#define SPSTATE_BUSY            FLAG02      // The spooler is currently working
#define SPSTATE_CANCEL          FLAG03      // The user hit stop
#define SPSTATE_SHUTDOWN        FLAG04      // The spooler is shutting down
#define SPSTATE_UISHUTDOWN      FLAG05      // ::UIShutdown

// ------------------------------------------------------------------------------------
// NOTIFYTABLE
// ------------------------------------------------------------------------------------
typedef struct tagNOTIFYTABLE {
    ULONG               cAlloc;             // Number of array items allocated
    ULONG               cNotify;            // Number of registered views
    HWND               *prghwndNotify;      // Array of view who want notifications
} NOTIFYTABLE, *LPNOTIFYTABLE;

// ------------------------------------------------------------------------------------
// SPOOLERACCOUNT
// ------------------------------------------------------------------------------------
typedef struct tagSPOOLERACCOUNT {
    CHAR                szConnectoid[CCHMAX_CONNECTOID]; // RAS Connectoid Name
    DWORD               dwSort;             // Inverted Sort Index
    DWORD               dwConnType;         // CONNECTION_TYPE_XXXX (imnact.h)
    DWORD               dwServers;          // Support Server Types on this account
    IImnAccount        *pAccount;           // The Account Object
} SPOOLERACCOUNT, *LPSPOOLERACCOUNT;

// ------------------------------------------------------------------------------------
// ACCOUNTTABLE
// ------------------------------------------------------------------------------------
typedef struct tagACCOUNTTABLE {
    ULONG               cAccounts;          // cRasAccts + cLanAccts
    ULONG               cLanAlloc;          // Number of elements allocated;
    ULONG               cLanAccts;          // Number of valid lan/manual accounts
    ULONG               cRasAlloc;          // Number of elements allocated;
    ULONG               cRasAccts;          // Number of valid lan/manual accounts
    LPSPOOLERACCOUNT    prgLanAcct;         // Array of elements
    LPSPOOLERACCOUNT    prgRasAcct;         // Array of elements
} ACCOUNTTABLE, *LPACCOUNTTABLE;

// ------------------------------------------------------------------------------------
// SPOOLERTASKTYPE
// ------------------------------------------------------------------------------------
typedef enum tagSPOOLERTASKTYPE {
    TASK_POP3,                              // POP3 Task
    TASK_SMTP,                              // SMTP Task
    TASK_NNTP,                              // NNTP Task
    TASK_IMAP                               // IMAP Task
} SPOOLERTASKTYPE;

// ------------------------------------------------------------------------------------
// SPOOLEREVENT
// ------------------------------------------------------------------------------------
typedef struct tagSPOOLEREVENT {
    CHAR                szConnectoid[CCHMAX_CONNECTOID]; // RAS Connectoid Name
    DWORD               dwConnType;         // Connection Type
    IImnAccount        *pAccount;           // Account object for this task
    EVENTID             eid;                // Event ID
    ISpoolerTask       *pSpoolerTask;       // Pointer to Task Object
    DWORD_PTR           dwTwinkie;          // Event extra data
} SPOOLEREVENT, *LPSPOOLEREVENT;

// ------------------------------------------------------------------------------------
// SPOOLEREVENTTABLE
// ------------------------------------------------------------------------------------
typedef struct tagSPOOLEREVENTTABLE {
    DWORD               cEvents;
    DWORD               cSucceeded;
    DWORD               cEventsAlloc;
    LPSPOOLEREVENT      prgEvents;
} SPOOLEREVENTTABLE, *LPSPOOLEREVENTTABLE;

// ------------------------------------------------------------------------------------
// VIEWREGISTER
// ------------------------------------------------------------------------------------
typedef struct tagVIEWREGISTER {
    ULONG               cViewAlloc;     // Number of array items allocated
    HWND               *rghwndView;     // Array of view who want notifications
    ULONG               cView;          // Number of registered views
} VIEWREGISTER, *LPVIEWREGISTER;

#define     ALL_ACCT_SERVERS    0xffffffff

// --------------------------------------------------------------------------------
// CSpoolerEngine
// --------------------------------------------------------------------------------
#ifndef WIN16  // No RAS support in Win16
class CSpoolerEngine : public ISpoolerEngine, ISpoolerBindContext, IConnectionNotify
#else
class CSpoolerEngine : public ISpoolerEngine, ISpoolerBindContext
#endif
{
    friend HRESULT CreateThreadedSpooler(PFNCREATESPOOLERUI pfnCreateUI, ISpoolerEngine **ppSpooler, BOOL fPoll);

public:
    // ----------------------------------------------------------------------------
    // CSpoolerEngine
    // ----------------------------------------------------------------------------
    CSpoolerEngine(void);
    ~CSpoolerEngine(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // ISpoolerEngine members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(ISpoolerUI *pUI, BOOL fPoll);
    STDMETHODIMP StartDelivery(HWND hwnd, LPCSTR pszAcctID, FOLDERID idFolder, DWORD dwFlags);
    STDMETHODIMP Close(void);
    STDMETHODIMP Advise(HWND hwndView, BOOL fRegister);
    STDMETHODIMP UpdateTrayIcon(TRAYICONTYPE type);
    STDMETHODIMP GetThreadInfo(LPDWORD pdwThreadId, HTHREAD* phThread);
    STDMETHODIMP OnStartupFinished(void);

    // ---------------------------------------------------------------------------
    // ISpoolerBindContext members
    // ---------------------------------------------------------------------------
    STDMETHODIMP RegisterEvent(LPCSTR pszDescription, ISpoolerTask *pTask, DWORD_PTR dwTwinkie, 
                               IImnAccount *pAccount, LPEVENTID peid);
    STDMETHODIMP EventDone(EVENTID eid, EVENTCOMPLETEDSTATUS status);
    STDMETHODIMP BindToObject(REFIID riid, void **ppvObject);
    STDMETHODIMP TaskFromEventId(EVENTID eid, ISpoolerTask *ppTask);
    STDMETHODIMP OnWindowMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP Cancel(void);
    STDMETHODIMP Notify(DELIVERYNOTIFYTYPE notify, LPARAM lParam);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP PumpMessages(void);
    STDMETHODIMP UIShutdown(void);
    STDMETHODIMP OnUIChange(BOOL fVisible);
    STDMETHODIMP_(LRESULT) QueryEndSession(WPARAM wParam, LPARAM lParam);

#ifndef WIN16  // No RAS support in Win16
    // ---------------------------------------------------------------------------
    // IConnectionNotify
    // ---------------------------------------------------------------------------
    STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);
#endif //!WIN16


    // ---------------------------------------------------------------------------
    // CSpoolerEngine members
    // ---------------------------------------------------------------------------
    HRESULT Shutdown(void);

private:
    // ---------------------------------------------------------------------------
    // Private Members
    // ---------------------------------------------------------------------------
    HRESULT _HrStartDeliveryActual(DWORD dwFlags);
    HRESULT _HrAppendAccountTable(LPACCOUNTTABLE pTable, LPCSTR pszAcctID, DWORD    dwServers);
    HRESULT _HrAppendAccountTable(LPACCOUNTTABLE pTable, IImnAccount *pAccount, DWORD dwServers);
#ifndef WIN16  // No RAS support in Win16
    void _InsertRasAccounts(LPACCOUNTTABLE pTable, LPCSTR pszConnectoid, DWORD dwSrvTypes);
    void _SortAccountTableByConnName(LONG left, LONG right, LPSPOOLERACCOUNT prgRasAcct);
#endif
    HRESULT _HrCreateTaskObject(LPSPOOLERACCOUNT pSpoolerAcct);
    HRESULT _HrStartNextEvent(void);
    HRESULT _HrGoIdle(void);
    void _ShutdownTasks(void);
    void _DoBackgroundPoll(void);
    void _StartPolling(void);
    void _StopPolling(void);
    HRESULT _HrDoRasConnect(const LPSPOOLEREVENT pEvent);
    HRESULT _OpenMailLogFile(DWORD dwOptionId, LPCSTR pszPrefix, LPCSTR pszFileName, ILogFile **ppLogFile);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    ULONG               m_cRef;                     // Reference count
    DWORD               m_dwThreadId;               // Thread Id of this spooler
    HTHREAD             m_hThread;                  // Handle to my own thread
    ISpoolerUI         *m_pUI;                      // Spooler UI
    DWORD               m_dwState;                  // Spooler Engine State
    IImnAccountManager *m_pAcctMan;                 // The Account Manager
    IDatabase          *m_pUidlCache;               // POP3 uidl Cache
    DWORD               m_dwFlags;                  // Current DELIVERYFLAGS
    HWND                m_hwndUI;                   // Spooler Window
    LPSTR               m_pszAcctID;                // Work on a specific account
    FOLDERID            m_idFolder;                 // Work on a specific folder or group
    CRITICAL_SECTION    m_cs;                       // Thread Safety
    SPOOLEREVENTTABLE   m_rEventTable;              // Table of events
    BOOL                m_fBackgroundPollPending;
    VIEWREGISTER        m_rViewRegister;            // Registered Views
    DWORD               m_dwPollInterval;           // Duration between background polling
    HWND                m_hwndTray;                 // The tray icon window
    DWORD               m_cCurEvent;                // Index of the currently executing event
    DWORD               m_dwQueued;                 // Queued Polling Flags
    BOOL                m_fRasSpooled;              // Use this for the Hangup when done options
    BOOL                m_fOfflineWhenDone;         // Toggle the Work Offline state after spool
    ILogFile           *m_pPop3LogFile;
    ILogFile           *m_pSmtpLogFile;
    BOOL                m_fIDialed;
    DWORD               m_cSyncEvent;
    BOOL                m_fNoSyncEvent;
};

#endif // __SPENGINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\spengine.cpp ===
// --------------------------------------------------------------------------------
// Spengine.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "spengine.h"
#include "strconst.h"
#include "spoolui.h"
#include "thormsgs.h"
#include "newstask.h"
#include "goptions.h"
#include "conman.h"
#include "resource.h"
#include "ontask.h"
#include "smtptask.h"
#include "pop3task.h"
#include "instance.h"
#include "shlwapip.h" 
#include "ourguid.h"
#include "demand.h"
#include "storutil.h"
#include "msgfldr.h"
#include "httptask.h"
#include "watchtsk.h"
#include "shared.h"
#include "util.h"

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
BOOL g_fCheckOutboxOnShutdown=FALSE;

extern HANDLE  hSmapiEvent;     // Added for Bug# 62129 (v-snatar)

// --------------------------------------------------------------------------------
// ISSPOOLERTHREAD
// --------------------------------------------------------------------------------
#define ISSPOOLERTHREAD \
    (m_dwThreadId == GetCurrentThreadId())

// --------------------------------------------------------------------------------
// CSpoolerEngine::CSpoolerEngine
// --------------------------------------------------------------------------------
CSpoolerEngine::CSpoolerEngine(void)
    {
    m_cRef = 1;
    m_pUI = NULL;
    m_dwState = 0;
    m_dwFlags = 0;
    m_dwQueued = 0;
    m_pAcctMan = NULL;
    m_pUidlCache = NULL;
    m_hwndUI = NULL;
    m_pszAcctID = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_dwThreadId = GetCurrentThreadId();
    m_hThread = GetCurrentThread();
    ZeroMemory(&m_rViewRegister, sizeof(VIEWREGISTER));
    ZeroMemory(&m_rEventTable, sizeof(SPOOLEREVENTTABLE));
    m_fBackgroundPollPending = FALSE;
    m_dwPollInterval = 0;
    m_cCurEvent = FALSE;
    m_hwndTray = NULL;
    m_fRasSpooled = FALSE;
    m_fOfflineWhenDone = FALSE;
    m_pPop3LogFile = NULL;
    m_pSmtpLogFile = NULL;
    m_fIDialed = FALSE;
    m_cSyncEvent = 0;
    m_fNoSyncEvent = FALSE;
    InitializeCriticalSection(&m_cs);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::~CSpoolerEngine
// --------------------------------------------------------------------------------
CSpoolerEngine::~CSpoolerEngine(void)
    {

    Assert(m_rEventTable.prgEvents == NULL);
    Assert(ISSPOOLERTHREAD);
    if (g_pConMan)
        g_pConMan->Unadvise((IConnectionNotify *) this);
    OptionUnadvise(m_hwndUI);
    SafeRelease(m_pUI);
    SafeRelease(m_pAcctMan);
    SafeRelease(m_pUidlCache);
    SafeRelease(m_pSmtpLogFile);
    SafeRelease(m_pPop3LogFile);
    SafeMemFree(m_pszAcctID);
    ReleaseMem(m_rViewRegister.rghwndView);
    DeleteCriticalSection(&m_cs);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;
    
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerEngine *)this;
    else if (IID_ISpoolerEngine == riid)
        *ppv = (ISpoolerEngine *)this;
    else if (IID_ISpoolerBindContext == riid)
        *ppv = (ISpoolerBindContext *)this;
    else
        {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
        }
    
    // AddRef It
    ((IUnknown *)*ppv)->AddRef();
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSpoolerEngine::AddRef(void)
    {
    EnterCriticalSection(&m_cs);
    ULONG cRef = ++m_cRef;
    LeaveCriticalSection(&m_cs);
    return cRef;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSpoolerEngine::Release(void)
    {
    EnterCriticalSection(&m_cs);
    ULONG cRef = --m_cRef;
    LeaveCriticalSection(&m_cs);
    if (0 != cRef)
        return cRef;
    delete this;
    return 0;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Init(ISpoolerUI *pUI, BOOL fPoll)
    {
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw;


    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Already Inited
    if (m_pAcctMan)
        {
        Assert(FALSE);
        goto exit;
        }
    
    // Create Default Spooler UI Object
    if (NULL == pUI)
        {
        // Create a Serdy UI object
        CHECKALLOC(m_pUI = (ISpoolerUI *)new CSpoolerDlg);
        
        // Create
        CHECKHR(hr = m_pUI->Init(GetDesktopWindow()));
        }
    
    // Otherwise, assume pUI
    else
        {
        m_pUI = pUI;
        m_pUI->AddRef();
        }
    
    // Register SpoolerBindContext with the UI object
    m_pUI->RegisterBindContext((ISpoolerBindContext *)this);
    
    // Get the window handle of the spooler UI
    m_pUI->GetWindow(&m_hwndUI);

    // Get Me An Account Manager
    Assert(NULL == m_pAcctMan);
    CHECKHR(hr = HrCreateAccountManager(&m_pAcctMan));

    // Advise on the connection status
    Assert(g_pConMan);
    g_pConMan->Advise((IConnectionNotify *) this);

exit:

    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }


HRESULT CSpoolerEngine::OnStartupFinished(void)
    {
    DWORD dw;


    // Start Polling...
    dw = DwGetOption(OPT_POLLFORMSGS);
    if (dw != OPTION_OFF)
        SetTimer(m_hwndUI, IMAIL_POOLFORMAIL, dw, NULL);

    // Advise Options
    OptionAdvise(m_hwndUI);

    return (S_OK);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::StartDelivery
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::StartDelivery(HWND hwnd, LPCSTR pszAcctID, FOLDERID idFolder, DWORD dwFlags)
{
    // Locals
    HRESULT  hr=S_OK;

    
    // No Flags
    if (0 == dwFlags || (DELIVER_SHOW != dwFlags && 0 == (dwFlags & ~DELIVER_COMMON_MASK)))
        return TrapError(E_INVALIDARG);

    // Check to see if we're working offline
    Assert(g_pConMan);


    if (DELIVER_SHOW != dwFlags && g_pConMan->IsGlobalOffline())
    {
        if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))
        {
            return (S_OK);
        }
        else
        {
            g_pConMan->SetGlobalOffline(FALSE);
        }
    }
    
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // If were busy...
    if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
    {
        // Don't need this anymore
        SafeMemFree(m_pszAcctID);
    
        // Save the Account Name
        if (pszAcctID)
            CHECKALLOC(m_pszAcctID = PszDupA(pszAcctID));

        // Save the folder ID
        m_idFolder = idFolder;
    
        // Lets enter the busy state
        FLAGSET(m_dwState, SPSTATE_BUSY);                                    
    }
    else
        FLAGSET(dwFlags, DELIVER_REFRESH);

    // Process the outbox
    Assert(m_hwndUI && IsWindow(m_hwndUI));
    PostMessage(m_hwndUI, IMAIL_DELIVERNOW, 0, dwFlags);
    
exit:
    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::_HrStartDeliveryActual
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_HrStartDeliveryActual(DWORD dwFlags)
    {
    // Locals
    HRESULT             hr=S_OK;
    IImnAccount        *pAccount=NULL;
    ACCOUNTTABLE        rTable;
    IImnEnumAccounts   *pEnum=NULL;
    DWORD               dw;
    ULONG               c;
    MSG                 msg;
    ULONG               iConnectoid;
    ULONG               i;
    CHAR                szConnectoid[CCHMAX_CONNECTOID];
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(&rTable, sizeof(ACCOUNTTABLE));

    m_cSyncEvent = 0;
    m_fNoSyncEvent = FALSE;

    // If we are currently busy...
    if (ISFLAGSET(dwFlags, DELIVER_REFRESH))
        {
        // If we are currently with no UI, and new request is for ui
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI) && !ISFLAGSET(dwFlags, DELIVER_NOUI))
            FLAGCLEAR(m_dwFlags, DELIVER_NOUI);

        // If we are currently doing a background poll
        if (ISFLAGSET(m_dwFlags, DELIVER_BACKGROUND) && !ISFLAGSET(dwFlags, DELIVER_BACKGROUND))
            FLAGCLEAR(m_dwFlags, DELIVER_BACKGROUND);

        // If not running with now ui, set to foreground
        if (!ISFLAGSET(m_dwFlags, DELIVER_NOUI) && !ISFLAGSET(m_dwFlags, DELIVER_BACKGROUND))
            {
            m_pUI->ShowWindow(SW_SHOW);
            SetForegroundWindow(m_hwndUI);
            }

        // Should I queue an outbox delivery?
        if (0 == m_dwQueued && ISFLAGSET(dwFlags, DELIVER_QUEUE))
            {
            m_dwQueued = dwFlags;
            FLAGCLEAR(m_dwQueued, DELIVER_REFRESH);
            FLAGCLEAR(m_dwQueued, DELIVER_QUEUE);
            }

        // Done
        goto exit;
        }

    // Simply show the ui ?
    if (ISFLAGSET(dwFlags, DELIVER_SHOW))
        {
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);
        FLAGCLEAR(m_dwState, SPSTATE_BUSY);
        goto exit;
        }

    // Reset
    m_pUI->ClearEvents();
    m_pUI->SetTaskCounts(0, 0);
    m_pUI->StartDelivery();

    // Save these flags
    m_dwFlags = dwFlags;

    // Show the UI if necessary
    if (!ISFLAGSET(m_dwFlags, DELIVER_BACKGROUND))
        {
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);
        }
    else
        {
        // If the invoker called for background, but the UI is already visible,
        // then remove the flags
        if (IsWindowVisible(m_hwndUI))
            {
            FLAGCLEAR(m_dwFlags, DELIVER_BACKGROUND);
            FLAGCLEAR(m_dwFlags, DELIVER_NOUI);
            }
        }

#if 0
    // Raid 43695: Spooler: News post with a CC causes an SMTP error
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
#endif

    // Single Account Polling...
    if (m_pszAcctID)
        {
        // Add the Account into the Account Table
        CHECKHR(hr = _HrAppendAccountTable(&rTable, m_pszAcctID, ALL_ACCT_SERVERS));
        }
    
    // Otherwise, polling all accounts
    else
    {
        // Determine the types of servers we're going to queue up

        DWORD   dwServers = 0, dw;

        if (m_dwFlags & DELIVER_SMTP_TYPE)
            dwServers |= SRV_SMTP;

        if (m_dwFlags & DELIVER_NEWS_TYPE && !(g_dwAthenaMode & MODE_MAILONLY))
            dwServers |= SRV_NNTP;

        if (m_dwFlags & DELIVER_HTTP_TYPE && !(g_dwAthenaMode & MODE_NEWSONLY))
            dwServers |= SRV_HTTPMAIL;
    
        if (m_dwFlags & DELIVER_IMAP_TYPE && !(g_dwAthenaMode & MODE_NEWSONLY))
            dwServers |= SRV_IMAP;

        if ((m_dwFlags & DELIVER_MAIL_RECV) && !(g_dwAthenaMode & MODE_NEWSONLY))
            dwServers |= SRV_POP3;

        // Enumerate the accounts
        CHECKHR(hr = m_pAcctMan->Enumerate(dwServers, &pEnum));

        // Sort by Account Name
        pEnum->SortByAccountName();
        
        // Add all the accounts into the Account Table
        while (SUCCEEDED(pEnum->GetNext(&pAccount)))
            {
            // Add Account Into the Account Table
            CHECKHR(hr = _HrAppendAccountTable(&rTable, pAccount, dwServers));
            
            // Release
            SafeRelease(pAccount);
            }
        }
    
    // No Accounts...
    if (0 == rTable.cAccounts)
        goto exit;
    
    // Sort the Account Table by Connnection Name
    if (rTable.cRasAccts)
        {
        Assert(rTable.prgRasAcct);
        _SortAccountTableByConnName(0, rTable.cRasAccts - 1, rTable.prgRasAcct);
        }

    m_fRasSpooled = FALSE;
    m_fIDialed = FALSE;

    // Raid-46334: MAIL: Time to build a Task List.  First loop through the LAN list and build tasks from those accounts.
    for (dw = 0; dw < rTable.cLanAccts; dw++)
        {
        if (ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_POP3) ||
            ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_SMTP) ||
            ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_IMAP) ||
            ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_HTTPMAIL))
            {
            Assert(rTable.prgLanAcct[dw].pAccount);
            _HrCreateTaskObject(&(rTable.prgLanAcct[dw]));
            SafeRelease(rTable.prgLanAcct[dw].pAccount);
            }
        }

    // Raid-46334: NEWS: Time to build a Task List.  First loop through the LAN/news list and build tasks from those accounts.
    for (dw = 0; dw < rTable.cLanAccts; dw++)
        {
        if (ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_NNTP))
            {
            Assert(rTable.prgLanAcct[dw].pAccount);
            _HrCreateTaskObject(&(rTable.prgLanAcct[dw]));
            SafeRelease(rTable.prgLanAcct[dw].pAccount);
            }
        else
            Assert(NULL == rTable.prgLanAcct[dw].pAccount);
        }
    
    // Now walk the list of RAS accounts and add those to the task list
    iConnectoid = 0;
    while(iConnectoid < rTable.cRasAccts)
        {
        // Indirect Sort
        i = rTable.prgRasAcct[iConnectoid].dwSort;

        // Save current connectoid
        StrCpyN(szConnectoid, rTable.prgRasAcct[i].szConnectoid, ARRAYSIZE(szConnectoid));

        // Insert Ras Accounts
        // TODO Add HTTP accounts to it too.
        _InsertRasAccounts(&rTable, szConnectoid, SRV_POP3 | SRV_SMTP | SRV_IMAP | SRV_HTTPMAIL);

        // Insert Ras Accounts
        _InsertRasAccounts(&rTable, szConnectoid, SRV_NNTP);

        // Move iConnectoid to next unique connectoid
        while(1)
            {
            // Increment iConnectoid
            iConnectoid++;

            // Done
            if (iConnectoid >= rTable.cRasAccts)
                break;

            // Indirect Sort
            i = rTable.prgRasAcct[iConnectoid].dwSort;

            // Next connectoid
            if (lstrcmpi(szConnectoid, rTable.prgRasAcct[i].szConnectoid) != 0)
                break;
            }
        }
    
    // Execute the first task
    m_cCurEvent = -1;

    m_fNoSyncEvent = (ISFLAGSET(m_dwFlags, DELIVER_OFFLINE_SYNC) && m_pszAcctID != NULL && m_cSyncEvent == 0);

    // Toggle Hangup When Done option
    m_pUI->ChangeHangupOption(m_fRasSpooled, DwGetOption(OPT_DIALUP_HANGUP_DONE));

    // $$HACK$$
    EnableWindow(GetDlgItem(m_hwndUI, IDC_SP_STOP), TRUE);

    // Notify
    Notify(DELIVERY_NOTIFY_STARTING, 0);

    // Start Next Task
    PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);

exit:
    // Failure
    if (FAILED(hr) || 0 == m_rEventTable.cEvents && !ISFLAGSET(dwFlags, DELIVER_SHOW))
        {
        // Not Busy
        FLAGCLEAR(m_dwState, SPSTATE_BUSY);

        // Forces a next task
        PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
        
        // No Flags
        m_dwFlags = 0;
        }
    
    // Cleanup
    SafeRelease(pEnum);
    SafeRelease(pAccount);
    SafeMemFree(m_pszAcctID);
    SafeMemFree(rTable.prgLanAcct);
    SafeMemFree(rTable.prgRasAcct);
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::_InsertRasAccounts
// --------------------------------------------------------------------------------
void CSpoolerEngine::_InsertRasAccounts(LPACCOUNTTABLE pTable, LPCSTR pszConnectoid, DWORD dwSrvTypes)
    {
    // Locals
    ULONG       j;
    ULONG       i;

    // Loop through the ras accounts and insert account on szConnetoid that are mail accounts
    for (j=0; j<pTable->cRasAccts; j++)
        {
        // Indirect
        i = pTable->prgRasAcct[j].dwSort;

        // Is a mail account
        if (pTable->prgRasAcct[i].dwServers & dwSrvTypes)
            {
            // On this connectoid
            if (lstrcmpi(pszConnectoid, pTable->prgRasAcct[i].szConnectoid) == 0)
                {
                // We better have an account
                Assert(pTable->prgRasAcct[i].pAccount);

                // If dialog allowed or we can connect to the account
                if (0 == (m_dwFlags & DELIVER_NODIAL) || S_OK == g_pConMan->CanConnect(pTable->prgRasAcct[i].pAccount))
                    {
                    _HrCreateTaskObject(&(pTable->prgRasAcct[i]));
                    }

                // Release the account, we've added it
                SafeRelease(pTable->prgRasAcct[i].pAccount);
                }
            }
        }
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_SortAccountTableByConnName
// --------------------------------------------------------------------------------
void CSpoolerEngine::_SortAccountTableByConnName(LONG left, LONG right, LPSPOOLERACCOUNT prgRasAcct)
    {
    // Locals
    register    long i, j;
    DWORD       k, temp;
    
    i = left;
    j = right;
    k = prgRasAcct[(i + j) / 2].dwSort;
    
    do  
        {
        while(lstrcmpiA(prgRasAcct[prgRasAcct[i].dwSort].szConnectoid, prgRasAcct[k].szConnectoid) < 0 && i < right)
            i++;
        while (lstrcmpiA(prgRasAcct[prgRasAcct[j].dwSort].szConnectoid, prgRasAcct[k].szConnectoid) > 0 && j > left)
            j--;
        
        if (i <= j)
            {
            temp = prgRasAcct[i].dwSort;
            prgRasAcct[i].dwSort = prgRasAcct[j].dwSort;
            prgRasAcct[j].dwSort = temp;
            i++; j--;
            }
        
        } while (i <= j);
        
    if (left < j)
        _SortAccountTableByConnName(left, j, prgRasAcct);
    if (i < right)
        _SortAccountTableByConnName(i, right, prgRasAcct);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_HrAppendAccountTable
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_HrAppendAccountTable(LPACCOUNTTABLE pTable, LPCSTR pszAcctID, DWORD dwServers)
    {
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    
    // Invalid Arg
    Assert(pTable && pszAcctID);
    
    // Does the Account Exist...
    CHECKHR(hr = m_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAcctID, &pAccount));
    
    // Actual Append
    CHECKHR(hr = _HrAppendAccountTable(pTable, pAccount, dwServers));
    
exit:
    // Cleanup
    SafeRelease(pAccount);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_HrAppendAccountTable
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_HrAppendAccountTable(LPACCOUNTTABLE pTable, IImnAccount *pAccount, DWORD   dwServers)
    {
    // Locals
    HRESULT             hr=S_OK;
    LPSPOOLERACCOUNT    pSpoolAcct;
    DWORD               dwConnType;
    CHAR                szConnectoid[CCHMAX_CONNECTOID];
    
    // InvalidArg
    Assert(pTable && pAccount);
    
    // Init
    *szConnectoid = '\0';
    
    // Get the Account Connection Type
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnType)))
        {
        // Default to Manual Connection
        dwConnType = CONNECTION_TYPE_MANUAL;
        }
    
    // Otheriwse, get the connectoid if its a RAS connection
    //else if (CONNECTION_TYPE_RAS == dwConnType || CONNECTION_TYPE_INETSETTINGS == dwConnType)
    else if (CONNECTION_TYPE_RAS == dwConnType)
        {
        // AP_RAS_CONNECTOID
        if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnectoid, ARRAYSIZE(szConnectoid))))
            {
            // Default to Lan Connection
            dwConnType = CONNECTION_TYPE_MANUAL;
            }
        }
    else if (CONNECTION_TYPE_INETSETTINGS == dwConnType)
    {
        DWORD   dwFlags;

        InternetGetConnectedStateExA(&dwFlags, szConnectoid, ARRAYSIZE(szConnectoid), 0);
        if (!!(dwFlags & INTERNET_CONNECTION_MODEM))
        {
            dwConnType = CONNECTION_TYPE_RAS;
        }
        else
        {
            dwConnType = CONNECTION_TYPE_LAN;
        }
    }
    
    // Which Table Should I insert into - LAN OR RAS
      if (CONNECTION_TYPE_RAS == dwConnType)
        {
        // Better have a Connectoid
        Assert(FIsEmptyA(szConnectoid) == FALSE);
        
        // Grow the Table
        if (pTable->cRasAccts + 1 > pTable->cRasAlloc)
            {
            // Temp
            LPSPOOLERACCOUNT pRealloc=pTable->prgRasAcct;
            
            // Realloc
            CHECKALLOC(pTable->prgRasAcct = (LPSPOOLERACCOUNT)g_pMalloc->Realloc((LPVOID)pRealloc, (pTable->cRasAlloc + 5) * sizeof(SPOOLERACCOUNT)));
            
            // Grow
            pTable->cRasAlloc += 5;
            }
        
        // Readability
        pSpoolAcct = &pTable->prgRasAcct[pTable->cRasAccts];
        }
    
    // Otherwise, LAN
    else
        {
        // Grow the Table
        if (pTable->cLanAccts + 1 > pTable->cLanAlloc)
            {
            // Temp
            LPSPOOLERACCOUNT pRealloc=pTable->prgLanAcct;
            
            // Realloc
            CHECKALLOC(pTable->prgLanAcct = (LPSPOOLERACCOUNT)g_pMalloc->Realloc((LPVOID)pRealloc, (pTable->cLanAlloc + 5) * sizeof(SPOOLERACCOUNT)));
            
            // Grow
            pTable->cLanAlloc += 5;
            }
        
        // Readability
        pSpoolAcct = &pTable->prgLanAcct[pTable->cLanAccts];
        }
    
    // Zero
    ZeroMemory(pSpoolAcct, sizeof(SPOOLERACCOUNT));
    
    // AddRef the Account
    pSpoolAcct->pAccount = pAccount;
    pSpoolAcct->pAccount->AddRef();
    
    // Get the servers supported by the account
    CHECKHR(hr = pAccount->GetServerTypes(&pSpoolAcct->dwServers));

    //Mask the servers returned by the acctman with the servers we want to spool
    pSpoolAcct->dwServers &= dwServers;
    
    /*
    if (pSpoolAcct->dwServers & (SRV_HTTPMAIL | SRV_IMAP))
    {
        //For each of these two servers, set the sync flags. See Bug# 51895
        m_dwFlags |= (DELIVER_NEWSIMAP_OFFLINE | DELIVER_NEWSIMAP_OFFLINE_FLAGS);
    }
    */

    // Save Connection Type
    pSpoolAcct->dwConnType = dwConnType;
    
    // Save Connectoid
    StrCpyN(pSpoolAcct->szConnectoid, szConnectoid, ARRAYSIZE(pSpoolAcct->szConnectoid));
    
    // Increment Count and set the sort index
//    if (CONNECTION_TYPE_RAS == dwConnType || dwConnType == CONNECTION_TYPE_INETSETTINGS)
      if (CONNECTION_TYPE_RAS == dwConnType)
        {
        pSpoolAcct->dwSort = pTable->cRasAccts;
        pTable->cRasAccts++;
        }
    else
        {
        pSpoolAcct->dwSort = pTable->cLanAccts;
        pTable->cLanAccts++;
        }
    
    // Total Acount
    pTable->cAccounts++;
    
exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Close
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Close(void)
    {
    // Locals
    HRESULT     hr=S_OK;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    _StopPolling();
    
    // Was I Threaded ?
    if (NULL != m_hThread)
        {
        hr = TrapError(E_FAIL);
        goto exit;
        }
    
    // Shutdown
    CHECKHR(hr = Shutdown());
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Notify
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Notify(DELIVERYNOTIFYTYPE notify, LPARAM lParam)
{
    // Locals
    ULONG i;

    // Enter it
    EnterCriticalSection(&m_cs);

    // Same thread we were created on...
    Assert(ISSPOOLERTHREAD);

    // Loop through registered views
    for (i=0; i<m_rViewRegister.cViewAlloc; i++)
        if (m_rViewRegister.rghwndView[i] != 0 && IsWindow(m_rViewRegister.rghwndView[i]))
            PostMessage(m_rViewRegister.rghwndView[i], MVM_SPOOLERDELIVERY, (WPARAM)notify, lParam);

    // Enter it
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::Advise
// --------------------------------------------------------------------------------
#define VIEW_TABLE_GROWSIZE 8
STDMETHODIMP CSpoolerEngine::Advise(HWND hwndView, BOOL fRegister)
    {
    // Locals
    ULONG           i;
    HRESULT         hr=S_OK;
    
    // Enter it
    EnterCriticalSection(&m_cs);
    
    // If NULL view handle...
    if (!hwndView)
        {
        hr = TrapError(E_FAIL);
        goto exit;
        }
    
    // Are we registering the window
    if (fRegister)
        {
        // Do we need to grow the register array
        if (m_rViewRegister.cViewAlloc == m_rViewRegister.cView)
            {
            // Add some more
            m_rViewRegister.cViewAlloc += VIEW_TABLE_GROWSIZE;
            
            // Realloc the array
            if (!MemRealloc((LPVOID *)&m_rViewRegister.rghwndView, sizeof(HWND) * m_rViewRegister.cViewAlloc))
                {
                m_rViewRegister.cViewAlloc -= VIEW_TABLE_GROWSIZE;
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
                }
            
            // Zeroinit the new items
            ZeroMemory(&m_rViewRegister.rghwndView[m_rViewRegister.cView], sizeof(HWND) * (m_rViewRegister.cViewAlloc - m_rViewRegister.cView));
            }
        
        // Fill the first NULL item with the new view
        for (i=0; i<m_rViewRegister.cViewAlloc; i++)
            {
            // If empty, lets fill it
            if (!m_rViewRegister.rghwndView[i])
                {
                m_rViewRegister.rghwndView[i] = hwndView;
                m_rViewRegister.cView++;
                break;
                }
            }
        
        // Did we insert it ?
        AssertSz(i != m_rViewRegister.cViewAlloc, "didn't find a hole??");
        }
    
    // Otherwise, find and remove the view
    else
        {
        // Look for hwndView
        for (i=0; i<m_rViewRegister.cViewAlloc; i++)
            {
            // Is this it
            if (m_rViewRegister.rghwndView[i] == hwndView)
                {
                m_rViewRegister.rghwndView[i] = NULL;
                m_rViewRegister.cView--;
                break;
                }
            }
        }
    
exit:
    // Leave CS
    LeaveCriticalSection(&m_cs);
    
    // If this is the first view to register, and there is a background poll pending, lets do it...
    if (fRegister && m_rViewRegister.cView == 1 && m_fBackgroundPollPending)
        {
        StartDelivery(NULL, NULL, FOLDERID_INVALID, DELIVER_BACKGROUND_POLL);
        m_fBackgroundPollPending = FALSE;
        }
    else if (m_rViewRegister.cView == 0)
        {
        // remove the notify icon if there aren't any views registered
        UpdateTrayIcon(TRAYICON_REMOVE);
        }
    
    // Done    
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::UpdateTrayIcon
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::UpdateTrayIcon(TRAYICONTYPE type)
    {
    // Locals
    NOTIFYICONDATA  nid;
    HWND            hwnd=NULL;
    ULONG           i;

    // Enter it
    EnterCriticalSection(&m_cs);

    // Add the icon...
    if (TRAYICON_ADD == type)
    {
        // Loop through registered views
        for (i=0; i<m_rViewRegister.cViewAlloc; i++)
        {
            if (m_rViewRegister.rghwndView[i] && IsWindow(m_rViewRegister.rghwndView[i]))
            {
                hwnd = m_rViewRegister.rghwndView[i];
                break;
            }
        }

        // No window...
        if (hwnd == NULL)
            goto exit;
    }

    // Otherwise, if no notify window, were done
    else if (m_hwndTray == NULL)
        goto exit;

    // Set Tray Notify Icon Data
    nid.cbSize = sizeof(NOTIFYICONDATA);
    nid.uID = 0;
    nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    nid.uCallbackMessage = MVM_NOTIFYICONEVENT;
    nid.hIcon = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiNewMailNotify));
    LoadString(g_hLocRes, idsNewMailNotify, nid.szTip, sizeof(nid.szTip));

    // Hmmm
    if (TRAYICON_REMOVE == type || (m_hwndTray != NULL && m_hwndTray != hwnd))
    {
        nid.hWnd = m_hwndTray;
        Shell_NotifyIcon(NIM_DELETE, &nid);
        m_hwndTray = NULL;
    }

    // Add
    if (TRAYICON_ADD == type)
    {
        nid.hWnd = hwnd;
        Shell_NotifyIcon(NIM_ADD, &nid);
        m_hwndTray = hwnd;
    }

exit:
    // Leave CS
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::RegisterEvent
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::RegisterEvent(LPCSTR pszDescription, ISpoolerTask *pTask, 
                                           DWORD_PTR dwTwinkie, IImnAccount *pAccount,
                                           LPEVENTID peid)
    {
    HRESULT hr = S_OK;
    LPSPOOLEREVENT pEvent = NULL;
    LPWSTR pwszConn = NULL;
    WCHAR  wsz[CCHMAX_STRINGRES];
    
    // Verify the input parameters
    if (FIsEmptyA(pszDescription) || pTask == NULL)
        return (E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);
    
    // Grow the Table
    if (m_rEventTable.cEvents + 1 > m_rEventTable.cEventsAlloc)
        {
        // Temp
        LPSPOOLEREVENT pRealloc = m_rEventTable.prgEvents;
        
        // Realloc
        CHECKALLOC(m_rEventTable.prgEvents = (LPSPOOLEREVENT) g_pMalloc->Realloc((LPVOID)pRealloc, (m_rEventTable.cEventsAlloc + 5) * sizeof(SPOOLEREVENT)));
        
        // Grow
        m_rEventTable.cEventsAlloc += 5;
        }

    pEvent = &m_rEventTable.prgEvents[m_rEventTable.cEvents];
    
    // Insert the event
    pEvent->eid = m_rEventTable.cEvents;
    pEvent->pSpoolerTask = pTask;
    pEvent->pSpoolerTask->AddRef();
    pEvent->dwTwinkie = dwTwinkie;
    pEvent->pAccount = pAccount;
    pEvent->pAccount->AddRef();

    // Get the Account Connection Type
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &pEvent->dwConnType)))
        {
        // Default to Manual Connection
        pEvent->dwConnType = CONNECTION_TYPE_MANUAL;
        }
    
    // Otheriwse, get the connectoid if its a RAS connection
    //else if (CONNECTION_TYPE_RAS == pEvent->dwConnType || CONNECTION_TYPE_INETSETTINGS == pEvent->dwConnType)
    else if (CONNECTION_TYPE_RAS == pEvent->dwConnType)
    {
        // AP_RAS_CONNECTOID
        if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, pEvent->szConnectoid, ARRAYSIZE(pEvent->szConnectoid))))
        {
            // Default to Lan Connection
            pEvent->dwConnType = CONNECTION_TYPE_MANUAL;
        }
    }
    else if (CONNECTION_TYPE_INETSETTINGS == pEvent->dwConnType)
    {
        DWORD   dwFlags = 0;

        InternetGetConnectedStateExA(&dwFlags, pEvent->szConnectoid, ARRAYSIZE(pEvent->szConnectoid), 0);
        if (!!(dwFlags & INTERNET_CONNECTION_MODEM))
        {
            pEvent->dwConnType = CONNECTION_TYPE_RAS;
        }
        else
        {
            pEvent->dwConnType = CONNECTION_TYPE_LAN;
        }
    }

    // Get the connection name to put in the task list
    if (pEvent->dwConnType == CONNECTION_TYPE_LAN)
    {
        AthLoadStringW(idsConnectionLAN, wsz, ARRAYSIZE(wsz));
        pwszConn = wsz;
    }
    else if (pEvent->dwConnType == CONNECTION_TYPE_MANUAL)
    {
        AthLoadStringW(idsConnectionManual, wsz, ARRAYSIZE(wsz));
        pwszConn = wsz;
        m_fRasSpooled = TRUE;
    }
    else
    {
        IF_NULLEXIT(pwszConn = PszToUnicode(CP_ACP, pEvent->szConnectoid));
        m_fRasSpooled = TRUE;
    }

    // Add the event description to the UI
    if (m_pUI)
    {
        m_pUI->InsertEvent(m_rEventTable.prgEvents[m_rEventTable.cEvents].eid, pszDescription, pwszConn);
        m_pUI->SetTaskCounts(0, m_rEventTable.cEvents + 1);
    }
    
    // Check to see if the task cares about the event id
    if (peid)
        *peid = m_rEventTable.prgEvents[m_rEventTable.cEvents].eid;
    
    m_rEventTable.cEvents++;

exit:
    if (pwszConn != wsz)
        MemFree(pwszConn);
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::EventDone
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::EventDone(EVENTID eid, EVENTCOMPLETEDSTATUS status)
    {
    LPSPOOLEREVENT pEvent;

    // Update the UI
    if (EVENT_SUCCEEDED == status)
        {
        m_rEventTable.cSucceeded++;
        m_pUI->SetTaskCounts(m_rEventTable.cSucceeded, m_rEventTable.cEvents);
        m_pUI->UpdateEventState(eid, IMAGE_CHECK, NULL, MAKEINTRESOURCE(idsStateCompleted));
        }
    else if (EVENT_WARNINGS == status)
        {
        m_pUI->UpdateEventState(eid, IMAGE_WARNING, NULL, MAKEINTRESOURCE(idsStateWarnings));
        }
    else if (EVENT_FAILED == status)
        {
        m_pUI->UpdateEventState(eid, IMAGE_ERROR, NULL, MAKEINTRESOURCE(idsStateFailed));
        }
    else if (EVENT_CANCELED == status)
        {
        m_pUI->UpdateEventState(eid, IMAGE_WARNING, NULL, MAKEINTRESOURCE(idsStateCanceled));
        }

    // When an event completes, we can move to the next item in the queue unless
    // we're done.
    if (!ISFLAGCLEAR(m_dwState, SPSTATE_CANCEL))
    {
        m_cCurEvent++;
        pEvent = &m_rEventTable.prgEvents[m_cCurEvent];
        for ( ; m_cCurEvent < m_rEventTable.cEvents; m_cCurEvent++, pEvent++)
        {
            pEvent->pSpoolerTask->CancelEvent(pEvent->eid, pEvent->dwTwinkie);
        }
    }

    // Next Task
    PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
    
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_OpenMailLogFile
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_OpenMailLogFile(DWORD dwOptionId, LPCSTR pszPrefix, 
    LPCSTR pszFileName, ILogFile **ppLogFile)
{
    // Locals
    HRESULT hr=S_OK;
    CHAR    szLogFile[MAX_PATH];
    CHAR    szDirectory[MAX_PATH];
    DWORD   dw;

    // Invalid Args
    Assert(pszPrefix && ppLogFile);

    // Log file path
    dw = GetOption(dwOptionId, szLogFile, ARRAYSIZE(szLogFile));

    // If we found a filepath and the file exists
    if (0 == dw || FALSE == PathFileExists(szLogFile))
    {
        // Get the Store Root Directory
        GetStoreRootDirectory(szDirectory, ARRAYSIZE(szDirectory));

        // Ends with a backslash ?
        IF_FAILEXIT(hr = MakeFilePath(szDirectory, pszFileName, c_szEmpty, szLogFile, ARRAYSIZE(szLogFile)));

        // Reset the Option
        SetOption(dwOptionId, szLogFile, lstrlen(szLogFile) + 1, NULL, 0);
    }

    // Create the log file
    IF_FAILEXIT(hr = CreateLogFile(g_hInst, szLogFile, pszPrefix, DONT_TRUNCATE, ppLogFile,
        FILE_SHARE_READ | FILE_SHARE_WRITE));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::BindToObject
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::BindToObject(REFIID riid, void **ppvObject)
    {
    // Locals
    HRESULT     hr=S_OK;
    
    // Invalid Arg
    if (NULL == ppvObject)
        return TrapError(E_INVALIDARG);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // IID_ISpoolerBindContext
    if (IID_ISpoolerBindContext == riid)
        *ppvObject = (ISpoolerBindContext *)this;

    // IID_CUidlCache
    else if (IID_CUidlCache == riid)
    {
        // Doesn't Exist
        if (NULL == m_pUidlCache)
            {
            // Open the Cache
            CHECKHR(hr = OpenUidlCache(&m_pUidlCache));
            }

        // AddRef it
        m_pUidlCache->AddRef();
        
        // Return It
        *ppvObject = (IDatabase *)m_pUidlCache;
    }
    
    // IImnAccountManager
    else if (IID_IImnAccountManager == riid)
        {
        // Doesn't Exist
        if (NULL == m_pAcctMan)
            {
            AssertSz(FALSE, "The Account Manager Could Not Be Created.");
            hr = TrapError(E_FAIL);
            goto exit;
            }

        // AddRef It
        m_pAcctMan->AddRef();
        
        // Return It
        *ppvObject = (IImnAccountManager *)m_pAcctMan;
        }
    
    // ISpoolerUI
    else if (IID_ISpoolerUI == riid)
        {
        // Doesn't Exist
        if (NULL == m_pUI)
            {
            AssertSz(FALSE, "The Spooler UI Object Could Not Be Created.");
            hr = TrapError(E_FAIL);
            goto exit;
            }

        // AddRef It
        m_pUI->AddRef();
        
        // Return It
        *ppvObject = (ISpoolerUI *)m_pUI;
        }

    // IID_CLocalStoreDeleted
    else if (IID_CLocalStoreDeleted == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_DELETED, (IMessageFolder **)ppvObject));
        }
    
    // IID_CLocalStoreInbox
    else if (IID_CLocalStoreInbox == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, (IMessageFolder **)ppvObject));
        }
    
    // IID_CLocalStoreOutbox
    else if (IID_CLocalStoreOutbox == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_OUTBOX, (IMessageFolder **)ppvObject));
        }
    
    // IID_CLocalStoreSentItems
    else if (IID_CLocalStoreSentItems == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_SENT, (IMessageFolder **)ppvObject));
        }

    // IID_CPop3LogFile
    else if (IID_CPop3LogFile == riid)
        {   
        // Create logging objects
        if (!DwGetOption(OPT_MAILLOG))
            {
            hr = TrapError(E_FAIL);
            goto exit;
            }


        // Do I have the logfile yet ?
        if (NULL == m_pPop3LogFile)
            {
            // Open the log file
            CHECKHR(hr = _OpenMailLogFile(OPT_MAILPOP3LOGFILE, "POP3", c_szDefaultPop3Log, &m_pPop3LogFile));
            }

        // AddRef It
        m_pPop3LogFile->AddRef();

        // Return It
        *ppvObject = (ILogFile *)m_pPop3LogFile;
        }

    // IID_CSmtpLogFile
    else if (IID_CSmtpLogFile == riid)
        {   
        // Create logging objects
        if (!DwGetOption(OPT_MAILLOG))
            {
            hr = TrapError(E_FAIL);
            goto exit;
            }

        // Do I have the logfile yet ?
        if (NULL == m_pSmtpLogFile)
            {
            // Open the log file
            CHECKHR(hr = _OpenMailLogFile(OPT_MAILSMTPLOGFILE, "SMTP", c_szDefaultSmtpLog, &m_pSmtpLogFile));
            }

        // AddRef It
        m_pSmtpLogFile->AddRef();

        // Return It
        *ppvObject = (ILogFile *)m_pSmtpLogFile;
        }
    
    // E_NOTINTERFACE
    else
        {
        hr = TrapError(E_NOINTERFACE);
        goto exit;
        }
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::TaskFromEventId
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::TaskFromEventId(EVENTID eid, ISpoolerTask *ppTask)
    {
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CSpoolerEngine::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Cancel(void)
    {
    EnterCriticalSection(&m_cs);

    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
        Assert(m_rEventTable.cEvents && m_rEventTable.prgEvents);    
        FLAGSET(m_dwState, SPSTATE_CANCEL);
        if (m_rEventTable.prgEvents && m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask)
            m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask->Cancel();
        }

    LeaveCriticalSection(&m_cs);

    return S_OK;
    }



// --------------------------------------------------------------------------------
// CSpoolerEngine::GetThreadInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::GetThreadInfo(LPDWORD pdwThreadId, HTHREAD* phThread)
    {
    // Invalid Arg
    if (NULL == pdwThreadId || NULL == phThread)
        return TrapError(E_INVALIDARG);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Return It
    *pdwThreadId = m_dwThreadId;
    *phThread = m_hThread;
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::QueryEndSession
// --------------------------------------------------------------------------------
STDMETHODIMP_(LRESULT) CSpoolerEngine::QueryEndSession(WPARAM wParam, LPARAM lParam)
    {
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
        if (AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsAbortDownload), NULL, MB_YESNO|MB_ICONEXCLAMATION ) == IDNO)
            return FALSE;
        }
    Cancel();
    return TRUE;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Shutdown
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::Shutdown(void)
    {
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better shutdown on the same thread we started on
    Assert(ISSPOOLERTHREAD);

    // Stop Polling
    _StopPolling();

    // Are we currently busy
    _ShutdownTasks();
    
    // If we're executing, then we need to stop and release all the tasks
    for (UINT i = 0; i < m_rEventTable.cEvents; i++)
        {
        SafeRelease(m_rEventTable.prgEvents[i].pSpoolerTask);
        SafeRelease(m_rEventTable.prgEvents[i].pAccount);
        }
    
    // Release Objects
    SafeRelease(m_pUI);
    SafeRelease(m_pAcctMan);
    SafeRelease(m_pUidlCache);
    SafeMemFree(m_pszAcctID);
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CSpoolerEngine::Shutdown
// --------------------------------------------------------------------------------
void CSpoolerEngine::_ShutdownTasks(void)
{
    // Locals
    HRESULT              hr=S_OK;
    MSG                  msg;
    BOOL                 fFlushOutbox=FALSE;
    IMessageFolder      *pOutbox=NULL;
    int                  ResId;
    BOOL                 fOffline = FALSE;


    // Clear queued events
    m_dwQueued = 0;

    // Check for unsent mail
    if (g_fCheckOutboxOnShutdown)
    {
        // Open the Outbox
        if (SUCCEEDED(BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&pOutbox)))
        {
            // Locals
            HROWSET hRowset=NULL;
            MESSAGEINFO MsgInfo={0};

            // Create a Rowset
            if (SUCCEEDED(pOutbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset)))
            {
                // While 
                while (S_OK == pOutbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
                {
                    // Has this message been submitted and is it a mail message
                    if (((MsgInfo.dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) == ARF_SUBMITTED) &&
                        (!ISFLAGSET(m_dwState, SPSTATE_BUSY)))
                    {
                        fOffline = g_pConMan->IsGlobalOffline();

                        if (fOffline)
                            ResId = idsWarnUnsentMailOffline;
                        else
                            ResId = idsWarnUnsentMail;

                        // Prompt to flush the outbox
                        if (AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(ResId), NULL, MB_YESNO|MB_ICONEXCLAMATION ) == IDYES)
                        {
                            // Go online
                            if (fOffline)
                                g_pConMan->SetGlobalOffline(FALSE);

                            // Flush on exit
                            fFlushOutbox = TRUE;
                        }

                        // Done
                        break;
                    }
                
                    // Free MsgInfo
                    pOutbox->FreeRecord(&MsgInfo);
                }

                // Free MsgInfo
                pOutbox->FreeRecord(&MsgInfo);

                // Close the Rowset
                pOutbox->CloseRowset(&hRowset);
            }
        }
    }

    // Release outbox
    SafeRelease(pOutbox);

    // Set Shutdown state
    FLAGSET(m_dwState, SPSTATE_SHUTDOWN);

    // If not busy now, start the flush
    if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
    {
        // Flush the Outbox
        if (fFlushOutbox)
        {
            // No need to flush again
            fFlushOutbox = FALSE;

            // Start the delivery
            _HrStartDeliveryActual(DELIVER_SEND | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE );

            // We are busy
            FLAGSET(m_dwState, SPSTATE_BUSY);
        }

        // Otheriwse, were done...
        else
            goto exit;
    }

    // We must wait for current cycle to finish
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
    {
        // Lets show progress...
        FLAGCLEAR(m_dwFlags, DELIVER_NOUI | DELIVER_BACKGROUND);

        // Show the ui object
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);

        // Here's a nice hack to disable the Hide button
        EnableWindow(GetDlgItem(m_hwndUI, IDC_SP_MINIMIZE), FALSE);

        // Set focus on the dialog
        SetFocus(m_hwndUI);

        // Set the focus onto the Stop Button
        SetFocus(GetDlgItem(m_hwndUI, IDC_SP_STOP));

        // Pump messages until current cycle is complete
        while(GetMessage(&msg, NULL, 0, 0))
        {
            // Give the message to the UI object
            if (m_pUI->IsDialogMessage(&msg) == S_FALSE && IsDialogMessage(&msg) == S_FALSE)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // If no cycle, were done
            if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
            {
                // Do the Outbox
                if (fFlushOutbox)
                {
                    // Were the errors...
                    if (S_OK == m_pUI->AreThereErrors())
                    {
                        // Errors were encountered during the last Delivery Cycle. Would you still like to send the messages that are in your Outbox?
                        if (AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsWarnErrorUnsentMail), NULL, MB_YESNO | MB_ICONEXCLAMATION ) == IDNO)
                            break;
                    }

                    // No need to flush again
                    fFlushOutbox = FALSE;

                    // Start the delivery
                    _HrStartDeliveryActual(DELIVER_SEND | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE );

                    // We are busy
                    FLAGSET(m_dwState, SPSTATE_BUSY);
                }
                else
                    break;
            }
        }
    }

    // Were the errors...
    if (S_OK == m_pUI->AreThereErrors() && !g_pInstance->SwitchingUsers())
    {
        // Tell the ui to go into Shutdown Mode
        m_pUI->Shutdown();

        // Show the ui object
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);

        // We are busy
        FLAGCLEAR(m_dwState, SPSTATE_UISHUTDOWN);

        // Set the focus onto the Stop Button
        SetFocus(GetDlgItem(m_hwndUI, IDC_SP_MINIMIZE));

        // Pump messages until current cycle is complete
        while(GetMessage(&msg, NULL, 0, 0))
        {
            // Give the message to the UI object
            if (m_pUI->IsDialogMessage(&msg) == S_FALSE && IsDialogMessage(&msg) == S_FALSE)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // User Pressed close yet ?
            if (ISFLAGSET(m_dwState, SPSTATE_UISHUTDOWN))
                break;
        }
    }

exit:
    // Cleanup
    SafeRelease(pOutbox);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::UIShutdown
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::UIShutdown(void)
{
    EnterCriticalSection(&m_cs);
    FLAGSET(m_dwState, SPSTATE_UISHUTDOWN);
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::PumpMessages
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::PumpMessages(void)
{
    // Locals
    MSG     msg;
    BOOL    fQuit=FALSE;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Pump messages until current cycle is complete
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        // WM_QUIT
        if (WM_QUIT == msg.message)
            {
            // Make a note that a quit was received
            fQuit = TRUE;

            // If not running with now ui, set to foreground
            if (FALSE == IsWindowVisible(m_hwndUI))
                {
                m_pUI->ShowWindow(SW_SHOW);
                SetForegroundWindow(m_hwndUI);
                }
            }

        // Give the message to the UI object
        if (m_pUI->IsDialogMessage(&msg) == S_FALSE && IsDialogMessage(&msg) == S_FALSE)
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }
        }

    // Repost the quit message
    if (fQuit)
        PostThreadMessage(m_dwThreadId, WM_QUIT, 0, 0);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::OnWindowMessage - S_OK (I Handled the message)
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::OnWindowMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Handle the window message
    switch(uMsg)
        {
        case IMAIL_DELIVERNOW:
            _HrStartDeliveryActual((DWORD)lParam);
            break;

        case IMAIL_NEXTTASK:
            _HrStartNextEvent();
            break;            
        
        case WM_TIMER:
            if (wParam == IMAIL_POOLFORMAIL)
                {
                KillTimer(hwnd, IMAIL_POOLFORMAIL);
                _DoBackgroundPoll();
                }
            break;

        case CM_OPTIONADVISE:
            // Check to see if the polling option changed
            if (wParam == OPT_POLLFORMSGS)
                {
                dw = DwGetOption(OPT_POLLFORMSGS);
                if (dw != OPTION_OFF)
                    {
                    if (dw != m_dwPollInterval)
                        {
                        KillTimer(hwnd, IMAIL_POOLFORMAIL);
                        SetTimer(hwnd, IMAIL_POOLFORMAIL, dw, NULL);
                        m_dwPollInterval = dw;
                        }
                    }
                else
                    {
                    KillTimer(hwnd, IMAIL_POOLFORMAIL);
                    m_dwPollInterval = 0;
                    }
                }

            // Check to see if the hang up option changed
            if (wParam == OPT_DIALUP_HANGUP_DONE)
                {
                dw = DwGetOption(OPT_DIALUP_HANGUP_DONE);
                m_pUI->ChangeHangupOption(m_fRasSpooled, dw);
                }

            break;

        default:
            hr = S_FALSE;
            break;
        }
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }


HRESULT CSpoolerEngine::_HrCreateTaskObject(LPSPOOLERACCOUNT pSpoolerAcct)
{
    DWORD           cEvents, cEventsT;
    HRESULT         hr=S_OK;

    // Let's try pumping messages to see if this get's any smoother
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        // Give the message to the UI object
        if (m_pUI->IsDialogMessage(&msg) == S_FALSE)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    // Create the appropriate task object.  Start with SMTP
    if (pSpoolerAcct->dwServers & SRV_SMTP && m_dwFlags & DELIVER_SEND)
    {
        CSmtpTask *pSmtpTask = new CSmtpTask();
        if (pSmtpTask)
        {
            // Initialize the news task
            if (SUCCEEDED(hr = pSmtpTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
            {
                // Tell the task to build it's event list
                hr = pSmtpTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);
            }

            pSmtpTask->Release();
        }
    }

    // HTTPMail Servers
    if ((!!(pSpoolerAcct->dwServers & SRV_HTTPMAIL)) && (!!(m_dwFlags & (DELIVER_SEND | DELIVER_POLL))))
    {
/*		DWORD dw;
		if (SUCCEEDED(pSpoolerAcct->pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
		{
			if(HideHotmail())
				return(hr);
		}
*/
        CHTTPTask *pHTTPTask = new CHTTPTask();
        if (pHTTPTask)
        {
            // initialize the http mail task
            if (SUCCEEDED(hr = pHTTPTask->Init(m_dwFlags, (ISpoolerBindContext *)this)))
                hr = pHTTPTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);

            pHTTPTask->Release();
        }
    }
    
    // POP3 Servers
    if (pSpoolerAcct->dwServers & SRV_POP3 && m_dwFlags & DELIVER_MAIL_RECV)
    {
        // Skipping Marked Pop3 Accounts
        DWORD dw=FALSE;
        if (ISFLAGSET(m_dwFlags, DELIVER_NOSKIP) || FAILED(pSpoolerAcct->pAccount->GetPropDw(AP_POP3_SKIP, &dw)) || FALSE == dw)
        {
            CPop3Task *pPop3Task = new CPop3Task();
            if (pPop3Task)
            {
                // Initialize the news task
                if (SUCCEEDED(hr = pPop3Task->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    // Tell the task to build it's event list
                    hr = pPop3Task->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);
                }

                pPop3Task->Release();
            }
        }
    }

    // Servers that support offline sync
    if ((pSpoolerAcct->dwServers & (SRV_NNTP | SRV_IMAP | SRV_HTTPMAIL)))
    {
        if (!!((DELIVER_POLL | DELIVER_SEND) & m_dwFlags))
        {
            CNewsTask *pNewsTask = new CNewsTask();
            if (pNewsTask)
            {
                // Initialize the news task
                if (SUCCEEDED(hr = pNewsTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    // Tell the task to build it's event list
                    hr = pNewsTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);
                }

                pNewsTask->Release();
            }
        }

        if ((m_dwFlags & DELIVER_WATCH) && !(m_dwFlags & DELIVER_NO_NEWSPOLL) 
            && (pSpoolerAcct->dwServers & SRV_NNTP))
        {
            CWatchTask *pWatchTask = new CWatchTask();

            if (pWatchTask)
            {
                if (SUCCEEDED(hr = pWatchTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    hr = pWatchTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, m_idFolder);
                }

                pWatchTask->Release();
            }
        }       
        
        cEvents = m_rEventTable.cEvents;

        if (m_dwFlags & DELIVER_OFFLINE_FLAGS)
        {
            COfflineTask *pOfflineTask = new COfflineTask();
            if (pOfflineTask)
            {
                // Initialize the offline task
                if (SUCCEEDED(hr = pOfflineTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    // Tell the task to build it's event list
                    hr = pOfflineTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, m_idFolder);
                }
                
                pOfflineTask->Release();    
            }
        }

        cEventsT = m_rEventTable.cEvents;
        m_cSyncEvent += (cEventsT - cEvents);
    }

    return (hr);
    }

STDMETHODIMP CSpoolerEngine::IsDialogMessage(LPMSG pMsg)
    {
    HRESULT hr=S_FALSE;
    EnterCriticalSection(&m_cs);
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY) && (LONG)m_cCurEvent >= 0 && m_cCurEvent < m_rEventTable.cEvents && m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask)
       hr = m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask->IsDialogMessage(pMsg);
    LeaveCriticalSection(&m_cs);
    return hr;
    }

HRESULT CSpoolerEngine::_HrStartNextEvent(void)
{
    HRESULT        hr = S_OK;
    TCHAR          szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    TCHAR          szBuf2[CCHMAX_CONNECTOID + 2];

    EnterCriticalSection(&m_cs);

    // RAID-30804 Release the current task. This makes sure that objects like the pop3 object
    // release it's locks on the store.
    if ((LONG)m_cCurEvent >= 0 && m_cCurEvent < m_rEventTable.cEvents)
    {
        SafeRelease(m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask);
    }

    // Advance to the next event
    m_cCurEvent++;

    // Check to see if that pushes us over the edge
    if (m_cCurEvent >= m_rEventTable.cEvents)
    {
        _HrGoIdle();
    }
    else
    {
        LPSPOOLEREVENT pEvent = &m_rEventTable.prgEvents[m_cCurEvent];

        // Check to see if we need to connect first
        if (pEvent->dwConnType == CONNECTION_TYPE_RAS)
        {
            // Check to see if we need to connect
            if (m_cCurEvent == 0 || (0 != lstrcmpi(pEvent->szConnectoid, m_rEventTable.prgEvents[m_cCurEvent - 1].szConnectoid)) || S_OK != g_pConMan->CanConnect(pEvent->szConnectoid))
            {
                hr = _HrDoRasConnect(pEvent);

                if (hr == HR_E_OFFLINE || hr == HR_E_USER_CANCEL_CONNECT || hr == HR_E_DIALING_INPROGRESS)
                {
                    for (m_cCurEvent; m_cCurEvent < m_rEventTable.cEvents; m_cCurEvent++)
                    {
                        // Mark the event as cancelled
                        m_pUI->UpdateEventState(m_cCurEvent, IMAGE_WARNING, NULL, MAKEINTRESOURCE(idsStateCanceled));
                        
                        //This is a hack to not show errors. In this case we just want to behave as though this 
                        //operation succeeded.
                        m_rEventTable.cSucceeded++;
                        
                        // Check to see if we've found a different connection yet
                        if ((m_cCurEvent == m_rEventTable.cEvents - 1) || 
                             0 != lstrcmpi(m_rEventTable.prgEvents[m_cCurEvent].szConnectoid, m_rEventTable.prgEvents[m_cCurEvent + 1].szConnectoid))
                            break;
                    }
                }
                else 
                if (FAILED(hr))
                {
                    // We need to mark all the events for this connection as failed as
                    // well.
                    for (m_cCurEvent; m_cCurEvent < m_rEventTable.cEvents; m_cCurEvent++)
                    {
                        // Mark the event as failed
                        m_pUI->UpdateEventState(m_cCurEvent, IMAGE_ERROR, NULL, MAKEINTRESOURCE(idsStateFailed));                        

                        // Check to see if we've found a different connection yet
                        if ((m_cCurEvent == m_rEventTable.cEvents - 1) || 
                             0 != lstrcmpi(m_rEventTable.prgEvents[m_cCurEvent].szConnectoid, m_rEventTable.prgEvents[m_cCurEvent + 1].szConnectoid))
                            break;
                    }

                    // Insert an error for this failure
                    AthLoadString(idsRasErrorGeneralWithName, szRes, ARRAYSIZE(szRes));
                    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, PszEscapeMenuStringA(m_rEventTable.prgEvents[m_cCurEvent].szConnectoid, szBuf2, ARRAYSIZE(szBuf2)));
                    m_pUI->InsertError(m_cCurEvent, szBuf);
                    hr = E_FAIL;
                }

                if (hr != S_OK)
                {
                    // Move on to the next task
                    PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
                    goto exit;
                }
            }
        }

        if (FAILED(pEvent->pSpoolerTask->Execute(pEvent->eid, pEvent->dwTwinkie))) 
        {                   
            m_pUI->UpdateEventState(pEvent->eid, IMAGE_ERROR, NULL, MAKEINTRESOURCE(idsStateFailed));
            PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
        }
        else
            m_pUI->UpdateEventState(pEvent->eid, IMAGE_EXECUTE, NULL, MAKEINTRESOURCE(idsStateExecuting));
    }

exit:
    LeaveCriticalSection(&m_cs);

    //return (S_OK);
    return hr;
}


HRESULT CSpoolerEngine::_HrDoRasConnect(const LPSPOOLEREVENT pEvent)
    {
    HRESULT hr;
    HWND hwndParent = m_hwndUI;

    // Check to see if we already can connect
    hr = g_pConMan->CanConnect(pEvent->pAccount);
    if (S_OK == hr)
        return (S_OK);

    // Check to see if we're allowed to dial
    if (m_dwFlags & DELIVER_NODIAL)
        return (E_FAIL);

    if (m_dwFlags & DELIVER_DIAL_ALWAYS)
    {
        if (hr == HR_E_OFFLINE)
        {
            g_pConMan->SetGlobalOffline(FALSE);
            m_fOfflineWhenDone = TRUE;
        }
    }

    // Check to see if the parent window exists and is visible
    if (!IsWindow(hwndParent) || !IsWindowVisible(hwndParent))
    {

        // Parent the UI to the browser window
        hwndParent = FindWindowEx(NULL, NULL, c_szBrowserWndClass, 0);
    }

    // Try to connect
    hr = g_pConMan->Connect(pEvent->pAccount, hwndParent, TRUE);
    if (S_OK == hr)
        {
        m_fIDialed = TRUE;
        return S_OK;
        }
    else
        return hr;
    }

HRESULT CSpoolerEngine::_HrGoIdle(void)
    {
    EnterCriticalSection(&m_cs);

    // We need to hangup every time to be compatible with OE4. Bug# 75222
    if (m_fRasSpooled && g_pConMan)
    {
        if (!!DwGetOption(OPT_DIALUP_HANGUP_DONE))
        {
            g_pConMan->Disconnect(m_hwndUI, FALSE, FALSE, FALSE);
        }
    }

    // Check to see if we need to go offline now
    // I'm disabling this for bug #17578.
    if (m_fOfflineWhenDone)
    {
        g_pConMan->SetGlobalOffline(TRUE);
        m_fOfflineWhenDone = FALSE;
    }

    // Tell the UI to idle
    if (ISFLAGSET(m_dwState, SPSTATE_CANCEL))
        m_pUI->GoIdle(m_dwState, ISFLAGSET(m_dwState, SPSTATE_SHUTDOWN), FALSE);
    else
        m_pUI->GoIdle(m_rEventTable.cSucceeded != m_rEventTable.cEvents, ISFLAGSET(m_dwState, SPSTATE_SHUTDOWN),
                        m_fNoSyncEvent && 0 == (m_dwFlags & DELIVER_BACKGROUND));

    // If we're running background and there was errors, then we should show the UI
    if (m_dwFlags & DELIVER_BACKGROUND && !(m_dwFlags & DELIVER_NOUI) &&
        m_rEventTable.cSucceeded != m_rEventTable.cEvents)
        {
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);
        }

    // Free the event table
    for (UINT i = 0; i < m_rEventTable.cEvents; i++)
        {
        SafeRelease(m_rEventTable.prgEvents[i].pSpoolerTask);
        SafeRelease(m_rEventTable.prgEvents[i].pAccount);
        }

    SafeMemFree(m_rEventTable.prgEvents);
    ZeroMemory(&m_rEventTable, sizeof(SPOOLEREVENTTABLE));

    // Leave the busy state
    FLAGCLEAR(m_dwState, SPSTATE_CANCEL);
    FLAGCLEAR(m_dwState, SPSTATE_BUSY);

    // Notify
    Notify(DELIVERY_NOTIFY_ALLDONE, 0);

    // Is Something Queued, and the current poll was a success ?
    if (!ISFLAGSET(m_dwState, SPSTATE_SHUTDOWN))
        {
        if (m_rEventTable.cSucceeded == m_rEventTable.cEvents && m_dwQueued)
            StartDelivery(NULL, NULL, FOLDERID_INVALID, m_dwQueued);
        else
            _StartPolling();
        }

    // Nothing is queued now
    m_dwQueued = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Added Bug# 62129 (v-snatar)
    SetEvent(hSmapiEvent);
    
    return (S_OK);
    }

// ------------------------------------------------------------------------------------
// CSpoolerEngine::_DoBackgroundPoll
// ------------------------------------------------------------------------------------
void CSpoolerEngine::_DoBackgroundPoll(void)
{
    BOOL    fFound = FALSE;
    ULONG   i;
    DWORD   dw;
    DWORD   dwFlags = 0;

    dw = DwGetOption(OPT_DIAL_DURING_POLL);

    switch (dw)
    {
        case DIAL_ALWAYS:
        {
            //connect always
            if (g_pConMan && g_pConMan->IsGlobalOffline())
            {
                g_pConMan->SetGlobalOffline(FALSE);
                m_fOfflineWhenDone = TRUE;
            }
            dwFlags = DELIVER_BACKGROUND_POLL_DIAL_ALWAYS;
            break;
        }

        case DIAL_IF_NOT_OFFLINE: 
        case DO_NOT_DIAL:
        {
            if (g_pConMan && g_pConMan->IsGlobalOffline())
            {
                _StartPolling();
                return;
            }
            if (dw == DIAL_IF_NOT_OFFLINE)
            {
                dwFlags = DELIVER_BACKGROUND_POLL_DIAL;
            }
            else
            {
                dwFlags = DELIVER_BACKGROUND_POLL;
            }
            break;
        }

        default:
            dwFlags = DELIVER_BACKGROUND_POLL_DIAL_ALWAYS;
    }
    
    //We need this flag to tell the spooler that this polling is triggered by the timer.
    //In this case the spooler hangs up the phone if it dialed, irrespective of the option OPT_HANGUP_WHEN_DONE
    dwFlags |= DELIVER_AT_INTERVALS | DELIVER_OFFLINE_FLAGS;

    // Same thread we were created on...
    Assert(ISSPOOLERTHREAD);

    EnterCriticalSection(&m_cs);

    // Are there any registered views...
    for (i = 0; i < m_rViewRegister.cViewAlloc; i++)
    {
        // Is there a view handle
        if (m_rViewRegister.rghwndView[i] && IsWindow(m_rViewRegister.rghwndView[i]))
        {
            fFound=TRUE;
            break;
        }
    }

    LeaveCriticalSection(&m_cs);

    // If at least one view is registered we poll, otherwise we wait
    if (fFound)
    {
        StartDelivery(NULL, NULL, FOLDERID_INVALID, dwFlags);
    }
    else
        m_fBackgroundPollPending = TRUE;
}

void CSpoolerEngine::_StartPolling(void)
    {
    DWORD dw = DwGetOption(OPT_POLLFORMSGS);
    if (dw != OPTION_OFF)
        {
        KillTimer(m_hwndUI, IMAIL_POOLFORMAIL); 

        SetTimer(m_hwndUI, IMAIL_POOLFORMAIL, dw, NULL);
        }
    }

void CSpoolerEngine::_StopPolling(void)
    {
    KillTimer(m_hwndUI, IMAIL_POOLFORMAIL);
    }


STDMETHODIMP CSpoolerEngine::OnUIChange(BOOL fVisible)
    {
    EnterCriticalSection(&m_cs);

    // Check to see if we need to notify the tasks
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
        // Check to see if our flags are up to date
        if (fVisible)
            {
            FLAGCLEAR(m_dwFlags, DELIVER_NOUI);
            FLAGCLEAR(m_dwFlags, DELIVER_BACKGROUND);
            }
        else
            {
            FLAGSET(m_dwFlags, DELIVER_BACKGROUND);
            }

        for (UINT i = m_cCurEvent; i < m_rEventTable.cEvents; i++)
            {
            if (m_rEventTable.prgEvents[i].pSpoolerTask)
                {
                m_rEventTable.prgEvents[i].pSpoolerTask->OnFlagsChanged(m_dwFlags);
                }
            }
        }

    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }

STDMETHODIMP CSpoolerEngine::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, 
                                                CConnectionManager *pConMan)
{

    // If we're not busy, and the user has background polling turned on, then
    // we should fire a poll right now
    /* Bug# 75222
    if (nCode == CONNNOTIFY_CONNECTED && OPTION_OFF != DwGetOption(OPT_POLLFORMSGS))
    {
        if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
            SendMessage(m_hwndUI, WM_TIMER, IMAIL_POOLFORMAIL, 0);
        }
    }
    */
    // If the user just chose "Work Offline", then we cancel anything that's in progress
    if (nCode == CONNNOTIFY_WORKOFFLINE && !!pvData)
    {
        if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
            Cancel();
        }
    }

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\spoolui.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     spoolui.h
//
//  PURPOSE:    Defines the spooler UI classes, prototypes, constants, etc.
//

#ifndef __SPOOLUI_H__
#define __SPOOLUI_H__

#include "spoolapi.h"
#include "msident.h"

class CNewsTask;


/////////////////////////////////////////////////////////////////////////////
// Spooler UI class
//
class CSpoolerDlg : 
        public ISpoolerUI,
        public IIdentityChangeNotify

    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    CSpoolerDlg();
    ~CSpoolerDlg();
    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    
    /////////////////////////////////////////////////////////////////////////
    // ISpoolerUI Interface
    STDMETHOD(Init)(HWND hwndParent);
    STDMETHOD(RegisterBindContext)(ISpoolerBindContext *pBindCtx);
    STDMETHOD(InsertEvent)(EVENTID eid, LPCSTR pszDescription,
                           LPCWSTR pwszConnection);
    STDMETHOD(InsertError)(EVENTID eid, LPCSTR pszError);
    STDMETHOD(UpdateEventState)(EVENTID eid, INT nImage, LPCSTR pszDescription,
                             LPCSTR pszStatus);
    STDMETHOD(SetProgressRange)(WORD wMax);
    STDMETHOD(IncrementProgress)(WORD wDelta);
    STDMETHOD(SetProgressPosition)(WORD wPos);
    STDMETHOD(SetGeneralProgress)(LPCSTR pszProgress);
    STDMETHOD(SetSpecificProgress)(LPCSTR pszProgress);
    STDMETHOD(SetAnimation)(int nAnimationId, BOOL fPlay);
    STDMETHOD(EnsureVisible)(EVENTID eid);
    STDMETHOD(ShowWindow)(int nCmdShow);
    STDMETHOD(GetWindow)(HWND *pHwnd);
    STDMETHOD(StartDelivery)(void); 
    STDMETHOD(GoIdle)(BOOL fErrors, BOOL fShutdown, BOOL fNoSync);
    STDMETHOD(ClearEvents)(void);
    STDMETHOD(SetTaskCounts)(DWORD cSucceeded, DWORD cTotal);
    STDMETHOD(IsDialogMessage)(LPMSG pMsg);
    STDMETHOD(Close)(void);
    STDMETHOD(ChangeHangupOption)(BOOL fEnable, DWORD dwOption);
    STDMETHOD(AreThereErrors)(void);
    STDMETHOD(Shutdown)(void);

    /////////////////////////////////////////////////////////////////////////
    // IIdentityChangeNotify Interface
    virtual STDMETHODIMP QuerySwitchIdentities();
    virtual STDMETHODIMP SwitchIdentities();
    virtual STDMETHODIMP IdentityInformationChanged(DWORD dwType);

    /////////////////////////////////////////////////////////////////////////
    // Dialog message handling
protected:
    static INT_PTR CALLBACK SpoolerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ListSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem);
    void OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpMeasureItem);
    void OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT * lpDeleteItem);
    void OnClose(HWND hwnd);
    void OnDestroy(HWND hwnd);
    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);
    void OnTabChange(LPNMHDR pnmhdr);

    
    /////////////////////////////////////////////////////////////////////////
    // UI Utility functions
    BOOL InitializeTabs(void);
    BOOL InitializeLists(void);
    BOOL InitializeAnimation(void);
    BOOL InitializeToolbar(void);
    void ExpandCollapse(BOOL fExpand, BOOL fSetFocus=TRUE);
    void UpdateLists(BOOL fEvents, BOOL fErrors, BOOL fHistory);
    void ToggleStatics(BOOL fIdle);

    /////////////////////////////////////////////////////////////////////////
    // Class member data
private:    
    ULONG                   m_cRef;         // Object reference count
    
    // Interfaces
    ISpoolerBindContext    *m_pBindCtx;     // Interface to communicate with the engine
    
    // Window handles
    HWND                    m_hwnd;         // Handle of the primary dialog window
    HWND                    m_hwndOwner;    // Handle of the window that parents the dialog
    HWND                    m_hwndEvents;   // Handle of the listview which displays the event list
    HWND                    m_hwndErrors;   // Handle of the listview which displays errors
    
    CRITICAL_SECTION        m_cs;           // Thread safety
    
    // Drawing info
    HIMAGELIST              m_himlImages;   // Images shared by the list views
    DWORD                   m_cxErrors;     // Width of the error list box

    // State
    BOOL                    m_fTack;        // TRUE if the tack is pressed
    BOOL                    m_iTab;         // Which tab currently has the foreground

    BOOL                    m_fExpanded;    // TRUE if the details part of the dialog is visible
    RECT                    m_rcDlg;        // Size of the fully expanded dialog
    DWORD                   m_cyCollapsed;  // Height of the collapsed dialog
    BOOL                    m_fIdle;        // TRUE if we're in an idle state
    BOOL                    m_fErrors;      // Are errors in the error box
    BOOL                    m_fShutdown;    // Are we in shutdown mode
    BOOL                    m_fSaveSize;    // Set to TRUE if we should persist our expanded / collapsed state
    
    // Strings
    TCHAR                   m_szCount[256];

    HICON                   m_hIcon,
                            m_hIconSm;    

    DWORD                   m_dwIdentCookie;
    };


/////////////////////////////////////////////////////////////////////////////
// Structures
//
typedef struct tagLBDATA 
    {
    LPTSTR  pszText;
    RECT    rcText;
    EVENTID eid;
    } LBDATA;

    
/////////////////////////////////////////////////////////////////////////////
// Images
//
enum {
    IMAGE_BLANK = 0,
    IMAGE_TACK_IN,
    IMAGE_TACK_OUT,
    IMAGE_ERROR,
    IMAGE_CHECK,
    IMAGE_BULLET,
    IMAGE_EXECUTE,
    IMAGE_WARNING,
    IMAGE_MAX
};

#define BULLET_WIDTH  20
#define BULLET_INDENT 2

/////////////////////////////////////////////////////////////////////////////
// Tabs on the details dialog
// 
enum { 
    TAB_TASKS,
    TAB_ERRORS,
    TAB_MAX
};

const int c_cxImage = 16;
const int c_cyImage = 16;
    
    
/////////////////////////////////////////////////////////////////////////////
// Resource ID's
//
#define IDC_SP_MINIMIZE                 1001
#define IDC_SP_STOP                     1002
#define IDC_SP_DETAILS                  1003
#define IDC_SP_SEPARATOR                1004
#define IDC_SP_ANIMATE                  1006
#define IDC_SP_PROGRESS_BAR             1007
#define IDC_SP_GENERAL_PROG             1009
#define IDC_SP_SPECIFIC_PROG            1010
#define IDC_SP_TABS                     1011
#define IDC_SP_SKIP_TASK                1012
#define IDC_SP_TACK                     1015
#define IDC_SP_OVERALL_STATUS           1016
#define IDC_SP_EVENTS                   1017
#define IDC_SP_ERRORS                   1018
#define IDC_SP_TOOLBAR                  1019
#define IDC_SP_HANGUP                   1020
#define IDC_SP_IDLETEXT                 1021
#define IDC_SP_IDLEICON                 1022
#define IDC_SP_PROGSTAT                 1023

#endif // __SPOOLUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\spoolapi.h ===
// ---------------------------------------------------------------------------------------
// Spoolapi.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// ---------------------------------------------------------------------------------------
#ifndef __SPOOLAPI_H
#define __SPOOLAPI_H

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern BOOL g_fCheckOutboxOnShutdown;

// ---------------------------------------------------------------------------------------
// Forward Decls
// ---------------------------------------------------------------------------------------
interface ISpoolerEngine;
interface ISpoolerBindContext;
interface ISpoolerTask;
interface ISpoolerUI;
interface IImnAccount;

#include "error.h"  // This get's the ATH_HR_x() macros
               

// ---------------------------------------------------------------------------------------
// Errors
// ---------------------------------------------------------------------------------------
#define SP_HR_FIRST 0x2000
#define SP_E_ALREADYINITIALIZED                         ATH_HR_E(SP_HR_FIRST + 1)
#define SP_E_UNINITIALIZED                              ATH_HR_E(SP_HR_FIRST + 2)
#define SP_E_EVENTNOTFOUND                              ATH_HR_E(SP_HR_FIRST + 3)
#define SP_E_EXECUTING                                  ATH_HR_E(SP_HR_FIRST + 4)
#define SP_E_CANNOTCONNECT                              ATH_HR_E(SP_HR_FIRST + 5)
#define SP_E_HTTP_NOSENDMSGURL                          ATH_HR_E(SP_HR_FIRST + 6)
#define SP_E_HTTP_SERVICEDOESNTWORK                     ATH_HR_E(SP_HR_FIRST + 7)
#define SP_E_HTTP_NODELETESUPPORT                       ATH_HR_E(SP_HR_FIRST + 8)
#define SP_E_HTTP_CANTMODIFYMSNFOLDER                   ATH_HR_E(SP_HR_FIRST + 9)

// ---------------------------------------------------------------------------------------
// SMTP Task Errors
// ---------------------------------------------------------------------------------------
#define SP_E_SMTP_CANTOPENMESSAGE                       ATH_HR_E(SP_HR_FIRST + 200)
#define SP_E_SENDINGSPLITGROUP                          ATH_HR_E(SP_HR_FIRST + 202)
#define SP_E_CANTLEAVEONSERVER                          ATH_HR_E(SP_HR_FIRST + 203)
#define SP_E_CANTLOCKUIDLCACHE                          ATH_HR_E(SP_HR_FIRST + 204)
#define SP_E_POP3_RETR                                  ATH_HR_E(SP_HR_FIRST + 205)
#define SP_E_CANT_MOVETO_SENTITEMS                      ATH_HR_E(SP_HR_FIRST + 206)

// ---------------------------------------------------------------------------------------
// Spooler Types
// ---------------------------------------------------------------------------------------
typedef DWORD EVENTID;
typedef LPDWORD LPEVENTID;

// ---------------------------------------------------------------------------------------
// Spooler Delivery Types
// ---------------------------------------------------------------------------------------

// Common delivery flags
#define DELIVER_COMMON_MASK              0x000000FF
#define DELIVER_BACKGROUND               0x00000001   // No progress UI, but will show errors at the end if DELIVER_NOUI not specified
#define DELIVER_NOUI                     0x00000002   // No UI at all.  Errors are silently ignored.
#define DELIVER_NODIAL                   0x00000004   // Not allowed to change the current connection
#define DELIVER_POLL                     0x00000008   // Poll for new messages
#define DELIVER_QUEUE                    0x00000010   // A request was made while busy
#define DELIVER_SHOW                     0x00000020   // Simply show the spooler UI
#define DELIVER_REFRESH                  0x00000040   // Simply refresh based on background, noui
#define DELIVER_DIAL_ALWAYS              0x00000080

// Mail delivery flags
#define DELIVER_MAIL_MASK                0x0000FF00
#define DELIVER_SEND                     0x00000100
#define DELIVER_MAIL_RECV                0x00000200
#define DELIVER_MAIL_NOSKIP              0x00000400
#define DELIVER_MAIL_SENDRECV            (DELIVER_SEND | DELIVER_MAIL_RECV | DELIVER_IMAP_TYPE \
                                          | DELIVER_HTTP_TYPE | DELIVER_SMTP_TYPE)

//Flag to distinguish between Send&Receive and synchronize
#define DELIVER_OFFLINE_SYNC             0x00000800               

//Flag to distinguish between Send&Receive triggered by timer and Send&Receive invoked by the user
//We need to distinguish these because we hangup the phone in the first case, if we dialed
#define DELIVER_AT_INTERVALS             0x00001000               
#define DELIVER_OFFLINE_HEADERS          0x00002000
#define DELIVER_OFFLINE_NEW              0x00004000
#define DELIVER_OFFLINE_ALL              0x00008000
#define DELIVER_OFFLINE_MARKED           0x00010000
#define DELIVER_NOSKIP                   0x00020000
#define DELIVER_NO_NEWSPOLL              0x00040000
#define DELIVER_WATCH                    0x00080000

//The first three bits are reserved for Server Types
#define DELIVER_NEWS_TYPE                0x00100000
#define DELIVER_IMAP_TYPE                0x00200000
#define DELIVER_HTTP_TYPE                0x00400000
#define DELIVER_SMTP_TYPE                0x00800000


#define DELIVER_MAIL_SEND                (DELIVER_SEND | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE)
#define DELIVER_NEWS_SEND                (DELIVER_SEND | DELIVER_NEWS_TYPE)

#define DELIVER_SERVER_TYPE_MASK         0x00F00000
#define DELIVER_SERVER_TYPE_ALL          0x00F00000

#define DELIVER_OFFLINE_FLAGS            (DELIVER_OFFLINE_HEADERS | DELIVER_OFFLINE_NEW | \
                                          DELIVER_OFFLINE_ALL | DELIVER_OFFLINE_MARKED)

#define DELIVER_IMAP_MASK                (DELIVER_IMAP_TYPE | DELIVER_OFFLINE_FLAGS)
#define DELIVER_NEWS_MASK                (DELIVER_NEWS_TYPE | DELIVER_OFFLINE_FLAGS)

/*
// News delivery flags
#define DELIVER_NEWS_MASK                0x007F0000
#define DELIVER_NEWS_SEND                0x00010000

// IMAP delivery flags
#define DELIVER_IMAP_MASK                0x007E0000


// Combined News and IMAP delivery flags
#define DELIVER_NEWSIMAP_OFFLINE         0x00020000 // General offline for server, when "Sync Now" button in AcctView pushed
#define DELIVER_NEWSIMAP_OFFLINE_HEADERS 0x00040000
#define DELIVER_NEWSIMAP_OFFLINE_NEW     0x00080000
#define DELIVER_NEWSIMAP_OFFLINE_ALL     0x00100000
#define DELIVER_NEWSIMAP_OFFLINE_MARKED  0x00200000
#define DELIVER_NEWSIMAP_OFFLINE_FLAGS   (DELIVER_NEWSIMAP_OFFLINE_HEADERS | DELIVER_NEWSIMAP_OFFLINE_NEW | DELIVER_NEWSIMAP_OFFLINE_ALL | DELIVER_NEWSIMAP_OFFLINE_MARKED)
#define DELIVER_NEWSIMAP_NOSKIP          0x00400000
*/


// Combinations
#define DELIVER_BACKGROUND_POLL         (DELIVER_NODIAL | DELIVER_BACKGROUND | DELIVER_NOUI | DELIVER_POLL | DELIVER_WATCH | \
                                         DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_SERVER_TYPE_ALL)

#define DELIVER_BACKGROUND_POLL_DIAL    (DELIVER_BACKGROUND | DELIVER_NOUI | DELIVER_POLL | DELIVER_WATCH | \
                                         DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_SERVER_TYPE_ALL)

#define DELIVER_BACKGROUND_POLL_DIAL_ALWAYS (DELIVER_DIAL_ALWAYS | DELIVER_BACKGROUND | DELIVER_NOUI | DELIVER_POLL | DELIVER_WATCH | \
                                             DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_SERVER_TYPE_ALL)

#define DELIVER_UPDATE_ALL              (DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_POLL | DELIVER_WATCH | \
                                         DELIVER_OFFLINE_FLAGS | DELIVER_SERVER_TYPE_ALL)

// ---------------------------------------------------------------------------------------
// Event completion types
// ---------------------------------------------------------------------------------------
typedef enum tagEVENTCOMPLETEDSTATUS {
    EVENT_SUCCEEDED,
    EVENT_WARNINGS,
    EVENT_FAILED,
    EVENT_CANCELED
} EVENTCOMPLETEDSTATUS;

// ------------------------------------------------------------------------------------
// DELIVERYNOTIFYTYPE
// ------------------------------------------------------------------------------------
typedef enum tagDELIVERYNOTIFYTYPE {
    DELIVERY_NOTIFY_STARTING,       // Sent by spengine when a delivery cycle starts
    DELIVERY_NOTIFY_CONNECTING,
    DELIVERY_NOTIFY_SECURE,
    DELIVERY_NOTIFY_UNSECURE,
    DELIVERY_NOTIFY_AUTHORIZING,
    DELIVERY_NOTIFY_CHECKING,
    DELIVERY_NOTIFY_CHECKING_NEWS,
    DELIVERY_NOTIFY_SENDING,
    DELIVERY_NOTIFY_SENDING_NEWS,
    DELIVERY_NOTIFY_RECEIVING,
    DELIVERY_NOTIFY_RECEIVING_NEWS,
    DELIVERY_NOTIFY_COMPLETE,       // lParam == n new messages
    DELIVERY_NOTIFY_RESULT,         // lParam == EVENTCOMPLETEDSTATUS
    DELIVERY_NOTIFY_ALLDONE         // Sent by spengine when all tasks have completed
} DELIVERYNOTIFYTYPE;

// ------------------------------------------------------------------------------------
// TRAYICONTYPE
// ------------------------------------------------------------------------------------
typedef enum tagTRAYICONTYPE {
    TRAYICON_ADD,
    TRAYICON_REMOVE
} TRAYICONTYPE;

// ---------------------------------------------------------------------------------------
// IID_ISpoolerEngine
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerEngine, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpooerEngine members
    // -----------------------------------------------------------------------------------
    STDMETHOD(Init)(THIS_ ISpoolerUI *pUI, BOOL fPoll) PURE;
    STDMETHOD(StartDelivery)(THIS_ HWND hwnd, LPCSTR pszAcctID, FOLDERID idFolder, DWORD dwFlags) PURE;
    STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(Advise)(THIS_ HWND hwndView, BOOL fRegister) PURE;
    STDMETHOD(GetThreadInfo)(THIS_ LPDWORD pdwThreadId, HTHREAD* phThread) PURE;
    STDMETHOD(UpdateTrayIcon)(THIS_ TRAYICONTYPE type) PURE;
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(OnStartupFinished)(THIS) PURE;
};

// ---------------------------------------------------------------------------------------
// IID_ISpoolerBindContext
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerBindContext, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpoolerBindContext members
    // -----------------------------------------------------------------------------------
    STDMETHOD(UpdateTrayIcon)(THIS_ TRAYICONTYPE type) PURE;
    STDMETHOD(RegisterEvent)(THIS_ LPCSTR pszDescription, ISpoolerTask *pTask, DWORD_PTR dwTwinkie, IImnAccount *pAccount, LPEVENTID peid) PURE;
    STDMETHOD(EventDone)(THIS_ EVENTID eid, EVENTCOMPLETEDSTATUS status) PURE;
    STDMETHOD(BindToObject)(THIS_ REFIID riid, LPVOID *ppvObject) PURE;
    STDMETHOD(TaskFromEventId)(THIS_ EVENTID eid, ISpoolerTask *ppTask) PURE;
    STDMETHOD(OnWindowMessage)(THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(Cancel)(THIS) PURE;
    STDMETHOD(Notify)(THIS_ DELIVERYNOTIFYTYPE notify, LPARAM lParam) PURE;
    STDMETHOD(PumpMessages)(THIS) PURE;
    STDMETHOD(UIShutdown)(THIS) PURE;
    STDMETHOD(OnUIChange)(THIS_ BOOL fVisible) PURE;
    STDMETHOD_(LRESULT, QueryEndSession)(THIS_ WPARAM wParam, LPARAM lParam) PURE;
};

// ---------------------------------------------------------------------------------------
// IID_ISpoolerTask
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerTask, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpoolerTask members
    // -----------------------------------------------------------------------------------
    STDMETHOD(Init)(THIS_ DWORD dwFlags, ISpoolerBindContext *pBindCtx) PURE;
    STDMETHOD(BuildEvents)(THIS_ ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder) PURE;
    STDMETHOD(Execute)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie) PURE;
    STDMETHOD(CancelEvent)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie) PURE;
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) PURE;
    STDMETHOD(GetExtendedDetails)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) PURE; 
    STDMETHOD(Cancel)(THIS) PURE;
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(OnFlagsChanged)(THIS_ DWORD dwFlags) PURE;
};

// ---------------------------------------------------------------------------------------
// IID_ISpoolerUI
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerUI, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpoolerUI members
    // -----------------------------------------------------------------------------------
    STDMETHOD(Init)(THIS_ HWND hwndParent) PURE;
    STDMETHOD(RegisterBindContext)(THIS_ ISpoolerBindContext *pBindCtx) PURE;
    STDMETHOD(InsertEvent)(THIS_ EVENTID eid, LPCSTR pszDescription, LPCWSTR pszConnection) PURE;
    STDMETHOD(InsertError)(THIS_ EVENTID eid, LPCSTR pszError) PURE;
    STDMETHOD(UpdateEventState)(THIS_ EVENTID eid, INT nIcon, LPCSTR pszDescription, LPCSTR pszStatus) PURE;
    STDMETHOD(SetProgressRange)(THIS_ WORD wMax) PURE;
    STDMETHOD(SetProgressPosition)(WORD wPos) PURE;
    STDMETHOD(IncrementProgress)(THIS_ WORD  wDelta) PURE;
    STDMETHOD(SetGeneralProgress)(THIS_ LPCSTR pszProgress) PURE;
    STDMETHOD(SetSpecificProgress)(THIS_ LPCSTR pszProgress) PURE;
    STDMETHOD(SetAnimation)(THIS_ INT nAnimationID, BOOL fPlay) PURE;
    STDMETHOD(EnsureVisible)(THIS_ EVENTID eid) PURE;
    STDMETHOD(ShowWindow)(THIS_ INT nCmdShow) PURE;
    STDMETHOD(GetWindow)(THIS_ HWND *pHwnd) PURE;
    STDMETHOD(StartDelivery)(THIS) PURE;            
    STDMETHOD(GoIdle)(THIS_ BOOL fErrors, BOOL fShutdown, BOOL fNoSync) PURE;
    STDMETHOD(ClearEvents)(THIS) PURE;
    STDMETHOD(SetTaskCounts)(THIS_ DWORD cSucceeded, DWORD cTotal) PURE;
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(ChangeHangupOption)(THIS_ BOOL fEnable, DWORD dwOption) PURE;
    STDMETHOD(AreThereErrors)(THIS) PURE;
    STDMETHOD(Shutdown)(THIS) PURE;
};

// ------------------------------------------------------------------------------------
// Exported C Functions
// ------------------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif

typedef HRESULT (APIENTRY *PFNCREATESPOOLERUI)(ISpoolerUI **ppSpoolerUI);

HRESULT CreateThreadedSpooler(
        /* in */     PFNCREATESPOOLERUI       pfnCreateUI,
        /* out */    ISpoolerEngine         **ppSpooler,
        /* in */     BOOL                     fPoll);

HRESULT CloseThreadedSpooler(
        /* in */     ISpoolerEngine *pSpooler);

#ifdef __cplusplus
}
#endif

#endif // __SPOOLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\spoolui.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     spoolui.cpp
//
//  PURPOSE:    Implements the spooler UI dialogs.
//

#include "pch.hxx"
#include "resource.h"
#include "spoolui.h"
#include "goptions.h"
#include "imnact.h"
#include "thormsgs.h"
#include "shlwapip.h" 
#include "spengine.h"
#include "ourguid.h"
#include "demand.h"
#include "menures.h"
#include "multiusr.h"

ASSERTDATA

static const char c_szWndProc[] = "WndProc";

//
//  FUNCTION:   CSpoolerDlg::CSpoolerDlg()
//
//  PURPOSE:    Initializes the member variables of the spooler ui object.
//
CSpoolerDlg::CSpoolerDlg()
    {
    m_cRef = 1;
    
    m_pBindCtx = NULL;
    
    m_hwnd = NULL;
    m_hwndOwner = NULL;
    m_hwndEvents = NULL;
    m_hwndErrors = NULL;
    
    InitializeCriticalSection(&m_cs);
   
    m_himlImages = NULL;

    m_fTack = FALSE;
    m_iTab = 0;
    m_fIdle = FALSE;
    m_fErrors = FALSE;
    m_fShutdown = FALSE;
    m_fSaveSize = FALSE;

    m_fExpanded = TRUE;
    ZeroMemory(&m_rcDlg, sizeof(RECT));
    m_cyCollapsed = 0;

    m_szCount[0] = '\0';
    
    m_hIcon=NULL;
    m_hIconSm=NULL;
    m_dwIdentCookie = 0;
    }

//
//  FUNCTION:   CSpoolerDlg::~CSpoolerDlg()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
CSpoolerDlg::~CSpoolerDlg()
    {
    GoIdle(TRUE, FALSE, FALSE);

    if (m_hwnd && IsWindow(m_hwnd))
        DestroyWindow(m_hwnd);
    if (m_himlImages)
        ImageList_Destroy(m_himlImages);
    SafeRelease(m_pBindCtx);
    DeleteCriticalSection(&m_cs);
    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));
    if (m_hIconSm)
        SideAssert(DestroyIcon(m_hIconSm));

    }


//
//  FUNCTION:   CSpoolerDlg::Init()
//
//  PURPOSE:    Creates the spooler dialog.  The dialog is not initially 
//              visible.
//
//  PARAMETERS:
//      <in> hwndOwner - Handle of the window to parent the dialog to.
//
//  RETURN VALUE:
//      S_OK - The dialog was created and initialized
//      E_OUTOFMEMORY - The dialog could not be created
//      E_INVALIDARG - Think about it.
//
HRESULT CSpoolerDlg::Init(HWND hwndOwner)
    {
    int iReturn = -1;
    HWND hwnd, hwndActive;
    
    // Verify the arguments
    if (!IsWindow(hwndOwner))
        return (E_INVALIDARG);
    
    // Make a copy    
    m_hwndOwner = hwndOwner;
    
    // Invoke the dialog
    hwndActive = GetForegroundWindow();

    hwnd = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddSpoolerDlg), m_hwndOwner,
           SpoolerDlgProc, (LPARAM) this);

    if (hwndActive != GetForegroundWindow())
        SetForegroundWindow(hwndActive);

    // Set the dialog icon
    m_hIcon = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idiMail), IMAGE_ICON, 32, 32, 0);
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
    m_hIconSm = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idiMail), IMAGE_ICON, 16, 16, 0);
    SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

    SetTaskCounts(0, 0);

    // Register with identity manager
    SideAssert(SUCCEEDED(MU_RegisterIdentityNotifier((IUnknown *)(ISpoolerUI *)this, &m_dwIdentCookie)));

    return (IsWindow(hwnd) ? S_OK : E_OUTOFMEMORY);
    }
    
    
HRESULT CSpoolerDlg::QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
    if (NULL == *ppvObj)
        return (E_INVALIDARG);
        
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID)(IUnknown *)(ISpoolerUI *) this;
    
    else if (IsEqualIID(riid, IID_ISpoolerUI))
        *ppvObj = (LPVOID)(ISpoolerUI *) this;

    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (LPVOID)(IIdentityChangeNotify *) this;

    if (NULL == *ppvObj)    
        return (E_NOINTERFACE);
    
    AddRef();
    return (S_OK);    
    }


ULONG CSpoolerDlg::AddRef(void)
    {
    m_cRef++;
    return (m_cRef);
    }    


ULONG CSpoolerDlg::Release(void)
    {
    ULONG cRefT = --m_cRef;
    
    if (0 == m_cRef)
        delete this;
    
    return (cRefT);    
    }


//
//  FUNCTION:   CSpoolerDlg::RegisterBindContext()
//
//  PURPOSE:    Allows the spooler engine to provide us with a bind context
//              interface for us to call back into.
//
//  PARAMETERS:
//      <in> pBindCtx - Pointer to the engine's bind context interface
//
//  RETURN VALUE:
//      E_INVALIDARG
//      S_OK
//
HRESULT CSpoolerDlg::RegisterBindContext(ISpoolerBindContext *pBindCtx)
    {
    if (NULL == pBindCtx)
        return (E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);    
    
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();
    
    LeaveCriticalSection(&m_cs);
    
    return (S_OK);    
    }


//
//  FUNCTION:   CSpoolerDlg::InsertEvent()
//
//  PURPOSE:    Allows a caller to insert an event into our event list UI.
//
//  PARAMETERS:
//      <in> eid - Event ID for this new event
//      <in> pszDescription - Description of the event
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      E_OUTOFMEMORY
//
HRESULT CSpoolerDlg::InsertEvent(EVENTID eid, LPCTSTR pszDescription, 
                                 LPCWSTR pwszConnection)
{
    HRESULT hr=S_OK;
    LV_ITEM lvi;
    int     iItem = -1;
    TCHAR   szRes[CCHMAX_STRINGRES];
    
    // Verify the arguments
    if (0 == pszDescription)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);    
    
    // Make sure the listview has been initialized
    if (!IsWindow(m_hwndEvents))    
        hr = SP_E_UNINITIALIZED;    
    else
    {
        // Insert the item into the listview
        ZeroMemory(&lvi, sizeof(LV_ITEM));
        lvi.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.iItem    = ListView_GetItemCount(m_hwndEvents);
        lvi.iSubItem = 0;
        lvi.lParam   = (LPARAM) eid;
        lvi.iImage   = IMAGE_BLANK;
        
        if (IS_INTRESOURCE(pszDescription))
        {
            AthLoadString(PtrToUlong(pszDescription), szRes, ARRAYSIZE(szRes));
            lvi.pszText = szRes;
        }
        else
            lvi.pszText  = (LPTSTR) pszDescription;

        iItem = ListView_InsertItem(m_hwndEvents, &lvi);    
        Assert(iItem != -1);
        if (iItem == -1)    
            hr = E_OUTOFMEMORY;
        else
        {
            LVITEMW     lviw = {0};
            
            lviw.iSubItem = 2;
            lviw.pszText  = (LPWSTR)pwszConnection;
            SendMessage(m_hwndEvents, LVM_SETITEMTEXTW, (WPARAM)iItem, (LPARAM)&lviw);
        }
    }

    LeaveCriticalSection(&m_cs);
       
    return hr;
}    

    
//
//  FUNCTION:   CSpoolerDlg::InsertError()
//
//  PURPOSE:    Allows a task to insert an error into our error list UI.
//
//  PARAMETERS:
//      <in> eid      - The event ID of the event that had the error.
//      <in> pszError - Description of the error. 
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      E_OUTOFMEMORY
//
HRESULT CSpoolerDlg::InsertError(EVENTID eid, LPCTSTR pszError)
    {
    HRESULT  hr = S_OK;
    LBDATA  *pData = NULL;
    int      nItem;
    HDC      hdc;
    HFONT    hfont;

    // Verify the arguments
    if (0 == pszError)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);    
    
    // Make sure the listview has been initialized
    if (!IsWindow(m_hwndErrors))    
        hr = SP_E_UNINITIALIZED;    
    else
        {
        // Allocate a struct for the item data
        if (!MemAlloc((LPVOID *) &pData, sizeof(LBDATA)))
            {
            hr = E_OUTOFMEMORY;
            goto exit;
            }

        pData->eid = eid;

        // Check to see if we need to load the string ourselves
        if (IS_INTRESOURCE(pszError))
            {
            pData->pszText = AthLoadString(PtrToUlong(pszError), 0, 0);
            }
        else
            pData->pszText = PszDupA(pszError);

        // Get the size of the string
        hfont = (HFONT) SendMessage(m_hwnd, WM_GETFONT, 0, 0);

        hdc = GetDC(m_hwndErrors);
        SelectFont(hdc, hfont);

        SetRect(&(pData->rcText), 0, 0, m_cxErrors - BULLET_WIDTH - 4, 0);
        // bug #47453, add DT_INTERNAL flag so that on FE platform (PRC and TC)
        // two list items is not overlapping. 
        DrawText(hdc, pData->pszText, -1, &(pData->rcText), DT_CALCRECT | DT_WORDBREAK | DT_INTERNAL);
        ReleaseDC(m_hwndErrors, hdc);

        pData->rcText.bottom += 4;
        
        // Add the item data
        nItem = ListBox_AddItemData(m_hwndErrors, pData);    
        }

exit:
    LeaveCriticalSection(&m_cs);    
    return hr;
    }


//
//  FUNCTION:   CSpoolerDlg::UpdateEventState()
//
//  PURPOSE:    Allows a task to update the description and state of an event.
//
//  PARAMETERS:
//      <in> eid            - ID of the event to update
//      <in> nImage         - Image to display for the item.  If this is -1, 
//                            the image is not changed.
//      <in> pszDescription - Description for the item.  If this is NULL, the 
//                            description is not changed.
//      <in> pszStatus      - Status of the item.  If this is NULL, the status
//                            is not changed.
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      SP_E_EVENTNOTFOUND
//      E_UNEXPECTED
//
HRESULT CSpoolerDlg::UpdateEventState(EVENTID eid, INT nImage, 
                                      LPCTSTR pszDescription, LPCTSTR pszStatus)
    {
    LV_ITEM     lvi;
    LV_FINDINFO lvfi;
    int         iItem = -1;
    BOOL        fSuccess = FALSE;
    HRESULT     hr = S_OK;
    TCHAR       szRes[CCHMAX_STRINGRES];
    
    EnterCriticalSection(&m_cs);

    ZeroMemory(&lvi, sizeof(LV_ITEM));

    // See if we're initialized
    if (!IsWindow(m_hwndEvents))
        {
        hr = SP_E_UNINITIALIZED;
        goto exit;
        }
    
    // Start by finding the event in our list
    lvfi.flags  = LVFI_PARAM;
    lvfi.psz    = 0;
    lvfi.lParam = eid;    
    
    iItem = ListView_FindItem(m_hwndEvents, -1, &lvfi);
    if (-1 == iItem)
        {
        hr = SP_E_EVENTNOTFOUND;
        goto exit;
        }
    
    // Update the image and description
    lvi.mask = 0;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;    
    
    // Set up the image info
    if (-1 != nImage)    
        {
        lvi.mask = LVIF_IMAGE;
        lvi.iImage = nImage;
        }
        
    // Set up the description text
    if (NULL != pszDescription)
        {
        // Check to see if we need to load the string ourselves
        if (IS_INTRESOURCE(pszDescription))
            {
            AthLoadString(PtrToUlong(pszDescription), szRes, ARRAYSIZE(szRes));
            lvi.pszText = szRes;
            }
        else
            lvi.pszText  = (LPTSTR) pszDescription;

        lvi.mask |= LVIF_TEXT;
        }
    
    if (lvi.mask)
        fSuccess = ListView_SetItem(m_hwndEvents, &lvi);
    
    // Update the status
    if (NULL != pszStatus)
        {
        // Check to see if we need to load the string ourselves
        if (IS_INTRESOURCE(pszStatus))
            {
            AthLoadString(PtrToUlong(pszStatus), szRes, ARRAYSIZE(szRes));
            lvi.pszText = szRes;
            }
        else
            lvi.pszText  = (LPTSTR) pszStatus;

        lvi.mask     = LVIF_TEXT;
        lvi.iSubItem = 1;           
        
        ListView_SetItemText(m_hwndEvents, lvi.iItem, 1, lvi.pszText); /* fSuccess = fSuccess && */
        }
        
    hr = fSuccess ? S_OK : E_UNEXPECTED;

exit:
    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::SetProgressRange()
//
//  PURPOSE:    Resets the progress bar to zero, and then sets the upper bound
//              to the specified amount.
//
//  PARAMETERS:
//      <in> wMax - New maximum range for the progress bar
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetProgressRange(WORD wMax)
    {
    HWND    hwndProg = GetDlgItem(m_hwnd, IDC_SP_PROGRESS_BAR);
    HRESULT hr = S_OK;
    
    if (wMax == 0)
        return (E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);

    // Make sure we have a progress bar
    if (!IsWindow(hwndProg))
        hr = SP_E_UNINITIALIZED;
    else
        {
        // Reset the progress bar    
        SendMessage(hwndProg, PBM_SETPOS, 0, 0);
    
        // Set the new range
        SendMessage(hwndProg, PBM_SETRANGE, 0, MAKELPARAM(0, wMax));
        }
    
    LeaveCriticalSection(&m_cs);    
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::IncrementProgress()
//
//  PURPOSE:    Increments the progress bar by a specified amount.
//
//  PARAMETERS:
//      <in> wDelta - Amount to increment the progress bar by
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::IncrementProgress(WORD wDelta)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);
    
    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else        
        SendDlgItemMessage(m_hwnd, IDC_SP_PROGRESS_BAR, PBM_DELTAPOS, wDelta, 0);

    LeaveCriticalSection(&m_cs);    
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::SetProgressPosition()
//
//  PURPOSE:    Sets the progress bar to a specific position.
//
//  PARAMETERS:
//      <in> wPos - Position to set progress bar to
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetProgressPosition(WORD wPos)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);
    
    if (wPos < 0)
        hr = E_INVALIDARG;
    else if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        SendDlgItemMessage(m_hwnd, IDC_SP_PROGRESS_BAR, PBM_SETPOS, wPos, 0);

    LeaveCriticalSection(&m_cs);
    return (hr);
    }

//
//  FUNCTION:   CSpoolerDlg::SetGeneralProgress()
//
//  PURPOSE:    Allows the caller to update the general progress text.
//
//  PARAMETERS:
//      <in> pszProgress - New progress string
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetGeneralProgress(LPCTSTR pszProgress)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        {
        if (pszProgress)
            SetDlgItemText(m_hwnd, IDC_SP_GENERAL_PROG, pszProgress);
        else
            SetDlgItemText(m_hwnd, IDC_SP_GENERAL_PROG, _T(""));
        }

    LeaveCriticalSection(&m_cs);    
    return (hr);    
    }    


//
//  FUNCTION:   CSpoolerDlg::SetSpecificProgress()
//
//  PURPOSE:    Allows the caller to update the specific progress text.
//
//  PARAMETERS:
//      <in> pszProgress - New progress string
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetSpecificProgress(LPCTSTR pszProgress)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        {
        TCHAR szRes[CCHMAX_STRINGRES];
        if (IS_INTRESOURCE(pszProgress))
            {
            AthLoadString(PtrToUlong(pszProgress), szRes, ARRAYSIZE(szRes));
            pszProgress = szRes;
            }

        if (pszProgress)
            SetDlgItemText(m_hwnd, IDC_SP_SPECIFIC_PROG, pszProgress);
        else
            SetDlgItemText(m_hwnd, IDC_SP_SPECIFIC_PROG, _T(""));
        }
    
    LeaveCriticalSection(&m_cs);    
    return (hr);
    }    


//
//  FUNCTION:   CSpoolerDlg::SetAnimation()
//
//  PURPOSE:    Allows the caller to choose which animation is playing
//
//  PARAMETERS:
//      <in> nAnimationID - New resource id for the animation
//      <in> fPlay - TRUE if we should start animating it.
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetAnimation(int nAnimationID, BOOL fPlay)
    {
    HRESULT hr = S_OK;
    HWND    hwndAni;

    EnterCriticalSection(&m_cs);
#ifndef _WIN64
    if (!IsWindow(m_hwnd) || !IsWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE)))
        hr = SP_E_UNINITIALIZED;
    else
        {
        hwndAni = GetDlgItem(m_hwnd, IDC_SP_ANIMATE);
        Animate_Close(hwndAni);

        if (IsWindow(m_hwnd) && IsWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE)))
            {
            Animate_OpenEx(hwndAni, g_hLocRes, MAKEINTRESOURCE(nAnimationID));

            if (fPlay)
                Animate_Play(hwndAni, 0, -1, -1);
            }
        }
#endif // _WIN64    
    LeaveCriticalSection(&m_cs);    
    return (hr);
    }    


//
//  FUNCTION:   CSpoolerDlg::EnsureVisible()
//
//  PURPOSE:    Ensures that the specified event is visible within the listview
//
//  PARAMETERS:
//      <in> eid - Event ID to make sure is visible
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      SP_E_EVENTNOTFOUND
//      S_OK
//
HRESULT CSpoolerDlg::EnsureVisible(EVENTID eid)
    {
    LV_FINDINFO lvfi;
    int         iItem = -1;
    HRESULT     hr = S_OK;
    
    EnterCriticalSection(&m_cs);

    // See if we're initialized
    if (!IsWindow(m_hwndEvents))
        hr = SP_E_UNINITIALIZED;
    else
        {
        // Start by finding the event in our list
        lvfi.flags  = LVFI_PARAM;
        lvfi.psz    = 0;
        lvfi.lParam = eid;
    
        iItem = ListView_FindItem(m_hwndEvents, -1, &lvfi);       
    
        // Now tell the listview to make sure it's visible
        if (-1 != iItem)
            ListView_EnsureVisible(m_hwndEvents, iItem, FALSE);

        hr = (iItem == -1) ? SP_E_EVENTNOTFOUND : S_OK;
        }
    
    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::ShowWindow()
//
//  PURPOSE:    Shows or hides the spooler dialog
//
//  PARAMETERS:
//      <in> nCmdShow - This is the same as the ShowWindow() API
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::ShowWindow(int nCmdShow)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        {
        ::ShowWindow(m_hwnd, nCmdShow);
        if (m_pBindCtx)
            m_pBindCtx->OnUIChange(nCmdShow == SW_SHOW);
        }       

    LeaveCriticalSection(&m_cs);
    
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::StartDelivery()
//
//  PURPOSE:    Tells the dialog the delivery has begun.
//
//  RETURN VALUE:
//      S_OK
//      SP_E_UNINITIALIZED
//
HRESULT CSpoolerDlg::StartDelivery(void)
    {
    HRESULT hr = SP_E_UNINITIALIZED;

    EnterCriticalSection(&m_cs);

    if (IsWindow(m_hwnd))
        {
        //Animate_Play(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), 0, -1, -1);
        
        TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), TAB_TASKS);
        OnTabChange(0);

        ToggleStatics(FALSE);
        SetDlgItemText(m_hwnd, IDC_SP_GENERAL_PROG, _T(""));
        SetDlgItemText(m_hwnd, IDC_SP_SPECIFIC_PROG, _T(""));
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);

        hr = S_OK;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::ClearEvents()
//
//  PURPOSE:    Clears any events and errors out of the listviews.
//
//  RETURN VALUE:
//      S_OK
//      SP_E_UNINITIALIZED
//
HRESULT CSpoolerDlg::ClearEvents(void)
    {
    HRESULT hr = SP_E_UNINITIALIZED;

    EnterCriticalSection(&m_cs);

    if (IsWindow(m_hwnd))
        {
        m_fErrors = FALSE;
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);
        ListView_DeleteAllItems(m_hwndEvents);
        ListBox_ResetContent(m_hwndErrors);
        hr = S_OK;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CSpoolerDlg::SetTaskCounts(DWORD cSucceeded, DWORD cTotal)
    {
    TCHAR szBuf[CCHMAX_STRINGRES];
    HRESULT hr = SP_E_UNINITIALIZED;

    EnterCriticalSection(&m_cs);
    
    if (IsWindow(m_hwnd))
        {
        wnsprintf(szBuf, ARRAYSIZE(szBuf), m_szCount, cSucceeded, cTotal);
        SetDlgItemText(m_hwnd, IDC_SP_OVERALL_STATUS, szBuf);
        hr = S_OK;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CSpoolerDlg::AreThereErrors(void)
    {
    EnterCriticalSection(&m_cs);
    HRESULT hr = (m_fErrors ? S_OK : S_FALSE);
    LeaveCriticalSection(&m_cs);
    return hr;
    }

HRESULT CSpoolerDlg::Shutdown(void)
    {
    CHAR szRes[255];

    EnterCriticalSection(&m_cs);

    m_fShutdown = TRUE;

    if (IsWindow(m_hwnd))
        {
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_MINIMIZE), TRUE);

        LoadString(g_hLocRes, idsClose, szRes, ARRAYSIZE(szRes));
        SetDlgItemText(m_hwnd, IDC_SP_MINIMIZE, szRes);
        }

    LeaveCriticalSection(&m_cs);

    return S_OK;
    }

//
//  FUNCTION:   CSpoolerDlg::GoIdle()
//
//  PURPOSE:    Tells the dialog the delivery has ended.
//
//  PARAMETERS:
//      <in> fErrors - TRUE if errors occured during the download.
//
//  RETURN VALUE:
//      S_OK
//      SP_E_UNINITIALIZED
//
HRESULT CSpoolerDlg::GoIdle(BOOL fErrors, BOOL fShutdown, BOOL fNoSync)
    {
    HRESULT hr = SP_E_UNINITIALIZED;
    TCHAR   szRes[CCHMAX_STRINGRES];

    EnterCriticalSection(&m_cs);

    if (IsWindow(m_hwnd))
        {
        // Stop the animation
#ifndef _WIN64
        Animate_Close(GetDlgItem(m_hwnd, IDC_SP_ANIMATE));
#endif 
        hr = S_OK;

        ToggleStatics(TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);

        if (ISFLAGSET(fErrors, SPSTATE_CANCEL))
        {
            m_fErrors = TRUE;
            ExpandCollapse(TRUE);
            TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), TAB_TASKS);
            OnTabChange(0);

            AthLoadString(idsSpoolerUserCancel, szRes, ARRAYSIZE(szRes));
            SetDlgItemText(m_hwnd, IDC_SP_IDLETEXT, szRes);
            SendDlgItemMessage(m_hwnd, IDC_SP_IDLEICON, STM_SETICON, 
                               (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiError)), 0);
        }
        // Also if there were errors, we should switch to the error page
        else if (fErrors)
            {
            m_fErrors = TRUE;
            ExpandCollapse(TRUE);
            TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), TAB_ERRORS);
            OnTabChange(0);

            AthLoadString(idsSpoolerIdleErrors, szRes, ARRAYSIZE(szRes));
            SetDlgItemText(m_hwnd, IDC_SP_IDLETEXT, szRes);
            SendDlgItemMessage(m_hwnd, IDC_SP_IDLEICON, STM_SETICON, 
                               (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiError)), 0);
            }
        else
            {
            AthLoadString(idsSpoolerIdle, szRes, ARRAYSIZE(szRes));
            SetDlgItemText(m_hwnd, IDC_SP_IDLETEXT, szRes);
            SendDlgItemMessage(m_hwnd, IDC_SP_IDLEICON, STM_SETICON, 
                               (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiMailNews)), 0);

            if (fNoSync)
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsNothingToSync), NULL, MB_OK | MB_ICONEXCLAMATION);

            // Determine if we need to hide the dialog
            UINT state = (UINT) SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETSTATE, IDC_SP_TACK, 0);
            if (!(state & TBSTATE_CHECKED))
                ShowWindow(SW_HIDE);
            }
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::IsDialogMessage()
//
//  PURPOSE:    Allows the dialog to retrieve messages from the message loop.
//
//  PARAMETERS:
//      <in> pMsg - Pointer to the message for us to examine.
//
//  RETURN VALUE:
//      Returns S_OK if we eat the message, S_FALSE otherwise.
//
HRESULT CSpoolerDlg::IsDialogMessage(LPMSG pMsg)
    {
    HRESULT hr;
    BOOL    fEaten = FALSE;
    BOOL    fBack = FALSE;
    
    EnterCriticalSection(&m_cs);

    // Intended for modeless timeout dialog running on this thread?
    HWND hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);
    if (hwndTimeout && ::IsDialogMessage(hwndTimeout, pMsg))
        return(S_OK);

    if (pMsg->message == WM_KEYDOWN && (GetAsyncKeyState(VK_CONTROL) < 0))
        {
        switch (pMsg->wParam)
            {
            case VK_TAB:
                fBack = GetAsyncKeyState(VK_SHIFT) < 0;
                break;

            case VK_PRIOR:  // VK_PAGE_UP
            case VK_NEXT:   // VK_PAGE_DOWN
                fBack = (pMsg->wParam == VK_PRIOR);
                break;

            default:
                goto NoKeys;
            }

        int iCur = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS));

        // tab in reverse if shift is down
        if (fBack)
            iCur += (TAB_MAX - 1);
        else
            iCur++;

        iCur %= TAB_MAX;
        TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), iCur);
        OnTabChange(NULL);
        }
   
NoKeys:    
    if (IsWindow(m_hwnd) && IsWindowVisible(m_hwnd))
        fEaten = ::IsDialogMessage(m_hwnd, pMsg);
        
    LeaveCriticalSection(&m_cs);
    return (fEaten ? S_OK : S_FALSE);
    }


//
//  FUNCTION:   CSpoolerDlg::GetWindow()
//
//  PURPOSE:    Returns the handle to the spooler dialog window.
//
//  PARAMETERS:
//      <out> pHwnd - Where we return the handle.
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::GetWindow(HWND *pHwnd)
    {
    HRESULT hr=S_OK;

    if (NULL == pHwnd)
        return E_INVALIDARG;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        *pHwnd = m_hwnd;

    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }


HRESULT CSpoolerDlg::Close(void)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        DestroyWindow(m_hwnd);

    // Unregister with Identity manager
    if (m_dwIdentCookie != 0)
    {
        MU_UnregisterIdentityNotifier(m_dwIdentCookie);
        m_dwIdentCookie = 0;
    }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CSpoolerDlg::ChangeHangupOption(BOOL fEnable, DWORD dwOption)
    {
    ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_HANGUP), fEnable ? SW_SHOW : SW_HIDE);
    ::EnableWindow(GetDlgItem(m_hwnd, IDC_SP_HANGUP), fEnable);
    SendDlgItemMessage(m_hwnd, IDC_SP_HANGUP, BM_SETCHECK, dwOption, 0);
    return (S_OK);
    }


//
//  FUNCTION:   CSpoolerDlg::PostDlgProc()
//
//  PURPOSE:    Dialog callback for the spooler dialog proc.
//
INT_PTR CALLBACK CSpoolerDlg::SpoolerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                          LPARAM lParam)
    {
    CSpoolerDlg *pThis = (CSpoolerDlg *) GetWindowLongPtr(hwnd, DWLP_USER);
    LRESULT lResult;

    // Pass to spooler bind context
    if (pThis && pThis->m_pBindCtx && pThis->m_pBindCtx->OnWindowMessage(hwnd, uMsg, wParam, lParam) == S_OK)
        return (TRUE);
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stash the this pointer so we can use it later
            Assert(lParam);
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis = (CSpoolerDlg *) lParam;
            
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, 
                                               pThis->OnInitDialog);
                                        
        case WM_COMMAND:
            if (pThis)
                HANDLE_WM_COMMAND(hwnd, wParam, lParam, pThis->OnCommand);
            return (TRUE);  

        case WM_NOTIFY:
            if (pThis)
                {
                lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, pThis->OnNotify);
                SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
                }
            return (TRUE);
            
        case WM_DRAWITEM:
            if (pThis)
                HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, pThis->OnDrawItem);
            return (TRUE);

        case WM_MEASUREITEM:
            if (pThis)
                HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, pThis->OnMeasureItem);
            return (TRUE);

        case WM_DELETEITEM:
            if (pThis)
                HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, pThis->OnDeleteItem);
            return (TRUE);

#if 0
        case WM_SYSCOLORCHANGE:
        case WM_SETTINGCHANGE:
            if (pThis)
                HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, pThis->OnSysColorChange);
            return (TRUE);
#endif
        
        case WM_CLOSE:
            if (pThis)
                HANDLE_WM_CLOSE(hwnd, wParam, lParam, pThis->OnClose);
            return (TRUE);

        case WM_DESTROY:
            if (pThis)
                HANDLE_WM_DESTROY(hwnd, wParam, lParam, pThis->OnDestroy);
            return (TRUE);

        case IMAIL_SHOWWINDOW:
            ::ShowWindow(hwnd, (int) lParam);
            if (pThis)
                pThis->ToggleStatics(lParam == SW_HIDE);
            return (TRUE);

        case WM_QUERYENDSESSION:
            if (pThis && pThis->m_pBindCtx)
                {
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pThis->m_pBindCtx->QueryEndSession(wParam, lParam));
                return (TRUE);
                }
            break;

        case WM_CONTEXTMENU:
            if (pThis)
                {
                HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, pThis->OnContextMenu);
                return (TRUE);
                }
            break;
        }

    return (FALSE);
    }


//
//  FUNCTION:   CSpoolerDlg::OnInitDialog()
//
//  PURPOSE:    Initializes the dialog.
//
//  PARAMETERS:
//      <in> hwnd      - Handle of the dialog window.
//      <in> hwndFocus - Handle of the control that will start with the focus.
//      <in> lParam    - Extra data being passed to the dialog.
//
//  RETURN VALUE:
//      Return TRUE to set the focus to hwndFocus
//
BOOL CSpoolerDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
    m_hwnd = hwnd;

    // Bug #38692 - Set the font correctly for Intl charsets
    SetIntlFont(hwnd);
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_GENERAL_PROG));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_SPECIFIC_PROG));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_EVENTS));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_ERRORS));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_IDLETEXT));

    // Initialize the controls on the dialog
    InitializeTabs();
    InitializeLists();
    InitializeAnimation();
    InitializeToolbar();
    ToggleStatics(TRUE);

    // Hide the Hangup when done deal.
    // ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_HANGUP), SW_HIDE);

    // Set the hangup when done option
    Button_SetCheck(GetDlgItem(m_hwnd, IDC_SP_HANGUP), DwGetOption(OPT_DIALUP_HANGUP_DONE));

    // Get some information from the dialog template we'll need later
    GetDlgItemText(m_hwnd, IDC_SP_OVERALL_STATUS, m_szCount, ARRAYSIZE(m_szCount));

    // Initialize the rectangles that we'll need for sizing later
    RECT rcSep;
    GetWindowRect(GetDlgItem(hwnd, IDC_SP_SEPARATOR), &rcSep);
    GetWindowRect(hwnd, &m_rcDlg);
    m_cyCollapsed = rcSep.top - m_rcDlg.top;

    // Load the window size from the registry
    WINDOWPLACEMENT wp;
    wp.length = sizeof(WINDOWPLACEMENT);
    if (GetOption(OPT_SPOOLERDLGPOS, (LPVOID*) &wp, sizeof(WINDOWPLACEMENT)))
        {
        wp.showCmd = SW_HIDE;
        SetWindowPlacement(hwnd, &wp);
        ExpandCollapse(m_cyCollapsed < (DWORD) ((wp.rcNormalPosition.bottom - wp.rcNormalPosition.top)), FALSE);
        }
    else
        {
        // Center the dialog on the screen.
        CenterDialog(hwnd);
        ExpandCollapse(FALSE, FALSE);
        }

    // Set the state of the thumbtack
    DWORD dwTack;
    if (DwGetOption(OPT_SPOOLERTACK))
        {
        SendDlgItemMessage(hwnd, IDC_SP_TOOLBAR, TB_SETSTATE, IDC_SP_TACK, 
                           MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED, 0));
        SendMessage(hwnd, WM_COMMAND, IDC_SP_TACK, 0);
        }

    // Disable the stop button
    EnableWindow(GetDlgItem(hwnd, IDC_SP_STOP), FALSE);

    // Subclass the list box
    HWND hwnderr = GetDlgItem(hwnd, IDC_SP_ERRORS);
    WNDPROC proc = (WNDPROC) GetWindowLongPtr(hwnderr, GWLP_WNDPROC);
    SetProp(hwnderr, c_szWndProc, proc);
    SetWindowLongPtr(hwnderr, GWLP_WNDPROC, (LPARAM) ListSubClassProc);

    // BUG: 44376. ATOK11 has a hidden window. If we return TRUE user will do a setfocus on US, at this point the browser
    // thread is block waiting for the spooler to complete and when ATOK gets a WM_ACTIVATE they interthreadsendmsg on our blocked
    // browser window with inf. timeout. So we hang at startup. Don't set focus in here at startup time.
    return (FALSE);
    }

//
//  FUNCTION:   CSpoolerDlg::OnCommand()
//
//  PURPOSE:    Handle the various command messages dispatched from the dialog
//
void CSpoolerDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
    switch (id)
        {
        case IDCANCEL:
        case IDC_SP_MINIMIZE:
            if (m_fShutdown)
                {
                Assert(m_pBindCtx);
                EnableWindow(GetDlgItem(hwnd, IDC_SP_MINIMIZE), FALSE);
                m_pBindCtx->UIShutdown();
                }
            else
                ShowWindow(SW_HIDE);
            break;

        case IDC_SP_STOP:
            if (m_pBindCtx)
                {
                m_pBindCtx->Cancel();
                if (GetFocus() == GetDlgItem(hwnd, IDC_SP_STOP))
                    SetFocus(GetDlgItem(hwnd, IDC_SP_MINIMIZE));
                EnableWindow(GetDlgItem(hwnd, IDC_SP_STOP), FALSE);
                }
            break;

        case IDC_SP_TACK:
            {
            UINT state = (UINT) SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETSTATE,
                                            IDC_SP_TACK, 0);
            SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_CHANGEBITMAP, 
                               IDC_SP_TACK, 
                               MAKELPARAM(state & TBSTATE_CHECKED ? IMAGE_TACK_IN : IMAGE_TACK_OUT, 0));
            }
            break;

        case IDC_SP_DETAILS:
            m_fSaveSize = TRUE;
            ExpandCollapse(!m_fExpanded);
            break;

        case IDC_SP_HANGUP:
            SetDwOption(OPT_DIALUP_HANGUP_DONE, BST_CHECKED == Button_GetCheck(hwndCtl), NULL, 0);
            break;
        }
    }


//
//  FUNCTION:   CSpoolerDlg::OnNotify
//
//  PURPOSE:    Handles notifications from the common controls on the dialog.
//
LRESULT CSpoolerDlg::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
    switch (pnmhdr->code)
        {
        case TCN_SELCHANGE:
            OnTabChange(pnmhdr);
            return (0);
        }

    return (0);
    }

//
//  FUNCTION:   CSpoolerDlg::OnDrawItem()
//
//  PURPOSE:    Draws the link buttons
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the dialog window
//      <in> lpDrawItem - Pointer to a DRAWITEMSTRUCT with the info needed to 
//                        draw the button.
//
void CSpoolerDlg::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem)
    {
    HDC      hdc = lpDrawItem->hDC;
    COLORREF clrText, clrBack;
    RECT     rcText, rcFocus;
    SIZE     size;
    BOOL     fSelected = (lpDrawItem->itemState & ODS_SELECTED) && 
                         (GetFocus() == lpDrawItem->hwndItem);

    Assert(lpDrawItem->CtlType == ODT_LISTBOX);
    if (lpDrawItem->itemID == -1)
        goto exit;

    // Draw the bullet first
    ImageList_Draw(m_himlImages, 
                   IMAGE_BULLET, 
                   hdc, 
                   BULLET_INDENT, 
                   lpDrawItem->rcItem.top, 
                   fSelected ? ILD_SELECTED | ILD_TRANSPARENT : ILD_TRANSPARENT);

    // Set up the text rectangle
    rcText = lpDrawItem->rcItem;
    rcText.left += BULLET_WIDTH;

    // Set up the text and background colors
    clrBack = SetBkColor(hdc, GetSysColor(fSelected ? COLOR_HIGHLIGHT : COLOR_WINDOW));
    clrText = SetTextColor(hdc, GetSysColor(fSelected ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));

    // Draw the text
    FillRect(hdc, &rcText, (HBRUSH)IntToPtr((fSelected ? COLOR_HIGHLIGHT : COLOR_WINDOW) + 1));
    InflateRect(&rcText, -2, -2);
    DrawText(hdc, ((LBDATA *) lpDrawItem->itemData)->pszText, -1, &rcText, DT_NOCLIP | DT_WORDBREAK);

    // If we need a focus rect, do that too
    if (lpDrawItem->itemState & ODS_FOCUS)
        {
        rcFocus = lpDrawItem->rcItem;
        rcFocus.left += BULLET_WIDTH;
//        InflateRect(&rcFocus, -2, -2);
        DrawFocusRect(hdc, &rcFocus);
        }

    SetBkColor(hdc, clrBack);
    SetTextColor(hdc, clrText);

exit:
    return;
    }


void CSpoolerDlg::OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT *pMeasureItem)
    {
    LBDATA *pData = NULL;

    EnterCriticalSection(&m_cs);

    // Set the height of the item
    if (NULL != (pData = (LBDATA *) ListBox_GetItemData(m_hwndErrors, pMeasureItem->itemID)))
        {
        pMeasureItem->itemHeight = pData->rcText.bottom;
        }

    LeaveCriticalSection(&m_cs);
    }


void CSpoolerDlg::OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT * lpDeleteItem)
    {
    EnterCriticalSection(&m_cs);

    if (lpDeleteItem->itemData)
        {
        SafeMemFree(((LBDATA *)lpDeleteItem->itemData)->pszText);
        MemFree((LPVOID) lpDeleteItem->itemData);
        }

    LeaveCriticalSection(&m_cs);
    }


//
//  FUNCTION:   CSpoolerDlg::OnClose()
//
//  PURPOSE:    Handles the WM_CLOSE notification by sending an IDCANCEL to
//              the dialog.
//
void CSpoolerDlg::OnClose(HWND hwnd)
    {
    SendMessage(hwnd, WM_COMMAND, IDC_SP_MINIMIZE, 0);
    }     


//
//  FUNCTION:   CSpoolerDlg::OnDestroy()
//
//  PURPOSE:    Handles the WM_DESTROY notification by freeing the memory stored
//              in the listview items.
//
void CSpoolerDlg::OnDestroy(HWND hwnd)
    {
#ifndef _WIN64
    Animate_Close(GetDlgItem(m_hwnd, IDC_SP_ANIMATE));
#endif

    // Save the window placement
    WINDOWPLACEMENT wp;
    wp.length = sizeof(WINDOWPLACEMENT);
    if (GetWindowPlacement(hwnd, &wp))
        {
        if (!m_fSaveSize)
            {
            // Load the old size out of the registry
            WINDOWPLACEMENT wp2;

            if (GetOption(OPT_SPOOLERDLGPOS, (LPVOID*) &wp2, sizeof(WINDOWPLACEMENT)))
                {
                wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + (wp2.rcNormalPosition.bottom - wp2.rcNormalPosition.top);                
                }
            else
                {
                wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + m_cyCollapsed;
                }
            }

        SetOption(OPT_SPOOLERDLGPOS, (LPVOID) &wp, sizeof(WINDOWPLACEMENT), NULL, 0);
        }

    DWORD dwState;
    dwState = (DWORD) SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETSTATE, IDC_SP_TACK, 0);
    SetDwOption(OPT_SPOOLERTACK, !!(dwState & TBSTATE_CHECKED), NULL, 0);

    HIMAGELIST himl;
    himl = (HIMAGELIST)SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETIMAGELIST, 0, 0);
    if (himl)
        ImageList_Destroy(himl);

    HWND hwnderr = GetDlgItem(hwnd, IDC_SP_ERRORS);
    WNDPROC proc = (WNDPROC)GetProp(hwnderr, c_szWndProc);
    if (proc != NULL)
        {
        SetWindowLongPtr(hwnderr, GWLP_WNDPROC, (LPARAM)proc);
        RemoveProp(hwnderr, c_szWndProc);
        }
    }


//
//  FUNCTION:   CSpoolerDlg::InitializeTabs()
//
//  PURPOSE:    Initializes the tab control on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeTabs(void)
    {
    HWND    hwndTabs = GetDlgItem(m_hwnd, IDC_SP_TABS);
    TC_ITEM tci;
    TCHAR   szRes[CCHMAX_STRINGRES];

    // "Tasks"
    tci.mask = TCIF_TEXT;
    tci.pszText = AthLoadString(idsTasks, szRes, ARRAYSIZE(szRes));
    TabCtrl_InsertItem(hwndTabs, 0, &tci);
    
    // "Errors"
    tci.pszText = AthLoadString(idsErrors, szRes, ARRAYSIZE(szRes));
    TabCtrl_InsertItem(hwndTabs, 1, &tci);
    
    return (TRUE);
    }


//
//  FUNCTION:   CSpoolerDlg::InitializeLists()
//
//  PURPOSE:    Initializes the list control on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeLists(void)
    {
    LV_COLUMN lvc;
    TCHAR     szRes[CCHMAX_STRINGRES];
    RECT      rcClient;
    DWORD     cx;

    // Store the handle for the events list since we use it frequently
    m_hwndEvents = GetDlgItem(m_hwnd, IDC_SP_EVENTS);

    // Get the size of the client rect of the listview
    GetClientRect(m_hwndEvents, &rcClient);

    // "Tasks" column
    lvc.mask     = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_CENTER;
    lvc.cx       = rcClient.right / 2;
    lvc.pszText  = AthLoadString(idsTasks, szRes, ARRAYSIZE(szRes));
    lvc.iSubItem = 0;
    ListView_InsertColumn(m_hwndEvents, 0, &lvc);

    // "Status" column
    cx = (rcClient.right / 2 - GetSystemMetrics(SM_CXVSCROLL)) / 2;
    lvc.cx       = cx;
    lvc.pszText  = AthLoadString(idsStatusCol, szRes, ARRAYSIZE(szRes));
    lvc.iSubItem = 1;
    ListView_InsertColumn(m_hwndEvents, 1, &lvc);

    // "Connection" column
    lvc.cx       = cx;
    lvc.pszText  = AthLoadString(idsConnection, szRes, ARRAYSIZE(szRes));
    lvc.iSubItem = 2;
    ListView_InsertColumn(m_hwndEvents, 2, &lvc);

    // Set the listview image list
    m_himlImages = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbSpooler), 16, 0,
                                        RGB(255, 0, 255));

    if (m_himlImages)
        ListView_SetImageList(m_hwndEvents, m_himlImages, LVSIL_SMALL);

    // The listview looks better if we use full row select
    ListView_SetExtendedListViewStyle(m_hwndEvents, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

    // Initialize the Error list
    m_hwndErrors = GetDlgItem(m_hwnd, IDC_SP_ERRORS);
    ::ShowWindow(m_hwndErrors, FALSE);
    EnableWindow(m_hwndErrors, FALSE);

    // Save the width of the error list
    GetClientRect(m_hwndErrors, &rcClient);
    m_cxErrors = rcClient.right;

    return (TRUE);
    }    


//
//  FUNCTION:   CSpoolerDlg::InitializeAnimation()
//
//  PURPOSE:    Initializes the animation controls on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeAnimation(void)
    {
#ifndef _WIN64

    HWND hwndAni = GetDlgItem(m_hwnd, IDC_SP_ANIMATE);

    Animate_OpenEx(hwndAni, g_hLocRes, MAKEINTRESOURCE(idanOutbox));
#endif
    return (0);
    }
    

//
//  FUNCTION:   CSpoolerDlg::InitializeToolbar()
//
//  PURPOSE:    What dialog would be complete without a toolbar, eh?
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeToolbar(void)
    {
    HWND hwndTool;
    RECT rcTabs;
    POINT point;

    HIMAGELIST himlImages = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbSpooler), 16, 0,
                                        RGB(255, 0, 255));

    GetWindowRect(GetDlgItem(m_hwnd, IDC_SP_TABS), &rcTabs);
    point.x = rcTabs.right - 22;
    point.y = rcTabs.bottom + 3;
    ScreenToClient(m_hwnd, &point);

    hwndTool = CreateWindowEx(0, TOOLBARCLASSNAME, NULL, 
                              CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN |
                              WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | TBSTYLE_FLAT,
                              point.x, point.y, 22, 22, 
                              m_hwnd, (HMENU) IDC_SP_TOOLBAR,
                              g_hInst, 0);
    if (hwndTool)
        {
#ifndef WIN16
        TBBUTTON tb = { IMAGE_TACK_OUT, IDC_SP_TACK, TBSTATE_ENABLED, TBSTYLE_CHECK, {0, 0}, 0, 0 };
#else
        TBBUTTON tb = { IMAGE_TACK_OUT, IDC_SP_TACK, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0 };
#endif
        SendMessage(hwndTool, TB_SETIMAGELIST, 0, (LPARAM) himlImages);
        SendMessage(hwndTool, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(hwndTool, TB_SETBUTTONSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_SETBITMAPSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_ADDBUTTONS, 1, (LPARAM) &tb);
        }
    return (0);
    }


//
//  FUNCTION:   CSpoolerDlg::ExpandCollapse()
//
//  PURPOSE:    Takes care of showing and hiding the "details" part of the
//              error dialog.
//
//  PARAMETERS:
//      <in> fExpand - TRUE if we should be expanding the dialog.
//
void CSpoolerDlg::ExpandCollapse(BOOL fExpand, BOOL fSetFocus)
    {
    RECT rcSep;
    TCHAR szBuf[64];
    
    m_fExpanded = fExpand;
    
    GetWindowRect(GetDlgItem(m_hwnd, IDC_SP_SEPARATOR), &rcSep);
    
    if (!m_fExpanded)
        SetWindowPos(m_hwnd, 0, 0, 0, m_rcDlg.right - m_rcDlg.left, 
                     m_cyCollapsed, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    else
        SetWindowPos(m_hwnd, 0, 0, 0, m_rcDlg.right - m_rcDlg.left,
                     m_rcDlg.bottom - m_rcDlg.top, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    // Make sure the entire dialog is visible on the screen.  If not,
    // then push it up
    RECT rc;
    RECT rcWorkArea;
    GetWindowRect(m_hwnd, &rc);
    SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID) &rcWorkArea, 0);
    if (rc.bottom > rcWorkArea.bottom)
        {
        rc.top = max(0, (int) rc.top - (rc.bottom - rcWorkArea.bottom));
        
        SetWindowPos(m_hwnd, 0, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
                
    AthLoadString(m_fExpanded ? idsHideDetails : idsShowDetails, szBuf, 
                  ARRAYSIZE(szBuf));     
    SetDlgItemText(m_hwnd, IDC_SP_DETAILS, szBuf);

    if (fExpand)
        {
        switch (m_iTab)
            {
            case TAB_TASKS:
                UpdateLists(TRUE, FALSE, FALSE);
                break;
            case TAB_ERRORS:
                UpdateLists(FALSE, TRUE, FALSE);
                break;
            }
        }
    else
        UpdateLists(FALSE, FALSE, FALSE);

    // Raid-34387: Spooler: Closing details with ALT-D while focus is on a task disables keyboard input
    if (!fExpand && fSetFocus)
        SetFocus(GetDlgItem(m_hwnd, IDC_SP_DETAILS));
    }


//
//  FUNCTION:   CSpoolerDlg::OnTabChange()
//
//  PURPOSE:    Gets called in response to the user changing which tab is
//              the selected tab.  In response, we update which listview
//              is currently visible.
//
//  PARAMETERS:
//      <in> pnmhdr - Pointer to the notification information
//
void CSpoolerDlg::OnTabChange(LPNMHDR pnmhdr)
    {
    HWND hwndDisable1, hwndDisable2 = 0, hwndEnable;

    // Find out which tab is currently active
    m_iTab = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS));
    if (-1 == m_iTab)
        return;

    // Update which listview is visible
    switch (m_iTab)
        {
        case TAB_TASKS:
            // Hide the error listview, show the tasks list
            UpdateLists(TRUE, FALSE, FALSE);
            break;

        case TAB_ERRORS:
            // Hide the error listview, show the tasks list
            UpdateLists(FALSE, TRUE, FALSE);
            break;
        }
    }


//
//  FUNCTION:   CSpoolerDlg::UpdateLists()
//
//  PURPOSE:    Does the work of hiding and showing the lists when the
//              tab selection changes.
//
//  PARAMETERS:
//      <in> fEvents - TRUE to display the events list
//      <in> fErrors - TRUE to display the error list
//      <in> fHistory - TRUE to display the history list
//
void CSpoolerDlg::UpdateLists(BOOL fEvents, BOOL fErrors, BOOL fHistory)
    {
    if (IsWindow(m_hwndEvents))
        {
        EnableWindow(m_hwndEvents, fEvents);
        ::ShowWindow(m_hwndEvents, fEvents ? SW_SHOWNA : SW_HIDE);
        }

    if (IsWindow(m_hwndErrors))
        {
        EnableWindow(m_hwndErrors, fErrors);
        ::ShowWindow(m_hwndErrors, fErrors ? SW_SHOWNA : SW_HIDE);
        }
    }

void CSpoolerDlg::ToggleStatics(BOOL fIdle)
    {
    m_fIdle = fIdle;

    if (fIdle)
        {
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), TRUE);


        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), SW_SHOWNA);
        }
    else
        {
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), FALSE);

        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), SW_HIDE);
        }
    }


void CSpoolerDlg::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
    POINT pt = {xPos, yPos};
    RECT  rcError;
    LBDATA *pData = NULL;

    // Check to see if the error window is visible
    if (!IsWindowVisible(m_hwndErrors))
        return;

    // Check to see if the click was within the error window
    GetWindowRect(m_hwndErrors, &rcError);
    if (!PtInRect(&rcError, pt))
        return;

    // Do the context menu
    HMENU hMenu = CreatePopupMenu();

    // Add a "Copy..." item
    TCHAR szRes[CCHMAX_STRINGRES]; 
    AthLoadString(idsCopyTT, szRes, ARRAYSIZE(szRes));

    // Add it to the menu
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, ID_COPY, szRes);

    // If the click is on an item in the listbox, then enable the command
    ScreenToClient(m_hwndErrors, &pt);
    DWORD iItem = (DWORD) SendMessage(m_hwndErrors, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));

    if (iItem != -1)
    {
        EnterCriticalSection(&m_cs);
        pData = (LBDATA *) ListBox_GetItemData(m_hwndErrors, iItem);
        LeaveCriticalSection(&m_cs);
    }
    
    if (iItem == -1 || NULL == pData || ((LBDATA*)-1) == pData)
        EnableMenuItem(hMenu, ID_COPY, MF_BYCOMMAND | MF_GRAYED);

    // Show the menu
    DWORD id;
    id = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_NONOTIFY,
                          xPos, yPos, m_hwndErrors, NULL);
    if (id == ID_COPY)
    {
        // Get the item data for the item they clicked on
        LPTSTR pszDup;

        EnterCriticalSection(&m_cs);

        // Set the height of the item
        if (NULL != pData && ((LBDATA*)-1) != pData)
        {
            // Dupe the string.  Clipboard owns the copy.
            pszDup = PszDupA(pData->pszText);

            // Put it on the clipboard
            OpenClipboard(m_hwndErrors);
            EmptyClipboard();
            SetClipboardData(CF_TEXT, pszDup);
            CloseClipboard();
        }

        LeaveCriticalSection(&m_cs);
    }

    if (hMenu)
        DestroyMenu(hMenu);
}

HRESULT CSpoolerDlg::QuerySwitchIdentities()
{
    DWORD_PTR   dwResult;

    if (!IsWindowEnabled(m_hwnd))
        return E_PROCESS_CANCELLED_SWITCH;

    if (m_pBindCtx)
    {
        dwResult = m_pBindCtx->QueryEndSession(0, ENDSESSION_LOGOFF);
        SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, dwResult);

        if (dwResult != TRUE)
            return E_PROCESS_CANCELLED_SWITCH;
    }

    return S_OK;
}

HRESULT CSpoolerDlg::SwitchIdentities()
{
    return S_OK;
}

HRESULT CSpoolerDlg::IdentityInformationChanged(DWORD dwType)
{
    return S_OK;
}


LRESULT CALLBACK CSpoolerDlg::ListSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_KEYDOWN && wParam == 'C')
    {
        if (0 > GetAsyncKeyState(VK_CONTROL))
        {
            int iSel = (int) SendMessage(hwnd, LB_GETCURSEL, 0, 0);
            if (LB_ERR != iSel)
            {
                LBDATA *pData = NULL;
                LPTSTR pszDup;

                // Set the height of the item
                if (NULL != (pData = (LBDATA *) ListBox_GetItemData(hwnd, iSel)))
                {
                    // Dupe the string.  Clipboard owns the copy.
                    pszDup = PszDupA(pData->pszText);

                    // Put it on the clipboard
                    OpenClipboard(hwnd);
                    EmptyClipboard();
                    SetClipboardData(CF_TEXT, pszDup);
                    CloseClipboard();
                }
            }
        }
    }

    WNDPROC wp = (WNDPROC) GetProp(hwnd, c_szWndProc);
    return (CallWindowProc(wp, hwnd, uMsg, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\watchtsk.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     watchtsk.cpp
//
//  PURPOSE:    Implements the spooler task that is responsible for checking
//              for watched messages.
//


#include "pch.hxx"
#include "watchtsk.h"
#include "storutil.h"
#include "storsync.h"

ASSERTDATA

/////////////////////////////////////////////////////////////////////////////
// State Machine dispatch table
//

static const PFNWSTATEFUNC g_rgpfnState[WTS_MAX] = 
{
    NULL,
    NULL,
    &CWatchTask::_Watch_Init,
    &CWatchTask::_Watch_NextFolder,
    NULL,
    &CWatchTask::_Watch_Done
};

/////////////////////////////////////////////////////////////////////////////
// Local Data
//

static const TCHAR c_szWatchWndClass[] = "Outlook Express Watch Spooler Task Window";
static const TCHAR c_szThis[] = "this";

//
//  FUNCTION:   CWatchTask::CWatchTask()
//
//  PURPOSE:    Initializes the member variables of the object.
//
CWatchTask::CWatchTask()
{
    m_cRef = 1;

    m_fInited = FALSE;
    m_dwFlags = 0;
    *m_szAccount = 0;
    *m_szAccountId = 0;
    m_idAccount = 0;
    m_eidCur = 0;

    m_pBindCtx = NULL;
    m_pUI = NULL;
    m_pAccount = NULL;
    m_pServer = NULL;
    m_pCancel = NULL;

    m_idFolderCheck = FOLDERID_INVALID;
    m_rgidFolders = 0;
    m_cFolders = 0;
    m_hwnd = 0;
    m_hTimeout = 0;

    m_state = WTS_IDLE;
    m_fCancel = FALSE;
    m_cCurFolder = 0;
    m_cFailed = 0;
    m_tyOperation = SOT_INVALID;
};


//
//  FUNCTION:   CWatchTask::~CWatchTask()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
CWatchTask::~CWatchTask()    
{
    SafeRelease(m_pBindCtx);
    SafeRelease(m_pAccount);
    SafeRelease(m_pServer);
    SafeRelease(m_pCancel);
    SafeMemFree(m_rgidFolders);

    // Don't RIP
    if (m_hwnd)
        DestroyWindow(m_hwnd);
};

/////////////////////////////////////////////////////////////////////////////
// IUnknown
//

HRESULT CWatchTask::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) (ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_ISpoolerTask))
        *ppvObj = (LPVOID) (ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (LPVOID) (IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (LPVOID) (ITimeoutCallback *) this;

    if (NULL == *ppvObj)
        return (E_NOINTERFACE);

    AddRef();
    return S_OK;
}


ULONG CWatchTask::AddRef(void)
{
    return InterlockedIncrement((LONG *) &m_cRef);
}

ULONG CWatchTask::Release(void)
{
    InterlockedDecrement((LONG *) &m_cRef);
    if (0 == m_cRef)
    {
        delete this;
        return (0);
    }
    return (m_cRef);
}


//
//  FUNCTION:   CWatchTask::Init()
//
//  PURPOSE:    Called by the spooler engine to tell us what type of task to 
//              execute and to provide us with a pointer to our bind context.
//
//  PARAMETERS:
//      <in> dwFlags  - Flags to tell us what types of things to do
//      <in> pBindCtx - Pointer to the bind context interface we are to use
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_ALREADYINITIALIZED
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT CWatchTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    HRESULT hr = S_OK;

    // Validate the args
    if (NULL == pBindCtx)
        return (E_INVALIDARG);

    // Check to see if we've already been initialized
    if (m_fInited)
    {
        hr = SP_E_ALREADYINITIALIZED;
        goto exit;
    }

    // Copy the flags for later
    m_dwFlags = dwFlags;

    // Copy the bind context pointer
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();

    // Register the window class
    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szWatchWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = _TaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szWatchWndClass;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    m_fInited = TRUE;

exit:
    return (hr);
}


//
//  FUNCTION:   CWatchTask::BuildEvents()
//
//  PURPOSE:    This method is called by the spooler engine telling us to create
//              and event list for the account specified.  
//
//  PARAMETERS:
//      <in> pAccount - Account object to build the event list for
//
//  RETURN VALUE:
//      SP_E_UNINITALIZED
//      E_INVALIDARG
//      S_OK
//
HRESULT CWatchTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, 
                                FOLDERID idFolder)
{
    HRESULT hr = S_OK;
    DWORD   dwPoll;
    DWORD   dw;

    // Validate the args
    if (pSpoolerUI == NULL || pAccount == NULL)
        return (E_INVALIDARG);

    // Make sure we've been initialized
    if (!m_fInited)
        return (SP_E_UNINITIALIZED);

    // Figure out which account this is
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId))))
        goto exit;

    // We only do this for accounts that have polling turned on
    if (0 == (m_dwFlags & DELIVER_NOSKIP))
    {
        if (FAILED(hr = pAccount->GetPropDw(AP_NNTP_POLL, &dw)) || dw == 0)
            goto exit;
    }

    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccount, ARRAYSIZE(m_szAccount))))
        goto exit;

    // Get the folder ID for this account from the store
    if (FAILED(hr = g_pStore->FindServerId(m_szAccountId, &m_idAccount)))
        goto exit;

    // Hold on to the UI object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Also hold on to the account
    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Also hold on to the folder ID
    m_idFolderCheck = idFolder;

    // Check to see if any folders that are part of this account have watched
    // messages within them.
    if (_ChildFoldersHaveWatched(m_idAccount))
    {
        TCHAR      szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        EVENTID    eid;

        // Create the string for the event description
        AthLoadString(idsCheckWatchedMessgesServer, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_szAccount);

        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, 0, pAccount, &eid);
    }
    else
    {
        // Do this so stuff at the end get's released correctly
        hr = E_FAIL;
    }

exit:
    // If we failed, we should clean up all the info we accumulated along 
    // the way so we don't accidentially think we're initalized later.
    if (FAILED(hr))
    {
        SafeRelease(m_pUI);
        SafeRelease(m_pAccount);
        SafeMemFree(m_rgidFolders);

        *m_szAccountId = 0;
        *m_szAccount = 0;
        m_idAccount = FOLDERID_INVALID;
    }

    return (hr);
}


//
//  FUNCTION:   CWatchTask::Execute()
//
//  PURPOSE:    Called by the spooler to when it's our turn to run.
//
HRESULT CWatchTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    // Double check that we're idle.
    Assert(m_state == WTS_IDLE && m_eidCur == NULL);

    // Make sure we're initialized
    if (FALSE == m_fInited || NULL == m_pUI)
        return (SP_E_UNINITIALIZED);

    // Copy the event ID
    m_eidCur = eid;

    // Create our internal window now
    if (!m_hwnd)
    {
        m_hwnd = CreateWindow(c_szWatchWndClass, NULL, WS_POPUP, 10, 10, 10, 10,
                              GetDesktopWindow(), NULL, g_hInst, this);
    }

    // Set up the UI to show progress for us
    m_pUI->SetProgressRange(1);

    AthLoadString(idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    m_pUI->SetAnimation(idanDownloadNews, TRUE);

    // Start the state machine
    m_state = WTS_INIT;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return (S_OK);
}


//  
//  FUNCTION:   CWatchTask::CancelEvent()
//
//  PURPOSE:    Called by the spooler when it needs to free us before 
//              executing our events.  This gives us an opporutnity to free
//              our cookie.
//
HRESULT CWatchTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // We have no cookie now, so there's nothing to do.
    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::ShowProperties()
//
//  PURPOSE:    Not Implemented
//
HRESULT CWatchTask::ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CWatchTask::GetExtendedDetails()
//
//  PURPOSE:    Called by the spooler to get more information about an error
//              that has occured.
//
HRESULT CWatchTask::GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CWatchTask::Cancel()
//
//  PURPOSE:    Called by the spooler when the user presses the <Cancel> button
//              on the spooler dialog.
//
HRESULT CWatchTask::Cancel(void)
{
    // This happens if the user cancel's out of the Connect dialog
    if (m_state == WTS_IDLE)
        return (S_OK);

    // Drop the server connection
    if (m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_fCancel = TRUE;

    // Clean up
    m_state = WTS_END;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::IsDialogMessage()
//
//  PURPOSE:    Gives the task an opportunity to see window messages.
//
HRESULT CWatchTask::IsDialogMessage(LPMSG pMsg)
{
    return (S_FALSE);
}


//
//  FUNCTION:   CWatchTask::OnFlagsChanged()
//
//  PURPOSE:    Called by the spooler to notify us when current stae flags
//              have changed (such as visible, background etc)
//
HRESULT CWatchTask::OnFlagsChanged(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::OnBegin()
//
//  PURPOSE:    Called by the server object when it begins some operation we
//              requested.
//
HRESULT CWatchTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo,
                            IOperationCancel *pCancel)
{
    // Hold on to the operation type
    Assert(m_tyOperation == SOT_INVALID);
    m_tyOperation = tyOperation;

    if (tyOperation == SOT_GET_WATCH_INFO)
        m_cMsgs = 0;

    // Keep the pointer to the cancel object too
    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return (S_OK);
}


// 
//  FUNCTION:   CWatchTask::OnProgress()
//
//  PURPOSE:    Called by the server to give us progress on the current operation
//
HRESULT CWatchTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, 
                               DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog that might be present
    CallbackCloseTimeout(&m_hTimeout);

    if (tyOperation == SOT_GET_WATCH_INFO)
    {
        m_cMsgs = dwMax;
    }

    return (S_OK);
}


// 
//  FUNCTION:   CWatchTask::OnTimeout()
//
//  PURPOSE:    Get's called when we timeout waiting for a server response.  If
//              the user has the spooler window visible, we show the timeout
//              dialog.  If not, we eat it and fail.
//
HRESULT CWatchTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return (E_FAIL);

    // Display the dialog
    return (CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *) this, &m_hTimeout));
}


// 
//  FUNCTION:   CWatchTask::CanConnect()
//
//  PURPOSE:    Get's called when we need to dial the phone to connect to the
//              server.  If we have our UI visible, we go ahead and show the UI,
//              otherwise we eat it.
//
HRESULT CWatchTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;

    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}


// 
//  FUNCTION:   CWatchTask::OnLogonPrompt()
//
//  PURPOSE:    Get's called when we need to prompt the user for their password
//              to connect to the server.
//
HRESULT CWatchTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(S_FALSE);

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}


//
//  FUNCTION:   CWatchTask::OnComplete()
//
//  PURPOSE:    Called by the server when it completes a requested task.
//
HRESULT CWatchTask::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, 
                                   LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    LPCSTR pszError;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_tyOperation != tyOperation)
        return (S_OK);

    if (SOT_GET_WATCH_INFO == tyOperation)
    {
        if (FAILED(hrComplete))
        {
            // If an error detail was returned, insert that
            pszError = pErrorInfo->pszDetails;
            if (pszError == NULL || *pszError == 0)
                pszError = pErrorInfo->pszProblem;

            if (pszError != NULL && *pszError != 0)
                m_pUI->InsertError(m_eidCur, pszError);

            // Increment the failure count
            m_cFailed++;

        }

        m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

        m_state = WTS_NEXTFOLDER;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }

    // If the user canceled something just give up.
    if (IXP_E_USER_CANCEL == hrComplete)
    {
        Cancel();
    }

    // Reset some state information
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;

    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::OnPrompt()
//
//  PURPOSE:    Called by the server when it needs to do some funky SSL thing.
//
HRESULT CWatchTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}


//
//  FUNCTION:   CWatchTask::OnPrompt()
//
//  PURPOSE:    Called by the timeout dialog when the user responds.
//
HRESULT CWatchTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


//
//  FUNCTION:   CWatchTask::GetParentWindow()
//
//  PURPOSE:    Called by the server object when it needs to display some sort
//              of UI.  If we're running in the background, we fail the call.
//
HRESULT CWatchTask::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr;

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    if (m_pUI)
    {
        hr = m_pUI->GetWindow(phwndParent);
    }
    else
    {
        *phwndParent = NULL;
        hr = E_FAIL;
    }

    return(hr);
}


//
//  FUNCTION:   CWatchTask::_TaskWndProc()
//
//  PURPOSE:    Hidden window that processes messages for this task.
//
LRESULT CALLBACK CWatchTask::_TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                          LPARAM lParam)
{
    CWatchTask *pThis = (CWatchTask *) GetProp(hwnd, c_szThis);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
            pThis = (CWatchTask *) pcs->lpCreateParams;
            SetProp(hwnd, c_szThis, (LPVOID) pThis);
            return (0);
        }

        case NTM_NEXTSTATE:
            if (pThis)
            {
                pThis->AddRef();
                pThis->_NextState();
                pThis->Release();
            }
            return (0);

        case WM_DESTROY:
            RemoveProp(hwnd, c_szThis);
            break;
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CWatchTask::_NextState()
//
//  PURPOSE:    Executes the function for the current state
//
void CWatchTask::_NextState(void)
{
    if (NULL != g_rgpfnState[m_state])
        (this->*(g_rgpfnState[m_state]))();
}


//
//  FUNCTION:   CWatchTask::_Watch_Init()
//
//  PURPOSE:    When we need to start doing our thing.  This function creates
//              and initializes any objects we need to do our job and starts
//              looking at the first group.
//
HRESULT CWatchTask::_Watch_Init(void)
{
    FOLDERINFO fi;
    HRESULT    hr;

    // Get information about the server we're checking
    if (SUCCEEDED(hr = g_pStore->GetFolderInfo(m_idAccount, &fi)))
    {
        // With that information, create the server object
        hr = CreateMessageServerType(fi.tyFolder, &m_pServer);
        g_pStore->FreeRecord(&fi);            

        if (SUCCEEDED(hr))
        {
            // Initialize the server object
            if (SUCCEEDED(m_pServer->Initialize(g_pLocalStore, m_idAccount, 
                                                NULL, FOLDERID_INVALID)))
            {                
                // At this point we have all the information we need.  Initialize
                // the progress UI.
                TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

                AthLoadString(idsCheckingWatchedProgress, szRes, ARRAYSIZE(szRes));
                wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_szAccount);

                m_pUI->SetGeneralProgress(szBuf);
                m_pUI->SetProgressRange((WORD) m_cFolders);
                
                m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING_NEWS, 0);                
                
                // Go ahead and start with the first folder.
                m_cCurFolder = -1;
                m_cFailed = 0;
                m_state = WTS_NEXTFOLDER;

                PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0); 
                return (S_OK);
            }
        }
    }

    // If we got here, we didn't succeed in initializing the required stuff.
    // We need to log the error and bail.
    m_pUI->InsertError(m_eidCur, MAKEINTRESOURCE(idsErrFailedWatchInit));
    m_cFailed = m_cFolders;

    m_state = WTS_END;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    SafeRelease(m_pServer);
    return (E_OUTOFMEMORY);
}


//
//  FUNCTION:   CWatchTask::_Watch_NextFolder()
//
//  PURPOSE:    Requests the watched information from the server object for the
//              next folder in our list of folders to check.
//
HRESULT CWatchTask::_Watch_NextFolder(void)
{
    HRESULT     hr = E_FAIL;
    FOLDERINFO  fi;
    TCHAR       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    // Loop until we succeed
    while (TRUE)
    {
        m_cCurFolder++;

        // Check to see if we've reached the end
        if (m_cCurFolder >= m_cFolders)
        {
            m_state = WTS_END;
            PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
            return (S_OK);
        }

        // Update the progress UI.  If we fail to get the folder name, it's not
        // fatal, just keep truckin.
        if (SUCCEEDED(g_pStore->GetFolderInfo(m_rgidFolders[m_cCurFolder], &fi)))
        {
            AthLoadString(idsCheckingWatchedFolderProg, szRes, ARRAYSIZE(szRes));
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, fi.pszName);
            m_pUI->SetSpecificProgress(szBuf);

            g_pStore->FreeRecord(&fi);
        }

        // Open the store folder for this next folder
        hr = E_FAIL;
        IMessageFolder *pFolder;
        hr = g_pStore->OpenFolder(m_rgidFolders[m_cCurFolder], NULL, OPEN_FOLDER_NOCREATE, &pFolder);
        if (SUCCEEDED(hr))
        {
            IServiceProvider *pSP;

            if (SUCCEEDED(pFolder->QueryInterface(IID_IServiceProvider, (LPVOID *) &pSP)))
            {
                IMessageFolder *pFolderReal;

                if (SUCCEEDED(hr = pSP->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (LPVOID *) &pFolderReal)))
                {
                    m_pServer->ResetFolder(pFolderReal, m_rgidFolders[m_cCurFolder]);

                    // Request the information
                    hr = m_pServer->GetWatchedInfo(m_rgidFolders[m_cCurFolder], (IStoreCallback *) this);
                    if (E_PENDING == hr)
                    {
                        m_state = WTS_RESP;
                    }

                    pFolderReal->Release();
                }
                pSP->Release();
            }
            pFolder->Release();
        }

        if (E_PENDING == hr)
            return (S_OK);
    }

    if (FAILED(hr))
    {
        // If we got here, something failed
        m_cFailed++;
    }

    m_pUI->IncrementProgress(1);
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return (E_FAIL);
}


//
//  FUNCTION:   CWatchTask::_Watch_Done()
//
//  PURPOSE:    Called when we're done getting all our watched stuff.  This 
//              function primarily is used to clean stuff up.
//
HRESULT CWatchTask::_Watch_Done(void)
{
    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

    // Tell the spooler if we failed or not
    if (m_fCancel)
    {
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
        m_fCancel = FALSE;
    }
    else if (m_cFailed == m_cFolders)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_cFailed == 0)
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);

    if (m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION | MSGSVRF_HANDS_OFF_SERVER);

    SafeRelease(m_pServer);
    SafeMemFree(m_rgidFolders);
    SafeRelease(m_pAccount);
    SafeRelease(m_pUI);

    m_cFolders = 0;
    m_cFailed = 0;
    m_eidCur = 0;
    m_state = WTS_IDLE;

    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::_ChildFoldersHaveWatched()
//
//  PURPOSE:    Checks to see if any of the folders which are a child of the 
//              given folder have any messages that are being watched.
//
BOOL CWatchTask::_ChildFoldersHaveWatched(FOLDERID id)
{
    HRESULT   hr = S_OK;
    FOLDERID *rgidFolderList = 0;
    DWORD     dwAllocated;
    DWORD     dwUsed;
    DWORD     i;

    // If the user want's us to check all folders, get a list of 'em
    if (m_idFolderCheck == FOLDERID_INVALID)
    {
        // Get a list of all the folders which are a child of this folder
        hr = FlattenHierarchy(g_pStore, id, FALSE, TRUE, &rgidFolderList, &dwAllocated,
                              &dwUsed);
        if (FAILED(hr))
            goto exit;
    }
    else
    {
        if (!MemAlloc((LPVOID *) &rgidFolderList, sizeof(FOLDERID) * 1))
            return (FALSE);

        *rgidFolderList = m_idFolderCheck;
        dwUsed = 1;
    }

    // Check to see if we got any folders back
    m_cFolders = 0;
    if (dwUsed)
    {
        // Allocate a new array that will in the end only contain the folders we 
        // care about.    
        if (!MemAlloc((LPVOID *) &m_rgidFolders, sizeof(FOLDERID) * dwUsed))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Initialize the stored list
        ZeroMemory(m_rgidFolders, sizeof(FOLDERID) * dwUsed);
        m_cFolders = 0;

        // Now loop through the array 
        for (i = 0; i < dwUsed; i++)
        {
            if (_FolderContainsWatched(rgidFolderList[i]))
            {
                m_rgidFolders[m_cFolders] = rgidFolderList[i];
                m_cFolders++;
            }
        }
    }

exit:
    SafeMemFree(rgidFolderList);

    if (FAILED(hr))
    {
        SafeMemFree(m_rgidFolders);
        m_cFolders = 0;
    }

    return (m_cFolders != 0);
}


//
//  FUNCTION:   CWatchTask::_FolderContainsWatched()
//
//  PURPOSE:    Checks to see if the specified folder has any messages which are
//              being watched.
//
BOOL CWatchTask::_FolderContainsWatched(FOLDERID id)
{
    FOLDERINFO      rFolderInfo = {0};
    BOOL            fReturn = FALSE;

    // Get the folder info struct
    if (SUCCEEDED(g_pStore->GetFolderInfo(id, &rFolderInfo)))
    {
        fReturn = rFolderInfo.cWatched;
        g_pStore->FreeRecord(&rFolderInfo);
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\taskutil.h ===
// --------------------------------------------------------------------------------
// TaskUtil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __TASKUTIL_H
#define __TASKUTIL_H

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "spoolapi.h"

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
const EVENTID INVALID_EVENT = -1;

// --------------------------------------------------------------------------------
// LOADSTRING
// --------------------------------------------------------------------------------
#define LOADSTRING(_idsString, _szDest) \
    SideAssert(LoadString(g_hLocRes, _idsString, _szDest, ARRAYSIZE(_szDest)) > 0)
#define CCHMAX_RES 255

// --------------------------------------------------------------------------------
// TASKRESULTTYPE
// --------------------------------------------------------------------------------
typedef enum tagTASKRESULTTYPE {
    TASKRESULT_SUCCESS,                               // No problem
    TASKRESULT_FAILURE,                               // Fatal results in disconnect
    TASKRESULT_EVENTFAILED                            // An item or event failed
} TASKRESULTTYPE;

// ------------------------------------------------------------------------------------
// TIMEOUTINFO
// ------------------------------------------------------------------------------------
typedef struct tagTIMEOUTINFO {
    DWORD               dwTimeout;
    LPCSTR              pszServer;
    LPCSTR              pszAccount;
    LPCSTR              pszProtocol;
    ITimeoutCallback   *pCallback;
} TIMEOUTINFO, *LPTIMEOUTINFO;

// --------------------------------------------------------------------------------
// TASKERROR
// --------------------------------------------------------------------------------
typedef struct tagTASKERROR {
    HRESULT         hrResult;
    ULONG           ulStringId;
    LPCSTR          pszError;
    BOOL            fShowUI;
    TASKRESULTTYPE  tyResult;
} TASKERROR, *LPTASKERROR;
typedef TASKERROR const *LPCTASKERROR;

// --------------------------------------------------------------------------------
// PTaskUtil_GetError
// --------------------------------------------------------------------------------
LPCTASKERROR PTaskUtil_GetError(HRESULT hrResult, ULONG *piError);

// --------------------------------------------------------------------------------
// TaskUtil_SplitStoreError - converts STOREERROR into IXPRESULT and INETSERVER
// --------------------------------------------------------------------------------
void TaskUtil_SplitStoreError(IXPRESULT *pixpResult, INETSERVER *pInetServer,
                              STOREERROR *pErrorInfo);

// --------------------------------------------------------------------------------
// TaskUtil_InsertTransportError
// --------------------------------------------------------------------------------
TASKRESULTTYPE TaskUtil_InsertTransportError(BOOL fCanShowUI, ISpoolerUI *pUI, EVENTID eidCurrent,
                                             STOREERROR *pErrorInfo, LPSTR pszOpDescription,
                                             LPSTR pszSubject);

// --------------------------------------------------------------------------------
// TaskUtil_FBaseTransportError - Returns TRUE if the error was handled
// --------------------------------------------------------------------------------
TASKRESULTTYPE TaskUtil_FBaseTransportError(IXPTYPE ixptype, EVENTID idEvent, LPIXPRESULT pResult, 
    LPINETSERVER pServer, LPCSTR pszSubject, ISpoolerUI *pUI, BOOL fCanShowUI, HWND hwndParent);

// ------------------------------------------------------------------------------------
// TaskUtil_HrBuildErrorInfoString
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_HrBuildErrorInfoString(LPCSTR pszProblem, IXPTYPE ixptype, LPIXPRESULT pResult,
    LPINETSERVER pServer, LPCSTR pszSubject, LPSTR *ppszInfo, ULONG *pcchInfo);

// ------------------------------------------------------------------------------------
// TaskUtil_OnLogonPrompt
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OnLogonPrompt(IImnAccount *pAccount, ISpoolerUI *pUI, HWND hwndParent,
    LPINETSERVER pServer, DWORD apidUserName, DWORD apidPassword, DWORD apidPromptPwd, BOOL fSaveChanges);

// ------------------------------------------------------------------------------------
// TaskUtil_HwndOnTimeout
// ------------------------------------------------------------------------------------
HWND TaskUtil_HwndOnTimeout(LPCSTR pszServer, LPCSTR pszAccount, LPCSTR pszProtocol, DWORD dwTimeout,
    ITimeoutCallback *pTask);

// ------------------------------------------------------------------------------------
// TaskUtil_OpenSentItemsFolder
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OpenSentItemsFolder(IImnAccount *pAccount, IMessageFolder **ppFolder);



#endif // __TASKUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\taskutil.cpp ===
// --------------------------------------------------------------------------------
// TaskUtil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "spoolapi.h"
#include "imnxport.h"
#include "taskutil.h"
#include "strconst.h"
#include "resource.h"
#include "passdlg.h"
#include "xpcomm.h"
#include "timeout.h"
#include "thormsgs.h"
#include "mimeutil.h"
#include "flagconv.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Array of mappings between IXPTYPE and protocol name
// --------------------------------------------------------------------------------
static const LPSTR g_prgszServers[IXP_HTTPMail + 1] = { 
    "NNTP",
    "SMTP",
    "POP3",
    "IMAP",
    "RAS",
    "HTTPMail"
};

// --------------------------------------------------------------------------------
// LOGONINFO
// --------------------------------------------------------------------------------
typedef struct tagLOGFONINFO {
    LPSTR           pszAccount;                     // Account
    LPSTR           pszServer;                      // Server Name
    LPSTR           pszUserName;                    // User Name
    LPSTR           pszPassword;                    // Passowrd
    DWORD           fSavePassword;                  // Save Password
    DWORD           fAlwaysPromptPassword;          // "Always prompt for password"
} LOGONINFO, *LPLOGONINFO;

// --------------------------------------------------------------------------------
// TASKERROR
// --------------------------------------------------------------------------------
static const TASKERROR c_rgTaskErrors[] = {
    { SP_E_CANTLOCKUIDLCACHE,               idshrLockUidCacheFailed,                NULL, TRUE,   TASKRESULT_FAILURE  },
    { IXP_E_TIMEOUT,                        IDS_IXP_E_TIMEOUT,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSASYSNOTREADY,         IDS_IXP_E_CONN,                         NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAEINPROGRESS,         IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_FAILED_WSASTARTUP,      IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAEFAULT,              IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAEPROCLIM,            IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAVERNOTSUPPORTED,     IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_LOAD_SICILY_FAILED,             IDS_IXP_E_LOAD_SICILY_FAILED,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_INVALID_CERT_CN,                IDS_IXP_E_INVALID_CERT_CN,              NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_INVALID_CERT_DATE,              IDS_IXP_E_INVALID_CERT_DATE,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONN,                           IDS_IXP_E_CONN,                         NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CANT_FIND_HOST,                 IDS_IXP_E_CANT_FIND_HOST,               NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_FAILED_TO_CONNECT,              IDS_IXP_E_FAILED_TO_CONNECT,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONNECTION_DROPPED,             IDS_IXP_E_CONNECTION_DROPPED,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONN_RECV,                      IDS_IXP_E_SOCKET_READ_ERROR,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_READ_ERROR,              IDS_IXP_E_SOCKET_READ_ERROR,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONN_SEND,                      IDS_IXP_E_SOCKET_WRITE_ERROR,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_WRITE_ERROR,             IDS_IXP_E_SOCKET_WRITE_ERROR,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_INIT_ERROR,              IDS_IXP_E_SOCKET_INIT_ERROR,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_CONNECT_ERROR,           IDS_IXP_E_SOCKET_CONNECT_ERROR,         NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_INVALID_ACCOUNT,                IDS_IXP_E_INVALID_ACCOUNT,              NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_USER_CANCEL,                    IDS_IXP_E_USER_CANCEL,                  NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SICILY_LOGON_FAILED,            IDS_IXP_E_SICILY_LOGON_FAILED,          NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SMTP_RESPONSE_ERROR,            IDS_IXP_E_SMTP_RESPONSE_ERROR,          NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SMTP_UNKNOWN_RESPONSE_CODE,     IDS_IXP_E_SMTP_UNKNOWN_RESPONSE_CODE,   NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SMTP_REJECTED_RECIPIENTS,       IDS_IXP_E_SMTP_REJECTED_RECIPIENTS,     NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX,   IDS_IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX, NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_NO_SENDER,                 IDS_IXP_E_SMTP_NO_SENDER,               NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_NO_RECIPIENTS,             IDS_IXP_E_SMTP_NO_RECIPIENTS,           NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { SP_E_SMTP_CANTOPENMESSAGE,            IDS_SP_E_SMTP_CANTOPENMESSAGE,          NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { SP_E_SENDINGSPLITGROUP,               IDS_SP_E_SENDINGSPLITGROUP,             NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_REJECTED_SENDER,           IDS_IXP_E_SMTP_REJECTED_SENDER,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_POP3_RESPONSE_ERROR,            IDS_IXP_E_POP3_RESPONSE_ERROR,          NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_POP3_INVALID_USER_NAME,         IDS_IXP_E_POP3_INVALID_USER_NAME,       NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_POP3_INVALID_PASSWORD,          IDS_IXP_E_POP3_INVALID_PASSWORD,        NULL, FALSE,  TASKRESULT_FAILURE  },
    { SP_E_CANTLEAVEONSERVER,               idshrCantLeaveOnServer,                 NULL, FALSE,  TASKRESULT_FAILURE  },
    { E_OUTOFMEMORY,                        IDS_E_OUTOFMEMORY,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { ERROR_NOT_ENOUGH_MEMORY,              IDS_E_OUTOFMEMORY,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { ERROR_OUTOFMEMORY,                    IDS_E_OUTOFMEMORY,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { hrDiskFull,                           idsDiskFull,                            NULL, FALSE,  TASKRESULT_FAILURE  },
    { ERROR_DISK_FULL,                      idsDiskFull,                            NULL, FALSE,  TASKRESULT_FAILURE  },
    { DB_E_DISKFULL,                        idsDiskFull,                            NULL, FALSE,  TASKRESULT_FAILURE  },
    { DB_E_ACCESSDENIED,                    idsDBAccessDenied,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { SP_E_POP3_RETR,                       IDS_SP_E_RETRFAILED,                    NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_552_STORAGE_OVERFLOW,      IDS_IXP_E_SMTP_552_STORAGE_OVERFLOW,    NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { SP_E_CANT_MOVETO_SENTITEMS,           IDS_SP_E_CANT_MOVETO_SENTITEMS,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_RESPONSE_ERROR,            idsNNTPErrUnknownResponse,              NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_NNTP_NEWGROUPS_FAILED,          idsNNTPErrNewgroupsFailed,              NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_LIST_FAILED,               idsNNTPErrListFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_LISTGROUP_FAILED,          idsNNTPErrListGroupFailed,              NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_GROUP_FAILED,              idsNNTPErrGroupFailed,                  NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_GROUP_NOTFOUND,            idsNNTPErrGroupNotFound,                NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_ARTICLE_FAILED,            idsNNTPErrArticleFailed,                NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_HEAD_FAILED,               idsNNTPErrHeadFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_BODY_FAILED,               idsNNTPErrBodyFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_POST_FAILED,               idsNNTPErrPostFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_NEXT_FAILED,               idsNNTPErrNextFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_DATE_FAILED,               idsNNTPErrDateFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_HEADERS_FAILED,            idsNNTPErrHeadersFailed,                NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_XHDR_FAILED,               idsNNTPErrXhdrFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_INVALID_USERPASS,          idsNNTPErrPasswordFailed,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SECURE_CONNECT_FAILED,          idsFailedToConnectSecurely,             NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_USE_PROXY,                 IDS_IXP_E_HTTP_USE_PROXY,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_BAD_REQUEST,               IDS_IXP_E_HTTP_BAD_REQUEST,             NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_UNAUTHORIZED,              IDS_IXP_E_HTTP_UNAUTHORIZED,            NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_FORBIDDEN,                 IDS_IXP_E_HTTP_FORBIDDEN,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_NOT_FOUND,                 IDS_IXP_E_HTTP_NOT_FOUND,               NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_METHOD_NOT_ALLOW,          IDS_IXP_E_HTTP_METHOD_NOT_ALLOW,        NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_NOT_ACCEPTABLE,            IDS_IXP_E_HTTP_NOT_ACCEPTABLE,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_PROXY_AUTH_REQ,            IDS_IXP_E_HTTP_PROXY_AUTH_REQ,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_REQUEST_TIMEOUT,           IDS_IXP_E_HTTP_REQUEST_TIMEOUT,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_CONFLICT,                  IDS_IXP_E_HTTP_CONFLICT,                NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_GONE,                      IDS_IXP_E_HTTP_GONE,                    NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_LENGTH_REQUIRED,           IDS_IXP_E_HTTP_LENGTH_REQUIRED,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_PRECOND_FAILED,            IDS_IXP_E_HTTP_PRECOND_FAILED,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_INTERNAL_ERROR,            IDS_IXP_E_HTTP_INTERNAL_ERROR,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_NOT_IMPLEMENTED,           IDS_IXP_E_HTTP_NOT_IMPLEMENTED,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_BAD_GATEWAY,               IDS_IXP_E_HTTP_BAD_GATEWAY,             NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_SERVICE_UNAVAIL,           IDS_IXP_E_HTTP_SERVICE_UNAVAIL,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_GATEWAY_TIMEOUT,           IDS_IXP_E_HTTP_GATEWAY_TIMEOUT,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_VERS_NOT_SUP,              IDS_IXP_E_HTTP_VERS_NOT_SUP,            NULL, FALSE,  TASKRESULT_FAILURE },
    { SP_E_HTTP_NOSENDMSGURL,               idsHttpNoSendMsgUrl,                    NULL, FALSE,  TASKRESULT_FAILURE },
    { SP_E_HTTP_SERVICEDOESNTWORK,          idsHttpServiceDoesntWork,               NULL, FALSE,  TASKRESULT_FAILURE },    
    { SP_E_HTTP_NODELETESUPPORT,            idsHttpNoDeleteSupport,                 NULL, FALSE,  TASKRESULT_FAILURE },    
    { SP_E_HTTP_CANTMODIFYMSNFOLDER,        idsCantModifyMsnFolder,                 NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_INSUFFICIENT_STORAGE,      idsHttpNoSpaceOnServer,                 NULL, FALSE,  TASKRESULT_FAILURE },    
    { STORE_E_IMAP_HC_NOSLASH,              idsIMAPHC_NoSlash,                      NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_IMAP_HC_NOBACKSLASH,          idsIMAPHC_NoBackSlash,                  NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_IMAP_HC_NODOT,                idsIMAPHC_NoDot,                        NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_IMAP_HC_NOHC,                 idsIMAPHC_NoHC,                         NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_NOTRANSLATION,                idsIMAPNoTranslatableInferiors,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SMTP_530_STARTTLS_REQUIRED,     idsSMTPSTARTTLSRequired,                NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SMTP_NO_STARTTLS_SUPPORT,       idsSMTPNoSTARTTLSSupport,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SMTP_454_STARTTLS_FAILED,       idsSMTPSTARTTLSFailed,                  NULL, FALSE,  TASKRESULT_FAILURE },
};

// --------------------------------------------------------------------------------
// TaskUtil_LogonPromptDlgProc
// --------------------------------------------------------------------------------
INT_PTR CALLBACK TaskUtil_LogonPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK TaskUtil_TimeoutPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// --------------------------------------------------------------------------------
// TaskUtil_HrWriteQuoted
// --------------------------------------------------------------------------------
HRESULT TaskUtil_HrWriteQuoted(IStream *pStream, LPCSTR pszName, LPCSTR pszData, BOOL fQuoted, 
    LPCSTR *ppszSep)
{
    // Locals
    HRESULT     hr=S_OK;

    // Write - Separator
    CHECKHR(hr = pStream->Write(*ppszSep, lstrlen(*ppszSep), NULL));

    // Change Separator
    *ppszSep = g_szCommaSpace;

    // Write - 'Account Name:'
    CHECKHR(hr = pStream->Write(pszName, lstrlen(pszName), NULL));

    // Write Space
    CHECKHR(hr = pStream->Write(g_szSpace, lstrlen(g_szSpace), NULL));

    // Write single quote
    if (fQuoted)
        CHECKHR(hr = pStream->Write(g_szQuote, lstrlen(g_szQuote), NULL));

    // Write Data
    CHECKHR(hr = pStream->Write(pszData, lstrlen(pszData), NULL));

    // Write End Quote
    if (fQuoted)
        CHECKHR(hr = pStream->Write(g_szQuote, lstrlen(g_szQuote), NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// TaskUtil_HrBuildErrorInfoString
// --------------------------------------------------------------------------------
HRESULT TaskUtil_HrBuildErrorInfoString(LPCSTR pszProblem, IXPTYPE ixptype, LPIXPRESULT pResult,
    LPINETSERVER pServer, LPCSTR pszSubject, LPSTR *ppszInfo, ULONG *pcchInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[255];
    CHAR            szNumber[50];
    LPCSTR          pszSep=c_szEmpty;
    CByteStream     cStream;

    // Init
    *ppszInfo = NULL;
    *pcchInfo = 0;

    // Write out the problem
    AssertSz(NULL != pszProblem, "Hey, what's your problem, buddy?");
    if (pszProblem) {
        CHECKHR(hr = cStream.Write(pszProblem, lstrlen(pszProblem), NULL));
        CHECKHR(hr = cStream.Write(g_szSpace, lstrlen(g_szSpace), NULL));
    }

    // Subject: 'Subject'
    if (pszSubject)
    {
        LOADSTRING(idsSubject, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pszSubject, TRUE, &pszSep));
    }

     // Account: 'Account Name'
    if (!FIsEmptyA(pServer->szAccount))
    {
        LOADSTRING(idsDetail_Account, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pServer->szAccount, TRUE, &pszSep));
    }

    // Server: 'Server Name'
    if (!FIsEmptyA(pServer->szServerName))
    {
        LOADSTRING(idsDetail_Server, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pServer->szServerName, TRUE, &pszSep));
    }

    // Protocol: 'SMTP'
    LOADSTRING(idsDetail_Protocol, szRes);
    CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, g_prgszServers[ixptype], FALSE, &pszSep));

    // Server Response: 'Text'
    if (pResult->pszResponse)
    {
        LOADSTRING(idsDetail_ServerResponse, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pResult->pszResponse, TRUE, &pszSep));
    }

    // Port: 'Port'
    LOADSTRING(idsDetail_Port, szRes);
    wnsprintf(szNumber, ARRAYSIZE(szNumber), "%d", pServer->dwPort);
    CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));

    // Secure: 'Yes or No'
    LOADSTRING(idsDetail_Secure, szRes);
    if (pServer->fSSL)
        LOADSTRING(idsOui, szNumber);
    else
        LOADSTRING(idsNon, szNumber);
    CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));

    // Server Error: 'number'
    if (pResult->uiServerError)
    {
        LOADSTRING(idsServerErrorNumber, szRes);
        wnsprintf(szNumber, ARRAYSIZE(szNumber), "%d", pResult->uiServerError);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Server Error: '0x00000000'
    else if (pResult->hrServerError)
    {
        LOADSTRING(idsServerErrorNumber, szRes);
        wnsprintf(szNumber, ARRAYSIZE(szNumber), "0x%0X", pResult->hrServerError);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Socket Error: 'number'
    if (pResult->dwSocketError)
    {
        LOADSTRING(idsSocketErrorNumber, szRes);
        wnsprintf(szNumber, ARRAYSIZE(szNumber), "%d", pResult->dwSocketError);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Error Number: 'Text'
    if (pResult->hrResult)
    {
        LOADSTRING(idsDetail_ErrorNumber, szRes);
        wnsprintf(szNumber, ARRAYSIZE(szNumber), "0x%0X", pResult->hrResult);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Acquire the string from cStream
    CHECKHR(hr = cStream.HrAcquireStringA(pcchInfo, ppszInfo, ACQ_DISPLACE));

exit:
    if (FAILED(hr)) {
        // If we failed, just return the pszProblem string (duped), if possible
        *ppszInfo = StringDup(pszProblem);
        if (NULL != *ppszInfo) {
            *pcchInfo = lstrlen(*ppszInfo);
            hr = S_FALSE;
        }
        else {            
            *pcchInfo = 0;
            hr = E_OUTOFMEMORY;
        }
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// PTaskUtil_GetError
// --------------------------------------------------------------------------------
LPCTASKERROR PTaskUtil_GetError(HRESULT hrResult, ULONG *piError)
{
    // Look for the hresult
    for (ULONG i=0; i<ARRAYSIZE(c_rgTaskErrors); i++)
    {
        // Is this It
        if (hrResult == c_rgTaskErrors[i].hrResult)
        {
            // Done
            if (piError)
                *piError = i;
            return(&c_rgTaskErrors[i]);
        }
    }

    // Done
    return(NULL);
}


// --------------------------------------------------------------------------------
// TaskUtil_SplitStoreError
// --------------------------------------------------------------------------------
void TaskUtil_SplitStoreError(IXPRESULT *pixpResult, INETSERVER *pInetServer,
                              STOREERROR *pErrorInfo)
{
    if (NULL == pixpResult || NULL == pInetServer || NULL == pErrorInfo)
    {
        Assert(FALSE);
        return;
    }

    // Fill out IXPRESULT from STOREERROR
    ZeroMemory(pixpResult, sizeof(*pixpResult));
    pixpResult->hrResult = pErrorInfo->hrResult;
    pixpResult->pszResponse = pErrorInfo->pszDetails;
    pixpResult->uiServerError = pErrorInfo->uiServerError;
    pixpResult->hrServerError = pErrorInfo->hrServerError;
    pixpResult->dwSocketError = pErrorInfo->dwSocketError;
    pixpResult->pszProblem = pErrorInfo->pszProblem;

    // Fill out INETSERVER structure from STOREERROR
    ZeroMemory(pInetServer, sizeof(*pInetServer));
    if (NULL != pErrorInfo->pszAccount)
        StrCpyN(pInetServer->szAccount, pErrorInfo->pszAccount, ARRAYSIZE(pInetServer->szAccount));

    if (NULL != pErrorInfo->pszUserName)
        StrCpyN(pInetServer->szUserName, pErrorInfo->pszUserName, ARRAYSIZE(pInetServer->szUserName));

    pInetServer->szPassword[0] = '\0';

    if (NULL != pErrorInfo->pszServer)
        StrCpyN(pInetServer->szServerName, pErrorInfo->pszServer, ARRAYSIZE(pInetServer->szServerName));

    if (NULL != pErrorInfo->pszConnectoid)
        StrCpyN(pInetServer->szConnectoid, pErrorInfo->pszConnectoid, ARRAYSIZE(pInetServer->szConnectoid));

    pInetServer->rasconntype = pErrorInfo->rasconntype;
    pInetServer->dwPort = pErrorInfo->dwPort;
    pInetServer->fSSL = pErrorInfo->fSSL;
    pInetServer->fTrySicily = pErrorInfo->fTrySicily;
    pInetServer->dwTimeout = 30; // Whatever, I don't think it's used
    pInetServer->dwFlags = 0;
}



TASKRESULTTYPE TaskUtil_InsertTransportError(BOOL fCanShowUI, ISpoolerUI *pUI, EVENTID eidCurrent,
                                             STOREERROR *pErrorInfo, LPSTR pszOpDescription,
                                             LPSTR pszSubject)
{
    char            szBuf[CCHMAX_STRINGRES * 2];
    LPSTR           pszEnd; // Points to end of string being constructed in szBuf
    IXPRESULT       ixpResult;
    INETSERVER      rServer;
    HWND            hwndParent;

    if (NULL == pErrorInfo)
    {
        Assert(FALSE);
        return TASKRESULT_FAILURE;
    }

    // If operation description is provided, copy it first
    szBuf[0] = '\0';
    pszEnd = szBuf;
    if (NULL != pszOpDescription)
    {
        if (0 == HIWORD(pszOpDescription))
            pszEnd += LoadString(g_hLocRes, LOWORD(pszOpDescription), szBuf, sizeof(szBuf));
        else
        {
            StrCpyN(szBuf, pszOpDescription, ARRAYSIZE(szBuf));
            pszEnd += lstrlen(szBuf);
        }
    }

    // Append the transport error description to our error string buffer
    if ((pszEnd - szBuf) < (sizeof(szBuf) - 1))
    {
        *pszEnd = ' ';
        pszEnd += 1;
        *pszEnd = '\0';
    }

    if ((NULL != pErrorInfo->pszProblem) && ((ARRAYSIZE(szBuf)) > ((int)(pszEnd - szBuf))))
        StrCpyN(pszEnd, pErrorInfo->pszProblem, ARRAYSIZE(szBuf) - (int) (pszEnd - szBuf));

    // Now generate and insert the full error information
    TaskUtil_SplitStoreError(&ixpResult, &rServer, pErrorInfo);
    ixpResult.pszProblem = szBuf;

    // Get Window
    if (NULL == pUI || FAILED(pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    return TaskUtil_FBaseTransportError(pErrorInfo->ixpType, eidCurrent, &ixpResult,
        &rServer, pszSubject, pUI, fCanShowUI, hwndParent);
} // TaskUtil_InsertTransportError



// --------------------------------------------------------------------------------
// TaskUtil_FBaseTransportError
// --------------------------------------------------------------------------------
TASKRESULTTYPE TaskUtil_FBaseTransportError(IXPTYPE ixptype, EVENTID idEvent, LPIXPRESULT pResult, 
    LPINETSERVER pServer, LPCSTR pszSubject, ISpoolerUI *pUI, BOOL fCanShowUI, HWND hwndParent)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCTASKERROR pError=NULL;
    TASKRESULTTYPE  taskresult=TASKRESULT_FAILURE;
    CHAR            szRes[255];
    LPSTR           pszInfo=NULL;
    ULONG           cchInfo;
    LPSTR           pszError=NULL;
    LPSTR           pszFull=NULL;
    BOOL            fShowUI=FALSE;
    LPSTR           pszTempProb=pResult->pszProblem;
    ULONG           i;

    // Invalid Arg
    Assert(pResult && FAILED(pResult->hrResult) && pServer && ixptype <= IXP_HTTPMail);

    // Find the Error
    pError = PTaskUtil_GetError(pResult->hrResult, &i);

    // Found it
    if (pError)
    {
        // If I have hard-coded a string
        if (pError->pszError)
        {
            // Just copy the string
            StrCpyN(szRes, pError->pszError, ARRAYSIZE(szRes));

            // Set pszError
            pszError = szRes;
        }

        // Rejected Recips or Rejected Sender
        else if (IXP_E_SMTP_REJECTED_RECIPIENTS == pError->hrResult || IXP_E_SMTP_REJECTED_SENDER == pError->hrResult)
        {
            // Locals
            CHAR szMessage[1024];

            // Better Succeed
            SideAssert(LoadString(g_hLocRes, pError->ulStringId, szRes, ARRAYSIZE(szRes)) > 0);

            // Format the message
            if (pResult->pszProblem && '\0' != *pResult->pszProblem)
            {
                // Use pszProblem, it probably contains the email address, I hope
                wnsprintf(szMessage, ARRAYSIZE(szMessage), szRes, pResult->pszProblem);

                // Temporarily NULL it out so that we don't use it later
                pResult->pszProblem = NULL;
            }
            else
            {
                // Locals
                CHAR szUnknown[255];

                // Load '<Unknown>'
                SideAssert(LoadString(g_hLocRes, idsUnknown, szUnknown, ARRAYSIZE(szUnknown)) > 0);

                // Format the error
                wnsprintf(szMessage, ARRAYSIZE(szMessage), szRes, szUnknown);
            }

            // Set pszError
            pszError = szMessage;
        }

        // Otherwise, load the string
        else
        {
            // Better Succeed
            SideAssert(LoadString(g_hLocRes, pError->ulStringId, szRes, ARRAYSIZE(szRes)) > 0);

            // Set pszError
            pszError = szRes;
        }

        // Set the task result type
        taskresult = c_rgTaskErrors[i].tyResult;

        // Show UI
        fShowUI = pError->fShowUI;
    }

    // Otherwise, default
    else
    {
        // Load the unknwon string
        SideAssert(LoadString(g_hLocRes, IDS_IXP_E_UNKNOWN, szRes, ARRAYSIZE(szRes)) > 0);

        // Set the Error source
        pszError = szRes;
    }

    // No Error
    if (NULL == pszError)
        goto exit;

    // If there is a pszProblem, use it
    if (pResult->pszProblem)
        pszError = pResult->pszProblem;

    // Get the error information part
    CHECKHR(hr = TaskUtil_HrBuildErrorInfoString(pszError, ixptype, pResult, pServer, pszSubject, &pszInfo, &cchInfo));

    // Log into spooler ui
    if (pUI)
    {
        // Insert the Error
        CHECKHR(hr = pUI->InsertError(idEvent, pszInfo));
    }

    // Show in a message box ?
    if (fShowUI && fCanShowUI)
    {
        // Locals
        INETMAILERROR rError;

        // Zero Init
        ZeroMemory(&rError, sizeof(INETMAILERROR));

        // Setup the Error Structure
        rError.dwErrorNumber = pResult->hrResult;
        rError.hrError = pResult->hrServerError;
        rError.pszServer = pServer->szServerName;
        rError.pszAccount = pServer->szAccount;
        rError.pszMessage = pszError;
        rError.pszUserName = pServer->szUserName;
        rError.pszProtocol = g_prgszServers[ixptype];
        rError.pszDetails = pResult->pszResponse;
        rError.dwPort = pServer->dwPort;
        rError.fSecure = pServer->fSSL;

        // Beep
        MessageBeep(MB_OK);

        // Show the error
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddInetMailError), hwndParent, InetMailErrorDlgProc, (LPARAM)&rError);
    }

exit:
    // Cleanup
    SafeMemFree(pszInfo);
    SafeMemFree(pszFull);

    // Reset pszProblem
    pResult->pszProblem = pszTempProb;

    // Done
    return taskresult;
}


// ------------------------------------------------------------------------------------
// TaskUtil_OnLogonPrompt - Returns S_FALSE if user cancels, otherwise S_OK
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OnLogonPrompt(IImnAccount *pAccount, ISpoolerUI *pUI, HWND hwndParent,
    LPINETSERVER pServer, DWORD apidUserName, DWORD apidPassword, DWORD apidPromptPwd, BOOL fSaveChanges)
{
    // Locals
    HRESULT         hr=S_FALSE;
    LOGONINFO       rLogon;
    DWORD           cb, type, dw;

    // Check Params
    Assert(pAccount && pServer);

	if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
	{
		if(HideHotmail())
			return(hr);
	}

    // Use current account, blah
    rLogon.pszAccount = pServer->szAccount;
    rLogon.pszPassword = pServer->szPassword;
    rLogon.pszUserName = pServer->szUserName;
    rLogon.pszServer = pServer->szServerName;
    rLogon.fSavePassword = !ISFLAGSET(pServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);
    cb = sizeof(DWORD);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegValNoModifyAccts, &type, &dw, &cb) &&
        dw == 0)
        rLogon.fAlwaysPromptPassword = TRUE;
    else
        rLogon.fAlwaysPromptPassword = FALSE;

    // No Parent
    if (NULL == hwndParent && NULL != pUI)
    {
        // Get the window parent
        if (FAILED(pUI->GetWindow(&hwndParent)))
            hwndParent = NULL;

        // Set foreground
        if (hwndParent)
            SetForegroundWindow(hwndParent);
    }

    // Do the Dialog Box
    if (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddPassword), hwndParent, TaskUtil_LogonPromptDlgProc, (LPARAM)&rLogon) == IDCANCEL)
        goto exit;

    // Set User Name
    pAccount->SetPropSz(apidUserName, pServer->szUserName);

    // Save Password
    if (rLogon.fSavePassword)
        pAccount->SetPropSz(apidPassword, pServer->szPassword);
    else 
        pAccount->SetProp(apidPassword, NULL, 0);

    if (rLogon.fAlwaysPromptPassword && apidPromptPwd)
        pAccount->SetPropDw(apidPromptPwd, !rLogon.fSavePassword);

    // Save Changes
    if (fSaveChanges)
        pAccount->SaveChanges();

    // Everything is good
    hr = S_OK;

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// TaskUtil_LogonPromptDlgProc
// ------------------------------------------------------------------------------------
INT_PTR CALLBACK TaskUtil_LogonPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPLOGONINFO     pLogon=(LPLOGONINFO)GetWndThisPtr(hwnd);
    CHAR            szRes[CCHMAX_RES];
    CHAR            szTitle[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the pointer
        pLogon = (LPLOGONINFO)lParam;
        Assert(pLogon);

        // AddRef the pointer
        Assert(pLogon->pszAccount);
        Assert(pLogon->pszServer);
        Assert(pLogon->pszUserName);
        Assert(pLogon->pszPassword);

        // Center remember location
        CenterDialog(hwnd);

	    // Limit Text
        Edit_LimitText(GetDlgItem(hwnd, IDE_ACCOUNT), CCHMAX_USERNAME-1);
        Edit_LimitText(GetDlgItem(hwnd, IDE_PASSWORD), CCHMAX_PASSWORD-1);

        // Set Window Title
        if (!FIsEmptyA(pLogon->pszAccount))
        {
            GetWindowText(hwnd, szRes, sizeof(szRes)/sizeof(TCHAR));
            wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s - %s", szRes, pLogon->pszAccount);
            SetWindowText(hwnd, szTitle);
        }

        // Set Server
        if (!FIsEmptyA(pLogon->pszServer))
            Edit_SetText(GetDlgItem(hwnd, IDS_SERVER), pLogon->pszServer);

        // Set User Name
        if (!FIsEmptyA(pLogon->pszUserName))
        {
            Edit_SetText(GetDlgItem(hwnd, IDE_ACCOUNT), pLogon->pszUserName);
            SetFocus(GetDlgItem(hwnd, IDE_PASSWORD));
        }
        else 
            SetFocus(GetDlgItem(hwnd, IDE_ACCOUNT));

        // Set Password 
        if (!FIsEmptyA(pLogon->pszPassword))
            Edit_SetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pszPassword);

        // Remember Password
        CheckDlgButton(hwnd, IDCH_REMEMBER, pLogon->fSavePassword);

        if (!pLogon->fAlwaysPromptPassword)
            EnableWindow(GetDlgItem(hwnd, IDCH_REMEMBER), FALSE);

        // Save the pointer
        SetWndThisPtr(hwnd, pLogon);
        return FALSE;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return 1;

        case IDOK:
            Assert(pLogon);
            if (pLogon)
            {
                // Pray
                Assert(pLogon->pszUserName);
                Assert(pLogon->pszPassword);

                // User Name
                if (pLogon->pszUserName)
                    Edit_GetText(GetDlgItem(hwnd, IDE_ACCOUNT), pLogon->pszUserName, CCHMAX_USERNAME);

                // Password
                if (pLogon->pszPassword)
                    Edit_GetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pszPassword, CCHMAX_PASSWORD);

                // Save Password
                pLogon->fSavePassword = IsDlgButtonChecked(hwnd, IDCH_REMEMBER);
            }
            EndDialog(hwnd, IDOK);
            return 1;
        }
        break;

    case WM_DESTROY:
        SetWndThisPtr(hwnd, NULL);
        return 0;
    }

    // Done
    return 0;
}

// ------------------------------------------------------------------------------------
// TaskUtil_HwndOnTimeout
// ------------------------------------------------------------------------------------
HWND TaskUtil_HwndOnTimeout(LPCSTR pszServer, LPCSTR pszAccount, LPCSTR pszProtocol, DWORD dwTimeout,
    ITimeoutCallback *pCallback)
{
    // Locals
    TIMEOUTINFO rTimeout;

    // Init
    ZeroMemory(&rTimeout, sizeof(TIMEOUTINFO));
    rTimeout.pszProtocol = pszProtocol;
    rTimeout.pszServer = pszServer;
    rTimeout.pszAccount = pszAccount;
    rTimeout.dwTimeout = dwTimeout;
    rTimeout.pCallback = pCallback;

    // Modeless Dialog
    HWND hwnd = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddTimeout), NULL, TaskUtil_TimeoutPromptDlgProc, (LPARAM)&rTimeout);

    // Failure
    if (hwnd)
        SetForegroundWindow(hwnd);

    // Done
    return hwnd;
}

// ------------------------------------------------------------------------------------
// TaskUtil_TimeoutPromptDlgProc
// ------------------------------------------------------------------------------------
INT_PTR CALLBACK TaskUtil_TimeoutPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    ITimeoutCallback *pCallback=(ITimeoutCallback *)GetWndThisPtr(hwnd);
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the pointer
        {
            LPTIMEOUTINFO pTimeout = (LPTIMEOUTINFO)lParam;
            Assert(pTimeout);

            // Validate pIn
            Assert(pTimeout->pszServer && pTimeout->pszAccount && pTimeout->pszProtocol && pTimeout->pCallback);

            // Center remember location
            CenterDialog(hwnd);

            // Get the text from the static
            CHAR szText[CCHMAX_RES + CCHMAX_RES];
            Edit_GetText(GetDlgItem(hwnd, IDC_TIMEOUT), szText, ARRAYSIZE(szText));

            // Format the message
            CHAR szAccount[CCHMAX_ACCOUNT_NAME];
            CHAR szWarning[CCHMAX_RES + CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_SERVER_NAME];
            PszEscapeMenuStringA(pTimeout->pszAccount, szAccount, ARRAYSIZE(szAccount));
            wnsprintf(szWarning, ARRAYSIZE(szWarning), szText, pTimeout->pszProtocol, pTimeout->dwTimeout, pTimeout->dwTimeout, szAccount, pTimeout->pszServer);

            // Set the Text
            Edit_SetText(GetDlgItem(hwnd, IDC_TIMEOUT), szWarning);

            // AddRef the Task
            pTimeout->pCallback->AddRef();

            // Save the pointer
            SetWndThisPtr(hwnd, pTimeout->pCallback);
        }
        return FALSE;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            Assert(pCallback);
            if (pCallback)
                {
                // IMAP's OnTimeoutResponse blocks on modal error dlg when disconnecting
                // during cmd in progress. Hide us to avoid confusion
                ShowWindow(hwnd, SW_HIDE);
                pCallback->OnTimeoutResponse(TIMEOUT_RESPONSE_STOP);
                }
            DestroyWindow(hwnd);
            return 1;

        case IDOK:
            Assert(pCallback);
            if (pCallback)
                pCallback->OnTimeoutResponse(TIMEOUT_RESPONSE_WAIT);
            DestroyWindow(hwnd);
            return 1;
        }
        break;

    case WM_DESTROY:
        Assert(pCallback);
        SafeRelease(pCallback);
        SetWndThisPtr(hwnd, NULL);
        return 0;
    }

    // Done
    return 0;
}


// ------------------------------------------------------------------------------------
// TaskUtil_CheckForPasswordPrompt
//
// Purpose: This function checks if the given account is set to always prompt for a
//   a password, and we do not have a password cached for this account. If both are
//   true, we make the spooler window visible so that we may prompt the user
//   for his password. This function should be called immediately after a spooler
//   event has been successfully registered. This function should not be called if
//   the caller already has AP_*_PROMPT_PASSWORD, AP_*_PORT and AP_*_SERVER properties:
//   in this case, the caller can call GetPassword to see if the password is cached.
//
// Arguments:
//   IImnAccount *pAccount [in] - the account associated with a successfully registered
//     spooler event.
//   DWORD dwSrvType [in] - the SRV_* type of this server, eg, SRV_IMAP or SRV_SMTP.
//   ISpoolerUI *pUI [in] - used to show the spooler window if this account matches
//     the criteria.
// ------------------------------------------------------------------------------------
#if 0 // Nobody seems to use this right now
void TaskUtil_CheckForPasswordPrompt(IImnAccount *pAccount, DWORD dwSrvType,
                                     ISpoolerUI *pUI)
{
    DWORD dwPromptPassPropID, dwPortPropID, dwServerPropID;
    DWORD fAlwaysPromptPassword, dwPort;
    char szServerName[CCHMAX_SERVER_NAME];
    HRESULT hrResult;

    Assert(SRV_IMAP == dwSrvType || SRV_NNTP == dwSrvType ||
        SRV_POP3 == dwSrvType || SRV_SMTP == dwSrvType);

    // Resolve property ID's
    switch (dwSrvType) {
        case SRV_IMAP:
            dwPromptPassPropID = AP_IMAP_PROMPT_PASSWORD;
            dwPortPropID = AP_IMAP_PORT;
            dwServerPropID = AP_IMAP_SERVER;
            break;

        case SRV_NNTP:
            dwPromptPassPropID = AP_NNTP_PROMPT_PASSWORD;
            dwPortPropID = AP_NNTP_PORT;
            dwServerPropID = AP_NNTP_SERVER;
            break;

        case SRV_POP3:
            dwPromptPassPropID = AP_POP3_PROMPT_PASSWORD;
            dwPortPropID = AP_POP3_PORT;
            dwServerPropID = AP_POP3_SERVER;
            break;

        case SRV_SMTP:
            dwPromptPassPropID = AP_SMTP_PROMPT_PASSWORD;
            dwPortPropID = AP_SMTP_PORT;
            dwServerPropID = AP_SMTP_SERVER;
            break;

        default:
            return; // We can't help you, buddy
    } // switch

    // If this account is set to always prompt for password and password isn't
    // already cached, show UI so we can prompt user for password
    hrResult = pAccount->GetPropDw(dwPromptPassPropID, &fAlwaysPromptPassword);
    if (FAILED(hrResult) || !fAlwaysPromptPassword)
        return;

    hrResult = pAccount->GetPropDw(dwPortPropID, &dwPort);
    if (FAILED(hrResult))
        return;

    hrResult = pAccount->GetPropSz(dwServerPropID, szServerName, sizeof(szServerName));
    if (FAILED(hrResult))
        return;

    hrResult = GetPassword(dwPort, szServerName, NULL, 0);
    if (FAILED(hrResult))
        // No cached password! Go ahead and make the spooler window visible
        pUI->ShowWindow(SW_SHOW);

} // TaskUtil_CheckForPasswordPrompt
#endif // 0

// ------------------------------------------------------------------------------------
// TaskUtil_OpenSentItemsFolder
//
// 1. If pAccount is a POP3 Account, then return the Local Store Sent Items.
// 2. If pAccount is a NEWS Account, then return the default mail account sent items.
// 3. Otherwise, return the sent items folder for the account (IMAP or HotMail).

// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OpenSentItemsFolder(IImnAccount *pAccount, IMessageFolder **ppFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idServer;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount    *pDefault=NULL;
    DWORD           dwServers;

    // Invalid Args
    Assert(pAccount && ppFolder);

    // Trace
    TraceCall("TaskUtil_OpenSentItemsFolder");

    // Get Sever Types
    IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));

    // If News Server, use default mail account instead...
    if (ISFLAGSET(dwServers, SRV_NNTP))
    {
        // Try to get the default mail account
        if (SUCCEEDED(g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pDefault)))
        {
            // Reset pAccount
            pAccount = pDefault;

            // Get Sever Types
            IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));
        }

        // Otherwise, use local store
        else
            dwServers = SRV_POP3;
    }

    // If pop3...
    if (ISFLAGSET(dwServers, SRV_POP3))
    {
        // Local Store
        idServer = FOLDERID_LOCAL_STORE;
    }

    // Otherwise...
    else
    {
        // Can't be new
        Assert(!ISFLAGSET(dwServers, SRV_NNTP));

        // Get the Account ID for pAccount
        IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));

        // Find the Server Id
        IF_FAILEXIT(hr = g_pStore->FindServerId(szAccountId, &idServer));
    }

    // Open Local Store
    IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_SENT, ppFolder));

exit:
    // If failed, try to open local store special
    if (FAILED(hr))
        hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_SENT, ppFolder);

    // Cleanup
    SafeRelease(pDefault);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\cleanup.cpp ===
//--------------------------------------------------------------------------
// Cleanup.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "cleanup.h"
#include "goptions.h"
#include "shlwapi.h"
#include "storutil.h"
#include "xpcomm.h"
#include "shared.h"
#include "syncop.h"
#include "storsync.h"
#include "instance.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Strings
// --------------------------------------------------------------------------------
static const LPSTR g_szCleanupWndProc = "OEStoreCleanupThread";
static const LPSTR c_szRegLastStoreCleaned = "Last Store Cleaned";
static const LPSTR c_szRegLastFolderCleaned = "Last Folder Cleaned";

// --------------------------------------------------------------------------------
// STOREFILETYPE
// --------------------------------------------------------------------------------
typedef enum tagSTOREFILETYPE {
    STORE_FILE_HEADERS,
    STORE_FILE_FOLDERS,
    STORE_FILE_POP3UIDL,
    STORE_FILE_OFFLINE,
    STORE_FILE_LAST
} STOREFILETYPE;

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
static BOOL             g_fShutdown=FALSE;

// --------------------------------------------------------------------------------
// CCompactProgress
// --------------------------------------------------------------------------------
class CCompactProgress : public IDatabaseProgress
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return TraceResult(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void) { return(2); }
    STDMETHODIMP_(ULONG) Release(void) { return(1); }
    STDMETHODIMP Update(DWORD cCount) { return(g_fShutdown ? hrUserCancel : S_OK); }
};

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
static DWORD            g_dwCleanupThreadId=0;
static HANDLE           g_hCleanupThread=NULL;
static HWND             g_hwndStoreCleanup=NULL;
static UINT_PTR         g_uDelayTimerId=0;
static HROWSET          g_hCleanupRowset=NULL;
static BOOL             g_fWorking=FALSE;
static STOREFILETYPE    g_tyCurrentFile=STORE_FILE_LAST;
static ILogFile        *g_pCleanLog=NULL;
static CCompactProgress g_cProgress;

// --------------------------------------------------------------------------------
// Timer Constants
// --------------------------------------------------------------------------------
#define IDT_START_CYCLE          (WM_USER + 1)
#define IDT_CLEANUP_FOLDER       (WM_USER + 2)
#define CYCLE_INTERVAL           (1000 * 60 * 30)

// --------------------------------------------------------------------------------
// CLEANUPTRHEADCREATE
// --------------------------------------------------------------------------------
typedef struct tagCLEANUPTRHEADCREATE {
    HRESULT         hrResult;
    HANDLE          hEvent;
} CLEANUPTRHEADCREATE, *LPCLEANUPTRHEADCREATE;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
DWORD   StoreCleanupThreadEntry(LPDWORD pdwParam);
LRESULT CALLBACK StoreCleanupWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT CleanupStoreInitializeCycle(HWND hwnd);
HRESULT CleanupCurrentFolder(HWND hwnd);
HRESULT SetNextCleanupFolder(HWND hwnd);
HRESULT StartCleanupCycle(HWND hwnd);
HRESULT CleanupNewsgroup(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcRemovedRead, LPDWORD pcRemovedExpired);
HRESULT CleanupJunkMail(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcJunkDeleted);

//--------------------------------------------------------------------------
// RegisterWindowClass
//--------------------------------------------------------------------------
HRESULT RegisterWindowClass(LPCSTR pszClass, WNDPROC pfnWndProc)
{
    // Locals
    HRESULT         hr=S_OK;
    WNDCLASS        WindowClass;

    // Tracing
    TraceCall("RegisterWindowClass");

    // Register the Window Class
    if (0 != GetClassInfo(g_hInst, pszClass, &WindowClass))
        goto exit;

    // Zero the object
    ZeroMemory(&WindowClass, sizeof(WNDCLASS));

    // Initialize the Window Class
    WindowClass.lpfnWndProc = pfnWndProc;
    WindowClass.hInstance = g_hInst;
    WindowClass.lpszClassName = pszClass;

    // Register the Class
    if (0 == RegisterClass(&WindowClass))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CreateNotifyWindow
//--------------------------------------------------------------------------
HRESULT CreateNotifyWindow(LPCSTR pszClass, LPVOID pvParam, HWND *phwndNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwnd;

    // Tracing
    TraceCall("CreateNotifyWindow");

    // Invalid ARg
    Assert(pszClass && phwndNotify);

    // Initialize
    *phwndNotify = NULL;

    // Create the Window
    hwnd = CreateWindowEx(WS_EX_TOPMOST, pszClass, pszClass, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInst, (LPVOID)pvParam);

    // Failure
    if (NULL == hwnd)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Set Return
    *phwndNotify = hwnd;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DelayedStartStoreCleanup
// --------------------------------------------------------------------------------
void CALLBACK DelayedStartStoreCleanup(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    // Trace
    TraceCall("DelayedStartStoreCleanup");

    // Must have a timer
    Assert(g_uDelayTimerId);

    // Kill the Timer
    KillTimer(NULL, g_uDelayTimerId);

    // Set g_uDelayTimerId
    g_uDelayTimerId = 0;

    // Call this function with zero delay...
    StartBackgroundStoreCleanup(0);
}

// --------------------------------------------------------------------------------
// StartBackgroundStoreCleanup
// --------------------------------------------------------------------------------
HRESULT StartBackgroundStoreCleanup(DWORD dwDelaySeconds)
{
    // Locals
    HRESULT             hr=S_OK;
    CLEANUPTRHEADCREATE Create={0};

    // Trace
    TraceCall("StartBackgroundStoreCleanup");

    // Already Running ?
    if (NULL != g_hCleanupThread)
        return(S_OK);

    // If dwDelaySeconds is NOT zero, then lets start this function later
    if (0 != dwDelaySeconds)
    {
        // Trace
        TraceInfo(_MSG("Delayed start store cleanup in %d seconds.", dwDelaySeconds));

        // Set a timer to call this the delay function a little bit later
        g_uDelayTimerId = SetTimer(NULL, 0, (dwDelaySeconds * 1000), DelayedStartStoreCleanup);

        // Failure
        if (0 == g_uDelayTimerId)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Done
        return(S_OK);
    }

    // Trace
    TraceInfo("Starting store cleanup.");

    // Initialize
    Create.hrResult = S_OK;

    // Create an Event to synchonize creation
    Create.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == Create.hEvent)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Create the inetmail thread
    g_hCleanupThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)StoreCleanupThreadEntry, &Create, 0, &g_dwCleanupThreadId);
    if (NULL == g_hCleanupThread)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Wait for StoreCleanupThreadEntry to signal the event
    WaitForSingleObject(Create.hEvent, INFINITE);

    // Failure
    if (FAILED(Create.hrResult))
    {
        // Close
        SafeCloseHandle(g_hCleanupThread);

        // Reset Globals
        g_hCleanupThread = NULL;
        g_dwCleanupThreadId = 0;

        // Return
        hr = TrapError(Create.hrResult);

        // Done
        goto exit;
    }

exit:
    // Cleanup
    SafeCloseHandle(Create.hEvent);

    // Done
    return(hr);
}

// ------------------------------------------------------------------------------------
// CloseBackgroundStoreCleanup
// ------------------------------------------------------------------------------------
HRESULT CloseBackgroundStoreCleanup(void)
{
    // Trace
    TraceCall("CloseBackgroundStoreCleanup");

    // Trace
    TraceInfo("Terminating Store Cleanup thread.");

    // Kill the Timer
    if (g_uDelayTimerId)
    {
        KillTimer(NULL, g_uDelayTimerId);
        g_uDelayTimerId = 0;
    }

    // Invalid Arg
    if (0 != g_dwCleanupThreadId)
    {
        // Assert
        Assert(g_hCleanupThread && FALSE == g_fShutdown);

        // Set Shutdown bit
        g_fShutdown = TRUE;

        // Post quit message
        PostThreadMessage(g_dwCleanupThreadId, WM_QUIT, 0, 0);

        // Wait for event to become signaled
        WaitForSingleObject(g_hCleanupThread, INFINITE);
    }

    // Validate
    Assert(NULL == g_hwndStoreCleanup && 0 == g_dwCleanupThreadId);

    // If we have a handle
    if (NULL != g_hCleanupThread)
    {
        // Close the thread handle
        CloseHandle(g_hCleanupThread);

        // Reset Globals
        g_hCleanupThread = NULL;
    }

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// InitializeCleanupLogFile
// --------------------------------------------------------------------------------
HRESULT InitializeCleanupLogFile(void)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szLogFile[MAX_PATH];
    CHAR            szStoreRoot[MAX_PATH];

    // Trace
    TraceCall("InitializeCleanupLogFile");

    // Better not have a log file yet
    Assert(NULL == g_pCleanLog);

    // Open Log File
    IF_FAILEXIT(hr = GetStoreRootDirectory(szStoreRoot, ARRAYSIZE(szStoreRoot)));

    // MakeFilePath to cleanup.log
    IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, "cleanup.log", c_szEmpty, szLogFile, ARRAYSIZE(szLogFile)));

    // Open the LogFile
    IF_FAILEXIT(hr = CreateLogFile(g_hLocRes, szLogFile, "CLEANUP", 65536, &g_pCleanLog,
        FILE_SHARE_READ | FILE_SHARE_WRITE));

    // Write the Store root
    g_pCleanLog->WriteLog(LOGFILE_DB, szStoreRoot);

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// StoreCleanupThreadEntry
// --------------------------------------------------------------------------------
DWORD StoreCleanupThreadEntry(LPDWORD pdwParam) 
{  
    // Locals
    HRESULT                 hr=S_OK;
    MSG                     msg;
    DWORD                   dw;
    DWORD                   cb;
    LPCLEANUPTRHEADCREATE   pCreate;

    // Trace
    TraceCall("StoreCleanupThreadEntry");

    // We better have a parameter
    Assert(pdwParam);

    // Cast to create info
    pCreate = (LPCLEANUPTRHEADCREATE)pdwParam;

    // Initialize OLE
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        pCreate->hrResult = hr;
        SetEvent(pCreate->hEvent);
        return(1);
    }

    // Reset Shutdown Bit
    g_fShutdown = FALSE;

    // OpenCleanupLogFile
    InitializeCleanupLogFile();

    // Registery the window class
    IF_FAILEXIT(hr = RegisterWindowClass(g_szCleanupWndProc, StoreCleanupWindowProc));

    // Create the notification window
    IF_FAILEXIT(hr = CreateNotifyWindow(g_szCleanupWndProc, NULL, &g_hwndStoreCleanup));

    // Success
    pCreate->hrResult = S_OK;

    // Run at a low-priority
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    // Set Event
    SetEvent(pCreate->hEvent);

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Kill the timer
    if (g_uDelayTimerId)
    {
        KillTimer(NULL, g_uDelayTimerId);
        g_uDelayTimerId = 0;
    }

    // Kill the Current Timer
    KillTimer(g_hwndStoreCleanup, IDT_CLEANUP_FOLDER);

    // Kill the timer
    KillTimer(g_hwndStoreCleanup, IDT_START_CYCLE);

    // Kill the Window
    DestroyWindow(g_hwndStoreCleanup);
    g_hwndStoreCleanup = NULL;
    g_dwCleanupThreadId = 0;

    // Release LogFile
    SafeRelease(g_pCleanLog);

exit:
    // Failure
    if (FAILED(hr))
    {
        pCreate->hrResult = hr;
        SetEvent(pCreate->hEvent);
    }

    // Uninit
    CoUninitialize();

    // Done
    return 1;
}

// --------------------------------------------------------------------------------
// StoreCleanupWindowProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK StoreCleanupWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Trace
    TraceCall("StoreCleanupWindowProc");

    // Switch
    switch(msg)
    {
    // OnCreate
    case WM_CREATE:

        // Set the time to start the first cycle in one second
        SetTimer(hwnd, IDT_START_CYCLE, 1000, NULL);

        // Done
        return(0);

    // OnTime
    case WM_TIMER:

        // Cleanup Folder Timer
        if (IDT_CLEANUP_FOLDER == wParam)
        {
            // Kill the Current Timer
            KillTimer(hwnd, IDT_CLEANUP_FOLDER);

            // Cleanup the Next Folder
            CleanupCurrentFolder(hwnd);
        }

        // Start new cleanup cycle
        else if (IDT_START_CYCLE == wParam)
        {
            // Kill the timer
            KillTimer(hwnd, IDT_START_CYCLE);

            // Start a new cycle
            StartCleanupCycle(hwnd);
        }

        // Done
        return(0);

    // OnDestroy
    case WM_DESTROY:

        // Close the Current Rowset
        g_pLocalStore->CloseRowset(&g_hCleanupRowset);

        // Done
        return(0);
    }

    // Deletegate
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

// --------------------------------------------------------------------------------
// StartCleanupCycle
// --------------------------------------------------------------------------------
HRESULT StartCleanupCycle(HWND hwnd)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("StartCleanupCycle");

    // Validate State
    Assert(g_pLocalStore && NULL == g_hCleanupRowset);

    // Logfile
    if (g_pCleanLog)
    {
        // WriteLogFile
        g_pCleanLog->WriteLog(LOGFILE_DB, "Starting Background Cleanup Cycle...");
    }

    // Create a Store Rowset
    IF_FAILEXIT(hr = g_pLocalStore->CreateRowset(IINDEX_SUBSCRIBED, NOFLAGS, &g_hCleanupRowset));

    // Set state
    g_tyCurrentFile = STORE_FILE_HEADERS;

    // Cleanup this folder...
    SetTimer(hwnd, IDT_CLEANUP_FOLDER, 100, NULL);

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupCurrentFolder
// --------------------------------------------------------------------------------
HRESULT CleanupCurrentFolder(HWND hwnd)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCSTR              pszFile=NULL;
    FOLDERTYPE          tyFolder=FOLDER_INVALID;
    SPECIALFOLDER       tySpecial=FOLDER_NOTSPECIAL;
    FOLDERINFO          Folder={0};
    DWORD               cRecords;
    DWORD               cbAllocated;
    DWORD               cbFreed;
    DWORD               cbStreams;
    DWORD               cbFile;
    DWORD               dwWasted;
    DWORD               dwCompactAt;
    DWORD               cRemovedRead=0;
    DWORD               cRemovedExpired=0;
    DWORD               cJunkDeleted=0;
    IDatabase          *pDB=NULL;
    IMessageFolder     *pFolderObject=NULL;

    // Trace
    TraceCall("CleanupCurrentFolder");

    // Validate
    Assert(g_pLocalStore);

    // Get Next Folder
    if (STORE_FILE_HEADERS == g_tyCurrentFile)
    {
        // Better have a rowset
        Assert(g_hCleanupRowset);
        
        // Get a Folder
        hr = g_pLocalStore->QueryRowset(g_hCleanupRowset, 1, (LPVOID *)&Folder, NULL);
        if (FAILED(hr) || S_FALSE == hr)
        {
            // Don with Current Cycle
            g_pLocalStore->CloseRowset(&g_hCleanupRowset);

            // Set g_tyCurrentFile
            g_tyCurrentFile = STORE_FILE_FOLDERS;
        }

        // Otherwise...
        else if (FOLDERID_ROOT == Folder.idFolder || ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        {
            // Goto Next
            goto exit;
        }

        // Otherwise
        else
        {
            // Set some stuff
            pszFile = Folder.pszFile;
            tyFolder = Folder.tyFolder;
            tySpecial = Folder.tySpecial;

            // If no folder file, then jump to exit
            if (NULL == pszFile)
                goto exit;

            // Open the folder object
            if (FAILED(g_pLocalStore->OpenFolder(Folder.idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
                goto exit;

            // Get the Database
            pFolderObject->GetDatabase(&pDB);
        }
    }

    // If something other than a folder
    if (STORE_FILE_HEADERS != g_tyCurrentFile)
    {
        // Locals
        LPCTABLESCHEMA pSchema=NULL;
        LPCSTR         pszName=NULL;
        CHAR           szRootDir[MAX_PATH + MAX_PATH];
        CHAR           szFilePath[MAX_PATH + MAX_PATH];

        // Folders
        if (STORE_FILE_FOLDERS == g_tyCurrentFile)
        {
            pszName = pszFile = c_szFoldersFile;
            pSchema = &g_FolderTableSchema;
            g_tyCurrentFile = STORE_FILE_POP3UIDL;
        }

        // Pop3uidl
        else if (STORE_FILE_POP3UIDL == g_tyCurrentFile)
        {
            pszName = pszFile = c_szPop3UidlFile;
            pSchema = &g_UidlTableSchema;
            g_tyCurrentFile = STORE_FILE_OFFLINE;
        }

        // Offline.dbx
        else if (STORE_FILE_OFFLINE == g_tyCurrentFile)
        {
            pszName = pszFile = c_szOfflineFile;
            pSchema = &g_SyncOpTableSchema;
            g_tyCurrentFile = STORE_FILE_LAST;
        }

        // Otherwise, we are done
        else if (STORE_FILE_LAST == g_tyCurrentFile)
        {
            // Set time to start next cycle
            SetTimer(hwnd, IDT_START_CYCLE, CYCLE_INTERVAL, NULL);

            // Done
            return(S_OK);
        }

        // Validate
        Assert(pSchema && pszName);

        // No File
        if (FIsEmptyA(pszFile))
            goto exit;

        // Get Root Directory
        IF_FAILEXIT(hr = GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir)));

        // Make File Path
        IF_FAILEXIT(hr = MakeFilePath(szRootDir, pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // If the File Exists?
        if (FALSE == PathFileExists(szFilePath))
            goto exit;

        // Open a Database Object on the file
        IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NORESET, pSchema, NULL, &pDB));
    }

    // Not Working 
    g_fWorking = TRUE;

    // Get Record Count
    IF_FAILEXIT(hr = pDB->GetRecordCount(IINDEX_PRIMARY, &cRecords));

    // If this is a news folder, and I'm the only person with it open...
    if (FOLDER_NEWS == tyFolder)
    {
        // Cleanup Newgroup
        CleanupNewsgroup(pszFile, pDB, &cRemovedRead, &cRemovedExpired);
    }

    // If this is the junk mail folder
    if ((FOLDER_LOCAL == tyFolder) && (FOLDER_JUNK == tySpecial))
    {
        // Cleanup Junk Mail folder
        CleanupJunkMail(pszFile, pDB, &cJunkDeleted);
    }

    // Get Size Information...
    IF_FAILEXIT(hr = pDB->GetSize(&cbFile, &cbAllocated, &cbFreed, &cbStreams));

    // Wasted
    dwWasted = cbAllocated > 0 ? ((cbFreed * 100) / cbAllocated) : 0;

    // Get Option about when to compact
    dwCompactAt = DwGetOption(OPT_CACHECOMPACTPER);

    // Trace
    if (g_pCleanLog)
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("%12s, CompactAt: %02d%%, Wasted: %02d%%, File: %09d, Records: %08d, Allocated: %09d, Freed: %08d, Streams: %08d, RemovedRead: %d, RemovedExpired: %d, JunkDeleted: %d", pszFile, dwCompactAt, dwWasted, cbFile, cRecords, cbAllocated, cbFreed, cbStreams, cRemovedRead, cRemovedExpired, cJunkDeleted));
    }

    // If less than 25% wasted space and there is more than a meg allocated
    if (dwWasted < dwCompactAt)
        goto exit;

    // Compact
    hr = pDB->Compact((IDatabaseProgress *)&g_cProgress, COMPACT_PREEMPTABLE | COMPACT_YIELD);

    // Log Result
    if (g_pCleanLog && S_OK != hr)
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("IDatabase::Compact(%s) Returned: 0x%08X", pszFile, hr));
    }

exit:
    // Cleanup
    SafeRelease(pDB);
    SafeRelease(pFolderObject);
    g_pLocalStore->FreeRecord(&Folder);

    // Not Working 
    g_fWorking = FALSE;

    // ShutDown
    if (FALSE == g_fShutdown)
    {
        // Compute Next CleanupFolder
        SetTimer(hwnd, IDT_CLEANUP_FOLDER, 100, NULL);
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupNewsgroup
// --------------------------------------------------------------------------------
HRESULT CleanupNewsgroup(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcRemovedRead, 
    LPDWORD pcRemovedExpired)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cExpireDays;
    BOOL        fRemoveExpired=FALSE;
    BOOL        fRemoveRead=FALSE;
    DWORD       cClients;
    FILETIME    ftCurrent;
    HROWSET     hRowset=NULL;
    MESSAGEINFO MsgInfo={0};

    // Trace
    TraceCall("CleanupNewsgroup");

    // Get Current Time
    GetSystemTimeAsFileTime(&ftCurrent);

    // Get the Number of Days in which to expire messages
    cExpireDays = DwGetOption(OPT_CACHEDELETEMSGS);

    // If the option is not off, set the flag
    fRemoveExpired = (OPTION_OFF == cExpireDays) ? FALSE : TRUE;

    // Remove Read ?
    fRemoveRead = (FALSE != DwGetOption(OPT_CACHEREAD) ? TRUE : FALSE);

    // Nothing to do
    if (FALSE == fRemoveExpired && FALSE == fRemoveRead)
        goto exit;

    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
    {
        // If I'm not the only client, then abort the cleanup
        IF_FAILEXIT(hr = pDB->GetClientCount(&cClients));

        // Better be 1
        if (cClients != 1)
        {
            hr = DB_E_COMPACT_PREEMPTED;
            goto exit;
        }

        // Abort
        if (S_OK != g_cProgress.Update(1))
        {
            hr = STORE_E_OPERATION_CANCELED;
            goto exit;
        }

        // Only if this message has a body
        if (!ISFLAGSET(MsgInfo.dwFlags, ARF_KEEPBODY) && !ISFLAGSET(MsgInfo.dwFlags, ARF_WATCH) && ISFLAGSET(MsgInfo.dwFlags, ARF_HASBODY) && MsgInfo.faStream)
        {
            // Otherwise, if expiring...
            if (TRUE == fRemoveExpired && (UlDateDiff(&MsgInfo.ftDownloaded, &ftCurrent) / SECONDS_INA_DAY) >= cExpireDays)
            {
                // Delete this message
                IF_FAILEXIT(hr = pDB->DeleteRecord(&MsgInfo));

                // Count Removed Expired
                (*pcRemovedExpired)++;
            }

            // Removing Read and this message is read ?
            else if (TRUE == fRemoveRead && ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            {
                // Delete the Stream
                pDB->DeleteStream(MsgInfo.faStream);

                // No More Stream
                MsgInfo.faStream = 0;

                // Fixup the Record
                FLAGCLEAR(MsgInfo.dwFlags, ARF_HASBODY | ARF_ARTICLE_EXPIRED);

                // Clear downloaded time
                ZeroMemory(&MsgInfo.ftDownloaded, sizeof(FILETIME));

                // Update the Record
                IF_FAILEXIT(hr = pDB->UpdateRecord(&MsgInfo));

                // Count Removed Read
                (*pcRemovedRead)++;
            }
        }

        // Free Current
        pDB->FreeRecord(&MsgInfo);
    }

exit:
    // Cleanup
    pDB->CloseRowset(&hRowset);
    pDB->FreeRecord(&MsgInfo);

    // Log File
    if (g_pCleanLog && FAILED(hr))
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("CleanupNewsgroup(%s) Returned: 0x%08X", pszFile, hr));
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupJunkMail
// --------------------------------------------------------------------------------
HRESULT CleanupJunkMail(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcJunkDeleted)
{
    // Locals
    HRESULT             hr = S_OK;
    FILETIME            ftCurrent = {0};
    DWORD               cDeleteDays = 0;
    IDatabase          *pUidlDB = NULL;
    HROWSET             hRowset = NULL;
    MESSAGEINFO         MsgInfo = {0};
    DWORD               cClients = 0;

    // Trace
    TraceCall("CleanupJunkMail");

    // Is there anything to do?
    if ((0 == DwGetOption(OPT_FILTERJUNK)) || (0 == DwGetOption(OPT_DELETEJUNK)) || (0 == (g_dwAthenaMode & MODE_JUNKMAIL)))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Get Current Time
    GetSystemTimeAsFileTime(&ftCurrent);

    // Get the Number of Days in which to expire messages
    cDeleteDays = DwGetOption(OPT_DELETEJUNKDAYS);

    // Open the UIDL Cache
    IF_FAILEXIT(hr = OpenUidlCache(&pUidlDB));
    
    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
    {
        // If I'm not the only client, then abort the cleanup
        IF_FAILEXIT(hr = pDB->GetClientCount(&cClients));

        // Better be 1
        if (cClients != 1)
        {
            hr = DB_E_COMPACT_PREEMPTED;
            goto exit;
        }

        // Abort
        if (S_OK != g_cProgress.Update(1))
        {
            hr = STORE_E_OPERATION_CANCELED;
            goto exit;
        }

        // Has the message been around long enough?
        if (cDeleteDays <= (UlDateDiff(&MsgInfo.ftDownloaded, &ftCurrent) / SECONDS_INA_DAY))
        {
            // Count Deleted
            (*pcJunkDeleted)++;

            // Delete the message
            IF_FAILEXIT(hr = DeleteMessageFromStore(&MsgInfo, pDB, pUidlDB));
        }

        // Free Current
        pDB->FreeRecord(&MsgInfo);
    }

    hr = S_OK;
    
exit:
    // Cleanup
    SafeRelease(pUidlDB);
    pDB->CloseRowset(&hRowset);
    pDB->FreeRecord(&MsgInfo);

    // Log File
    if (g_pCleanLog && FAILED(hr))
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("CleanupJunkMail(%s) Returned: 0x%08X", pszFile, hr));
    }

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\spooler\watchtsk.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     watchtsk.h
//
//  PURPOSE:    Defines the spooler task that is responsible for checking
//              for watched messages.
//

#pragma once

#include "spoolapi.h"
#include "storutil.h"

/////////////////////////////////////////////////////////////////////////////
// States for the state machine
//

typedef enum tagWATCHTASKSTATE
{
    WTS_IDLE = 0,
    WTS_CONNECTING,
    WTS_INIT,
    WTS_NEXTFOLDER,
    WTS_RESP,
    WTS_END,
    WTS_MAX
} WATCHTASKSTATE;

class CWatchTask;
typedef HRESULT (CWatchTask::*PFNWSTATEFUNC)(THIS_ void);


/////////////////////////////////////////////////////////////////////////////
// class CWatchTask
//
// Overview:
// This object is responsible for checking folders on the server for new 
// messages that might be part of a conversation the user is watching.  If
// one of these messages is found, then that message is downloaded into the
// users's store and the user is notified.
//

class CWatchTask : public ISpoolerTask, 
                   public IStoreCallback, 
                   public ITimeoutCallback
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    //
    CWatchTask();
    ~CWatchTask();    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    //
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    /////////////////////////////////////////////////////////////////////////
    // ISpoolerTask Interface
    //
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails);
    STDMETHODIMP Cancel(void);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback Interface
    // 
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback Interface
    //
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

protected:
    /////////////////////////////////////////////////////////////////////////
    // Window callback and message handling
    //
    static LRESULT CALLBACK _TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                         LPARAM lParam);

    /////////////////////////////////////////////////////////////////////////
    // General stuff
    //
    void CWatchTask::_NextState(void);
    BOOL _ChildFoldersHaveWatched(FOLDERID id);
    BOOL _FolderContainsWatched(FOLDERID id);

    /////////////////////////////////////////////////////////////////////////
    // State Machine functions, public but don't call 'em directly.
    //
public:
    HRESULT _Watch_Init(void);
    HRESULT _Watch_NextFolder(void);
    HRESULT _Watch_Done(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private data
    //

    ULONG                   m_cRef;         // Reference Count

    // State
    BOOL                    m_fInited;      // TRUE if we've had our Init() member called
    DWORD                   m_dwFlags;      // Execution flags from the spooler engine
    TCHAR                   m_szAccount[256];
    TCHAR                   m_szAccountId[256];
    FOLDERID                m_idAccount;
    EVENTID                 m_eidCur;       // The current executing event

    // Interfaces
    ISpoolerBindContext    *m_pBindCtx;     // Interface to communicate with the spooler engine
    ISpoolerUI             *m_pUI;          // Interface to communicate with the UI
    IImnAccount            *m_pAccount;     // Interface of the account we're checking
    IMessageServer         *m_pServer;      // Interface of the server object we're using
    IOperationCancel       *m_pCancel;      // Interface we use to cancel the current server op

    // Stuff
    FOLDERID                m_idFolderCheck;// If the user just want's us to check one folder
    FOLDERID               *m_rgidFolders;  // Array of all of the folders we need to check
    DWORD                   m_cFolders;     // Number of folders in m_rgidFolders
    HWND                    m_hwnd;         // Handle of our window
    HTIMEOUT                m_hTimeout;     // Handle of the timeout dialog
    DWORD                   m_cMsgs;        // Number of watched messages downloaded


    // State Machine goo
    DWORD                   m_state;
    BOOL                    m_fCancel;      // TRUE if the user has pressed the Cancel button
    DWORD                   m_cCurFolder;   // Current folder being checked.  Index's into m_rgidFolders;
    DWORD                   m_cFailed;      // Number of folders that could not be checked
    STOREOPERATIONTYPE      m_tyOperation;  // Current operation type

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\cleanup.h ===
//--------------------------------------------------------------------------
// Cleanup.h
//--------------------------------------------------------------------------
#ifndef __CLEANUP_H
#define __CLEANUP_H

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT StartBackgroundStoreCleanup(DWORD dwDelaySeconds);
HRESULT CloseBackgroundStoreCleanup(void);

#endif // __CLEANUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\dbimpl.h ===
//--------------------------------------------------------------------------
// dbimpl.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// IMPLEMENT_IDATABASE
//--------------------------------------------------------------------------
#define IMPLEMENT_IDATABASE(_fStreams, _pMember) \
    STDMETHODIMP Lock(LPHLOCK phLock) { return _pMember->Lock(phLock); } \
    STDMETHODIMP Unlock(LPHLOCK phLock) { return _pMember->Unlock(phLock); } \
    STDMETHODIMP MoveFile(LPCWSTR pszFileName) { return _pMember->MoveFile(pszFileName); } \
    STDMETHODIMP SetSize(DWORD cbSize) { return _pMember->SetSize(cbSize); } \
    STDMETHODIMP GetIndexInfo(INDEXORDINAL iIndex, LPSTR *ppszFilter, LPTABLEINDEX pIndex) { return _pMember->GetIndexInfo(iIndex, ppszFilter, pIndex); } \
    STDMETHODIMP ModifyIndex(INDEXORDINAL iIndex, LPCSTR pszFilter, LPCTABLEINDEX pIndexSrc) { return _pMember->ModifyIndex(iIndex, pszFilter, pIndexSrc); } \
    STDMETHODIMP DeleteIndex(INDEXORDINAL iIndex) { return _pMember->DeleteIndex(iIndex); } \
    STDMETHODIMP InsertRecord(LPVOID pRecord) { return _pMember->InsertRecord(pRecord); } \
    STDMETHODIMP UpdateRecord(LPVOID pRecord) { return _pMember->UpdateRecord(pRecord); } \
    STDMETHODIMP DeleteRecord(LPVOID pRecord) { return _pMember->DeleteRecord(pRecord); } \
    STDMETHODIMP FindRecord(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pRecord, LPROWORDINAL piRow) { return _pMember->FindRecord(iIndex, cColumns, pRecord, piRow); } \
    STDMETHODIMP GetRowOrdinal(INDEXORDINAL iIndex, LPVOID pRecord, LPROWORDINAL piRow) { return _pMember->GetRowOrdinal(iIndex, pRecord, piRow); } \
    STDMETHODIMP CreateRowset(INDEXORDINAL iIndex, CREATEROWSETFLAGS dwFlags, LPHROWSET phRowset) { return _pMember->CreateRowset(iIndex, dwFlags, phRowset); } \
    STDMETHODIMP SeekRowset(HROWSET hRowset, SEEKROWSETTYPE tySeek, LONG cRows, LPROWORDINAL piRowNew) { return _pMember->SeekRowset(hRowset, tySeek, cRows, piRowNew); } \
    STDMETHODIMP QueryRowset(HROWSET hRowset, LONG cWanted, LPVOID *prgpRecord, LPDWORD pcObtained) { return _pMember->QueryRowset(hRowset, cWanted, prgpRecord, pcObtained); } \
    STDMETHODIMP CloseRowset(LPHROWSET phRowset) { return _pMember->CloseRowset(phRowset); } \
    STDMETHODIMP FreeRecord(LPVOID pRecord) { return _pMember->FreeRecord(pRecord); } \
    STDMETHODIMP CreateStream(LPFILEADDRESS pfaStart) { Assert(_fStreams); return _pMember->CreateStream(pfaStart); } \
    STDMETHODIMP CopyStream(IDatabase *pDest, FILEADDRESS faStream, LPFILEADDRESS pfaNew) { Assert(_fStreams); return _pMember->CopyStream(pDest, faStream, pfaNew); } \
    STDMETHODIMP DeleteStream(FILEADDRESS faStart) { Assert(_fStreams); return _pMember->DeleteStream(faStart); } \
    STDMETHODIMP OpenStream(ACCESSTYPE tyAccess, FILEADDRESS faStart, IStream **ppStream) { Assert(_fStreams); return _pMember->OpenStream(tyAccess, faStart, ppStream); } \
    STDMETHODIMP ChangeStreamLock(IStream *pStream, ACCESSTYPE tyAccessNew) { Assert(_fStreams); return _pMember->ChangeStreamLock(pStream, tyAccessNew); } \
    STDMETHODIMP GetUserData(LPVOID pvUserData, ULONG cbUserData) { return _pMember->GetUserData(pvUserData, cbUserData); } \
    STDMETHODIMP SetUserData(LPVOID pvUserData, ULONG cbUserData) { return _pMember->SetUserData(pvUserData, cbUserData); } \
    STDMETHODIMP GetRecordCount(INDEXORDINAL iIndex, LPDWORD pcRecords) { return _pMember->GetRecordCount(iIndex, pcRecords); } \
    STDMETHODIMP GetFile(LPWSTR *ppszFile) { return _pMember->GetFile(ppszFile); } \
    STDMETHODIMP GetSize(LPDWORD pcbFile, LPDWORD pcbAllocated, LPDWORD pcbFreed, LPDWORD pcbStreams) { return _pMember->GetSize(pcbFile, pcbAllocated, pcbFreed, pcbStreams); } \
    STDMETHODIMP Compact(IDatabaseProgress *pProgress, COMPACTFLAGS dwFlags) { return _pMember->Compact(pProgress, dwFlags); } \
    STDMETHODIMP DispatchNotify(IDatabaseNotify *pNotify) { return _pMember->DispatchNotify(pNotify); } \
    STDMETHODIMP RegisterNotify(INDEXORDINAL iIndex, REGISTERNOTIFYFLAGS dwFlags, DWORD_PTR dwCookie, IDatabaseNotify *pNotify)  { return _pMember->RegisterNotify(iIndex, dwFlags, dwCookie, pNotify); } \
    STDMETHODIMP SuspendNotify(IDatabaseNotify *pNotify) { return _pMember->SuspendNotify(pNotify); } \
    STDMETHODIMP ResumeNotify(IDatabaseNotify *pNotify) { return _pMember->ResumeNotify(pNotify); } \
    STDMETHODIMP UnregisterNotify(IDatabaseNotify *pNotify) { return _pMember->UnregisterNotify(pNotify); } \
    STDMETHODIMP GenerateId(LPDWORD pdwId) { return _pMember->GenerateId(pdwId); } \
    STDMETHODIMP LockNotify(LOCKNOTIFYFLAGS dwFlags, LPHLOCK phLock) { return _pMember->LockNotify(dwFlags, phLock); } \
    STDMETHODIMP UnlockNotify(LPHLOCK phLock) { return _pMember->UnlockNotify(phLock); } \
    STDMETHODIMP GetClientCount(LPDWORD pcClients) { return _pMember->GetClientCount(pcClients); } \
    STDMETHODIMP Repair(void) { return _pMember->Repair(); } \
    STDMETHODIMP HeapFree(LPVOID pBuffer) { return _pMember->HeapFree(pBuffer); } \
    STDMETHODIMP HeapAllocate(DWORD dwFlags, DWORD cbSize, LPVOID *ppBuffer) { return _pMember->HeapAllocate(dwFlags, cbSize, ppBuffer); } \
    STDMETHODIMP GetTransaction(LPHTRANSACTION phTransaction, LPTRANSACTIONTYPE ptyTransaction, LPVOID pRecord1, LPVOID pRecord2, LPINDEXORDINAL piIndex, LPORDINALLIST pOrdinals) { return _pMember->GetTransaction(phTransaction, ptyTransaction, pRecord1, pRecord2, piIndex, pOrdinals); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\enumsync.h ===
#pragma once

//--------------------------------------------------------------------------
// CEnumerateSyncOps
//--------------------------------------------------------------------------
class CEnumerateSyncOps : public IUnknown
{
public:
    //----------------------------------------------------------------------
    // CEnumerateSyncOps
    //----------------------------------------------------------------------
    CEnumerateSyncOps(void);
    ~CEnumerateSyncOps(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // CEnumerateSyncOps Members
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDB, FOLDERID idServer);

    //----------------------------------------------------------------------
    // IEnumerateFolders Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(LPSYNCOPINFO pInfo);
    STDMETHODIMP Count(ULONG *pcItems);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Skip(ULONG cItems);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;
    SYNCOPID           *m_pid;
    DWORD               m_iid;
    DWORD               m_cid;
    DWORD               m_cidBuf;
    FOLDERID            m_idServer;
    IDatabase          *m_pDB;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\enumfold.h ===
//--------------------------------------------------------------------------
// EnumFold.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// CEnumerateFolders
//--------------------------------------------------------------------------
class CEnumerateFolders : public IEnumerateFolders
{
public:
    //----------------------------------------------------------------------
    // CEnumerateFolders
    //----------------------------------------------------------------------
    CEnumerateFolders(void);
    ~CEnumerateFolders(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // CEnumerateFolders Members
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDB, BOOL fSubscribed, FOLDERID idParent);

    //----------------------------------------------------------------------
    // IEnumerateFolders Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cFetch, LPFOLDERINFO prgInfo, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cItems);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumerateFolders **ppEnum);
    STDMETHODIMP Count(ULONG *pcItems);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _FreeFolderArray(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;
    FOLDERID            m_idParent;
    BOOL                m_fSubscribed;
    DWORD               m_cFolders;
    DWORD               m_iFolder;
    IDatabase          *m_pDB;
    IStream            *m_pStream;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\enummsgs.h ===
//--------------------------------------------------------------------------
// EnumMsgs.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// CEnumerateMessages
//--------------------------------------------------------------------------
class CEnumerateMessages : public IUnknown
{
public:
    //----------------------------------------------------------------------
    // CEnumerateMessages
    //----------------------------------------------------------------------
    CEnumerateMessages(void);
    ~CEnumerateMessages(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // CEnumerateMessages Members
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDB, MESSAGEID idParent);

    //----------------------------------------------------------------------
    // IEnumerateFolders Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cFetch, LPMESSAGEINFO prgInfo, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cItems);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(CEnumerateMessages **ppEnum);
    STDMETHODIMP Count(ULONG *pcItems);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;
    HROWSET             m_hRowset;
    MESSAGEID           m_idParent;
    IDatabase     *m_pDB;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\enumfold.cpp ===
//--------------------------------------------------------------------------
// EnumFold.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "enumfold.h"

//--------------------------------------------------------------------------
// CFOLDER_FETCH
//--------------------------------------------------------------------------
#define CFOLDER_FETCH_MIN           5
#define CFOLDER_FETCH_MID           30
#define CFOLDER_FETCH_MAX           200

//--------------------------------------------------------------------------
// CEnumerateFolders::CEnumerateFolders
//--------------------------------------------------------------------------
CEnumerateFolders::CEnumerateFolders(void)
{
    TraceCall("CEnumerateFolders::CEnumerateFolders");
    m_cRef = 1;
    m_pDB = NULL;
    m_fSubscribed = FALSE;
    m_idParent = FOLDERID_INVALID;
    m_pStream = NULL;
    m_cFolders = 0;
    m_iFolder = 0;
}

//--------------------------------------------------------------------------
// CEnumerateFolders::~CEnumerateFolders
//--------------------------------------------------------------------------
CEnumerateFolders::~CEnumerateFolders(void)
{
    TraceCall("CEnumerateFolders::~CEnumerateFolders");
    _FreeFolderArray();
    SafeRelease(m_pDB);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CEnumerateFolders::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IEnumerateFolders == riid)
        *ppv = (IEnumerateFolders *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateFolders::AddRef(void)
{
    TraceCall("CEnumerateFolders::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateFolders::Release(void)
{
    TraceCall("CEnumerateFolders::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CEnumerateFolders::_FreeFolderArray
//--------------------------------------------------------------------------
HRESULT CEnumerateFolders::_FreeFolderArray(void)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder;
    DWORD           cbRead;
    DWORD           cbSeek;

    // Trace
    TraceCall("CEnumerateFolders::_FreeFolderArray");

    // If we have a stream
    if (NULL == m_pStream)
        return(S_OK);

    // Seek to next folder that should be read
    cbSeek = (m_iFolder * sizeof(FOLDERINFO));

    // Seek
    IF_FAILEXIT(hr = HrStreamSeekSet(m_pStream, cbSeek));

    // Read Folder Infos
    while (S_OK == m_pStream->Read(&Folder, sizeof(FOLDERINFO), &cbRead) && cbRead)
    {
        // Free Folder Info
        m_pDB->FreeRecord(&Folder);
    }

exit:
    // Reset
    m_cFolders = m_iFolder = 0;

    // Free
    SafeRelease(m_pStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Initialize
//--------------------------------------------------------------------------
HRESULT CEnumerateFolders::Initialize(IDatabase *pDB, BOOL fSubscribed, 
    FOLDERID idParent)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWORDINAL      iFirstRow;
    HLOCK           hLock=NULL;
    HROWSET         hRowset=NULL;
    FOLDERINFO      Child={0};
    FOLDERINFO      rgFolder[CFOLDER_FETCH_MAX];
    DWORD           cWanted=CFOLDER_FETCH_MIN;
    DWORD           cFetched=0;
    DWORD           i;
    INDEXORDINAL    iIndex;

    // Trace
    TraceCall("CEnumerateFolders::Initialize");

    // Invalid Args
    Assert(pDB);

    // Release Current m_pDB
    SafeRelease(m_pDB);
    m_pDB = pDB;
    m_pDB->AddRef();

    // Unlock
    IF_FAILEXIT(hr = pDB->Lock(&hLock));

    // Free Folder Array
    _FreeFolderArray();

    // Save Subscribed
    m_fSubscribed = fSubscribed;

    // Subscribed Stuff
    iIndex = (fSubscribed ? IINDEX_SUBSCRIBED : IINDEX_ALL);

    // Save parent
    m_idParent = idParent;

    // Set idParent
    Child.idParent = idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(iIndex, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Stream
    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&m_pStream));

    // Write the Folder....
    IF_FAILEXIT(hr = m_pStream->Write(&Child, sizeof(FOLDERINFO), NULL));

    // One Folder
    m_cFolders++;

    // Don't Free Child
    Child.pAllocated = NULL;

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(iIndex, NOFLAGS, &hRowset));

    // Seek the rowset to the first row
    if (FAILED(m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iFirstRow, NULL)))
    {
        hr = S_OK;
        goto exit;
    }

    // Loop and fetch all folders...
    while (SUCCEEDED(m_pDB->QueryRowset(hRowset, cWanted, (LPVOID *)rgFolder, &cFetched)) && cFetched > 0)
    {
        // Write the Folder....
        IF_FAILEXIT(hr = m_pStream->Write(rgFolder, sizeof(FOLDERINFO) * cFetched, NULL));

        // Loop through cFetched
        for (i=0; i<cFetched; i++)
        {
            // Done ?
            if (rgFolder[i].idParent != m_idParent)
                goto exit;

            // Increment Folder Count
            m_cFolders++;
        }

        // Adjust cWanted for Perf.
        if (cWanted < CFOLDER_FETCH_MID && m_cFolders >= CFOLDER_FETCH_MID)
            cWanted = CFOLDER_FETCH_MID;
        if (cWanted < CFOLDER_FETCH_MAX && m_cFolders >= CFOLDER_FETCH_MAX)
            cWanted = CFOLDER_FETCH_MAX;
    }

exit:
    // Commit
    if (m_pStream)
    {
        // Commit
        m_pStream->Commit(STGC_DEFAULT);

        // Rewind
        HrRewindStream(m_pStream);
    }

    // Close the Rowset
    m_pDB->FreeRecord(&Child);

    // Close the Rowset
    m_pDB->CloseRowset(&hRowset);

    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Next
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Next(ULONG cWanted, LPFOLDERINFO prgInfo, ULONG *pcFetched)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cFetched=0;
    DWORD       cbRead;

    // Trace
    TraceCall("CEnumerateFolders::Next");

    // Initialize
    if (pcFetched)
        *pcFetched = 0;

    // Get some Records
    while (cFetched < cWanted && m_iFolder < m_cFolders)
    {
        // Read a Folder
        IF_FAILEXIT(hr = m_pStream->Read(&prgInfo[cFetched], sizeof(FOLDERINFO), &cbRead));

        // Validate
        Assert(sizeof(FOLDERINFO) == cbRead && prgInfo[cFetched].idParent == m_idParent);

        // Increment m_iFolder
        m_iFolder++;

        // Increment iFetch
        cFetched++;
    }

    // Initialize
    if (pcFetched)
        *pcFetched = cFetched;

exit:
    // Done
    return(cFetched == cWanted) ? S_OK : S_FALSE;
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Skip
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Skip(ULONG cItems)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERINFO      Folder;

    // Trace
    TraceCall("CEnumerateFolders::Skip");

    // Loop...
    for (i=0; i<cItems; i++)
    {
        // Next
        IF_FAILEXIT(hr = Next(1, &Folder, NULL));

        // Done
        if (S_OK != hr)
            break;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Reset
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Reset(void)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CEnumerateFolders::Reset");

    // Initialize MySelf
    IF_FAILEXIT(hr = Initialize(m_pDB, m_fSubscribed, m_idParent));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Clone
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Clone(IEnumerateFolders **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    CEnumerateFolders  *pEnum=NULL;

    // Trace
    TraceCall("CEnumerateFolders::Clone");

    // Allocate a New Enumerator
    IF_NULLEXIT(pEnum = new CEnumerateFolders);

    // Initialzie
    IF_FAILEXIT(hr = pEnum->Initialize(m_pDB, m_fSubscribed, m_idParent));

    // Return It
    *ppEnum = (IEnumerateFolders *)pEnum;

    // Don't Release It
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Release
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Count(ULONG *pcItems)
{
    // Trace
    TraceCall("CEnumerateFolders::Next");

    // Return Folder count
    *pcItems = m_cFolders;

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\enummsgs.cpp ===
//--------------------------------------------------------------------------
// EnumMsgs.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "enummsgs.h"

//--------------------------------------------------------------------------
// CEnumerateMessages::CEnumerateMessages
//--------------------------------------------------------------------------
CEnumerateMessages::CEnumerateMessages(void)
{
    TraceCall("CEnumerateMessages::CEnumerateMessages");
    m_cRef = 1;
    m_hRowset = NULL;
    m_pDB = NULL;
    m_idParent = MESSAGEID_INVALID;
}

//--------------------------------------------------------------------------
// CEnumerateMessages::~CEnumerateMessages
//--------------------------------------------------------------------------
CEnumerateMessages::~CEnumerateMessages(void)
{
    TraceCall("CEnumerateMessages::~CEnumerateMessages");
    if (m_hRowset && m_pDB)
        m_pDB->CloseRowset(&m_hRowset);
    SafeRelease(m_pDB);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CEnumerateMessages::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateMessages::AddRef(void)
{
    TraceCall("CEnumerateMessages::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateMessages::Release(void)
{
    TraceCall("CEnumerateMessages::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Initialize
//--------------------------------------------------------------------------
HRESULT CEnumerateMessages::Initialize(IDatabase *pDB, MESSAGEID idParent)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Child={0};
    ROWORDINAL      iFirstRow;

    // Trace
    TraceCall("CEnumerateMessages::Initialize");

    // Invalid Args
    Assert(pDB);

    // Reset ?
    if (m_hRowset && m_pDB)
        m_pDB->CloseRowset(&m_hRowset);
    SafeRelease(m_pDB);

    // Save parent
    m_idParent = idParent;

    // Save pStore
    m_pDB = pDB;
    m_pDB->AddRef();

    // Set idParent
    Child.idParent = idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_THREADS, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_THREADS, NOFLAGS, &m_hRowset));

    // Seek the rowset to the first row
    IF_FAILEXIT(hr = m_pDB->SeekRowset(m_hRowset, SEEK_ROWSET_BEGIN, iFirstRow - 1, NULL));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Child);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Next
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Next(ULONG cWanted, LPMESSAGEINFO prgInfo, 
    ULONG *pcFetched)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cFetched=0;

    // Trace
    TraceCall("CEnumerateMessages::Next");

    // Initialize
    if (pcFetched)
        *pcFetched = 0;

    // Nothing
    if (NULL == m_hRowset)
        return(S_FALSE);

    // Validate
    Assert(m_pDB);

    // Query the Rowset for cFetch Rows...
    IF_FAILEXIT(hr = m_pDB->QueryRowset(m_hRowset, cWanted, (LPVOID *)prgInfo, &cFetched));

    // Adjust Actual Fetched based on m_idParent
    while(cFetched && prgInfo[cFetched - 1].idParent != m_idParent)
    {
        // Free prgInfo
        m_pDB->FreeRecord(&prgInfo[cFetched - 1]);

        // Decrement cFetched
        cFetched--;
    }

    // Return pcFetched
    if (pcFetched)
        *pcFetched = cFetched;

exit:
    // Done
    return(cFetched == cWanted) ? S_OK : S_FALSE;
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Skip
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Skip(ULONG cItems)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CEnumerateMessages::Skip");

    // Loop...
    for (i=0; i<cItems; i++)
    {
        // Query the Rowset for cFetch Rows...
        IF_FAILEXIT(hr = m_pDB->QueryRowset(m_hRowset, 1, (LPVOID *)&Message, NULL));

        // Different Parent
        if (Message.idParent != m_idParent)
            break;

        // Free
        m_pDB->FreeRecord(&Message);
    }

exit:
    // Free
    m_pDB->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Reset
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Reset(void)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Child={0};
    ROWORDINAL      iFirstRow;

    // Trace
    TraceCall("CEnumerateMessages::Reset");

    // Close Rowset
    m_pDB->CloseRowset(&m_hRowset);

    // Set idParent
    Child.idParent = m_idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_THREADS, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_THREADS, NOFLAGS, &m_hRowset));

    // Seek the rowset to the first row
    IF_FAILEXIT(hr = m_pDB->SeekRowset(m_hRowset, SEEK_ROWSET_BEGIN, iFirstRow - 1, NULL));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Child);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Clone
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Clone(CEnumerateMessages **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    CEnumerateMessages  *pEnum=NULL;

    // Trace
    TraceCall("CEnumerateMessages::Clone");

    // Allocate a New Enumerator
    IF_NULLEXIT(pEnum = new CEnumerateMessages);

    // Initialzie
    IF_FAILEXIT(hr = pEnum->Initialize(m_pDB, m_idParent));

    // Return It
    *ppEnum = (CEnumerateMessages *)pEnum;

    // Don't Release It
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Release
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Count(ULONG *pcItems)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Child={0};
    MESSAGEINFO     Message={0};
    ROWORDINAL      iFirstRow;
    HROWSET         hRowset;

    // Trace
    TraceCall("CEnumerateMessages::Next");

    // Init
    *pcItems = 0;

    // Set idParent
    Child.idParent = m_idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_THREADS, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_THREADS, NOFLAGS, &hRowset));

    // Seek the rowset to the first row
    IF_FAILEXIT(hr = m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iFirstRow - 1, NULL));

    // Walk the Rowset
    while (S_OK == m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL) && Message.idParent == m_idParent)
    {
        // Increment Count
        (*pcItems)++;

        // Free
        m_pDB->FreeRecord(&Message);
    }

exit:
    // Cleanup
    m_pDB->CloseRowset(&hRowset);
    m_pDB->FreeRecord(&Message);
    m_pDB->FreeRecord(&Child);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\enumsync.cpp ===
#include "pch.hxx"
#include "syncop.h"
#include "sync.h"
#include "enumsync.h"

//--------------------------------------------------------------------------
// CEnumerateSyncOps::CEnumerateSyncOps
//--------------------------------------------------------------------------
CEnumerateSyncOps::CEnumerateSyncOps(void)
{
    m_cRef = 1;
    m_pid = NULL;
    m_iid = 0;
    m_cid = 0;
    m_cidBuf = 0;
    m_pDB = NULL;
    m_idServer = FOLDERID_INVALID;
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::~CEnumerateSyncOps
//--------------------------------------------------------------------------
CEnumerateSyncOps::~CEnumerateSyncOps(void)
{
    SafeMemFree(m_pid);
    SafeRelease(m_pDB);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateSyncOps::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateSyncOps::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateSyncOps::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Initialize
//--------------------------------------------------------------------------
HRESULT CEnumerateSyncOps::Initialize(IDatabase *pDB, FOLDERID idServer)
{
    SYNCOPINFO      info;
    HROWSET         hRowset;
    DWORD           cBuf;
    HRESULT         hr;
    ROWORDINAL      iRow;

    Assert(pDB);

    Assert(idServer != m_idServer);

    // Save parent
    m_idServer = idServer;

    // Save pStore
    if (m_pDB != NULL)
        m_pDB->Release();
    m_pDB = pDB;
    m_pDB->AddRef();

    m_iid = 0;
    m_cid = 0;

    ZeroMemory(&info, sizeof(SYNCOPINFO));
    info.idServer = idServer;
    hr = m_pDB->FindRecord(IINDEX_ALL, 1, &info, &iRow);
    if (hr != DB_S_FOUND)
        return(S_OK);
    m_pDB->FreeRecord(&info);

    hr = m_pDB->CreateRowset(IINDEX_ALL, NOFLAGS, &hRowset);
    if (FAILED(hr))
        return(hr);

    hr = m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iRow - 1, NULL);
    if (SUCCEEDED(hr))
    {
        while (S_OK == m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&info, NULL))
        {
            if (info.idServer != idServer)
            {
                m_pDB->FreeRecord(&info);
                break;
            }

            if (m_cid == m_cidBuf)
            {
                cBuf = m_cidBuf + 256;
                if (!MemRealloc((void **)&m_pid, cBuf * sizeof(SYNCOPID)))
                {
                    m_pDB->FreeRecord(&info);
                    hr = E_OUTOFMEMORY;
                    break;
                }
                m_cidBuf = cBuf;
            }

            m_pid[m_cid] = info.idOperation;
            m_cid++;

            m_pDB->FreeRecord(&info);
        }
    }

    m_pDB->CloseRowset(&hRowset);

    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Next
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateSyncOps::Next(LPSYNCOPINFO pInfo)
{
    HRESULT hr;

    // Validate
    Assert(m_pDB != NULL);
    Assert(pInfo != NULL);

    if (m_iid >= m_cid)
        return(S_FALSE);

    ZeroMemory(pInfo, sizeof(SYNCOPINFO));
    pInfo->idOperation = m_pid[m_iid++];

    // Locate where the first record with idParent
    hr = m_pDB->FindRecord(IINDEX_PRIMARY, 1, pInfo, NULL);

    // Not Found
    if (DB_S_NOTFOUND == hr)
        hr = E_FAIL;
    else if (SUCCEEDED(hr))
        hr = S_OK;

    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Release
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateSyncOps::Count(ULONG *pcItems)
{
    Assert(pcItems != NULL);
    *pcItems = m_cid;

    return(S_OK);
}

STDMETHODIMP CEnumerateSyncOps::Reset()
{
    m_iid = 0;

    return(S_OK);
}

STDMETHODIMP CEnumerateSyncOps::Skip(ULONG cItems)
{
    m_iid += cItems;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\findfold.cpp ===
//--------------------------------------------------------------------------
// FindFold.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "finder.h"
#include "findfold.h"
#include "storutil.h"
#include "msgfldr.h"
#include "shlwapip.h" 
#include "storecb.h"

//--------------------------------------------------------------------------
// ENUMFINDFOLDERS
//--------------------------------------------------------------------------
typedef struct tagENUMFINDFOLDERS {
    LPFOLDERENTRY   prgFolder;
    DWORD           cFolders;
    DWORD           cAllocated;
    DWORD           cMax;
} ENUMFINDFOLDERS, *LPENUMFINDFOLDERS;

//--------------------------------------------------------------------------
// CLEAR_MESSAGE_FIELDS(_pMessage)
//--------------------------------------------------------------------------
#define CLEAR_MESSAGE_FIELDS(_Message) \
    _Message.pszUidl = NULL; \
    _Message.pszServer = NULL; \
    _Message.faStream = 0; \
    _Message.Offsets.cbSize = 0; \
    _Message.Offsets.pBlobData = NULL

//--------------------------------------------------------------------------
// EnumerateFindFolders
//--------------------------------------------------------------------------
HRESULT EnumerateFindFolders(LPFOLDERINFO pFolder, BOOL fSubFolders,
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERID            idDeleted;
    FOLDERID            idServer;
    LPENUMFINDFOLDERS   pEnum=(LPENUMFINDFOLDERS)dwCookie;
    LPFOLDERENTRY       pEntry;
    IMessageFolder     *pFolderObject=NULL;

    // Trace
    TraceCall("EnumerateFindFolders");

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) || FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Room For One More
    if (pEnum->cFolders + 1 > pEnum->cAllocated)
    {
        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&pEnum->prgFolder, sizeof(FOLDERENTRY) * (pEnum->cAllocated + 5)));

        // Set cAllocated
        pEnum->cAllocated += 5;
    }

    // Readability
    pEntry = &pEnum->prgFolder[pEnum->cFolders];

    // Open the Folder
    if (SUCCEEDED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
    {
        // Get the Database
        if (SUCCEEDED(pFolderObject->GetDatabase(&pEntry->pDB)))
        {
            // No Folder
            pEntry->pFolder = NULL;

            // fInDeleted
            if (S_OK == IsParentDeletedItems(pFolder->idFolder, &idDeleted, &idServer))
            {
                // We are in the deleted items folder
                pEntry->fInDeleted = TRUE;
            }

            // Otherwise, not in deleted items
            else
            {
                // Nope
                pEntry->fInDeleted = FALSE;
            }

            // Count Record
            IF_FAILEXIT(hr = pEntry->pDB->GetRecordCount(IINDEX_PRIMARY, &pEntry->cRecords));

            // Save the Folder id
            pEntry->idFolder = pFolder->idFolder;

            // Save the Folder Type
            pEntry->tyFolder = pFolder->tyFolder;

            // Increment Max
            pEnum->cMax += pEntry->cRecords;

            // Copy folder Name
            IF_NULLEXIT(pEntry->pszName = PszDupA(pFolder->pszName));

            // Increment Folder Count
            pEnum->cFolders++;
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolderObject);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::CFindFolder
//--------------------------------------------------------------------------
CFindFolder::CFindFolder(void)
{
    m_cRef = 1;
    m_pCriteria = NULL;
    m_pSearch = NULL;
    m_pStore = NULL;
    m_cFolders = 0;
    m_cAllocated = 0;
    m_cMax = 0;
    m_cCur = 0;
    m_fCancel = FALSE;
    m_prgFolder = NULL;
    m_pCallback = NULL;
    m_idRoot = FOLDERID_INVALID;
    m_idFolder = FOLDERID_INVALID;
    m_pMessage = NULL;
}

//--------------------------------------------------------------------------
// CFindFolder::~CFindFolder
//--------------------------------------------------------------------------
CFindFolder::~CFindFolder(void)
{
    // Locals
    LPACTIVEFINDFOLDER pCurrent;
    LPACTIVEFINDFOLDER pPrevious=NULL;

    // Thread Safety
    EnterCriticalSection(&g_csFindFolder);

    // Walk Through the global list of Active Search Folders
    for (pCurrent=g_pHeadFindFolder; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Is this it
        if (m_idFolder == pCurrent->idFolder)
        {
            // If there was a Previous
            if (pPrevious)
                pPrevious->pNext = pCurrent->pNext;

            // Otherwise, reset the header
            else
                g_pHeadFindFolder = pCurrent->pNext;

            // Free pCurrent
            g_pMalloc->Free(pCurrent);

            // Done
            break;
        }

        // Save Previous
        pPrevious = pCurrent;
    }

    // Thread Safety
    LeaveCriticalSection(&g_csFindFolder);

    // Release Database
    SafeRelease(m_pSearch);

    // Delete this folder
    if (FOLDERID_INVALID != m_idFolder && m_pStore)
    {
        // Delete this folder
        m_pStore->DeleteFolder(m_idFolder, DELETE_FOLDER_NOTRASHCAN, (IStoreCallback *)this);
    }

    // Release the Store
    SafeRelease(m_pStore);

    // Release the Callback
    SafeRelease(m_pCallback);

    // Free the Folder Array
    for (ULONG i=0; i<m_cFolders; i++)
    {
        // Free the Folder Name
        SafeMemFree(m_prgFolder[i].pszName);

        // Remove Notify
        m_prgFolder[i].pDB->UnregisterNotify((IDatabaseNotify *)this);

        // Release the Folder Object
        SafeRelease(m_prgFolder[i].pDB);

        // Release the Folder Object
        SafeRelease(m_prgFolder[i].pFolder);
    }

    // Release my mime message
    SafeRelease(m_pMessage);

    // Free the Array
    SafeMemFree(m_prgFolder);

    // Free Find Info
    if (m_pCriteria)
    {
        FreeFindInfo(m_pCriteria);
        SafeMemFree(m_pCriteria);
    }
}

//--------------------------------------------------------------------------
// CFindFolder::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFindFolder::AddRef(void)
{
    TraceCall("CFindFolder::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CFindFolder::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFindFolder::Release(void)
{
    TraceCall("CFindFolder::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CFindFolder::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CFindFolder::QueryInterface");

    // Invalid Arg
    Assert(ppv);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageFolder *)this;
    else if (IID_IMessageFolder == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IDatabaseNotify == riid)
        *ppv = (IDatabaseNotify *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::QueryService
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::QueryService(REFGUID guidService, REFIID riid, 
    LPVOID *ppvObject)
{
    // Trace
    TraceCall("CFindFolder::QueryService");

    // Just a Query Interface
    return(QueryInterface(riid, ppvObject));
}

//--------------------------------------------------------------------------
// CFindFolder::Initialize
//--------------------------------------------------------------------------
HRESULT CFindFolder::Initialize(IMessageStore *pStore, IMessageServer *pServer, 
    OPENFOLDERFLAGS dwFlags, FOLDERID idFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    FOLDERUSERDATA      UserData={0};
    TABLEINDEX          Index;
    LPACTIVEFINDFOLDER  pActiveFind;

    // Trace
    TraceCall("CFindFolder::Initialize");

    // I don't need a server
    Assert(NULL == pServer);

    // Invalid Arg
    if (NULL == pStore)
        return TraceResult(E_INVALIDARG);

    // Should be NULL
    Assert(NULL == m_pCriteria);

    // Save the Folder Id
    m_idRoot = idFolder;

    // Save the Store
    m_pStore = pStore;
    m_pStore->AddRef();

    // Fill Up My folder Info
    Folder.pszName = "Search Folder";
    Folder.tyFolder = FOLDER_LOCAL;
    Folder.tySpecial = FOLDER_NOTSPECIAL;
    Folder.dwFlags = FOLDER_HIDDEN | FOLDER_FINDRESULTS;
    Folder.idParent = FOLDERID_LOCAL_STORE;

    // Create a Folder
    IF_FAILEXIT(hr = m_pStore->CreateFolder(CREATE_FOLDER_UNIQUIFYNAME, &Folder, (IStoreCallback *)this));

    // Save the Id
    m_idFolder = Folder.idFolder;

    // Create a CMessageFolder Object
    IF_NULLEXIT(m_pSearch = new CMessageFolder);

    // Initialize
    IF_FAILEXIT(hr = m_pSearch->Initialize((IMessageStore *)pStore, NULL, NOFLAGS, m_idFolder));

    // Fill the IINDEX_FINDER Information
    ZeroMemory(&Index, sizeof(TABLEINDEX));
    Index.cKeys = 2;
    Index.rgKey[0].iColumn = MSGCOL_FINDFOLDER;
    Index.rgKey[1].iColumn = MSGCOL_FINDSOURCE;

    // Set Index
    IF_FAILEXIT(hr = m_pSearch->ModifyIndex(IINDEX_FINDER, NULL, &Index));

    // Allocate ACTIVEFINDFOLDER
    IF_NULLEXIT(pActiveFind = (LPACTIVEFINDFOLDER)ZeroAllocate(sizeof(ACTIVEFINDFOLDER)));

    // Set idFolder
    pActiveFind->idFolder = m_idFolder;

    // Set this
    pActiveFind->pFolder = this;

    // Thread Safety
    EnterCriticalSection(&g_csFindFolder);

    // Set Next
    pActiveFind->pNext = g_pHeadFindFolder;

    // Set Head
    g_pHeadFindFolder = pActiveFind;

    // Thread Safety
    LeaveCriticalSection(&g_csFindFolder);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::GetMessageFolderId
//--------------------------------------------------------------------------
HRESULT CFindFolder::GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message={0};

    // Trace
    TraceCall("CFindFolder::GetMessageFolderId");

    // Invalid Args
    if (NULL == m_pSearch || NULL == pidFolder)
        return TraceResult(E_INVALIDARG);

    // Initialize Message
    IF_FAILEXIT(hr = GetMessageInfo(m_pSearch, idMessage, &Message));

    // Get the Folder Entry
    *pidFolder = m_prgFolder[Message.iFindFolder].idFolder;

exit:
    // Done
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::GetMessageFolderType
//--------------------------------------------------------------------------
HRESULT CFindFolder::GetMessageFolderType(MESSAGEID idMessage, 
    FOLDERTYPE *ptyFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message={0};

    // Trace
    TraceCall("CFindFolder::GetMessageFolderType");

    // Invalid Args
    if (NULL == m_pSearch || NULL == ptyFolder)
        return TraceResult(E_INVALIDARG);

    // Initialize Message
    IF_FAILEXIT(hr = GetMessageInfo(m_pSearch, idMessage, &Message));

    // Get the Folder Entry
    *ptyFolder = m_prgFolder[Message.iFindFolder].tyFolder;

exit:
    // Done
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::StartFind
//--------------------------------------------------------------------------
HRESULT CFindFolder::StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    RECURSEFLAGS    dwFlags=RECURSE_ONLYSUBSCRIBED;
    ENUMFINDFOLDERS EnumFolders={0};

    // Trace
    TraceCall("CFindFolder::StartFind");

    // Invalid Arg
    if (NULL == pCriteria || NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Should be NULL
    Assert(NULL == m_pCriteria && m_pStore);

    // Allocate m_pCriteria
    IF_NULLEXIT(m_pCriteria = (FINDINFO *)g_pMalloc->Alloc(sizeof(FINDINFO)));

    // Copy the Find Info
    IF_FAILEXIT(hr = CopyFindInfo(pCriteria, m_pCriteria));

    // Hold Onto the Callback
    m_pCallback = pCallback;
    m_pCallback->AddRef();

    // Setup Flags
    if (FOLDERID_ROOT != m_idRoot)
        FLAGSET(dwFlags, RECURSE_INCLUDECURRENT);

    // SubFolder
    if (m_pCriteria->fSubFolders) 
        FLAGSET(dwFlags, RECURSE_SUBFOLDERS);

    // Build my Folder Table
    IF_FAILEXIT(hr = RecurseFolderHierarchy(m_idRoot, dwFlags, 0, (DWORD_PTR)&EnumFolders, (PFNRECURSECALLBACK)EnumerateFindFolders));

    // Take Stuff Back
    m_prgFolder = EnumFolders.prgFolder;
    m_cFolders = EnumFolders.cFolders;
    m_cAllocated = EnumFolders.cAllocated;
    m_cMax = EnumFolders.cMax;

    // Start the find...
    IF_FAILEXIT(hr = _StartFind());

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_StartFind
//--------------------------------------------------------------------------
HRESULT CFindFolder::_StartFind(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;

    // Trace
    TraceCall("CFindFolder::_StartFind");

    // Callback
    if (m_pCallback)
        m_pCallback->OnBegin(SOT_SEARCHING, NULL, (IOperationCancel *)this);

    // Loop through the Folders
    for (i=0; i<m_cFolders; i++)
    {
        // Query the Folder
        IF_FAILEXIT(hr = _SearchFolder(i));
    }

exit:
    // Callback
    if (m_pCallback)
        m_pCallback->OnComplete(SOT_SEARCHING, hr, NULL, NULL);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_SearchFolder
//--------------------------------------------------------------------------
HRESULT CFindFolder::_SearchFolder(DWORD iFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iRow=0;
    DWORD           cRows=0;
    HROWSET         hRowset=NULL;
    LPSTR           pszName;
    HLOCK           hNotify=NULL;
    MESSAGEINFO     rgMessage[100];
    BOOL            fFree=FALSE;
    LPFOLDERENTRY   pEntry;
    BOOL            fMatch;
    IDatabase      *pDB;
    DWORD           cMatch=0;

    // Trace
    TraceCall("CFindFolder::_SearchFolder");

    // Get pEntry
    pEntry = &m_prgFolder[iFolder];

    // Get the Folder Name
    pszName = pEntry->pszName;

    // Get the Folder Object
    pDB = pEntry->pDB;

    // Create a Rowset for this Folder
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Progress
    if (m_fCancel || (m_pCallback && S_FALSE == m_pCallback->OnProgress(SOT_SEARCHING, m_cCur, m_cMax, pszName)))
        goto exit;

    // Queue Notifications
    IF_FAILEXIT(hr = m_pSearch->LockNotify(NOFLAGS, &hNotify));

    // Walk the Rowset
    while (S_OK == pDB->QueryRowset(hRowset, 100, (LPVOID *)rgMessage, &cRows))
    {
        // Need to Free
        fFree = TRUE;

        // Walk through the Rows
        for (iRow=0; iRow<cRows; iRow++)
        {
            // Does Row Match Criteria
            IF_FAILEXIT(hr = _OnInsert(iFolder, &rgMessage[iRow], &fMatch));

            // Count Matched
            if (fMatch)
                cMatch++;

            // Incrment m_cCur
            m_cCur++;

            // Adjust the max
            if (m_cCur > m_cMax)
                m_cMax = m_cCur;

            // Do Progress Stuff
            if ((m_cCur % 50) == 0 && m_cCur > 0)
            {
                // Progress
                if (m_fCancel || (m_pCallback && S_FALSE == m_pCallback->OnProgress(SOT_SEARCHING, m_cCur, m_cMax, NULL)))
                {
                    // Register for a notifications on the stuff that we've searched
                    pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, iFolder, (IDatabaseNotify *)this);

                    // Done..
                    goto exit;
                }
            }

            // Do Progress Stuff
            if ((cMatch % 50) == 0 && cMatch > 0)
            {
                // Unlock the Notificaton Queue
                m_pSearch->UnlockNotify(&hNotify);

                // Lock It Again
                m_pSearch->LockNotify(NOFLAGS, &hNotify);
            }

            // Free It
            pDB->FreeRecord(&rgMessage[iRow]);
        }

        // No Need to Free
        fFree = FALSE;
    }

    // Register for a notificatoin on this folder
    pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, iFolder, (IDatabaseNotify *)this);

exit:
    // Unlock the Notificaton Queue
    m_pSearch->UnlockNotify(&hNotify);

    // Free ?
    if (fFree)
    {
        // Loop through remaining unfreed rows
        for (; iRow<cRows; iRow++)
        {
            // Free the Row
            pDB->FreeRecord(&rgMessage[iRow]);
        }
    }

    // Cleanup
    pDB->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_OnInsert
//--------------------------------------------------------------------------
HRESULT CFindFolder::_OnInsert(DWORD iFolder, LPMESSAGEINFO pInfo,
    BOOL *pfMatch, LPMESSAGEID pidNew /* =NULL */)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message;

    // Trace
    TraceCall("CFindFolder::_OnInsert");

    // Invalid Argts
    Assert(iFolder < m_cFolders && pInfo);

    // Init
    if (pfMatch)
        *pfMatch = FALSE;

    // Doesn't match my criteria ?
    if (S_FALSE == _IsMatch(iFolder, pInfo))
        goto exit;

    // Init
    if (pfMatch)
        *pfMatch = TRUE;

    // Copy the Message Info
    CopyMemory(&Message, pInfo, sizeof(MESSAGEINFO));

    // Store the Folder Name
    Message.pszFolder = m_prgFolder[iFolder].pszName;

    // Set the Source Id
    Message.idFindSource = Message.idMessage;

    // Set the Tag
    Message.iFindFolder = iFolder;

    // Generate a New Message Id
    IF_FAILEXIT(hr = m_pSearch->GenerateId((LPDWORD)&Message.idMessage));

    // Remove some stuff to make it smaller
    CLEAR_MESSAGE_FIELDS(Message);

    // Insert the Record
    IF_FAILEXIT(hr = m_pSearch->InsertRecord(&Message));

    // Return the Id
    if (pidNew)
        *pidNew = Message.idMessage;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_OnDelete
//--------------------------------------------------------------------------
HRESULT CFindFolder::_OnDelete(DWORD iFolder, LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message={0};

    // Trace
    TraceCall("CFindFolder::_OnDelete");

    // Invalid Argts
    Assert(iFolder < m_cFolders && pInfo);

    // Setup the Search key
    Message.iFindFolder = iFolder;
    Message.idFindSource = pInfo->idMessage;

    // Find It
    IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_FINDER, COLUMNS_ALL, &Message, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Delete this Record
    IF_FAILEXIT(hr = m_pSearch->DeleteRecord(&Message));
        
exit:
    // Cleanup
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_OnUpdate
//--------------------------------------------------------------------------
HRESULT CFindFolder::_OnUpdate(DWORD iFolder, LPMESSAGEINFO pInfo1,
    LPMESSAGEINFO pInfo2)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message;
    MESSAGEINFO Current={0};

    // Trace
    TraceCall("CFindFolder::_OnUpdate");

    // Invalid Argts
    Assert(iFolder < m_cFolders && pInfo1 && pInfo2);

    // Doesn't match my criteria ?
    if (S_FALSE == _IsMatch(iFolder, pInfo1))
    {
        // If the Original Record was not in the find folder, then see if record 2 should be added
        _OnInsert(iFolder, pInfo2, NULL);
    }

    // If pInfo2 should not be displayed, then delete pInfo1
    else if (S_FALSE == _IsMatch(iFolder, pInfo2))
    {
        // Delete pInfo1
        _OnDelete(iFolder, pInfo1);
    }

    // Otherwise, update pInfo1
    else
    {
        // Setup the Search key
        Current.iFindFolder = iFolder;
        Current.idFindSource = pInfo1->idMessage;

        // Find It
        IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_FINDER, COLUMNS_ALL, &Current, NULL));

        // Not Found
        if (DB_S_NOTFOUND == hr)
        {
            hr = TraceResult(DB_E_NOTFOUND);
            goto exit;
        }
        
        // Copy the Message Info
        CopyMemory(&Message, pInfo2, sizeof(MESSAGEINFO));

        // Fixup the Version
        Message.bVersion = Current.bVersion;

        // Store the Folder Name
        Message.pszFolder = m_prgFolder[iFolder].pszName;

        // Set the Source Id
        Message.idFindSource = Current.idFindSource;

        // Set the Tag
        Message.iFindFolder = iFolder;

        // Set the id
        Message.idMessage = Current.idMessage;

        // Remove some stuff to make it smaller
        Message.pszUidl = NULL;
        Message.pszServer = NULL;
        Message.faStream = 0;

        // Insert the Record
        IF_FAILEXIT(hr = m_pSearch->UpdateRecord(&Message));
    }

exit:
    // Cleanup
    m_pSearch->FreeRecord(&Current);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_IsMatch
//--------------------------------------------------------------------------
HRESULT CFindFolder::_IsMatch(DWORD iFolder, LPMESSAGEINFO pInfo)
{
    // Trace
    TraceCall("CFindFolder::_ProcessMessageInfo");

    // Has Attachment
    if (ISFLAGSET(m_pCriteria->mask, FIM_ATTACHMENT))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_HASATTACH))
            return(S_FALSE);
    }

    // Is Flagged
    if (ISFLAGSET(m_pCriteria->mask, FIM_FLAGGED))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_FLAGGED))
            return(S_FALSE);
    }

    // Was Forwarded
    if (ISFLAGSET(m_pCriteria->mask, FIM_FORWARDED))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_FORWARDED))
            return(S_FALSE);
    }

    // Was Replied to
    if (ISFLAGSET(m_pCriteria->mask, FIM_REPLIED))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_REPLIED))
            return(S_FALSE);
    }

    // From
    if (ISFLAGSET(m_pCriteria->mask, FIM_FROM))
    {
        // No pszFrom
        if (NULL == m_pCriteria->pszFrom)
            return(S_FALSE);

        // Check pszEmail From
        if (NULL == pInfo->pszDisplayFrom || NULL == StrStrIA(pInfo->pszDisplayFrom, m_pCriteria->pszFrom))
        {
            // Try Email
            if (NULL == pInfo->pszEmailFrom || NULL == StrStrIA(pInfo->pszEmailFrom, m_pCriteria->pszFrom))
                return(S_FALSE);
        }
    }

    // Subject
    if (ISFLAGSET(m_pCriteria->mask, FIM_SUBJECT))
    {
        // Check Subject
        if (NULL == m_pCriteria->pszSubject || NULL == pInfo->pszSubject || NULL == StrStrIA(pInfo->pszSubject, m_pCriteria->pszSubject))
            return(S_FALSE);
    }

    // Recipient
    if (ISFLAGSET(m_pCriteria->mask, FIM_TO))
    {
        // No pszFrom
        if (NULL == m_pCriteria->pszTo)
            return(S_FALSE);

        // Check pszEmail From
        if (NULL == pInfo->pszDisplayTo || NULL == StrStrIA(pInfo->pszDisplayTo, m_pCriteria->pszTo))
        {
            // Try Email
            if (NULL == pInfo->pszEmailTo || NULL == StrStrIA(pInfo->pszEmailTo, m_pCriteria->pszTo))
                return(S_FALSE);
        }
    }

    // DateFrom <= pInfo <= DateTo
    if (ISFLAGSET(m_pCriteria->mask, FIM_DATEFROM))
    {
        // Locals
        FILETIME ftLocal;

        // Convert to local file time
        FileTimeToLocalFileTime(&pInfo->ftReceived, &ftLocal);

        // Compare Received
        if (CompareFileTime(&ftLocal, &m_pCriteria->ftDateFrom) < 0)
            return(S_FALSE);
    }

    // DateFrom <= pInfo <= DateTo
    if (ISFLAGSET(m_pCriteria->mask, FIM_DATETO))
    {
        // Locals
        FILETIME ftLocal;

        // Convert to local file time
        FileTimeToLocalFileTime(&pInfo->ftReceived, &ftLocal);

        // Compare Received
        if (CompareFileTime(&ftLocal, &m_pCriteria->ftDateTo) > 0)
            return(S_FALSE);
    }

    // Body Text
    if (ISFLAGSET(m_pCriteria->mask, FIM_BODYTEXT))
    {
        // Locals
        BOOL fMatch=FALSE;
        IStream *pStream;

        // No Body TExt
        if (NULL == m_pCriteria->pszBody)
            return(S_FALSE);

        // Open the mime message
        if (SUCCEEDED(LighweightOpenMessage(m_prgFolder[iFolder].pDB, pInfo, &m_pMessage)))
        {
            // Try to Get the Plain Text Stream
            if (FAILED(m_pMessage->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
            {
                // Try to get the HTML stream
                if (FAILED(m_pMessage->GetTextBody(TXT_HTML, IET_DECODED, &pStream, NULL)))
                    pStream = NULL;
            }

            // Do we have a strema
            if (pStream)
            {
                // Search the Stream
                fMatch = StreamSubStringMatch(pStream, m_pCriteria->pszBody);

                // Release the Stream
                pStream->Release();
            }
        }

        // No Match
        if (FALSE == fMatch)
            return(S_FALSE);
    }

    // Its a match
    return(S_OK);
}

//--------------------------------------------------------------------------
// CFindFolder::SaveMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::SaveMessage(LPMESSAGEID pidMessage, 
    SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, 
    IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    MESSAGEID       idSaved;
    MESSAGEINFO     Saved={0};
    MESSAGEINFO     Message={0};
    LPFOLDERENTRY   pEntry=NULL;
    BOOL            fRegNotify=FALSE;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::SaveMessage");

    // Invalid Args
    if (NULL == pidMessage || NULL == pMessage || !ISFLAGSET(dwOptions, SAVE_MESSAGE_GENID))
    {
        Assert(FALSE);
        return TraceResult(E_INVALIDARG);
    }

    // Set the messageId
    Message.idMessage = *pidMessage;

    // Find It
    IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        AssertSz(FALSE, "This can't happen because you can't save new messages into a search folder.");
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Get the Folder Entry
    pEntry = &m_prgFolder[Message.iFindFolder];

    // Open the folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(pEntry->idFolder, NULL, NOFLAGS, &pFolder));

    // Lock
    IF_FAILEXIT(hr = pEntry->pDB->Lock(&hLock));

    // Remove my notification
    pEntry->pDB->UnregisterNotify((IDatabaseNotify *)this);

    // Re-Register for notifications
    fRegNotify = TRUE;

    // Set idFindSource
    idSaved = Message.idFindSource;

    // Open the Message
    IF_FAILEXIT(hr = pFolder->SaveMessage(&idSaved, dwOptions, dwFlags, pStream, pMessage, pCallback));

    // Get the new message info
    IF_FAILEXIT(hr = GetMessageInfo(pFolder, idSaved, &Saved));

    // Insert This Dude
    IF_FAILEXIT(hr = _OnInsert(Message.iFindFolder, &Saved, NULL, pidMessage));

exit:
    // Cleanup
    if (pEntry)
    {
        // fRegNotify
        if (fRegNotify)
        {
            // Re-register for notifications
            pEntry->pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, Message.iFindFolder, (IDatabaseNotify *)this);
        }

        // Unlock the Folder
        pEntry->pDB->Unlock(&hLock);
    }

    // Free Message
    m_pSearch->FreeRecord(&Message);

    // Free
    if (pFolder)
        pFolder->FreeRecord(&Saved);

    // Release the Folder
    SafeRelease(pFolder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::OpenMessage(MESSAGEID idMessage, 
    OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Message={0};
    LPFOLDERENTRY   pEntry;

    // Trace
    TraceCall("CFindFolder::OpenMessage");

    // Set the messageId
    Message.idMessage = idMessage;

    // Find It
    IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Get entry
    pEntry = &m_prgFolder[Message.iFindFolder];

    // Do we have a folder open yet ?
    if (NULL == pEntry->pFolder)
    {
        // Get the Real Folder
        IF_FAILEXIT(hr = g_pStore->OpenFolder(pEntry->idFolder, NULL, NOFLAGS, &pEntry->pFolder));
    }

    // Open the Message
    IF_FAILEXIT(hr = pEntry->pFolder->OpenMessage(Message.idFindSource, dwFlags, ppMessage, pCallback));

exit:
    // Cleanup
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::SetMessageFlags
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::SetMessageFlags(LPMESSAGEIDLIST pList, 
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwndParent;
    DWORD           i;
    LPMESSAGEIDLIST prgList=NULL;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::SetMessageFlags");

    // Invalid Args
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(pCallback);

    // Invalid Args
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Get the Parent Window
    IF_FAILEXIT(hr = pCallback->GetParentWindow(0, &hwndParent));

    // Collate into folders
    IF_FAILEXIT(hr = _CollateIdList(pList, &prgList, NULL));

    // Walk through the folders...
    for (i=0; i<m_cFolders; i++)
    {
        // Call Into the Folder unless cMsgs == 0
        if (prgList[i].cMsgs > 0)
        {
            // Get the Real Folder
            IF_FAILEXIT(hr = g_pStore->OpenFolder(m_prgFolder[i].idFolder, NULL, NOFLAGS, &pFolder));

            // Blocking...
            IF_FAILEXIT(hr = SetMessageFlagsProgress(hwndParent, pFolder, pFlags, &prgList[i]));

            // Cleanup
            SafeRelease(pFolder);
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolder);
    _FreeIdListArray(&prgList);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::CopyMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::CopyMessages(IMessageFolder *pDest, 
    COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, 
    LPRESULTLIST pResults, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwndParent;
    DWORD           i;
    LPMESSAGEIDLIST prgList=NULL;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::CopyMessages");

    // Better have a callback
    Assert(pCallback);

    // Invalid Args
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Get the Parent Window
    IF_FAILEXIT(hr = pCallback->GetParentWindow(0, &hwndParent));

    // Collate into folders
    IF_FAILEXIT(hr = _CollateIdList(pList, &prgList, NULL));

    // Walk through the folders...
    for (i=0; i<m_cFolders; i++)
    {
        // Anything to do?
        if (prgList[i].cMsgs > 0)
        {
            // Get the Real Folder
            IF_FAILEXIT(hr = g_pStore->OpenFolder(m_prgFolder[i].idFolder, NULL, NOFLAGS, &pFolder));

            // Call Justins
            IF_FAILEXIT(hr = CopyMessagesProgress(hwndParent, pFolder, pDest, dwFlags, &prgList[i], pFlags));

            // Cleanup
            SafeRelease(pFolder);
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolder);
    _FreeIdListArray(&prgList);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::DeleteMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::DeleteMessages(DELETEMESSAGEFLAGS dwFlags,
    LPMESSAGEIDLIST pList, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    BOOL            fSomeInDeleted;
    HWND            hwndParent;
    LPMESSAGEIDLIST prgList=NULL;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::DeleteMessages");

    // Invalid Args
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(pCallback);

    // Invalid Args
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Collate into folders
    IF_FAILEXIT(hr = _CollateIdList(pList, &prgList, &fSomeInDeleted));

    // Prompt...
    if (fSomeInDeleted && FALSE == ISFLAGSET(dwFlags, DELETE_MESSAGE_NOPROMPT))
    {
        // Get a Parent Hwnd
        Assert(pCallback);

        // Get Parent Window
        if (FAILED(pCallback->GetParentWindow(0, &hwndParent)))
            hwndParent = NULL;

        // Prompt...
        if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsWarnSomePermDelete), NULL, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ))
            goto exit;
    }

    // Get the Parent Window
    IF_FAILEXIT(hr = pCallback->GetParentWindow(0, &hwndParent));

    // Walk through the folders...
    for (i=0; i<m_cFolders; i++)
    {
        // Call Into the Folder unless cMsgs == 0
        if (prgList[i].cMsgs > 0)
        {
            // Get the Real Folder
            IF_FAILEXIT(hr = g_pStore->OpenFolder(m_prgFolder[i].idFolder, NULL, NOFLAGS, &pFolder));

            // Call Into the Folder
            IF_FAILEXIT(hr = DeleteMessagesProgress(hwndParent, pFolder, dwFlags | DELETE_MESSAGE_NOPROMPT, &prgList[i]));

            // Cleanup
            SafeRelease(pFolder);
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolder);
    _FreeIdListArray(&prgList);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_CollateIdList
//--------------------------------------------------------------------------
HRESULT CFindFolder::_CollateIdList(LPMESSAGEIDLIST pList, 
    LPMESSAGEIDLIST *pprgCollated, BOOL *pfSomeInDeleted)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    LPMESSAGEIDLIST pListDst;
    DWORD           i;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CFindFolder::_CollateIdList");

    // Initialize
    if (pfSomeInDeleted)
        *pfSomeInDeleted = FALSE;

    // Allocate pprgCollated
    IF_NULLEXIT(*pprgCollated = (LPMESSAGEIDLIST)ZeroAllocate(sizeof(MESSAGEIDLIST) * m_cFolders));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pSearch->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            Message.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pSearch->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Validate
            Assert(Message.iFindFolder < m_cFolders);

            // Return pfSomeInDeleted
            if (pfSomeInDeleted && m_prgFolder[Message.iFindFolder].fInDeleted)
                *pfSomeInDeleted = TRUE;

            // Locate the Correct 
            pListDst = &((*pprgCollated)[Message.iFindFolder]);

            // Need to Grow this puppy
            if (pListDst->cMsgs + 1 >= pListDst->cAllocated)
            {
                // Realloc the Array
                IF_FAILEXIT(hr = HrRealloc((LPVOID *)&pListDst->prgidMsg, sizeof(MESSAGEID) * (pListDst->cAllocated + 256)));

                // Increment 
                pListDst->cAllocated += 256;
            }

            // Store the Id
            pListDst->prgidMsg[pListDst->cMsgs++] = Message.idFindSource;

            // Free
            m_pSearch->FreeRecord(&Message);
        }
    }

exit:
    // Cleanup
    m_pSearch->FreeRecord(&Message);
    m_pSearch->CloseRowset(&hRowset);

    // Failure
    if (FAILED(hr))
        _FreeIdListArray(pprgCollated);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_FreeIdListArray
//--------------------------------------------------------------------------
HRESULT CFindFolder::_FreeIdListArray(LPMESSAGEIDLIST *pprgList)
{
    // Locals
    DWORD       i;

    // Trace
    TraceCall("CFindFolder::_FreeIdListArray");

    // Nothing to Free
    if (NULL == *pprgList)
        return(S_OK);

    // Loop
    for (i=0; i<m_cFolders; i++)
    {
        // Free prgidMsg
        SafeMemFree((*pprgList)[i].prgidMsg);
    }

    // Free the Array
    SafeMemFree((*pprgList));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CFindFolder::OnTransaction
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, 
    IDatabase *pDB)
{
    // Locals
    HRESULT         hr;
    HLOCK           hNotify=NULL;
    MESSAGEINFO     Message1={0};
    MESSAGEINFO     Message2={0};
    ORDINALLIST     Ordinals;
    INDEXORDINAL    iIndex;
    TRANSACTIONTYPE tyTransaction;

    // Trace
    TraceCall("CFindFolder::OnRecordNotify");

    // Lock Notifications
    m_pSearch->LockNotify(NOFLAGS, &hNotify);

    // While we have a Transaction...
    while (hTransaction)
    {
        // Get Transaction
        IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Message1, &Message2, &iIndex, &Ordinals));

        // Insert
        if (TRANSACTION_INSERT == tyTransaction)
        {
            // Ccall OnInsert
            _OnInsert((DWORD) dwCookie, &Message1, NULL);
        }

        // Delete
        else if (TRANSACTION_DELETE == tyTransaction)
        {
            // Ccall OnDelete
            _OnDelete((DWORD) dwCookie, &Message1);
        }

        // Update
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Ccall OnInsert
            _OnUpdate((DWORD) dwCookie, &Message1, &Message2);
        }
    }

exit:
    // Cleanup
    pDB->FreeRecord(&Message1);
    pDB->FreeRecord(&Message2);

    // Lock Notifications
    m_pSearch->UnlockNotify(&hNotify);

    // Done
    return(S_OK);
}

HRESULT CFindFolder::ConnectionAddRef()
{
    if (m_pSearch)
        m_pSearch->ConnectionAddRef();
    return S_OK;
}

HRESULT CFindFolder::ConnectionRelease()
{
    if (m_pSearch)
        m_pSearch->ConnectionAddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\findfold.h ===
//--------------------------------------------------------------------------
// FindFold.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "dbimpl.h"

//--------------------------------------------------------------------------
// ACTIVEFINDFOLDER
//--------------------------------------------------------------------------
class CFindFolder;
typedef struct tagACTIVEFINDFOLDER *LPACTIVEFINDFOLDER;
typedef struct tagACTIVEFINDFOLDER {
    FOLDERID            idFolder;
    CFindFolder        *pFolder;
    LPACTIVEFINDFOLDER  pNext;
} ACTIVEFINDFOLDER;

//--------------------------------------------------------------------------
// FOLDERENTRY
//--------------------------------------------------------------------------
typedef struct tagFOLDERENTRY {
    LPSTR               pszName;
    DWORD               cRecords;
    BOOL                fInDeleted;
    FOLDERID            idFolder;
    FOLDERTYPE          tyFolder;
    IDatabase          *pDB;
    IMessageFolder     *pFolder; // Used only for Opening messages...
} FOLDERENTRY, *LPFOLDERENTRY;

//--------------------------------------------------------------------------
// CFindFolder
//--------------------------------------------------------------------------
class CFindFolder : public IMessageFolder, 
                    public IDatabaseNotify, 
                    public IStoreCallback,
                    public IServiceProvider,
                    public IOperationCancel
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CFindFolder(void);
    ~CFindFolder(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageFolder Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERID idFolder);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback) { return E_NOTIMPL; }
    STDMETHODIMP Close() { return S_OK; }
    STDMETHODIMP GetFolderId(LPFOLDERID pidFolder) { *pidFolder = m_idFolder; return S_OK; }
    STDMETHODIMP GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder);
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP OpenMessage(MESSAGEID idMessage, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP SaveMessage(LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageStream(MESSAGEID idMessage, IStream *pStream) { return E_NOTIMPL; }
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP ConnectionAddRef();
    STDMETHODIMP ConnectionRelease();
    STDMETHODIMP GetDatabase(IDatabase **ppDB) { return m_pSearch->GetDatabase(ppDB); }
    STDMETHODIMP ResetFolderCounts(DWORD cMessages, DWORD cUnread, DWORD cWatchedUnread, DWORD cWatched) { return(S_OK); }
    STDMETHODIMP IsWatched(LPCSTR pszReferences, LPCSTR pszSubject) { return m_pSearch->IsWatched(pszReferences, pszSubject); }
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback) { return E_NOTIMPL; }

    //----------------------------------------------------------------------
    // IServiceProvider 
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IStoreCallback Members
    //----------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) { return(E_NOTIMPL); }

    //----------------------------------------------------------------------
    // IOperationCancel
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel) { m_fCancel = TRUE; return(S_OK); }

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(FALSE, m_pSearch)

    //----------------------------------------------------------------------
    // IDatabaseNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

    //----------------------------------------------------------------------
    // CFindFolder
    //----------------------------------------------------------------------
    HRESULT StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback);
    HRESULT GetMessageFolderType(MESSAGEID idMessage, FOLDERTYPE *ptyFolder);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _StartFind(void);
    HRESULT _SearchFolder(DWORD iFolder);
    HRESULT _IsMatch(DWORD iFolder, LPMESSAGEINFO pMessage);
    HRESULT _OnInsert(DWORD iFolder, LPMESSAGEINFO pMessage, BOOL *pfMatch, LPMESSAGEID pidNew=NULL);
    HRESULT _OnDelete(DWORD iFolder, LPMESSAGEINFO pInfo);
    HRESULT _OnUpdate(DWORD iFolder, LPMESSAGEINFO pInfo1, LPMESSAGEINFO pInfo2);
    HRESULT _FreeIdListArray(LPMESSAGEIDLIST *pprgList);
    HRESULT _CollateIdList(LPMESSAGEIDLIST pList, LPMESSAGEIDLIST *pprgCollated, BOOL *pfSomeInDeleted);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG              m_cRef;         // Reference Counting
    FOLDERID          m_idRoot;       // Root Folder Id to Search
    FOLDERID          m_idFolder;     // Temporary Search Folder Id
    DWORD             m_cFolders;     // Number of Folders we are looking at...
    DWORD             m_cAllocated;   // Number of allocated elements in m_prgFolder
    DWORD             m_cMax;         // Max Number of Records to Query
    DWORD             m_cCur;         // Current number of records queried
    BYTE              m_fCancel;      // Was IOperationCancel Called ?
    LPFOLDERENTRY     m_prgFolder;    // Array of folders to search
    LPFINDINFO        m_pCriteria;    // Criteria To perform Find With    
    IMessageFolder   *m_pSearch;      // Search Folder
    IMessageStore    *m_pStore;       // My Store Object
    IStoreCallback   *m_pCallback;    // The Callback (Usually to the Finder Dialog)
    IMimeMessage     *m_pMessage;     // Reusable mime message for searching
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\fldrsync.h ===
#ifndef __FLDRSYNC_H
#define __FLDRSYNC_H

#include <conman.h>

class CFolderSync;

enum
{
    COPY_STATE_OPEN = 0,
    COPY_STATE_SAVE,
    COPY_STATE_SAVE2,
    COPY_STATE_DELETE,
    COPY_STATE_DELETE2,
    COPY_STATE_DONE
};

enum
{
    CONN_STATE_CONNECTED = 0,
    CONN_STATE_NOT_CONNECTED,
    CONN_STATE_OFFLINE
};

typedef HRESULT (CFolderSync::*PFNCOPYFUNC)(THIS_ void);

typedef struct tagCOPYINFO
{
    DWORD           state;
    HRESULT         hr;
    CANCELTYPE      tyCancel;
    STOREOPERATIONTYPE type;
    BOOL            fDownloadFail;

    IMessageFolder *pDest;
    IMessageFolder *pDestLocal;
    LPMESSAGEIDLIST pList;
    ADJUSTFLAGS     AdjustFlags;
    IStoreCallback *pCallback;
    STOREERROR     *pErrorInfo;

    BOOL            fAsync;
    BOOL            fBegin;
    BOOL            fMove;
    DWORD           iMsg;
    BOOL            fSrcOffline;
    BOOL            fDestOffline;

    IStream        *pStream;

    BOOL            fSrcRequested;
} COPYINFO;

//--------------------------------------------------------------------------
// CFolderSync
//--------------------------------------------------------------------------
class CFolderSync : 
    public IMessageFolder,
    public IServiceProvider,
    public IStoreCallback,
    public IOperationCancel,
    public IConnectionNotify
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CFolderSync(void);
    ~CFolderSync(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageFolder Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERID idFolder);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback);
    STDMETHODIMP Close();
    STDMETHODIMP GetFolderId(LPFOLDERID pidFolder);
    STDMETHODIMP GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder);
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback);
    STDMETHODIMP OpenMessage(MESSAGEID idMessage, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP SaveMessage(LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageStream(MESSAGEID idMessage, IStream *pStream);
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPRESULTLIST pResults, IStoreCallback *pCallback); 
    STDMETHODIMP DoFolderCounts(BOOL fDoCounts);
    STDMETHODIMP ConnectionAddRef();
    STDMETHODIMP ConnectionRelease();
    STDMETHODIMP GetDatabase(IDatabase **ppDB) { return m_pFldr->GetDatabase(ppDB); }
    STDMETHODIMP ResetFolderCounts(DWORD cMessages, DWORD cUnread, DWORD cWatchedUnread, DWORD cWatched) { return m_pFldr->ResetFolderCounts(cMessages, cUnread, cWatchedUnread, cWatched); }
    STDMETHODIMP IsWatched(LPCSTR pszReferences, LPCSTR pszSubject) { return m_pFldr->IsWatched(pszReferences, pszSubject); }
    STDMETHODIMP GetAdBarUrl(IStoreCallback    *pCallback);   

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(TRUE, m_pFldr);

    //----------------------------------------------------------------------
    // IServiceProvider
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IStoreCallback
    //----------------------------------------------------------------------
    HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    //----------------------------------------------------------------------
    // IOperationCancel
    //----------------------------------------------------------------------
    HRESULT STDMETHODCALLTYPE Cancel(CANCELTYPE tyCancel);

    //----------------------------------------------------------------------
    // IConnectionNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);

    // CFolderSync
    HRESULT Initialize(IMessageStore *pStore, IMessageFolder *pLocalFolder, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERTYPE tyFolder, FOLDERID idFolder, FOLDERID idServer);

    HRESULT CopyOpen(void);
    HRESULT CopySave(void);
    HRESULT CopySave2(void);
    HRESULT CopyDelete(void);
    HRESULT CopyDelete2(void);

    static LRESULT CALLBACK FolderSyncWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _Offline(DWORD *pdwState);
    HRESULT _OfflineServer(FOLDERID idServer, DWORD *pdwState);
    HRESULT _CopyMessageState(void);
    void    _FreeCopyInfo(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;             // Ref Count
    FOLDERTYPE          m_tyFolder;         // Type of folder I'm In
    FOLDERID            m_idFolder;         // Folder Id
    FOLDERID            m_idServer;
    char                m_szAcctId[CCHMAX_ACCOUNT_NAME];
    IMessageFolder     *m_pFldr;            // local message folder
    IMessageStore      *m_pLocalStore;      // Store Object
    IMessageServer     *m_pServer;
    BOOL                m_fConManAdvise;
    HWND                m_hwnd;
    COPYINFO           *m_pCopy;
    BOOL                m_fImap;            // IMAP special-casing lives!
};

#endif // __FLDRSYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\fldrsync.cpp ===
#include "pch.hxx"
#include "store.h"
#include "instance.h"
#include "msgfldr.h"
#include "secutil.h"
#include "storutil.h"
#include "fldrsync.h"
#include <conman.h>
#include "shlwapip.h" 
#include "sync.h"

static char c_szFolderSyncWndClass[] = "Outlook Express FolderSync Window Class";

static const PFNCOPYFUNC c_rgpfnCopyMsgs[] = 
{
    &CFolderSync::CopyOpen,
    &CFolderSync::CopySave,
    &CFolderSync::CopySave2,
    &CFolderSync::CopyDelete,
    &CFolderSync::CopyDelete2,
};

//--------------------------------------------------------------------------
// CFolderSync::CFolderSync
//--------------------------------------------------------------------------
CFolderSync::CFolderSync(void)
{
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_pLocalStore = NULL;
    m_pFldr = NULL;
    m_tyFolder = FOLDER_INVALID;
    m_idFolder = FOLDERID_INVALID;
    m_idServer = FOLDERID_INVALID;
    m_szAcctId[0] = 0;
    m_pServer = NULL;
    m_fConManAdvise = FALSE;
    m_hwnd = NULL;
    m_pCopy = NULL;
    m_fImap = FALSE;
}

//--------------------------------------------------------------------------
// CFolderSync::~CFolderSync
//--------------------------------------------------------------------------
CFolderSync::~CFolderSync(void)
{
    Assert(m_pCopy == NULL);

    if (m_fConManAdvise && g_pConMan != NULL)
        g_pConMan->Unadvise((IConnectionNotify *)this);

    if (m_hwnd != NULL)
    {
        if (GetWindowThreadProcessId(m_hwnd, NULL) == GetCurrentThreadId())
        {
            DestroyWindow(m_hwnd);
        }
        else
        {
            SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
            PostMessage(m_hwnd, WM_CLOSE, 0, 0L);
        }
    }

    if (m_pServer)
    {
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
        m_pServer = NULL;
    }

    SafeRelease(m_pLocalStore);
    SafeRelease(m_pFldr);
    
    // Release the Dll
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CFolderSync::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IMessageFolder == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// CFolderSync::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFolderSync::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CFolderSync::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFolderSync::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CFolderSync::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::Initialize(IMessageStore *pStore, IMessageServer *pServer, 
    OPENFOLDERFLAGS dwFlags, FOLDERID idFolder)
{
    Assert(FALSE);
    return(E_NOTIMPL);
}

//--------------------------------------------------------------------------
// CFolderSync::SetOwner
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SetOwner(IStoreCallback *pDefaultCallback)
{
    HRESULT hrResult;

    TraceCall("CFolderSync::SetOwner");

    if (NULL == m_pServer)
    {
        hrResult = E_FAIL;
        goto exit;
    }

    hrResult = m_pServer->SetIdleCallback(pDefaultCallback);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
}

//--------------------------------------------------------------------------
// CFolderSync::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback)
{
    BOOL        fOffline;
    HRESULT     hr;

    // async
    // if online, then synchronize folder
    // if offline, no op (fail)

    if (m_pServer == NULL)
    {
        // local folders don't sync.
        // NOTE - This isn't failure - there's just nothing to do.
        return (S_FALSE);
    }

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);
	if(g_pConMan->IsAccountDisabled((LPSTR)m_szAcctId))
		hr = S_FALSE;
	else
		hr = m_pServer->SynchronizeFolder(dwFlags, cHeaders, pCallback);
    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::GetFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::GetFolderId(LPFOLDERID pidFolder)
{
    Assert(NULL != pidFolder);

    // local store operation only

    *pidFolder = m_idFolder;

    return(S_OK);
}

//--------------------------------------------------------------------------
// CFolderSync::GetMessageFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder)
{
    return(m_pFldr->GetMessageFolderId(idMessage, pidFolder));
}

//--------------------------------------------------------------------------
// CFolderSync::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::OpenMessage(MESSAGEID idMessage, 
    OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, 
    IStoreCallback *pCallback)
{
    HRESULT         hr;
    BOOL            fOffline;
    FILEADDRESS     faStart;

    Assert(NULL != ppMessage);

    // async
    // if message is already downloaded
    //      open message in local store
    // else
    //      if online, download message
    //      if offline, fail

    hr = m_pFldr->OpenMessage(idMessage, dwFlags, ppMessage, NULL);
    if (SUCCEEDED(hr))
        return(hr);

    if (hr == STORE_E_NOBODY && m_pServer != NULL && !ISFLAGSET(dwFlags, OPEN_MESSAGE_CACHEDONLY))
    {
        Assert(pCallback != NULL);
        if (pCallback == NULL)
            return(E_INVALIDARG);

        hr = m_pServer->GetMessage(idMessage, pCallback);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::SaveMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SaveMessage(LPMESSAGEID pidMessage, 
    SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, 
    IStream *pStreamIn, IMimeMessage *pMessage, IStoreCallback *pCallback)
{
    HRESULT         hr;
    IStream        *pStream;
    DWORD           dwOffline;
    LPFILETIME      pftRecv;
    PROPVARIANT     rVariant;
    
	Assert(NULL != pMessage);

    // save message to local store
    // if online, upload message
    // if offline, log transaction

    if (m_pServer == NULL)
    {
        hr = m_pFldr->SaveMessage(pidMessage, dwOptions, dwFlags, pStreamIn, pMessage, NULL);
        return(hr);
    }

    hr = _Offline(&dwOffline);
    if (SUCCEEDED(hr))
    {
        if (dwOffline == CONN_STATE_NOT_CONNECTED)
        {
            hr = E_NOT_ONLINE;
        }
        else if (dwOffline == CONN_STATE_OFFLINE)
        {
            hr = g_pSync->CreateMessage(m_pFldr, pidMessage, dwOptions, dwFlags, pStreamIn, pMessage);
        }
        else
        {
            Assert(dwOffline == CONN_STATE_CONNECTED);
            
            Assert(pCallback != NULL);
            if (pCallback == NULL)
                return(E_INVALIDARG);
            
            // the idStream can legally by null in the case of saving a draft
            if (NULL == pStreamIn)
                hr = pMessage->GetMessageSource(&pStream, COMMIT_ONLYIFDIRTY);
            else
            {
                pStream = pStreamIn;
                pStream->AddRef();
            }

            if (SUCCEEDED(hr))
            {
                rVariant.vt = VT_FILETIME;
                if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
                    pftRecv = &rVariant.filetime;
                else
                    pftRecv = NULL;
                
                hr = m_pServer->PutMessage(m_idFolder, dwFlags, pftRecv, pStream, pCallback);
                pStream->Release();
            }
        }
    }
    
    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::SetMessageStream
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SetMessageStream(MESSAGEID idMessage, 
    IStream *pStream)
{
    // pass through to the local store
    Assert (NULL != m_pFldr);
    Assert(NULL != pStream);

    if (NULL == pStream)
        return E_INVALIDARG;

    return m_pFldr->SetMessageStream(idMessage, pStream);
}

//--------------------------------------------------------------------------
// CFolderSync::SetMessageFlags
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SetMessageFlags(LPMESSAGEIDLIST pList,
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    INewsStore     *pNewsStore;
    ADJUSTFLAGS     localFlags, svrFlags;
    MESSAGEFLAGS    flags;
    DWORD           dwOffline;
    HRESULT         hr;

    Assert(NULL != pFlags);
    Assert(NULL == pList || 0 != pList->cMsgs);

    // async
    // save message flags to local store
    // if online, upload message flags if necessary (some flags are irrelevant to server)
    // if offline, log transaction if necessary

    if (m_pServer == NULL)
        return(m_pFldr->SetMessageFlags(pList, pFlags, pResults, NULL));

    hr = _Offline(&dwOffline);
    if (SUCCEEDED(hr))
    {
        hr = m_pServer->GetServerMessageFlags(&flags);
        if (SUCCEEDED(hr))
        {
            Assert(hr == S_OK || hr == S_FALSE);

            // hr == S_FALSE
            // this server doesn't have any flags that need to hit the server
            
            localFlags = *pFlags;

            if (hr == S_OK)
            {
                svrFlags = *pFlags;
                svrFlags.dwAdd &= flags;
                svrFlags.dwRemove &= flags;

                localFlags.dwAdd &= ~flags;
                localFlags.dwRemove &= ~flags;

                if (0 != svrFlags.dwAdd ||
                    0 != svrFlags.dwRemove)
                {
                    if (dwOffline == CONN_STATE_NOT_CONNECTED)
                    {
                        return(E_NOT_ONLINE);
                    }
                    else if (dwOffline == CONN_STATE_OFFLINE)
                    {
                        hr = g_pSync->SetMessageFlags(m_pFldr, pList, &svrFlags);
                    }
                    else
                    {
                        Assert(dwOffline == CONN_STATE_CONNECTED);

                        Assert(pCallback != NULL);
                        if (pCallback == NULL)
                            return(E_INVALIDARG);

                        hr = m_pServer->SetMessageFlags(pList, &svrFlags, 0, pCallback);
                    }
                }
            }

            if (0 != localFlags.dwAdd ||
                0 != localFlags.dwRemove)
            {
                hr = m_pFldr->SetMessageFlags(pList, &localFlags, pResults, NULL);

                // mark news crossposts as read
                if (m_tyFolder == FOLDER_NEWS &&
                    (!!(localFlags.dwAdd & ARF_READ) || !!(localFlags.dwRemove & ARF_READ)))
                {
                    IServiceProvider *pService;

                    if (SUCCEEDED(m_pServer->QueryInterface(IID_IServiceProvider, (void **)&pService)))
                    {
                        if (SUCCEEDED(pService->QueryService(SID_MessageServer, IID_INewsStore, (void **)&pNewsStore)))
                        {
                            pNewsStore->MarkCrossposts(pList, !!(localFlags.dwAdd & ARF_READ));

                            pNewsStore->Release();
                        }

                        pService->Release();
                    }
                }
            }
        }
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::DeleteMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::DeleteMessages(DELETEMESSAGEFLAGS dwOptions, 
    LPMESSAGEIDLIST pList, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    ADJUSTFLAGS     afFlags;
    DWORD           dwOffline;
    HRESULT         hr;

    Assert(NULL == pList || pList->cMsgs > 0);

    // if online, delete messages from server and local store
    // if offline, log transaction

    if (m_pServer == NULL || m_tyFolder == FOLDER_NEWS)
        return(m_pFldr->DeleteMessages(dwOptions, pList, pResults, pCallback));

    hr = _Offline(&dwOffline);
    if (SUCCEEDED(hr))
    {
        if (dwOffline == CONN_STATE_NOT_CONNECTED)
        {
            hr = E_NOT_ONLINE;
        }
        else if (dwOffline == CONN_STATE_OFFLINE)
        {
            // [PaulHi] 4/8/99  Raid 63339
            // Deleting from an HTTP folder (other than the 'deleted' folder)
            // translates into a message move from the source folder to the 
            // 'deleted' folder.  If offline we want the message copy to take
            // place and then cache the message 'copy' just as would happen with
            // an offline drag/drop copy operation.
            FOLDERINFO  fldrinfo;
            BOOL        bHMOffLineCopy = FALSE;

            hr = m_pLocalStore->GetFolderInfo(m_idFolder, &fldrinfo);
            if (SUCCEEDED(hr))
            {
                if ( (fldrinfo.tyFolder == FOLDER_HTTPMAIL) && (fldrinfo.tySpecial != FOLDER_DELETED) &&
                     (fldrinfo.tySpecial != FOLDER_MSNPROMO) )
                {
                    // Code stolen from CFolderSync::CopyMessages
                    IMessageFolder * pDeletedItems = NULL;
                    IMessageFolder * pDestLocal = NULL;
                    IServiceProvider * pService = NULL;

                    hr = g_pStore->OpenSpecialFolder(m_idServer, NULL, FOLDER_DELETED, &pDeletedItems);

                    if (SUCCEEDED(hr))
                    {
                        hr = pDeletedItems->QueryInterface(IID_IServiceProvider, (void **)&pService);
                        if (SUCCEEDED(hr))
                        {
                            hr = pService->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (void **)&pDestLocal);
                            pService->Release();
                        }

                        pDeletedItems->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
                        Assert(pDestLocal != NULL);

                        afFlags.dwAdd = 0;
                        afFlags.dwRemove = 0;
                        hr = g_pSync->CopyMessages(m_pFldr, pDestLocal, COPY_MESSAGE_MOVE, pList, &afFlags);
                        bHMOffLineCopy = TRUE;

                        pDestLocal->Release();
                    }

                    m_pLocalStore->FreeRecord(&fldrinfo);
                }
            }

            // If the HM offline copy didn't occur, for whatever reason, revert to the original
            // off line delete.
            if (!bHMOffLineCopy)
                hr = g_pSync->DeleteMessages(m_pFldr, dwOptions, pList);
        }
        else
        {
            Assert(dwOffline == CONN_STATE_CONNECTED);

            Assert(pCallback != NULL);
            if (pCallback == NULL)
                return(E_INVALIDARG);

            hr = m_pServer->DeleteMessages(dwOptions, pList, pCallback);
        }
    }

    return(hr);
}

HRESULT CFolderSync::Initialize(IMessageStore *pStore, IMessageFolder *pLocalFolder, 
    IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERTYPE tyFolder, 
    FOLDERID idFolder, FOLDERID idServer)
{
    WNDCLASSEX      wc;
    HRESULT         hr;
    FOLDERINFO      info;

    Assert(NULL != pStore);

    // Save the Folder Type
    m_tyFolder = tyFolder;

    // Save the FolderId
    m_idFolder = idFolder;

    m_idServer = idServer;

    // Save pStore
    m_pLocalStore = pStore;
    m_pLocalStore->AddRef();

    if (pServer != NULL)
    {
        hr = m_pLocalStore->GetFolderInfo(m_idServer, &info);
        if (FAILED(hr))
            return(hr);

        StrCpyN(m_szAcctId, info.pszAccountId, ARRAYSIZE(m_szAcctId));
        m_fImap = (info.tyFolder == FOLDER_IMAP);

        m_pLocalStore->FreeRecord(&info);

        m_pServer = pServer;
        m_pServer->AddRef();

        hr = g_pConMan->Advise((IConnectionNotify *)this);
        m_fConManAdvise = SUCCEEDED(hr);
    }

    if (pLocalFolder)
    {
        m_pFldr = pLocalFolder;
        m_pFldr->AddRef();
    }
    else
    {
        hr = m_pLocalStore->OpenFolder(m_idFolder, NULL, dwFlags, &m_pFldr);
        if (FAILED(hr))
            return(hr);
    }
    
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szFolderSyncWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = FolderSyncWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szFolderSyncWndClass;
        wc.hIconSm          = NULL;
        if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }

    m_hwnd = CreateWindowEx(WS_EX_TOPMOST, c_szFolderSyncWndClass, 
                c_szFolderSyncWndClass, WS_POPUP, 1, 1, 1, 1, NULL, 
                NULL, g_hInst, (LPVOID)this);
    if (m_hwnd == NULL)
        return(E_FAIL);

    return(S_OK);
}

HRESULT CFolderSync::Close()
{
    HRESULT hr = S_OK;
    if (m_pServer)
        hr = m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);

    return hr;
}

HRESULT CFolderSync::_Offline(DWORD *pdwOffline)
{
    BOOL fOffline;
    HRESULT hr;

    Assert(pdwOffline != NULL);
    Assert(m_szAcctId[0] != 0);

    fOffline = g_pConMan->IsGlobalOffline();
    if (fOffline)
    {
        *pdwOffline = CONN_STATE_OFFLINE;
    }
    else
    {
		//Bug# 39337. We just give the operation to the sync object even if we are not connected.
		//The sync object in turn figures out whether it needs to dial or not

		/*
        hr = g_pConMan->CanConnect(m_szAcctId);
    
        *pdwOffline = (hr == S_OK) ? CONN_STATE_CONNECTED : CONN_STATE_NOT_CONNECTED;
		*/
		*pdwOffline = CONN_STATE_CONNECTED;
    }

    return(S_OK);
}

HRESULT CFolderSync::_OfflineServer(FOLDERID idServer, DWORD *pdwOffline)
{
    HRESULT hr;
    FOLDERINFO info;
    BOOL fOffline;

    Assert(pdwOffline != NULL);

    hr = m_pLocalStore->GetFolderInfo(idServer, &info);
    if (FAILED(hr))
        return(hr);

    if (info.tyFolder == FOLDER_LOCAL)
    {
        *pdwOffline = CONN_STATE_CONNECTED;
    }
    else
    {
        fOffline = g_pConMan->IsGlobalOffline();
        if (fOffline)
        {
            *pdwOffline = CONN_STATE_OFFLINE;
        }
        else
        {
			/*
            hr = g_pConMan->CanConnect(info.pszAccountId);
    
            *pdwOffline = (hr == S_OK) ? CONN_STATE_CONNECTED : CONN_STATE_NOT_CONNECTED;
			*/
			*pdwOffline = CONN_STATE_CONNECTED;
        }
    }

    m_pLocalStore->FreeRecord(&info);

    return(S_OK);
}

HRESULT CFolderSync::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    IServiceProvider    *pSP;
    HRESULT             hr = E_NOINTERFACE;

    if (guidService == SID_LocalMessageFolder)
    {
        if (m_pFldr != NULL)
            hr = m_pFldr->QueryInterface(riid, ppvObject);
    }
    else if (m_pServer && m_pServer->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
    {
        hr = pSP->QueryService(guidService, riid, ppvObject);
        pSP->Release();
    }

    return hr;
}

HRESULT CFolderSync::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(m_pCopy->type == SOT_INVALID);
    Assert(m_pCopy->fAsync);

    m_pCopy->type = tyOperation;

    if (!m_pCopy->fBegin)
    {
        Assert(m_pCopy->pCallback != NULL);
        m_pCopy->pCallback->OnBegin(SOT_COPYMOVE_MESSAGE, pOpInfo, (IOperationCancel *)this);

        m_pCopy->fBegin = TRUE;
    }

    return(S_OK);
}

HRESULT CFolderSync::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    return(S_OK);
}

HRESULT CFolderSync::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->OnTimeout(pServer, pdwTimeout, ixpServerType));
}

HRESULT CFolderSync::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->CanConnect(pszAccountId, dwFlags));
}

HRESULT CFolderSync::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->OnLogonPrompt(pServer, ixpServerType));
}

HRESULT CFolderSync::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_pCopy != NULL);
    if (m_pCopy->type != tyOperation ||
        m_pCopy->hr != S_FALSE)
        return(S_OK);

    Assert(hrComplete != S_FALSE);

    m_pCopy->hr = hrComplete;

    if (NULL != pErrorInfo)
    {
        BOOL    fResult;

        fResult = MemAlloc((void **)&m_pCopy->pErrorInfo, sizeof(STOREERROR));
        if (FALSE == fResult)
        {
            TraceResult(E_OUTOFMEMORY);
        }
        else
        {
            // Make a copy of the STOREERROR so we can display rich errors to user
            m_pCopy->pErrorInfo->hrResult = pErrorInfo->hrResult;
            m_pCopy->pErrorInfo->uiServerError = pErrorInfo->uiServerError;
            m_pCopy->pErrorInfo->hrServerError = pErrorInfo->hrServerError;
            m_pCopy->pErrorInfo->dwSocketError = pErrorInfo->dwSocketError;
            m_pCopy->pErrorInfo->pszProblem = PszDupA(pErrorInfo->pszProblem);
            m_pCopy->pErrorInfo->pszDetails = PszDupA(pErrorInfo->pszDetails);
            m_pCopy->pErrorInfo->pszAccount = PszDupA(pErrorInfo->pszAccount);
            m_pCopy->pErrorInfo->pszServer = PszDupA(pErrorInfo->pszServer);
            m_pCopy->pErrorInfo->pszFolder = PszDupA(pErrorInfo->pszFolder);
            m_pCopy->pErrorInfo->pszUserName = PszDupA(pErrorInfo->pszUserName);
            m_pCopy->pErrorInfo->pszProtocol = PszDupA(pErrorInfo->pszProtocol);
            m_pCopy->pErrorInfo->ixpType = pErrorInfo->ixpType;
            m_pCopy->pErrorInfo->dwPort = pErrorInfo->dwPort;
            m_pCopy->pErrorInfo->fSSL = pErrorInfo->fSSL;
            m_pCopy->pErrorInfo->dwFlags = pErrorInfo->dwFlags;
        }
    }

    PostMessage(m_hwnd, WM_USER, 0, 0);
    
    m_pCopy->type = SOT_INVALID;

    return S_OK;
}

HRESULT CFolderSync::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->OnPrompt(hrError, pszText, pszCaption, uType, piUserResponse));
}

HRESULT CFolderSync::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->GetParentWindow(dwReserved, phwndParent));
}

HRESULT CFolderSync::Cancel(CANCELTYPE tyCancel)
{
    Assert(m_pCopy != NULL);
    Assert(tyCancel != CT_INVALID);

    m_pCopy->tyCancel = tyCancel;

    return(S_OK);
}

HRESULT CFolderSync::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan)
{
    FOLDERINFO info;
    HRESULT hr;

    Assert(m_pServer != NULL);

    if (nCode == CONNNOTIFY_CONNECTED)
    {
        
    }
    else if (nCode == CONNNOTIFY_WORKOFFLINE && pvData)
    {
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);
    }
    else if (nCode == CONNNOTIFY_DISCONNECTED)
    {
        hr = g_pStore->GetFolderInfo(m_idServer, &info);
        if (SUCCEEDED(hr))
        {
            CHAR szAccountId[CCHMAX_ACCOUNT_NAME];

            if (SUCCEEDED(GetFolderAccountId(&info, szAccountId, ARRAYSIZE(szAccountId))))
            {
                if (!g_pConMan->CanConnect(szAccountId))
                    m_pServer->Close(MSGSVRF_DROP_CONNECTION);
            }

            g_pStore->FreeRecord(&info);
        }
    }

    return(S_OK);
}

void CFolderSync::_FreeCopyInfo()
{
    Assert(m_pCopy != NULL);

    if (m_pCopy->pDest != NULL)
        m_pCopy->pDest->Release();
    if (m_pCopy->pDestLocal != NULL)
        m_pCopy->pDestLocal->Release();
    if (m_pCopy->pList != NULL)
        MemFree(m_pCopy->pList);

    if (m_pCopy->pErrorInfo != NULL)
    {
        SafeMemFree(m_pCopy->pErrorInfo->pszProblem);
        SafeMemFree(m_pCopy->pErrorInfo->pszDetails);
        SafeMemFree(m_pCopy->pErrorInfo->pszAccount);
        SafeMemFree(m_pCopy->pErrorInfo->pszServer);
        SafeMemFree(m_pCopy->pErrorInfo->pszFolder);
        SafeMemFree(m_pCopy->pErrorInfo->pszUserName);
        SafeMemFree(m_pCopy->pErrorInfo->pszProtocol);
        MemFree(m_pCopy->pErrorInfo);
    }

    MemFree(m_pCopy);
    m_pCopy = NULL;
}

HRESULT AllBodiesDownloaded(IMessageFolder *pFldr, LPMESSAGEIDLIST pList)
{
    MESSAGEINFO Message;
    DWORD iMsg;
    HRESULT hr;

    Assert(pFldr != NULL);
    Assert(pList != NULL);

    hr = S_OK;

    for (iMsg = 0; iMsg < pList->cMsgs; iMsg++)
    {
        ZeroMemory(&Message, sizeof(MESSAGEINFO));
        Message.idMessage = pList->prgidMsg[iMsg];
        if (DB_S_FOUND == pFldr->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
        {
            if (0 == (Message.dwFlags & ARF_HASBODY))
                hr = S_FALSE;

            pFldr->FreeRecord(&Message);
        }

        if (hr != S_OK)
            break;
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::CopyMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::CopyMessages(IMessageFolder   *pDest, 
                                       COPYMESSAGEFLAGS dwOptions, 
                                       LPMESSAGEIDLIST  pList, 
                                       LPADJUSTFLAGS    pFlags, 
                                       LPRESULTLIST     pResults,
                                       IStoreCallback  *pCallback)
{
    HWND                hwnd;
    DWORD               dwOfflineSrc, dwOfflineDst;
    HRESULT             hr;
    IMessageFolder     *pDestLocal;
    ADJUSTFLAGS         aflags;
    FOLDERID            idDst, idServerDst;
    IServiceProvider   *pService;
    FOLDERINFO          fiSource = {0};

    Assert(pDest != NULL);
    Assert(pList != NULL);

    hr = pDest->GetFolderId(&idDst);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServerId(idDst, &idServerDst);
    if (FAILED(hr))
        return(hr);

    if (m_pServer == NULL)
    {
        dwOfflineSrc = CONN_STATE_CONNECTED;
    }
    else
    {
        hr = _Offline(&dwOfflineSrc);
        if (FAILED(hr))
            return(hr);
    }

    if (m_tyFolder == FOLDER_IMAP)
    {
        if (pFlags != NULL)
        {
            aflags = *pFlags;
        }
        else
        {
            aflags.dwAdd = 0;
            aflags.dwRemove = 0;
        }
        aflags.dwRemove |= ARF_ENDANGERED;
        pFlags = &aflags;
    }

    if (m_idServer == idServerDst)
    {
        if (m_pServer == NULL)
        {
            hr = m_pFldr->CopyMessages(pDest, dwOptions, pList, pFlags, pResults, pCallback);
        }
        else if (dwOfflineSrc == CONN_STATE_NOT_CONNECTED)
        {
            hr = E_NOT_ONLINE;
        }
        else if (dwOfflineSrc == CONN_STATE_CONNECTED)
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
                return(E_INVALIDARG);

            hr = m_pServer->CopyMessages(pDest, dwOptions, pList, pFlags, pCallback);
        }
        else
        {
            Assert(dwOfflineSrc == CONN_STATE_OFFLINE);

            pDestLocal = NULL;

            hr = pDest->QueryInterface(IID_IServiceProvider, (void **)&pService);
            if (SUCCEEDED(hr))
            {
                hr = pService->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (void **)&pDestLocal);

                pService->Release();
            }

            if (FAILED(hr))
                return(hr);

            Assert(pDestLocal != NULL);
            hr = g_pSync->CopyMessages(m_pFldr, pDestLocal, dwOptions, pList, pFlags);

            pDestLocal->Release();
        }

        return(hr);
    }

    hr = _OfflineServer(idServerDst, &dwOfflineDst);
    if (FAILED(hr))
        return(hr);

    if (dwOfflineDst == CONN_STATE_NOT_CONNECTED)
        return(E_NOT_ONLINE);

    Assert(m_pCopy == NULL);
    if (m_pCopy != NULL)
        return(E_FAIL);

    if (dwOfflineSrc != CONN_STATE_CONNECTED)
    {
        hr = AllBodiesDownloaded(m_pFldr, pList);
        if (FAILED(hr))
        {
            return(hr);
        }
        else if (hr == S_FALSE)
        {
            pCallback->GetParentWindow(0, &hwnd);
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                !!(COPY_MESSAGE_MOVE & dwOptions) ? MAKEINTRESOURCEW(idsCantMoveNotDownloaded) : MAKEINTRESOURCEW(idsCantCopyNotDownloaded),
                0, MB_OK | MB_ICONEXCLAMATION);

            return(E_NOT_ONLINE);
        }
    }

    // Bug# 94639
    // If the src and dest servers are not the same, and if the source is Hotmail Deleted Items folder
    // disallow move.
    // For Hotmail accounts Deleted Items folder is managed by the Hotmail servers.
    // So the users cannot manually delete or move messages.
    // Hence, disallow moving from Deleted Items. 
    // Instead ask if the user wants to copy the message
    if ((m_idServer != idServerDst) && (FOLDER_HTTPMAIL == m_tyFolder))
    {
        IF_FAILEXIT(hr = m_pLocalStore->GetFolderInfo(m_idFolder, &fiSource));
        if (FOLDER_DELETED == fiSource.tySpecial)
        {
            if (IDNO == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                                         MAKEINTRESOURCEW(idsHttpNoMoveCopy), 0, MB_YESNO))
            {
                // Just return S_OK;
                hr = S_OK;
                goto exit;
            }
            else
            {
                // Change the move flags to copy.
                dwOptions = (dwOptions & ~COPY_MESSAGE_MOVE);
            }
        }
    }

    if (!MemAlloc((void **)&m_pCopy, sizeof(COPYINFO)))
        return(E_OUTOFMEMORY);

    ZeroMemory(m_pCopy, sizeof(COPYINFO));
    m_pCopy->fSrcOffline = (dwOfflineSrc != CONN_STATE_CONNECTED);
    m_pCopy->fDestOffline = (dwOfflineDst != CONN_STATE_CONNECTED);
    m_pCopy->hr = S_OK;
    m_pCopy->pDest = pDest;
    pDest->AddRef();
    m_pCopy->fMove = !!(COPY_MESSAGE_MOVE & dwOptions);
    hr = CloneMessageIDList(pList, &m_pCopy->pList);
    if (FAILED(hr))
    {
        _FreeCopyInfo();
        return(hr);
    }

    if (m_pCopy->fDestOffline)
    {
        hr = m_pCopy->pDest->QueryInterface(IID_IServiceProvider, (void **)&pService);
        if (SUCCEEDED(hr))
        {
            hr = pService->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (void **)&m_pCopy->pDestLocal);

            pService->Release();
        }

        if (FAILED(hr))
        {
            _FreeCopyInfo();
            return(E_INVALIDARG);
        }
    }
    
    if (pFlags != NULL)
        m_pCopy->AdjustFlags = *pFlags;

    m_pCopy->pCallback = pCallback;

    hr = _CopyMessageState();

exit:
    m_pLocalStore->FreeRecord(&fiSource);
    return(hr);
}

HRESULT CFolderSync::CopyOpen()
{
    HRESULT			hr;
	MESSAGEINFO		mi = {0};
	LPMESSAGEINFO	pmi = NULL;

    if (m_pCopy->iMsg >= m_pCopy->pList->cMsgs)
    {
        m_pCopy->state = COPY_STATE_DONE;
        return(S_OK);
    }

    Assert(m_pCopy->pStream == NULL);

    // initialize message info with the message id
    mi.idMessage = m_pCopy->pList->prgidMsg[m_pCopy->iMsg];
    
    // find the row
    hr = GetMessageInfo(m_pFldr, m_pCopy->pList->prgidMsg[m_pCopy->iMsg], &mi);
    if (FAILED(hr))
        goto exit;
    
    pmi = &mi;
    
    if (0 == mi.faStream || !!(mi.dwFlags & ARF_ARTICLE_EXPIRED))
    {
        // if the server is NULL and we don't have a body stream,
        // then something is wrong with the message. we skip the
        // bad message and move onto the next one.
        if (NULL == m_pServer || m_pCopy->fSrcOffline)
        {
            m_pCopy->state = COPY_STATE_DELETE2;
            hr = S_OK;
        }
        else if (!m_pCopy->fSrcRequested)
        {
            Assert(m_pServer != NULL);
            
            hr = m_pServer->GetMessage(m_pCopy->pList->prgidMsg[m_pCopy->iMsg], (IStoreCallback *)this);
            if (hr == E_PENDING)
                m_pCopy->fSrcRequested = TRUE;
            Assert(FAILED(hr));
        }
    }
    else
    {
        hr = m_pFldr->OpenStream(ACCESS_READ, mi.faStream, &m_pCopy->pStream);
        if (FAILED(hr))
            goto exit;
        m_pCopy->state = COPY_STATE_SAVE;
    }
    
exit:
    if (NULL != pmi)
        m_pFldr->FreeRecord(pmi);
    return(hr);
}

HRESULT CFolderSync::CopySave()
{
    DWORD dwFlags;
    HRESULT hr;
    MESSAGEINFO Message;
    MESSAGEID id;
    IMimeMessage *pMessage = NULL;
    
    Assert(m_pCopy->pStream != NULL);
    
    dwFlags = 0;
    
    ZeroMemory(&Message, sizeof(MESSAGEINFO));
    Message.idMessage = m_pCopy->pList->prgidMsg[m_pCopy->iMsg];
    if (DB_S_FOUND == m_pFldr->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
    {
        dwFlags = Message.dwFlags;
        m_pFldr->FreeRecord(&Message);
    }
    
    if (m_pCopy->AdjustFlags.dwRemove != 0)
        dwFlags &= ~m_pCopy->AdjustFlags.dwRemove;
    if (m_pCopy->AdjustFlags.dwAdd != 0)
        dwFlags |= m_pCopy->AdjustFlags.dwAdd;
    
    // create a mime message	
    hr = m_pFldr->OpenMessage(m_pCopy->pList->prgidMsg[m_pCopy->iMsg], OPEN_MESSAGE_SECURE, &pMessage, NOSTORECALLBACK);
    if (FAILED(hr))
        goto exit;
    
    if (m_pCopy->fDestOffline)
    {
        Assert(m_pCopy->pDestLocal != NULL);
        hr = g_pSync->CreateMessage(m_pCopy->pDestLocal, &id, SAVE_MESSAGE_GENID, dwFlags, m_pCopy->pStream, pMessage);
    }
    else
    {
        hr = m_pCopy->pDest->SaveMessage(&id, SAVE_MESSAGE_GENID, dwFlags, m_pCopy->pStream, pMessage, (IStoreCallback *)this);
    }
    
    if (hr == E_PENDING || SUCCEEDED(hr))
        m_pCopy->state = COPY_STATE_SAVE2;
    
exit:
    if (NULL != pMessage)
        pMessage->Release();
    
    m_pCopy->pStream->Release();
    m_pCopy->pStream = NULL;
    
    return(hr);
}

HRESULT CFolderSync::CopySave2()
{
    if (m_pCopy->fMove)
    {
        m_pCopy->state = COPY_STATE_DELETE;
    }
    else
    {
        m_pCopy->state = COPY_STATE_OPEN;
        m_pCopy->iMsg++;
        m_pCopy->fSrcRequested = FALSE;

        m_pCopy->pCallback->OnProgress(SOT_COPYMOVE_MESSAGE, m_pCopy->iMsg, m_pCopy->pList->cMsgs, NULL);
    }

    return(S_OK);
}

HRESULT CFolderSync::CopyDelete()
{
    MESSAGEIDLIST list;
    HRESULT hr;
    MESSAGEID id;
    ADJUSTFLAGS afFlags;

    list.cMsgs = 1;
    id = m_pCopy->pList->prgidMsg[m_pCopy->iMsg];
    list.prgidMsg = &id;

    if (m_pServer != NULL)
    {
        if (m_pCopy->fSrcOffline)
        {
            if (m_fImap)
            {
                afFlags.dwAdd = ARF_ENDANGERED;
                afFlags.dwRemove = 0;
                hr = g_pSync->SetMessageFlags(m_pFldr, &list, &afFlags);
            }
            else
            {
#ifdef DEAD
                hr = g_pSync->DeleteMessages(m_pFldr, DELETE_MESSAGE_NOTRASHCAN, &list);
#endif // DEAD
                hr = S_OK;
            }
        }
        else
        {
            hr = m_pServer->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT | DELETE_MESSAGE_MAYIGNORENOTRASH, &list, (IStoreCallback *)this);
        }
    }
    else
    {
        hr = m_pFldr->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NOSTORECALLBACK);
    }

    if (hr == E_PENDING || SUCCEEDED(hr))
        m_pCopy->state = COPY_STATE_DELETE2;

    return(hr);
}

HRESULT CFolderSync::CopyDelete2()
{
    m_pCopy->state = COPY_STATE_OPEN;
    m_pCopy->iMsg++;
    m_pCopy->fSrcRequested = FALSE;

    m_pCopy->pCallback->OnProgress(SOT_COPYMOVE_MESSAGE, m_pCopy->iMsg, m_pCopy->pList->cMsgs, NULL);

    return(S_OK);
}

HRESULT CFolderSync::_CopyMessageState()
{
    BOOL fBegin;
    HRESULT hr;
    HWND hwnd;
    IStoreCallback *pCallback;

    Assert(m_pCopy != NULL);
    Assert(m_pCopy->hr != S_FALSE);
    Assert(m_pCopy->hr != E_PENDING);

    if (FAILED(m_pCopy->hr) && m_pCopy->state == COPY_STATE_OPEN && m_pCopy->fSrcRequested)
    {
        m_pCopy->fDownloadFail = TRUE;
        m_pCopy->hr = S_OK;
        m_pCopy->iMsg++;
        m_pCopy->fSrcRequested = FALSE;
    }

    if (FAILED(m_pCopy->hr))
    {
        hr = m_pCopy->hr;
    }
    else
    {
        while (TRUE)
        {
            if (m_pCopy->tyCancel != CT_INVALID)
            {
                m_pCopy->state = COPY_STATE_DONE;
                hr = S_FALSE;
                break;
            }

            hr = (this->*(c_rgpfnCopyMsgs[m_pCopy->state]))();

            if (FAILED(hr) || m_pCopy->state == COPY_STATE_DONE)
                break;
        }
    }

    if (hr == E_PENDING)
    {
        Assert(m_pCopy->type == SOT_INVALID);
        m_pCopy->fAsync = TRUE;
        m_pCopy->hr = S_FALSE;
    }
    else if (FAILED(hr) || m_pCopy->state == COPY_STATE_DONE)
    {
        fBegin = m_pCopy->fBegin;
#ifdef DEBUG
        if (fBegin)
            Assert(m_pCopy->fAsync);
#endif // DEBUG
        pCallback = m_pCopy->pCallback;

        if (fBegin)
        {
            if (m_pCopy->fDownloadFail && SUCCEEDED(hr))
            {
                if (SUCCEEDED(pCallback->GetParentWindow(0, &hwnd)))
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                        m_pCopy->fMove ? MAKEINTRESOURCEW(idsMoveDownloadFail) : MAKEINTRESOURCEW(idsCopyDownloadFail),
                        NULL, MB_ICONEXCLAMATION | MB_OK);
                }
            }

            pCallback->OnComplete(SOT_COPYMOVE_MESSAGE, hr, NULL, m_pCopy->pErrorInfo);
        }

        _FreeCopyInfo();
    }

    return(hr);
}

LRESULT CALLBACK CFolderSync::FolderSyncWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    CFolderSync *pThis;

    pThis = (CFolderSync *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (NULL == pThis && msg != WM_CREATE)
        return DefWindowProc(hwnd, msg, wParam, lParam);

    switch(msg)
    {
        case WM_CREATE:
            Assert(pThis == NULL);
            pThis = (CFolderSync *)((CREATESTRUCT *)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
            break;

        case WM_USER:
            pThis->_CopyMessageState();
            break;
    }

    return(DefWindowProc(hwnd, msg, wParam, lParam));
}

//--------------------------------------------------------------------------
// CFolderSync::ConnectionAddRef
//
// Purpose: users of IMessageFolder need to keep alive the underlying server 
//          object if they plan of re-using the same server connection as
//          another user of the same IMessageTable. eg. a note and a view window
//          This allows us to not have to re-auth for operations that could
//          be potentially expensive
//--------------------------------------------------------------------------
HRESULT CFolderSync::ConnectionAddRef()
{
    if (m_pServer)
        m_pServer->ConnectionAddRef();
    return S_OK;
}

//--------------------------------------------------------------------------
// CFolderSync::ConnectionRelease
//
// Purpose: figure it out
//--------------------------------------------------------------------------
HRESULT CFolderSync::ConnectionRelease()
{
    if (m_pServer)
        m_pServer->ConnectionRelease();
    return S_OK;
}

HRESULT CFolderSync::GetAdBarUrl(IStoreCallback *pCallback)
{
    HRESULT     hr = E_FAIL;

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);

    if (m_pServer)
        hr = m_pServer->GetAdBarUrl(pCallback);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\istore.cpp ===
//--------------------------------------------------------------------------
// ISTORE.CPP
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "istore.h"
#include "instance.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "flagconv.h"
#include "storutil.h"
#include "notify.h"

//--------------------------------------------------------------------------
// Flag Conversion functions
//--------------------------------------------------------------------------
DWORD DwConvertSCFStoMSG(DWORD dwSCFS);
DWORD DwConvertMSGtoARF(DWORD dwMSG);
DWORD DwConvertARFtoMSG(DWORD dwARF);
DWORD DwConvertMSGtoIMAP(DWORD dwMSG);

//--------------------------------------------------------------------------
// DwConvertMSGtoARF
//--------------------------------------------------------------------------
DWORD DwConvertMSGtoARF(DWORD dwMSG)
{
    register DWORD dwRet = 0;

    if (dwMSG & MSG_UNSENT)
        dwRet |= ARF_UNSENT;
    if (0 == (dwMSG & MSG_UNREAD))
        dwRet |= ARF_READ;
    if (dwMSG & MSG_NOSECUI)
        dwRet |= ARF_NOSECUI;
    if (dwMSG & MSG_SUBMITTED)
        dwRet |= ARF_SUBMITTED;
    if (dwMSG & MSG_RECEIVED)
        dwRet |= ARF_RECEIVED;
    if (dwMSG & MSG_NEWSMSG)
        dwRet |= ARF_NEWSMSG;
    if (dwMSG & MSG_REPLIED)
        dwRet |= ARF_REPLIED;
    if (dwMSG & MSG_FORWARDED)
        dwRet |= ARF_FORWARDED;
    if (dwMSG & MSG_RCPTSENT)
        dwRet |= ARF_RCPTSENT;
    if (dwMSG & MSG_FLAGGED)
        dwRet |= ARF_FLAGGED;
    if (dwMSG & MSG_VOICEMAIL)
        dwRet |= ARF_VOICEMAIL;

    return dwRet;
}

//--------------------------------------------------------------------------
// DwConvertARFtoMSG
//--------------------------------------------------------------------------
DWORD DwConvertARFtoMSG(DWORD dwARF)
{
    register DWORD dwRet = 0;

    if (dwARF & ARF_UNSENT)
        dwRet |= MSG_UNSENT;
    if (0 == (dwARF & ARF_READ))
        dwRet |= MSG_UNREAD;
    if (dwARF & ARF_NOSECUI)
        dwRet |= MSG_NOSECUI;
    if (dwARF & ARF_SUBMITTED)
        dwRet |= MSG_SUBMITTED;
    if (dwARF & ARF_RECEIVED)
        dwRet |= MSG_RECEIVED;
    if (dwARF & ARF_NEWSMSG)
        dwRet |= MSG_NEWSMSG;
    if (dwARF & ARF_REPLIED)
        dwRet |= MSG_REPLIED;
    if (dwARF & ARF_FORWARDED)
        dwRet |= MSG_FORWARDED;
    if (dwARF & ARF_RCPTSENT)
        dwRet |= MSG_RCPTSENT;
    if (dwARF & ARF_FLAGGED)
        dwRet |= MSG_FLAGGED;
    if (dwARF & ARF_VOICEMAIL)
        dwRet |= MSG_VOICEMAIL;
    
    return dwRet;
}

//--------------------------------------------------------------------------
// CreateInstance_StoreNamespace
//--------------------------------------------------------------------------
HRESULT CreateInstance_StoreNamespace(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CStoreNamespace   *pNew=NULL;

    // Trace
    TraceCall("CreateInstance_StoreNamespace");

    // Invalid Arg
    Assert(NULL != ppUnknown && NULL == pUnkOuter);

    // Create
    IF_NULLEXIT(pNew = new CStoreNamespace);

    // Return the Innter
    *ppUnknown = SAFECAST(pNew, IStoreNamespace *);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// FldInfoToFolderProps
//--------------------------------------------------------------------------
HRESULT FldInfoToFolderProps(LPFOLDERINFO pInfo, LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               cbSize;
    IEnumerateFolders  *pEnum=NULL;

    // Stack...
    TraceCall("FldInfoToFolderProps");

    // Invalid ARg
    Assert(pInfo && pProps);

    // Bad version
    if (sizeof(FOLDERPROPS) != pProps->cbSize)
    {
        AssertSz(FALSE, "Invalid - un-supported version.");
        return TraceResult(MSOEAPI_E_INVALID_STRUCT_SIZE);
    }

    // Save Size
    cbSize = pProps->cbSize;

    // ZeroInit
    ZeroMemory(pProps, sizeof(FOLDERPROPS));

    // Copy the properties
    pProps->cbSize = cbSize;
    pProps->dwFolderId = pInfo->idFolder;
    pProps->cUnread = pInfo->cUnread;
    pProps->cMessage = pInfo->cMessages;
    StrCpyN(pProps->szName, pInfo->pszName, ARRAYSIZE(pProps->szName));

    // Map the special folder type
    if (FOLDER_NOTSPECIAL == pInfo->tySpecial)
        pProps->sfType = -1;
    else
        pProps->sfType = (pInfo->tySpecial - 1);

    // Enumerate Subscribed Children
    IF_FAILEXIT(hr = g_pStore->EnumChildren(pInfo->idFolder, TRUE, &pEnum));

    // Count
    if (FAILED(pEnum->Count((LPDWORD)&pProps->cSubFolders)))
        pProps->cSubFolders = 0;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// MsgInfoToMessageProps
//--------------------------------------------------------------------------
HRESULT MsgInfoToMessageProps(BOOL fFast, LPMESSAGEINFO pMsgInfo, LPMESSAGEPROPS pProps)
{
    // Locals
    ULONG           cbSize;
    LPBYTE          pbOffsets;

    // Stack
    TraceCall("MsgInfoToMessageProps");

    // Invalid Arg
    Assert(pMsgInfo && pProps);

    // Bad version
    if (sizeof(MESSAGEPROPS) != pProps->cbSize)
    {
        AssertSz(FALSE, "Invalid - un-supported version.");
        return TraceResult(MSOEAPI_E_INVALID_STRUCT_SIZE);
    }

    // Save Size
    cbSize = pProps->cbSize;

    // ZeroInit
    ZeroMemory(pProps, sizeof(MESSAGEPROPS));

    // If Not Fast
    if (FALSE == fFast)
    {
        // Message Size
        pProps->cbMessage = pMsgInfo->cbMessage;

        // Priority
        pProps->priority = (IMSGPRIORITY)pMsgInfo->wPriority;

        // Subject
        pProps->pszSubject = pMsgInfo->pszSubject;

        // Display To
        pProps->pszDisplayTo = pMsgInfo->pszDisplayTo;

        // Dislay From
        pProps->pszDisplayFrom = pMsgInfo->pszDisplayFrom;

        // Normalized Subject
        pProps->pszNormalSubject = pMsgInfo->pszNormalSubj;

        // Received Time
        pProps->ftReceived = pMsgInfo->ftReceived;

        // Sent Time
        pProps->ftSent = pMsgInfo->ftSent;

        // Set dwFlags
        if (ISFLAGSET(pMsgInfo->dwFlags, ARF_VOICEMAIL))
            FLAGSET(pProps->dwFlags, IMF_VOICEMAIL);
        if (ISFLAGSET(pMsgInfo->dwFlags, ARF_NEWSMSG))
            FLAGSET(pProps->dwFlags, IMF_NEWS);

        // Dup the memory
        pbOffsets = (LPBYTE)g_pMalloc->Alloc(pMsgInfo->Offsets.cbSize);

        // If that worked
        if (pbOffsets)
        {
            // Copy the offsets
            CopyMemory(pbOffsets, pMsgInfo->Offsets.pBlobData, pMsgInfo->Offsets.cbSize);

            // Create the Offset Table
            pProps->pStmOffsetTable = new CByteStream(pbOffsets, pMsgInfo->Offsets.cbSize);
        }

        // Better have an offset table
        AssertSz(pProps->pStmOffsetTable, "There is no offset table for this message.");
    }

    // Reset the Size
    pProps->cbSize = cbSize;

    // Store the MessageId
    pProps->dwMessageId = pMsgInfo->idMessage;

    // Store the Language
    pProps->dwLanguage = pMsgInfo->wLanguage;

    // Convert ARF_ to MSG_
    pProps->dwState = DwConvertARFtoMSG(pMsgInfo->dwFlags);

    // Store the Memory
    pProps->dwReserved = (DWORD_PTR)pMsgInfo->pAllocated;

    // pProps owns *ppHeader
    ZeroMemory(pMsgInfo, sizeof(MESSAGEINFO));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CStoreNamespace
//--------------------------------------------------------------------------
CStoreNamespace::CStoreNamespace(void)
{
    TraceCall("CStoreNamespace::CStoreNamespace");
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_cNotify = 0;
    m_prghwndNotify = NULL;
    m_fRegistered = FALSE;
    m_hInitRef = NULL;
    InitializeCriticalSection(&m_cs);
}

//--------------------------------------------------------------------------
// CStoreNamespace::~CStoreNamespace
//--------------------------------------------------------------------------
CStoreNamespace::~CStoreNamespace(void)
{
    TraceCall("CStoreNamespace::~CStoreNamespace");
    SafeMemFree(m_prghwndNotify);
    if (m_fRegistered)
        g_pStore->UnregisterNotify((IDatabaseNotify *)this);
    DeleteCriticalSection(&m_cs);
    g_pInstance->DllRelease();
    CoDecrementInit("CStoreNamespace::Initialize", &m_hInitRef);
}

//--------------------------------------------------------------------------
// CStoreNamespace::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreNamespace::AddRef(void)
{
    TraceCall("CStoreNamespace::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CStoreNamespace::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreNamespace::Release(void)
{
    TraceCall("CStoreNamespace::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CStoreNamespace::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CStoreNamespace::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IStoreNamespace *)this;
    else if (IID_IStoreNamespace == riid)
        *ppv = (IStoreNamespace *)this;
    else if (IID_IStoreCallback == riid)
        *ppv = (IStoreCallback *)this;
    else if (IID_IDatabaseNotify == riid)
        *ppv = (IDatabaseNotify *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::Initialize
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::Initialize(HWND hwndOwner, DWORD dwFlags)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwStart=MSOEAPI_START_COMOBJECT;

    // Stack
    TraceCall("CStoreNamespace::Initialize");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Already Initialized
    if (NULL != m_hInitRef)
    {
        TraceInfo("IStoreNamespace::Initialize has been called more than once.");
        goto exit;
    }

    // Not Current Identity
    if (!ISFLAGSET(dwFlags, NAMESPACE_INITIALIZE_CURRENTIDENTITY))
    {
        // Use Default Identity, must be MS Phone
        FLAGSET(dwStart, MSOEAPI_START_DEFAULTIDENTITY);
    }

    // Initialize the store directory
    IF_FAILEXIT(hr = CoIncrementInit("CStoreNamespace::Initialize", dwStart | MSOEAPI_START_STOREVALIDNODELETE, NULL, &m_hInitRef));

    // Better Have g_pStore
    Assert(g_pStore);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetDirectory
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetDirectory(LPSTR pszPath, DWORD cchMaxPath)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::GetDirectory");

    // Invalid Arg
    if (NULL == pszPath)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Get the directory
    IF_FAILEXIT(hr = GetStoreRootDirectory(pszPath, cchMaxPath));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::OpenSpecialFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::OpenSpecialFolder(LONG sfType, DWORD dwReserved, 
    IStoreFolder **ppFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    IMessageFolder     *pFolder=NULL;
    CStoreFolder       *pComFolder=NULL;

    // Stack
    TraceCall("CStoreNamespace::OpenSpecialFolder");

    // Invalid Arg
    if (sfType <= -1 || sfType >= (FOLDER_MAX - 1) || 0 != dwReserved || NULL == ppFolder)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppFolder = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Ask the store to do the work
    IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, (BYTE)(sfType + 1), &pFolder));

    // Create an IStoreFolder
    IF_NULLEXIT(pComFolder = new CStoreFolder(pFolder, this));

    // Return it
    *ppFolder = (IStoreFolder *)pComFolder;
    (*ppFolder)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pFolder);
    SafeRelease(pComFolder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::OpenFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::OpenFolder(FOLDERID dwFolderId, DWORD dwReserved, 
    IStoreFolder **ppFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    IMessageFolder     *pFolder=NULL;
    CStoreFolder       *pComFolder=NULL;

    // Stack
    TraceCall("CStoreNamespace::OpenFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || 0 != dwReserved || NULL == ppFolder)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppFolder = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Open the folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(dwFolderId, NULL, NOFLAGS, &pFolder));

    // Create an IStoreFolder
    IF_NULLEXIT(pComFolder = new CStoreFolder(pFolder, this));

    // Return it
    *ppFolder = (IStoreFolder *)pComFolder;
    (*ppFolder)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pFolder);
    SafeRelease(pComFolder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CreateFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::CreateFolder(FOLDERID dwParentId, LPCSTR pszName, 
    DWORD dwReserved, LPFOLDERID pdwFolderId)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder;

    // Stack
    TraceCall("CStoreNamespace::CreateFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwParentId || NULL == pszName || 0 != dwReserved || NULL == pdwFolderId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Adjust the Parent
    if (dwParentId == FOLDERID_ROOT)
        dwParentId = FOLDERID_LOCAL_STORE;

    // Init
    *pdwFolderId = FOLDERID_INVALID;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Setup a Folder Info
    ZeroMemory(&Folder, sizeof(FOLDERINFO));
    Folder.idParent = dwParentId;
    Folder.pszName = (LPSTR)pszName;
    Folder.dwFlags = FOLDER_SUBSCRIBED;

    // Create a folder
    IF_FAILEXIT(hr = g_pStore->CreateFolder(NOFLAGS, &Folder, (IStoreCallback *)this));
    
    // Return the Id
    *pdwFolderId = Folder.idFolder;

    // Sucess
    hr = S_OK;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::RenameFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::RenameFolder(FOLDERID dwFolderId, DWORD dwReserved, LPCSTR pszNewName)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::RenameFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || 0 != dwReserved || NULL == pszNewName)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Create a folder
    IF_FAILEXIT(hr = g_pStore->RenameFolder(dwFolderId, pszNewName, NOFLAGS, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::MoveFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::MoveFolder(FOLDERID dwFolderId, FOLDERID dwParentId, DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::MoveFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || FOLDERID_INVALID == dwParentId || 0 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Adjust the Parent
    if (dwParentId == FOLDERID_ROOT)
        dwParentId = FOLDERID_LOCAL_STORE;

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Move the folder
    IF_FAILEXIT(hr = g_pStore->MoveFolder(dwFolderId, dwParentId, NOFLAGS, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::DeleteFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::DeleteFolder(FOLDERID dwFolderId, DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::DeleteFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Delete the folder
    IF_FAILEXIT(hr = g_pStore->DeleteFolder(dwFolderId, DELETE_FOLDER_RECURSIVE, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetFolderProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetFolderProps(FOLDERID dwFolderId, DWORD dwReserved, 
    LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Stack
    TraceCall("CStoreNamespace::GetFolderProps");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || 0 != dwReserved || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Adjust the Parent
    if (dwFolderId == FOLDERID_ROOT)
        dwFolderId = FOLDERID_LOCAL_STORE;

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Save the structure size
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(dwFolderId, &Folder));

    // FolderInfoToProps
    IF_FAILEXIT(hr = FldInfoToFolderProps(&Folder, pProps));
    
exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CopyMoveMessages
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::CopyMoveMessages(IStoreFolder *pSource, IStoreFolder *pDest, 
    LPMESSAGEIDLIST pMsgIdList, DWORD dwFlags, DWORD dwFlagsRemove,IProgressNotify *pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    ADJUSTFLAGS         AdjustFlags;
    DWORD               dwArfRemoveFlags;
    CStoreFolder       *pComSource=NULL;
    CStoreFolder       *pComDest=NULL;
    IMessageFolder     *pActSource=NULL;
    IMessageFolder     *pActDest=NULL;

    // Stack
    TraceCall("CStoreNamespace::CopyMoveMessages");

    // Invalid Arg
    if (NULL == pSource || NULL == pDest || NULL == pMsgIdList)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Get Actual Soruce Local Store Folder
    IF_FAILEXIT(hr = pSource->QueryInterface(IID_CStoreFolder, (LPVOID *)&pComSource));
    IF_FAILEXIT(hr = pComSource->GetMessageFolder(&pActSource));

    // Get Actual Destination Local Store Folder
    IF_FAILEXIT(hr = pDest->QueryInterface(IID_CStoreFolder, (LPVOID *)&pComDest));
    IF_FAILEXIT(hr = pComDest->GetMessageFolder(&pActDest));

    // Convert dwFlagsRemove to ARF Flags...
    dwArfRemoveFlags = DwConvertMSGtoARF(dwFlagsRemove);

    // Adjust Flags
    AdjustFlags.dwAdd = 0;
    AdjustFlags.dwRemove = dwArfRemoveFlags;

    // Do the Copy or Move
    IF_FAILEXIT(hr = pActSource->CopyMessages(pActDest, dwFlags, pMsgIdList, &AdjustFlags, NULL, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pComSource);
    SafeRelease(pComDest);
    SafeRelease(pActSource);
    SafeRelease(pActDest);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::RegisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::RegisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       i;
    BOOL        fFoundEmpty=FALSE;

    // Stack
    TraceCall("CStoreNamespace::RegisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Try to Find an Empty Spot in m_prghwndNotify
    for (i=0; i<m_cNotify; i++)
    {
        // Empty
        if (NULL == m_prghwndNotify[i])
        {
            // Use It
            m_prghwndNotify[i] = hwnd;

            // Found Empty
            fFoundEmpty = TRUE;

            // Done
            break;
        }
    }

    // Didn't Find an Empty slot ?
    if (FALSE == fFoundEmpty)
    {
        // Add hwnd into the Array
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prghwndNotify, (m_cNotify + 1) * sizeof(HWND)));

        // Store the hwnd
        m_prghwndNotify[m_cNotify] = hwnd;

        // Increment Count
        m_cNotify++;
    }

    // Am I registered yet?
    if (FALSE == m_fRegistered)
    {
        // Register
        IF_FAILEXIT(hr = g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this));

        // We are Registered
        m_fRegistered = TRUE;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::UnregisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::UnregisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       i;

    // Stack
    TraceCall("CStoreNamespace::UnregisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Try to Find an Empty Spot in m_prghwndNotify
    for (i=0; i<m_cNotify; i++)
    {
        // Empty
        if (hwnd == m_prghwndNotify[i])
        {
            // Use It
            m_prghwndNotify[i] = NULL;

            // Done
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::OnNotify
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::OnTransaction(HTRANSACTION hTransaction, 
    DWORD_PTR dwCookie, IDatabase *pDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iNotify;
    FOLDERINFO          Folder1={0};
    FOLDERINFO          Folder2={0};
    ORDINALLIST         Ordinals;
    TRANSACTIONTYPE     tyTransaction;
    FOLDERNOTIFYEX      SendBase;
    INDEXORDINAL        iIndex;
    LPFOLDERNOTIFYEX    pSend=NULL;

    // Trace
    TraceCall("CStoreNamespace::OnNotify");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through info structures
    while (hTransaction)
    {
        // Get Transact
        IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals));

        // Only send notifications about local folders
        if (Folder1.tyFolder == FOLDER_LOCAL)
        {
            // Zero
            ZeroMemory(&SendBase, sizeof(FOLDERNOTIFYEX));

            // TRANSACTION_INSERT
            if (TRANSACTION_INSERT == tyTransaction)
            {
                SendBase.type = NEW_FOLDER;
                SendBase.idFolderNew = Folder1.idFolder;
            }

            // TRANSACTION_UPDATE
            else if (TRANSACTION_UPDATE == tyTransaction)
            {
                // Set Old and New
                SendBase.idFolderOld = Folder1.idFolder;
                SendBase.idFolderNew = Folder2.idFolder;

                // Was this a rename
                if (lstrcmp(Folder1.pszName, Folder2.pszName) != 0)
                    SendBase.type = RENAME_FOLDER;

                // Move
                else if (Folder1.idParent != Folder2.idParent)
                    SendBase.type = MOVE_FOLDER;

                // Unread Change
                else if (Folder1.cUnread != Folder2.cUnread)
                    SendBase.type = UNREAD_CHANGE;

                // Flag Change
                else if (Folder1.dwFlags != Folder2.dwFlags)
                    SendBase.type = UPDATEFLAG_CHANGE;

                // Otherwise, generic catch all
                else
                    SendBase.type = FOLDER_PROPS_CHANGED;
            }

            // TRANSACTION_DELETE
            else if (TRANSACTION_DELETE == tyTransaction)
            {
                SendBase.type = DELETE_FOLDER;
                SendBase.idFolderNew = Folder1.idFolder;
            }

            // Loop through the Notifications
            for (iNotify=0; iNotify<m_cNotify; iNotify++)
            {
                // Do we have a window /
                if (m_prghwndNotify[iNotify])
                {
                    // Is a valid window ?
                    if (IsWindow(m_prghwndNotify[iNotify]))
                    {
                        // Allocate a FolderNotifyEx
                        IF_NULLEXIT(pSend = (LPFOLDERNOTIFYEX)g_pMalloc->Alloc(sizeof(FOLDERNOTIFYEX)));

                        // Copy the Base
                        CopyMemory(pSend, &SendBase, sizeof(FOLDERNOTIFYEX));

                        // Send It
                        SendMessage(m_prghwndNotify[iNotify], WM_FOLDERNOTIFY, 0, (LPARAM)pSend);

                        // Don't Free It
                        pSend = NULL;
                    }

                    // Don't try this window again
                    else
                        m_prghwndNotify[iNotify] = NULL;
                }
            }
        }
    }

exit:
    // Cleanup
    SafeMemFree(pSend);

    // Free Records
    g_pStore->FreeRecord(&Folder1);
    g_pStore->FreeRecord(&Folder2);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CompactAll (1 = Fail with no UI)
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::CompactAll(DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwRecurse=RECURSE_ONLYSUBSCRIBED | RECURSE_SUBFOLDERS;

    // Stack
    TraceCall("CStoreNamespace::UnregisterNotification");

    // Invalid Arg
    if (0 != dwReserved && 1 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // No UI
    if (1 == dwReserved)
        FLAGSET(dwRecurse, RECURSE_NOUI);

    // Do the compaction
    IF_FAILEXIT(hr = CompactFolders(NULL, dwRecurse, FOLDERID_LOCAL_STORE));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetFirstSubFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetFirstSubFolder(FOLDERID dwFolderId, 
    LPFOLDERPROPS pProps, LPHENUMSTORE phEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pEnum=NULL;
    
    // Stack
    TraceCall("CStoreNamespace::GetFirstSubFolder");

    // Invalid Arg
    if (NULL == pProps || NULL == phEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // INit
    *phEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Adjust the Parent
    if (dwFolderId == FOLDERID_ROOT)
        dwFolderId = FOLDERID_LOCAL_STORE;

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Create Enumerator
    IF_FAILEXIT(hr = g_pStore->EnumChildren(dwFolderId, TRUE, &pEnum));

    // Pluck off the first item
    IF_FAILEXIT(hr = pEnum->Next(1, &Folder, NULL));

    // Done ?
    if (S_FALSE == hr)
        goto exit;

    // Copy Folder Properties
    IF_FAILEXIT(hr = FldInfoToFolderProps(&Folder, pProps));

    // Set return
    *phEnum = (HENUMSTORE)pEnum;

    // Don't Free
    pEnum = NULL;

exit:
    // Failed Cleanup
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetNextSubFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetNextSubFolder(HENUMSTORE hEnum, LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pEnum=(IEnumerateFolders *)hEnum;

    // Stack
    TraceCall("CStoreNamespace::GetNextSubFolder");

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Pluck off the next item
    IF_FAILEXIT(hr = pEnum->Next(1, &Folder, NULL));

    // Done ?
    if (S_FALSE == hr)
        goto exit;

    // Copy Folder Properties
    IF_FAILEXIT(hr = FldInfoToFolderProps(&Folder, pProps));

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetSubFolderClose
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetSubFolderClose(HENUMSTORE hEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    IEnumerateFolders  *pEnum=(IEnumerateFolders *)hEnum;

    // Stack
    TraceCall("CStoreNamespace::GetSubFolderClose");

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Renum pEnum
    SafeRelease(pEnum);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::CStoreFolder
//-------------------------------------------------------------------------- 
CStoreFolder::CStoreFolder(IMessageFolder *pFolder, CStoreNamespace *pNamespace) 
    : m_pFolder(pFolder), m_pNamespace(pNamespace)
{
    TraceCall("CStoreFolder::CStoreFolder");
    Assert(m_pNamespace && m_pFolder);
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_hwndNotify = NULL;
    m_pFolder->AddRef();
    m_pNamespace->AddRef();
    m_pFolder->GetFolderId(&m_idFolder);
    InitializeCriticalSection(&m_cs);
}

//--------------------------------------------------------------------------
// CStoreFolder::CStoreFolder
//-------------------------------------------------------------------------- 
CStoreFolder::~CStoreFolder(void)
{
    TraceCall("CStoreFolder::~CStoreFolder");
    SafeRelease(m_pFolder);
    SafeRelease(m_pNamespace);
    DeleteCriticalSection(&m_cs);
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CStoreFolder::QueryInterface
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IStoreFolder *)this;
    else if (IID_IStoreFolder == riid)
        *ppv = (IStoreFolder *)this;
    else if (IID_CStoreFolder == riid)
        *ppv = (CStoreFolder *)this;
    else if (IID_IStoreCallback == riid)
        *ppv = (IStoreCallback *)this;
    else if (IID_IDatabaseNotify == riid)
        *ppv = (IDatabaseNotify *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::AddRef
//-------------------------------------------------------------------------- 
STDMETHODIMP_(ULONG) CStoreFolder::AddRef(void)
{
    TraceCall("CStoreFolder::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CStoreFolder::Release
//-------------------------------------------------------------------------- 
STDMETHODIMP_(ULONG) CStoreFolder::Release(void)
{
    TraceCall("CStoreFolder::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CStoreFolder::GetFolderProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetFolderProps(DWORD dwReserved, LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::GetFolderProps");

    // Invalid Arg
    if (0 != dwReserved || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Call through namespace
    IF_FAILEXIT(hr = m_pNamespace->GetFolderProps(m_idFolder, 0, pProps));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::DeleteMessages
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::DeleteMessages(LPMESSAGEIDLIST pMsgIdList, DWORD dwReserved, 
    IProgressNotify *pProgress)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::DeleteMessages");

    // Invalid Arg
    if (NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg || 0 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Delete me some messages
    IF_FAILEXIT(hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOPROMPT, pMsgIdList, NULL, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::SetLanguage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::SetLanguage(DWORD dwLanguage, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList)
{
    // Locals
    HRESULT          hr=S_OK;
    MESSAGEINFO      MsgInfo={0};
    ULONG            i;

    // Stack
    TraceCall("CStoreFolder::SetLanguage");

    // Invalid Arg
    if (0 != dwReserved || NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Loop through the message ids
    for (i=0; i<pMsgIdList->cMsgs; i++)
    {
        // Initialize MsgInfo with the Id
        MsgInfo.idMessage = pMsgIdList->prgidMsg[i];

        // Find the Row
        IF_FAILEXIT(hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL));

        // If Not found
        if (DB_S_FOUND == hr)
        {
            // Return the Language
            MsgInfo.wLanguage = (WORD)dwLanguage;

            // Update the Record
            IF_FAILEXIT(hr = m_pFolder->UpdateRecord(&MsgInfo));

            // Free It
            m_pFolder->FreeRecord(&MsgInfo);
        }
    }

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::MarkMessagesAsRead
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::MarkMessagesAsRead(BOOL fRead, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList)
{
    // Locals
    HRESULT     hr=S_OK;
    ADJUSTFLAGS AdjustFlags={0};

    // Stack
    TraceCall("CStoreFolder::MarkMessagesAsRead");

    // Invalid Arg
    if (0 != dwReserved || NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Setup AdjustFlags
    if (fRead)
        AdjustFlags.dwAdd = ARF_READ;
    else
        AdjustFlags.dwRemove = ARF_READ;

    // Mark messages as read
    IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(pMsgIdList, &AdjustFlags, NULL, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::SetFlags
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::SetFlags(LPMESSAGEIDLIST pMsgIdList, DWORD dwState, 
    DWORD dwStatemask, LPDWORD prgdwNewFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    ADJUSTFLAGS     AdjustFlags={0};
    DWORD           dwArfState=DwConvertMSGtoARF(dwState);
    DWORD           dwArfStateMask=DwConvertMSGtoARF(dwStatemask);
    MESSAGEINFO     MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::SetFlags");

    // Invalid Arg
    if (NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Setup Adjust Flags
    AdjustFlags.dwAdd = (dwArfState & dwArfStateMask);

    // Mark messages as read
    IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(pMsgIdList, &AdjustFlags, NULL, (IStoreCallback *)this));

    // Convert prgdwNewFlags to MSG_xxx Flags
    if (prgdwNewFlags)
    {
        // Loop through the message ids
        for (ULONG i=0; i<pMsgIdList->cMsgs; i++)
        {
            // Initialize MsgInfo with the Id
            MsgInfo.idMessage = pMsgIdList->prgidMsg[i];

            // Find the Row
            IF_FAILEXIT(hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL));

            // If Not found
            if (DB_S_FOUND == hr)
            {
                // Return the Flags
                prgdwNewFlags[i] = DwConvertARFtoMSG(MsgInfo.dwFlags);

                // Free It
                m_pFolder->FreeRecord(&MsgInfo);
            }
        }
    }

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::OpenMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::OpenMessage(MESSAGEID dwMessageId, REFIID riid, LPVOID *ppvObject)
{
    // Locals
    HRESULT          hr=S_OK;
    MESSAGEINFO      MsgInfo={0};
    IStream         *pStream=NULL;
    IMimeMessage    *pMessage=NULL;

    // Stack
    TraceCall("CStoreFolder::OpenMessage");

    // Invalid Arg
    if (MESSAGEID_INVALID == dwMessageId || NULL == ppvObject || (IID_IStream != riid && IID_IMimeMessage != riid))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppvObject = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Streamout
    // [PaulHi] 6/11/99  Raid 69317
    // This is a security hole.  We can't export a public method that allows anyone
    // to open and read a secure message.
    IF_FAILEXIT(hr = m_pFolder->OpenMessage(dwMessageId, OPEN_MESSAGE_SECURE/*NOFLAGS*/, &pMessage, (IStoreCallback *)this));

    // User just wants a stream out...
    if (IID_IStream == riid)
    {
        // Streamout
        IF_FAILEXIT(hr = pMessage->GetMessageSource(&pStream, NOFLAGS));

        // Set Return
        *ppvObject = pStream;

        // AddRef It
        pStream->AddRef();
    }

    // Otherwise, user wants an IMimeMessage
    else
    {
        // Set Return
        *ppvObject = pMessage;

        // AddRef It
        pMessage->AddRef();
    }

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::SaveMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::SaveMessage(REFIID riid, LPVOID pvObject, DWORD dwMsgFlags, 
    LPMESSAGEID pdwMessageId)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimeMessage       *pMessage=NULL;
    IStream            *pStream=NULL;
    IStream            *pStmSource=NULL;
    MESSAGEID           dwMessageId=MESSAGEID_INVALID;

    // Stack
    TraceCall("CStoreFolder::SaveMessage");

    // Invalid Arg
    if ((IID_IStream != riid && IID_IMimeMessage != riid) || NULL == pvObject)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Creates me a stream to put the message in...
    IF_FAILEXIT(hr = CreateStream(NULL, 0, &pStream, &dwMessageId));

    // If they gave me a stream, I need to create an IMimeMessage
    if (IID_IStream == riid)
    {
        // Cast to a IStream
        pStmSource = (IStream *)pvObject;

        // AddRef
        pStmSource->AddRef();
    }

    // Otherwise, the user gave me a message
    else
    {
        // Cast to a message
        pMessage = (IMimeMessage *)pvObject;

        // AddRef since we release in cleanup
        IF_FAILEXIT(hr = pMessage->GetMessageSource(&pStmSource, 0));
    }

    // Copy pvObject to pStream
    IF_FAILEXIT(hr = HrCopyStream(pStmSource, pStream, NULL));

    // Commit the stream
    IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

    // Creates me a stream to put the message in...
    IF_FAILEXIT(hr = CommitStream(NULL, 0, dwMsgFlags, pStream, dwMessageId, pMessage));

    // Return the message id
    if (pdwMessageId)
        *pdwMessageId = dwMessageId;

    // We commited
    dwMessageId = MESSAGEID_INVALID;
    SafeRelease(pStream);

exit:
    // If we didn't commit
    if (FAILED(hr) && MESSAGEID_INVALID != dwMessageId && pStream)
        CommitStream(NULL, COMMITSTREAM_REVERT, 0, pStream, dwMessageId, NULL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pStmSource);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::CreateStream
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::CreateStream(HBATCHLOCK hBatchLock, DWORD dwReserved, 
    IStream **ppStream, LPMESSAGEID pdwMessageId)
{
    // Locals
    HRESULT          hr=S_OK;
    FILEADDRESS      faStream;

    // Stack
    TraceCall("CStoreFolder::CreateStream");

    // Invalid Arg
    if (0 != dwReserved || NULL == ppStream || NULL == pdwMessageId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppStream = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Generate a message Id
    IF_FAILEXIT(hr = m_pFolder->GenerateId((LPDWORD)pdwMessageId));

    // Create a Stream
    IF_FAILEXIT(hr = m_pFolder->CreateStream(&faStream));

    // Open the Stream
    IF_FAILEXIT(hr = m_pFolder->OpenStream(ACCESS_WRITE, faStream, ppStream));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::CommitStream
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::CommitStream(HBATCHLOCK hBatchLock, DWORD dwFlags, 
    DWORD dwMsgFlags, IStream *pStream, MESSAGEID dwMessageId, 
    IMimeMessage *pMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    DWORD                   dwImfFlags;
    DWORD                   dwArfFlags=DwConvertMSGtoARF(dwMsgFlags);
    IDatabaseStream        *pDBStream=NULL;

    // Stack
    TraceCall("CStoreFolder::CommitStream");

    // Validate
    Assert(hBatchLock == (HBATCHLOCK)this);

    // Invalid Arg
    if (NULL == pStream || MESSAGEID_INVALID == dwMessageId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Determine if this is an ObjectDB Stream
    IF_FAILEXIT(hr = pStream->QueryInterface(IID_IDatabaseStream, (LPVOID *)&pDBStream));

    // If no stream, this must be a failure
    if (ISFLAGSET(dwFlags, COMMITSTREAM_REVERT))
    {
        // Locals
        FILEADDRESS faStream;

        // Get the Address
        IF_FAILEXIT(hr = pDBStream->GetFileAddress(&faStream));

        // Delete the Stream
        IF_FAILEXIT(hr = m_pFolder->DeleteStream(faStream));

        // Done
        goto exit;
    }

    // Convert the Stream to a REad lock
    IF_FAILEXIT(hr = m_pFolder->ChangeStreamLock(pDBStream, ACCESS_READ));

    // If the user did not passin an IMimeMessage
    if (NULL == pMessage)
    {
        // Create a message object
        IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMessage));

        // Lets rewind the stream
        IF_FAILEXIT(hr = HrRewindStream(pStream));

        // Load the message object with the stream
        IF_FAILEXIT(hr = pMessage->Load(pStream));
    }
    else
        pMessage->AddRef();

    // Get message flags
    pMessage->GetFlags(&dwImfFlags);
    if (ISFLAGSET(dwImfFlags, IMF_VOICEMAIL))
        FLAGSET(dwArfFlags, ARF_VOICEMAIL);

    // Insert the message
    IF_FAILEXIT(hr = m_pFolder->SaveMessage(&dwMessageId, NOFLAGS, dwArfFlags, pDBStream, pMessage, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pMessage);
    SafeRelease(pDBStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::BatchLock
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::BatchLock(DWORD dwReserved, LPHBATCHLOCK phBatchLock)
{
    // Just a simple test
    *phBatchLock = (HBATCHLOCK)this;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::BatchFlush
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::BatchFlush(DWORD dwReserved, HBATCHLOCK hBatchLock)
{
    // Just a simple test
    Assert(hBatchLock == (HBATCHLOCK)this);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::BatchUnlock
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::BatchUnlock(DWORD dwReserved, HBATCHLOCK hBatchLock)
{
    // Just a simple test
    Assert(hBatchLock == (HBATCHLOCK)this);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::RegisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::RegisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::RegisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Somebody is already registered
    if (m_hwndNotify)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Register for notify on the folder
    IF_FAILEXIT(hr = m_pFolder->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, NOTIFY_FOLDER, (IDatabaseNotify *)this));

    // Register for notify on the store
    IF_FAILEXIT(hr = g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, NOTIFY_STORE, (IDatabaseNotify *)this));

    // Hold Onto hwnd
    m_hwndNotify = hwnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::UnregisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::UnregisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::UnregisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Nobody is registered
    if (NULL == m_hwndNotify)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Kill It
    m_hwndNotify = NULL;

    // Register for notify
    IF_FAILEXIT(hr = g_pStore->UnregisterNotify((IDatabaseNotify *)this));

    // Register for notify
    IF_FAILEXIT(hr = m_pFolder->UnregisterNotify((IDatabaseNotify *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::Compact
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::Compact(DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwRecurse=RECURSE_ONLYSUBSCRIBED | RECURSE_INCLUDECURRENT;

    // Stack
    TraceCall("CStoreFolder::Compact");

    // Invalid Arg
    if (0 != dwReserved && 1 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // No UI
    if (1 == dwReserved)
        FLAGSET(dwRecurse, RECURSE_NOUI);

    // Compact
    IF_FAILEXIT(hr = CompactFolders(NULL, dwRecurse, m_idFolder));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetMessageProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetMessageProps(MESSAGEID dwMessageId, DWORD dwFlags, LPMESSAGEPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::GetMessageProps");

    // Invalid Arg
    if (MESSAGEID_INVALID == dwMessageId || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Set Id
    MsgInfo.idMessage = dwMessageId;

    // Find dwMessageId
    IF_FAILEXIT(hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Copy message header to message props
    IF_FAILEXIT(hr = MsgInfoToMessageProps(ISFLAGSET(dwFlags, MSGPROPS_FAST), &MsgInfo, pProps));

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::FreeMessageProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::FreeMessageProps(LPMESSAGEPROPS pProps)
{
    // Locals
    DWORD       cbSize;
    MESSAGEINFO MsgInfo;

    // Stack
    TraceCall("CStoreFolder::FreeMessageProps");

    // Invalid Arg
    if (NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Bad version
    if (sizeof(MESSAGEPROPS) != pProps->cbSize)
    {
        AssertSz(FALSE, "Invalid - un-supported version.");
        return TraceResult(MSOEAPI_E_INVALID_STRUCT_SIZE);
    }

    // Save Size
    cbSize = pProps->cbSize;

    // Free the elements
    if (pProps->dwReserved && m_pFolder)
    {
        // Store the Pointer
        MsgInfo.pAllocated = (LPBYTE)pProps->dwReserved;

        // Free It
        m_pFolder->FreeRecord(&MsgInfo);
    }

    // Free the STream
    SafeRelease(pProps->pStmOffsetTable);

    // ZeroInit
    ZeroMemory(pProps, sizeof(MESSAGEPROPS));
    pProps->cbSize = cbSize;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetMessageFolder
//-------------------------------------------------------------------------- 
HRESULT CStoreFolder::GetMessageFolder(IMessageFolder **ppFolder)
{
    // Stack
    TraceCall("CStoreFolder::GetMessageFolder");

    // Invalid Arg
    Assert(ppFolder)

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Retrun
    *ppFolder = m_pFolder;
    (*ppFolder)->AddRef();

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetFirstMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetFirstMessage(DWORD dwFlags, DWORD dwMsgFlags, MESSAGEID dwMsgIdFirst, 
    LPMESSAGEPROPS pProps, LPHENUMSTORE phEnum)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwArfFlags=DwConvertMSGtoARF(dwMsgFlags);
    HROWSET     hRowset=NULL;
    MESSAGEINFO MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::GetFirstMessage");

    // Invalid Arg
    if (NULL == pProps || NULL == phEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Create a Rowset
    IF_FAILEXIT(hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop..
    IF_FAILEXIT(hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL));

    // If Nothing found
    if (S_FALSE == hr)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // MsgInfoToMessageProps
    IF_FAILEXIT(hr = MsgInfoToMessageProps(ISFLAGSET(dwFlags, MSGPROPS_FAST), &MsgInfo, pProps));

    // Return the Handle
    *phEnum = (HENUMSTORE)hRowset;

exit:
    // Failure
    if (FAILED(hr))
        m_pFolder->CloseRowset(&hRowset);

    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetNextMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetNextMessage(HENUMSTORE hEnum, DWORD dwFlags, LPMESSAGEPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;
    HROWSET     hRowset=(HROWSET)hEnum;
    MESSAGEINFO MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::GetNextMessage");

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Loop..
    IF_FAILEXIT(hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL));

    // If Nothing found
    if (S_FALSE == hr)
        goto exit;

    // MsgInfoToMessageProps
    IF_FAILEXIT(hr = MsgInfoToMessageProps(ISFLAGSET(dwFlags, MSGPROPS_FAST), &MsgInfo, pProps));

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetMessageClose
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetMessageClose(HENUMSTORE hEnum)
{
    // Locals
    HROWSET     hRowset=(HROWSET)hEnum;

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Close the Rowset
    m_pFolder->CloseRowset(&hRowset);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::OnNotify
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::OnTransaction(HTRANSACTION hTransaction, 
    DWORD_PTR dwCookie, IDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    TRANSACTIONTYPE tyTransaction;
    ORDINALLIST     Ordinals;
    MESSAGEINFO     Message1={0};
    MESSAGEINFO     Message2={0};
    FOLDERINFO      Folder1={0};
    FOLDERINFO      Folder2={0};
    UINT            msg=0;
    WPARAM          wParam=0;
    LPARAM          lParam=0;
    INDEXORDINAL    iIndex;

    // Trace
    TraceCall("CStoreFolder::OnNotify");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Notify on the Folder
    if (NOTIFY_FOLDER == dwCookie)
    {
        // Loop through the Notification Info
        while (hTransaction)
        {
            // Get Transact Info
            IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Message1, &Message2, &iIndex, &Ordinals));

            // TRANSACTION_INSERT
            if (TRANSACTION_INSERT == tyTransaction)
            {
                msg = WM_NEWMSGS;
                wParam = (WPARAM)Message1.idMessage;
            }

            // TRANSACTION_UPDATE
            else if (TRANSACTION_UPDATE == tyTransaction)
            {
                // Unread State Change ?
                if (ISFLAGSET(Message1.dwFlags, ARF_READ) != ISFLAGSET(Message2.dwFlags, ARF_READ))
                {
                    // Set w and l param
                    wParam = (WPARAM)&Message2.idMessage;
                    lParam = 1;

                    // Marked as Read
                    if (ISFLAGSET(Message2.dwFlags, ARF_READ))
                        msg = WM_MARKEDASREAD;
                    else
                        msg = WM_MARKEDASUNREAD;
                }
            }

            // TRANSACTION_DELETE
            else if (TRANSACTION_DELETE == tyTransaction)
            {
                // Allocate a message id
                LPMESSAGEID pidMessage = (LPMESSAGEID)g_pMalloc->Alloc(sizeof(MESSAGEID));

                // If that worked
                if (pidMessage)
                {
                    msg = WM_DELETEMSGS;
                    *pidMessage = Message1.idMessage;
                    wParam = (WPARAM)pidMessage;
                    lParam = 1;
                }
            }

            // Do we have a message?
            if (IsWindow(m_hwndNotify))
            {
                // Send Delete Folder Notification
                SendMessage(m_hwndNotify, msg, wParam, lParam);
            }
        }
    }

    // Otherwise, store notification
    else
    {
        // Must be a store notification
        Assert(NOTIFY_STORE == dwCookie);

        // Loop through the Notification Info
        while (hTransaction)
        {
            // Get Transact Info
            IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals));

            // Only Reporting Delete folder Notifications
            if (TRANSACTION_DELETE == tyTransaction)
            {
                // Send Delete Folder Notification
                PostMessage(m_hwndNotify, WM_DELETEFOLDER, (WPARAM)Folder1.idFolder, 0);
            }
        }
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder1);
    g_pStore->FreeRecord(&Folder2);
    m_pFolder->FreeRecord(&Message1);
    m_pFolder->FreeRecord(&Message2);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\istore.h ===
//--------------------------------------------------------------------------
// ISTORE.H
//--------------------------------------------------------------------------
#ifndef __ISTORE_H
#define __ISTORE_H

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
interface INotify;

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define NOTIFY_FOLDER       0xf0001000
#define NOTIFY_STORE        0xf0002000

//--------------------------------------------------------------------------
// ENUMFOLDERINFO
//--------------------------------------------------------------------------
typedef struct tagENUMFOLDERINFO {
    HLOCK           hLock;
    FOLDERID        idNext;
} ENUMFOLDERINFO, *LPENUMFOLDERINFO;

//--------------------------------------------------------------------------
// CStoreNamespace
//--------------------------------------------------------------------------
class CStoreNamespace : public IStoreNamespace, public IDatabaseNotify, public IStoreCallback
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CStoreNamespace(void);
    ~CStoreNamespace(void);

    //----------------------------------------------------------------------
    // IUnknown Methods
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IStoreCallback Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) { return(E_NOTIMPL); }

    //----------------------------------------------------------------------
    // IDatabaseNotify Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pLog);

    //----------------------------------------------------------------------
    // IStoreNamespace Methods
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(HWND hwndOwner, DWORD dwReserved);
    STDMETHODIMP GetDirectory(LPSTR pszPath, DWORD cchMaxPath);
    STDMETHODIMP OpenSpecialFolder(LONG sfType, DWORD dwReserved, IStoreFolder **ppFolder);
    STDMETHODIMP OpenFolder(FOLDERID dwFolderId, DWORD dwReserved, IStoreFolder **ppFolder);
    STDMETHODIMP CreateFolder(FOLDERID dwParentId, LPCSTR pszName,DWORD dwReserved, LPFOLDERID pdwFolderId);
    STDMETHODIMP RenameFolder(FOLDERID dwFolderId, DWORD dwReserved, LPCSTR pszNewName);
    STDMETHODIMP MoveFolder(FOLDERID dwFolderId, FOLDERID dwParentId, DWORD dwReserved);
    STDMETHODIMP DeleteFolder(FOLDERID dwFolderId, DWORD dwReserved);
    STDMETHODIMP GetFolderProps(FOLDERID dwFolderId, DWORD dwReserved, LPFOLDERPROPS pProps);
    STDMETHODIMP CopyMoveMessages(IStoreFolder *pSource, IStoreFolder *pDest, LPMESSAGEIDLIST pMsgIdList, DWORD dwFlags, DWORD dwFlagsRemove,IProgressNotify *pProgress);
    STDMETHODIMP RegisterNotification(DWORD dwReserved, HWND hwnd);
    STDMETHODIMP UnregisterNotification(DWORD dwReserved, HWND hwnd);
    STDMETHODIMP CompactAll(DWORD dwReserved);
    STDMETHODIMP GetFirstSubFolder(FOLDERID dwFolderId, LPFOLDERPROPS pProps, LPHENUMSTORE phEnum);
    STDMETHODIMP GetNextSubFolder(HENUMSTORE hEnum, LPFOLDERPROPS pProps);
    STDMETHODIMP GetSubFolderClose(HENUMSTORE hEnum);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    HINITREF            m_hInitRef;     // Application reference count
    BOOL                m_fRegistered;  // Is this object register for notifications yets
    DWORD               m_cNotify;      // Number of notification recipients
    HWND               *m_prghwndNotify;// Array of hwnd's to notify
    CRITICAL_SECTION    m_cs;           // Thread Safety
};

//--------------------------------------------------------------------------
// CStoreFolder
//--------------------------------------------------------------------------
class CStoreFolder : public IStoreFolder, public IDatabaseNotify, public IStoreCallback
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CStoreFolder(IMessageFolder *pFolder, CStoreNamespace *pNamespace);
    ~CStoreFolder(void);

    //----------------------------------------------------------------------
    // IUnknown Methods
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IStoreCallback Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) { return(E_NOTIMPL); }

    //----------------------------------------------------------------------
    // IDatabaseNotify Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pLog);

    //----------------------------------------------------------------------
    // IStoreFolder Methods
    //----------------------------------------------------------------------
    STDMETHODIMP GetFolderProps(DWORD dwReserved, LPFOLDERPROPS pProps);
    STDMETHODIMP GetMessageProps(MESSAGEID dwMessageId, DWORD dwFlags, LPMESSAGEPROPS pProps);
    STDMETHODIMP FreeMessageProps(LPMESSAGEPROPS pProps);
    STDMETHODIMP DeleteMessages(LPMESSAGEIDLIST pMsgIdList, DWORD dwReserved, IProgressNotify *pProgress);
    STDMETHODIMP SetLanguage(DWORD dwLanguage, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList);
    STDMETHODIMP MarkMessagesAsRead(BOOL fRead, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList);
    STDMETHODIMP SetFlags(LPMESSAGEIDLIST pMsgIdList, DWORD dwState, DWORD dwStatemask, LPDWORD prgdwNewFlags);
    STDMETHODIMP OpenMessage(MESSAGEID dwMessageId, REFIID riid, LPVOID *ppvObject);            
    STDMETHODIMP SaveMessage(REFIID riid, LPVOID pvObject, DWORD dwMsgFlags, LPMESSAGEID pdwMessageId);          
    STDMETHODIMP BatchLock(DWORD dwReserved, LPHBATCHLOCK phBatchLock);           
    STDMETHODIMP BatchFlush(DWORD dwReserved, HBATCHLOCK hBatchLock);            
    STDMETHODIMP BatchUnlock(DWORD dwReserved, HBATCHLOCK hBatchLock);
    STDMETHODIMP CreateStream(HBATCHLOCK hBatchLock, DWORD dwReserved, IStream **ppStream, LPMESSAGEID pdwMessageId);
    STDMETHODIMP CommitStream(HBATCHLOCK hBatchLock, DWORD dwFlags, DWORD dwMsgFlags, IStream *pStream, MESSAGEID dwMessageId, IMimeMessage *pMessage);
    STDMETHODIMP RegisterNotification(DWORD dwReserved, HWND hwnd);                  
    STDMETHODIMP UnregisterNotification(DWORD dwReserved, HWND hwnd);                  
    STDMETHODIMP Compact(DWORD dwReserved);            
    STDMETHODIMP GetFirstMessage(DWORD dwFlags, DWORD dwMsgFlags, MESSAGEID dwMsgIdFirst, LPMESSAGEPROPS pProps, LPHENUMSTORE phEnum);
    STDMETHODIMP GetNextMessage(HENUMSTORE hEnum, DWORD dwFlags, LPMESSAGEPROPS pProps);
    STDMETHODIMP GetMessageClose(HENUMSTORE hEnum);

    //----------------------------------------------------------------------
    // CStoreFolder Methods
    //----------------------------------------------------------------------
    HRESULT GetMessageFolder(IMessageFolder **ppFolder);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;                 // Reference Count
    HWND                m_hwndNotify;           // Current Registered Notify Window
    FOLDERID            m_idFolder;             // ID of this folder
    IMessageFolder     *m_pFolder;              // The real folder
    CStoreNamespace    *m_pNamespace;           // Store Namespace
    CRITICAL_SECTION    m_cs;                   // Thread Safety
};

//--------------------------------------------------------------------------
// C Prototypes
//--------------------------------------------------------------------------
HRESULT CreateInstance_StoreNamespace(IUnknown *pUnkOuter, IUnknown **ppUnknown);

#endif // __ISTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\locstore.cpp ===
//--------------------------------------------------------------------------
// LocStore.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "locstore.h"

//--------------------------------------------------------------------------
// CreateLocalStore
//--------------------------------------------------------------------------
HRESULT CreateLocalStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateLocalStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CLocalStore *pNew = new CLocalStore();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IUnknown *);

    // Done
    return S_OK;
}

//--------------------------------------------------------------------------
// CLocalStore::CLocalStore
//--------------------------------------------------------------------------
CLocalStore::CLocalStore(void)
{
    TraceCall("CLocalStore::CLocalStore");
    g_pInstance->DllAddRef();
    m_cRef = 1;
}

//--------------------------------------------------------------------------
// CLocalStore::~CLocalStore
//--------------------------------------------------------------------------
CLocalStore::~CLocalStore(void)
{
    // Trace
    TraceCall("CLocalStore::~CLocalStore");
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CLocalStore::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CLocalStore::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CLocalStore::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMessageServer == riid)
        *ppv = (IMessageServer *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CLocalStore::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLocalStore::AddRef(void)
{
    TraceCall("CLocalStore::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CLocalStore::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLocalStore::Release(void)
{
    TraceCall("CLocalStore::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\locstore.h ===
// --------------------------------------------------------------------------------
// Locstore.h
// --------------------------------------------------------------------------------
#ifndef __LOCSTORE_H
#define __LOCSTORE_H

//--------------------------------------------------------------------------
// CLocalStore
//--------------------------------------------------------------------------
class CLocalStore : public IMessageServer
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CLocalStore(void);
    ~CLocalStore(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IStoreSink Members
    //----------------------------------------------------------------------
    STDMETHODIMP SetCurrentFolder(IMessageStore *pStore, IMessageFolder *pFolder, FOLDERID idFolder) { return S_OK; }
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback, HWND hwndUIParent) { return E_NOTIMPL; }
    STDMETHODIMP SetConnectionState(CONNECT_STATE tyConnect) { return E_NOTIMPL; }
    STDMETHODIMP SynchronizeFolder(SYNCFOLDERFLAGS dwFlags) { return E_NOTIMPL; }
    STDMETHODIMP GetMessage(MESSAGEID idMessage, IStream *pStream, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream *pStream, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP SynchronizeStore(FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetFolderCounts( FOLDERID idFolder,IStoreCallback *pCallback) { return E_NOTIMPL; }

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;         // Reference Counting
    IDatabaseTable *m_pTable;       // Database table
    FOLDERID        m_idFolder;     // Folder Id We are looking at
    IMessageStore  *m_pStore;       // My Store Object
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateLocalStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);

#endif // __LOCSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\msgfldr.h ===
//--------------------------------------------------------------------------
// MsgFldr.h
//--------------------------------------------------------------------------
#ifndef __MSGFLDR_H
#define __MSGFLDR_H

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "dbimpl.h"

//--------------------------------------------------------------------------
// ONLOCKINFO
//--------------------------------------------------------------------------
typedef struct tagONLOCKINFO {
    DWORD           cLocked;
    LONG            lMsgs;
    LONG            lUnread;
    LONG            lWatchedUnread;
    LONG            lWatched;
} ONLOCKINFO, *LPONLOCKINFO;

//--------------------------------------------------------------------------
// FOLDERSTATE
//--------------------------------------------------------------------------
typedef DWORD FOLDERSTATE;
#define FOLDER_STATE_RELEASEDB          0x00000001
#define FOLDER_STATE_CANCEL             0x00000002

//--------------------------------------------------------------------------
// CMessageFolder
//--------------------------------------------------------------------------
class CMessageFolder : public IMessageFolder, 
                       public IDatabaseExtension,
                       public IOperationCancel,
                       public IServiceProvider
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CMessageFolder(void);
    ~CMessageFolder(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageFolder Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERID idFolder);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetFolderId(LPFOLDERID pidFolder);
    STDMETHODIMP GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder);
    STDMETHODIMP Close(void) { return(S_OK); }
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback) { return(S_OK); }
    STDMETHODIMP OpenMessage(MESSAGEID idMessage, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP SaveMessage(LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageStream(MESSAGEID idMessage, IStream *pStream);
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPRESULTLIST pResults, IStoreCallback *pCallback); 
    STDMETHODIMP ConnectionAddRef(void) { return(S_OK); }
    STDMETHODIMP ConnectionRelease(void) { return(S_OK); }
    STDMETHODIMP ResetFolderCounts(DWORD cMessages, DWORD cUnread, DWORD cWatchedUnread, DWORD cWatched);
    STDMETHODIMP IsWatched(LPCSTR pszReferences, LPCSTR pszSubject);
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback) { return E_NOTIMPL; };

    //----------------------------------------------------------------------
    // IMessageFolder::GetDatabase Members
    //----------------------------------------------------------------------
    STDMETHODIMP GetDatabase(IDatabase **ppDB) { 
        *ppDB = m_pDB; 
        (*ppDB)->AddRef(); 
        return(S_OK); 
    }

    //----------------------------------------------------------------------
    // IDatabaseExtension Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IDatabase *pDB);
    STDMETHODIMP OnLock(void);
    STDMETHODIMP OnUnlock(void);
    STDMETHODIMP OnRecordInsert(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnRecordUpdate(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew);
    STDMETHODIMP OnRecordDelete(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnExecuteMethod(METHODID idMethod, LPVOID pBinding, LPDWORD pdwResult);

    //----------------------------------------------------------------------
    // IServiceProvider 
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IOperationCancel Members
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel) { FLAGSET(m_dwState, FOLDER_STATE_CANCEL); return(S_OK); }

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(TRUE, m_pDB);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _FixupMessageCharset(IMimeMessage *pMessage, CODEPAGEID cpCurrent);
    HRESULT _GetMsgInfoFromMessage(IMimeMessage *pMessage, LPMESSAGEINFO pInfo);
    HRESULT _GetMsgInfoFromPropertySet(IMimePropertySet *pPropertySet, LPMESSAGEINFO pInfo);
    HRESULT _FreeMsgInfoData(LPMESSAGEINFO pInfo);
    HRESULT _SetMessageStream(LPMESSAGEINFO pInfo, BOOL fUpdateRecord, IStream *pStream);
    HRESULT _InitializeWatchIgnoreIndex(void);
    HRESULT _GetWatchIgnoreParentFlags(LPCSTR pszReferences, LPCSTR pszSubject, MESSAGEFLAGS *pdwFlags);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;                 // Ref Count
    ONLOCKINFO          m_OnLock;               // OnLock information
    FOLDERTYPE          m_tyFolder;             // Folder Type
    SPECIALFOLDER       m_tySpecial;            // Am I a Special Folder ?
    FOLDERID            m_idFolder;             // Folder Id
    FOLDERSTATE         m_dwState;              // Folder State
    IDatabase          *m_pDB;                  // Database Table
    IMessageStore      *m_pStore;               // Store Object
};

//--------------------------------------------------------------------------
// CreateMsgDbExtension
//--------------------------------------------------------------------------
HRESULT CreateMsgDbExtension(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT WalkThreadAdjustFlags(IDatabase *pDB, LPMESSAGEINFO pMessage, 
    BOOL fSubThreads, DWORD cIndent, DWORD_PTR dwCookie, BOOL *pfDoSubThreads);

#endif // __MSGFLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\msgfldr.cpp ===
//--------------------------------------------------------------------------
// MsgFldr.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "store.h"
#include "instance.h"
#include "msgfldr.h"
#include "secutil.h"
#include "storutil.h"
#include "shared.h"
#include "flagconv.h"
#include "qstrcmpi.h"
#include "xpcomm.h"
#include "msgtable.h"
#include "shlwapip.h" 
#include <oerules.h>
#include <ruleutil.h>

//--------------------------------------------------------------------------
// Watch/Ignore Index Filter
//--------------------------------------------------------------------------
static const char c_szWatchIgnoreFilter[] = "((MSGCOL_FLAGS & ARF_WATCH) != 0 || (MSGCOL_FLAGS & ARF_IGNORE) != 0)";

//--------------------------------------------------------------------------
// GETWATCHIGNOREPARENT
//--------------------------------------------------------------------------
typedef struct tagGETWATCHIGNOREPARENT {
    IDatabase      *pDatabase;
    HRESULT         hrResult;
    MESSAGEINFO     Parent;
} GETWATCHIGNOREPARENT, *LPGETWATCHIGNOREPARENT;

//--------------------------------------------------------------------------
// EnumRefsGetWatchIgnoreParent
//--------------------------------------------------------------------------
HRESULT EnumRefsGetWatchIgnoreParent(LPCSTR pszMessageId, DWORD_PTR dwCookie,
    BOOL *pfDone)
{
    // Locals
    LPGETWATCHIGNOREPARENT pGetParent = (LPGETWATCHIGNOREPARENT)dwCookie;

    // Trace
    TraceCall("EnumRefsGetWatchIgnoreParent");

    // Set MessageId
    pGetParent->Parent.pszMessageId = (LPSTR)pszMessageId;

    // Find pszMessageId in the IINDEX_WATCHIGNORE Index
    pGetParent->hrResult = pGetParent->pDatabase->FindRecord(IINDEX_WATCHIGNORE, 1, &pGetParent->Parent, NULL);

    // Done
    if (DB_S_FOUND == pGetParent->hrResult)
    {
        // We are done
        *pfDone = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CreateMsgDbExtension
//--------------------------------------------------------------------------
HRESULT CreateMsgDbExtension(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateMsgDbExtension");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageFolder *pNew = new CMessageFolder();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IDatabaseExtension *);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::CMessageFolder
//--------------------------------------------------------------------------
CMessageFolder::CMessageFolder(void)
{
    TraceCall("CMessageFolder::CMessageFolder");
#ifndef _WIN64
    Assert(1560 == sizeof(FOLDERUSERDATA));
#endif // WIN64
    m_cRef = 1;
    m_pStore = NULL;
    m_pDB = NULL;
    m_tyFolder = FOLDER_INVALID;
    m_tySpecial = FOLDER_NOTSPECIAL;
    m_idFolder = FOLDERID_INVALID;
    m_dwState = 0;
    ZeroMemory(&m_OnLock, sizeof(ONLOCKINFO));
}

//--------------------------------------------------------------------------
// CMessageFolder::~CMessageFolder
//--------------------------------------------------------------------------
CMessageFolder::~CMessageFolder(void)
{
    // Trace
    TraceCall("CMessageFolder::~CMessageFolder");

    // Release the Store
    SafeRelease(m_pStore);

    // Release the Database Table
    if (ISFLAGSET(m_dwState, FOLDER_STATE_RELEASEDB) && m_pDB)
    {
        m_pDB->Release();
        m_pDB = NULL;
    }
}

//--------------------------------------------------------------------------
// CMessageFolder::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CMessageFolder::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageFolder *)this;
    else if (IID_IMessageFolder == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IDatabaseExtension == riid)
        *ppv = (IDatabaseExtension *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageFolder::AddRef(void)
{
    TraceCall("CMessageFolder::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CMessageFolder::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageFolder::Release(void)
{
    TraceCall("CMessageFolder::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CMessageFolder::QueryService
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::QueryService(REFGUID guidService, REFIID riid, 
    LPVOID *ppvObject)
{
    // Trace
    TraceCall("CMessageFolder::QueryService");

    // Just a Query Interface
    return(QueryInterface(riid, ppvObject));
}

//--------------------------------------------------------------------------
// CMessageFolder::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::Initialize(IMessageStore *pStore, IMessageServer *pServer,
    OPENFOLDERFLAGS dwFlags, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szDirectory[MAX_PATH];
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    FOLDERINFO      Folder={0};
    FOLDERUSERDATA  UserData={0};

    // Trace
    TraceCall("CMessageFolder::Initialize");

    // Invalid Args
    if (NULL == pStore)
        return TraceResult(E_INVALIDARG);

    // Save the FolderId
    m_idFolder = idFolder;

    // Save pStore (This must happen before m_pDB->Open happens)
    m_pStore = pStore;
    m_pStore->AddRef();

    // Find the Folder Information
    IF_FAILEXIT(hr = pStore->GetFolderInfo(idFolder, &Folder));

    // Make Folder File Path
    IF_FAILEXIT(hr = pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory)));

    // No Folder File Yet ?
    if (FIsEmptyA(Folder.pszFile))
    {
        // Don't Create
        if (ISFLAGSET(dwFlags, OPEN_FOLDER_NOCREATE))
        {
            hr = STORE_E_FILENOEXIST;
            goto exit;
        }

        // Build Friendly Name
        IF_FAILEXIT(hr = BuildFriendlyFolderFileName(szDirectory, &Folder, szFilePath, ARRAYSIZE(szFilePath), NULL, NULL));

        // Get the new pszFile...
        Folder.pszFile = PathFindFileName(szFilePath);

        // Update the Record
        IF_FAILEXIT(hr = pStore->UpdateRecord(&Folder));
    }

    // Otherwise, build the filepath
    else
    {
        // Make File Path
        IF_FAILEXIT(hr = MakeFilePath(szDirectory, Folder.pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));
    }

    // If the file doesn't exist...
    if (FALSE == PathFileExists(szFilePath))
    {
        // Reset the Folder Counts...
        Folder.cMessages = 0;
        Folder.dwClientHigh = 0;
        Folder.dwClientLow = 0;
        Folder.cUnread = 0;
        Folder.cWatched = 0;
        Folder.cWatchedUnread = 0;
        Folder.dwServerHigh = 0;
        Folder.dwServerLow = 0;
        Folder.dwServerCount = 0;
        Folder.dwStatusMsgDelta = 0;
        Folder.dwStatusUnreadDelta = 0;
        Folder.dwNotDownloaded = 0;
        Folder.dwClientWatchedHigh = 0;
        Folder.Requested.cbSize = 0;
        Folder.Requested.pBlobData = NULL;
        Folder.Read.cbSize = 0;
        Folder.Read.pBlobData = NULL;

        // Update the Record
        IF_FAILEXIT(hr = pStore->UpdateRecord(&Folder));

        // No Create ?
        if (ISFLAGSET(dwFlags, OPEN_FOLDER_NOCREATE))
        {
            hr = STORE_E_FILENOEXIST;
            goto exit;
        }
    }

    // Save Special Folder Type
    m_tySpecial = Folder.tySpecial;

    // Save the Folder Type
    m_tyFolder = Folder.tyFolder;

    // Create a Database Table
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NOADDREFEXT, &g_MessageTableSchema, (IDatabaseExtension *)this, &m_pDB));

    // Release m_pDB
    FLAGSET(m_dwState, FOLDER_STATE_RELEASEDB);

    // Get the User Data
    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // May not have been initialized yet ?
    if (FALSE == UserData.fInitialized)
    {
        // Locals
        FOLDERINFO  Server;

        // Get the Server Info
        IF_FAILEXIT(hr = GetFolderServer(Folder.idParent, &Server));

        // Its Initialized
        UserData.fInitialized = TRUE;

        // Configure the Folder UserData
        UserData.tyFolder = Folder.tyFolder;

        // Is Special Folder ?
        UserData.tySpecial = Folder.tySpecial;

        // Copy the Account Id
        StrCpyN(UserData.szAcctId, Server.pszAccountId, ARRAYSIZE(UserData.szAcctId));

        // Free
        pStore->FreeRecord(&Server);

        // Store the Folder Name
        StrCpyN(UserData.szFolder, Folder.pszName, ARRAYSIZE(UserData.szFolder));

        // Set Folder Id
        UserData.idFolder = Folder.idFolder;

        // Sort Ascending
        UserData.fAscending = FALSE;

        // No Threading
        UserData.fThreaded = FALSE;

        // Base Filter
        UserData.ridFilter = (RULEID) IntToPtr(DwGetOption(OPT_VIEW_GLOBAL));
        if ((RULEID_INVALID == UserData.ridFilter) || ((RULEID_VIEW_DOWNLOADED == UserData.ridFilter) && (FOLDER_LOCAL == m_tyFolder)))
            UserData.ridFilter = RULEID_VIEW_ALL;

        // Hide Deleted Messages
        UserData.fShowDeleted = FALSE;

        // Hide Deleted Messages
        UserData.fShowReplies = FALSE;

        // Set Sort Order
        UserData.idSort = COLUMN_RECEIVED;

        // New thread model
        UserData.fNoIndexes = TRUE;

        // Set the User Data
        IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));
    }

    // Otherwise, fixup cWatchedUnread ?
    else
    {
        // No Indexes
        if (FALSE == UserData.fNoIndexes)
        {
            // Index Ordinals
            const INDEXORDINAL IINDEX_VIEW       = 1;
            const INDEXORDINAL IINDEX_MESSAGEID  = 3;
            const INDEXORDINAL IINDEX_SUBJECT    = 4;
            const INDEXORDINAL IINDEX_THREADS    = 5;

            // Delete the indexes that I don't user anymore
            m_pDB->DeleteIndex(IINDEX_VIEW);
            m_pDB->DeleteIndex(IINDEX_MESSAGEID);
            m_pDB->DeleteIndex(IINDEX_SUBJECT);
            m_pDB->DeleteIndex(IINDEX_THREADS);

            // Reset fNoIndexes
            UserData.fNoIndexes = TRUE;

            // Set the User Data
            IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));
        }
    }

    // Initialize Watch/Ignore Index
    _InitializeWatchIgnoreIndex();

exit:
    // Cleanup
    pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::IsWatched
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::IsWatched(LPCSTR pszReferences, 
    LPCSTR pszSubject)
{
    // Locals
    MESSAGEFLAGS dwFlags;

    // Trace
    TraceCall("CMessageFolder::IsWatched");

    // Get Flags
    if (DB_S_FOUND == _GetWatchIgnoreParentFlags(pszReferences, pszSubject, &dwFlags))
    {
        // Watched
        if (ISFLAGSET(dwFlags, ARF_WATCH))
            return(S_OK);
    }

    // Not Watched
    return(S_FALSE);
}

//--------------------------------------------------------------------------
// CMessageFolder::_GetWatchIgnoreParentFlags
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_GetWatchIgnoreParentFlags(LPCSTR pszReferences, 
    LPCSTR pszSubject, MESSAGEFLAGS *pdwFlags)
{
    // Locals
    GETWATCHIGNOREPARENT GetParent;

    // Trace
    TraceCall("CMessageFolder::_GetWatchIgnoreParentFlags");

    // Init hrResult...
    GetParent.pDatabase = m_pDB;
    GetParent.hrResult = DB_S_NOTFOUND;

    // EnumerateReferences
    if (SUCCEEDED(EnumerateRefs(pszReferences, (DWORD_PTR)&GetParent, EnumRefsGetWatchIgnoreParent)))
    {
        // If Found
        if (DB_S_FOUND == GetParent.hrResult)
        {
            // Return the Flags
            *pdwFlags = GetParent.Parent.dwFlags;

            // Free It
            m_pDB->FreeRecord(&GetParent.Parent);
        }
    }

    // Not Watched
    return(GetParent.hrResult);
}

//--------------------------------------------------------------------------
// CMessageFolder::_InitializeWatchIgnoreIndex
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_InitializeWatchIgnoreIndex(void)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fRebuild=FALSE;
    LPSTR       pszFilter=NULL;
    TABLEINDEX  Index;

    // Trace
    TraceCall("CMessageFolder::_InitializeWatchIgnoreIndex");

    // Reset fRebuild
    fRebuild = FALSE;

    // Create the Watch Ignore Index
    if (FAILED(m_pDB->GetIndexInfo(IINDEX_WATCHIGNORE, &pszFilter, &Index)))
        fRebuild = TRUE;

    // Filter Change ?
    else if (NULL == pszFilter || lstrcmpi(pszFilter, c_szWatchIgnoreFilter) != 0)
        fRebuild = TRUE;

    // Otherwise, the index is different
    else if (S_FALSE == CompareTableIndexes(&Index, &g_WatchIgnoreIndex))
        fRebuild = TRUE;

    // Rebuild It ?
    if (fRebuild)
    {
        // Create the Index
        IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_WATCHIGNORE, c_szWatchIgnoreFilter, &g_WatchIgnoreIndex));
    }

exit:
    // Cleanup
    SafeMemFree(pszFilter);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::GetFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::GetFolderId(LPFOLDERID pidFolder)
{
    // Trace
    TraceCall("CMessageFolder::GetFolderId");

    // Invalid Args
    if (NULL == pidFolder)
        return TraceResult(E_INVALIDARG);

    // Return the FolderId
    *pidFolder = m_idFolder;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::GetMessageFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder)
{
    // Trace
    TraceCall("CMessageFolder::GetFolderId");

    // Invalid Args
    if (NULL == pidFolder)
        return TraceResult(E_INVALIDARG);

    // Return the FolderId
    *pidFolder = m_idFolder;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OpenMessage(MESSAGEID idMessage, 
    OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT          hr=S_OK;
    IMimeMessage    *pMessage=NULL;
    MESSAGEINFO      Message={0};
    PROPVARIANT      Variant;
    IStream         *pStream=NULL;

    // Trace
    TraceCall("CMessageFolder::OpenMessage");

    // Invalid Args
    if (NULL == ppMessage)
        return TraceResult(E_INVALIDARG);

    // Initiailize
    *ppMessage = NULL;

    // Initialize Message with the Id
    Message.idMessage = idMessage;

    // Find the Row
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Does we have it ?
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Has Expired?
    if (Message.dwFlags & ARF_ARTICLE_EXPIRED)
    {
        hr = STORE_E_EXPIRED;
        goto exit;
    }

    // No Body ?
    if (0 == Message.faStream)
    {
        hr = STORE_E_NOBODY;
        goto exit;
    }

    // Create a Message
    IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMessage));

    // Open the Stream from the Store
    IF_FAILEXIT(hr = m_pDB->OpenStream(ACCESS_READ, Message.faStream, &pStream));

    // If there is an offset table
    if (Message.Offsets.cbSize > 0)
    {
        // Create a ByteStream Object
        CByteStream cByteStm(Message.Offsets.pBlobData, Message.Offsets.cbSize);

        // Load the Offset Table Into the message
        pMessage->LoadOffsetTable(&cByteStm);

        // Take the bytes back out of the bytestream object (so that it doesn't try to free it)
        cByteStm.AcquireBytes(&Message.Offsets.cbSize, &Message.Offsets.pBlobData, ACQ_DISPLACE);
    }

    // Load the pMessage
    IF_FAILEXIT(hr = pMessage->Load(pStream));

    // Undo security enhancements if the caller wants us to
    if (!ISFLAGSET(dwFlags, OPEN_MESSAGE_SECURE))
    {
        // Handle Message Security
        IF_FAILEXIT(hr = HandleSecurity(NULL, pMessage));
    }

    // All Props are VT_LPSTR
    Variant.vt = VT_LPSTR;

    // MUD_SERVER
    if (Message.pszServer)
    {
        Variant.pszVal = Message.pszServer;
        pMessage->SetProp(PIDTOSTR(PID_ATT_SERVER), 0, &Variant);
    }

    // PID_ATT_ACCOUNTID
    if (Message.pszAcctId)
    {
        Variant.pszVal = Message.pszAcctId;
        pMessage->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &Variant);
    }
    
    // PID_ATT_ACCOUNTID
    if (Message.pszAcctName)
    {
        Variant.pszVal = Message.pszAcctName;
        pMessage->SetProp(STR_ATT_ACCOUNTNAME, 0, &Variant);
    }

    // Otherwise, if there is an account id... lets get the account name
    else if (Message.pszAcctId)
    {
        // Locals
        IImnAccount *pAccount=NULL;
        CHAR szName[CCHMAX_ACCOUNT_NAME];

        // Find an Account
        if (g_pAcctMan && SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Message.pszAcctId, &pAccount)))
        {
            // Get the Account name
            if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szName, ARRAYSIZE(szName))))
            {
                Variant.pszVal = szName;
                pMessage->SetProp(STR_ATT_ACCOUNTNAME, 0, &Variant);
            }

            // Release
            pAccount->Release();
        }
    }

    // PID_ATT_UIDL
    if (Message.pszUidl)
    {
        Variant.pszVal = Message.pszUidl;
        pMessage->SetProp(PIDTOSTR(PID_ATT_UIDL), 0, &Variant);
    }

    // PID_ATT_FORWARDTO
    if (Message.pszForwardTo)
    {
        Variant.pszVal = Message.pszForwardTo;
        pMessage->SetProp(PIDTOSTR(PID_ATT_FORWARDTO), 0, &Variant);
    }

    // PID_HDR_XUNSENT
    if (ISFLAGSET(Message.dwFlags, ARF_UNSENT))
    {
        Variant.pszVal = "1";
        pMessage->SetProp(PIDTOSTR(PID_HDR_XUNSENT), 0, &Variant);
    }

    // Fixup Character Set
    IF_FAILEXIT(hr = _FixupMessageCharset(pMessage, (CODEPAGEID)Message.wLanguage));

    // Clear Dirty
    MimeOleClearDirtyTree(pMessage);

    // Return pMessage
    *ppMessage = pMessage;
    pMessage = NULL;

exit:
    // Free Records
    m_pDB->FreeRecord(&Message);

    // Release
    SafeRelease(pMessage);
    SafeRelease(pStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::SaveMessage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::SaveMessage(LPMESSAGEID pidMessage, 
    SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, 
    IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pSource=NULL;
    CByteStream     cStream;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CMessageFolder::SaveMessage");

    // Invalid Args
    if (NULL == pMessage)
        return TraceResult(E_INVALIDARG);

    if (NULL == pidMessage && !ISFLAGSET(dwOptions, SAVE_MESSAGE_GENID))
        return TraceResult(E_INVALIDARG);

    // Get Message from the Message
    IF_FAILEXIT(hr = _GetMsgInfoFromMessage(pMessage, &Message));

    // Validate or Generate a message id
    if (ISFLAGSET(dwOptions, SAVE_MESSAGE_GENID))
    {
        // Generate Unique Message Id
        IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&Message.idMessage));

        // Return It ?
        if (pidMessage)
            *pidMessage = Message.idMessage;
    }

    // Otherwise, just use idMessage
    else
        Message.idMessage = *pidMessage;

    // Set the Message Flags
    Message.dwFlags |= dwFlags;

    // Do I need to store the message stream...
    if (NULL == pStream)
    {
        // Get the Message Stream From the Message
        IF_FAILEXIT(hr = pMessage->GetMessageSource(&pSource, COMMIT_ONLYIFDIRTY));
    }

    // Otherwise, set pSource
    else
    {
        pSource = pStream;
        pSource->AddRef();
    }

    // Store the Message onto this record
    IF_FAILEXIT(hr = _SetMessageStream(&Message, FALSE, pSource));

    // Create the offset table
    if (SUCCEEDED(pMessage->SaveOffsetTable(&cStream, 0)))
    {
        // pulls the Bytes out of cByteStm
        cStream.AcquireBytes(&Message.Offsets.cbSize, &Message.Offsets.pBlobData, ACQ_DISPLACE);
    }
    
    // Store the Record
    if (FAILED(hr = m_pDB->InsertRecord(&Message)))
    {
        // Trace That
        TraceResult(hr);

        // A failure here means that the stream's refCount has been incremented, but the message does not reference the stream
        SideAssert(SUCCEEDED(m_pDB->DeleteStream(Message.faStream)));

        // Done
        goto exit;
    }
    
exit:
    // Free Allocate Message Properties
    _FreeMsgInfoData(&Message);
    
    // Release Message Source IStream 
    SafeRelease(pSource);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::SetMessageStream
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::SetMessageStream(MESSAGEID idMessage, 
    IStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CMessageFolder::SetMessageStream");

    // Invalid Args
    if (NULL == pStream)
        return TraceResult(E_INVALIDARG);

    // Set the MsgId
    Message.idMessage = idMessage;

    // Find the Record
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Store the Stream
    IF_FAILEXIT(hr = _SetMessageStream(&Message, TRUE, pStream));

exit:
    // Free the Record
    m_pDB->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::SetMessageFlags
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::SetMessageFlags(LPMESSAGEIDLIST pList,
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults,
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i=0;
    DWORD           cWatchedUnread=0;
    DWORD           cWatched=0;
    MESSAGEINFO     Message={0};
    HROWSET         hRowset=NULL;
    HLOCK           hLock=NULL;
    MESSAGEFLAGS    dwFlags;
    DWORD           cTotal;

    // Trace
    TraceCall("CMessageFolder::SetMessageFlags");

    // Invalid Args
    if (NULL == pFlags)
        return TraceResult(E_INVALIDARG);

    // Lock Notifications
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

        // Get Count
        IF_FAILEXIT(hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cTotal));
    }

    // Otherwise, set cTotal
    else
        cTotal = pList->cMsgs;

    // User Wants Results ?
    if (pResults)
    {
        // Zero Init
        ZeroMemory(pResults, sizeof(RESULTLIST));

        // Return Results
        IF_NULLEXIT(pResults->prgResult = (LPRESULTINFO)ZeroAllocate(cTotal * sizeof(RESULTINFO)));

        // Set cAllocated
        pResults->cAllocated = pResults->cMsgs = cTotal;
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            Message.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Save Flags
            dwFlags = Message.dwFlags;

            // Remove Flags
            FLAGCLEAR(dwFlags, pFlags->dwRemove);

            // Add Flags
            FLAGSET(dwFlags, pFlags->dwAdd);

            // if there is a body for this msg, then the download flag can't be on
            if (ISFLAGSET(dwFlags, ARF_DOWNLOAD) && ISFLAGSET(dwFlags, ARF_HASBODY))
                FLAGCLEAR(dwFlags, ARF_DOWNLOAD);

            // Update All...or no change
            if (Message.dwFlags != dwFlags)
            {
                // Reset the Flags
                Message.dwFlags = dwFlags;

                // Update the Record
                IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Message));
            }

            // Count Watched Unread
            if (ISFLAGSET(Message.dwFlags, ARF_WATCH))
            {
                // Count Watched
                cWatched++;

                // Is unread
                if (!ISFLAGSET(Message.dwFlags, ARF_READ))
                    cWatchedUnread++;
            }

            // Return Result
            if (pResults)
            {
                // hrResult
                pResults->prgResult[i].hrResult = S_OK;

                // Message Id
                pResults->prgResult[i].idMessage = Message.idMessage;

                // Store Falgs
                pResults->prgResult[i].dwFlags = Message.dwFlags;
            
                // Increment Success
                pResults->cValid++;
            }

            // Free
            m_pDB->FreeRecord(&Message);
        }

        // Otherwise, if pResults
        else if (pResults)
        {
            // Set hr
            pResults->prgResult[i].hrResult = hr;

            // Increment Success
            pResults->cValid++;
        }
    }

exit:
    // Reset Folder Counts ?
    if (NULL == pList && ISFLAGSET(pFlags->dwAdd, ARF_READ))
    {
        // Reset Folder Counts
        ResetFolderCounts(i, 0, cWatchedUnread, cWatched);
    }

    // Unlock the Database
    m_pDB->Unlock(&hLock);

    // Cleanup
    m_pDB->FreeRecord(&Message);
    m_pDB->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMesageFolder::ResetFolderCounts
//--------------------------------------------------------------------------
HRESULT CMessageFolder::ResetFolderCounts(DWORD cMessages, DWORD cUnread,
    DWORD cWatchedUnread, DWORD cWatched)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("CMesageFolder::ResetFolderCounts");

    // Get Folder Info
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_idFolder, &Folder));

    Folder.cMessages = cMessages;
    Folder.cUnread = cUnread;    
    Folder.cWatchedUnread = cWatchedUnread;
    Folder.cWatched = cWatched;
    Folder.dwStatusMsgDelta = 0;
    Folder.dwStatusUnreadDelta = 0;

    // Update the Record
    IF_FAILEXIT(hr = m_pStore->UpdateRecord(&Folder));

exit:
    // Cleanup
    m_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::CopyMessages
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::CopyMessages(IMessageFolder *pDest, 
    COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, 
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     InfoSrc={0};
    MESSAGEINFO     InfoDst;
    DWORD           i;
    FOLDERID        idDstFolder=FOLDERID_INVALID;
    HLOCK           hSrcLock=NULL;
    HLOCK           hDstLock=NULL;

    // Trace
    TraceCall("CMessageFolder::CopyMessages");

    // Invalid Args
    if (NULL == pDest)
        return TraceResult(E_INVALIDARG);

    // Get Destination Folder Id
    IF_FAILEXIT(hr = pDest->GetFolderId(&idDstFolder));

    // Same ?
    if (ISFLAGSET(dwOptions, COPY_MESSAGE_MOVE) && m_idFolder == idDstFolder)
        return(S_OK);

    // Lock current folder
    IF_FAILEXIT(hr = Lock(&hSrcLock));

    // Lock the Dest
    IF_FAILEXIT(hr = pDest->Lock(&hDstLock));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            InfoSrc.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &InfoSrc, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&InfoSrc, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Initialize the InfoDst
            CopyMemory(&InfoDst, &InfoSrc, sizeof(MESSAGEINFO));

            // Kill some fields
            InfoDst.idMessage = 0;

            // Don't Copy the UIDL...
            if (FALSE == ISFLAGSET(dwOptions, COPY_MESSAGE_MOVE))
            {
                // Clear It Out
                InfoDst.pszUidl = NULL;
            }

            // Clear a flag
            FLAGCLEAR(InfoDst.dwFlags, ARF_ENDANGERED);

            // Copy Source Stream
            if (InfoSrc.faStream)
            {
                // Copy the Stream
                IF_FAILEXIT(hr = m_pDB->CopyStream(pDest, InfoSrc.faStream, &InfoDst.faStream));
            }

            // Adjust Flags
            if (pFlags)
            {
                // Remove the Flags
                FLAGCLEAR(InfoDst.dwFlags, pFlags->dwRemove);

                // Flags to Add
                FLAGSET(InfoDst.dwFlags, pFlags->dwAdd);
            }

            // Generate a Message Id
            IF_FAILEXIT(hr = pDest->GenerateId((LPDWORD)&InfoDst.idMessage));

            // Insert the Record
            IF_FAILEXIT(hr = pDest->InsertRecord(&InfoDst));

            // Cleanup
            m_pDB->FreeRecord(&InfoSrc);
        }
    }

    // Delete the Original Array of messages ?
    if (ISFLAGSET(dwOptions, COPY_MESSAGE_MOVE))
    {
        // DeleteMessages
        IF_FAILEXIT(hr = DeleteMessages(DELETE_MESSAGE_NOUIDLUPDATE | DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, pList, pResults, pCallback));
    }

exit:
    // Unlock
    Unlock(&hSrcLock);
    pDest->Unlock(&hDstLock);

    // Cleanup
    m_pDB->CloseRowset(&hRowset);
    m_pDB->FreeRecord(&InfoSrc);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::DeleteMessages
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::DeleteMessages(DELETEMESSAGEFLAGS dwOptions, 
    LPMESSAGEIDLIST pList, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrCancel;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};
    DWORD           cTotal;
    DWORD           cCurrent=0;
    DWORD           i;
    FOLDERID        idServer;
    FOLDERID        idDeletedItems;
    HLOCK           hLock=NULL;
    HWND            hwndParent;
    BOOL            fOnBegin=FALSE;
    IDatabase      *pUidlDB=NULL;
    IMessageFolder *pDeleted=NULL;

    // Trace
    TraceCall("CMessageFolder::DeleteMessages");

    // I can't Undelete
    AssertSz(0 == (dwOptions & DELETE_MESSAGE_UNDELETE), "This flag only makes sense for IMAP!");

    // Am I in the Trash Can ?
    if (!ISFLAGSET(dwOptions, DELETE_MESSAGE_NOTRASHCAN))
    {
        // Not in the deleted items folder
        if (S_FALSE == IsParentDeletedItems(m_idFolder, &idDeletedItems, &idServer))
        {
            // Get the Deleted Items Folder
            IF_FAILEXIT(hr = m_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_DELETED, &pDeleted));

            // Simply move messages to the deleted items
            IF_FAILEXIT(hr = CopyMessages(pDeleted, COPY_MESSAGE_MOVE, pList, NULL, pResults, pCallback));

            // Done
            goto exit;
        }

        // Otherwise, do deleted items
        else
        {
            // Prompt...
            if (FALSE == ISFLAGSET(dwOptions, DELETE_MESSAGE_NOPROMPT))
            {
                // Get a Parent Hwnd
                Assert(pCallback);

                // Get Parent Window
                if (FAILED(pCallback->GetParentWindow(0, &hwndParent)))
                    hwndParent = NULL;

                // Prompt...
                if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsWarnPermDelete), NULL, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ))
                    goto exit;
            }
        }
    }
    else if (!ISFLAGSET(dwOptions, DELETE_MESSAGE_NOPROMPT))
    {
        // Get a Parent Hwnd
        Assert(pCallback);

        // Get Parent Window
        if (FAILED(pCallback->GetParentWindow(0, &hwndParent)))
            hwndParent = NULL;

        // Prompt...
        if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsWarnPermDelete), NULL, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ))
            goto exit;
    }

    // If deleting messages from local folder, update the uidl cache.
    if (FOLDER_LOCAL == m_tyFolder && !ISFLAGSET(dwOptions, DELETE_MESSAGE_NOUIDLUPDATE))
    {
        // Open the UIDL Cache
        IF_FAILEXIT(hr = OpenUidlCache(&pUidlDB));
    }

    // No Cancel
    FLAGCLEAR(m_dwState, FOLDER_STATE_CANCEL);

    // Lock Notifications
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

        // Get Count
        IF_FAILEXIT(hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cTotal));
    }

    // Otherwise, set cTotal
    else
        cTotal = pList->cMsgs;

    // User Wants Results ?
    if (pResults)
    {
        // Zero Init
        ZeroMemory(pResults, sizeof(RESULTLIST));

        // Return Results
        IF_NULLEXIT(pResults->prgResult = (LPRESULTINFO)ZeroAllocate(cTotal * sizeof(RESULTINFO)));

        // Set cAllocated
        pResults->cAllocated = pResults->cMsgs = cTotal;
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            Message.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Delete the message
            IF_FAILEXIT(hr = DeleteMessageFromStore(&Message, m_pDB, pUidlDB));

            // Free
            m_pDB->FreeRecord(&Message);

            // Return Result
            if (pResults)
            {
                // hrResult
                pResults->prgResult[i].hrResult = S_OK;

                // Message Id
                pResults->prgResult[i].idMessage = Message.idMessage;

                // Store Falgs
                pResults->prgResult[i].dwFlags = Message.dwFlags;
            
                // Increment Success
                pResults->cValid++;
            }
        }

        // Otherwise, if pResults
        else if (pResults)
        {
            // Set hr
            pResults->prgResult[i].hrResult = hr;

            // Increment Success
            pResults->cValid++;
        }

        // Increment Progress
        cCurrent++;

        // Update Progress
        if (pCallback)
        {
            // Do some progress
            hrCancel = pCallback->OnProgress(SOT_DELETING_MESSAGES, cCurrent, cTotal, NULL);
            if (FAILED(hrCancel) && E_NOTIMPL != hrCancel)
                break;

            // Cancelled ?
            if (ISFLAGSET(m_dwState, FOLDER_STATE_CANCEL))
                break;
        }
    }

exit:
    // Deleted All ?
    if (NULL == pList)
    {
        // Get Count
        if (SUCCEEDED(m_pDB->GetRecordCount(IINDEX_PRIMARY, &cTotal)) && 0 == cTotal)
        {
            // Reset The Counts
            ResetFolderCounts(0, 0, 0, 0);
        }
    }

    // Lock Notifications
    m_pDB->Unlock(&hLock);

    // Cleanup
    SafeRelease(pDeleted);
    SafeRelease(pUidlDB);
    m_pDB->CloseRowset(&hRowset);
    m_pDB->FreeRecord(&Message);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageFolder::_FixupMessageCharset
// --------------------------------------------------------------------------------
HRESULT CMessageFolder::_FixupMessageCharset(IMimeMessage *pMessage, 
    CODEPAGEID cpCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    HCHARSET        hCharset;
    INETCSETINFO    CsetInfo;
    DWORD           dwCodePage=0;
    DWORD           dwFlags;

    // Trace
    TraceCall("CMessageFolder::_FixupMessageCharset");

    // Invalid Args
    Assert(pMessage);

    // See if we need to apply charset re-mapping
    if (cpCurrent == 0)
    {
        HCHARSET hChar = NULL;
        
        // Get Flags
        IF_FAILEXIT(hr = pMessage->GetFlags(&dwFlags));

        if(DwGetOption(OPT_INCOMDEFENCODE))
        {
            if (SUCCEEDED(HGetDefaultCharset(&hChar)))
                pMessage->SetCharset(hChar, CSET_APPLY_ALL);
            else
                cpCurrent = GetACP();
        }
        // for tagged message or news only
        else if (ISFLAGSET(dwFlags, IMF_CSETTAGGED))
        {
            // Get the Character SEt
            IF_FAILEXIT(hr= pMessage->GetCharset(&hCharset));

            // Remap the Character Set
            if (hCharset && CheckIntlCharsetMap(hCharset, &dwCodePage))
                cpCurrent = dwCodePage;
        }
        // Check AutoSelect
        else if(CheckAutoSelect((UINT *) &dwCodePage))
            cpCurrent = dwCodePage;

        // The message is not tagged, use the default character set
        else if (SUCCEEDED(HGetDefaultCharset(&hChar)))
        {
            // Change the Character set of the message to default
            pMessage->SetCharset(hChar, CSET_APPLY_ALL);
        }
    }

    // If cpCurrent is set, call SetCharset to change charset
    if (cpCurrent)
    {
        // Get the character set fromt he codepage
        hCharset = GetMimeCharsetFromCodePage(cpCurrent);

        // Modify the Character set of the message
        if (hCharset)
        {
            // SetCharset
            IF_FAILEXIT(hr = pMessage->SetCharset(hCharset, CSET_APPLY_ALL));
        }
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageFolder::_GetMsgInfoFromMessage
// --------------------------------------------------------------------------------
HRESULT CMessageFolder::_GetMsgInfoFromMessage(IMimeMessage *pMessage,
    LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwImf;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    SYSTEMTIME          st;
    FILETIME            ftCurrent;
    IMimePropertySet   *pPropertySet=NULL;

    // Trace
    TraceCall("CMessageFolder::_GetMsgInfoFromMessage");

    // Invalid Args
    Assert(pMessage && pInfo);

    // Get the Root Property Set from the Message
    IF_FAILEXIT(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropertySet));

    // File pInfo from pPropertySet
    IF_FAILEXIT(hr = _GetMsgInfoFromPropertySet(pPropertySet, pInfo));

    // Get Message Flags
    if (SUCCEEDED(pMessage->GetFlags(&dwImf)))
        pInfo->dwFlags = ConvertIMFFlagsToARF(dwImf);

    // Get the Message Size
    pMessage->GetMessageSize(&pInfo->cbMessage, 0);

exit:
    // Cleanup
    SafeRelease(pPropertySet);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder:_GetMsgInfoFromPropertySet
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_GetMsgInfoFromPropertySet(IMimePropertySet *pPropertySet,
    LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    FILETIME            ftCurrent;
    IMimeAddressTable  *pAdrTable=NULL;
    ADDRESSPROPS        rAddress;

    // Trace
    TraceCall("CMessageFolder::_GetMsgInfoFromPropertySet");

    // Invalid Args
    Assert(pPropertySet && pInfo);

    // Default Sent and Received Times...
    GetSystemTimeAsFileTime(&ftCurrent);

    // Set Variant tyStore
    Variant.vt = VT_UI4;

    // Priority
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &Variant)))
    {
        // Set Priority
        pInfo->wPriority = (WORD)Variant.ulVal;
    }

    // Partial Numbers...
    if (pPropertySet->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK)
    {
        // Locals
        WORD cParts=0, iPart=0;

        // Get Total
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_TOTAL, NOFLAGS, &Variant)))
            cParts = (WORD)Variant.ulVal;

        // Get Number
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_NUMBER, NOFLAGS, &Variant)))
            iPart = (WORD)Variant.ulVal;

        // Set Parts
        pInfo->dwPartial = MAKELONG(cParts, iPart);
    }

    // Otherwise, check for user property
    else if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_COMBINED), NOFLAGS, &Variant)))
    {
        // Set the Partial Id
        pInfo->dwPartial = Variant.ulVal;
    }

    // Getting some file times
    Variant.vt = VT_FILETIME;

    // Get Received Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &Variant)))
        pInfo->ftReceived = Variant.filetime;
    else
        pInfo->ftReceived = ftCurrent;

    // Get Sent Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &Variant)))
        pInfo->ftSent = Variant.filetime;
    else
        pInfo->ftSent = ftCurrent;

    // Get Address Table
    IF_FAILEXIT(hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAdrTable));

    // Display From
    pAdrTable->GetFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &pInfo->pszDisplayFrom);

    // Email From
    rAddress.dwProps = IAP_EMAIL;
    if (SUCCEEDED(pAdrTable->GetSender(&rAddress)))
    {
        pInfo->pszEmailFrom = rAddress.pszEmail;
    }

    // Display to
    pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &pInfo->pszDisplayTo);

    // Email To
    pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_EMAIL, &pInfo->pszEmailTo);

    // String Properties
    Variant.vt = VT_LPSTR;

    // pszDisplayFrom as newsgroups
    if (NULL == pInfo->pszDisplayTo && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &Variant)))
        pInfo->pszDisplayTo = Variant.pszVal;

    // pszMessageId
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &Variant)))
        pInfo->pszMessageId = Variant.pszVal;

    // pszMSOESRec
    if (SUCCEEDED(pPropertySet->GetProp(STR_HDR_XMSOESREC, NOFLAGS, &Variant)))
        pInfo->pszMSOESRec = Variant.pszVal;

    // pszXref
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_XREF), NOFLAGS, &Variant)))
        pInfo->pszXref = Variant.pszVal;

    // pszReferences
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(STR_HDR_REFS), NOFLAGS, &Variant)))
        pInfo->pszReferences = Variant.pszVal;

    // pszSubject
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &Variant)))
        pInfo->pszSubject = Variant.pszVal;

    // pszNormalSubj
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &Variant)))
        pInfo->pszNormalSubj = Variant.pszVal;

    // pszAcctId
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &Variant)))
        pInfo->pszAcctId = Variant.pszVal;

    // pszAcctName
    if (SUCCEEDED(pPropertySet->GetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &Variant)))
        pInfo->pszAcctName = Variant.pszVal;

    // pszServer
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &Variant)))
        pInfo->pszServer = Variant.pszVal;

    // pszUidl
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_UIDL), NOFLAGS, &Variant)))
        pInfo->pszUidl = Variant.pszVal;

    // pszPartialId
    if (pInfo->dwPartial != 0 && SUCCEEDED(pPropertySet->GetProp(STR_PAR_ID, NOFLAGS, &Variant)))
        pInfo->pszPartialId = Variant.pszVal;

    // ForwardTo
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_FORWARDTO), NOFLAGS, &Variant)))
        pInfo->pszForwardTo = Variant.pszVal;

exit:
    // Cleanup
    SafeRelease(pAdrTable);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::_FreeMsgInfoData
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_FreeMsgInfoData(LPMESSAGEINFO pInfo)
{
    // Trace
    TraceCall("CMessageFolder::_FreeMsgInfoData");

    // Invalid Args
    Assert(pInfo && NULL == pInfo->pAllocated);

    // Free all the items
    g_pMalloc->Free(pInfo->pszMessageId);
    g_pMalloc->Free(pInfo->pszSubject);
    g_pMalloc->Free(pInfo->pszNormalSubj);
    g_pMalloc->Free(pInfo->pszFromHeader);
    g_pMalloc->Free(pInfo->pszReferences);
    g_pMalloc->Free(pInfo->pszXref);
    g_pMalloc->Free(pInfo->pszServer);
    g_pMalloc->Free(pInfo->pszDisplayFrom);
    g_pMalloc->Free(pInfo->pszEmailFrom);
    g_pMalloc->Free(pInfo->pszDisplayTo);
    g_pMalloc->Free(pInfo->pszEmailTo);
    g_pMalloc->Free(pInfo->pszUidl);
    g_pMalloc->Free(pInfo->pszPartialId);
    g_pMalloc->Free(pInfo->pszForwardTo);
    g_pMalloc->Free(pInfo->pszAcctId);
    g_pMalloc->Free(pInfo->pszAcctName);
    g_pMalloc->Free(pInfo->Offsets.pBlobData);
    g_pMalloc->Free(pInfo->pszMSOESRec);

    // Zero It
    ZeroMemory(pInfo, sizeof(MESSAGEINFO));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::_SetMessageStream
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_SetMessageStream(LPMESSAGEINFO pInfo, 
    BOOL fUpdateRecord, IStream *pStmSrc)
{
    // Locals
    HRESULT               hr=S_OK;
    FILEADDRESS           faStream=0;
    FILEADDRESS           faOldStream=0;
    IStream              *pStmDst=NULL;
    IDatabaseStream      *pDBStream=NULL;

    // Trace
    TraceCall("CMessageFolder::_SetMessageStream");

    // Invalid Args
    Assert(pInfo && pStmSrc);

    // Raid 38276: message moves after being downloaded (don't reset the size if its already set)
    if (0 == pInfo->cbMessage)
    {
        // Get the size of the stream
        IF_FAILEXIT(hr = HrGetStreamSize(pStmSrc, &pInfo->cbMessage));
    }

    // Rewind the source stream
    IF_FAILEXIT(hr = HrRewindStream(pStmSrc));

    // Determine if this is an ObjectDB Stream
    if (SUCCEEDED(pStmSrc->QueryInterface(IID_IDatabaseStream, (LPVOID *)&pDBStream)) && S_OK == pDBStream->CompareDatabase(m_pDB))
    {
        // Get the Stream Id
        pDBStream->GetFileAddress(&faStream);
    }

    // Otherwise, create a stream
    else
    {
        // Create a stream
        IF_FAILEXIT(hr = m_pDB->CreateStream(&faStream));

        // Open the Stream
        IF_FAILEXIT(hr = m_pDB->OpenStream(ACCESS_WRITE, faStream, &pStmDst));

        // Copy the Stream
        IF_FAILEXIT(hr = HrCopyStream(pStmSrc, pStmDst, NULL));

        // Commit
        IF_FAILEXIT(hr = pStmDst->Commit(STGC_DEFAULT));
    }

    // Save the Address of the Old Message Stream Attached to this message
    faOldStream = pInfo->faStream;

    // Update the Message Information
    pInfo->faStream = faStream;

    // Get the time in which the article was downloaded
    GetSystemTimeAsFileTime(&pInfo->ftDownloaded);

    // Has a Body
    FLAGSET(pInfo->dwFlags, ARF_HASBODY);

    // Update the Record ?
    if (fUpdateRecord)
    {
        // Save the new Record
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(pInfo));
    }

    // Don't Free faStream
    faStream = 0;

exit:
    // If pInfo already has a message sstream,
    if (faOldStream)
    {
        // Free this stream
        SideAssert(SUCCEEDED(m_pDB->DeleteStream(faOldStream)));
    }

    // Failure
    if (faStream)
    {
        // Free this stream
        SideAssert(SUCCEEDED(m_pDB->DeleteStream(faStream)));
    }

    // Cleanup
    SafeRelease(pDBStream);
    SafeRelease(pStmDst);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CMessageFolder::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::Initialize(IDatabase *pDB)
{
    // Trace
    TraceCall("CMessageFolder::Initialize");

    // Assume the Database from here ?
    if (NULL == m_pDB)
    {
        // Save Database
        m_pDB = pDB;
    }

    // Only if there is a global store...
    if (NULL == m_pStore && g_pStore)
    {
        // Locals
        FOLDERINFO      Folder;
        FOLDERUSERDATA  UserData;

        // Get the user data
        m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA));

        // Get Folder Info
        if (UserData.fInitialized && SUCCEEDED(g_pStore->GetFolderInfo(UserData.idFolder, &Folder)))
        {
            // AddRef g_pStore
            m_pStore = g_pStore;

            // AddRef it
            m_pStore->AddRef();

            // Save My Folder Id
            m_idFolder = Folder.idFolder;

            // Save m_tyFolder
            m_tyFolder = Folder.tyFolder;

            // Save m_tySpecial
            m_tySpecial = Folder.tySpecial;

            // Free Folder
            g_pStore->FreeRecord(&Folder);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnLock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnLock(void)
{
    // Trace
    TraceCall("CMessageFolder::OnLock");

    // Validate
    Assert(0 == m_OnLock.cLocked ? (0 == m_OnLock.lMsgs && 0 == m_OnLock.lUnread && 0 == m_OnLock.lWatchedUnread) : TRUE);

    // Increment cLock
    m_OnLock.cLocked++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnUnlock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnUnlock(void)
{
    // Trace
    TraceCall("CMessageFolder::OnUnlock");

    // Increment cLock
    m_OnLock.cLocked--;

    // If zero, then lets flush counts...
    if (0 == m_OnLock.cLocked)
    {
        // Do we have a folder ?
        if (FOLDERID_INVALID != m_idFolder && m_pStore)
        {
            // Update Folder Counts
            m_pStore->UpdateFolderCounts(m_idFolder, m_OnLock.lMsgs, m_OnLock.lUnread, m_OnLock.lWatchedUnread, m_OnLock.lWatched);
        }

        // Zero OnLock
        ZeroMemory(&m_OnLock, sizeof(ONLOCKINFO));
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnInsertRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnRecordInsert(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Locals
    HRESULT         hr;
    MESSAGEFLAGS    dwFlags;
    LPMESSAGEINFO   pMessage=(LPMESSAGEINFO)pRecord;

    // Trace
    TraceCall("CMessageFolder::OnInsertRecord");

    // Validate
    Assert(pRecord && m_OnLock.cLocked > 0);

    // Before
    if (OPERATION_BEFORE == tyState)
    {
        // If not Watched and Not ignored...
        if (!ISFLAGSET(pMessage->dwFlags, ARF_WATCH) && !ISFLAGSET(pMessage->dwFlags, ARF_IGNORE))
        {
            // Get Flags
            if (DB_S_FOUND == _GetWatchIgnoreParentFlags(pMessage->pszReferences, pMessage->pszNormalSubj, &dwFlags))
            {
                // Set Watched
                if (ISFLAGSET(dwFlags, ARF_WATCH))
                    FLAGSET(pMessage->dwFlags, ARF_WATCH);
                else if (ISFLAGSET(dwFlags, ARF_IGNORE))
                    FLAGSET(pMessage->dwFlags, ARF_IGNORE);
            }
        }
    }

    // After
    else if (OPERATION_AFTER == tyState)
    {
        // One more message...
        m_OnLock.lMsgs++;

        // Watched
        if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
            m_OnLock.lWatched++;

        // On more unread...
        if (FALSE == ISFLAGSET(pMessage->dwFlags, ARF_READ))
        {
            // Total Unread
            m_OnLock.lUnread++;

            // Watched ?
            if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
                m_OnLock.lWatchedUnread++;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnUpdateRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnRecordUpdate(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lUnread=0;
    ROWORDINAL      iOrdinal1;
    ROWORDINAL      iOrdinal2;
    LPMESSAGEINFO   pMsgOld = (LPMESSAGEINFO)pRecordOld;
    LPMESSAGEINFO   pMsgNew = (LPMESSAGEINFO)pRecordNew;

    // Trace
    TraceCall("CMessageFolder::OnRecordUpdate");

    // Validate
    Assert(pRecordOld && pRecordNew && m_OnLock.cLocked > 0);

    // After
    if (OPERATION_AFTER == tyState)
    {
        // One less Unread Message
        if (!ISFLAGSET(pMsgOld->dwFlags, ARF_READ) && ISFLAGSET(pMsgNew->dwFlags, ARF_READ))
            lUnread = -1;

        // Otherwise...new unread
        else if (ISFLAGSET(pMsgOld->dwFlags, ARF_READ) && !ISFLAGSET(pMsgNew->dwFlags, ARF_READ))
            lUnread = 1;

        // Update m_OnLock
        m_OnLock.lUnread += lUnread;

        // Old was Watched new is not watched
        if (ISFLAGSET(pMsgOld->dwFlags, ARF_WATCH) && !ISFLAGSET(pMsgNew->dwFlags, ARF_WATCH))
        {
            // Total Watched
            m_OnLock.lWatched--;

            // Unread
            if (!ISFLAGSET(pMsgOld->dwFlags, ARF_READ))
                m_OnLock.lWatchedUnread--;
        }

        // Otherwise, Old was not watched and new message is watched
        else if (!ISFLAGSET(pMsgOld->dwFlags, ARF_WATCH) && ISFLAGSET(pMsgNew->dwFlags, ARF_WATCH))
        {
            // Total Watched
            m_OnLock.lWatched++;

            // Unread
            if (!ISFLAGSET(pMsgNew->dwFlags, ARF_READ))
                m_OnLock.lWatchedUnread++;
        }

        // Otherwise, old was watched, new is watched, then just adjust the unread count
        else if (ISFLAGSET(pMsgOld->dwFlags, ARF_WATCH) && ISFLAGSET(pMsgNew->dwFlags, ARF_WATCH))
            m_OnLock.lWatchedUnread += lUnread;
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnDeleteRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnRecordDelete(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Locals
    LPMESSAGEINFO   pMessage=(LPMESSAGEINFO)pRecord;

    // Trace
    TraceCall("CMessageFolder::OnDeleteRecord");

    // Validate
    Assert(pRecord && m_OnLock.cLocked > 0);

    // After
    if (OPERATION_AFTER == tyState)
    {
        // One less message
        m_OnLock.lMsgs--;

        // Watched
        if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
            m_OnLock.lWatched--;

        // Read State Change
        if (FALSE == ISFLAGSET(pMessage->dwFlags, ARF_READ))
        {
            // Total Unread
            m_OnLock.lUnread--;

            // Watched
            if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
                m_OnLock.lWatchedUnread--;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnExecuteMethod
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnExecuteMethod(METHODID idMethod, LPVOID pBinding, 
    LPDWORD pdwResult)
{
    // Locals
    FILETIME        ftCurrent;
    LPMESSAGEINFO   pMessage=(LPMESSAGEINFO)pBinding;

    // Validate
    Assert(METHODID_MESSAGEAGEINDAYS == idMethod);

    // Get system time as filetime
    GetSystemTimeAsFileTime(&ftCurrent);

    // Convert st to seconds since Jan 1, 1996
    *pdwResult = (UlDateDiff(&pMessage->ftSent, &ftCurrent) / SECONDS_INA_DAY);

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\msgtable.cpp ===
//--------------------------------------------------------------------------
// MsgTable.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "msgtable.h"
#include "findfold.h"
#include "storutil.h"
#include "ruleutil.h"
#include "newsutil.h"
#include "xpcomm.h"

//--------------------------------------------------------------------------
// CGROWTABLE
//--------------------------------------------------------------------------
#define CGROWTABLE              256
#define INVALID_ROWINDEX        0xffffffff
#define ROWSET_FETCH            100

//--------------------------------------------------------------------------
// GETTHREADSTATE
//--------------------------------------------------------------------------
typedef struct tagGETTHREADSTATE {
    MESSAGEFLAGS            dwFlags;
    DWORD                   cHasFlags;
    DWORD                   cChildren;
} GETTHREADSTATE, *LPGETTHREADSTATE;

//--------------------------------------------------------------------------
// THREADISFROMME
//--------------------------------------------------------------------------
typedef struct tagTHREADISFROMME {
    BOOL                    fResult;
    LPROWINFO               pRow;
} THREADISFROMME, *LPTHREADISFROMME;

//--------------------------------------------------------------------------
// THREADHIDE
//--------------------------------------------------------------------------
typedef struct tagTHREADHIDE {
    BOOL                    fNotify;
} THREADHIDE, *LPTHREADHIDE;

//--------------------------------------------------------------------------
// GETSELECTIONSTATE
//--------------------------------------------------------------------------
typedef struct tagGETSELECTIONSTATE {
    SELECTIONSTATE          dwMask;
    SELECTIONSTATE          dwState;
} GETSELECTIONSTATE, *LPGETSELECTIONSTATE;

//--------------------------------------------------------------------------
// GETTHREADPARENT
//--------------------------------------------------------------------------
typedef struct tagGETTHREADPARENT {
    IDatabase       *pDatabase;
    IHashTable      *pHash;
    LPVOID           pvResult;
} GETTHREADPARENT, *LPGETTHREADPARENT;

//--------------------------------------------------------------------------
// IsInitialized
//--------------------------------------------------------------------------
#define IsInitialized(_pThis) \
    (_pThis->m_pFolder && _pThis->m_pDB)

//--------------------------------------------------------------------------
// EnumRefsGetThreadParent
//--------------------------------------------------------------------------
HRESULT EnumRefsGetThreadParent(LPCSTR pszMessageId, DWORD_PTR dwCookie,
    BOOL *pfDone)
{
    // Locals
    LPGETTHREADPARENT pGetParent = (LPGETTHREADPARENT)dwCookie;

    // Trace
    TraceCall("EnumRefsGetThreadParent");

    // Find Message Id
    if (SUCCEEDED(pGetParent->pHash->Find((LPSTR)pszMessageId, FALSE, &pGetParent->pvResult)))
    {
        // Ok
        *pfDone = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::CMessageTable
//--------------------------------------------------------------------------
CMessageTable::CMessageTable(void)
{
    TraceCall("CMessageTable::CMessageTable");
    m_cRef = 1;
    m_fSynching = FALSE;
    m_pFolder = NULL;
    m_pDB = NULL;
    m_cRows = 0;
    m_cView = 0;
    m_cFiltered = 0;
    m_cUnread = 0;
    m_cAllocated = 0;
    m_prgpRow = NULL;
    m_prgpView = NULL;
    m_pFindFolder = NULL;
    m_pNotify = NULL;
    m_fRelNotify = FALSE;
    m_pThreadMsgId = NULL;
    m_pThreadSubject = NULL;
    m_pQuery = NULL;
    m_cDelayed = 0;
    m_fRegistered = FALSE;
    m_clrWatched = 0;
    m_pszEmail = NULL;
    m_fLoaded = FALSE;
    ZeroMemory(&m_SortInfo, sizeof(FOLDERSORTINFO));
    ZeroMemory(&m_Notify, sizeof(NOTIFYQUEUE));
    ZeroMemory(&m_Folder, sizeof(FOLDERINFO));
    m_Notify.iRowMin = 0xffffffff;
    m_Notify.fClean = TRUE;
}

//--------------------------------------------------------------------------
// CMessageTable::~CMessageTable - Don't put any Asserts in this function
//--------------------------------------------------------------------------
CMessageTable::~CMessageTable()
{
    // Trace
    TraceCall("CMessageTable::~CMessageTable");

    // Free Folder Info
    g_pStore->FreeRecord(&m_Folder);

    // Free Cached Rows
    _FreeTable();

    // Release the Folder
    SafeRelease(m_pFolder);

    // Release Query Object...
    SafeRelease(m_pQuery);

    // Release DB after folder, because releasing folder can cause call chain: ~CFolderSync->~CServerQ->
    // CMessageList::OnComplete->CMessageTable::GetCount, for which we need a m_pDB.
    if (m_pDB)
    {
        // Unregister
        m_pDB->UnregisterNotify((IDatabaseNotify *)this);

        // Release the Folder
        m_pDB->Release();

        // Null
        m_pDB = NULL;
    }

    // Release the Find Folder
    SafeRelease(m_pFindFolder);

    // Set pCurrent
    if (m_pNotify)
    {
        if (m_fRelNotify)
            m_pNotify->Release();
        m_pNotify = NULL;
    }

    // Free m_pszEmail
    SafeMemFree(m_pszEmail);

    // Free the Notification Queue
    SafeMemFree(m_Notify.prgiRow);
}

//--------------------------------------------------------------------------
// CMessageTable::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageTable::AddRef(void)
{
    TraceCall("CMessageTable::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CMessageTable::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageTable::Release(void)
{
    TraceCall("CMessageTable::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CMessageTable::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CMessageTable::QueryInterface");

    // Invalid Arg
    Assert(ppv);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageTable *)this;
    else if (IID_IMessageTable == riid)
        *ppv = (IMessageTable *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_FIsHidden
//--------------------------------------------------------------------------
BOOL CMessageTable::_FIsHidden(LPROWINFO pRow)
{
    // Trace
    TraceCall("CMessageTable::_FIsHidden");

    // Hide Deleted ?
    if (FALSE == m_SortInfo.fShowDeleted && ISFLAGSET(pRow->Message.dwFlags, ARF_ENDANGERED))
        return(TRUE);

    // Hide Offline Deleted ?
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_DELETED_OFFLINE))
        return(TRUE);

    // Not Hidden
    return(FALSE);
}

//--------------------------------------------------------------------------
// CMessageTable::_FIsFiltered
//--------------------------------------------------------------------------
BOOL CMessageTable::_FIsFiltered(LPROWINFO pRow)
{
    // Trace
    TraceCall("CMessageTable::_FIsFiltered");

    // No Query Object
    if (NULL == m_pQuery)
        return(FALSE);

    // No m_pQuery
    return(S_OK == m_pQuery->Evaluate(&pRow->Message) ? FALSE : TRUE);
}

//--------------------------------------------------------------------------
// CMessageTable::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Initialize(FOLDERID idFolder, IMessageServer *pServer,
    BOOL fFindTable, IStoreCallback *pCallback)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CMessageTable::Initialize");

    // Already Open ?
    if (m_pFolder)
    {
        hr = TraceResult(E_UNEXPECTED);
        goto exit;
    }

    // Search Folder ?
    if (fFindTable)
    {
        // Create a Find Folder
        IF_NULLEXIT(m_pFindFolder = new CFindFolder);

        // Initialize
        IF_FAILEXIT(hr = m_pFindFolder->Initialize(g_pStore, NULL, NOFLAGS, idFolder));

        // Get an IMessageFolder
        IF_FAILEXIT(hr = m_pFindFolder->QueryInterface(IID_IMessageFolder, (LPVOID *)&m_pFolder));
    }

    // Otherwise
    else
    {
        // Are there children
        IF_FAILEXIT(hr = g_pStore->OpenFolder(idFolder, pServer, NOFLAGS, &m_pFolder));
    }

    // Get the folder id, it might have changed if this is a find folder
    IF_FAILEXIT(hr = m_pFolder->GetFolderId(&idFolder));

    // Get Folder Info
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &m_Folder));

    // Get the Database
    IF_FAILEXIT(hr = m_pFolder->GetDatabase(&m_pDB));

    // Set m_clrWatched
    m_clrWatched = (WORD)DwGetOption(OPT_WATCHED_COLOR);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::StartFind
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CMessageTable::StartFind");

    // Validate State
    if (!IsInitialized(this) || NULL == m_pFindFolder)
        return(TraceResult(E_UNEXPECTED));

    // Initialize the Find Folder
    IF_FAILEXIT(hr = m_pFindFolder->StartFind(pCriteria, pCallback));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetSortChangeInfo
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetSortChangeInfo(LPFOLDERSORTINFO pSortInfo,
    LPFOLDERUSERDATA pUserData, LPSORTCHANGEINFO pChange)
{
    // Locals
    HRESULT     hr;
    DWORD       dwVersion;

    // Trace
    TraceCall("CMessageTable::_GetSortChangeInfo");

    // INitialize
    ZeroMemory(pChange, sizeof(SORTCHANGEINFO));

    // Invalid ?
    if (pSortInfo->ridFilter == RULEID_INVALID)
    {
        // Reset
        pSortInfo->ridFilter = RULEID_VIEW_ALL;
    }

    // Get the filter version
    hr = RuleUtil_HrGetFilterVersion(pSortInfo->ridFilter, &dwVersion);

    // Bummer, that failed, so lets revert back to the default filter
    if (FAILED(hr))
    {
        // View All filter
        pSortInfo->ridFilter = RULEID_VIEW_ALL;

        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Ohterwise, If this is a different filter
    else if (pUserData->ridFilter != pSortInfo->ridFilter)
    {
        // Reset Version
        pUserData->dwFilterVersion = dwVersion;

        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Otherwise, did the version of this filter change
    else if (pUserData->dwFilterVersion != dwVersion)
    {
        // Reset Version
        pUserData->dwFilterVersion = dwVersion;

        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Other filtering changes
    if (pSortInfo->fShowDeleted != (BOOL)pUserData->fShowDeleted || pSortInfo->fShowReplies != (BOOL)pUserData->fShowReplies)
    {
        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Sort Order Change
    if (pSortInfo->idColumn != (COLUMN_ID)pUserData->idSort || pSortInfo->fAscending != (BOOL)pUserData->fAscending)
    {
        // Sort Changed
        pChange->fSort = TRUE;
    }

    // Thread Change...
    if (pSortInfo->fThreaded != (BOOL)pUserData->fThreaded)
    {
        // Thread Change
        pChange->fThread = TRUE;
    }

    // Expand Change
    if (pSortInfo->fExpandAll != (BOOL)pUserData->fExpandAll)
    {
        // Expand Change
        pChange->fExpand = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::OnSynchronizeComplete
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::OnSynchronizeComplete(void)
{
    // Locals
    DWORD           i;
    SORTCHANGEINFO  Change={0};

    // Trace
    TraceCall("CMessageTable::OnSynchronizeComplete");

    // If Not New...
    if (FOLDER_NEWS != m_Folder.tyFolder)
        goto exit;

    // Finish any insert notifications
    m_pDB->DispatchNotify(this);

    // Nothing to do...
    if (0 == m_cDelayed)
        goto exit;

    // Reset m_cDelayed
    m_cDelayed = 0;

    // ChangeSortOrThreading
    _SortThreadFilterTable(&Change, m_SortInfo.fShowReplies);

    // Remove fDelayed Bit...
    for (i = 0; i < m_cRows; i++)
    {
        // Remove Delayed Bit
        m_prgpRow[i]->fDelayed = FALSE;
    }

exit:
    // Reset m_fSynching
    m_fSynching = FALSE;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::SetSortInfo
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::SetSortInfo(LPFOLDERSORTINFO pSortInfo,
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HCURSOR         hCursor=NULL;
    HLOCK           hLock=NULL;
    FOLDERUSERDATA  UserData;
    SORTCHANGEINFO  Change;
    IF_DEBUG(DWORD  dwTickStart=GetTickCount());

    // Trace
    TraceCall("CMessageTable::SetSortInfo");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // If this isn't a news folder then don't allow fShowReplies
    if (FOLDER_NEWS != m_Folder.tyFolder)
    {
        // Clear fShowReplies
        pSortInfo->fShowReplies = FALSE;
    }

    // Lock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Get UserData
    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Get Sort Change Information...
    IF_FAILEXIT(hr = _GetSortChangeInfo(pSortInfo, &UserData, &Change));

    // Save the SortInfo
    CopyMemory(&m_SortInfo, pSortInfo, sizeof(FOLDERSORTINFO));

    // Total Rebuild ?
    if (NULL == m_prgpRow)
    {
        // Build RowTable
        IF_FAILEXIT(hr = _BuildTable(pCallback));
    }

    // Sort or Threading Change Only
    else if (Change.fSort || Change.fThread || Change.fFilter)
    {
        // ChangeSortOrThreading
        _SortThreadFilterTable(&Change, Change.fFilter);
    }

    // Expand State Change
    else if (Change.fExpand && m_SortInfo.fThreaded)
    {
        // Expand All ?
        if (m_SortInfo.fExpandAll)
        {
            // Expand Everything
            _ExpandThread(INVALID_ROWINDEX, FALSE, FALSE);
        }

        // Otherwise, collapse all
        else
        {
            // Collapse Everything
            _CollapseThread(INVALID_ROWINDEX, FALSE);
        }
    }

    // Otherwise, just refresh the filter
    else
    {
        // RefreshFilter
        _RefreshFilter();
    }

    // Save Sort Order
    UserData.fAscending = pSortInfo->fAscending;
    UserData.idSort = pSortInfo->idColumn;
    UserData.fThreaded = pSortInfo->fThreaded;
    UserData.ridFilter = pSortInfo->ridFilter;
    UserData.fExpandAll = pSortInfo->fExpandAll;
    UserData.fShowDeleted = (BYTE) !!(pSortInfo->fShowDeleted);
    UserData.fShowReplies = (BYTE) !!(pSortInfo->fShowReplies);

    // Get UserData
    IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Have I Registered For Notifications Yet ?
    if (FALSE == m_fRegistered)
    {
        // Register for Notifications
        IF_FAILEXIT(hr = m_pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this));

        // Registered
        m_fRegistered = TRUE;
    }

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Reset Cursor
    SetCursor(hCursor);

    // Time to Sort
    TraceInfo(_MSG("Table Sort Time: %d Milli-Seconds", GetTickCount() - dwTickStart));

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetSortInfo
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetSortInfo(LPFOLDERSORTINFO pSortInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERUSERDATA  UserData;

    // Trace
    TraceCall("CMessageTable::GetSortInfo");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    ZeroMemory(pSortInfo, sizeof(FOLDERSORTINFO));

    // Get Sort Information
    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Save Sort Order if not threaded
    pSortInfo->fAscending = UserData.fAscending;

    // Threaded
    pSortInfo->fThreaded = UserData.fThreaded;

    // Save Sort Column
    pSortInfo->idColumn = (COLUMN_ID)UserData.idSort;

    // Expand All
    pSortInfo->fExpandAll = UserData.fExpandAll;

    // Set rid Filter
    pSortInfo->ridFilter = UserData.ridFilter;

    // Set deleted state
    pSortInfo->fShowDeleted = UserData.fShowDeleted;

    // Set replies
    pSortInfo->fShowReplies = UserData.fShowReplies;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetRowFromIndex
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetRowFromIndex(ROWINDEX iRow, LPROWINFO *ppRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::_GetRowFromIndex");

    // Out of View Range ?
    if (iRow >= m_cView)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Bad Row Index
    if (NULL == m_prgpView[iRow])
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Set pRow
    pRow = m_prgpView[iRow];

    // Validate Reserved...
    IxpAssert(pRow->Message.dwReserved == (DWORD_PTR)pRow);

    // Must have pAllocated
    IxpAssert(pRow->Message.pAllocated);

    // Must have References
    IxpAssert(pRow->cRefs > 0);

    // Set pprow
    *ppRow = pRow;

exit:
    // Return the Row
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_CreateRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::_CreateRow(LPMESSAGEINFO pMessage, LPROWINFO *ppRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::_CreateRow");

    // Allocate the Row
    IF_FAILEXIT(hr = m_pDB->HeapAllocate(HEAP_ZERO_MEMORY, sizeof(ROWINFO), (LPVOID *)&pRow));

    // Save the Highlight
    pRow->wHighlight = pMessage->wHighlight;

    // Copy the message
    CopyMemory(&pRow->Message, pMessage, sizeof(MESSAGEINFO));

    // Set pRow into 
    pRow->Message.dwReserved = (DWORD_PTR)pRow;

    // OneRef
    pRow->cRefs = 1;

    // Return the Row
    *ppRow = pRow;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_DeleteRowFromThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_DeleteRowFromThread(LPROWINFO pRow, BOOL fNotify)
{
    // Locals
    LPROWINFO   pCurrent;
    LPROWINFO   pNewRow;
    ROWINDEX    iMin;
    ROWINDEX    iMax;

    // Trace
    TraceCall("CMessageTable::_DeleteRowFromThread");

    // Abort
    if (FALSE == m_SortInfo.fThreaded || pRow->fFiltered || pRow->fHidden)
        return(S_OK);

    // Notify
    if (fNotify)
    {
        // _RefreshThread
        _GetThreadIndexRange(pRow, TRUE, &iMin, &iMax);
    }

    // If there is a messageid
    if (pRow->Message.pszMessageId)
    {
        // Remove pRow from both threading indexes!!!
        if (SUCCEEDED(m_pThreadMsgId->Find(pRow->Message.pszMessageId, TRUE, (LPVOID *)&pCurrent)))
        {
            // If this isn't this row, then put it back...
            if (pRow != pCurrent)
            {
                // Put It Back
                m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pCurrent, HF_NO_DUPLICATES);
            }
        }
    }

    // If there is a normalized subject and a subject hash table
    if (NULL == pRow->pParent && pRow->Message.pszNormalSubj && m_pThreadSubject)
    {
        // Remove pRow from both threading indexes!!!
        if (SUCCEEDED(m_pThreadSubject->Find(pRow->Message.pszNormalSubj, TRUE, (LPVOID *)&pCurrent)))
        {
            // If this isn't this row, then put it back...
            if (pRow != pCurrent)
            {
                // Put It Back
                m_pThreadSubject->Insert(pRow->Message.pszNormalSubj, (LPVOID)pCurrent, HF_NO_DUPLICATES);
            }
        }
    }

    // If we have a Child
    if (pRow->pChild)
    {
        // Set pNewRow
        pNewRow = pRow->pChild;

        // Promote Children of pNewRow to be at the same level as the children of pRow
        if (pNewRow->pChild)
        {
            // Walk until I find the last sibling
            pCurrent = pNewRow->pChild;
            
            // Continue
            while (pCurrent->pSibling)
            {
                // Validate Parent
                Assert(pCurrent->pParent == pNewRow);

                // Goto Next
                pCurrent = pCurrent->pSibling;
            }

            // Make pLastSibling->pSibling
            pCurrent->pSibling = pNewRow->pSibling;
        }

        // Otherwise, Child is the first sibling of pNewRow
        else
        {
            // Set First Child
            pNewRow->pChild = pNewRow->pSibling;
        }

        // Fixup other children of pRow to have a new parent of pNewRow...
        pCurrent = pNewRow->pSibling;

        // While we have siblings...
        while (pCurrent)
        {
            // Current Parent is pRow
            Assert(pRow == pCurrent->pParent);

            // Reset the parent...
            pCurrent->pParent = pNewRow;

            // Goto Next Sibling
            pCurrent = pCurrent->pSibling;
        }

        // Set the Sibling of pNewRow to be the same sibling as pRow
        pNewRow->pSibling = pRow->pSibling;

        // Reset Parent of pNewRow
        pNewRow->pParent = pRow->pParent;

        // Assume Expanded Flags...
        pNewRow->fExpanded = pRow->fExpanded;

        // Clear dwState
        pNewRow->dwState = 0;

        // If pNewRow is now a Root.. Need to adjust the subject hash table..
        if (NULL == pNewRow->pParent && pNewRow->Message.pszNormalSubj && m_pThreadSubject)
        {
            // Remove pRow from both threading indexes!!!
            m_pThreadSubject->Insert(pNewRow->Message.pszNormalSubj, (LPVOID)pNewRow, HF_NO_DUPLICATES);
        }
    }

    // Otherwise...
    else
    {
        // Set pNewRow for doing sibling/parent fixup
        pNewRow = pRow->pSibling;
    }

    // Otherwise, if there is a parent...
    if (pRow->pParent)
    {
        // Parent must have children
        Assert(pRow->pParent->pChild);

        // First Child of pRow->pParent
        if (pRow == pRow->pParent->pChild)
        {
            // Set new first child to pRow's Sibling
            pRow->pParent->pChild = pNewRow;
        }

        // Otherwise, Walk pParent's Child and remove pRow from Sibling List
        else
        {
            // Set pPrevious
            LPROWINFO pPrevious=NULL;

            // Set pCurrent
            pCurrent = pRow->pParent->pChild;

            // Loop
            while (pCurrent)
            {
                // Is this the row to remove!
                if (pRow == pCurrent)
                {
                    // Better be a previous
                    Assert(pPrevious);

                    // pPrevious's Sibling better be pRow
                    Assert(pPrevious->pSibling == pRow);

                    // Set New Sibling
                    pPrevious->pSibling = pNewRow;

                    // Done
                    break;
                }
                
                // Set pPrevious
                pPrevious = pCurrent;

                // Set pCurrent
                pCurrent = pCurrent->pSibling;
            }

            // Validate
            Assert(pRow == pCurrent);
        }

        // Set row state
        pRow->pParent->dwState = 0;
    }

    // UpdateRows
    if (fNotify && INVALID_ROWINDEX != iMin && INVALID_ROWINDEX != iMax)
    {
        // Queue the Notification
        _QueueNotification(TRANSACTION_UPDATE, iMin, iMax);
    }

    // Clear the row
    pRow->pParent = pRow->pChild = pRow->pSibling = NULL;

    // done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_PGetThreadRoot
//--------------------------------------------------------------------------
LPROWINFO CMessageTable::_PGetThreadRoot(LPROWINFO pRow)
{
    // Trace
    TraceCall("CMessageTable::_PGetThreadRoot");

    // Validate
    Assert(pRow);

    // Set Root
    LPROWINFO pRoot = pRow;

    // While there is a parent
    while (pRoot->pParent)
    {
        // Go Up One
        pRoot = pRoot->pParent;
    }

    // Done
    return(pRoot);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetThreadIndexRange
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetThreadIndexRange(LPROWINFO pRow, BOOL fClearState,
    LPROWINDEX piMin, LPROWINDEX piMax)
{
    // Locals
    LPROWINFO   pRoot;
    ROWINDEX    iRow;

    // Trace
    TraceCall("CMessageTable::_GetThreadIndexRange");

    // Validate Args
    Assert(pRow && piMin && piMax);

    // Initialize
    *piMin = *piMax = INVALID_ROWINDEX;

    // Get the Root
    pRoot = _PGetThreadRoot(pRow);

    // If the root isn't visible, then don't bother...
    if (FALSE == pRoot->fVisible)
        return(S_OK);

    // The Root Must be Visible, not filtered and not hidden
    Assert(FALSE == pRoot->fFiltered && FALSE == pRoot->fHidden);
    
    // Get the Row Index
    SideAssert(SUCCEEDED(GetRowIndex(pRoot->Message.idMessage, piMin)));

    // Init piMax
    (*piMax) = (*piMin);

    // Loop until I hit the next row in the view who is the root
    while (1)
    {
        // Set irow
        iRow = (*piMax) + 1;

        // Dont
        if (iRow >= m_cView)
            break;

        // Look at the Next Row
        if (NULL == m_prgpView[iRow]->pParent)
            break;

        // Increment piMax
        (*piMax) = iRow;
    }

    // ClearState
    if (fClearState)
    {
        // If Clear State
        _WalkMessageThread(pRoot, WALK_THREAD_CURRENT, NULL, _WalkThreadClearState);
    }

    // Done
    return(S_OK);
}
        
//--------------------------------------------------------------------------
// CMessageTable::_LinkRowIntoThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_LinkRowIntoThread(LPROWINFO pParent, LPROWINFO pRow,
    BOOL fNotify)
{
    // Locals
    BOOL            fHadChildren=(pParent->pChild ? TRUE : FALSE);
    LPROWINFO       pCurrent;
    LPROWINFO       pPrevious=NULL;

    // Trace
    TraceCall("CMessageTable::_LinkRowIntoThread");

    // Set Parent
    pRow->pParent = pParent;

    // Loop through the children and find the right place to insert this child
    pCurrent = pParent->pChild;

    // Loop
    while (pCurrent)
    {
        // Compare Received Time...
        if (CompareFileTime(&pRow->Message.ftReceived, &pCurrent->Message.ftReceived) <= 0)
            break;

        // Set Previous
        pPrevious = pCurrent;

        // Goto Next
        pCurrent = pCurrent->pSibling;
    }

    // If there is a pPrevious
    if (pPrevious)
    {
        // Set Sibling of pRow
        pRow->pSibling = pPrevious->pSibling;

        // Point pPrevious to pRow
        pPrevious->pSibling = pRow;
    }

    // Otherwise, set parent child
    else
    {
        // Set Sibling of pRow
        pRow->pSibling = pParent->pChild;

        // First Row ?
        if (NULL == pParent->pChild && FALSE == m_fLoaded)
        {
            // Set Expanded
            pParent->fExpanded = m_SortInfo.fExpandAll;
        }

        // Set Parent Child
        pParent->pChild = pRow;
    }

    // Not Loaded
    if (FALSE == m_fLoaded || TRUE == pRow->fDelayed)
    {
        // Set Expanded Bit on this row...
        pRow->fExpanded = pParent->fExpanded;
    }

    // If this is the first child and we have expand all on
    if (fNotify)
    {
        // First Child...
        if (pParent->fVisible && (m_SortInfo.fExpandAll || pParent->fExpanded))
        {
            // Locals
            ROWINDEX iParent;

            // Expand this thread...
            SideAssert(SUCCEEDED(GetRowIndex(pParent->Message.idMessage, &iParent)));

            // Expand...
            _ExpandThread(iParent, TRUE, FALSE);
        }

        // Otherwise, update this thread range...
        else if (m_pNotify)
        {
            // Locals
            ROWINDEX iMin;
            ROWINDEX iMax;

            // _RefreshThread
            _GetThreadIndexRange(pParent, TRUE, &iMin, &iMax);

            // UpdateRows
            if (INVALID_ROWINDEX != iMin && INVALID_ROWINDEX != iMax)
            {
                // Queue It
                _QueueNotification(TRANSACTION_UPDATE, iMin, iMax);
            }
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_FindThreadParentByRef
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FindThreadParentByRef(LPCSTR pszReferences, 
    LPROWINFO *ppParent)
{
    // Locals
    HRESULT         hr=S_OK;
    GETTHREADPARENT GetParent;

    // Trace
    TraceCall("CMessageTable::_FindThreadParentByRef");

    // Init
    *ppParent = NULL;

    // Setup GetParent
    GetParent.pDatabase = m_pDB;
    GetParent.pHash = m_pThreadMsgId;
    GetParent.pvResult = NULL;

    // EnumerateReferences
    IF_FAILEXIT(hr = EnumerateRefs(pszReferences, (DWORD_PTR)&GetParent, EnumRefsGetThreadParent));

    // Not Found
    if (NULL == GetParent.pvResult)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Return the Row
    *ppParent = (LPROWINFO)GetParent.pvResult;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_InsertRowIntoThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_InsertRowIntoThread(LPROWINFO pRow, BOOL fNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pParent;
    LPMESSAGEINFO   pMessage=&pRow->Message;

    // Trace
    TraceCall("CMessageTable::_InsertRowIntoThread");

    // Better not be hidden or filtered
    Assert(FALSE == pRow->fFiltered && FALSE == pRow->fHidden);

    // Find Parent by References Line
    if (S_OK == _FindThreadParentByRef(pMessage->pszReferences, &pParent))
    {
        // Link row into thread
        _LinkRowIntoThread(pParent, pRow, fNotify);

        // Ok
        hr = S_OK;

        // Done
        goto exit;
    }

    // Subject Threading
    if (m_pThreadSubject)
    {
        // If there is a subject
        if (NULL == pRow->Message.pszNormalSubj)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Try to find a message who has the same normalized subject....
        if (SUCCEEDED(m_pThreadSubject->Find(pRow->Message.pszNormalSubj, FALSE, (LPVOID *)&pParent)))
        {
            // Should we Swap the parent and pRow ?
            if (CompareFileTime(&pRow->Message.ftReceived, &pParent->Message.ftReceived) <= 0)
            {
                // Locals
                ROWINDEX iRow;

                // Make pRow be the Root
                IxpAssert(NULL == pParent->pParent && NULL == pParent->pSibling && pParent->fVisible);

                // No Parent for pRow
                pRow->pParent = NULL;

                // Set Expanded
                pRow->fExpanded = pParent->fExpanded;

                // Get the Row Index
                SideAssert(SUCCEEDED(GetRowIndex(pParent->Message.idMessage, &iRow)));

                // Validate
                Assert(m_prgpView[iRow] == pParent);

                // Replace with pRow
                m_prgpView[iRow] = pRow;

                // Visible
                pRow->fVisible = TRUE;

                // Clear Visible...
                pParent->fVisible = FALSE;

                // Replace the Subject Token
                SideAssert(SUCCEEDED(m_pThreadSubject->Replace(pRow->Message.pszNormalSubj, (LPVOID *)pRow)));

                // Link row into thread
                _LinkRowIntoThread(pRow, pParent, fNotify);
            }

            // Otherwise..
            else
            {
                // Link row into thread
                _LinkRowIntoThread(pParent, pRow, fNotify);
            }

            // Success
            hr = S_OK;

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = S_FALSE;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_RefreshFilter
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RefreshFilter(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;
    SORTCHANGEINFO  Change={0};

    // Trace
    TraceCall("CMessageTable::_RefreshFilter");

    // No filter currently enabled
    if (NULL == m_pQuery)
        goto exit;

    // Loop through current rows...
    for (i = 0; i < m_cRows; i++)
    {
        // Set pRow
        pRow = m_prgpRow[i];

        // If Not Hidden and Not Filtered
        if (pRow->fFiltered)
            continue;

        // Set Filtered Bit
        if (FALSE == _FIsFiltered(pRow))
            continue;

        // Adjust m_cUnread
        _AdjustUnreadCount(pRow, -1);

        // Hide the Row
        _HideRow(pRow, FALSE);

        // Filtered
        pRow->fFiltered = TRUE;

        // Increment m_cFiltered
        m_cFiltered++;
    }
    
exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_SortThreadFilterTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_SortThreadFilterTable(LPSORTCHANGEINFO pChange,
    BOOL fApplyFilter)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;
    QUERYINFO       Query={0};

    // Trace
    TraceCall("CMessageTable::_SortThreadFilterTable");

    // Nothing to resort ?
    if (0 == m_cRows)
        goto exit;

    // Nuke the View Index
    m_cView = 0;

    // Do the Filter
    if (pChange->fFilter)
    {
        // Get m_pQuery
        SafeRelease(m_pQuery);

        // Build a Query Object
        if (SUCCEEDED(RuleUtil_HrBuildQuerysFromFilter(m_SortInfo.ridFilter, &Query)) && Query.pszQuery)
        {
            // Get the Query Object
            IF_FAILEXIT(hr = g_pDBSession->OpenQuery(m_pDB, Query.pszQuery, &m_pQuery));
        }
    }

    // Drop the Threading Indexes
    SafeRelease(m_pThreadMsgId);
    SafeRelease(m_pThreadSubject);

    // If Threaded
    if (m_SortInfo.fThreaded)
    {
        // Create a New Hash TAble
        IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, m_cRows), FALSE, &m_pThreadMsgId));

        // Don't do Subject threading?
        if (DwGetOption(OPT_SUBJECT_THREADING) || (FOLDER_NEWS != m_Folder.tyFolder))
        {
            // Create a Subject Hash Table
            IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, m_cRows), FALSE, &m_pThreadSubject));
        }
    }

    // Reset Unread and Filtered
    m_cUnread = m_cFiltered = 0;

    // Loop through current rows...
    for (i = 0; i < m_cRows; i++)
    {
        // Set pRow
        pRow = m_prgpRow[i];

        // Reset Visible
        pRow->fVisible = FALSE;

        // Clear Threading
        pRow->pParent = pRow->pChild = pRow->pSibling = NULL;

        // Clear dwState
        pRow->dwState = 0;

        // If Threaded..
        if (FALSE == m_SortInfo.fThreaded)
        {
            // Clear Expanded
            pRow->fExpanded = FALSE;
        }

        // Otherwise, if the row is hidden
        else if (pRow->fFiltered || pRow->fHidden)
        {
            // Reset Expanded State
            pRow->fExpanded = m_SortInfo.fExpandAll;
        }

        // Do filter
        if (fApplyFilter)
        {
            // Reset the Highlight
            pRow->Message.wHighlight = pRow->wHighlight;

            // If not doing show repiles
            if (FALSE == m_SortInfo.fShowReplies)
            {
                // Set Filtered Bit
                pRow->fFiltered = _FIsFiltered(pRow);

                // Set Hidden Bit
                pRow->fHidden = _FIsHidden(pRow);
            }

            // Otherwise, clear the filtered bits
            else
            {
                // Clear the Bits
                pRow->fFiltered = pRow->fHidden = FALSE;
            }
        }

        // If Not Filtered
        if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
        {
            // Hash the MessageId
            if (m_SortInfo.fThreaded)
            {
                // Insert Message Id into the hash table
                if (pRow->Message.pszMessageId)
                {
                    // Insert It
                    m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pRow, HF_NO_DUPLICATES);
                }
            }

            // Otherwise, add entry to view index
            else
            {
                // Visible
                pRow->fVisible = TRUE;

                // Put into m_prgpView
                m_prgpView[m_cView] = pRow;

                // Increment View Count
                m_cView++;
            }

            // Adjust m_cUnread
            _AdjustUnreadCount(pRow, 1);
        }

        // Otherwise, free the record
        else
        {
            // Count Filtered
            m_cFiltered++;
        }
    }

    // Sort the Table
    _SortAndThreadTable(fApplyFilter);

    // If Threaded
    if (m_SortInfo.fThreaded)
    {
        // If the Filter Changed, then re-apply collapse and expand...
        if (pChange->fThread)
        {
            // Expand All ?
            if (m_SortInfo.fExpandAll)
            {
                // Expand Everything
                _ExpandThread(INVALID_ROWINDEX, FALSE, FALSE);
            }

            // Otherwise, collapse all
            else
            {
                // Collapse Everything
                _CollapseThread(INVALID_ROWINDEX, FALSE);
            }
        }

        // Otherwise, re-expand threads that were expanded and expand newly deferred inserted rows
        else 
        {
            // Re-Expand Threads that were expanded...
            _ExpandThread(INVALID_ROWINDEX, FALSE, TRUE);
        }
    }

exit:
    // Cleanup
    SafeMemFree(Query.pszQuery);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_BuildTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_BuildTable(IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;
    QUERYINFO       Query={0};
    DWORD           cRecords;
    DWORD           cFetched;
    DWORD           i;
    DWORD           cMessages=0;
    DWORD           cUnread=0;
    DWORD           cWatched=0;
    DWORD           cWatchedUnread=0;
    HROWSET         hRowset=NULL;
    LPMESSAGEINFO   pMessage;
    MESSAGEINFO     rgMessage[ROWSET_FETCH];

    // Trace
    TraceCall("CMessageTable::_BuildTable");

    // Free my current row table
    _FreeTable();

    // Get m_pQuery
    SafeRelease(m_pQuery);

    // Build a Query Object
    if (SUCCEEDED(RuleUtil_HrBuildQuerysFromFilter(m_SortInfo.ridFilter, &Query)) && Query.pszQuery)
    {
        // Get the Query Object
        IF_FAILEXIT(hr = g_pDBSession->OpenQuery(m_pDB, Query.pszQuery, &m_pQuery));
    }

    // Get the Row Count
    IF_FAILEXIT(hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cRecords));

    // Do OnBegin
    if (pCallback)
        pCallback->OnBegin(SOT_SORTING, NULL, (IOperationCancel *)this);

    // If Threaded
    if (m_SortInfo.fThreaded)
    {
        // Create a New Hash TAble
        IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, cRecords), FALSE, &m_pThreadMsgId));

        // Don't do Subject threading?
        if (DwGetOption(OPT_SUBJECT_THREADING) || (FOLDER_NEWS != m_Folder.tyFolder))
        {
            // Create a Subject Hash Table
            IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, cRecords), FALSE, &m_pThreadSubject));
        }
    }

    // Allocate the Row Table
    IF_FAILEXIT(hr = HrAlloc((LPVOID *)&m_prgpRow, sizeof(LPROWINFO) * (cRecords + CGROWTABLE)));

    // Allocate the View Table
    IF_FAILEXIT(hr = HrAlloc((LPVOID *)&m_prgpView, sizeof(LPROWINFO) * (cRecords + CGROWTABLE)));

    // Set m_cAllocated
    m_cAllocated = cRecords + CGROWTABLE;

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Walk the Rowset
    while (S_OK == m_pDB->QueryRowset(hRowset, ROWSET_FETCH, (LPVOID *)rgMessage, &cFetched))
    {
        // Loop through the Rows
        for (i=0; i<cFetched; i++)
        {
            // Set pMessage
            pMessage = &rgMessage[i];

            // Count Messages
            cMessages++;

            // Create a Row
            IF_FAILEXIT(hr = _CreateRow(pMessage, &pRow));

            // Unread ?
            if (!ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
            {
                // Increment cUnread
                cUnread++;

                // Watched
                if (ISFLAGSET(pRow->Message.dwFlags, ARF_WATCH))
                    cWatchedUnread++;
            }

            // Watched
            if (ISFLAGSET(pRow->Message.dwFlags, ARF_WATCH))
                cWatched++;

            // If not showing repiles
            if (FALSE == m_SortInfo.fShowReplies)
            {
                // Set Filtered Bit
                pRow->fFiltered = _FIsFiltered(pRow);

                // Set Hidden Bit
                pRow->fHidden = _FIsHidden(pRow);
            }

            // If Not Filtered
            if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
            {
                // Hash the MessageId
                if (m_SortInfo.fThreaded)
                {
                    // Insert Message Id into the hash table
                    if (pRow->Message.pszMessageId)
                    {
                        // Insert It
                        m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pRow, HF_NO_DUPLICATES);
                    }
                }

                // Otherwise, add entry to view index
                else
                {
                    // Visible
                    pRow->fVisible = TRUE;

                    // Put into m_prgpView
                    m_prgpView[m_cView] = pRow;

                    // Increment View Count
                    m_cView++;
                }

                // Adjust m_cUnread
                _AdjustUnreadCount(pRow, 1);
            }

            // Otherwise, free the record
            else
            {
                // Count Filtered
                m_cFiltered++;
            }

            // Store the Row
            m_prgpRow[m_cRows] = pRow;

            // Increment Row Count
            m_cRows++;
        }

        // Do OnBegin
        if (pCallback)
            pCallback->OnProgress(SOT_SORTING, m_cRows, cRecords, NULL);
    }

    // Reset the folder count
    m_pFolder->ResetFolderCounts(cMessages, cUnread, cWatchedUnread, cWatched);

    // Sort the Table
    _SortAndThreadTable(TRUE);

    // Threaded
    if (m_SortInfo.fThreaded)
    {
        // Expand All ?
        if (m_SortInfo.fExpandAll)
        {
            // Expand Everything
            _ExpandThread(INVALID_ROWINDEX, FALSE, FALSE);
        }

        // Otherwise, collapse all
        else
        {
            // Collapse Everything
            _CollapseThread(INVALID_ROWINDEX, FALSE);
        }
    }

    // Set Bit to denote that m_fBuiltTable
    m_fLoaded = TRUE;

exit:
    // Free rgMessage?
    for (; i<cFetched; i++)
    {
        // Free this record
        m_pDB->FreeRecord(&rgMessage[i]);
    }

    // Close the Rowset
    m_pDB->CloseRowset(&hRowset);

    // Cleanup
    SafeMemFree(Query.pszQuery);

    // Do OnBegin
    if (pCallback)
        pCallback->OnComplete(SOT_SORTING, S_OK, NULL, NULL);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_SortAndThreadTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_SortAndThreadTable(BOOL fApplyFilter)
{
    // Locals
    DWORD       i;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::_SortAndThreadTable");

    // If there are rows...
    if (0 == m_cRows)
        goto exit;

    // Threaded
    if (m_SortInfo.fThreaded)
    {
        // Build Thread Roots
        for (i = 0; i < m_cRows; i++)
        {
            // Set pRow
            pRow = m_prgpRow[i];

            // If Not Filtered...
            if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
            {
                // Insert this row into a thread...
                if (S_FALSE == _InsertRowIntoThread(pRow, FALSE))
                {
                    // Subject Threading ?
                    if (m_pThreadSubject && pRow->Message.pszNormalSubj)
                    {
                        // Insert Subject into Hash Table...
                        m_pThreadSubject->Insert(pRow->Message.pszNormalSubj, (LPVOID)pRow, HF_NO_DUPLICATES);
                    }

                    // Visible
                    pRow->fVisible = TRUE;

                    // Its a Root
                    m_prgpView[m_cView++] = pRow;
                }
            }
        }

        // Show Replies Only ?
        if (fApplyFilter && m_SortInfo.fShowReplies)
        {
            // PruneToReplies
            _PruneToReplies();
        }
    }

    // If there are rows...
    if (0 == m_cView)
        goto exit;

    // Sort the View
    _SortView(0, m_cView - 1);

    // Refresh Filter
    if (fApplyFilter && m_SortInfo.fShowReplies)
    {
        // Refresh Any filter (I have to do this after I've pruned replies
        _RefreshFilter();
    }

exit:
    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_PruneToReplies
//--------------------------------------------------------------------------
HRESULT CMessageTable::_PruneToReplies(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iRow;
    LPROWINFO       pRow;
    FOLDERINFO      Server={0};
    IImnAccount    *pAccount=NULL;
    CHAR            szEmail[CCHMAX_EMAIL_ADDRESS];
    THREADISFROMME  IsFromMe;
    THREADHIDE      HideThread={0};

    // Trace
    TraceCall("CMessageTable::_PruneToReplies");

    // Validate
    Assert(FOLDER_NEWS == m_Folder.tyFolder && TRUE == m_SortInfo.fThreaded);

    // Free m_pszEmail
    SafeMemFree(m_pszEmail);

    // Get Folder Store Info
    IF_FAILEXIT(hr = GetFolderStoreInfo(m_Folder.idFolder, &Server));

    // Better have an account id
    Assert(Server.pszAccountId);

    // Find the Account for the id for this Server
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Server.pszAccountId, &pAccount));

    // Try the NNTP Email Address
    IF_FAILEXIT(hr = pAccount->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szEmail, CCHMAX_EMAIL_ADDRESS));

    // Duplicate szEmail
    IF_NULLEXIT(m_pszEmail = PszDupA(szEmail));

    // Don't notify on hide thread
    HideThread.fNotify = FALSE;

    // Init iRow...
    iRow = 0;

    // Walk through the Roots
    while (iRow < m_cView)
    {
        // Set pRow
        pRow = m_prgpView[iRow];

        // Not a Root ?
        if (NULL == pRow->pParent)
        {
            // Reset
            IsFromMe.fResult = FALSE;
            IsFromMe.pRow = NULL;

            // Find the first message that is from me in this thread...
            _WalkMessageThread(pRow, WALK_THREAD_CURRENT, (DWORD_PTR)&IsFromMe, _WalkThreadIsFromMe);

            // If Not From Me, then hide this thread...
            if (FALSE == IsFromMe.fResult)
            {
                // Find the first message that is from me in this thread...
                _WalkMessageThread(pRow, WALK_THREAD_CURRENT | WALK_THREAD_BOTTOMUP, (DWORD_PTR)&HideThread, _WalkThreadHide);
            }

            // Otherwise, increment iRow
            else
                iRow++;
        }

        // Otherwise, increment iRow
        else
            iRow++;
    }

exit:
    // Clearnup
    SafeRelease(pAccount);
    g_pStore->FreeRecord(&Server);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_AdjustUnreadCount
//--------------------------------------------------------------------------
HRESULT CMessageTable::_AdjustUnreadCount(LPROWINFO pRow, LONG lCount)
{
    // Not Filtered
    if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
    {
        // Not Read
        if (FALSE == ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
        {
            // Adjust Unread Count
            m_cUnread += lCount;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SafeStrCmpI
//--------------------------------------------------------------------------
inline SafeStrCmpI(LPCSTR psz1, LPCSTR psz2) 
{
    // Null
    if (NULL == psz1) 
    {
        // Equal
        if (NULL == psz2)
            return(0);

        // Less Than
        return(-1);
    }

    // Greater than
    if (NULL == psz2) 
        return(1);

    // Return Comparison
    return(lstrcmpi(psz1, psz2));
}

//--------------------------------------------------------------------------
// CMessageTable::_CompareMessages
//--------------------------------------------------------------------------
LONG CMessageTable::_CompareMessages(LPMESSAGEINFO pMsg1, LPMESSAGEINFO pMsg2)
{
    // Locals
    LONG lRet = 0;

    // Trace
    TraceCall("CMessageTable::_CompareMessages");

    switch (m_SortInfo.idColumn)
    {
    case COLUMN_TO:
        lRet = SafeStrCmpI(pMsg1->pszDisplayTo, pMsg2->pszDisplayTo);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            }
        break;

    case COLUMN_FROM:
        lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            }
        break;

    case COLUMN_SUBJECT:
        lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_RECEIVED:
        lRet = CompareFileTime(&pMsg1->ftReceived, &pMsg2->ftReceived);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_SENT:
        lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_SIZE:
        lRet = (pMsg1->cbMessage - pMsg2->cbMessage);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            }
        break;

    case COLUMN_FOLDER:
        lRet = SafeStrCmpI(pMsg1->pszFolder, pMsg2->pszFolder);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_LINES:
        lRet = (pMsg1->cLines - pMsg2->cLines);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            }
        break;

    case COLUMN_ACCOUNT:
        lRet = SafeStrCmpI(pMsg1->pszAcctName, pMsg2->pszAcctName);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftReceived, &pMsg2->ftReceived);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            }
        break;

    case COLUMN_ATTACHMENT:
        lRet = (pMsg1->dwFlags & ARF_HASATTACH) - (pMsg2->dwFlags & ARF_HASATTACH);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_PRIORITY:
        lRet = (pMsg1->wPriority - pMsg2->wPriority);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_FLAG:
        lRet = (pMsg1->dwFlags & ARF_FLAGGED) - (pMsg2->dwFlags & ARF_FLAGGED);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_DOWNLOADMSG:
        lRet = (pMsg1->dwFlags & ARF_DOWNLOAD) - (pMsg2->dwFlags & ARF_DOWNLOAD);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_THREADSTATE:
        lRet = (pMsg1->dwFlags & (ARF_WATCH | ARF_IGNORE)) - (pMsg2->dwFlags & (ARF_WATCH | ARF_IGNORE));
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    default:
        Assert(FALSE);
        break;
    }

    // Done
    return (m_SortInfo.fAscending ? lRet : -lRet);
}

//--------------------------------------------------------------------------
// CMessageTable::_SortView
//--------------------------------------------------------------------------
VOID CMessageTable::_SortView(LONG left, LONG right)
{
    // Locals
    register LONG   i;
    register LONG   j;
    LPROWINFO       pRow;
    LPROWINFO       y;

    i = left;
    j = right;
    pRow = m_prgpView[(left + right) / 2];

    do  
    {
        while (_CompareMessages(&m_prgpView[i]->Message, &pRow->Message) < 0 && i < right)
            i++;
        while (_CompareMessages(&m_prgpView[j]->Message, &pRow->Message) > 0 && j > left)
            j--;

        if (i <= j)
        {
            y = m_prgpView[i];
            m_prgpView[i] = m_prgpView[j];
            m_prgpView[j] = y;
            i++; j--;
        }
     } while (i <= j);

    if (left < j)
        _SortView(left, j);
    if (i < right)
        _SortView(i, right);
}

//--------------------------------------------------------------------------
// CMessageTable::GetCount
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetCount(GETCOUNTTYPE tyCount, DWORD *pcRows)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idFolder;
    FOLDERINFO      Folder;

    // Trace
    TraceCall("CMessageTable::GetCount");

    // Invalid Args
    Assert(pcRows);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *pcRows = 0;

    // Get the Folder Id
    IF_FAILEXIT(hr = m_pFolder->GetFolderId(&idFolder));

    // Handle Type
    switch(tyCount)
    {
    case MESSAGE_COUNT_VISIBLE:
        *pcRows = m_cView;
        break;

    case MESSAGE_COUNT_ALL:
        *pcRows = (m_cRows - m_cFiltered);
        break;

    case MESSAGE_COUNT_FILTERED:
        *pcRows = m_cFiltered;
        break;

    case MESSAGE_COUNT_UNREAD:
        *pcRows = m_cUnread;
        break;

    case MESSAGE_COUNT_NOTDOWNLOADED:
        if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        {
            if (Folder.tyFolder == FOLDER_NEWS)
                *pcRows = NewsUtil_GetNotDownloadCount(&Folder);
            g_pStore->FreeRecord(&Folder);
        }
        break;

    default:
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_FreeTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FreeTable(void)
{
    // Trace
    TraceCall("CMessageTable::_FreeTable");

    // Free Hash Tables
    SafeRelease(m_pThreadMsgId);
    SafeRelease(m_pThreadSubject);

    // Free Elements
    _FreeTableElements();

    // Fre the Array
    SafeMemFree(m_prgpRow);

    // Free the View Index
    SafeMemFree(m_prgpView);

    // Set m_cAllocated
    m_cFiltered = m_cUnread = m_cRows = m_cView = m_cAllocated = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_FreeTableElements
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FreeTableElements(void)
{
    // Trace
    TraceCall("CMessageTable::_FreeTableElements");

    // If we have an m_prgpRow
    if (m_prgpRow)
    {
        // Free Cache
        for (DWORD i=0; i<m_cRows; i++)
        {
            // Not Null ?
            if (m_prgpRow[i])
            {
                // Release the Row
                ReleaseRow(&m_prgpRow[i]->Message);

                // Null It
                m_prgpRow[i] = NULL;
            }
        }
    }

    // Done
    return(S_OK);
}


//--------------------------------------------------------------------------
// CMessageTable::GetRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRow(ROWINDEX iRow, LPMESSAGEINFO *ppInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::GetRow");

    // Invalid Args
    Assert(ppInfo);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *ppInfo = NULL;

    // Failure
    hr = _GetRowFromIndex(iRow, &pRow);
    if (FAILED(hr))
        goto exit;

    // Copy the Record to pInfo...
    *ppInfo = &pRow->Message;

    // Increment Refs
    pRow->cRefs++;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::ReleaseRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::ReleaseRow(LPMESSAGEINFO pMessage)
{
    // Locals
    LPROWINFO pRow;

    // Trace
    TraceCall("CMessageTable::ReleaseRow");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Release ?
    if (pMessage)
    {
        // Get pRow
        pRow = (LPROWINFO)pMessage->dwReserved;

        // Must have at least one ref
        IxpAssert(pRow->cRefs);

        // Decrement Refs
        pRow->cRefs--;

        // No more refs
        if (0 == pRow->cRefs)
        {
            // Free
            m_pDB->FreeRecord(&pRow->Message);

            // Free pMessage
            m_pDB->HeapFree(pRow);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRelativeRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRelativeRow(ROWINDEX iRow, RELATIVEROWTYPE tyRelative, 
    LPROWINDEX piRelative)
{
    // Locals
    HRESULT             hr=S_OK;
    LPROWINFO           pRow;

    // Trace
    TraceCall("CMessageTable::GetRelativeRow");

    // Invalid Args
    Assert(piRelative);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *piRelative = INVALID_ROWINDEX;

    // Failure
    IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

    // Parent
    if (RELATIVE_ROW_PARENT == tyRelative)
    {
        // If this row is expanded...
        if (TRUE == pRow->fExpanded)
        {
            // Expand...
            _CollapseThread(iRow, TRUE);

            // Return iRow
            *piRelative = iRow;
        }

        // If there is a Parent
        else if (pRow->pParent)
        {
            // Get Row Index
            IF_FAILEXIT(hr = GetRowIndex(pRow->pParent->Message.idMessage, piRelative));
        }
    }

    // Child
    else if (RELATIVE_ROW_CHILD == tyRelative)
    {
        // If there is a Parent
        if (pRow->pChild)
        {
            // If not Expanded, expand...
            if (FALSE == pRow->fExpanded)
            {
                // Expand...
                _ExpandThread(iRow, TRUE, FALSE);

                // Return iRow
                *piRelative = iRow;
            }

            // Otherwise...
            else
            {
                // Get Row Index
                IF_FAILEXIT(hr = GetRowIndex(pRow->pChild->Message.idMessage, piRelative));
            }
        }
    }

    // Root
    else if (RELATIVE_ROW_ROOT == tyRelative)
    {
        // While
        while (pRow->pParent)
        {
            // Walk to the root
            pRow = pRow->pParent;
        }

        // Get Row Index
        IF_FAILEXIT(hr = GetRowIndex(pRow->Message.idMessage, piRelative));
    }

    // Failure
    else
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetLanguage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetLanguage(ROWINDEX iRow, LPDWORD pdwCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetLanguage");

    // Invalid Args
    Assert(pdwCodePage);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Get the Row
    IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

    // Get the Charset
    *pdwCodePage = pMessage->wLanguage;

exit:
    // Cleanup
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::SetLanguage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::SetLanguage(DWORD cRows, LPROWINDEX prgiRow, 
    DWORD dwCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    HLOCK           hLock=NULL;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::SetLanguage");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Lock Notify
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Loop
    for (i=0; i<cRows; i++)
    {
        // Get Row
        if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
        {
            // Set the Language
            pRow->Message.wLanguage = (WORD)dwCodePage;

            // Update the Record
            IF_FAILEXIT(hr = m_pDB->UpdateRecord(&pRow->Message));
        }
    }

exit:
    // Lock Notify
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::OpenMessage(ROWINDEX iRow, OPENMESSAGEFLAGS dwFlags, 
    IMimeMessage **ppMessage, IStoreCallback *pCallback)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMESSAGEINFO       pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetMessage");

    // Invalid Args
    Assert(ppMessage);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *ppMessage = NULL;

    // Get the message info
    IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

    // Open the message
    IF_FAILEXIT(hr = m_pFolder->OpenMessage(pMessage->idMessage, dwFlags, ppMessage, pCallback));

exit:
    // Clenaup
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowMessageId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowMessageId(ROWINDEX iRow, LPMESSAGEID pidMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetRowMessageId");

    // Invalid Args
    Assert(pidMessage);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *pidMessage = 0;

    // Get the Row Info
    IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

    // Store the id
    *pidMessage = pMessage->idMessage;

exit:
    // Free
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowIndex
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowIndex(MESSAGEID idMessage, LPROWINDEX piRow)
{
    // Locals
    HRESULT     hr=S_OK;
    ROWINDEX    iRow;
    LPROWINFO   pRow;
    
    // Trace
    TraceCall("CMessageTable::GetRowIndex");

    // Invalid Args
    Assert(idMessage && piRow);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // INit
    *piRow = INVALID_ROWINDEX;

    // Loop through the view index
    for (iRow=0; iRow<m_cView; iRow++)
    {
        // Is This It ?
        if (m_prgpView[iRow]->Message.idMessage == idMessage)
        {
            // Done
            *piRow = iRow;

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetIndentLevel
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetIndentLevel(ROWINDEX iRow, LPDWORD pcIndent)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetIndentLevel");

    // Invalid Args
    Assert(pcIndent);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Don't Call Unless Threaded
    Assert(m_SortInfo.fThreaded);

    // Init
    *pcIndent = 0;

    // Valid irow
    IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

    // Walk the Parent Chain...
    while (pRow->pParent)
    {
        // Increment Index
        (*pcIndent)++;

        // Set pRow
        pRow = pRow->pParent;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkMessageThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkMessageThread(LPROWINFO pRow, WALKTHREADFLAGS dwFlags, 
    DWORD_PTR dwCookie, PFWALKTHREADCALLBACK pfnCallback)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pCurrent;
    LPROWINFO   pTemp;
    BOOL        fCurrent=FALSE;

    // Trace
    TraceCall("CMessageTable::_WalkMessageThread");

    // Invalid Args
    Assert(pfnCallback);

    // Include idMessage ?
    if (ISFLAGSET(dwFlags, WALK_THREAD_CURRENT))
    {
        // This is the first iteration
        fCurrent = TRUE;
    }

    // Don't include current anymore
    FLAGCLEAR(dwFlags, WALK_THREAD_CURRENT);

    // Bottom Up Recursion...
    if (ISFLAGSET(dwFlags, WALK_THREAD_BOTTOMUP))
    {
        // Set iCurrent
        pCurrent = pRow->pChild;

        // Loop
        while (pCurrent)
        {
            // Enumerate Children
            IF_FAILEXIT(hr = _WalkMessageThread(pCurrent, dwFlags, dwCookie, pfnCallback));

            // Set iCurrent
            pTemp = pCurrent->pSibling;

            // Call the Callback
            (*(pfnCallback))(this, pCurrent, dwCookie);

            // Set pCurrent
            pCurrent = pTemp;
        }

        // Can't Support these flags with bottom up...
        if (TRUE == fCurrent)
        {
            // Call the Callback
            (*(pfnCallback))(this, pRow, dwCookie);
        }
    }

    // Otherwise.
    else
    {
        // Include idMessage ?
        if (TRUE == fCurrent)
        {
            // Call the Callback
            (*(pfnCallback))(this, pRow, dwCookie);
        }

        // Set iCurrent
        pCurrent = pRow->pChild;

        // Loop
        while (pCurrent)
        {
            // Call the Callback
            (*(pfnCallback))(this, pCurrent, dwCookie);

            // Enumerate Children
            IF_FAILEXIT(hr = _WalkMessageThread(pCurrent, dwFlags, dwCookie, pfnCallback));

            // Set iCurrent
            pCurrent = pCurrent->pSibling;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetSelectionState
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetSelectionState(DWORD cRows, LPROWINDEX prgiRow, 
    SELECTIONSTATE dwMask, BOOL fIncludeChildren, SELECTIONSTATE *pdwState)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERID            idFolder;
    FOLDERINFO          Folder={0};
    LPROWINFO           pRow;
    FOLDERTYPE          tyFolder;
    DWORD               i;
    GETSELECTIONSTATE   Selection={0};

    // Trace
    TraceCall("CMessageTable::GetSelectionState");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *pdwState = 0;

    // SELECTION_STATE_DELETABLE
    if (ISFLAGSET(dwMask, SELECTION_STATE_DELETABLE))
    {
        // Not a Find Folder ?
        if (NULL == m_pFindFolder)
        {
            // Get the Folder Id from pidFolder
            IF_FAILEXIT(hr = m_pFolder->GetFolderId(&idFolder));

            // Get Folder Info
            IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

            // BUGBUG @bug [PaulHi] 4/23/99  This is backwards.  The FOLDER_NEWS is the only folder
            // that CAN'T delete messages.  The CMessageList::_IsSelectionDeletable() function
            // reverses this so that deletion is available correctly.  I don't want to mess with
            // this now, in case other code compensates for this.
            // $HACK$ We know that the only folder types that can delete messages are FOLDER_NEWS
            if (FOLDER_NEWS == Folder.tyFolder)
            {
                // Set the Flag
                FLAGSET(*pdwState, SELECTION_STATE_DELETABLE);
            }

#if 0
            // [PaulHi] 4/25/99  Only HotMail HTTP servers don't allow deletion of items in the 
            // 'deleted' folders.  Excehange servers do, so back this fix out.
            // [PaulHi] 4/23/99  Raid 62883.
            if ( (FOLDER_HTTPMAIL == Folder.tyFolder) && (FOLDER_DELETED == Folder.tySpecial) )
            {
                FLAGSET(*pdwState, SELECTION_STATE_DELETABLE);  // Not deletable see above @bug comment
            }
#endif
        }

        // Otherwise, ask the find folder...
        else
        {
            // Setup Selection
            Selection.dwMask = dwMask;
            Selection.dwState = 0;

            // Mark things that are in this folder...
            for (i=0; i<cRows; i++)
            {
                // Good Row Index
                if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
                {
                    // Get the Folder Type
                    IF_FAILEXIT(hr = m_pFindFolder->GetMessageFolderType(pRow->Message.idMessage, &tyFolder));

                    // Get the State
                    if (FOLDER_NEWS == tyFolder)
                    {
                        // Set the State
                        FLAGSET(*pdwState, SELECTION_STATE_DELETABLE);

                        // Done
                        break;
                    }

                    // Threaded
                    if (m_SortInfo.fThreaded)
                    {
                        // Do Children ?
                        if (fIncludeChildren && !pRow->fExpanded && pRow->pChild)
                        {
                            // Walk the Thread
                            IF_FAILEXIT(hr = _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&Selection, _WalkThreadGetSelectionState));

                            // Optimize so that we can finish early
                            if (ISFLAGSET(Selection.dwState, SELECTION_STATE_DELETABLE))
                                break;
                        }
                    }
                }
            }
        }
    }

exit:
    // Free
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_IsThreadImportance
//--------------------------------------------------------------------------
HRESULT CMessageTable::_IsThreadImportance(LPROWINFO pRow, MESSAGEFLAGS dwFlag,
    ROWSTATE dwState, ROWSTATE *pdwState)
{
    // Locals
    LPROWINFO       pRoot;
    GETTHREADSTATE  GetState={0};

    // Trace
    TraceCall("CMessageTable::_IsThreadImportance");

    // Validate
    Assert(ARF_WATCH == dwFlag || ARF_IGNORE == dwFlag);

    // Does this row have the flag set ?
    if (ISFLAGSET(pRow->Message.dwFlags, dwFlag))
    {
        // Set the State
        FLAGSET(*pdwState, dwState);

        // Done
        return(S_OK);
    }

    // Get the Root of this thread
    pRoot = _PGetThreadRoot(pRow);

    // Does this row have the flag set ?
    if (ISFLAGSET(pRoot->Message.dwFlags, dwFlag))
    {
        // Set the State
        FLAGSET(*pdwState, dwState);

        // Done
        return(S_OK);
    }

    // Set Flags to Count
    GetState.dwFlags = dwFlag;

    // Enumerate Immediate Children
    _WalkMessageThread(pRoot, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

    // If This is row is marked as read
    if (GetState.cHasFlags > 0)
    {
        // Set the Bit
        FLAGSET(*pdwState, dwState);

        // Done
        return(S_OK);
    }

    // Not Found
    return(S_FALSE);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowState
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowState(ROWINDEX iRow, ROWSTATE dwStateMask, 
    ROWSTATE *pdwState)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetRowState");

    // Invalid Args
    Assert(pdwState);

    // Validate State
    if (!IsInitialized(this) || iRow >= m_cRows)
        return(E_UNEXPECTED);

    // Initialzie
    *pdwState = 0;

    // Get the row
    IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

    // Is the state Cached Yet?
    if (ISFLAGSET(pRow->dwState, ROW_STATE_VALID))
    {
        // Return the State
        *pdwState = pRow->dwState;

        // Done
        return(S_OK);
    }

    // Reset
    pRow->dwState = 0;

    // Get Thread State
    if (m_SortInfo.fThreaded && pRow->pChild && !pRow->fExpanded && ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
    {
        // Locals
        GETTHREADSTATE GetState={0};

        // Set Flags to Count
        GetState.dwFlags = ARF_READ;

        // Enumerate Immediate Children
        _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

        // If This is row is marked as read
        if (GetState.cHasFlags == GetState.cChildren)
            FLAGSET(pRow->dwState, ROW_STATE_READ);
    }

    // Otherwise, just check the message
    else if (ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
        FLAGSET(pRow->dwState, ROW_STATE_READ);
    
    // If single watched row
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_WATCH))
        FLAGSET(pRow->dwState, ROW_STATE_WATCHED);

    // If single ignored row
    else if (ISFLAGSET(pRow->Message.dwFlags, ARF_IGNORE))
        FLAGSET(pRow->dwState, ROW_STATE_IGNORED);

    // ROW_STATE_DELETED
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_ENDANGERED) || ISFLAGSET(pRow->Message.dwFlags, ARF_ARTICLE_EXPIRED))
        FLAGSET(pRow->dwState, ROW_STATE_DELETED);

    // ROW_STATE_HAS_BODY
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_HASBODY))
        FLAGSET(pRow->dwState, ROW_STATE_HAS_BODY);

    // ROW_STATE_FLAGGED
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_FLAGGED))
        FLAGSET(pRow->dwState, ROW_STATE_FLAGGED);

    // ROW_STATE_EXPANDED
    if (m_SortInfo.fThreaded && pRow->fExpanded)
        FLAGSET(pRow->dwState, ROW_STATE_EXPANDED);

    // ROW_STATE_HAS_CHILDREN
    if (m_SortInfo.fThreaded && pRow->pChild)
        FLAGSET(pRow->dwState, ROW_STATE_HAS_CHILDREN);

    // ROW_STATE_MARKED_DOWNLOAD
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_DOWNLOAD))
        FLAGSET(pRow->dwState, ROW_STATE_MARKED_DOWNLOAD);

    // Cache the State
    FLAGSET(pRow->dwState, ROW_STATE_VALID);

    // Return the State
    *pdwState = pRow->dwState;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Mark
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Mark(LPROWINDEX prgiRow, DWORD cRows, 
    APPLYCHILDRENTYPE tyApply, MARK_TYPE tyMark, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPMESSAGEINFO   pMessage=NULL;
    ADJUSTFLAGS     Flags={0};
    MESSAGEIDLIST   List={0};
    LPROWINFO       pRow;
    HCURSOR         hCursor=NULL;

    // Trace
    TraceCall("CMessageTable::Mark");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Handle Mark Type
    switch(tyMark)
    {
    case MARK_MESSAGE_READ: 
        Flags.dwAdd = ARF_READ; 
        break;

    case MARK_MESSAGE_UNREAD: 
        Flags.dwRemove = ARF_READ; 
        break;

    case MARK_MESSAGE_DELETED: 
        Flags.dwAdd = ARF_ENDANGERED; 
        break;

    case MARK_MESSAGE_UNDELETED: 
        Flags.dwRemove = ARF_ENDANGERED; 
        break;

    case MARK_MESSAGE_DOWNLOAD:  
        Flags.dwAdd = ARF_DOWNLOAD;
        break;

    case MARK_MESSAGE_UNDOWNLOAD: 
        Flags.dwRemove = ARF_DOWNLOAD;
        break;

    case MARK_MESSAGE_FLAGGED: 
        Flags.dwAdd = ARF_FLAGGED; 
        break;

    case MARK_MESSAGE_UNFLAGGED: 
        Flags.dwRemove = ARF_FLAGGED; 
        break;

    case MARK_MESSAGE_FORWARDED:
        Flags.dwAdd = ARF_FORWARDED;
        break;

    case MARK_MESSAGE_UNFORWARDED:
        Flags.dwRemove = ARF_FORWARDED;
        break;

    case MARK_MESSAGE_REPLIED:
        Flags.dwAdd = ARF_REPLIED;
        break;

    case MARK_MESSAGE_UNREPLIED:
        Flags.dwRemove = ARF_REPLIED;
        break;

    case MARK_MESSAGE_NOSECUI:
        Flags.dwAdd = ARF_NOSECUI;
        break;

    case MARK_MESSAGE_SECUI:
        Flags.dwRemove = ARF_NOSECUI;
        break;

    case MARK_MESSAGE_WATCH:
        Flags.dwAdd = ARF_WATCH;
        Flags.dwRemove = ARF_IGNORE;
        break;

    case MARK_MESSAGE_IGNORE:
        Flags.dwAdd = ARF_IGNORE;
        Flags.dwRemove = ARF_WATCH;
        break;

    case MARK_MESSAGE_NORMALTHREAD:
        Flags.dwRemove = ARF_WATCH | ARF_IGNORE;
        break;

    case MARK_MESSAGE_RCPT_PROCESSED:
        Flags.dwAdd = ARF_RCPT_PROCESSED;
        break;

    default:
        Assert(FALSE);
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Not Mark All...
    if (prgiRow && cRows)
    {
        // Allocate an Array
        IF_FAILEXIT(hr = _GrowIdList(&List, cRows + 32));

        // Mark things that are in this folder...
        for (i=0; i<cRows; i++)
        {
            // Valid Row Index
            if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
            {
                // Allocate an Array
                IF_FAILEXIT(hr = _GrowIdList(&List, 1));

                // Set id
                List.prgidMsg[List.cMsgs++] = pRow->Message.idMessage;

                // Do the children 
                if (APPLY_CHILDREN == tyApply || (APPLY_COLLAPSED == tyApply && !pRow->fExpanded))
                {
                    // Only if there are children
                    if (pRow->pChild)
                    {
                        // Walk the Thread
                        IF_FAILEXIT(hr = _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&List, _WalkThreadGetIdList));
                    }
                }
            }
        }

        // Are there messages
        if (List.cMsgs > 0)
        {
            // Adjust the Flags
            IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(&List, &Flags, NULL, pCallback));
        }
    }

    // Mark All
    else
    {
        // Adjust the Flags
        IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(NULL, &Flags, NULL, pCallback));
    }

    // Re-Register for notifications
    m_pDB->DispatchNotify((IDatabaseNotify *)this);

exit:
    // Reset Cursor
    SetCursor(hCursor);

    // Cleanup
    SafeMemFree(List.prgidMsg);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::ConnectionRelease
//--------------------------------------------------------------------------
HRESULT CMessageTable::ConnectionAddRef(void)
{
    if (m_pFolder)
        m_pFolder->ConnectionAddRef();
    return S_OK;
}

//--------------------------------------------------------------------------
// CMessageTable::ConnectionRelease
//--------------------------------------------------------------------------
HRESULT CMessageTable::ConnectionRelease(void)
{
    if (m_pFolder)
        m_pFolder->ConnectionRelease();
    return S_OK;
}

//--------------------------------------------------------------------------
// CMessageTable::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Synchronize(SYNCFOLDERFLAGS dwFlags, 
    DWORD           cHeaders,
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CMessageTable::Synchronize");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Tell the Folder to Synch
    hr = m_pFolder->Synchronize(dwFlags, cHeaders, pCallback);

    // Success
    if (E_PENDING == hr)
    {
        // We are synching
        m_fSynching = TRUE;
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::SetOwner
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::SetOwner(IStoreCallback *pDefaultCallback)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CMessageTable::SetOwner");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Set the Owner
    hr = m_pFolder->SetOwner(pDefaultCallback);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Close
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Close(void)
{
    // Locals
    HRESULT hr = S_OK;

    //Trace
    TraceCall("CMessageTable::Close");

    // Pass it on
    if (m_pFolder)
        hr = m_pFolder->Close();

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowFolderId(ROWINDEX iRow, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetRowFolderId");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Not a Find Folder ?
    if (NULL == m_pFindFolder)
    {
        // Get the Folder Id from pidFolder
        IF_FAILEXIT(hr = m_pFolder->GetFolderId(pidFolder));
    }

    // Otherwise, ask the find folder...
    else
    {
        // Get the Row
        IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

        // Call into the find folder
        IF_FAILEXIT(hr = m_pFindFolder->GetMessageFolderId(pMessage->idMessage, pidFolder));
    }

exit:
    // Free the Row
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::RegisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::RegisterNotify(REGISTERNOTIFYFLAGS dwFlags, 
    IMessageTableNotify *pNotify)
{
    // Trace
    TraceCall("CMessageTable::RegisterNotify");

    // Invalid Args
    if (NULL == pNotify)
        return TraceResult(E_INVALIDARG);

    // Only One is allowed
    AssertSz(NULL == m_pNotify, "Only one person can register for notifications on my object");

    // Save It
    m_pNotify = pNotify;

    // No Release
    m_fRelNotify = FALSE;

    // AddRef ?
    if (FALSE == ISFLAGSET(dwFlags, REGISTER_NOTIFY_NOADDREF))
    {
        m_pNotify->AddRef();
        m_fRelNotify = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::UnregisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::UnregisterNotify(IMessageTableNotify *pNotify)
{
    // Trace
    TraceCall("CMessageTable::UnregisterNotify");

    // Invalid Args
    if (NULL == pNotify)
        return TraceResult(E_INVALIDARG);

    // Otherwise, remove
    if (m_pNotify)
    {
        // Validate
        Assert(m_pNotify == pNotify);

        // Release It
        if (m_fRelNotify)
            m_pNotify->Release();
        m_pNotify = NULL;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::GetNextRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetNextRow(ROWINDEX iCurrentRow, 
    GETNEXTTYPE tyDirection, ROWMESSAGETYPE tyMessage, GETNEXTFLAGS dwFlags, 
    LPROWINDEX piNewRow)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWINDEX        iRow=iCurrentRow;
    ROWINDEX        iStartRow=iCurrentRow;
    BOOL            fWrapAround=FALSE;
    BYTE            fThreadHasUnread;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetNextRow");

    // Invalid Args
    Assert(piNewRow);

    // Validate State
    if (!IsInitialized(this) || iCurrentRow >= m_cView)
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *piNewRow = INVALID_ROWINDEX;

    // Loop
    while (1)
    {
        // Threaded
        if (m_SortInfo.fThreaded)
        {
            // Get pRow
            IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

            // If not expanded
            if (FALSE == pRow->fExpanded && pRow->pChild)
            {
                // Imay need to expand this row...
                if (ROWMSG_ALL == tyMessage || (ROWMSG_NEWS == tyMessage && ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)) || (ROWMSG_MAIL == tyMessage && !ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)))
                {
                    // If looking for unread, see if the thread has unread messages in it
                    if (ISFLAGSET(dwFlags, GETNEXT_UNREAD) && !ISFLAGSET(dwFlags, GETNEXT_THREAD))
                    {
                        // Locals
                        GETTHREADSTATE GetState={0};

                        // Set Flags to Count
                        GetState.dwFlags = ARF_READ;

                        // Root that isn't totally read...
                        _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

                        // If there are unread children of this 
                        if (GetState.cHasFlags != GetState.cChildren)
                        {
                            // Expand This thread
                            _ExpandThread(iRow, TRUE, FALSE);
                        }
                    }
                }
            }
        }

        // Next ?
        if (GETNEXT_NEXT == tyDirection)
        {
            // Increment 
            iRow++;

            // Start back at zero
            if (iRow >= m_cView)
            {
                // Done
                if (!ISFLAGSET(dwFlags, GETNEXT_UNREAD))
                {
                    hr = E_FAIL;
                    goto exit;
                }

                // We Wrapped Around
                fWrapAround = TRUE;

                // Start back at zero
                iRow = 0;
            }
        }

        // Otherwise, backwards
        else
        {
            // Start back at zero
            if (0 == iRow)
            {
                // Done
                if (!ISFLAGSET(dwFlags, GETNEXT_UNREAD))
                {
                    hr = E_FAIL;
                    goto exit;
                }

                // We Wrapped Around
                fWrapAround = TRUE;

                // Start back at zero
                iRow = m_cView - 1;
            }

            // Otherwise, decrement iRow
            else
                iRow--;
        }

        // Wrapped and back to original row
        if (fWrapAround && iRow == iStartRow)
            break;

        // Validate iRow
        Assert(iRow < m_cView);

        // Get pRow
        IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

        // Good time to Stop ?
        if (ROWMSG_ALL == tyMessage || (ROWMSG_NEWS == tyMessage && ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)) || (ROWMSG_MAIL == tyMessage && !ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)))
        {
            // Set fThreadHasUnread
            fThreadHasUnread = FALSE;

            // If looking for unread, see if the thread has unread messages in it
            if (ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // Locals
                GETTHREADSTATE GetState={0};

                // Set Flags to Count
                GetState.dwFlags = ARF_READ;

                // Root that isn't totally read...
                _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

                // If there are unread children of this 
                if (GetState.cHasFlags != GetState.cChildren)
                {
                    // This thread has unread stuff
                    fThreadHasUnread = TRUE;
                }
            }

            // Looking for the next thread with unread messages in it
            if (ISFLAGSET(dwFlags, GETNEXT_THREAD) && ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // If this is a root thread...
                if (NULL == pRow->pParent)
                {
                    // If this row is unread
                    if (!ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
                    {
                        // This is It
                        *piNewRow = iRow;

                        // Done
                        goto exit;
                    }

                    // Otherwise...
                    else if (fThreadHasUnread)
                    {
                        // This is It
                        *piNewRow = iRow;

                        // Done
                        goto exit;
                    }
                }
            }

            // Looking for a thread root
            else if (ISFLAGSET(dwFlags, GETNEXT_THREAD) && !ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // If this is a root thread...
                if (NULL == pRow->pParent)
                {
                    // This is It
                    *piNewRow = iRow;

                    // Done
                    goto exit;
                }
            }

            // Looking for the next unread message
            else if (!ISFLAGSET(dwFlags, GETNEXT_THREAD) && ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // If this is a thread that has unread children, then expand It.
                if (m_SortInfo.fThreaded && FALSE == pRow->fExpanded && pRow->pChild && fThreadHasUnread)
                {
                    // Expand This thread
                    _ExpandThread(iRow, TRUE, FALSE);
                }

                // If this is a root thread...
                if (FALSE == ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
                {
                    // This is It
                    *piNewRow = iRow;

                    // Done
                    goto exit;
                }
            }

            // Otherwise, this is it
            else
            {
                // This is It
                *piNewRow = iRow;

                // Done
                goto exit;
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetMessageIdList
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetMessageIdList(BOOL fRootsOnly, DWORD cRows, 
    LPROWINDEX prgiRow, LPMESSAGEIDLIST pIdList)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetMessageIdList");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    ZeroMemory(pIdList, sizeof(MESSAGEIDLIST));

    // Allocate an Array
    IF_FAILEXIT(hr = _GrowIdList(pIdList, cRows + 32));

    // Mark things that are in this folder...
    for (i=0; i<cRows; i++)
    {
        // Good View Index
        if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
        {
            // _GrowIdList
            IF_FAILEXIT(hr = _GrowIdList(pIdList, 1));

            // Set id
            pIdList->prgidMsg[pIdList->cMsgs++] = pRow->Message.idMessage;

            // If Not Expanded and Has children, insert the children...
            if (!fRootsOnly && m_SortInfo.fThreaded && !pRow->fExpanded && pRow->pChild)
            {
                // Walk the Thread
                IF_FAILEXIT(hr = _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)pIdList, _WalkThreadGetIdList));
            }
        }
    }

exit:
    // Done
    return(hr);
}

#if 0
//--------------------------------------------------------------------------
// CMessageTable::_GetRowOrdinal
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetRowOrdinal(MESSAGEID idMessage, LPROWORDINAL piOrdinal)
{
    // Locals
    LONG        lLower=0;
    LONG        lUpper=m_cRows - 1;
    LONG        lCompare;
    DWORD       dwMiddle;
    LPROWINFO   pRow;

    // Do binary search / insert
    while (lLower <= lUpper)
    {
        // Set lMiddle
        dwMiddle = (DWORD)((lLower + lUpper) / 2);

        // Compute middle record to compare against
        pRow = m_prgpRow[dwMiddle];

        // Get string to compare against
        lCompare = ((DWORD)idMessage - (DWORD)pRow->Message.idMessage);

        // If Equal, then were done
        if (lCompare == 0)
        {
            *piOrdinal = dwMiddle;
            return(S_OK);
        }

        // Compute upper and lower 
        if (lCompare > 0)
            lLower = (LONG)(dwMiddle + 1);
        else 
            lUpper = (LONG)(dwMiddle - 1);
    }       

    // Not Found
    return(TraceResult(DB_E_NOTFOUND));
}

//--------------------------------------------------------------------------
// CMessageTable::_ProcessResults
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ProcessResults(TRANSACTIONTYPE tyTransaction,
    DWORD cRows, LPROWINDEX prgiRow, LPRESULTLIST pResults)
{
    // Locals
    DWORD           i;
    ROWORDINAL      iOrdinal;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_ProcessResults");

    // Validate
    Assert(TRANSACTION_UPDATE == tyTransaction || TRANSACTION_DELETE == tyTransaction);

    // Another Validation
    Assert(cRows == pResults->cMsgs);

    // No Results
    if (NULL == pResults || NULL == pResults->prgResult)
        return(S_OK);

    // Do Row Updates Myself...
    for (i=0; i<pResults->cValid; i++)
    {
        // If this row was deleted
        if (S_OK == pResults->prgResult[i].hrResult)
        {
            // Get Row From Index
            if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
            {
                // Validate
                Assert(pResults->prgResult[i].idMessage == pRow->Message.idMessage);

                // Find the Row Ordinal
                SideAssert(SUCCEEDED(_GetRowOrdinal(pRow->Message.idMessage, &iOrdinal)));

                // We better have found it
                Assert(iOrdinal < m_cRows);

                // Update
                else if (TRANSACTION_UPDATE == tyTransaction)
                {
                    // Get pRow
                    _RowTableUpdate(iOrdinal, &pRow->Message, &pResults->prgResult[i]);
                }
            }
        }
    }

    // Flush Notification Queue
    _FlushNotificationQueue(TRUE);

    // Done
    return(S_OK);
}
#endif

//--------------------------------------------------------------------------
// CMessageTable::DeleteRows
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::DeleteRows(DELETEMESSAGEFLAGS dwFlags, DWORD cRows, 
    LPROWINDEX prgiRow, BOOL fIncludeChildren, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEIDLIST   List={0};
    HCURSOR         hCursor=NULL;

    // Trace
    TraceCall("CMessageTable::DeleteRows");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Get MessageID List
    IF_FAILEXIT(hr = GetMessageIdList((FALSE == fIncludeChildren), cRows, prgiRow, &List));

    // Adjust the Flags
    IF_FAILEXIT(hr = m_pFolder->DeleteMessages(dwFlags, &List, NULL, pCallback));

    // Re-Register for notifications
    m_pDB->DispatchNotify((IDatabaseNotify *)this);

exit:
    // Reset Cursor
    SetCursor(hCursor);

    // Cleanup
    SafeMemFree(List.prgidMsg);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::CopyRows
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::CopyRows(FOLDERID idFolder, 
    COPYMESSAGEFLAGS dwOptions, DWORD cRows, LPROWINDEX prgiRow, 
    LPADJUSTFLAGS pFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEIDLIST   List={0};
    HCURSOR         hCursor=NULL;
    IMessageFolder *pDstFolder=NULL;

    // Trace
    TraceCall("CMessageTable::CopyRows");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Open the Destination Folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pDstFolder));

    // Get MessageID List
    IF_FAILEXIT(hr = GetMessageIdList(FALSE, cRows, prgiRow, &List));

    // Adjust the Flags
    IF_FAILEXIT(hr = m_pFolder->CopyMessages(pDstFolder, dwOptions, &List, pFlags, NULL, pCallback));

    // Re-Register for notifications
    m_pDB->DispatchNotify((IDatabaseNotify *)this);

exit:
    // Reset Cursor
    SetCursor(hCursor);

    // Cleanup
    SafeRelease(pDstFolder);
    SafeMemFree(List.prgidMsg);
    
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::QueryService
//--------------------------------------------------------------------------
HRESULT CMessageTable::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    // Locals
    HRESULT             hr=E_NOINTERFACE;
    IServiceProvider   *pSP;

    // Trace
    TraceCall("CMessageTable::QueryService");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Currently the msgtable doesn't expose any objects, but will delegate to the folder to see if it can handle it
    if (guidService == IID_IMessageFolder)
    {
        if (m_pFolder)
            hr = m_pFolder->QueryInterface(riid, ppvObject);
    }
    else if (m_pFolder && m_pFolder->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP) == S_OK)
    {
        // Query Service This
        hr = pSP->QueryService(guidService, riid, ppvObject);

        // Release It
        pSP->Release();
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::FindNextRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::FindNextRow(ROWINDEX iStartRow, LPCTSTR pszFindString, 
    FINDNEXTFLAGS dwFlags, BOOL fIncludeBody, ROWINDEX *piNextRow, BOOL *pfWrapped)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;
    ROWINDEX        iCurrent;
    DWORD           cchFindString;
    BOOL            fWrapAround=FALSE;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageTable::QueryService");

    // Invalid Args
    Assert(pszFindString && piNextRow);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *piNextRow = -1;
    if (pfWrapped)
        *pfWrapped = FALSE;

    // Get Prefix Length
    cchFindString = lstrlen(pszFindString);

    // Lock the Folder
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Set iCurrent
    iCurrent = iStartRow >= m_cRows ? 0 : iStartRow;

    // COLUMN_TO
    if (FINDNEXT_TYPEAHEAD != dwFlags )
        iCurrent++;

    // Start my Loop
    while (1)
    {
        // Start back at zero
        if (iCurrent >= m_cRows)
        {
            // We Wrapped Around
            fWrapAround = TRUE;

            if (pfWrapped)
                *pfWrapped = TRUE;

            // Start back at zero
            iCurrent = 0;
        }

        // Get the Row Info
        IF_FAILEXIT(hr = GetRow(iCurrent, &pMessage));

        // How to search...
        if (FINDNEXT_ALLCOLUMNS == dwFlags)
        {
            // Display to
            if (pMessage->pszDisplayTo && StrStrIA(pMessage->pszDisplayTo, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }
            
            // Email To
            if (pMessage->pszEmailTo && StrStrIA(pMessage->pszEmailTo, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Display From
            if (pMessage->pszDisplayFrom && StrStrIA(pMessage->pszDisplayFrom, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Email From
            if (pMessage->pszEmailFrom && StrStrIA(pMessage->pszEmailFrom, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Subject
            if (pMessage->pszNormalSubj && StrStrIA(pMessage->pszNormalSubj, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Folder
            if (pMessage->pszFolder && StrStrIA(pMessage->pszFolder, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Account name
            if (pMessage->pszAcctName && StrStrIA(pMessage->pszAcctName, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Search the Body ?
            if (fIncludeBody && pMessage->faStream)
            {
                // Locals
                BOOL fMatch=FALSE;
                IMimeMessage *pMessageObject;
                IStream *pStream;

                // Open the Stream
                if (SUCCEEDED(m_pFolder->OpenMessage(pMessage->idMessage, OPEN_MESSAGE_CACHEDONLY, &pMessageObject, NOSTORECALLBACK)))
                {
                    // Try to Get the Plain Text Stream
                    if (FAILED(pMessageObject->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
                    {
                        // Try to get the HTML stream
                        if (FAILED(pMessageObject->GetTextBody(TXT_HTML, IET_DECODED, &pStream, NULL)))
                            pStream = NULL;
                    }

                    // Do we have a strema
                    if (pStream)
                    {
                        // Search the Stream
                        fMatch = StreamSubStringMatch(pStream, (LPSTR)pszFindString);

                        // Release the Stream
                        pStream->Release();
                    }

                    // Cleanup
                    pMessageObject->Release();
                }

                // Found a Match ?
                if (fMatch)
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
            }
        }

        // Otherwise
        else
        {
            // Handle the column to search on...
            switch(m_SortInfo.idColumn)
            {
            case COLUMN_TO:
                if (pMessage->pszDisplayTo && 0 == StrCmpNI(pszFindString, pMessage->pszDisplayTo, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_FROM:       
                if (pMessage->pszDisplayFrom && 0 == StrCmpNI(pszFindString, pMessage->pszDisplayFrom, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_SUBJECT:    
                if (pMessage->pszNormalSubj && 0 == StrCmpNI(pszFindString, pMessage->pszNormalSubj, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_FOLDER:     
                if (pMessage->pszFolder && 0 == StrCmpNI(pszFindString, pMessage->pszFolder, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_ACCOUNT:    
                if (pMessage->pszAcctName && 0 == StrCmpNI(pszFindString, pMessage->pszAcctName, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            default:
                goto exit;
            }
        }

        // Cleanup
        SafeReleaseRow(this, pMessage);

        // Increment iCurrent
        iCurrent++;

        // Wrapped and back to original row
        if (fWrapAround && iCurrent >= iStartRow)
            break;
    }

exit:
    // Cleanup
    SafeReleaseRow(this, pMessage);

    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Collapse
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Collapse(ROWINDEX iRow)
{
    // Trace
    TraceCall("CMessageTable::Collapse");

    // Call Internal Function
    return(_CollapseThread(iRow, TRUE));
}

//--------------------------------------------------------------------------
// CMessageTable::_CollapseThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_CollapseThread(ROWINDEX iRow, BOOL fNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWINDEX        iParent;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_CollapseThread");

    // Expand All ?
    if (INVALID_ROWINDEX == iRow)
    {
        // Walk through the Roots in the View...
        for (iRow = 0; iRow < m_cView; iRow++)
        {
            // Set pRow
            if (NULL == m_prgpView[iRow]->pParent)
            {
                // Set iParent
                iParent = iRow;

                // _CollapseSingleThread
                IF_FAILEXIT(hr = _CollapseSingleThread(&iRow, m_prgpView[iRow], fNotify));

                // Notify ?
                if (fNotify)
                {
                    // Queue It
                    _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
                }
            }
        }
    }

    // Otherwise, expand one row
    else
    {
        // Get the Row
        IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

        // Set iParent
        iParent = iRow;

        // _ExpandSingleThread
        IF_FAILEXIT(hr = _CollapseSingleThread(&iRow, pRow, fNotify));

        // Notify ?
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
        }
    }

exit:
    // Flush
    if (fNotify)
        _FlushNotificationQueue(TRUE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_CollapseSingleThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_CollapseSingleThread(LPROWINDEX piCurrent, 
    LPROWINFO pParent, BOOL fNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pCurrent;

    // Trace
    TraceCall("CMessageTable::_CollapseSingleThread");

    // Mark Parent as Expanded...
    pParent->fExpanded = FALSE;

    // Set row state
    pParent->dwState = 0;

    // If no children
    if (NULL == pParent->pChild)
        return(S_OK);

    // Loop through the children...
    for (pCurrent = pParent->pChild; pCurrent != NULL; pCurrent = pCurrent->pSibling)
    {
        // If not visible
        if (pCurrent->fVisible)
        {
            // Increment
            (*piCurrent)++;

            // Validate
            Assert(m_prgpView[(*piCurrent)] == pCurrent);

            // Insert pCurrent's Children
            IF_FAILEXIT(hr = _CollapseSingleThread(piCurrent, pCurrent, fNotify));

            // Insert into View
            _DeleteFromView((*piCurrent), pCurrent);

            // Insert the Row
            if (fNotify)
            {
                // Queue It
                _QueueNotification(TRANSACTION_DELETE, *piCurrent, INVALID_ROWINDEX, TRUE);
            }

            // Decrement
            (*piCurrent)--;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Expand
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Expand(ROWINDEX iRow)
{
    // Trace
    TraceCall("CMessageTable::Collapse");

    // Call Internal Function
    return(_ExpandThread(iRow, TRUE, FALSE));
}

//--------------------------------------------------------------------------
// CMessageTable::_ExpandThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ExpandThread(ROWINDEX iRow, BOOL fNotify, BOOL fReExpand)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWINDEX        iParent;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_ExpandThread");

    // Expand All ?
    if (INVALID_ROWINDEX == iRow)
    {
        // Walk through the Roots in the View...
        for (iRow = 0; iRow < m_cView; iRow++)
        {
            // Set pRow
            if (NULL == m_prgpView[iRow]->pParent)
            {
                // Set iParent
                iParent = iRow;

                // _ExpandSingleThread
                IF_FAILEXIT(hr = _ExpandSingleThread(&iRow, m_prgpView[iRow], fNotify, fReExpand));

                // Notify ?
                if (fNotify)
                {
                    // Queue It
                    _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
                }
            }
        }
    }

    // Otherwise, expand one row
    else
    {
        // Get the Row
        IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

        // Set iParent
        iParent = iRow;

        // _ExpandSingleThread
        IF_FAILEXIT(hr = _ExpandSingleThread(&iRow, pRow, fNotify, fReExpand));

        // Notify ?
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
        }
    }

exit:
    // Flush
    if (fNotify)
        _FlushNotificationQueue(TRUE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_ExpandSingleThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ExpandSingleThread(LPROWINDEX piCurrent, 
    LPROWINFO pParent, BOOL fNotify, BOOL fReExpand)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pCurrent;

    // Trace
    TraceCall("CMessageTable::_ExpandSingleThread");

    // If not delayed inserted...
    if (fReExpand && FALSE == pParent->fExpanded)
        return(S_OK);

    // Mark Parent as Expanded...
    pParent->fExpanded = TRUE;

    // Set row state
    pParent->dwState = 0;

    // If no children
    if (NULL == pParent->pChild)
        return(S_OK);

    // Loop through the children...
    for (pCurrent = pParent->pChild; pCurrent != NULL; pCurrent = pCurrent->pSibling)
    {
        // Increment piCurrent
        (*piCurrent)++;

        // If not visible
        if (FALSE == pCurrent->fVisible)
        {
            // Insert into View
            _InsertIntoView((*piCurrent), pCurrent);

            // Insert the Row
            if (fNotify)
            {
                // Queue It
                _QueueNotification(TRANSACTION_INSERT, *piCurrent, INVALID_ROWINDEX, TRUE);
            }
        }

        // Otherwise, valident entry in view index
        else
            Assert(m_prgpView[(*piCurrent)] == pCurrent);

        // Insert pCurrent's Children
        IF_FAILEXIT(hr = _ExpandSingleThread(piCurrent, pCurrent, fNotify, fReExpand));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_DeleteFromView
//--------------------------------------------------------------------------
HRESULT CMessageTable::_DeleteFromView(ROWINDEX iRow, LPROWINFO pRow)
{
    // Better not be visible yet
    Assert(TRUE == pRow->fVisible);

    // Correct Row
    Assert(m_prgpView[iRow] == pRow);

    // Visible...
    pRow->fVisible = FALSE;

    // Collapse the Array
    MoveMemory(&m_prgpView[iRow], &m_prgpView[iRow + 1], sizeof(LPROWINFO) * (m_cView - (iRow + 1)));

    // Decrement m_cView
    m_cView--;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_InsertIntoView
//--------------------------------------------------------------------------
HRESULT CMessageTable::_InsertIntoView(ROWINDEX iRow, LPROWINFO pRow)
{
    // Better not be visible yet
    Assert(FALSE == pRow->fVisible);

    // Visible...
    pRow->fVisible = TRUE;

    // Increment view Count
    m_cView++;

    // Shift The Array
    MoveMemory(&m_prgpView[iRow + 1], &m_prgpView[iRow], sizeof(LPROWINFO) * (m_cView - iRow));

    // Set the Index
    m_prgpView[iRow] = pRow;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_RowTableInsert
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RowTableInsert(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;
    ROWINDEX        iRow;

    // Trace
    TraceCall("CMessageTable::_RowTableInsert");

    // Failure
    if (iOrdinal >= m_cRows + 1)
    {
        Assert(FALSE);
        return(TraceResult(E_FAIL));
    }

    // Do I need to grow the table
    if (m_cRows + 1 >= m_cAllocated)
    {
        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prgpRow, sizeof(LPROWINFO) * (m_cRows + CGROWTABLE)));

        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prgpView, sizeof(LPROWINFO) * (m_cRows + CGROWTABLE)));

        // Set m_cAllocated
        m_cAllocated = m_cRows + CGROWTABLE;
    }

    // Create a Row
    IF_FAILEXIT(hr = _CreateRow(pMessage, &pRow));
  
    // Don't Free
    pMessage->pAllocated = NULL;

    // Increment Row Count
    m_cRows++;

    // Shift The Array
    MoveMemory(&m_prgpRow[iOrdinal + 1], &m_prgpRow[iOrdinal], sizeof(LPROWINFO) * (m_cRows - iOrdinal));

    // Set pRow
    m_prgpRow[iOrdinal] = pRow;

    // If the row is Filtered, then just return
    pRow->fFiltered = _FIsFiltered(pRow);

    // Get Hidden Bit
    pRow->fHidden = _FIsHidden(pRow);

    // If not filtered and not hidden
    if (pRow->fFiltered || pRow->fHidden)
    {
        // Update Filtered Count
        m_cFiltered++;

        // Done
        goto exit;
    }

    // If this  is a news folder, then lets just wait for a while...we will get hit with a force sort later...
    if (TRUE == m_fSynching && FOLDER_NEWS == m_Folder.tyFolder)
    {
        // Set Expanded
        pRow->fExpanded = m_SortInfo.fExpandAll;

        // Set fDelayed
        pRow->fDelayed = TRUE;

        // Count Skiped
        m_cDelayed++;

        // Done
        goto exit;
    }

    // If not filtered
    _AdjustUnreadCount(pRow, 1);

    // Show the Row
    _ShowRow(pRow);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_ShowRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ShowRow(LPROWINFO pRow)
{
    // Locals
    ROWINDEX iRow = INVALID_ROWINDEX;

    // Compare
    if (m_SortInfo.fShowReplies)
    {
        // Have Addresses
        if (pRow->Message.pszEmailFrom && m_pszEmail)
        {
            // From Me
            if (0 == lstrcmpi(m_pszEmail, pRow->Message.pszEmailFrom))
            {
                // Set the Highlight
                pRow->Message.wHighlight = m_clrWatched;
            }
        }
    }

    // Threaded ?
    if (m_SortInfo.fThreaded)
    {
        // Insert Message Id into the hash table
        if (pRow->Message.pszMessageId)
        {
            // Insert It
            m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pRow, HF_NO_DUPLICATES);
        }

        // Insert this row into a thread...
        if (S_OK == _InsertRowIntoThread(pRow, TRUE))
            return(S_OK);

        // Subject Threading ?
        // [PaulHi] 6/22/99  Raid 81081
        // Make sure we have a non-NULL subject string pointer before trying to hash it.
        if (m_pThreadSubject && pRow->Message.pszNormalSubj)
        {
            // Insert Subject into Hash Table...
            m_pThreadSubject->Insert(pRow->Message.pszNormalSubj, (LPVOID)pRow, HF_NO_DUPLICATES);
        }
    }

    // If no parent, then just insert sorted into the view
    Assert(NULL == pRow->pParent);

    // Insert into View
    for (iRow=0; iRow<m_cView; iRow++)
    {
        // Only Compare Against Roots
        if (NULL == m_prgpView[iRow]->pParent)
        {
            // Insert Here...
            if (_CompareMessages(&pRow->Message, &m_prgpView[iRow]->Message) <= 0)
                break;
        }
    }

    // Insert into the view
    _InsertIntoView(iRow, pRow);

    // Queue It
    _QueueNotification(TRANSACTION_INSERT, iRow, INVALID_ROWINDEX);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetRowFromOrdinal
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetRowFromOrdinal(ROWORDINAL iOrdinal, 
    LPMESSAGEINFO pExpected, LPROWINFO *ppRow)
{
    // Trace
    TraceCall("CMessageTable::_GetRowFromOrdinal");

    // Failure
    if (iOrdinal >= m_cRows)
    {
        Assert(FALSE);
        return(TraceResult(E_FAIL));
    }

    // Set pRow
    (*ppRow) = m_prgpRow[iOrdinal];

    // Valid Row
    if ((*ppRow)->Message.idMessage != pExpected->idMessage)
    {
        Assert(FALSE);
        return(TraceResult(E_FAIL));
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_RowTableDelete
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RowTableDelete(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage)
{
    // Set pRow
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_RowTableDelete");

    // Get Row From Ordinal
    IF_FAILEXIT(hr = _GetRowFromOrdinal(iOrdinal, pMessage, &pRow));

    // Shift The Array
    MoveMemory(&m_prgpRow[iOrdinal], &m_prgpRow[iOrdinal + 1], sizeof(LPROWINFO) * (m_cRows - (iOrdinal + 1)));

    // Decrement row Count
    m_cRows--;

    // If the message was filtered
    if (pRow->fFiltered || pRow->fHidden)
    {
        // One less filtered item
        m_cFiltered--;
    }

    // If not filtered
    _AdjustUnreadCount(pRow, -1);

    // Call Utility
    _HideRow(pRow, TRUE);

    // Release the Row
    ReleaseRow(&pRow->Message);

exit:
    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_HideRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::_HideRow(LPROWINFO pRow, BOOL fNotify)
{
    // Locals
    LPROWINFO   pReplace=NULL;
    ROWINDEX    iRow;

    // Trace
    TraceCall("CMessageTable::_HideRow");

    // Threaded
    if (m_SortInfo.fThreaded)
    {
        // Save First Child
        pReplace = pRow->pChild;
    }

    // Delete the row from the thread
    _DeleteRowFromThread(pRow, fNotify);

    // Locate pRow in m_prgpView
    if (FALSE == pRow->fVisible)
        return(S_OK);

    // Better not be hidden or filtered
    Assert(FALSE == pRow->fHidden && FALSE == pRow->fFiltered);

    // Must Succeed
    SideAssert(SUCCEEDED(GetRowIndex(pRow->Message.idMessage, &iRow)));

    // Replace ?
    if (pReplace && TRUE == pRow->fVisible && FALSE == pReplace->fVisible)
    {
        // Validate
        Assert(m_prgpView[iRow] == pRow);

        // Insert into View
        m_prgpView[iRow] = pReplace;

        // Visible...
        pReplace->fVisible = TRUE;

        // Insert the Row
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iRow, iRow, TRUE);
        }
    }

    // Otherwise, just delete it...
    else
    {
        // Delete from view
        _DeleteFromView(iRow, pRow);

        // Notify ?
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_DELETE, iRow, INVALID_ROWINDEX);
        }
    }

    // Not Visible
    pRow->fVisible = FALSE;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_RowTableUpdate
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RowTableUpdate(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;
    ROWINDEX        iMin;
    ROWINDEX        iMax;
    BOOL            fDone=FALSE;
    BOOL            fHidden;

    // Trace
    TraceCall("CMessageTable::_RowTableUpdate");

    // Get Row From Ordinal
    IF_FAILEXIT(hr = _GetRowFromOrdinal(iOrdinal, pMessage, &pRow));

    // If not filtered
    _AdjustUnreadCount(pRow, -1);

    // Free pRow->Message
    m_pDB->FreeRecord(&pRow->Message);

    // Copy the Message Info
    CopyMemory(&pRow->Message, pMessage, sizeof(MESSAGEINFO));

    // Set dwReserved
    pRow->Message.dwReserved = (DWORD_PTR)pRow;

    // Don't Free
    pMessage->pAllocated = NULL;

    // Save the Highlight
    pRow->wHighlight = pRow->Message.wHighlight;

    // Clear this rows state...
    pRow->dwState = 0;

    // Compare
    if (m_SortInfo.fShowReplies)
    {
        // Have Addresses
        if (pRow->Message.pszEmailFrom && m_pszEmail)
        {
            // From Me
            if (0 == lstrcmpi(m_pszEmail, pRow->Message.pszEmailFrom))
            {
                // Set the Highlight
                pRow->Message.wHighlight = m_clrWatched;
            }
        }
    }

    // Hidden
    fHidden = _FIsHidden(pRow);

    // If the message was filtered, but isn't filtered now...
    if (TRUE == pRow->fFiltered)
    {
        // Reset the Filtered Bit
        if (FALSE == _FIsFiltered(pRow))
        {
            // Set fFiltered
            pRow->fFiltered = FALSE;

            // If Not Hidden
            if (FALSE == pRow->fHidden)
            {
                // Need to do something so that it gets shown
                pRow->fHidden = !fHidden;

                // Decrement m_cFiltered
                m_cFiltered--;
            }
        }
    }

    // If not filtered
    if (FALSE == pRow->fFiltered)
    {
        // Is it hidden now
        if (FALSE == pRow->fHidden && TRUE == fHidden)
        {
            // If not filtered
            _AdjustUnreadCount(pRow, -1);

            // Hide the Row
            _HideRow(pRow, TRUE);

            // Its Hidden
            pRow->fHidden = TRUE;

            // Increment Filtered
            m_cFiltered++;

            // Done
            fDone = TRUE;
        }

        // Otherwise, if it was hidden, and now its not...
        else if (TRUE == pRow->fHidden && FALSE == fHidden)
        {
            // Its Hidden
            pRow->fHidden = FALSE;

            // If not filtered
            _AdjustUnreadCount(pRow, 1);

            // Increment Filtered
            m_cFiltered--;

            // Show the row
            _ShowRow(pRow);

            // Done
            fDone = TRUE;
        }
    }

    // If not hidden and not filtered
    if (FALSE == fDone && FALSE == pRow->fHidden && FALSE == pRow->fFiltered)
    {
        // If not filtered
        _AdjustUnreadCount(pRow, 1);

        // If this row is visible, then I just need to update this row...
        if (pRow->fVisible)
        {
            // Get the Row Index
            SideAssert(SUCCEEDED(GetRowIndex(pRow->Message.idMessage, &iMin)));

            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iMin, iMin);
        }

        // Otherwise, update the thread range
        else
        {
            // Get the index range of this thread
            _GetThreadIndexRange(pRow, TRUE, &iMin, &iMax);

            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iMin, iMax);
        }
    }

exit:
    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_FlushNotificationQueue
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FlushNotificationQueue(BOOL fFinal)
{
    // Nothing to Notify
    if (NULL == m_pNotify)
        return(S_OK);

    // Have Delete or Inserted rows ?
    if (m_Notify.cRows > 0)
    {
        // TRANSACTION_INSERT
        if (TRANSACTION_INSERT == m_Notify.tyCurrent)
        {
            // Is this It ?
            m_pNotify->OnInsertRows(m_Notify.cRows, m_Notify.prgiRow, m_Notify.fIsExpandCollapse);
        }

        // TRANSACTION_DELETE
        else if (TRANSACTION_DELETE == m_Notify.tyCurrent)
        {
            // Is this It ?
            m_pNotify->OnDeleteRows(m_Notify.cRows, m_Notify.prgiRow, m_Notify.fIsExpandCollapse);
        }
    }

    // Have Updated Rows ?
    if (m_Notify.cUpdate > 0)
    {
        // Is this It ?
        m_pNotify->OnUpdateRows(m_Notify.iRowMin, m_Notify.iRowMax);

        // Reset Update Range
        m_Notify.cUpdate = 0;
        m_Notify.iRowMin = 0xffffffff;
        m_Notify.iRowMax = 0;
    }

    // Nothing to Notify About
    m_Notify.cRows = 0;

    // Final ?
    m_Notify.fClean = fFinal;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_QueueNotification
//--------------------------------------------------------------------------
HRESULT CMessageTable::_QueueNotification(TRANSACTIONTYPE tyTransaction, 
    ROWINDEX iRowMin, ROWINDEX iRowMax, BOOL fIsExpandCollapse /*=FALSE*/)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("CMessageTable::_QueueNotification");

    // Nothing to Notify
    if (NULL == m_pNotify)
        return(S_OK);

    // Not Clearn
    m_Notify.fClean = FALSE;

    // If Update
    if (TRANSACTION_UPDATE == tyTransaction)
    {
        // Min
        if (iRowMin < m_Notify.iRowMin)
            m_Notify.iRowMin = iRowMin;

        // Max
        if (iRowMax > m_Notify.iRowMax)
            m_Notify.iRowMax = iRowMax;

        // Count Notify
        m_Notify.cUpdate++;
    }

    // Otherwise...
    else
    {
        // Queue It
        if (tyTransaction != m_Notify.tyCurrent || m_Notify.fIsExpandCollapse != fIsExpandCollapse)
        {
            // Flush
            _FlushNotificationQueue(FALSE);

            // Save the New Type
            m_Notify.tyCurrent = tyTransaction;

            // Count fIsExpandCollapse
            m_Notify.fIsExpandCollapse = (BYTE) !!fIsExpandCollapse;
        }

        // Grow the Queue Size
        if (m_Notify.cRows + 1 > m_Notify.cAllocated)
        {
            // Realloc
            IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_Notify.prgiRow, (m_Notify.cAllocated + 256) * sizeof(ROWINDEX)));

            // Set cAlloc
            m_Notify.cAllocated = (m_Notify.cAllocated + 256);
        }

        // Append the iRow
        m_Notify.prgiRow[m_Notify.cRows] = iRowMin;

        // Increment Row count
        m_Notify.cRows++;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::OnTransaction
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::OnTransaction(HTRANSACTION hTransaction, 
    DWORD_PTR dwCookie, IDatabase *pDB)
{
    // Locals
    HRESULT             hr=S_OK;
    ORDINALLIST         Ordinals;
    INDEXORDINAL        iIndex;
    MESSAGEINFO         Message1={0};
    MESSAGEINFO         Message2={0};
    TRANSACTIONTYPE     tyTransaction;

    // Trace
    TraceCall("CMessageTable::OnTransaction");

    // Should have final bit set
    IxpAssert(m_Notify.fClean == TRUE);

    // Loop Through Notifications
    while (hTransaction)
    {
        // Get the Transaction Info
        IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Message1, &Message2, &iIndex, &Ordinals));

        // Insert
        if (TRANSACTION_INSERT == tyTransaction)
        {
            // Good Ordinal
            Assert(INVALID_ROWORDINAL != Ordinals.rgiRecord1[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] > 0);

            // Insert Row Into Table
            _RowTableInsert(Ordinals.rgiRecord1[IINDEX_PRIMARY] - 1, &Message1);
        }

        // Delete
        else if (TRANSACTION_DELETE == tyTransaction)
        {
            // Good Ordinal
            Assert(INVALID_ROWORDINAL != Ordinals.rgiRecord1[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] > 0);

            // Delete Row From Table
            _RowTableDelete(Ordinals.rgiRecord1[IINDEX_PRIMARY] - 1, &Message1);
        }

        // Update
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Deleted
            Assert(INVALID_ROWORDINAL != Ordinals.rgiRecord1[IINDEX_PRIMARY] && INVALID_ROWORDINAL != Ordinals.rgiRecord2[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] == Ordinals.rgiRecord2[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] > 0 && Ordinals.rgiRecord2[IINDEX_PRIMARY] > 0);

            // Delete Row From Table
            _RowTableUpdate(Ordinals.rgiRecord1[IINDEX_PRIMARY] - 1, &Message2);
        }
    }

exit:
    // Cleanup
    pDB->FreeRecord(&Message1);
    pDB->FreeRecord(&Message2);

    // Flush the Queue
    _FlushNotificationQueue(TRUE);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadGetSelectionState
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadGetSelectionState(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERTYPE          tyFolder;
    LPGETSELECTIONSTATE pState = (LPGETSELECTIONSTATE)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadGetSelectionState");

    // Is Deletetable
    if (ISFLAGSET(pState->dwMask, SELECTION_STATE_DELETABLE))
    {
        // Validate
        Assert(pThis->m_pFindFolder);

        // Get the Folder Type
        IF_FAILEXIT(hr = pThis->m_pFindFolder->GetMessageFolderType(pRow->Message.idMessage, &tyFolder));

        // Get the State
        if (FOLDER_NEWS == tyFolder)
        {
            // Set the State
            FLAGSET(pState->dwState, SELECTION_STATE_DELETABLE);
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadGetIdList
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadGetIdList(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEIDLIST pList=(LPMESSAGEIDLIST)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadGetIdList");

    // Grow the Id List
    IF_FAILEXIT(hr = pThis->_GrowIdList(pList, 1));

    // Insert Id
    pList->prgidMsg[pList->cMsgs++] = pRow->Message.idMessage;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadGetState
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadGetState(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    LPGETTHREADSTATE pGetState = (LPGETTHREADSTATE)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadGetState");

    // Children
    pGetState->cChildren++;

    // Is Unread
    if (0 != (pRow->Message.dwFlags & pGetState->dwFlags))
        pGetState->cHasFlags++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadClearState
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadClearState(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Trace
    TraceCall("CMessageTable::_WalkThreadClearState");

    // Clear State
    pRow->dwState = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadIsFromMe
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadIsFromMe(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    LPTHREADISFROMME pIsFromMe = (LPTHREADISFROMME)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadIsFromMe");

    // m_pszEmail or pszEmailFrom is null
    if (NULL == pRow->Message.pszEmailFrom)
        return(S_OK);

    // Compare
    if (pThis->m_pszEmail && 0 == lstrcmpi(pThis->m_pszEmail, pRow->Message.pszEmailFrom))
    {
        // This thread is from me
        pIsFromMe->fResult = TRUE;

        // Set the Row
        pIsFromMe->pRow = pRow;

        // Override the highlight
        pRow->Message.wHighlight = pThis->m_clrWatched;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadHide
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadHide(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    LPTHREADHIDE pHide = (LPTHREADHIDE)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadHide");

    // Hide this row
    pThis->_HideRow(pRow, pHide->fNotify);

    // If not filtered
    pThis->_AdjustUnreadCount(pRow, -1);

    // Mark Row as Filtered
    pRow->fFiltered = TRUE;

    // Increment m_cFiltered
    pThis->m_cFiltered++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_GrowIdList
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GrowIdList(LPMESSAGEIDLIST pList, DWORD cNeeded)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CMessageTable::_GrowIdList");

    // Allocate
    if (pList->cMsgs + cNeeded > pList->cAllocated)
    {
        // Compute cGrow
        DWORD cGrow = max(32, cNeeded);

        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&pList->prgidMsg, sizeof(MESSAGEID) * (pList->cAllocated + cGrow)));

        // Increment dwREserved
        pList->cAllocated += cGrow;
    }
exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// EnumerateRefs
// --------------------------------------------------------------------------------
HRESULT EnumerateRefs(LPCSTR pszReferences, DWORD_PTR dwCookie, PFNENUMREFS pfnEnumRefs)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cchRefs;
    LPSTR           pszRefs;
    LPSTR           pszFree=NULL;
    LPSTR           pszT;
    BOOL            fDone=FALSE;
    CHAR            szBuffer[1024];

    // Trace
    TraceCall("EnumerateRefs");

    // If the message has a references line
    if (NULL == pszReferences || '\0' == *pszReferences)
        return(S_OK);

    // Get Length
    cchRefs = lstrlen(pszReferences);

    // Use Buffer ?
    if (cchRefs + 1 <= ARRAYSIZE(szBuffer))
        pszRefs = szBuffer;

    // Otherwise, duplicate it
    else
    {
        // Allocate Memory
        IF_NULLEXIT(pszFree = (LPSTR)g_pMalloc->Alloc(cchRefs + 1));

        // Set pszRefs
        pszRefs = pszFree;
    }

    // Copy It
    CopyMemory(pszRefs, pszReferences, cchRefs + 1);

    // Set pszT
    pszT = (LPSTR)(pszRefs + cchRefs - 1);

    // Strip
    while (pszT > pszRefs && *pszT != '>')
        *pszT-- = '\0';

    // We have have ids
    while (pszT >= pszRefs)
    {
        // Start of message Id ?
        if (*pszT == '<')
        {
            // Callback function
            (*pfnEnumRefs)(pszT, dwCookie, &fDone);

            // Done
            if (fDone)
                goto exit;

            // Strip
            while (pszT > pszRefs && *pszT != '>')
                *pszT-- = '\0';
        }

        // Decrement
        pszT--;
    }

exit:
    // Cleanup
    SafeMemFree(pszFree);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRelativeRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::IsChild(ROWINDEX iRowParent, ROWINDEX iRowChild)
{
    // Locals
    HRESULT             hr=S_FALSE;
    LPROWINFO           pRow;
    LPROWINFO           pRowParent;

    // Trace
    TraceCall("CMessageTable::IsChild");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Failure
    IF_FAILEXIT(hr = _GetRowFromIndex(iRowChild, &pRow));
    IF_FAILEXIT(hr = _GetRowFromIndex(iRowParent, &pRowParent));

    // Loop through all the parents of the child row to see if we find the
    // specified parent row.
    while (pRow->pParent)
    {
        if (pRow->pParent == pRowParent)
        {
            hr = S_OK;
            goto exit;
        }

        pRow = pRow->pParent;
    }
    hr = S_FALSE;

exit:
    return (hr);
}

STDMETHODIMP CMessageTable::GetAdBarUrl(IStoreCallback *pCallback)
{
    HRESULT     hr = S_OK;

    // Trace
    TraceCall("CMessageTable::GetAdBarUrl");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Tell the Folder to Synch
    IF_FAILEXIT(hr = m_pFolder->GetAdBarUrl(pCallback));

exit:
    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\msgtable.h ===
//--------------------------------------------------------------------------
// MsgTable.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decl.
//--------------------------------------------------------------------------
class CFindFolder;
class CMessageTable;

//--------------------------------------------------------------------------
// SafeReleaseRow
//--------------------------------------------------------------------------
#define SafeReleaseRow(_pTable, _pMessage) \
    if (_pMessage) { \
        _pTable->ReleaseRow(_pMessage); \
        _pMessage = NULL; \
    }

//--------------------------------------------------------------------------
// WALKTHREADFLAGS
//--------------------------------------------------------------------------
typedef DWORD WALKTHREADFLAGS;
#define WALK_THREAD_CURRENT      0x00000001
#define WALK_THREAD_BOTTOMUP     0x00000020

//--------------------------------------------------------------------------
// SORTCHANGEINFO
//--------------------------------------------------------------------------
typedef struct tagSORTCHANGEINFO {
    BYTE                fSort;
    BYTE                fThread;
    BYTE                fFilter;
    BYTE                fExpand;
} SORTCHANGEINFO, *LPSORTCHANGEINFO;

//--------------------------------------------------------------------------
// ROWINFO
//--------------------------------------------------------------------------
typedef struct tagROWINFO *LPROWINFO;
typedef struct tagROWINFO {
    BYTE                cRefs;
    ROWSTATE            dwState;
    LPROWINFO           pParent;
    LPROWINFO           pChild;
    LPROWINFO           pSibling;
    WORD                wHighlight;
    unsigned            fExpanded : 1;  // A thread parent that is expanded
    unsigned            fVisible  : 1;  // Is displayed in the m_prgpView index
    unsigned            fFiltered : 1;  // Filtered and won't be displayed until filter changes
    unsigned            fHidden   : 1;  // Hidden, but if row is changed it may become visible.
    unsigned            fDelayed  : 1;  // Delayed Insert
    MESSAGEINFO         Message;
} ROWINFO;

//--------------------------------------------------------------------------
// NOTIFYQUEUE
//--------------------------------------------------------------------------
typedef struct tagNOTIFYQUEUE {
    BOOL                fClean;
    TRANSACTIONTYPE     tyCurrent;
    ROWINDEX            iRowMin;
    ROWINDEX            iRowMax;
    DWORD               cUpdate;
    DWORD               cAllocated;
    DWORD               cRows;
    BYTE                fIsExpandCollapse;
    LPROWINDEX          prgiRow;
} NOTIFYQUEUE, *LPNOTIFYQUEUE;

//--------------------------------------------------------------------------
// PFWALKTHREADCALLBACK
//--------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFWALKTHREADCALLBACK)(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie);

//--------------------------------------------------------------------------
// PFNENUMREFS
//--------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNENUMREFS)(LPCSTR pszMessageId, DWORD_PTR dwCookie,
    BOOL *pfDone);

//--------------------------------------------------------------------------
// CMessageTable
//--------------------------------------------------------------------------
class CMessageTable : public IMessageTable,
                      public IDatabaseNotify,
                      public IServiceProvider,
                      public IOperationCancel

{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CMessageTable(void);
    ~CMessageTable(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageTable Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(FOLDERID idFolder, IMessageServer *pServer, BOOL fFindTable, IStoreCallback *pCallback);
    STDMETHODIMP StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback);
    STDMETHODIMP Close(void);
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback);
    STDMETHODIMP OnSynchronizeComplete(void);
    STDMETHODIMP GetCount(GETCOUNTTYPE tyCount, DWORD *pdwCount);
    STDMETHODIMP GetRow(ROWINDEX iRow, LPMESSAGEINFO *ppData);
    STDMETHODIMP ReleaseRow(LPMESSAGEINFO pInfo);
    STDMETHODIMP GetRelativeRow(ROWINDEX iRow, RELATIVEROWTYPE tyRelative, LPROWINDEX piRelative);
    STDMETHODIMP GetIndentLevel(ROWINDEX iRow, LPDWORD pcIndent);            
    STDMETHODIMP Mark(LPROWINDEX prgiView, DWORD cRows, APPLYCHILDRENTYPE tyApply, MARK_TYPE mark, IStoreCallback *pCallback);
    STDMETHODIMP GetSortInfo(LPFOLDERSORTINFO pSortInfo);
    STDMETHODIMP SetSortInfo(LPFOLDERSORTINFO pSortInfo, IStoreCallback *pCallback);
    STDMETHODIMP GetLanguage(ROWINDEX iRow, LPDWORD pdwCodePage);
    STDMETHODIMP SetLanguage(DWORD cRows, LPROWINDEX prgiRow, DWORD dwCodePage);
    STDMETHODIMP GetNextRow(ROWINDEX iCurrentRow, GETNEXTTYPE tyDirection, ROWMESSAGETYPE tyMessage, GETNEXTFLAGS dwFlags, LPROWINDEX piNewRow);
    STDMETHODIMP GetRowState(ROWINDEX iRow, ROWSTATE dwStateMask, ROWSTATE *pdwState);
    STDMETHODIMP GetSelectionState(DWORD cRows, LPROWINDEX prgiView, SELECTIONSTATE dwMask, BOOL fIncludeChildren, SELECTIONSTATE *pdwState);
    STDMETHODIMP Expand(ROWINDEX iRow);
    STDMETHODIMP Collapse(ROWINDEX iRow);
    STDMETHODIMP OpenMessage(ROWINDEX iRow, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP GetRowMessageId(ROWINDEX iRow, LPMESSAGEID pidMessage);
    STDMETHODIMP GetRowIndex(MESSAGEID idMessage, LPROWINDEX piView);
    STDMETHODIMP DeleteRows(DELETEMESSAGEFLAGS dwFlags, DWORD cRows, LPROWINDEX prgiView, BOOL fIncludeChildren, IStoreCallback *pCallback);
    STDMETHODIMP CopyRows(FOLDERID idFolder, COPYMESSAGEFLAGS dwOptions, DWORD cRows, LPROWINDEX prgiView, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback);
    STDMETHODIMP RegisterNotify(REGISTERNOTIFYFLAGS dwFlags, IMessageTableNotify *pNotify);
    STDMETHODIMP UnregisterNotify(IMessageTableNotify *pNotify);
    STDMETHODIMP FindNextRow(ROWINDEX iStartRow, LPCTSTR pszFindString, FINDNEXTFLAGS dwFlags, BOOL fIncludeBody, ROWINDEX *piNextRow, BOOL *pfWrapped);
    STDMETHODIMP GetRowFolderId(ROWINDEX iRow, LPFOLDERID pidFolder);
    STDMETHODIMP GetMessageIdList(BOOL fRootsOnly, DWORD cRows, LPROWINDEX prgiView, LPMESSAGEIDLIST pIdList);
    STDMETHODIMP ConnectionAddRef(void);
    STDMETHODIMP ConnectionRelease(void);
    STDMETHODIMP IsChild(ROWINDEX iRowParent, ROWINDEX iRowChild);
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IDatabaseNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

    //----------------------------------------------------------------------
    // IServiceProvider 
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IOperationCancel
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel) { return(S_OK); }

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _CreateRow(LPMESSAGEINFO pMessage, LPROWINFO *ppRow);
    HRESULT _InsertRowIntoThread(LPROWINFO pRow, BOOL fNotify);
    HRESULT _DeleteRowFromThread(LPROWINFO pRow, BOOL fNotify);
    HRESULT _FreeTable(void);
    HRESULT _FreeTableElements(void);
    HRESULT _BuildTable(IStoreCallback *pCallback);
    HRESULT _WalkMessageThread(LPROWINFO pRow, WALKTHREADFLAGS dwFlags, DWORD_PTR dwCookie, PFWALKTHREADCALLBACK pfnCallback);
    HRESULT _RowTableInsert(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage);
    HRESULT _RowTableDelete(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage);
    HRESULT _RowTableUpdate(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage);
    HRESULT _GetRowFromIndex(ROWINDEX iRow, LPROWINFO *ppRow);
    HRESULT _LinkRowIntoThread(LPROWINFO pParent, LPROWINFO pRow, BOOL fNotify);
    HRESULT _GrowIdList(LPMESSAGEIDLIST pList, DWORD cNeeded);
    HRESULT _ExpandThread(ROWINDEX iRow, BOOL fNotify, BOOL fReExpand);
    HRESULT _ExpandSingleThread(LPROWINDEX piCurrent, LPROWINFO pParent, BOOL fNotify, BOOL fForceExpand);
    HRESULT _CollapseThread(ROWINDEX iRow, BOOL fNotify);
    HRESULT _CollapseSingleThread(LPROWINDEX piCurrent, LPROWINFO pParent, BOOL fNotify);
    HRESULT _InsertIntoView(ROWINDEX iRow, LPROWINFO pRow);
    HRESULT _DeleteFromView(ROWINDEX iRow, LPROWINFO pRow);
    HRESULT _GetRowFromOrdinal(ROWORDINAL iOrdinal, LPMESSAGEINFO pExpected, LPROWINFO *ppRow);
    HRESULT _AdjustUnreadCount(LPROWINFO pRow, LONG lCount);
    HRESULT _GetThreadIndexRange(LPROWINFO pRow, BOOL fClearState, LPROWINDEX piMin, LPROWINDEX piMax);
    HRESULT _IsThreadImportance(LPROWINFO pRow, MESSAGEFLAGS dwFlag, ROWSTATE dwState, ROWSTATE *pdwState);
    HRESULT _QueueNotification(TRANSACTIONTYPE tyTransaction, ROWINDEX iRowMin, ROWINDEX iRowMax, BOOL fIsExpandCollapse=FALSE);
    HRESULT _FlushNotificationQueue(BOOL fFinal);
    HRESULT _GetSortChangeInfo(LPFOLDERSORTINFO pSortInfo, LPFOLDERUSERDATA pUserData, LPSORTCHANGEINFO pChange);
    HRESULT _SortThreadFilterTable(LPSORTCHANGEINFO pChange, BOOL fApplyFilter);
    HRESULT _SortAndThreadTable(BOOL fApplyFilter);
    HRESULT _HideRow(LPROWINFO pRow, BOOL fNotify);
    HRESULT _ShowRow(LPROWINFO pRow);
    HRESULT _PruneToReplies(void);
    HRESULT _FindThreadParentByRef(LPCSTR pszReferences, LPROWINFO *ppParent);
    HRESULT _RefreshFilter(void);

    //----------------------------------------------------------------------
    // Utilities
    //----------------------------------------------------------------------
    VOID        _SortView(LONG left, LONG right);
    LONG        _CompareMessages(LPMESSAGEINFO pMsg1, LPMESSAGEINFO pMsg2);
    BOOL        _FIsFiltered(LPROWINFO pRow);
    BOOL        _FIsHidden(LPROWINFO pRow);
    LPROWINFO   _PGetThreadRoot(LPROWINFO pRow);

    //----------------------------------------------------------------------
    // Friends
    //----------------------------------------------------------------------
    static HRESULT _WalkThreadGetSelectionState(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadGetIdList(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadGetState(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadClearState(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadIsFromMe(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadHide(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                 m_cRef;                // Reference Counting
    BOOL                 m_fSynching;           // Are we synching a folder ?
    DWORD                m_cAllocated;          // Allocated elements in m_prgRow and m_prgiView
    DWORD                m_cRows;               // Rows...
    DWORD                m_cView;               // Number of items in the listview
    DWORD                m_cFiltered;           // Number of rows that were filtered
    DWORD                m_cUnread;             // Number of unread rows in m_prgpRow
    LPROWINFO           *m_prgpRow;             // Array of Pointers to Rows
    LPROWINFO           *m_prgpView;            // Current View
    FOLDERSORTINFO       m_SortInfo;            // Folder Sort Info
    IMessageFolder      *m_pFolder;             // Base Folder
    IDatabase           *m_pDB;                 // The Database
    CFindFolder         *m_pFindFolder;         // Find Folder
    IMessageTableNotify *m_pNotify;             // usually the message list
    BYTE                 m_fRelNotify;          // Release m_pNotify?
    IDatabaseQuery      *m_pQuery;              // Query Object
    NOTIFYQUEUE          m_Notify;              // Notify Queue
    FOLDERINFO           m_Folder;              // Folder Information
    DWORD                m_cDelayed;            // Number of news messages not insert into view
    BYTE                 m_fRegistered;         // Registered for Notifications
    BYTE                 m_fLoaded;             // The first load has completed.
    WORD                 m_clrWatched;          // Watched Color
    LPSTR                m_pszEmail;            // Email Address to use for show replies filter
    IHashTable          *m_pThreadMsgId;        // Message-ID Hash Table for Threading
    IHashTable          *m_pThreadSubject;      // Message-ID Hash Table for Threading
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT EnumerateRefs(LPCSTR pszReferences, DWORD_PTR dwCookie, PFNENUMREFS pfnEnumRefs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\newfldr.cpp ===
//--------------------------------------------------------------------------
// Newfldr.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "imagelst.h"
#include "newfldr.h"
#include <ourguid.h>
#include "conman.h"
#include "storutil.h"
#include "storecb.h"
#include "shlwapip.h" 
#include "instance.h"
#include "demand.h"

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define WM_SETFOLDERSELECT  (WM_USER + 1666)

//--------------------------------------------------------------------------
// SELECTFOLDER
//--------------------------------------------------------------------------
typedef struct tagSELECTFOLDER {
    DWORD               op;
    FOLDERID            idCurrent;      // Current Selected Folder
    FOLDERDIALOGFLAGS   dwFlags;        // Folder dialog flags
    LPSTR               pszTitle;       // Title of the dialog box
    LPSTR               pszText;        // Why are you asking for a folder
    FOLDERID            idSelected;     // The selected folder
    CTreeViewFrame     *pFrame;         // Treeview frame object

    BOOL                fPending;
    CStoreDlgCB        *pCallback;
    FOLDERID            idParent;
    char                szName[CCHMAX_FOLDER_NAME];
} SELECTFOLDER, *LPSELECTFOLDER;

//--------------------------------------------------------------------------
// NEWFOLDERDIALOGINIT
//--------------------------------------------------------------------------
typedef struct tagNEWFOLDERDIALOGINIT {
    IN  FOLDERID        idParent;
    OUT FOLDERID        idNew;
    
        BOOL            fPending;
    IN  CStoreDlgCB    *pCallback;
        char            szName[CCHMAX_FOLDER_NAME];
} NEWFOLDERDIALOGINIT, *LPNEWFOLDERDIALOGINIT;

//--------------------------------------------------------------------------
// SelectFolderDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK SelectFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT CreateNewFolder(HWND hwnd, LPCSTR pszName, FOLDERID idParent, LPFOLDERID pidNew, IStoreCallback *pCallback);
BOOL EnabledFolder(HWND hwnd, LPSELECTFOLDER pSelect, FOLDERID idFolder);
HRESULT GetCreatedFolderId(FOLDERID idParent, LPCSTR pszName, FOLDERID *pid);
BOOL SelectFolder_HandleCommand(HWND hwnd, WORD wID, LPSELECTFOLDER pSelect);
void SelectFolder_HandleStoreComplete(HWND hwnd, LPSELECTFOLDER pSelect);

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
static FOLDERID g_idPrevSel = FOLDERID_LOCAL_STORE;

//--------------------------------------------------------------------------
// SelectFolderDialog
//--------------------------------------------------------------------------
HRESULT SelectFolderDialog(
    IN      HWND                hwnd,
    IN      DWORD               op,
    IN      FOLDERID            idCurrent,
    IN      FOLDERDIALOGFLAGS   dwFlags,
    IN_OPT  LPCSTR              pszTitle,
    IN_OPT  LPCSTR              pszText,
    OUT_OPT LPFOLDERID          pidSelected)
{
    // Locals
    HRESULT         hr=S_OK;
    UINT            uAnswer;
    SELECTFOLDER    Select={0};

    // Trace
    TraceCall("SelectFolderDialog");

    // Invalid Args
    Assert(IsWindow(hwnd));
    Assert(((int) op) >= SFD_SELECTFOLDER && op < SFD_LAST);

    // Initialize Select Folder
    Select.op = op;
    if (SFD_MOVEFOLDER == op || (!!(dwFlags & FD_FORCEINITSELFOLDER) && FOLDERID_ROOT != idCurrent))
    {
        Assert(idCurrent != FOLDERID_INVALID);
        Select.idCurrent = idCurrent;
    }
    else
    {
        Select.idCurrent = g_idPrevSel;
    }
    Select.dwFlags = dwFlags | TREEVIEW_DIALOG;

    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
        Select.dwFlags |= TREEVIEW_NOIMAP | TREEVIEW_NOHTTP;

    Select.pszTitle = (LPSTR)pszTitle;
    Select.pszText = (LPSTR)pszText;
    Select.pCallback = new CStoreDlgCB;
    if (Select.pCallback == NULL)
        return(E_OUTOFMEMORY);

    // Create the Dialog Box
    if (IDOK != DialogBoxParam(g_hLocRes, ((op == SFD_NEWFOLDER) ? MAKEINTRESOURCE(iddCreateFolder) : MAKEINTRESOURCE(iddSelectFolder)), hwnd, SelectFolderDlgProc, (LPARAM)&Select))
    {
        hr = TraceResult(hrUserCancel);
        goto exit;
    }

    // Return selected folderid
    g_idPrevSel = Select.idSelected;
    if (pidSelected)
        *pidSelected = Select.idSelected;

exit:
    Select.pCallback->Release();

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// SelectFolderDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK SelectFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    FOLDERINFO              info;
    HRESULT                 hr;
    BOOL                    fEnable;
    LPSELECTFOLDER          pSelect;
    HWND                    hwndT;
    HWND                    hwndTree;
    CHAR                    sz[256];
    WORD                    wID;
    RECT                    rc;
    FOLDERID                id;
    NEWFOLDERDIALOGINIT     NewFolder;
    FOLDERINFO              Folder;
    CTreeView              *pTreeView;

    // Trace
    TraceCall("SelectFolderDlgProc");

    // Get pSelect
    pSelect = (LPSELECTFOLDER)GetWndThisPtr(hwnd);

    switch (msg)
    {
    case WM_INITDIALOG:
        // Better not have it yet
        Assert(NULL == pSelect);

        // Set pSelect
        pSelect = (LPSELECTFOLDER)lParam;

        // Set This pointer
        SetWndThisPtr(hwnd, (LPSELECTFOLDER)lParam);

        if (pSelect->op != SFD_SELECTFOLDER)
        {
            Assert(pSelect->pCallback != NULL);
            pSelect->pCallback->Initialize(hwnd);
        }

        if (pSelect->op == SFD_NEWFOLDER)
        {
            hwndT = GetDlgItem(hwnd, idcFolderEdit);
            SetIntlFont(hwndT);
            SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_FOLDER_NAME - 1, 0);
        }
        else if (ISFLAGSET(pSelect->dwFlags, FD_NONEWFOLDERS))
        {
            ShowWindow(GetDlgItem(hwnd, idcNewFolderBtn), SW_HIDE);
        }

        // Set the title
        if (pSelect->pszTitle != NULL)
        {
            // Must be a string resourceid
            if (IS_INTRESOURCE(pSelect->pszTitle))
            {
                // Load the String
                AthLoadString(PtrToUlong(pSelect->pszTitle), sz, ARRAYSIZE(sz));

                // Set Temp
                SetWindowText(hwnd, sz);
            }

            // Otherwise, just use the string
            else
                SetWindowText(hwnd, pSelect->pszTitle);
        }

        // Do we have some status text
        if (pSelect->pszText != NULL)
        {
            // Must be a resource string id
            if (IS_INTRESOURCE(pSelect->pszText))
            {
                // Load the String
                AthLoadString(PtrToUlong(pSelect->pszText), sz, ARRAYSIZE(sz));

                // Set Temp
                SetWindowText(GetDlgItem(hwnd, idcTreeViewText), sz);
            }

            // Otherwise, just use the string
            else
                SetWindowText(GetDlgItem(hwnd, idcTreeViewText), pSelect->pszText);
        }

        // Set the treeview font
        hwndT = GetDlgItem(hwnd, idcTreeView);
        Assert(hwndT != NULL);
        SetIntlFont(hwndT);
        GetWindowRect(hwndT, &rc);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
        DestroyWindow(hwndT);

        // Create a Frame
        pSelect->pFrame = new CTreeViewFrame;
        if (NULL == pSelect->pFrame)
        {
            EndDialog(hwnd, IDCANCEL);
            return FALSE;
        }

        // Initialzie the tree view frame
        if (FAILED(pSelect->pFrame->Initialize(hwnd, &rc, (TREEVIEW_FLAGS & pSelect->dwFlags))))
        {
            EndDialog(hwnd, IDCANCEL);
            return FALSE;
        }

        // Get the Tree View Object from the Frame
        pTreeView = pSelect->pFrame->GetTreeView();

        // Get the Window Handle
        if (SUCCEEDED(pTreeView->GetWindow(&hwndTree)))
        {
            hwndT = GetDlgItem(hwnd, idcTreeViewText);
            SetWindowPos(hwndTree, hwndT, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOREDRAW | SWP_NOSIZE);
        }

        // Refresh the Treeview
        pTreeView->Refresh();

        // Set current selection
        if (FAILED(pTreeView->SetSelection(pSelect->idCurrent, 0)))
        {
            pSelect->idCurrent = g_idPrevSel;
            
            pTreeView->SetSelection(pSelect->idCurrent, 0);
        }

        // Center Myself
        CenterDialog(hwnd);

        // Done
        return(TRUE);           

    case WM_SETFOLDERSELECT:

        // Validate Params
        Assert(wParam != NULL && pSelect != NULL);

        // Get the Tree View Object
        pTreeView = pSelect->pFrame->GetTreeView();

        // Validate
        Assert(pTreeView != NULL);

        // Set current selection
        pTreeView->SetSelection((FOLDERID)wParam, 0);

        // Done
        return(TRUE);           

    case WM_STORE_COMPLETE:
        SelectFolder_HandleStoreComplete(hwnd, pSelect);
        return(TRUE);

    case WM_COMMAND:

        // Get the Command Id
        wID = LOWORD(wParam);

        return(SelectFolder_HandleCommand(hwnd, wID, pSelect));

    case TVM_SELCHANGED:

        // Possibly disable choosing the newly selected folder based on flags we were given
        fEnable = EnabledFolder(hwnd, pSelect, (FOLDERID)lParam);

        // Enable the OK Button
        EnableWindow(GetDlgItem(hwnd, IDOK), fEnable);

        // Get the new folder button hwnd
        hwndT = GetDlgItem(hwnd, SFD_SELECTFOLDER == pSelect->op ? idcNewFolderBtn : IDOK);
        if (hwndT != NULL)
        {
            // Get Folder Info
            if (SUCCEEDED(g_pStore->GetFolderInfo((FOLDERID)lParam, &Folder)))
            {
                // fEnable
                fEnable = Folder.idFolder != FOLDERID_ROOT &&
                          Folder.tyFolder != FOLDER_NEWS &&
                          !ISFLAGSET(Folder.dwFlags, FOLDER_NOCHILDCREATE);

                // Enable/disable the window
                EnableWindow(hwndT, fEnable);

                // Free
                g_pStore->FreeRecord(&Folder);
            }
        }

        // Done
        return(TRUE);

    case TVM_DBLCLICK:
        // If Not Creating a Folder:
        if (pSelect->op != SFD_NEWFOLDER)    
        {
            // If the OK button isn't enabled, I can't select this folder
            if (FALSE == IsWindowEnabled(GetDlgItem(hwnd, IDOK)))
                return(TRUE);

            pTreeView = pSelect->pFrame->GetTreeView();

            id = pTreeView->GetSelection();

            hr = g_pStore->GetFolderInfo(id, &info);
            if (SUCCEEDED(hr))
            {
                if (!FHasChildren(&info, TRUE))
                    SelectFolder_HandleCommand(hwnd, IDOK, pSelect);

                g_pStore->FreeRecord(&info);
            }
        }
        // Done
        return(TRUE);

    case WM_DESTROY:

        // Close the Tree View
        if (pSelect != NULL && pSelect->pFrame != NULL)
        {
            // Close the TreeView
            pSelect->pFrame->CloseTreeView();

            // Release the Frame
            SideAssert(pSelect->pFrame->Release() == 0);
        }

        // Done
        return(TRUE);
    }

    // Done
    return(FALSE);
}

//--------------------------------------------------------------------------
// SelectFolderDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK NewFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    HRESULT                  hr;
    LPNEWFOLDERDIALOGINIT    pNew;
    WORD                     wID;
    FOLDERID                 id;
    HWND                     hwndEdit;

    // Trace
    TraceCall("NewFolderDlgProc");

    // Get This
    pNew = (LPNEWFOLDERDIALOGINIT)GetWndThisPtr(hwnd);

    // Handle the Message
    switch (msg)
    {
    case WM_INITDIALOG:

        // Shouldn't Have This
        Assert(pNew == NULL);

        // Set pNew
        pNew = (LPNEWFOLDERDIALOGINIT)lParam;

        // Set this Pointer
        SetWndThisPtr(hwnd, (LPNEWFOLDERDIALOGINIT)lParam);

        Assert(pNew->pCallback != NULL);
        pNew->pCallback->Initialize(hwnd);

        // Get the Folder Name Edit
        hwndEdit = GetDlgItem(hwnd, idtxtFolderName);

        // Correct for intl.
        SetIntlFont(hwndEdit);

        // Limit the text
        SendMessage(hwndEdit, EM_LIMITTEXT, CCHMAX_FOLDER_NAME - 1, 0);

        // Center
        CenterDialog(hwnd);

        // Done
        return(TRUE);

    case WM_STORE_COMPLETE:
        Assert(pNew->fPending);
        pNew->fPending = FALSE;

        hr = pNew->pCallback->GetResult();
        if (hr == S_FALSE)
        {
            EndDialog(hwnd, IDCANCEL);
        }
        else if (SUCCEEDED(hr))
        {
            hr = GetCreatedFolderId(pNew->idParent, pNew->szName, &id);
            if (SUCCEEDED(hr))
                pNew->idNew = id;
            else
                pNew->idNew = pNew->idParent;
            EndDialog(hwnd, IDOK);
        }
        else
        {
            // No need to put up error dialog, CStoreDlgCB already did this on failed OnComplete
            hwndEdit = GetDlgItem(hwnd, idtxtFolderName);
            SendMessage(hwndEdit, EM_SETSEL, 0, -1);
            SetFocus(hwndEdit);
        }
        return(TRUE);

    case WM_COMMAND:

        // Get the Command Id
        wID = LOWORD(wParam);

        // Handle the Command
        switch (wID)
        {
        case IDOK:
            if (pNew->fPending)
                return(TRUE);

            Assert(pNew->pCallback != NULL);
            pNew->pCallback->Reset();

            hwndEdit = GetDlgItem(hwnd, idtxtFolderName);
            GetWindowText(hwndEdit, pNew->szName, ARRAYSIZE(pNew->szName));

            // Try to Create the Folder
            hr = CreateNewFolder(hwnd, pNew->szName, pNew->idParent, &pNew->idNew, (IStoreCallback *)pNew->pCallback);
            if (hr == E_PENDING)
            {
                pNew->fPending = TRUE;
                break;
            }
            else if (FAILED(hr))
            {
                AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCreateNewFld), hr);
                SendMessage(hwndEdit, EM_SETSEL, 0, -1);
                SetFocus(hwndEdit);
                break;
            }

            // End the dialog
            EndDialog(hwnd, IDOK);

            // done
            return(TRUE);

        case IDCANCEL:

            if (pNew->fPending)
                pNew->pCallback->Cancel();
            else    
                // End the dialog
                EndDialog(hwnd, IDCANCEL);

            // Done
            return(TRUE);
        }

        // Done
        break;
    }

    // Done
    return(FALSE);
}

//--------------------------------------------------------------------------
// CreateNewFolder
//--------------------------------------------------------------------------
HRESULT CreateNewFolder(HWND hwnd, LPCSTR pszName, FOLDERID idParent, LPFOLDERID pidNew, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr;
    ULONG           cchFolder;
    FOLDERINFO      Folder;

    // Trace
    TraceCall("CreateNewFolder");

    Assert(pCallback != NULL);

    // Get Text Length
    cchFolder = lstrlen(pszName);

    // Invalid
    if (0 == cchFolder)
        return(STORE_E_BADFOLDERNAME);

    // Filup the Folder Info
    ZeroMemory(&Folder, sizeof(FOLDERINFO));
    Folder.idParent = idParent;
    Folder.tySpecial = FOLDER_NOTSPECIAL;
    Folder.pszName = (LPSTR)pszName;
    Folder.dwFlags = FOLDER_SUBSCRIBED;

    // Create the Folder
    hr = g_pStore->CreateFolder(NOFLAGS, &Folder, pCallback);
    if (hr == E_PENDING)
        return(hr);

    // Return the Folder Id
    if (pidNew)
        *pidNew = Folder.idFolder;

    // Done
    return (hr);
}

//--------------------------------------------------------------------------
// EnabledFolder
//--------------------------------------------------------------------------
BOOL EnabledFolder(HWND hwnd, LPSELECTFOLDER pSelect, FOLDERID idFolder)
{
    // Locals
    BOOL fRet = FALSE;
    FOLDERINFO Folder;

    // Trace
    TraceCall("EnabledFolder");

    // Get Folder Info
    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        goto exit;

    // FD_DISABLEROOT
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLEROOT) && FOLDERID_ROOT == idFolder)
        goto exit;

    // FD_DISABLEINBOX
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLEINBOX) && FOLDER_INBOX == Folder.tySpecial)
        goto exit;

    // FD_DISABLEOUTBOX
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLEOUTBOX) && FOLDER_OUTBOX == Folder.tySpecial)
        goto exit;

    // FD_DISABLESENTITEMS
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLESENTITEMS) && FOLDER_SENT == Folder.tySpecial)
        goto exit;

    // FD_DISABLESERVERS
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLESERVERS) && ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        goto exit;

    fRet = TRUE;

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Default
    return fRet;
}

HRESULT GetCreatedFolderId(FOLDERID idParent, LPCSTR pszName, FOLDERID *pid)
{
    HRESULT hr;
    HLOCK hLock;
    FOLDERINFO Folder = {0};

    Assert(pszName != NULL);
    Assert(pid != NULL);

    hr = g_pStore->Lock(&hLock);
    if (FAILED(hr))
        return(hr);

    Folder.idParent = idParent;
    Folder.pszName = (LPSTR)pszName;

    if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        *pid = Folder.idFolder;

        g_pStore->FreeRecord(&Folder);
    }
    else
    {
        hr = E_FAIL;
    }

    g_pStore->Unlock(&hLock);

    return(hr);
}

BOOL SelectFolder_HandleCommand(HWND hwnd, WORD wID, LPSELECTFOLDER pSelect)
{
    HRESULT                 hr;
    HWND                    hwndT;
    FOLDERID                id=FOLDERID_INVALID;
    NEWFOLDERDIALOGINIT     NewFolder;
    CTreeView              *pTreeView;

    switch (wID)
    {
        case idcNewFolderBtn:
            pTreeView = pSelect->pFrame->GetTreeView();

            ZeroMemory(&NewFolder, sizeof(NEWFOLDERDIALOGINIT));
            NewFolder.idParent = pTreeView->GetSelection();
            NewFolder.pCallback = new CStoreDlgCB;
            if (NewFolder.pCallback == NULL)
                // TODO: an error message might be helpful
                return(TRUE);

            // Launch the dialog to create a new folder
            if (IDOK == DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddNewFolder), hwnd, NewFolderDlgProc, (LPARAM)&NewFolder))
            {
                // Select the new folder
                PostMessage(hwnd, WM_SETFOLDERSELECT, (WPARAM)NewFolder.idNew, 0);
            }

            NewFolder.pCallback->Release();
            return(TRUE);

        case IDOK:
            if (pSelect->fPending)
                return(TRUE);

            pTreeView = pSelect->pFrame->GetTreeView();

            pSelect->idSelected = pTreeView->GetSelection();

            switch (pSelect->op)
            {
                case SFD_SELECTFOLDER:
                    break;

                case SFD_NEWFOLDER:
                    Assert(pSelect->pCallback != NULL);
                    pSelect->pCallback->Reset();

                    hwndT = GetDlgItem(hwnd, idcFolderEdit);
                    GetWindowText(hwndT, pSelect->szName, ARRAYSIZE(pSelect->szName));

                    hr = CreateNewFolder(hwnd, pSelect->szName, pSelect->idSelected, &id, (IStoreCallback *)pSelect->pCallback);
                    if (hr == E_PENDING)
                    {
                        pSelect->fPending = TRUE;
                        pSelect->idParent = pSelect->idSelected;
                        return(TRUE);
                    }
                    else if (STORE_S_ALREADYEXISTS == hr)
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCreateExists), 0, MB_OK | MB_ICONEXCLAMATION);
                        SendMessage(hwndT, EM_SETSEL, 0, -1);
                        SetFocus(hwndT);
                        return(TRUE);
                    }
                    else if (FAILED(hr))
                    {
                        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCreateNewFld), hr);
                        SendMessage(hwndT, EM_SETSEL, 0, -1);
                        SetFocus(hwndT);
                        return(TRUE);
                    }
        
                    pSelect->idSelected = id;
                    break;

                case SFD_MOVEFOLDER:
                    Assert(pSelect->pCallback != NULL);
                    pSelect->pCallback->Reset();

                    hr = g_pStore->MoveFolder(pSelect->idCurrent, pSelect->idSelected, 0, (IStoreCallback *)pSelect->pCallback);
                    if (hr == E_PENDING)
                    {
                        pSelect->fPending = TRUE;
                        return(TRUE);
                    }
                    else if (FAILED(hr))
                    {
                        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrFolderMove), hr);
                        return(TRUE);
                    }
        
                    pSelect->idSelected = id;
                    break;

                default:
                    Assert(FALSE);
                    break;
            }

            EndDialog(hwnd, IDOK);
            return(TRUE);

        case IDCANCEL:
            if (pSelect->fPending)
                pSelect->pCallback->Cancel();
            else
                EndDialog(hwnd, IDCANCEL);
            return(TRUE);
            
        default:
            break;
    }

    return(FALSE);
}

void SelectFolder_HandleStoreComplete(HWND hwnd, LPSELECTFOLDER pSelect)
{
    HRESULT hr;
    FOLDERID id;
    HWND hwndT;

    Assert(pSelect->op != SFD_SELECTFOLDER);
    Assert(pSelect->fPending);
    pSelect->fPending = FALSE;

    hr = pSelect->pCallback->GetResult();
    if (hr == S_FALSE)
    {
        EndDialog(hwnd, IDCANCEL);
        return;
    }

    switch (pSelect->op)
    {
        case SFD_NEWFOLDER:
            if (SUCCEEDED(hr))
            {
                hr = GetCreatedFolderId(pSelect->idParent, pSelect->szName, &id);
                if (SUCCEEDED(hr))
                    pSelect->idSelected = id;
                else
                    pSelect->idSelected = pSelect->idParent;
                EndDialog(hwnd, IDOK);
            }
            else
            {
                // No need to put up error dialog, CStoreDlgCB already did this on failed OnComplete
                hwndT = GetDlgItem(hwnd, idcFolderEdit);
                SendMessage(hwndT, EM_SETSEL, 0, -1);
                SetFocus(hwndT);
            }
            break;

        case SFD_MOVEFOLDER:
            if (SUCCEEDED(hr))
            {
                pSelect->idSelected = pSelect->idCurrent;
                EndDialog(hwnd, IDOK);
            }
            else if (FAILED(hr))
            {
                AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrFolderMove), hr);
            }
            break;

        default:
            Assert(FALSE);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\store.cpp ===
//--------------------------------------------------------------------------
// Store.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "Store.h"
#include "msgfldr.h"
#include "storfldr.h"
#include "storutil.h"
#include "enumfold.h"
#include "findfold.h"
#include "shared.h"
#include <msident.h>
#include "acctutil.h"
#include "xpcomm.h"
#include "multiusr.h"

//--------------------------------------------------------------------------
// CreateMessageStore
//--------------------------------------------------------------------------
static const char c_szSubscribedFilter[] = "(FLDCOL_FLAGS & FOLDER_SUBSCRIBED)";
                                      
//--------------------------------------------------------------------------
// CreateMessageStore
//--------------------------------------------------------------------------
HRESULT CreateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CMessageStore      *pNew;

    // Trace
    TraceCall("CreateMessageStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    IF_NULLEXIT(pNew = new CMessageStore(FALSE));

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMessageStore *);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CreateFolderDatabaseExt
//--------------------------------------------------------------------------
HRESULT CreateFolderDatabaseExt(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateFolderDatabaseExt");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageStore *pNew = new CMessageStore(FALSE);
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IDatabaseExtension *);

    // Done
    return(S_OK);
}


//--------------------------------------------------------------------------
// CreateMigrateMessageStore
//--------------------------------------------------------------------------
HRESULT CreateMigrateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CMessageStore      *pNew;

    // Trace
    TraceCall("CreateMigrateMessageStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    IF_NULLEXIT(pNew = new CMessageStore(TRUE));

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMessageStore *);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::CMessageStore
//--------------------------------------------------------------------------
CMessageStore::CMessageStore(BOOL fMigrate/*=FALSE*/) : m_fMigrate(fMigrate)
{
    TraceCall("CMessageStore::CMessageStore");
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_pszDirectory = NULL;
    m_pDB = NULL;
    m_pSession = NULL;
    m_pActManRel = NULL;
    m_pServerHead = NULL;
}

//--------------------------------------------------------------------------
// CMessageStore::~CMessageStore
//--------------------------------------------------------------------------
CMessageStore::~CMessageStore(void)
{
    // Trace
    TraceCall("CMessageStore::~CMessageStore");

    // Was this a Migrate Session ?
    if (m_fMigrate)
    {
        // Must have m_pUnkRelease
        Assert(g_pAcctMan == m_pActManRel && g_pStore == this);

        // Cleanup
        SafeRelease(m_pActManRel);

        // Clear
        g_pAcctMan = NULL;

        // Clear g_pStore
        g_pStore = NULL;
    }

    // Validate
    Assert(NULL == m_pActManRel);

    // Free Directory
    SafeMemFree(m_pszDirectory);

    // Free Database Table
    SafeRelease(m_pDB);

    // If I have a private session
    if (m_pSession)
    {
        // Must be the same as the global
        Assert(m_pSession == g_pDBSession);

        // Release Session
        m_pSession->Release();

        // Set to Null
        g_pDBSession = m_pSession = NULL;
    }

    // Free m_pServerHead
    LPSERVERFOLDER pCurrent = m_pServerHead;
    LPSERVERFOLDER pNext;

    // While Current
    while(pCurrent)
    {
        // Set Next
        pNext = pCurrent->pNext;

        // Free
        g_pMalloc->Free(pCurrent);

        // Goto next
        pCurrent = pNext;
    }
   
    // Release the Dll
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CMessageStore::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CMessageStore::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageStore *)this;
    else if (IID_IMessageStore == riid)
        *ppv = (IMessageStore *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IDatabaseExtension == riid)
        *ppv = (IDatabaseExtension *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageStore::AddRef(void)
{
    TraceCall("CMessageStore::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CMessageStore::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageStore::Release(void)
{
    TraceCall("CMessageStore::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CMessageStore::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::Initialize(LPCSTR pszDirectory)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    TABLEINDEX      Index;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    STOREUSERDATA   UserData={0};
    LPSTR           pszFilter=NULL;

    // Trace
    TraceCall("CMessageStore::Initialize");

    // Invalid Args
    if (NULL == pszDirectory)
        return TraceResult(E_INVALIDARG);

    // Make sure the directory exists
    if (FALSE == PathIsDirectory(pszDirectory))
    {
        // It doesn't, so create it
        IF_FAILEXIT(hr = OpenDirectory((LPTSTR)pszDirectory));
    }

    // Save the directory
    IF_NULLEXIT(m_pszDirectory = PszDupA(pszDirectory));

    // Build Path to Folders
    IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, c_szFoldersFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

    // If we have g_pDBSession, then use it, otherwise, get one...(happens on store migration)
    if (NULL == g_pDBSession)
    {
        // Create the Session
        IF_FAILEXIT(hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&g_pDBSession));

        // I should release this..;
        m_pSession = g_pDBSession;
    }
        
    // Create an Object Database
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NOADDREFEXT, &g_FolderTableSchema, (IDatabaseExtension *)this, &m_pDB));

    // set Folder
    Folder.idFolder = FOLDERID_ROOT;

    // Is there a root folder ?
    if (DB_S_NOTFOUND == m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Folder, NULL))
    {
        // Locals
        DWORD           idReserved;
        CHAR            szRes[100];

        // Reset the Cache
        IF_FAILEXIT(hr = DeleteAllRecords(&g_FolderTableSchema, m_pDB, NULL));

        // Create the idParent / FolderName Index
        IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_ALL, NULL, &g_FolderNameIndex));

        // Create the idParent / FolderName Index
        IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_SUBSCRIBED, c_szSubscribedFilter, &g_FolderNameIndex));

        // Insert the Root Folder
        Folder.idParent = FOLDERID_INVALID;

        // Set clsidType
        Folder.tyFolder = FOLDER_ROOTNODE;

        // Insert the Root
        Folder.tySpecial = FOLDER_NOTSPECIAL;

        // Load String
        LoadString(g_hLocRes, idsAthena, szRes, ARRAYSIZE(szRes));

        // Get the Name of the Root
        Folder.pszName = szRes;

        // Insert the Record
        IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

        // Generate a couple of ids to prevent collision
        m_pDB->GenerateId(&idReserved);
        m_pDB->GenerateId(&idReserved);

        // Create Time
        GetSystemTimeAsFileTime(&UserData.ftCreated);

        // Don't need to convert to DBX
        UserData.fConvertedToDBX = TRUE;

        // Set the UserData
        IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(STOREUSERDATA)));
    }

    // Otherwise, verify the IINDEX_NAME index
    else
    {
        // Locals
        BOOL fReset=FALSE;

        // Create the idParent / FolderName Index
        if (FAILED(m_pDB->GetIndexInfo(IINDEX_ALL, NULL, &Index)))
            fReset = TRUE;

        // If still noreset, see of indexes are the same
        else if (S_FALSE == CompareTableIndexes(&Index, &g_FolderNameIndex))
            fReset = TRUE;

        // Change the Index
        if (fReset)
        {
            // Create the idParent / FolderName Index
            IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_ALL, NULL, &g_FolderNameIndex));
        }

        // Not Reset
        fReset = FALSE;

        // Create the idParent / FolderName Index
        if (FAILED(m_pDB->GetIndexInfo(IINDEX_SUBSCRIBED, &pszFilter, &Index)))
            fReset = TRUE;

        // If still noreset, see of indexes are the same
        else if (S_FALSE == CompareTableIndexes(&Index, &g_FolderNameIndex))
            fReset = TRUE;

        // If still noreset, see if the filter is different
        else if (NULL == pszFilter || lstrcmpi(pszFilter, c_szSubscribedFilter) != 0)
            fReset = TRUE;

        // Change the Index
        if (fReset)
        {
            // Create the idParent / FolderName Index
            IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_SUBSCRIBED, c_szSubscribedFilter, &g_FolderNameIndex));
        }
    }

    // If this object is being used for migration
    if (m_fMigrate)
    {
        // Validate
        Assert(NULL == g_pStore && NULL == g_pAcctMan);

        // Create manager for ID
        hr = AcctUtil_CreateAccountManagerForIdentity(PGUIDCurrentOrDefault(), &m_pActManRel);

        // Try Something Else
        if (FAILED(hr))
            hr = AcctUtil_CreateAccountManagerForIdentity((GUID *)&UID_GIBC_DEFAULT_USER, &m_pActManRel);

        // Failure
        if (FAILED(hr))
            goto exit;

        // Set Global
        g_pAcctMan = m_pActManRel;

        // Set g_pStore
        g_pStore = this;
    }

exit:
    // Cleanup
    if (m_pDB)
        m_pDB->FreeRecord(&Folder);
    SafeMemFree(pszFilter);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::MigrateToDBX
//--------------------------------------------------------------------------
HRESULT CMessageStore::MigrateToDBX(void)
{
    // Locals
    HRESULT         hr=S_OK;
    STOREUSERDATA   UserData;

    // Get the User Data
    if(m_pDB == NULL)
        return(E_OUTOFMEMORY);

    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(STOREUSERDATA)));

    // ConvertedToDBX ?
    if (UserData.fConvertedToDBX)
        goto exit;

    // Convert to DBX
    IF_FAILEXIT(hr = GetRidOfMessagesODSFile());

    // Converted
    UserData.fConvertedToDBX = TRUE;

    // Store the UserDat
    IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(STOREUSERDATA)));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::Validate
//--------------------------------------------------------------------------
HRESULT CMessageStore::Validate(STOREVALIDATEFLAGS dwFlags)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    FOLDERID            idServer;
    CHAR                szAccountId[CCHMAX_ACCOUNT_NAME], szFolder[CCHMAX_FOLDER_NAME];
    IEnumerateFolders  *pChildren=NULL;
    IImnEnumAccounts   *pEnum=NULL;
    IImnAccount        *pAccount=NULL;

    // Trace
    TraceCall("CMessageStore::Validate");

    // Validate
    Assert(g_pAcctMan);

    // Don't Sync With Accounts ?
    if (!ISFLAGSET(dwFlags, STORE_VALIDATE_DONTSYNCWITHACCOUNTS))
    {
        // Enumerate Folders
        IF_FAILEXIT(hr = EnumChildren(FOLDERID_ROOT, TRUE, &pChildren));

        // Enumerate the top-level servers in the store
        while (S_OK == pChildren->Next(1, &Folder, NULL))
        {
            // Does Folder.szAccountId exist in the Account Manager ?
            if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Folder.pszAccountId, &pAccount)) && lstrcmp(STR_LOCALSTORE, Folder.pszAccountId) != 0)
            {
                // Delete this server node
                DeleteFolder(Folder.idFolder, DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_NOTRASHCAN, NOSTORECALLBACK);
            }

            // Otherwise, release
            else
                SafeRelease(pAccount);

            // Cleanup
            m_pDB->FreeRecord(&Folder);
        }
    }

    // local store
    if (FAILED(GetFolderInfo(FOLDERID_LOCAL_STORE, &Folder)))
    {
        // Create the Store
        IF_FAILEXIT(hr = CreateServer(NULL, NOFLAGS, &idServer));

        // Valid ?
        Assert(idServer == FOLDERID_LOCAL_STORE);
    }

    // Otherwise, Validate FolderId
    else
    {
        // _ValidateSpecialFolders
        IF_FAILEXIT(hr = _ValidateSpecialFolders(&Folder));

        // Free Folder
        m_pDB->FreeRecord(&Folder);

        hr = GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_ERRORS, &Folder);
        if (SUCCEEDED(hr))
        {
            if (Folder.cMessages == 0 && 0 == (Folder.dwFlags & FOLDER_HASCHILDREN))
                DeleteFolder(Folder.idFolder, DELETE_FOLDER_NOTRASHCAN | DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_DELETESPECIAL, NULL);

            m_pDB->FreeRecord(&Folder);
        }
        else if (hr != DB_E_NOTFOUND)
        {
            goto exit;
        }

        // Lose the junk mail folder if we can't use it...
        if (0 == (g_dwAthenaMode & MODE_JUNKMAIL))
        {
            hr = GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_JUNK, &Folder);
            if (SUCCEEDED(hr))
            {
                if (Folder.cMessages == 0 && 0 == (Folder.dwFlags & FOLDER_HASCHILDREN))
                    DeleteFolder(Folder.idFolder, DELETE_FOLDER_NOTRASHCAN | DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_DELETESPECIAL, NULL);

                m_pDB->FreeRecord(&Folder);
            }
            else if (hr != DB_E_NOTFOUND)
            {
                goto exit;
            }
        }
    }

    // Get an Account Enumerator...
    hr = g_pAcctMan->Enumerate(SRV_SMTP | SRV_POP3 | SRV_NNTP | SRV_IMAP | SRV_HTTPMAIL, &pEnum);

    // No Accounts
    if (hr == E_NoAccounts)
        hr = S_OK;

    // Otherwise, if failed
    else if (FAILED(hr))
        goto exit;

    // Otherwise...
    else
    {
        // Loop accounts
        while (SUCCEEDED(pEnum->GetNext(&pAccount)))
        {
            // Create the Store
            CreateServer(pAccount, NOFLAGS, &idServer);

            // Cleanup
            SafeRelease(pAccount);
        }
    }

    // Should we put a welcome message into the store
    if (g_pAcctMan && FALSE == m_fMigrate)
    {
        // Locals
        IMessageFolder *pInbox;

        // Open Inbox
        if (SUCCEEDED(OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, &pInbox)))
        {
            // Locals
            FOLDERUSERDATA UserData;

            // Get the User Data
            if (SUCCEEDED(pInbox->GetUserData(&UserData, sizeof(FOLDERUSERDATA))))
            {
                // No Welcome message yet ?
                if ((FALSE == UserData.fWelcomeAdded) && (DwGetOption(OPT_NEEDWELCOMEMSG) != 0))
                {
                    // Add the Welcome Message
                    AddWelcomeMessage(pInbox);

                    // We Added the Welcome Message
                    UserData.fWelcomeAdded = TRUE;

                    // Update the User Data
                    pInbox->SetUserData(&UserData, sizeof(FOLDERUSERDATA));
                }
            }

            // Done
            pInbox->Release();
        }
    }

exit:
    // Cleanup
    SafeRelease(pChildren);
    SafeRelease(pAccount);
    SafeRelease(pEnum);
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_ValidateSpecialFolders
//--------------------------------------------------------------------------
HRESULT CMessageStore::_ValidateSpecialFolders(LPFOLDERINFO pServer)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERINFO      Folder;
    FOLDERINFO      NewFolder;
    CHAR            szFolder[CCHMAX_FOLDER_NAME];

    // Trace
    TraceCall("CMessageStore::_ValidateSpecialFolders");

    // Loop through the special folders
    for (i = FOLDER_INBOX; i < FOLDER_MAX; i++)
    {
        // Ignore FOLDER_ERRORS and FOLDER_MSNPROMO
        if (FOLDER_ERRORS != i && FOLDER_MSNPROMO != i && FOLDER_BULKMAIL != i && (FOLDER_JUNK != i 
            || (g_dwAthenaMode & MODE_JUNKMAIL)
            ))
        {
            // Does this special folder exist under this node yet ?
            if (FAILED(GetSpecialFolderInfo(pServer->idFolder, (SPECIALFOLDER)i, &Folder)))
            {
                // Load the Folder String
                LoadString(g_hLocRes, (idsInbox + i) - 1, szFolder, ARRAYSIZE(szFolder));

                // Fill the Folder Info
                ZeroMemory(&NewFolder, sizeof(FOLDERINFO));
                NewFolder.idParent = pServer->idFolder;
                NewFolder.tySpecial = (SPECIALFOLDER)i;
                NewFolder.pszName = szFolder;
                NewFolder.dwFlags = FOLDER_SUBSCRIBED;

                // Create the Folder
                IF_FAILEXIT(hr = CreateFolder(NOFLAGS, &NewFolder, NOSTORECALLBACK));
            }

            // Otherwise...
            else
                m_pDB->FreeRecord(&Folder);
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_ValidateServer
//--------------------------------------------------------------------------
HRESULT CMessageStore::_ValidateServer(LPFOLDERINFO pServer)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szSearch[MAX_PATH + MAX_PATH];
    HANDLE              hFind=INVALID_HANDLE_VALUE;
    FOLDERID            idFolder;
    WIN32_FIND_DATA     fd;

    // Trace
    TraceCall("CMessageStore::Validate");

    // Not a Server
    Assert(pServer && ISFLAGSET(pServer->dwFlags, FOLDER_SERVER));

    // Don't overwrite buffer
    IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, "*.dbx", c_szEmpty, szSearch, ARRAYSIZE(szSearch)));
    
    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    do
    {
        // If this is not a directory
        if (ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
            continue;

        // Skip folders
        if (lstrcmpi(fd.cFileName, c_szFoldersFile) == 0)
            continue;

        // Skip pop3uidl
        if (lstrcmpi(fd.cFileName, c_szPop3UidlFile) == 0)
            continue;

        // Skip offline
        if (lstrcmpi(fd.cFileName, c_szOfflineFile) == 0)
            continue;

        // Create Folder
        if (FAILED(_InsertFolderFromFile(pServer->pszAccountId, fd.cFileName)))
            continue;

    } while (0 != FindNextFile(hFind, &fd));

    // Can Have Specail Folders ?
    if (ISFLAGSET(pServer->dwFlags, FOLDER_CANHAVESPECIAL))
    {
        // _ValidateSpecialFolders
        IF_FAILEXIT(hr = _ValidateSpecialFolders(pServer));
    }

exit:
    // Cleanup
    if (INVALID_HANDLE_VALUE != hFind)
        FindClose(hFind);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::GetDirectory(LPSTR pszDir, DWORD cchMaxDir)
{
    // Trace
    TraceCall("CMessageStore::GetDirectory");

    // Invalid Args
    if (NULL == pszDir || NULL == m_pszDirectory)
        return TraceResult(E_INVALIDARG);

    // Copy It
    StrCpyN(pszDir, m_pszDirectory, cchMaxDir);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::Synchronize(FOLDERID idFolder, 
    SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idDeletedItems;
    FOLDERID        idServer=FOLDERID_INVALID;
    FOLDERID        idCurrent=idFolder;
    IMessageServer *pServer=NULL;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CMessageStore::Synchronize");

    // Invalid Args
    if (NULL == pCallback || FOLDERID_ROOT == idFolder)
        return TraceResult(E_INVALIDARG);

    // Walk up the parent chain
    IF_FAILEXIT(hr = IsParentDeletedItems(idFolder, &idDeletedItems, &idServer));

    // Didn't Find Server ?
    if (FOLDERID_INVALID == idServer)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Tell the Server to snchronize...
    IF_FAILEXIT(hr = pServer->SynchronizeStore(idFolder, dwFlags, pCallback));

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::CreateServer
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::CreateServer(IImnAccount *pAccount, FLDRFLAGS dwFlags,
    LPFOLDERID pidFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwServers;
    FOLDERINFO      Root={0};
    FOLDERINFO      Folder={0};
    CHAR            szRes[CCHMAX_ACCOUNT_NAME], szAccountId[CCHMAX_ACCOUNT_NAME];
    BOOL            fLocalStore=FALSE;
    DWORD           dwDomainMsn = 0;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageStore::CreateServer");

    if (pAccount == NULL)
        StrCpyN(szAccountId, STR_LOCALSTORE, ARRAYSIZE(szAccountId));
    else if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId))))
        return(hr);

    // Lock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Make sure that an account with this id doesn't already exist
    if (SUCCEEDED(FindServerId(szAccountId, pidFolder)))
        goto exit;

    // If Local Store, lets fix the id to FOLDERID_LOCAL
    if (0 != lstrcmpi(STR_LOCALSTORE, szAccountId))
    {
        // Get the server types supported by this account.
        IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));

        // If SRV_POP3
        if (ISFLAGSET(dwServers, SRV_POP3))
        {
            // See if the local store node already exists
            if (SUCCEEDED(FindServerId(STR_LOCALSTORE, pidFolder)))
                goto exit;

            // Local Store
            fLocalStore = TRUE;
        }
    }

    // If Local Store, lets fix the id to FOLDERID_LOCAL
    if (fLocalStore || 0 == lstrcmpi(STR_LOCALSTORE, szAccountId))
    {
        // Load the String Name
        LoadString(g_hLocRes, idsPersonalFolders, szRes, ARRAYSIZE(szRes));

        // Flags
        Folder.dwFlags = FOLDER_CANHAVESPECIAL | FOLDER_SERVER | FOLDER_SUBSCRIBED;

        // Set pszName
        Folder.pszName = szRes;

        // Set the Type
        Folder.tyFolder = FOLDER_LOCAL;

        // Set the Id
        Folder.idFolder = FOLDERID_LOCAL_STORE;
    }

    // Otherwise, generate a value
    else
    {
        // Get the Friendly Name
        IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szRes, ARRAYSIZE(szRes)));

        // Set pszName
        Folder.pszName = szRes;

        // NNTP
        if (ISFLAGSET(dwServers, SRV_NNTP))
        {
            // Set the Folder Flags
            Folder.dwFlags = FOLDER_CANRENAME | FOLDER_CANDELETE | FOLDER_SERVER | FOLDER_SUBSCRIBED;

            // Set Type
            Folder.tyFolder = FOLDER_NEWS;
        }

        // IMAP
        else if (ISFLAGSET(dwServers, SRV_IMAP))
        {
            // Set Flags
            Folder.dwFlags = FOLDER_CANRENAME | FOLDER_CANDELETE | FOLDER_SERVER | FOLDER_SUBSCRIBED;

            // Set Type
            Folder.tyFolder = FOLDER_IMAP;
        }
        
        // HTTP
        else if (ISFLAGSET(dwServers, SRV_HTTPMAIL))
        {
            // Set Flags
            Folder.dwFlags = /* FOLDER_CANHAVESPECIAL | */ FOLDER_CANRENAME | FOLDER_CANDELETE | FOLDER_SERVER | FOLDER_SUBSCRIBED;

            // Is the account associated with MSN.com?
            if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwDomainMsn)) && dwDomainMsn)
                Folder.dwFlags |= FOLDER_MSNSERVER;

            // Set Type
            Folder.tyFolder = FOLDER_HTTPMAIL;
        }

        // Generate a folderid
        IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&Folder.idFolder));

        // Validate
        Assert(FOLDERID_ROOT != Folder.idFolder && FOLDERID_LOCAL_STORE != Folder.idFolder);
    }

    // Fill the Folder Info
    Folder.pszAccountId = szAccountId;
    Folder.tySpecial = FOLDER_NOTSPECIAL;

    // Insert this Record
    IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

    // Validate
    IF_FAILEXIT(hr = _ValidateServer(&Folder));

    // Get the Root
    IF_FAILEXIT(hr = GetFolderInfo(FOLDERID_ROOT, &Root));

    // Parent Doesn't Think it Has Kids Yet ?
    if (FALSE == ISFLAGSET(Root.dwFlags, FOLDER_HASCHILDREN))
    {
        // Set the Flags
        FLAGSET(Root.dwFlags, FOLDER_HASCHILDREN);

        // Update the Record
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Root));
    }

    // Return the Folderid
    if (pidFolder)
        *pidFolder = Folder.idFolder;

exit:
    // Cleanup
    m_pDB->FreeRecord(&Root);

    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_MakeUniqueFolderName
//--------------------------------------------------------------------------
HRESULT CMessageStore::_MakeUniqueFolderName(FOLDERID idParent, 
    LPCSTR pszOriginalName, LPSTR *ppszNewName)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    ULONG           i;

    // Allocate
    DWORD cchSize = (lstrlen(pszOriginalName) + 20);
    IF_NULLEXIT(*ppszNewName = (LPSTR)g_pMalloc->Alloc(cchSize));

    // Generate a Unique Name
    for (i=1; i<500; i++)
    {
        // Format the New Name
        wnsprintf(*ppszNewName, cchSize, "%s (%d)", pszOriginalName, i);

        // Setup Folder
        Folder.idParent = idParent;
        Folder.pszName = (*ppszNewName);

        // Not Found
        if (DB_S_NOTFOUND == m_pDB->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            goto exit;

        // Free Folder
        m_pDB->FreeRecord(&Folder);
    }

    // Free *ppszNewName
    SafeMemFree((*ppszNewName));

    // Failure
    hr = TraceResult(DB_E_DUPLICATE);

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::CreateFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, 
    LPFOLDERINFO pInfo, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszNewName=NULL;
    LPSTR           pszName;
    FOLDERINFO      Parent={0};
    FOLDERINFO      Folder={0};
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageStore::CreateFolder");

    // Invalid Args
    if (NULL == pInfo || NULL == pInfo->pszName)
        return TraceResult(E_INVALIDARG);

    // Bad Folder Name
    if (NULL == pInfo->pszName || FIsEmpty(pInfo->pszName))
        return TraceResult(STORE_E_BADFOLDERNAME);

    // Lock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // See if the Folder Already Exists
    Folder.idParent = pInfo->idParent;
    Folder.pszName = pszName = (LPSTR)pInfo->pszName;

    // Try to find in the index
    if (DB_S_FOUND == m_pDB->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        // Try to Uniquify the name ?
        if (ISFLAGSET(dwCreateFlags, CREATE_FOLDER_UNIQUIFYNAME))
        {
            // Free
            m_pDB->FreeRecord(&Folder);

            // Generate Unique Folder Name
            IF_FAILEXIT(hr = _MakeUniqueFolderName(pInfo->idParent, pInfo->pszName, &pszNewName));

            // Set pszName
            pszName = pszNewName;
        }

        // Otherwise, return success
        else
        {
            // Set the pidFolder
            pInfo->idFolder = Folder.idFolder;

            // Free
            m_pDB->FreeRecord(&Folder);

            // Success, but already exists...
            hr = STORE_S_ALREADYEXISTS;

            // Done
            goto exit;
        }
    }

    // Get Parent Folder Info
    IF_FAILEXIT(hr = GetFolderInfo(pInfo->idParent, &Parent));

    // Parent Can not be the root
    if (FOLDERID_ROOT == Parent.idFolder)
    {
        hr = TraceResult(STORE_E_INVALIDPARENT);
        goto exit;
    }

    // Generate a folderid
    IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&Folder.idFolder));

    // Fill In the Folder Info
    Folder.tyFolder = Parent.tyFolder;
    Folder.idParent = Parent.idFolder;
    Folder.pszName = pszName;
    Folder.pszUrlComponent = pInfo->pszUrlComponent;
    Folder.tySpecial = pInfo->tySpecial;
    Folder.dwFlags = pInfo->dwFlags;
    Folder.bHierarchy = pInfo->bHierarchy;
    Folder.pszDescription = pInfo->pszDescription;
    Folder.dwServerHigh = pInfo->dwServerHigh;
    Folder.dwServerLow = pInfo->dwServerLow;
    Folder.dwServerCount = pInfo->dwServerCount;
    Folder.dwClientHigh = pInfo->dwClientHigh;
    Folder.dwClientLow = pInfo->dwClientLow;
    Folder.cMessages = pInfo->cMessages;
    Folder.cUnread = pInfo->cUnread;
    Folder.pszFile = pInfo->pszFile;
    Folder.Requested = pInfo->Requested;

    // Insert this Record
    IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

    // Parent Doesn't Think it Has Kids Yet ?
    if (FALSE == ISFLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN))
    {
        // Set the Flags
        FLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN);

        // Update the Record
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));
    }

    // Return the Folderid
    pInfo->idFolder = Folder.idFolder;

exit:
    // Cleanup
    m_pDB->FreeRecord(&Parent);
    m_pDB->Unlock(&hLock);
    SafeMemFree(pszNewName);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::OpenSpecialFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer,
    SPECIALFOLDER tySpecial, IMessageFolder **ppFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idFolder;

    // Trace
    TraceCall("CMessageStore::OpenSpecialFolder");

    // Get Special Folder INformation
    IF_FAILEXIT(hr = _GetSpecialFolderId(idStore, tySpecial, &idFolder));

    // Open the Folder
    IF_FAILEXIT(hr = OpenFolder(idFolder, pServer, NOFLAGS, ppFolder));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::OpenFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OpenFolder(FOLDERID idFolder, IMessageServer *pServer, 
    OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    CFindFolder    *pFindFolder=NULL;
    CMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CMessageStore::OpenFolder");

    // Invalid Args
    if (NULL == ppFolder || NULL == m_pDB)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *ppFolder = NULL;

    // Get Folder Info...
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // Search Folder ?
    if (ISFLAGSET(Folder.dwFlags, FOLDER_FINDRESULTS))
    {
        // Thread Safety
        EnterCriticalSection(&g_csFindFolder);

        // Walk Through the global list of Active Search Folders
        for (LPACTIVEFINDFOLDER pCurrent=g_pHeadFindFolder; pCurrent!=NULL; pCurrent=pCurrent->pNext)
        {
            // Is this it
            if (Folder.idFolder == pCurrent->idFolder)
            {
                // AddRef the Folder
                pFindFolder = pCurrent->pFolder;

                // AddRef It
                pFindFolder->AddRef();

                // Done
                break;
            }
        }

        // Thread Safety
        LeaveCriticalSection(&g_csFindFolder);

        // If Not Found
        if (NULL == pFindFolder)
        {
            hr = TraceResult(DB_E_NOTFOUND);
            goto exit;
        }

        // Return
        *ppFolder = (IMessageFolder *)pFindFolder;

        // Don't Free It
        pFindFolder = NULL;
    }

    // Otherwise
    else
    {
        // Create a CMessageFolder Object
        IF_NULLEXIT(pFolder = new CMessageFolder);

        // Initialize
        hr = pFolder->Initialize((IMessageStore *)this, pServer, dwFlags, idFolder);
        if (FAILED(hr))
            goto exit;

        // Return
        *ppFolder = (IMessageFolder *)pFolder;

        // Don't Free It
        pFolder = NULL;
    }

exit:
    // Cleanup
    SafeRelease(pFindFolder);
    SafeRelease(pFolder);
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::MoveFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, 
    MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERID        idParentOld;
    FOLDERINFO      Folder={0};
    FOLDERINFO      Parent={0};
    LPSTR           pszNewName=NULL;

    // Trace
    TraceCall("CMessageStore::MoveFolder");

    // Get all the Parents
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // Save Old Parent
    idParentOld = Folder.idParent;

    // Same Parent
    if (idParentOld == idParentNew)
        goto exit;

    // If Folder is a server..
    if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
    {
        hr = TraceResult(STORE_E_CANTMOVESERVERS);
        goto exit;
    }

    // If Folder is a special folder
    if (FOLDER_NOTSPECIAL != Folder.tySpecial)
    {
        hr = TraceResult(STORE_E_CANTMOVESPECIAL);
        goto exit;
    }

    // Set new Parent
    Folder.idParent = idParentNew;

    // Update the Parent
    hr = m_pDB->UpdateRecord(&Folder);

    // Failed and not a duplicate
    if (FAILED(hr) && DB_E_DUPLICATE != hr)
    {
        TraceResult(hr);
        goto exit;
    }

    // Duplicate
    if (DB_E_DUPLICATE == hr)
    {
        // Make Unique
        IF_FAILEXIT(hr = _MakeUniqueFolderName(Folder.idParent, Folder.pszName, &pszNewName));

        // Set the Name
        Folder.pszName = pszNewName;

        // Update the Parent
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));
    }

    // Update Parents
    IF_FAILEXIT(hr = GetFolderInfo(idParentOld, &Parent));

    // idParentOld no longer has children ?
    if (FALSE == FHasChildren(&Parent, FALSE))
    {
        // Remove FOLDER_HASCHILDREN flag
        FLAGCLEAR(Parent.dwFlags, FOLDER_HASCHILDREN);

        // Write It
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));
    }

    // Free It
    m_pDB->FreeRecord(&Parent);

    // Update Parents
    IF_FAILEXIT(hr = GetFolderInfo(idParentNew, &Parent));

    // Set the FOLDER_HASCHILDREN flag
    FLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN);

    // Write It
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Parent);
    m_pDB->FreeRecord(&Folder);
    SafeMemFree(pszNewName);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::RenameFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::RenameFolder(FOLDERID idFolder, LPCSTR pszName, 
    RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    FOLDERINFO      Folder={0};
    BOOL            fChanged;
    IDatabase      *pDB=NULL;
    LPWSTR          pwszFilePath=NULL;

    // Trace
    TraceCall("CMessageStore::RenameFolder");

    // Invalid Args
    if (NULL == pszName)
        return TraceResult(E_INVALIDARG);

    // Bad Folder Name
    if (FIsEmpty(pszName))
        return TraceResult(STORE_E_BADFOLDERNAME);

    // Get the FolderInfo
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // Can't Rename Special Folders
    if (FOLDER_NOTSPECIAL != Folder.tySpecial && 0 != lstrcmpi(pszName, Folder.pszName))
    {
        hr = TraceResult(STORE_E_CANTRENAMESPECIAL);
        goto exit;
    }

    // Set the Name
    Folder.pszName = (LPSTR)pszName;

    // If the file current has a folder file..
    if (Folder.pszFile)
    {
        // Build folder name
        IF_FAILEXIT(hr = BuildFriendlyFolderFileName(m_pszDirectory, &Folder, szFilePath, ARRAYSIZE(szFilePath), Folder.pszFile, &fChanged));

        // Changed ?
        if (fChanged)
        {
            // Locals
            CHAR szSrcFile[MAX_PATH + MAX_PATH];

            // Delete the Dest
            DeleteFile(szFilePath);

            // Open the old file
            IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, Folder.pszFile, c_szEmpty, szSrcFile, ARRAYSIZE(szSrcFile)));

            // Open the Folder
            IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szSrcFile, OPEN_DATABASE_NORESET | OPEN_DATABASE_NOEXTENSION, &g_MessageTableSchema, NULL, &pDB));

            // Convert to Unicode
            IF_NULLEXIT(pwszFilePath = PszToUnicode(CP_ACP, szFilePath));

            // Move the file
            IF_FAILEXIT(hr = pDB->MoveFile(pwszFilePath));

            // Set the File Name
            Folder.pszFile = PathFindFileName(szFilePath);
        }
    }

    // Update the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

exit:
    // Cleanup
    SafeRelease(pDB);
    SafeMemFree(pwszFilePath);
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::DeleteFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::DeleteFolder(FOLDERID idFolder, 
    DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Delete={0};
    FOLDERID        idStore=FOLDERID_INVALID;
    FOLDERID        idDeletedItems=FOLDERID_INVALID;
    FOLDERINFO      DeletedItems={0};
    FOLDERINFO      Parent={0};
    BOOL            fTryTrashCan=FALSE;
    BOOL            fInDeletedItems=FALSE;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageStore::DeleteFolder");

    // Can't Delete the root
    if (FOLDERID_ROOT == idFolder || FOLDERID_INVALID == idFolder)
        return TraceResult(E_INVALIDARG);

    // Lock Notifications
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Get the Folder Information
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Delete));

    // Can't Delete special Folder
    if (!ISFLAGSET(dwFlags, DELETE_FOLDER_CHILDRENONLY) && FOLDER_NOTSPECIAL != Delete.tySpecial &&
        !ISFLAGSET(dwFlags, DELETE_FOLDER_DELETESPECIAL))
    {
        hr = TraceResult(STORE_E_CANTDELETESPECIAL);
        goto exit;
    }

    // Try to do the trash can ?
    if (FALSE == ISFLAGSET(Delete.dwFlags, FOLDER_SERVER) && FALSE == ISFLAGSET(dwFlags, DELETE_FOLDER_NOTRASHCAN))
        fTryTrashCan = TRUE;

    // If not in deleted items, then simply move this idFolder to deleted items
    if (TRUE == fTryTrashCan && S_FALSE == IsParentDeletedItems(idFolder, &idDeletedItems, &idStore) && FOLDER_NOTSPECIAL == Delete.tySpecial)
    {
        // Validate
        Assert(FOLDERID_INVALID == idDeletedItems && FOLDERID_INVALID != idStore);

        // Get the Deleted Items Folder for this store
        IF_FAILEXIT(hr = GetSpecialFolderInfo(idStore, FOLDER_DELETED, &DeletedItems));

        // Move this folder
        IF_FAILEXIT(hr = MoveFolder(idFolder, DeletedItems.idFolder, NOFLAGS, NULL));
    }

    // Otherwise, permanently delete these folders
    else
    {
        // Delete Children ?
        if (ISFLAGSET(dwFlags, DELETE_FOLDER_RECURSIVE))
        {
            // Delete Child Folders
            IF_FAILEXIT(hr = _DeleteSiblingsAndChildren(&Delete));

            // Delete has no children
            FLAGCLEAR(Delete.dwFlags, FOLDER_HASCHILDREN);

            // Update Delete
            IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Delete));
        }

        // _InternalDeleteFolder if not children only
        if (FALSE == ISFLAGSET(dwFlags, DELETE_FOLDER_CHILDRENONLY))
        {
            // Try to Delete this folder
            IF_FAILEXIT(hr = _InternalDeleteFolder(&Delete));

            // Delete's Parent has no childre
            if (FOLDERID_INVALID != Delete.idParent && FALSE == ISFLAGSET(Delete.dwFlags, FOLDER_HASCHILDREN))
            {
                // Get the Parent
                IF_FAILEXIT(hr = GetFolderInfo(Delete.idParent, &Parent));

                // Must have had children
                Assert(ISFLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN));

                // No more children
                if (FALSE == FHasChildren(&Parent, FALSE))
                {
                    // Delete has no children
                    FLAGCLEAR(Parent.dwFlags, FOLDER_HASCHILDREN);

                    // Update Delete
                    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));
                }
            }
        }
    }

exit:
    // Cleanup
    m_pDB->FreeRecord(&Delete);
    m_pDB->FreeRecord(&Parent);
    m_pDB->FreeRecord(&DeletedItems);
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_DeleteSiblingsAndChildren
//--------------------------------------------------------------------------
HRESULT CMessageStore::_DeleteSiblingsAndChildren(LPFOLDERINFO pParent)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("CMessageStore::_DeleteSiblingsAndChildren");

    // Enumerate Children
    IF_FAILEXIT(hr = EnumChildren(pParent->idFolder, FALSE, &pChildren));

    // Loop
    while (S_OK == pChildren->Next(1, &Folder, NULL))
    {
        // Has Children
        if (ISFLAGSET(Folder.dwFlags, FOLDER_HASCHILDREN))
        {
            // Delete Siblings and Children
            IF_FAILEXIT(hr = _DeleteSiblingsAndChildren(&Folder));
        }

        // _InternalDeleteFolder
        IF_FAILEXIT(hr = _InternalDeleteFolder(&Folder));

        // Cleanup
        m_pDB->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);
    SafeRelease(pChildren);

    // Done
    return (hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_InternalDeleteFolder
//--------------------------------------------------------------------------
HRESULT CMessageStore::_InternalDeleteFolder(LPFOLDERINFO pDelete)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("CMessageStore::_InternalDeleteFolder");

    // Has Children
    if (ISFLAGSET(pDelete->dwFlags, FOLDER_HASCHILDREN))
    {
        // Enumerate the Children
        IF_FAILEXIT(hr = EnumChildren(pDelete->idFolder, FALSE, &pChildren));

        // Loop
        while (S_OK == pChildren->Next(1, &Folder, NULL))
        {
            // Validate
            Assert(Folder.idParent == pDelete->idFolder);

            // Set New Parent
            Folder.idParent = pDelete->idParent;

            // Update the REcord
            IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

            // Cleanup
            m_pDB->FreeRecord(&Folder);
        }
    }

    // Final thing to do is to delete pFolder
    IF_FAILEXIT(hr = m_pDB->DeleteRecord(pDelete));

    // Delete folder file
    _DeleteFolderFile(pDelete);

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);
    SafeRelease(pChildren);

    // Done
    return (hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_DeleteFolderFile
//--------------------------------------------------------------------------
HRESULT CMessageStore::_DeleteFolderFile(LPFOLDERINFO pFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szFilePath[MAX_PATH + MAX_PATH];

    // Trac
    TraceCall("CMessageStore::_DeleteFolderFile");

    // If there is a file
    if (!FIsEmptyA(pFolder->pszFile))
    {
        // Make the file path
        IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, pFolder->pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // Delete the File
        if (0 == DeleteFile(szFilePath))
        {
            // Locals
            DeleteTempFileOnShutdownEx(PszDupA(szFilePath), NULL);
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_FreeServerTable
//--------------------------------------------------------------------------
HRESULT CMessageStore::_FreeServerTable(HLOCK hLock)
{
    // Locals
    LPSERVERFOLDER pCurrent = m_pServerHead;
    LPSERVERFOLDER pNext;

    // Trace
    TraceCall("CMessageStore::_FreeServerTable");

    // Validate
    Assert(hLock);

    // While Current
    while(pCurrent)
    {
        // Set Next
        pNext = pCurrent->pNext;

        // Free
        g_pMalloc->Free(pCurrent);

        // Goto next
        pCurrent = pNext;
    }

    // Reset
    m_pServerHead = NULL;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::_LoadServerTable
//--------------------------------------------------------------------------
HRESULT CMessageStore::_LoadServerTable(HLOCK hLock)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Server={0};
    FOLDERINFO          Folder={0};
    LPSERVERFOLDER      pServer=NULL;
    IEnumerateFolders  *pEnumServers=NULL;
    IEnumerateFolders  *pEnumFolders=NULL;

    // Trace
    TraceCall("CMessageStore::_LoadServerTable");

    // Validate
    Assert(hLock);

    // If Already Loaded
    if (m_pServerHead)
        return(S_OK);

    // Enumerate Children of Root
    IF_FAILEXIT(hr = EnumChildren(FOLDERID_ROOT, TRUE, &pEnumServers));

    // Loop..
    while (S_OK == pEnumServers->Next(1, &Server, NULL))
    {
        // Better be a store
        Assert(ISFLAGSET(Server.dwFlags, FOLDER_SERVER));

        // Allocate a Server Node
        IF_NULLEXIT(pServer = (LPSERVERFOLDER)g_pMalloc->Alloc(sizeof(SERVERFOLDER)));

        // Store the ServerId
        pServer->idServer = Server.idFolder;

        // Save AccountId
        StrCpyN(pServer->szAccountId, Server.pszAccountId, ARRAYSIZE(pServer->szAccountId));

        // Initialize
        FillMemory(pServer->rgidSpecial, sizeof(pServer->rgidSpecial), 0xFF);

        // Enumerate the Children
        IF_FAILEXIT(hr = EnumChildren(pServer->idServer, TRUE, &pEnumFolders));

        // Loop..
        while (S_OK == pEnumFolders->Next(1, &Folder, NULL))
        {
            // If Special
            if (FOLDER_NOTSPECIAL != Folder.tySpecial)
            {
                // Save the folder id
                pServer->rgidSpecial[Folder.tySpecial] = Folder.idFolder;
            }

            // Cleanup
            m_pDB->FreeRecord(&Folder);
        }

        // Release the Folder Enumerator
        SafeRelease(pEnumFolders);

        // Link it In
        pServer->pNext = m_pServerHead;

        // Set Server Head
        m_pServerHead = pServer;

        // Don't Free
        pServer = NULL;

        // Cleanup
        m_pDB->FreeRecord(&Server);
    } 

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);
    m_pDB->FreeRecord(&Server);
    SafeMemFree(pServer);

    // Release Enums
    SafeRelease(pEnumServers);
    SafeRelease(pEnumFolders);

    // Failure
    if (FAILED(hr))
    {
        // Free the Table
        _FreeServerTable(hLock);
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::FindServerId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::FindServerId(LPCSTR pszAcctId, LPFOLDERID pidServer)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPSERVERFOLDER      pServer;

    // Trace
    TraceCall("CMessageStore::FindServerId");

    // Unlock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // LoadServer Table
    IF_FAILEXIT(hr = _LoadServerTable(hLock));

    // Loop through the cached server nodes...
    for (pServer = m_pServerHead; pServer != NULL; pServer = pServer->pNext)
    {
        // If this is It...
        if (lstrcmpi(pszAcctId, pServer->szAccountId) == 0)
        {
            *pidServer = pServer->idServer;
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// GetFolderInfo
//--------------------------------------------------------------------------
HRESULT CMessageStore::GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("CMessageStore::GetFolderInfo");
    
    // Invalid Arg
    Assert(pInfo);

    // Set pInfo
    pInfo->idFolder = idFolder;

    // Return
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pInfo, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

    // Found
    hr = S_OK;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetSpecialFolderInfo
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::GetSpecialFolderInfo(FOLDERID idStore,
    SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPSERVERFOLDER      pServer;

    // Trace
    TraceCall("CMessageStore::GetSpecialFolderInfo");

    // Invalid Args
    if (NULL == pInfo || FOLDER_NOTSPECIAL == tySpecial)
        return TraceResult(E_INVALIDARG);

    // Unlock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // LoadServer Table
    IF_FAILEXIT(hr = _LoadServerTable(hLock));

    // Loop through the cached server nodes...
    for (pServer = m_pServerHead; pServer != NULL; pServer = pServer->pNext)
    {
        // If this is It...
        if (idStore == pServer->idServer)
        {
            // Validate Special Folder Id ?
            if (FOLDERID_INVALID == pServer->rgidSpecial[tySpecial])
            {
                hr = DB_E_NOTFOUND;
                goto exit;
            }

            // Otherwise, get the folder info...
            IF_FAILEXIT(hr = GetFolderInfo(pServer->rgidSpecial[tySpecial], pInfo));

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_GetSpecialFolderId
//--------------------------------------------------------------------------
HRESULT CMessageStore::_GetSpecialFolderId(FOLDERID idStore,
    SPECIALFOLDER tySpecial, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPSERVERFOLDER      pServer;

    // Trace
    TraceCall("CMessageStore::_GetSpecialFolderId");

    // Unlock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // LoadServer Table
    IF_FAILEXIT(hr = _LoadServerTable(hLock));

    // Loop through the cached server nodes...
    for (pServer = m_pServerHead; pServer != NULL; pServer = pServer->pNext)
    {
        // If this is It...
        if (idStore == pServer->idServer)
        {
            // Validate Special Folder Id ?
            if (FOLDERID_INVALID == pServer->rgidSpecial[tySpecial])
            {
                hr = DB_E_NOTFOUND;
                goto exit;
            }

            // Return the id
            *pidFolder = pServer->rgidSpecial[tySpecial];

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::SubscribeToFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::SubscribeToFolder(FOLDERID idFolder, 
    BOOL fSubscribed, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CMessageStore::SubscribeToFolder");

    // Invalid Args
    if (NULL == m_pDB)
        return TraceResult(E_INVALIDARG);

    // Set idFolder
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // If not Subscribed yet ?
    if (fSubscribed ^ ISFLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED))
    {
        // Remove the Not-Subscribed Falgs
        FLAGTOGGLE(Folder.dwFlags, FOLDER_SUBSCRIBED);
    }

    // Update the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

    // Delete the file if not subscribed
    if (FALSE == ISFLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED))
    {
        // Delete this file
        _DeleteFolderFile(&Folder);
    }

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::GetFolderCounts(FOLDERID idFolder,
                                               IStoreCallback *pCallback)
{
    // Has no equivalent in a local store
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
// CMessageStore::UpdateFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::UpdateFolderCounts(FOLDERID idFolder, 
    LONG lMsgs, LONG lUnread, LONG lWatchedUnread, LONG lWatched)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CMessageStore::UpdateMessageCount");

    // Invalid Args
    if (NULL == m_pDB)
        return TraceResult(E_INVALIDARG);

    // No Change
    if (0 == lMsgs && 0 == lUnread && 0 == lWatchedUnread && 0 == lWatched)
        return(S_OK);

    // Set idFolder
    Folder.idFolder = idFolder;

    // Find idFolder
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Folder, NULL));

    // Not found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    if (lMsgs < 0 && (DWORD)(abs(lMsgs)) >= Folder.cMessages)
        lMsgs = -((LONG)Folder.cMessages);

    // Message Unread Count
    if (lUnread < 0 && (DWORD)(abs(lUnread)) >= Folder.cUnread)
        lUnread = -((LONG)Folder.cUnread);

    // Set Counts
    Folder.cMessages += lMsgs;
    Folder.cUnread += lUnread;

    // Total Watched Count
    if (lWatched < 0 && (DWORD)(abs(lWatched)) > Folder.cWatched)
        Folder.cWatched = 0;
    else
        Folder.cWatched += lWatched;

    // Watched Unread Counts
    if (lWatchedUnread < 0 && (DWORD)(abs(lWatchedUnread)) > Folder.cWatchedUnread)
        Folder.cWatchedUnread = 0;
    else
        Folder.cWatchedUnread += lWatchedUnread;

    // Reset IMAP status counts
    Folder.dwStatusMsgDelta = 0;
    Folder.dwStatusUnreadDelta = 0;

    // Update the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_ComputeMessageCounts
//--------------------------------------------------------------------------
HRESULT CMessageStore::_ComputeMessageCounts(IDatabase *pDB,
    LPDWORD pcMsgs, LPDWORD pcUnread)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CMessageStore::_ComputeMessageCounts");

    // Invalid Args
    Assert(pDB && pcMsgs && pcUnread);

    // Initialize
    *pcMsgs = 0;
    *pcUnread = 0;

    // Create Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Iterate throug the messages
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Count
        (*pcMsgs)++;

        // Not Read
        if (FALSE == ISFLAGSET(Message.dwFlags, ARF_READ))
            (*pcUnread)++;

        // Free
        pDB->FreeRecord(&Message);
    }

exit:
    // Clenaup
    pDB->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_InsertFolderFromFile
//--------------------------------------------------------------------------
HRESULT CMessageStore::_InsertFolderFromFile(LPCSTR pszAcctId, 
    LPCSTR pszFile)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i=1;
    CHAR            szFolder[255];
    FOLDERINFO      Parent={0};
    FOLDERINFO      Folder={0};
    FOLDERUSERDATA  UserData={0};
    FOLDERUSERDATA  FolderData;
    FOLDERID        idParent;
    FOLDERID        idFolder;
    LPSTR           pszName;
    LPSTR           pszNewName=NULL;
    IDatabase *pDB=NULL;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("CMessageStore::_InsertFolderFromFile");

    // Invalid Args
    Assert(!FIsEmptyA(pszAcctId) && !FIsEmptyA(pszFile));

    // Init
    *szFilePath = '\0';

    // Make Path to the mst
    IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, pszFile, c_szEmpty, szFilePath, sizeof(szFilePath)));

    // Lets verify that this is really a message database
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NORESET, &g_MessageTableSchema, NULL, &pDB));

    // Get folder user data
    IF_FAILEXIT(hr = pDB->GetUserData(&FolderData, sizeof(FOLDERUSERDATA)));

    // If Not Initialized yet
    if (FALSE == FolderData.fInitialized)
        goto exit;

    // Locate the Parent Store
    IF_FAILEXIT(hr = FindServerId(FolderData.szAcctId, &idParent));

    // Get Parent Folder Info
    IF_FAILEXIT(hr = GetFolderInfo(idParent, &Parent));

    // pszAcctId
    if (lstrcmp(FolderData.szAcctId, pszAcctId) != 0)
        goto exit;

    // Parent Can not be the root
    if (FOLDERID_ROOT == idParent)
    {
        hr = TraceResult(STORE_E_INVALIDPARENT);
        goto exit;
    }

    // Setup Folder
    Folder.idFolder = idFolder = FolderData.idFolder;

    // Does FolderData.idFolder aready exist ?
    if (DB_S_FOUND == m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Folder, NULL))
    {
        // Free Folder
        m_pDB->FreeRecord(&Folder);

        // Make Unique
        IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&idFolder));

        // Setup Folder
        FolderData.idFolder = idFolder;

        // Reset the User Data
        IF_FAILEXIT(hr = pDB->SetUserData(&FolderData, sizeof(FOLDERUSERDATA)));
    }

    // Set Name
    Folder.pszName = pszName = FolderData.szFolder;
    Folder.idParent = idParent;

    // See if folder with same name and paent already exists...
    if (DB_S_FOUND == m_pDB->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        // Free Folder
        m_pDB->FreeRecord(&Folder);

        // Don't duplicate special folders!!!
        if (FOLDER_NOTSPECIAL != FolderData.tySpecial)
        {
            hr = TraceResult(DB_E_DUPLICATE);
            goto exit;
        }

        // Make Unique
        IF_FAILEXIT(hr = _MakeUniqueFolderName(idParent, FolderData.szFolder, &pszNewName));

        // Reset FolderData
        StrCpyN(FolderData.szFolder, pszNewName, ARRAYSIZE(FolderData.szFolder));

        // Reset the User Data
        IF_FAILEXIT(hr = pDB->SetUserData(&FolderData, sizeof(FOLDERUSERDATA)));

        // Set the Name
        pszName = pszNewName;
    }

    // Fill the Folder Info
    ZeroMemory(&Folder, sizeof(FOLDERINFO));
    Folder.idFolder = idFolder;
    Folder.pszName = pszName;
    Folder.tySpecial = FolderData.tySpecial;
    Folder.tyFolder = Parent.tyFolder;
    Folder.idParent = Parent.idFolder;
    Folder.dwFlags = FOLDER_SUBSCRIBED;
    Folder.pszFile = (LPSTR)pszFile;

    // Compute Message Counts
    IF_FAILEXIT(hr = _ComputeMessageCounts(pDB, &Folder.cMessages, &Folder.cUnread));

    // Insert this Record
    IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

    // Update the Parent
    FLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN);

    // Write the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));

exit:
    // Cleanup
    SafeRelease(pDB);
    m_pDB->FreeRecord(&Parent);
    SafeMemFree(pszNewName);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::EnumChildren
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::EnumChildren(FOLDERID idParent, 
    BOOL fSubscribed, IEnumerateFolders **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    CEnumerateFolders  *pEnum=NULL;

    // Trace
    TraceCall("CMessageStore::EnumChildren");

    // Allocate a New Enumerator
    IF_NULLEXIT(pEnum = new CEnumerateFolders);

    // Initialzie
    IF_FAILEXIT(hr = pEnum->Initialize(m_pDB, fSubscribed, idParent));

    // Return It
    *ppEnum = (IEnumerateFolders *)pEnum;

    // Don't Release It
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetNewGroups
//--------------------------------------------------------------------------
HRESULT CMessageStore::GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    return(E_NOTIMPL);
}

//--------------------------------------------------------------------------
// CMessageStore::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::Initialize(IDatabase *pDB)
{
    // Trace
    TraceCall("CMessageStore::Initialize");

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnLock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnLock(void)
{
    // Trace
    TraceCall("CMessageStore::OnLock");

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnUnlock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnUnlock(void)
{
    // Trace
    TraceCall("CMessageStore::OnUnlock");

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnInsertRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnRecordInsert(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Cast to MessageInfos
    LPFOLDERINFO pFolder = (LPFOLDERINFO)pRecord;

    // Trace
    TraceCall("CMessageStore::OnRecordInsert");

    // If this was a server
    if (m_pDB && ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) || FOLDER_NOTSPECIAL != pFolder->tySpecial)
    {
        // Free the Server Table
        _FreeServerTable((HLOCK)-1);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnUpdateRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnRecordUpdate(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew)
{
    // Cast to MessageInfos
    LPFOLDERINFO pFolderOld = (LPFOLDERINFO)pRecordOld;
    LPFOLDERINFO pFolderNew = (LPFOLDERINFO)pRecordNew;

    // Trace
    TraceCall("CMessageStore::OnRecordInsert");

    // Special Folder Type Changed ?
    if (m_pDB && ISFLAGSET(pFolderOld->dwFlags, FOLDER_SERVER) != ISFLAGSET(pFolderNew->dwFlags, FOLDER_SERVER) || pFolderOld->tySpecial != pFolderNew->tySpecial)
    {
        // Free the Server Table
        _FreeServerTable((HLOCK)-1);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnDeleteRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnRecordDelete(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Cast to MessageInfos
    LPFOLDERINFO pFolder = (LPFOLDERINFO)pRecord;

    // Trace
    TraceCall("CMessageStore::OnRecordInsert");

    // If this was a server
    if (m_pDB && ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) || FOLDER_NOTSPECIAL != pFolder->tySpecial)
    {
        // Free the Server Table
        _FreeServerTable((HLOCK)-1);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnExecuteMethod
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnExecuteMethod(METHODID idMethod, LPVOID pBinding, 
    LPDWORD pdwResult)
{
    // Trace
    TraceCall("CMessageStore::OnExecuteMethod");

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\playback.h ===
#ifndef _INC_PLAYBACK_H
#define _INC_PLAYBACK_H

class COfflinePlayback : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE );
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        COfflinePlayback(void);
        ~COfflinePlayback(void);

        HRESULT DoPlayback(HWND hwnd, IDatabase *pDB, FOLDERID *pid, DWORD cid, FOLDERID idFolderSel);

        static INT_PTR CALLBACK PlaybackDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    private:
        HRESULT _DoNextOperation(void);
        HRESULT _DoSetPropOp(SYNCOPINFO *pInfo);
        HRESULT _DoCreateOp(SYNCOPINFO *pInfo);
        HRESULT _DoDeleteOp(SYNCOPINFO *pInfo);
        HRESULT _DoCopyOp(SYNCOPINFO *pInfo);

        HRESULT _HandleSetPropComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);
        HRESULT _HandleCreateComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);
        HRESULT _HandleDeleteComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);
        HRESULT _HandleCopyComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);

        ULONG               m_cRef;
        HRESULT             m_hr;
        HWND                m_hwndDlg;
        BOOL                m_fComplete;
        STOREOPERATIONTYPE  m_type;
        IOperationCancel   *m_pCancel;
        HTIMEOUT            m_hTimeout;

        DWORD               m_cMovedToErrors;
        DWORD               m_cFailures;

        IDatabase          *m_pDB;

        FOLDERID           *m_pid;
        DWORD               m_iid;
        DWORD               m_cid;
        FOLDERID            m_idFolderSel;
        BOOL                m_fSyncSel;

        FOLDERID            m_idServer;
        FOLDERID            m_idFolder;
        IMessageServer     *m_pServer;
        IMessageFolder     *m_pLocalFolder;
        DWORD               m_iOps;
        DWORD               m_cOps;
        CEnumerateSyncOps  *m_pEnum;
        SYNCOPID            m_idOperation;

        IMessageFolder     *m_pFolderDest; // for copy and move
};

#endif // _INC_PLAYBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\newfldr.h ===
//--------------------------------------------------------------------------
// Newfldr.h
//--------------------------------------------------------------------------
#ifndef __NEWFLDR_H
#define __NEWFLDR_H

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "treeview.h"

//--------------------------------------------------------------------------
// Control Ids
//--------------------------------------------------------------------------
#define idcFolderEdit           1000
#define idcTreeView             1001
#define idcTreeViewText         1002
#define idcNewFolderBtn         1003

//--------------------------------------------------------------------------
// Folder Dialog flags (Can be combined with TREEVIEW_xxx Flags
//--------------------------------------------------------------------------
typedef DWORD FOLDERDIALOGFLAGS;
#define FD_NONEWFOLDERS         0x0100
#define FD_DISABLEROOT          0x0200
#define FD_DISABLEINBOX         0x0400
#define FD_DISABLEOUTBOX        0x0800
#define FD_DISABLESENTITEMS     0x1000
#define FD_DISABLESERVERS       0x2000
#define FD_FORCEINITSELFOLDER   0x4000

//--------------------------------------------------------------------------
// Common Folder Dialog flags Combos
//--------------------------------------------------------------------------
#define FD_COPYFLAGS            (FD_DISABLEROOT | FD_DISABLEOUTBOX)
#define FD_MOVEFLAGS            (FD_DISABLEROOT | FD_DISABLEOUTBOX)
#define FD_DISABLEFLAGS         (FD_DISABLEROOT | FD_DISABLEINBOX | FD_DISABLEOUTBOX | FD_DISABLESENTITEMS | FD_DISABLESERVERS)
#define FD_DISABLEFOLDERS       (FD_DISABLEINBOX | FD_DISABLEOUTBOX | FD_DISABLESENTITEMS)

//--------------------------------------------------------------------------
// Select Folder Dialog operations
//--------------------------------------------------------------------------
enum
{
    SFD_SELECTFOLDER = 0,
    SFD_NEWFOLDER,
    SFD_MOVEFOLDER,
    // SFD_MOVEMESSAGES,
    // SFD_COPYMESSAGES,
    SFD_LAST
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT SelectFolderDialog(
    IN      HWND                hwnd,
    IN      DWORD               op,
    IN      FOLDERID            idCurrent,
    IN      FOLDERDIALOGFLAGS   dwFlags,
    IN_OPT  LPCSTR              pszTitle,
    IN_OPT  LPCSTR              pszText,
    OUT_OPT LPFOLDERID          pidSelected);

#endif // _INC_NEWFLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\playback.cpp ===
#include "pch.hxx"
#include <progress.h>
#include "store.h"
#include "storutil.h"
#include "storsync.h"
#include "syncop.h"
#include "sync.h"
#include "shlwapip.h" 
#include "enumsync.h"
#include "playback.h"

#define WM_NEXT_OPERATION   (WM_USER + 69)

HRESULT OpenErrorsFolder(IMessageFolder **ppFolder);

COfflinePlayback::COfflinePlayback()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndDlg = NULL;
    m_fComplete = TRUE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;

    m_cMovedToErrors = 0;
    m_cFailures = 0;

    m_pDB = NULL;

    m_pid = NULL;
    m_iid = 0;
    m_cid = 0;

    m_idServer = FOLDERID_INVALID;
    m_idFolder = FOLDERID_INVALID;
    m_idFolderSel = FOLDERID_INVALID;
    m_fSyncSel = FALSE;
    m_pServer = NULL;
    m_pLocalFolder = NULL;
    m_iOps = 0;
    m_cOps = 0;
    m_pEnum = NULL;

    m_pFolderDest = NULL;
}

COfflinePlayback::~COfflinePlayback()
{
    Assert(m_pFolderDest == NULL);

    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();
    if (m_pDB != NULL)
        m_pDB->Release();
    if (m_pid != NULL)
        MemFree(m_pid);
    if (m_pLocalFolder != NULL)
        m_pLocalFolder->Release();
    if (m_pServer != NULL)
    {
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
    }
    if (m_pEnum != NULL)
        m_pEnum->Release();
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (void*) (ITimeoutCallback *)this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE COfflinePlayback::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE COfflinePlayback::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT COfflinePlayback::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    Assert(m_hwndDlg != NULL);
    Assert(!m_fComplete);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    return CallbackCanConnect(pszAccountId, m_hwndDlg, FALSE);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    HRESULT hr;
    SYNCOPINFO info;

    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    if (m_idOperation == SYNCOPID_INVALID)
    {
        m_idFolderSel = FOLDERID_INVALID;
    }
    else
    {
        ZeroMemory(&info, sizeof(SYNCOPINFO));

        info.idOperation = m_idOperation;
        hr = m_pDB->FindRecord(IINDEX_PRIMARY, 1, &info, NULL);
        if (hr == DB_S_FOUND)
        {
            switch (info.tyOperation)
            {
                case SYNC_DELETE_MSG:
                    hr = _HandleDeleteComplete(hrComplete, &info);
                    break;

                case SYNC_SETPROP_MSG:
                    hr = _HandleSetPropComplete(hrComplete, &info);
                    break;

                case SYNC_CREATE_MSG:
                    hr = _HandleCreateComplete(hrComplete, &info);
                    break;

                case SYNC_COPY_MSG:
                case SYNC_MOVE_MSG:
                    hr = _HandleCopyComplete(hrComplete, &info);
                    break;

                default:
                    Assert(FALSE);
                    break;
            }

            m_pDB->DeleteRecord(&info);
            m_pDB->FreeRecord(&info);
        }
    }

    PostMessage(m_hwndDlg, WM_NEXT_OPERATION, 0, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}

HRESULT COfflinePlayback::DoPlayback(HWND hwnd, IDatabase *pDB, FOLDERID *pid, DWORD cid, FOLDERID idFolderSel)
{
    FOLDERTYPE type;
    int iRet;
    char szStoreDir[MAX_PATH + MAX_PATH];

    Assert(pDB != NULL);
    Assert(pid != NULL);
    Assert(cid > 0);

    m_pDB = pDB;
    m_pDB->AddRef();

    m_pEnum = new CEnumerateSyncOps;
    if (m_pEnum == NULL)
        return(E_OUTOFMEMORY);

    if (!MemAlloc((void **)&m_pid, cid * sizeof(FOLDERID)))
        return(E_OUTOFMEMORY);

    CopyMemory(m_pid, pid, cid * sizeof(FOLDERID));
    m_cid = cid;
    type = GetFolderType(idFolderSel);
    if (type == FOLDER_IMAP || type == FOLDER_HTTPMAIL)
        m_idFolderSel = idFolderSel;

    iRet = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(IDD_PLAYBACK), hwnd, PlaybackDlgProc, (LPARAM)this);

    if (m_cFailures > 0)
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsOfflineTransactionsFailed),
            (m_cMovedToErrors > 0) ? MAKEINTRESOURCEW(idsMovedToOfflineErrors) : NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    return(S_OK);
}

INT_PTR CALLBACK COfflinePlayback::PlaybackDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet;
    HRESULT hr;
    COfflinePlayback *pThis;

    fRet = TRUE;

    switch (msg)
    {
        case WM_INITDIALOG:
            pThis = (COfflinePlayback *)lParam;
            Assert(pThis != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);

            pThis->m_hwndDlg = hwnd;

            CenterDialog(hwnd);

            Animate_OpenEx(GetDlgItem(hwnd, idcANI), g_hLocRes, MAKEINTRESOURCE(idanOutbox));
            PostMessage(hwnd, WM_NEXT_OPERATION, 0, 0);
            break;

        case WM_NEXT_OPERATION:
            pThis = (COfflinePlayback *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            Assert(pThis != NULL);
            hr = pThis->_DoNextOperation();
            if (hr != S_OK)
                EndDialog(hwnd, 0);
            break;

        default:
            fRet = FALSE;
            break;
    }

    return(fRet);
}

HRESULT COfflinePlayback::_DoNextOperation()
{
    HRESULT hr;
    char sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];
    SYNCOPINFO info;
    FOLDERINFO Folder;

    Assert(m_pEnum != NULL);
    Assert(g_pLocalStore != NULL);

    if (m_iOps == m_cOps)
    {
        m_iOps = 0;
        m_idServer = FOLDERID_INVALID;
        m_idFolder = FOLDERID_INVALID;
        if (m_pServer != NULL)
        {
            m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
            m_pServer->Release();
            m_pServer = NULL;
        }

        if (m_pLocalFolder != NULL)
        {
            m_pLocalFolder->Release();
            m_pLocalFolder = NULL;
        }

        while (TRUE)
        {
            if (m_iid == m_cid)
            {
                hr = S_FALSE;

                if (m_idFolderSel != FOLDERID_INVALID &&
                    m_fSyncSel)
                {
                    if (SUCCEEDED(g_pLocalStore->GetFolderInfo(m_idFolderSel, &Folder)))
                    {
                        if (SUCCEEDED(CreateMessageServerType(Folder.tyFolder, &m_pServer)) &&
                            SUCCEEDED(g_pLocalStore->OpenFolder(m_idFolderSel, NULL, NOFLAGS, &m_pLocalFolder)) &&
                            SUCCEEDED(GetFolderServerId(m_idFolderSel, &m_idServer)) &&
                            SUCCEEDED(m_pServer->Initialize(g_pLocalStore, m_idServer, m_pLocalFolder, m_idFolderSel)))
                        {
                            if (E_PENDING == m_pServer->SynchronizeFolder(SYNC_FOLDER_CACHED_HEADERS | SYNC_FOLDER_NEW_HEADERS, 0, this))
                            {
                                m_idOperation = SYNCOPID_INVALID;

                                hr = S_OK;
                            }
                        }

                        g_pLocalStore->FreeRecord(&Folder);
                    }
                }

                return(hr);
            }

            m_idServer = m_pid[m_iid++];
            hr = m_pEnum->Initialize(m_pDB, m_idServer);
            if (FAILED(hr))
                return(hr);

            hr = m_pEnum->Count(&m_cOps);
            if (FAILED(hr))
                return(hr);

            if (m_cOps > 0)
            {
                if (SUCCEEDED(g_pLocalStore->GetFolderInfo(m_idServer, &Folder)))
                {
                    AthLoadString(idsAccountLabelFmt, szT, ARRAYSIZE(szT));
                    wnsprintf(sz, ARRAYSIZE(sz), szT, Folder.pszName);
                    SetDlgItemText(m_hwndDlg, IDC_ACCOUNT_STATIC, sz);
                    g_pLocalStore->FreeRecord(&Folder);
                }

                SendDlgItemMessage(m_hwndDlg, idcProgBar, PBM_SETRANGE, 0, MAKELPARAM(0, m_cOps));
                break;
            }
        }
    }

    Assert(m_pEnum != NULL);

    hr = m_pEnum->Next(&info);
    if (hr != S_OK)
        return(hr);
    m_iOps++;

    if (info.idFolder != m_idFolder)
    {
        if (m_pServer != NULL)
        {
            m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
            m_pServer->Release();
            m_pServer = NULL;
        }

        if (m_pLocalFolder != NULL)
        {
            m_pLocalFolder->Release();
            m_pLocalFolder = NULL;
        }

        m_idFolder = info.idFolder;

        hr = g_pLocalStore->GetFolderInfo(m_idFolder, &Folder);
        if (SUCCEEDED(hr))
        {
            hr = CreateMessageServerType(Folder.tyFolder, &m_pServer);
            if (SUCCEEDED(hr))
            {
                hr = g_pLocalStore->OpenFolder(m_idFolder, NULL, NOFLAGS, &m_pLocalFolder);
                if (SUCCEEDED(hr))
                {
                    hr = m_pServer->Initialize(g_pLocalStore, m_idServer, m_pLocalFolder, m_idFolder);
                }
            }
            AthLoadString(idsFolderLabelFmt, szT, ARRAYSIZE(szT));
            wnsprintf(sz, ARRAYSIZE(sz), szT, Folder.pszName);
            SetDlgItemText(m_hwndDlg, IDC_FOO_STATIC, sz);

            g_pLocalStore->FreeRecord(&Folder);
        }

        if (FAILED(hr))
        {
            m_pDB->FreeRecord(&info);
            return(hr);
        }
    }

    SendDlgItemMessage(m_hwndDlg, idcProgBar, PBM_SETPOS, m_iOps, 0);

    switch (info.tyOperation)
    {
        case SYNC_DELETE_MSG:
            hr = _DoDeleteOp(&info);
            break;

        case SYNC_SETPROP_MSG:
            hr = _DoSetPropOp(&info);
            break;

        case SYNC_CREATE_MSG:
            hr = _DoCreateOp(&info);
            break;

        case SYNC_COPY_MSG:
        case SYNC_MOVE_MSG:
            hr = _DoCopyOp(&info);
            break;

        default:
            Assert(FALSE);
            break;
    }

    if (FAILED(hr))
    {
        Assert(hr != E_PENDING);
        m_pDB->DeleteRecord(&info);

        PostMessage(m_hwndDlg, WM_NEXT_OPERATION, 0, 0);
    }
    else
    {
        m_idOperation = info.idOperation;
    }
    m_pDB->FreeRecord(&info);

    return(S_OK);
}

HRESULT COfflinePlayback::_DoDeleteOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;

    Assert(pInfo != NULL);

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessage;

    hr = m_pServer->DeleteMessages(pInfo->dwFlags, &list, this);
    if (hr == E_PENDING)
        hr = S_OK;
    else
        Assert(FAILED(hr));

    return(hr);
}

HRESULT COfflinePlayback::_DoSetPropOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessage;

    flags.dwRemove = pInfo->dwRemove;
    flags.dwAdd = pInfo->dwAdd;

    hr = m_pServer->SetMessageFlags(&list, &flags, SET_MESSAGE_FLAGS_FORCE, this);
    if (hr == E_PENDING)
        hr = S_OK;
    else
        Assert(FAILED(hr));

    return(hr);
}

HRESULT COfflinePlayback::_DoCreateOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    IMimeMessage *pMessage;
    IStream *pStream;
    MESSAGEINFO Message;
    PROPVARIANT rVariant;
    LPFILETIME pftRecv;
    DWORD dwFlags;

    Assert(pInfo != NULL);

    hr = m_pLocalFolder->OpenMessage(pInfo->idMessage, 0, &pMessage, NULL);
    if (SUCCEEDED(hr))
    {
        dwFlags = 0;
        ZeroMemory(&Message, sizeof(MESSAGEINFO));
        Message.idMessage = pInfo->idMessage;
        if (DB_S_FOUND == m_pLocalFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
        {
            dwFlags = Message.dwFlags;

            m_pLocalFolder->FreeRecord(&Message);
        }

        hr = pMessage->GetMessageSource(&pStream, 0);
        if (SUCCEEDED(hr))
        {
            rVariant.vt = VT_FILETIME;
            if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
                pftRecv = &rVariant.filetime;
            else
                pftRecv = NULL;

            hr = m_pServer->PutMessage(m_idFolder, dwFlags, pftRecv, pStream, this);
            if (hr == E_PENDING)
                hr = S_OK;
            else
                Assert(FAILED(hr));

            pStream->Release();
        }

        pMessage->Release();
    }

    return(hr);
}

HRESULT COfflinePlayback::_DoCopyOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    MESSAGEINFO infoSrc, infoDest;
    ADJUSTFLAGS flags, *pFlags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_COPY_MSG || pInfo->tyOperation == SYNC_MOVE_MSG);
    Assert(m_pFolderDest == NULL);

    hr = g_pLocalStore->OpenFolder(pInfo->idFolderDest, NULL, NOFLAGS, &m_pFolderDest);
    if (SUCCEEDED(hr))
    {
        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        if (pInfo->dwRemove != 0 || pInfo->dwAdd != 0)
        {
            flags.dwRemove = pInfo->dwRemove;
            flags.dwAdd = pInfo->dwAdd;
            pFlags = &flags;
        }
        else
        {
            pFlags = NULL;
        }

        hr = m_pServer->CopyMessages(m_pFolderDest, pInfo->tyOperation == SYNC_MOVE_MSG ? COPY_MESSAGE_MOVE : NOFLAGS,
                                        &list, pFlags, this);
        if (hr == E_PENDING)
        {
            hr = S_OK;
        }
        else
        {
            Assert(FAILED(hr));

            m_pFolderDest->Release();
            m_pFolderDest = NULL;
        }
    }

    return(hr);
}

HRESULT COfflinePlayback::_HandleSetPropComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_SETPROP_MSG);
    Assert(m_pLocalFolder != NULL);

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        flags.dwAdd = pInfo->dwRemove;
        flags.dwRemove = pInfo->dwAdd;

        hr = m_pLocalFolder->SetMessageFlags(&list, &flags, NULL, NULL);
    }
    
    return(S_OK);
}

HRESULT COfflinePlayback::_HandleCreateComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    FOLDERINFO Folder;
    MESSAGEIDLIST list;
    IMessageFolder *pErrorFolder;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_CREATE_MSG);
    Assert(m_pLocalFolder != NULL);

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessage;

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        hr = OpenErrorsFolder(&pErrorFolder);
        if (SUCCEEDED(hr))
        {
            hr = m_pLocalFolder->CopyMessages(pErrorFolder, NOFLAGS, &list, NULL, NULL, NULL);
            if (SUCCEEDED(hr))
                m_cMovedToErrors++;

            pErrorFolder->Release();
        }
    }

    // get rid of the temp offline msg
    hr = m_pLocalFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NULL);
    Assert(SUCCEEDED(hr));

    if (pInfo->idFolder == m_idFolderSel)
        m_fSyncSel = TRUE;

    return(S_OK);
}

HRESULT COfflinePlayback::_HandleDeleteComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_DELETE_MSG);
    Assert(m_pLocalFolder != NULL);

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        flags.dwAdd = 0;
        flags.dwRemove = ARF_DELETED_OFFLINE;

        hr = m_pLocalFolder->SetMessageFlags(&list, &flags, NULL, NULL);
    }
    
    return(S_OK);
}

HRESULT COfflinePlayback::_HandleCopyComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_COPY_MSG || pInfo->tyOperation == SYNC_MOVE_MSG);
    Assert(m_pLocalFolder != NULL);

    if (pInfo->tyOperation == SYNC_MOVE_MSG && FAILED(hrOperation))
    {
        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        flags.dwAdd = 0;
        flags.dwRemove = ARF_DELETED_OFFLINE;

        hr = m_pLocalFolder->SetMessageFlags(&list, &flags, NULL, NULL);
    }

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        // TODO: we need more robust error handling in here
    }

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessageDest;

    // get rid of the temp offline msg
    hr = m_pFolderDest->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NULL);
    Assert(SUCCEEDED(hr));

    if (pInfo->idFolderDest == m_idFolderSel)
        m_fSyncSel = TRUE;

    m_pFolderDest->Release();
    m_pFolderDest = NULL;

    return(S_OK);
}

HRESULT OpenErrorsFolder(IMessageFolder **ppFolder)
{
    FOLDERINFO Folder;
    HRESULT hr;
    char szFolder[CCHMAX_FOLDER_NAME];

    Assert(g_pLocalStore != NULL);
    Assert(ppFolder != NULL);

    hr = g_pLocalStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_ERRORS, &Folder);
    if (SUCCEEDED(hr))
    {
        hr = g_pLocalStore->OpenFolder(Folder.idFolder, NULL, NOFLAGS, ppFolder);

        g_pLocalStore->FreeRecord(&Folder);
    }
    else if (hr == DB_E_NOTFOUND)
    {
        LoadString(g_hLocRes, idsOfflineErrors, szFolder, ARRAYSIZE(szFolder));

        // Fill the Folder Info
        ZeroMemory(&Folder, sizeof(FOLDERINFO));
        Folder.idParent = FOLDERID_LOCAL_STORE;
        Folder.tySpecial = FOLDER_ERRORS;
        Folder.pszName = szFolder;
        Folder.dwFlags = FOLDER_SUBSCRIBED;

        // Create the Folder
        hr = g_pLocalStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK);
        if (SUCCEEDED(hr))
            hr = g_pLocalStore->OpenFolder(Folder.idFolder, NULL, NOFLAGS, ppFolder);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\store.h ===
//--------------------------------------------------------------------------
// Store.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "dbimpl.h"

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CProgress;
interface IImnAccountManager;

//--------------------------------------------------------------------------
// SERVERFOLDER
//--------------------------------------------------------------------------
typedef struct tagSERVERFOLDER *LPSERVERFOLDER;
typedef struct tagSERVERFOLDER {
    FOLDERID        idServer;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    FOLDERID        rgidSpecial[FOLDER_MAX];
    LPSERVERFOLDER  pNext;
} SERVERFOLDER;

//--------------------------------------------------------------------------
// CMessageStore
//--------------------------------------------------------------------------
class CMessageStore : public IMessageStore, public IDatabaseExtension
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CMessageStore(BOOL fMigrate);
    ~CMessageStore(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageStore Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(LPCSTR pszDirectory);
    STDMETHODIMP Validate(DWORD dwReserved);
    STDMETHODIMP GetDirectory(LPSTR pszDirectory, DWORD cchMaxDir);
    STDMETHODIMP Synchronize(FOLDERID idFolder, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP FindServerId(LPCSTR pszAcctId, LPFOLDERID pidStore);
    STDMETHODIMP CreateServer(IImnAccount *pAcct, FLDRFLAGS dwFlags, LPFOLDERID pidFolder);
    STDMETHODIMP CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, LPFOLDERINFO pInfo, IStoreCallback *pCallback);
    STDMETHODIMP OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer, SPECIALFOLDER tySpecial, IMessageFolder **ppFolder);
    STDMETHODIMP OpenFolder(FOLDERID idFolder, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder);
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo);
    STDMETHODIMP GetSpecialFolderInfo(FOLDERID idStore, SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo);
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP UpdateFolderCounts(FOLDERID idFolder, LONG lMsgs, LONG lUnread, LONG lWatchedUnread, LONG lWatched);
    STDMETHODIMP EnumChildren(FOLDERID idParent, BOOL fSubscribed, IEnumerateFolders **ppEnum);
    STDMETHODIMP GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IDatabaseExtension Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IDatabase *pDB);
    STDMETHODIMP OnLock(void);
    STDMETHODIMP OnUnlock(void);
    STDMETHODIMP OnRecordInsert(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnRecordUpdate(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew);
    STDMETHODIMP OnRecordDelete(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnExecuteMethod(METHODID idMethod, LPVOID pBinding, LPDWORD pdwResult);

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(FALSE, m_pDB);

    //----------------------------------------------------------------------
    // MigrateToDBX
    //----------------------------------------------------------------------
    HRESULT MigrateToDBX(void);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _ComputeMessageCounts(IDatabase *pDB, LPDWORD pcMsgs, LPDWORD pcUnread);
    HRESULT _DeleteSiblingsAndChildren(LPFOLDERINFO pParent);
    HRESULT _InternalDeleteFolder(LPFOLDERINFO pDelete);
    HRESULT _InsertFolderFromFile(LPCSTR pszAcctId, LPCSTR pszFile);
    HRESULT _ValidateServer(LPFOLDERINFO pServer);
    HRESULT _DeleteFolderFile(LPFOLDERINFO pFolder);
    HRESULT _MakeUniqueFolderName(FOLDERID idParent, LPCSTR pszOriginalName, LPSTR *ppszNewName);
    HRESULT _CountDeleteChildren(FOLDERID idParent, LPDWORD pcChildren);
    HRESULT _ValidateSpecialFolders(LPFOLDERINFO pServer);
    HRESULT _LoadServerTable(HLOCK hLock);
    HRESULT _FreeServerTable(HLOCK hLock);
    HRESULT _GetSpecialFolderId(FOLDERID idStore, SPECIALFOLDER tySpecial, LPFOLDERID pidFolder);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    LPSTR               m_pszDirectory; // Current Store Directory
    IDatabase          *m_pDB;          // Database Table
    IDatabaseSession   *m_pSession;     // Local Session if store is running as inproc server
    IImnAccountManager2 *m_pActManRel;  // Used for migration
    BOOL                m_fMigrate;     // Created Precisely for Migration
    LPSERVERFOLDER      m_pServerHead;  // List of Cached Server Nodes and their special folders...
};

//--------------------------------------------------------------------------
// ProtoTypes
//--------------------------------------------------------------------------
HRESULT CreateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT CreateMigrateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT CreateFolderDatabaseExt(IUnknown *pUnkOuter, IUnknown **ppUnknown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\storecb.h ===
#ifndef _INC_STORECB
#define _INC_STORECB

#include "storutil.h"

HRESULT CopyMessagesProgress(HWND hwnd, IMessageFolder *pFolder, IMessageFolder *pDest,
    COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags);
HRESULT MoveFolderProgress(HWND hwnd, FOLDERID idFolder, FOLDERID idParentNew);
HRESULT DeleteFolderProgress(HWND hwnd, FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags);
HRESULT DeleteMessagesProgress(HWND hwnd, IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList);
HRESULT RenameFolderProgress(HWND hwnd, FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags);
HRESULT SetMessageFlagsProgress(HWND hwnd, IMessageFolder *pFolder, LPADJUSTFLAGS pFlags, LPMESSAGEIDLIST pList);

#define WM_STORE_COMPLETE   (WM_USER + 666)
#define WM_STORE_PROGRESS   (WM_USER + 667)

class CStoreCB : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServer);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        virtual HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CStoreCB();
        ~CStoreCB();

        HRESULT Initialize(HWND hwnd, LPCSTR pszText, BOOL fProgress);
        HRESULT Block(void);
        HRESULT Close(void);
        HRESULT Reset(void);

        static INT_PTR CALLBACK StoreCallbackDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    private:

        void    _ShowDlg(void);

        ULONG       m_cRef;
        HRESULT     m_hr;
        HWND        m_hwndParent;
        HWND        m_hwndDlg;
        HWND        m_hwndProg;
        BOOL        m_fComplete;
        HCURSOR     m_hcur;
        UINT_PTR    m_uTimer;
        LPSTR       m_pszText;
        BOOL        m_fProgress;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        HTIMEOUT    m_hTimeout;
};

class CStoreDlgCB : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        virtual HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CStoreDlgCB(void);
        ~CStoreDlgCB(void);

        void Initialize(HWND hwndDlg);
        void Reset(void);
        void Cancel(void);
        HRESULT GetResult(void);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        HWND        m_hwndDlg;
        BOOL        m_fComplete;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        HTIMEOUT    m_hTimeout;
};

#endif // _INC_STORECB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\storsync.cpp ===
#include "pch.hxx"
#include "instance.h"
#include "storsync.h"
#include "msgfldr.h"
#include "storutil.h"
#include "store.h"
#include "fldrsync.h"
#include <conman.h>

IMessageStore *g_pLocalStore = NULL;

HRESULT InitializeStore(DWORD dwFlags /* MSOEAPI_xxx Flags from msoeapi.idl */)
{
    HRESULT hr;
    CStoreSync *pStore;
    char szStoreDir[MAX_PATH + MAX_PATH];

    hr = S_OK;

    if (g_pStore == NULL)
    {
        Assert(g_pLocalStore == NULL);

        hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
        if (FAILED(hr))
            return(hr);

        g_pLocalStore = new CMessageStore(FALSE);
        if (g_pLocalStore == NULL)
            return(E_OUTOFMEMORY);

        hr = g_pLocalStore->Initialize(szStoreDir);
        if (SUCCEEDED(hr))
        {
            pStore = new CStoreSync;
            if (pStore == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = pStore->Initialize(g_pLocalStore);
                if (SUCCEEDED(hr))
                {
                    g_pStore = pStore;
                    hr = g_pLocalStore->Validate(ISFLAGSET(dwFlags, MSOEAPI_START_STOREVALIDNODELETE) ? STORE_VALIDATE_DONTSYNCWITHACCOUNTS : 0);
                }
                else
                {
                    pStore->Release();
                }
            }
        }
    
        hr = ((CMessageStore *)g_pLocalStore)->MigrateToDBX();
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::CStoreSync
//--------------------------------------------------------------------------
CStoreSync::CStoreSync(void)
{
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_pLocalStore = NULL;
    m_fConManAdvise = FALSE;
    ZeroMemory(m_rgts, sizeof(m_rgts));
}

//--------------------------------------------------------------------------
// CStoreSync::~CStoreSync
//--------------------------------------------------------------------------
CStoreSync::~CStoreSync(void)
{
    DWORD i, j;

    SafeRelease(m_pLocalStore);

    if (m_fConManAdvise && g_pConMan != NULL)
        g_pConMan->Unadvise((IConnectionNotify *)this);

    for (j = 0; j < CMAXTHREADS; j++)
    {
        if (m_rgts[j].pEntry != NULL)
        {
            for (i = 0; i < m_rgts[j].cEntry; i++)
            {
                if (m_rgts[j].pEntry[i].pServer != NULL)
                    {
                    m_rgts[j].pEntry[i].pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
                    m_rgts[j].pEntry[i].pServer->Release();
                    }
            }

            MemFree(m_rgts[j].pEntry);
        }
    }

    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CStoreSync::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IMessageStore *)this;
    else if (IID_IMessageStore == riid)
        *ppv = (IMessageStore *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IConnectionNotify == riid)
        *ppv = (IConnectionNotify *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreSync::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreSync::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CStoreSync::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreSync::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CStoreSync::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::Initialize(LPCSTR pszDirectory)
{
    Assert(FALSE);
    return(E_NOTIMPL);
}

HRESULT CStoreSync::Initialize(IMessageStore *pLocalStore)
{
    HRESULT         hr;

    Assert(pLocalStore != NULL);
    Assert(g_pConMan != NULL);
    Assert(g_pAcctMan != NULL);

    // local store operation only

    m_pLocalStore = pLocalStore;
    m_pLocalStore->AddRef();

    hr = g_pConMan->Advise((IConnectionNotify *)this);
    m_fConManAdvise = SUCCEEDED(hr);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::Validate
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::Validate(DWORD dwReserved)
{
    HRESULT         hr;

    // local store operation only

    hr = m_pLocalStore->Validate(dwReserved);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::GetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::GetDirectory(LPSTR pszDir, DWORD cchMaxDir)
{
    HRESULT         hr;

    Assert(NULL != pszDir);

    // local store operation only

    hr = m_pLocalStore->GetDirectory(pszDir, cchMaxDir);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::Synchronize(FOLDERID idFolder, 
    SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback)
{
    BOOL            fOffline;
    FOLDERINFO      info;
    HRESULT         hr;
    IMessageServer *pServer;

    Assert(FOLDERID_ROOT != idFolder);

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);

    // if online, sync folder list
    // if offline, no op (fail)

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(!!(info.dwFlags & FOLDER_SERVER));

        if (info.tyFolder != FOLDER_LOCAL)
        {
            if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->SynchronizeStore(idFolder, dwFlags, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::CreateServer
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::CreateServer(IImnAccount *pAcct, FLDRFLAGS dwFlags, 
    LPFOLDERID pidFolder)
{
    HRESULT         hr;

    // local store operation only
    // create node in local store for server

    hr = m_pLocalStore->CreateServer(pAcct, dwFlags, pidFolder);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::CreateFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, 
    LPFOLDERINFO pInfo, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idFolder;
    DWORD           dwFlags;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != pInfo);
    Assert(NULL != pInfo->pszName);
    Assert(0 == (pInfo->dwFlags & FOLDER_SERVER));

    if (NULL == pInfo->pszName || FIsEmpty(pInfo->pszName))
        return(STORE_E_BADFOLDERNAME);

    // if online, create folder on server and then create one in local store
    // if offline, not supported (fail)

    GetFolderServerId(pInfo->idParent, &idFolder);

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder == FOLDER_LOCAL ||
            dwCreateFlags == CREATE_FOLDER_LOCALONLY)
        {
            dwFlags = pInfo->dwFlags;

            if (pInfo->tySpecial == FOLDER_NOTSPECIAL && info.tyFolder == FOLDER_LOCAL)
                pInfo->dwFlags |= FOLDER_CANRENAME | FOLDER_CANDELETE;
            
            hr = m_pLocalStore->CreateFolder(dwCreateFlags, pInfo, NOSTORECALLBACK);
            
            pInfo->dwFlags = dwFlags;
        }
        else
        {
            Assert(info.tyFolder != FOLDER_NEWS);

            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                {
                    hr = pServer->CreateFolder(pInfo->idParent, pInfo->tySpecial, pInfo->pszName, pInfo->dwFlags, pCallback);
                }
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::OpenSpecialFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer, 
    SPECIALFOLDER tySpecial, IMessageFolder **ppFolder)
{
    HRESULT         hr;
    FOLDERINFO      Folder;

    // local store operation only

    hr = GetSpecialFolderInfo(idStore, tySpecial, &Folder);
    if (SUCCEEDED(hr))
    {
        hr = OpenFolder(Folder.idFolder, pServer, NOFLAGS, ppFolder);

        m_pLocalStore->FreeRecord(&Folder);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::OpenFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::OpenFolder(FOLDERID idFolder, IMessageServer *pServerUseMeIfYouCan, 
    OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder)
{
    char            sz[CCHMAX_ACCOUNT_NAME];
    FOLDERINFO      info;
    HRESULT         hr;
    CFolderSync    *pFolder;
    CMessageFolder *pMsgFolder;
    IMessageServer *pServer;
    IMessageFolder *pLocalFolder=NULL;
    FOLDERTYPE      tyFolder;
    FOLDERID        idParent;
    BOOL            fFind;

    Assert(NULL != ppFolder);

    // local store operation only

    pServer = NULL;
    *ppFolder = NULL;

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    hr = m_pLocalStore->GetFolderInfo(idFolder, &info);
    if (hr != S_OK)
        return(E_FAIL);

    tyFolder = info.tyFolder;
    fFind = !!(info.dwFlags & FOLDER_FINDRESULTS);

    m_pLocalStore->FreeRecord(&info);

    if (fFind)
    {
        hr = m_pLocalStore->OpenFolder(idFolder, NULL, dwFlags, &pLocalFolder);
        if (SUCCEEDED(hr))
            *ppFolder = pLocalFolder;
        return(hr);
    }

    pFolder = new CFolderSync;
    if (pFolder == NULL)
        return(E_OUTOFMEMORY);

    Assert(hr == S_OK);
    if (tyFolder != FOLDER_LOCAL)
    {
        hr = m_pLocalStore->OpenFolder(idFolder, NULL, dwFlags, &pLocalFolder);
        if (SUCCEEDED(hr))
        {
            if (pServerUseMeIfYouCan != NULL)
            {
                hr = pServerUseMeIfYouCan->ResetFolder(pLocalFolder, idFolder);
                if (SUCCEEDED(hr))
                {
                    pServer = pServerUseMeIfYouCan;
                    pServer->AddRef();
                }
            }

            if (pServer == NULL)
            {
                hr = CreateMessageServerType(tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->Initialize(m_pLocalStore, idParent, pLocalFolder, idFolder);
            }
        }
    }

    if (SUCCEEDED(hr))
        hr = pFolder->Initialize((IMessageStore *)m_pLocalStore, pLocalFolder, pServer, dwFlags, tyFolder, idFolder, idParent);

    if (SUCCEEDED(hr))
    {
        *ppFolder = (IMessageFolder *)pFolder;
        pFolder->AddRef();
    }

    if (pServer != NULL)
        pServer->Release();
    pFolder->Release();
    if (pLocalFolder)
        pLocalFolder->Release();

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::MoveFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, 
    MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idAcct, idAcctNew;
    HRESULT         hr;
    IMessageServer *pServer;
    BOOL            fOffline;

    // if online, move folder on server and then move folder in local store
    // if offline, not supported (fail)

    if (idFolder == idParentNew)
        return(S_OK);

    hr = GetFolderServerId(idParentNew, &idAcctNew);
    if (hr != S_OK)
        return(E_FAIL);

    hr = GetFolderServerId(idFolder, &idAcct);
    if (hr != S_OK)
        return(E_FAIL);

    // can't move between servers...
    if (idAcct != idAcctNew)
        return(hrCantMoveFolderBetweenServers);

    hr = IsSubFolder(idParentNew, idFolder);
    if (hr == S_OK)
        return(hrCantMoveIntoSubfolder);
    else if (FAILED(hr))
        return(hr);

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_NEWS);

        if (info.tyFolder == FOLDER_LOCAL)
        {
            hr = m_pLocalStore->MoveFolder(idFolder, idParentNew, dwFlags, NULL);
        }
        else
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->MoveFolder(idFolder, idParentNew, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::RenameFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::RenameFolder(FOLDERID idFolder, LPCSTR pszName, 
    RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idParent;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != pszName);

    // if online, rename folder on server and then rename folder in local store
    // if offline, not supported (fail)

    if (FIsEmpty(pszName))
        return(STORE_E_BADFOLDERNAME);

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    if (idParent == idFolder)
    {
        // this is a server node, so we just handle it in the local store
        hr = m_pLocalStore->RenameFolder(idFolder, pszName, dwFlags, NULL);
        return(hr);
    }

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_NEWS);

        if (info.tyFolder == FOLDER_LOCAL)
        {
            hr = m_pLocalStore->RenameFolder(idFolder, pszName, dwFlags, NULL);
        }
        else
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->RenameFolder(idFolder, pszName, pCallback);
            }

        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::DeleteFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::DeleteFolder(FOLDERID idFolder, 
    DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idParent;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(FOLDERID_ROOT != idFolder);
    Assert(FOLDERID_INVALID != idFolder);

    // if online, delete folder on server and then delete folder in local store
    // if offline, not supported (fail)

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    if (idParent == idFolder)
    {
        // this is a server node, so we just handle it in the local store
        hr = m_pLocalStore->DeleteFolder(idFolder, dwFlags, pCallback);
        return(hr);
    }

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_NEWS);

        if (info.tyFolder == FOLDER_LOCAL)
        {
            hr = m_pLocalStore->DeleteFolder(idFolder, dwFlags, NULL);
        }
        else
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->DeleteFolder(idFolder, dwFlags, pCallback);
            }

        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::FindServerId
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::FindServerId(LPCSTR pszAcctId, LPFOLDERID pidServer)
{
    HRESULT         hr;

    Assert(pszAcctId != NULL);
    Assert(pidServer != NULL);

    // local store operation only

    hr = m_pLocalStore->FindServerId(pszAcctId, pidServer);

    return(hr);
}

//--------------------------------------------------------------------------
// GetFolderInfo
//--------------------------------------------------------------------------
HRESULT CStoreSync::GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo)
{
    HRESULT         hr;

    Assert(pInfo != NULL);

    // local store operation only

    hr = m_pLocalStore->GetFolderInfo(idFolder, pInfo);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::EnumChildren
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::EnumChildren(FOLDERID idParent, BOOL fSubscribed, 
    IEnumerateFolders **ppEnum)
{
    HRESULT         hr;

    Assert(ppEnum != NULL);

    // local store operation only

    hr = m_pLocalStore->EnumChildren(idParent, fSubscribed, ppEnum);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::GetSpecialFolderInfo
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::GetSpecialFolderInfo(FOLDERID idStore,
    SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo)
{
    HRESULT         hr;

    Assert(NULL != pInfo);
    Assert(FOLDER_NOTSPECIAL != tySpecial);

    // local store operation only

    hr = m_pLocalStore->GetSpecialFolderInfo(idStore, tySpecial, pInfo);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::SubscribeToFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::SubscribeToFolder(FOLDERID idFolder, 
    BOOL fSubscribed, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idParent;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != m_pLocalStore);

    // if imap and online, subscribe to folder on server and then in local store
    // otherwise, subscribe to folder in local store

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_LOCAL);

        if (info.tyFolder == FOLDER_NEWS)
        {
            hr = m_pLocalStore->SubscribeToFolder(idFolder, fSubscribed, NULL);
        }
        else
        {
            Assert(info.tyFolder == FOLDER_IMAP);

            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->SubscribeToFolder(idFolder, fSubscribed, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

STDMETHODIMP CStoreSync::GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(m_pLocalStore != NULL);

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);

    // if news server and online, get new groups on server

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder != FOLDER_NEWS ||
            0 == (info.dwFlags & FOLDER_SERVER))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->GetNewGroups(pSysTime, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::GetFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT         hr;
    FOLDERINFO      info;
    FOLDERID        idParent;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != m_pLocalStore);

    // if imap or news, pass GetFolderCounts call through to server obj
    // otherwise, this function should not have been called so returns error

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder != FOLDER_LOCAL)
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->GetFolderCounts(idFolder, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::UpdateFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::UpdateFolderCounts(FOLDERID idFolder, LONG lMessages,
    LONG lUnread, LONG lWatchedUnread, LONG lWatched)
{
    HRESULT         hr;

    Assert(NULL != m_pLocalStore);

    // local store operation only

    hr = m_pLocalStore->UpdateFolderCounts(idFolder, lMessages, lUnread, lWatchedUnread, lWatched);

    return(hr);
}

STDMETHODIMP CStoreSync::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan)
{
    if (nCode == CONNNOTIFY_CONNECTED)
    {
        
    }
    else if (((nCode == CONNNOTIFY_WORKOFFLINE) && (pvData)) ||
              (nCode == CONNNOTIFY_DISCONNECTED))
    {
        DWORD   i, j;

        for (j = 0; j < CMAXTHREADS; j++)
        {
            if (m_rgts[j].pEntry != NULL)
            {
                for (i = 0; i < m_rgts[j].cEntry; i++)
                {
                    if (m_rgts[j].pEntry[i].pServer != NULL)
                    {
                        m_rgts[j].pEntry[i].pServer->Close(MSGSVRF_DROP_CONNECTION);
                    }
                }
            }
        }
    }

    return(S_OK);
}

HRESULT CStoreSync::_GetFolderInfo(FOLDERID id, FOLDERINFO *pInfo, BOOL *pfOffline)
{
    HRESULT hr;

    Assert(pInfo != NULL);
    Assert(pfOffline != NULL);

    hr = m_pLocalStore->GetFolderInfo(id, pInfo);
    if (SUCCEEDED(hr))
    {
        //*pfOffline = g_pConMan->IsGlobalOffline();
        *pfOffline = FALSE;
    }

    return(hr);
}

HRESULT CStoreSync::_GetServer(FOLDERID idServer, FOLDERID idFolder, FOLDERTYPE tyFolder, IMessageServer **ppServer)
{
    HRESULT hr;
    IMessageServer *pServer;
    DWORD i;
    FOLDERINFO info;
    SERVERENTRY *pEntry;
    DWORD dwThreadId;
    THREADSERVERS *pts;

    Assert(FOLDER_LOCAL != tyFolder);
    Assert(FOLDER_ROOTNODE != tyFolder);
    Assert(ppServer != NULL);
    Assert(idServer == idFolder);

    // TODO: figure out a way not to hold onto these IMessageServer objects...

    *ppServer = NULL;

    dwThreadId = GetCurrentThreadId();
    Assert(dwThreadId != 0);

    for (i = 0, pts = m_rgts; i < CMAXTHREADS; i++, pts++)
    {
        if (dwThreadId == pts->dwThreadId)
        {
            break;
        }
        else if (pts->dwThreadId == 0)
        {
            pts->dwThreadId = dwThreadId;
            break;
        }
    }
    Assert(i != CMAXTHREADS);

    for (i = 0, pEntry = pts->pEntry; i < pts->cEntry; i++, pEntry++)
    {
        if (pEntry->idFolder == idFolder)
        {
            Assert(pEntry->idServer == idServer);
            *ppServer = pEntry->pServer;
            return(S_OK);
        }
    }

    if (pts->cEntry == pts->cEntryBuf)
    {
        i = pts->cEntryBuf + 16;
        if (!MemRealloc((void **)&pts->pEntry, i * sizeof(SERVERENTRY)))
            return(E_OUTOFMEMORY);
        pts->cEntryBuf = i;
    }

    hr = m_pLocalStore->GetFolderInfo(idServer, &info);
    if (SUCCEEDED(hr))
    {
        hr = CreateMessageServerType(tyFolder, &pServer);
        if (SUCCEEDED(hr))
        {
            hr = pServer->Initialize(m_pLocalStore, idServer, NULL, FOLDERID_INVALID);
            if (SUCCEEDED(hr))
            {
                pEntry = &pts->pEntry[pts->cEntry];
                pEntry->pServer = pServer;
                pEntry->idServer = idServer;
                pEntry->idFolder = idFolder;
                pts->cEntry++;

                *ppServer = pServer;
            }
            else
            {
                pServer->Release();
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\storecb.cpp ===
#include "pch.hxx"
#include "storecb.h"
#include "storutil.h"
#include <progress.h>

HRESULT CopyMessagesProgress(HWND hwnd, IMessageFolder *pFolder, IMessageFolder *pDest,
    COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags)
{
    CStoreCB *pCB;
    HRESULT hr;

    Assert(pFolder != NULL);

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, !!(dwFlags & COPY_MESSAGE_MOVE) ? MAKEINTRESOURCE(idsMovingMessages) : MAKEINTRESOURCE(idsCopyingMessages), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pFolder->CopyMessages(pDest, dwFlags, pList, pFlags, NULL, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT MoveFolderProgress(HWND hwnd, FOLDERID idFolder, FOLDERID idParentNew)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsMovingFolder), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->MoveFolder(idFolder, idParentNew, 0, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT DeleteFolderProgress(HWND hwnd, FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsDeletingFolder), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->DeleteFolder(idFolder, dwFlags, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT DeleteMessagesProgress(HWND hwnd, IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList)
{
    CStoreCB *pCB;
    HRESULT hr;

    Assert(pFolder != NULL);

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, !!(dwOptions & DELETE_MESSAGE_UNDELETE) ? MAKEINTRESOURCE(idsUndeletingMessages) : MAKEINTRESOURCE(idsDeletingMessages), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pFolder->DeleteMessages(dwOptions, pList, NULL, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT RenameFolderProgress(HWND hwnd, FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsRenamingFolder), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->RenameFolder(idFolder, pszName, dwFlags, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT SetMessageFlagsProgress(HWND hwnd, IMessageFolder *pFolder, LPADJUSTFLAGS pFlags, LPMESSAGEIDLIST pList)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsSettingMessageFlags), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = pFolder->SetMessageFlags(pList, pFlags, NULL, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

CStoreCB::CStoreCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndParent = NULL;
    m_hwndDlg = NULL;
    m_hwndProg = NULL;
    m_fComplete = FALSE;
    m_fProgress = TRUE;
    m_pszText = NULL;
    m_hcur = NULL;
    m_uTimer = 0;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;
}

CStoreCB::~CStoreCB()
{
    Assert(m_hwndDlg == NULL);
    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();
    if (m_pszText != NULL)
        MemFree(m_pszText);
}

HRESULT STDMETHODCALLTYPE CStoreCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CStoreCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CStoreCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CStoreCB::Initialize(HWND hwnd, LPCSTR pszText, BOOL fProgress)
{
    HWND hwndT;

    // Replace hwnd with top-most parent: this ensures modal behaviour (all windows disabled)
    hwnd = GetTopMostParent(hwnd);
    m_hwndParent = hwnd;

    if (IS_INTRESOURCE(pszText))
        m_pszText = AthLoadString(PtrToUlong(pszText), 0, 0);
    else
        m_pszText = PszDup(pszText);
    if (m_pszText == NULL)
        return(E_OUTOFMEMORY);

    m_fProgress = fProgress;

    hwndT = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddCopyMoveMessages), hwnd, StoreCallbackDlgProc, (LPARAM)this);
    if (hwndT == NULL)
        return(E_FAIL);

    EnableWindow(hwnd, FALSE);
    m_hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    return(S_OK);
}

HRESULT CStoreCB::Reset()
{
    m_fComplete = FALSE;

    return(S_OK);
}

HRESULT CStoreCB::Block()
{
    MSG     msg;

    while (GetMessage(&msg, NULL, 0, 0))
        {
        if (m_hcur)
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        if (m_fComplete)
            break;
        }    

    return(m_hr);
}

HRESULT CStoreCB::Close()
{
    if (m_hcur != NULL)
        SetCursor(m_hcur);
    EnableWindow(m_hwndParent, TRUE);
    Assert(m_hwndDlg != NULL);
    DestroyWindow(m_hwndDlg);

    return(S_OK);
}

void CStoreCB::_ShowDlg()
{
    if (m_uTimer != 0)
    {
        KillTimer(m_hwndDlg, m_uTimer);
        m_uTimer = 0;

        ShowWindow(m_hwndDlg, SW_SHOW);

        if (m_hcur != NULL)
        {
            SetCursor(m_hcur);
            m_hcur = NULL;
        }
    }
}

HRESULT CStoreCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (0 == dwMax)
    {
        // dwMax can be 0 if we have to re-connect to the server (SOT_CONNECTION_STATUS progress)
        TraceInfo(_MSG("CStoreCB::OnProgress bailing on %s progress with dwMax = 0",
            sotToSz(tyOperation)));
        return S_OK;
    }

    if (m_hwndProg != NULL)
        SendMessage(m_hwndProg, PBM_SETPOS, (dwCurrent * 100) / dwMax, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwnd;

    GetParentWindow(0, &hwnd);

    return CallbackCanConnect(pszAccountId, hwnd,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    GetParentWindow(0, &hwnd);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_hr = hrComplete;
    m_fComplete = TRUE;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        _ShowDlg();
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    GetParentWindow(0, &hwnd);

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CStoreCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    _ShowDlg();
    *phwndParent = m_hwndDlg;

    return(S_OK);
}

INT_PTR CALLBACK CStoreCB::StoreCallbackDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CStoreCB       *pThis = (CStoreCB *)GetWindowLongPtr(hwnd, DWLP_USER);
        
    switch (uMsg)
    {
        case WM_INITDIALOG:
            Assert(lParam);
            pThis = (CStoreCB *)lParam;

            pThis->m_hwndDlg = hwnd;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            pThis->m_hwndProg = GetDlgItem(pThis->m_hwndDlg, idcProgBar);
            Assert(pThis->m_hwndProg != NULL);
            if (!pThis->m_fProgress)
            {
                ShowWindow(pThis->m_hwndProg, SW_HIDE);
                pThis->m_hwndProg = NULL;
            }

            CenterDialog(hwnd);

            SetDlgItemText(hwnd, idcStatic1, pThis->m_pszText);

            ShowWindow(hwnd, SW_HIDE);
            pThis->m_uTimer = SetTimer(hwnd, 666, 2000, NULL);
            break;

        case WM_TIMER:
            pThis->_ShowDlg();
            break;

        case WM_COMMAND:
            Assert(pThis != NULL);

            if (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
            {   
                if (pThis->m_pCancel != NULL)
                    pThis->m_pCancel->Cancel(CT_CANCEL);

                return(TRUE);
            }
            break;

        case WM_DESTROY:
            if (pThis->m_uTimer != 0)
            {
                KillTimer(hwnd, pThis->m_uTimer);
                pThis->m_uTimer = 0;
            }
            pThis->m_hwndDlg = NULL;
            break;
    }
    
    return(0);    
}

CStoreDlgCB::CStoreDlgCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndDlg = NULL;
    m_fComplete = TRUE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;
}

CStoreDlgCB::~CStoreDlgCB()
{
    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CStoreDlgCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CStoreDlgCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

void CStoreDlgCB::Initialize(HWND hwnd)
{
    Assert(hwnd != NULL);
    // Should be OK to Re-initilize
    //Assert(m_hwndDlg == NULL);

    m_hwndDlg = hwnd;
}

void CStoreDlgCB::Reset()
{
    Assert(m_hwndDlg != NULL);

    m_hr = E_FAIL;
    m_fComplete = FALSE;
}

void CStoreDlgCB::Cancel()
{
    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_CANCEL);
}

HRESULT CStoreDlgCB::GetResult()
{
    Assert(m_fComplete);
    return(m_hr);
}

HRESULT CStoreDlgCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    Assert(m_hwndDlg != NULL);
    Assert(!m_fComplete);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // If numbers > 16 bits, scale the progress to fit within 16-bit.
    // I'd like to avoid using floating-point, so let's use an integer algorithm
    // I'll just multiply numerator and denominator by 0.5 until we fit in 16 bits
    while (dwMax > 65535)
    {
        dwCurrent >>= 1;
        dwMax >>= 1;
    }

    PostMessage(m_hwndDlg, WM_STORE_PROGRESS, (DWORD)tyOperation, MAKELONG(dwMax, dwCurrent));
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwndParent;
    DWORD   dwReserved = 0;

    GetParentWindow(dwReserved, &hwndParent);

    return CallbackCanConnect(pszAccountId, hwndParent,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
    }

    PostMessage(m_hwndDlg, WM_STORE_COMPLETE, hrComplete, (DWORD)tyOperation);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\storsync.h ===
#ifndef __STORSYNC_H
#define __STORSYNC_H

#include <conman.h>
#include "dbimpl.h"

#define CMAXTHREADS     4

typedef struct tagSERVERENTRY
{
    FOLDERID            idServer;
    FOLDERID            idFolder;
    IMessageServer     *pServer;
} SERVERENTRY, *LPSERVERENTRY;

typedef struct tagTHREADSERVERS
{
    DWORD               dwThreadId;
    SERVERENTRY        *pEntry;
    DWORD               cEntry;
    DWORD               cEntryBuf;
} THREADSERVERS;

extern IMessageStore *g_pLocalStore;

class CStoreSync :
                public IMessageStore,
                public IConnectionNotify
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CStoreSync(void);
    ~CStoreSync(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageStore Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(LPCSTR pszDirectory);
    STDMETHODIMP Validate(DWORD dwReserved);
    STDMETHODIMP GetDirectory(LPSTR pszDirectory, DWORD cchMaxDir);
    STDMETHODIMP Synchronize(FOLDERID idFolder, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP FindServerId(LPCSTR pszAcctId, LPFOLDERID pidStore);
    STDMETHODIMP CreateServer(IImnAccount *pAcct, FLDRFLAGS dwFlags, LPFOLDERID pidFolder);
    STDMETHODIMP CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, LPFOLDERINFO pInfo, IStoreCallback *pCallback);
    STDMETHODIMP OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer, SPECIALFOLDER tySpecial, IMessageFolder **ppFolder);
    STDMETHODIMP OpenFolder(FOLDERID idFolder, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder);
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo);
    STDMETHODIMP GetSpecialFolderInfo(FOLDERID idStore, SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo);
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP UpdateFolderCounts(FOLDERID idFolder, LONG lMessages, LONG lUnread, LONG lWatchedUnread, LONG lWatched);
    STDMETHODIMP EnumChildren(FOLDERID idParent, BOOL fSubscribed, IEnumerateFolders **ppEnum);
    STDMETHODIMP GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IConnectionNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(FALSE, m_pLocalStore);

    HRESULT Initialize(IMessageStore *pLocalStore);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT     _GetFolderInfo(FOLDERID id, FOLDERINFO *pInfo, BOOL *pfOffline);
    HRESULT     _GetServer(FOLDERID idServer, FOLDERID idFolder, FOLDERTYPE tyFolder, IMessageServer **ppServer);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    IMessageStore      *m_pLocalStore;  // local message store
    BOOL                m_fConManAdvise;

    THREADSERVERS       m_rgts[CMAXTHREADS];
};

//--------------------------------------------------------------------------
// ProtoTypes
//--------------------------------------------------------------------------
HRESULT InitializeStore(DWORD dwFlags /* MSOEAPI_xxx Flags from msoeapi.idl */);

#endif // __STORSYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\sync.cpp ===
#include "pch.hxx"
#include "store.h"
#include "instance.h"
#include "storutil.h"
#include <conman.h>
#include <syncop.h>
#include <shared.h>
#include "enumsync.h"
#include "playback.h"
#include "sync.h"

COfflineSync *g_pSync = NULL;

//--------------------------------------------------------------------------
// COfflineSync::COfflineSync
//--------------------------------------------------------------------------
COfflineSync::COfflineSync(void)
{
    m_cRef = 1;
    m_pDB = NULL;
}

//--------------------------------------------------------------------------
// CFolderSync::~CFolderSync
//--------------------------------------------------------------------------
COfflineSync::~COfflineSync(void)
{
    if (m_pDB != NULL)
        m_pDB->Release();
}

//--------------------------------------------------------------------------
// CFolderSync::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP COfflineSync::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// COfflineSync::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COfflineSync::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COfflineSync::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COfflineSync::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

HRESULT COfflineSync::_SetMessageFlags(IMessageFolder *pFolder, FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage, MESSAGEFLAGS dwFlags, LPADJUSTFLAGS pFlags)
{
    MESSAGEFLAGS dwAdd, dwRemove;
    SYNCOPINFO info;
    MESSAGEIDLIST list;
    HRESULT hr;

    Assert(pFolder != NULL);
    Assert(pFlags != NULL);
    Assert(0 != pFlags->dwAdd || 0 != pFlags->dwRemove);

    // if no new flags are being added or only unset flags are being removed,
    // we don't need to do anything
    if ((dwFlags | pFlags->dwAdd) == dwFlags &&
        (dwFlags & pFlags->dwRemove) == 0)
        return(S_OK);

    hr = _FindExistingOperation(idServer, idFolder, idMessage,
            SYNC_CREATE_MSG | SYNC_SETPROP_MSG, SYNC_COPY_MSG | SYNC_MOVE_MSG, &info);
    if (FAILED(hr))
        return(hr);

    if (hr == S_OK)
    {
        if (info.tyOperation == SYNC_CREATE_MSG)
        {
            // this message has been created offline and will be uploaded to the
            // server, so we can just set the flags in the message and they will
            // get uploaded with the message
        }
        else
        {
            dwAdd = pFlags->dwAdd;
            dwRemove = pFlags->dwRemove;

            dwFlags = info.dwAdd & dwRemove;
            if (dwFlags != 0)
            {
                FLAGCLEAR(info.dwAdd, dwFlags);
                FLAGCLEAR(dwRemove, dwFlags);
            }

            dwFlags = info.dwRemove & dwAdd;
            if (dwFlags != 0)
            {
                FLAGCLEAR(info.dwRemove, dwFlags);
                FLAGCLEAR(dwAdd, dwFlags);
            }

            FLAGSET(info.dwAdd, dwAdd);
            FLAGSET(info.dwRemove, dwRemove);

            if (info.dwAdd == 0 && info.dwRemove == 0 && info.tyOperation == SYNC_SETPROP_MSG)
            {
                // no flags are being changed so we can get rid of this operation
                hr = m_pDB->DeleteRecord(&info);
            }
            else
            {
                hr = m_pDB->UpdateRecord(&info);
            }
        }

        m_pDB->FreeRecord(&info);

        if (FAILED(hr))
            return(hr);
    }
    else
    {
        // no create or set prop operations exist for this message yet,
        // so create a new one

        ZeroMemory(&info, sizeof(SYNCOPINFO));
        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
        if (FAILED(hr))
            return(hr);
        info.idServer = idServer;
        info.idFolder = idFolder;
        info.idMessage = idMessage;
        info.tyOperation = SYNC_SETPROP_MSG;
        // info.dwFlags
        info.dwAdd = (~dwFlags & pFlags->dwAdd);
        info.dwRemove = (dwFlags & pFlags->dwRemove);

        hr = m_pDB->InsertRecord(&info);
        if (FAILED(hr))
            return(hr);
    }

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &idMessage;
    hr = pFolder->SetMessageFlags(&list, pFlags, NULL, NULL);

    return(hr);
}

HRESULT COfflineSync::SetMessageFlags(IMessageFolder *pFolder, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags)
{
    DWORD i;
    FOLDERID idFolder, idServer;
    MESSAGEINFO Message;
    HRESULT hr;
    HROWSET hRowset = NULL;

    Assert(pFolder != NULL);
    Assert(pFlags != NULL);
    Assert(0 != pFlags->dwAdd || 0 != pFlags->dwRemove);

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServerId(idFolder, &idServer);
    if (FAILED(hr))
        return(hr);

    if (NULL == pList)
    {
        hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            Message.idMessage = pList->prgidMsg[i];

            hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
            if (FAILED(hr))
                break;
            else if (hr != DB_S_FOUND)
                continue;
        }
        else
        {
            hr = pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        hr = _SetMessageFlags(pFolder, idServer, idFolder, Message.idMessage, Message.dwFlags, pFlags);

        pFolder->FreeRecord(&Message);

        if (FAILED(hr))
            break;
    }

    if (hRowset != NULL)
        pFolder->CloseRowset(&hRowset);

    return(hr);
}

HRESULT COfflineSync::DeleteMessages(IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList)
{
    DWORD i;
    ADJUSTFLAGS afFlags;
    BOOL fNoOp, fImap;
    FOLDERINFO Server;
    FOLDERID idFolder, idServer;
    MESSAGEID idMessage;
    SYNCOPINFO info;
    MESSAGEIDLIST list;
    MESSAGEINFO Message;
    HRESULT hr;
    HROWSET hRowset = NULL;

    // TODO: what about trashcan deletes????

    Assert(pFolder != NULL);

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServer(idFolder, &Server);
    if (FAILED(hr))
        return(hr);

    idServer = Server.idFolder;
    fImap = (Server.tyFolder == FOLDER_IMAP);

    g_pStore->FreeRecord(&Server);

    if (fImap)
    {
        if (!!(dwFlags & DELETE_MESSAGE_UNDELETE))
        {
            afFlags.dwAdd = 0;
            afFlags.dwRemove = ARF_ENDANGERED;
        }
        else
        {
            afFlags.dwAdd = ARF_ENDANGERED;
            afFlags.dwRemove = 0;
        }

        return(SetMessageFlags(pFolder, pList, &afFlags));
    }

    Assert(0 == (dwFlags & DELETE_MESSAGE_UNDELETE));

    if (NULL == pList)
    {
        hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &idMessage;

    afFlags.dwAdd = ARF_DELETED_OFFLINE;
    afFlags.dwRemove = 0;

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            idMessage = pList->prgidMsg[i];
        }
        else
        {
            hr = pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }

            idMessage = Message.idMessage;

            pFolder->FreeRecord(&Message);
        }

        hr = _FindExistingOperation(idServer, idFolder, idMessage,
                SYNC_CREATE_MSG | SYNC_SETPROP_MSG, SYNC_COPY_MSG | SYNC_MOVE_MSG, &info);
        if (FAILED(hr))
            break;

        if (hr == S_OK)
        {
            fNoOp = TRUE;

            if (info.tyOperation == SYNC_CREATE_MSG || info.tyOperation == SYNC_COPY_MSG)
            {
                // we don't need to do this create or copy anymore because the message is being
                // deleted. we don't need to do the delete either because the message
                // has never existed on the server

                hr = m_pDB->DeleteRecord(&info);
            }
            else if (info.tyOperation == SYNC_SETPROP_MSG)
            {
                // if it is a set prop operation, we don't need to do it anymore because the message
                // is just getting deleted anyway

                fNoOp = FALSE;

                hr = m_pDB->DeleteRecord(&info);
            }
            else
            {
                Assert(info.tyOperation == SYNC_MOVE_MSG);

                // convert it to a delete operation which is the same as moving it then deleting it

                info.idFolderDest = 0;
                info.idMessageDest = 0;
                info.tyOperation = SYNC_DELETE_MSG;
                info.dwAdd = 0;
                info.dwRemove = 0;
                info.dwFlags = dwFlags;

                hr = m_pDB->UpdateRecord(&info);
            }

            m_pDB->FreeRecord(&info);

            if (FAILED(hr))
            {
                break;
            }
            else if (fNoOp)
            {
                hr = pFolder->DeleteMessages(dwFlags, &list, NULL, NULL);
                if (FAILED(hr))
                    break;

                continue;
            }
        }

        // create the delete operation

        ZeroMemory(&info, sizeof(SYNCOPINFO));
        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
        if (FAILED(hr))
            break;
        info.idServer = idServer;
        info.idFolder = idFolder;
        info.idMessage = idMessage;
        info.tyOperation = SYNC_DELETE_MSG;
        info.dwFlags = dwFlags;
        // info.dwAdd
        // info.dwRemove

        hr = m_pDB->InsertRecord(&info);
        if (FAILED(hr))
            break;

        hr = pFolder->SetMessageFlags(&list, &afFlags, NULL, NULL);
        if (FAILED(hr))
            break;
    }

    if (hRowset != NULL)
        m_pDB->CloseRowset(&hRowset);

    return(hr);
}

HRESULT COfflineSync::CreateMessage(IMessageFolder *pFolder, 
									LPMESSAGEID pidMessage, 
									SAVEMESSAGEFLAGS dwOptions, 
									MESSAGEFLAGS dwFlags,
									IStream *pStream,
									IMimeMessage *pMessage)
{
    MESSAGEID idMessage;
    HRESULT hr;
    SYNCOPINFO info;
    FOLDERID idFolder, idServer;

    Assert(pFolder != NULL);
    Assert(pMessage != NULL);
    Assert(!!(dwOptions & SAVE_MESSAGE_GENID));

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServerId(idFolder, &idServer);
    if (FAILED(hr))
        return(hr);

    ZeroMemory(&info, sizeof(SYNCOPINFO));
    hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
    if (FAILED(hr))
        return(hr);

    hr = pFolder->SaveMessage(&idMessage, SAVE_MESSAGE_GENID, dwFlags, pStream, pMessage, NULL);
    if (FAILED(hr))
        return(hr);

    info.idServer = idServer;
    info.idFolder = idFolder;
    info.idMessage = idMessage;
    info.tyOperation = SYNC_CREATE_MSG;
    info.dwFlags = dwOptions;
    // info.dwAdd
    // info.dwRemove

    hr = m_pDB->InsertRecord(&info);

    return(hr);
}

HRESULT COfflineSync::CopyMessages(IMessageFolder *pFolder, IMessageFolder *pFolderDest, COPYMESSAGEFLAGS dwCopyFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags)
{
    DWORD i;
    BOOL fMove, fImap, fCopyToMove;
    FOLDERINFO Server;
    MESSAGEFLAGS dwFlags;
    ADJUSTFLAGS afFlags;
    FOLDERID idFolder, idServer, idFolderDest;
    MESSAGEID idMessage;
    SYNCOPINFO info, infoT;
    MESSAGEIDLIST list;
    HRESULT hr;
    IMimeMessage *pMsg;
    HROWSET hRowset = NULL;
    MESSAGEINFO Message = { 0 };

    Assert(pFolder != NULL);
    Assert(pFolderDest != NULL);

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = pFolderDest->GetFolderId(&idFolderDest);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServer(idFolder, &Server);
    if (FAILED(hr))
        return(hr);

    idServer = Server.idFolder;
    fImap = (Server.tyFolder == FOLDER_IMAP);

    g_pStore->FreeRecord(&Server);

#ifdef DEBUG
    FOLDERID idServerDest;

    Assert(SUCCEEDED(GetFolderServerId(idFolderDest, &idServerDest)));
    Assert(SUCCEEDED(hr));
    Assert(idServer == idServerDest);
#endif // DEBUG

    if (NULL == pList)
    {
        hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    fMove = !!(dwCopyFlags & COPY_MESSAGE_MOVE);

    if (fMove)
    {
        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &idMessage;

        if (fImap)
        {
            afFlags.dwAdd = ARF_ENDANGERED;
            afFlags.dwRemove = 0;
        }
        else
        {
            afFlags.dwAdd = ARF_DELETED_OFFLINE;
            afFlags.dwRemove = 0;
        }
    }

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            Message.idMessage = pList->prgidMsg[i];

            hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
            if (FAILED(hr))
                break;
            else if (hr != DB_S_FOUND)
                continue;
        }
        else
        {
            hr = pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        idMessage = Message.idMessage;
        dwFlags = Message.dwFlags;

        if (pFlags != NULL)
        {
            if (pFlags->dwRemove != 0)
                Message.dwFlags &= ~pFlags->dwRemove;
            if (pFlags->dwAdd != 0)
                Message.dwFlags |= pFlags->dwAdd;
        }

        pMsg = NULL;
        hr = pFolder->OpenMessage(idMessage, NOFLAGS, &pMsg, NULL);
        if (hr == STORE_E_NOBODY)
        {
            // just create the header in the destination folder
            Assert(pMsg == NULL);

            hr = pFolderDest->GenerateId((LPDWORD)&Message.idMessage);
            if (SUCCEEDED(hr))
                hr = pFolderDest->InsertRecord(&Message);
        }
        else if (SUCCEEDED(hr))
        {
            // create the whole message in the destination folder
            Assert(pMsg != NULL);

            hr = pFolderDest->SaveMessage(&Message.idMessage, SAVE_MESSAGE_GENID, Message.dwFlags, 0, pMsg, NULL);

            pMsg->Release();
        }
        else
        {
            Assert(pMsg == NULL);
        }
        if (FAILED(hr))
            break;

        hr = _FindExistingOperation(idServer, idFolder, idMessage,
                SYNC_CREATE_MSG, SYNC_COPY_MSG | SYNC_MOVE_MSG, &info);
        if (FAILED(hr))
            break;

        if (hr == S_OK)
        {
            if (fMove)
            {
                // delete source msg because we're moving a msg which doesn't exist on the server
                // and then move the previous operation to the destination folder

                hr = pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    if (info.tyOperation == SYNC_CREATE_MSG)
                    {
                        info.idFolder = idFolderDest;
                        info.idMessage = Message.idMessage;
                    }
                    else
                    {
                        info.idFolderDest = idFolderDest;
                        info.idMessageDest = Message.idMessage;
                    }

                    hr = m_pDB->UpdateRecord(&info);

                    // foo
                }
            }
            else
            {
                if (info.tyOperation == SYNC_CREATE_MSG)
                {
                    // we can't copy this message because it doesn't exist on the server,
                    // so we'll add another create operation for the destination message

                    ZeroMemory(&infoT, sizeof(SYNCOPINFO));
                    hr = m_pDB->GenerateId((LPDWORD)&infoT.idOperation);
                    if (SUCCEEDED(hr))
                    {
                        infoT.idServer = idServer;
                        infoT.idFolder = idFolderDest;
                        infoT.idMessage = Message.idMessage;
                        infoT.tyOperation = SYNC_CREATE_MSG;
                        // infoT.dwFlags
                        // info.dwAdd
                        // info.dwRemove

                        hr = m_pDB->InsertRecord(&infoT);
                    }
                }
                else if (info.tyOperation == SYNC_COPY_MSG)
                {
                    fCopyToMove = FALSE;

                    // if there is an earlier operation that will result in the source msg
                    // being deleted, then we'll find that and remove it (delete) or change
                    // it (move), and then we'll do a move instead of a copy

                    hr = _FindExistingOperation(info.idServer, info.idFolder, info.idMessage,
                            SYNC_DELETE_MSG | SYNC_MOVE_MSG, 0, &infoT);
                    if (hr == S_OK)
                    {
                        if (infoT.tyOperation == SYNC_DELETE_MSG)
                        {
                            hr = m_pDB->DeleteRecord(&infoT);
                        }
                        else
                        {
                            Assert(infoT.tyOperation == SYNC_MOVE_MSG);

                            infoT.tyOperation = SYNC_COPY_MSG;

                            hr = m_pDB->UpdateRecord(&infoT);
                        }

                        fCopyToMove = TRUE;

                        m_pDB->FreeRecord(&infoT);
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
                        if (SUCCEEDED(hr))
                        {
                            info.idFolderDest = idFolderDest;
                            info.idMessageDest = Message.idMessage;
                            if (fCopyToMove)
                                info.tyOperation = SYNC_MOVE_MSG;

                            hr = m_pDB->InsertRecord(&info);
                        }
                    }
                }
                else
                {
                    Assert(info.tyOperation == SYNC_MOVE_MSG);

                    // instead of doing a move then a copy which wouldn't work so good,
                    // we'll have the current copy become a move and the earlier move will become a copy

                    infoT = info;
                    hr = m_pDB->GenerateId((LPDWORD)&infoT.idOperation);
                    if (SUCCEEDED(hr))
                    {
                        infoT.idFolderDest = idFolderDest;
                        infoT.idMessageDest = Message.idMessage;

                        hr = m_pDB->InsertRecord(&infoT);
                        if (SUCCEEDED(hr))
                        {
                            info.tyOperation = SYNC_COPY_MSG;

                            hr = m_pDB->UpdateRecord(&info);
                        }
                    }
                }
            }

            m_pDB->FreeRecord(&info);

            if (FAILED(hr))
            {
                break;
            }
            else
            {
                pFolder->FreeRecord(&Message);
                continue;
            }
        }

        ZeroMemory(&info, sizeof(SYNCOPINFO));
        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
        if (FAILED(hr))
            break;
        info.idServer = idServer;
        info.idFolder = idFolder;
        info.idMessage = idMessage;
        info.tyOperation = (fMove && !fImap) ? SYNC_MOVE_MSG : SYNC_COPY_MSG;
        // info.dwFlags
        if (pFlags != NULL)
        {
            info.dwAdd = (~dwFlags & pFlags->dwAdd);
            info.dwRemove = (dwFlags & pFlags->dwRemove);
        }
        info.idFolderDest = idFolderDest;
        info.idMessageDest = Message.idMessage;

        hr = m_pDB->InsertRecord(&info);
        // TODO: if this fails, we should probably blow away the new msg we just created...
        if (FAILED(hr))
            break;

        if (fMove)
        {
            if (fImap)
            {
                // put this msg in the endangered species list
                hr = _SetMessageFlags(pFolder, idServer, idFolder, idMessage, dwFlags, &afFlags);
                if (FAILED(hr))
                    break;
            }
            else
            {
                // hide this msg because it is now deleted
                pFolder->SetMessageFlags(&list, &afFlags, NULL, NULL);
            }
        }

        pFolder->FreeRecord(&Message);
    }

    pFolder->FreeRecord(&Message);

    if (hRowset != NULL)
        pFolder->CloseRowset(&hRowset);

    return(hr);
}

HRESULT COfflineSync::Initialize()
{
    HRESULT         hr;
    BOOL            fReset;
    TABLEINDEX      Index;
    CHAR            szDirectory[MAX_PATH];
    CHAR            szFilePath[MAX_PATH];
    SYNCOPUSERDATA  UserData={0};

    Assert(g_pStore != NULL);

    hr = g_pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory));
    if (FAILED(hr))
        return(hr);

    hr = MakeFilePath(szDirectory, c_szOfflineFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath));
    if (FAILED(hr))
        return(hr);

    hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_SyncOpTableSchema, NULL, &m_pDB);
    if (FAILED(hr))
        return(hr);

    fReset = FALSE;

    // Create the idServer / idFolder Index
    if (FAILED(m_pDB->GetIndexInfo(IINDEX_ALL, NULL, &Index)))
        fReset = TRUE;

    // If still noreset, see of indexes are the same
    else if (S_FALSE == CompareTableIndexes(&Index, &g_OpFolderIdIndex))
        fReset = TRUE;

    // Change the Index
    if (fReset)
    {
        // Create the idParent / FolderName Index
        hr = m_pDB->ModifyIndex(IINDEX_ALL, NULL, &g_OpFolderIdIndex);
        if (FAILED(hr))
            return(hr);
    }

    hr = m_pDB->GetUserData(&UserData, sizeof(SYNCOPUSERDATA));
    if (SUCCEEDED(hr))
    {
        if (!UserData.fInitialized)
        {
            UserData.fInitialized = TRUE;

            hr = m_pDB->SetUserData(&UserData, sizeof(SYNCOPUSERDATA));
        }
    }

    return(hr);
}

HRESULT COfflineSync::DoPlayback(HWND hwnd, FOLDERID *pId, DWORD cId, FOLDERID idFolderSel)
{
    HRESULT hr;
    DWORD cOps;
    COfflinePlayback *pPlayback;

    Assert(pId != NULL);
    Assert(cId > 0);

    hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cOps);
    if (SUCCEEDED(hr) && cOps > 0)
    {
        pPlayback = new COfflinePlayback;
        if (pPlayback == NULL)
            return(E_OUTOFMEMORY);

        hr = pPlayback->DoPlayback(hwnd, m_pDB, pId, cId, idFolderSel);

        pPlayback->Release();
    }

    return(hr);
}

HRESULT COfflineSync::_FindExistingOperation(FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage,
                                             DWORD dwFlagsSrc, DWORD dwFlagsDest, LPSYNCOPINFO pInfo)
{
    ROWORDINAL iRow;
    HRESULT hr;
    HROWSET hRowset = NULL;

    Assert(pInfo != NULL);
    Assert(dwFlagsSrc != 0 || dwFlagsDest != 0);

    ZeroMemory(pInfo, sizeof(SYNCOPINFO));
    pInfo->idServer = idServer;
    hr = m_pDB->FindRecord(IINDEX_ALL, 1, pInfo, &iRow);
    if (hr != DB_S_FOUND)
        return(S_FALSE);
    m_pDB->FreeRecord(pInfo);

    hr = m_pDB->CreateRowset(IINDEX_ALL, NOFLAGS, &hRowset);
    if (FAILED(hr))
        return(hr);

    hr = m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iRow - 1, NULL);
    if (SUCCEEDED(hr))
    {
        while (TRUE)
        {
            hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)pInfo, NULL);
            if (S_FALSE == hr)
            {
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }

            if (pInfo->idServer != idServer)
            {
                hr = S_FALSE;
                m_pDB->FreeRecord(pInfo);
                break;
            }

            if (dwFlagsSrc != 0)
            {
                if (pInfo->idFolder == idFolder && pInfo->idMessage == idMessage)
                {
                    if (!!(dwFlagsSrc & pInfo->tyOperation))
                        break;
                }
            }

            if (dwFlagsDest != 0)
            {
                if (pInfo->idFolderDest == idFolder && pInfo->idMessageDest == idMessage)
                {
                    if (!!(dwFlagsDest & pInfo->tyOperation))
                        break;
                }
            }

            m_pDB->FreeRecord(pInfo);
        }
    }

    m_pDB->CloseRowset(&hRowset);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\storutil.cpp ===
//----------------------------------------------------------------------------------
// Storutil.cpp
//----------------------------------------------------------------------------------
#include "pch.hxx"
#include "optres.h"
#include "frntpage.h"
#include "acctview.h"
#include "storfldr.h"
#include "shared.h"
#include "util.h"
#include "msgview.h"
#include "storutil.h"
#include "xpcomm.h"
#include "migerror.h"
#include "storecb.h"
#include "taskutil.h"
#include "flagconv.h"
#include "msgfldr.h"
#include "syncop.h"
#include "store.h"
#include "storsync.h"
#include "shlwapip.h" 
#include <multiusr.h>
#include "instance.h"
#include <newsdlgs.h>
#include "msgtable.h"
#include "newsstor.h"
#include "..\imap\imapsync.h"
#include "..\http\httpserv.h"
#include "demand.h"
#include "acctutil.h"

//----------------------------------------------------------------------------------
// Consts
//----------------------------------------------------------------------------------
#define FIDARRAY_START 50
#define FIDARRAY_GROW  50

//----------------------------------------------------------------------------------
// DELETEMSGS
//----------------------------------------------------------------------------------
typedef struct tagDELETEMSGS {
    LPCSTR               pszRootDir;
    CProgress           *pProgress;
    BOOL                 fReset;
} DELETEMSGS, *LPDELETEMSGS;

//----------------------------------------------------------------------------------
// REMOVEBODIES
//----------------------------------------------------------------------------------
typedef struct tagREMOVEBODIES {
    CProgress           *pProgress;
    CLEANUPFOLDERFLAGS   dwFlags;
    DWORD                cExpireDays;
} REMOVEBODIES, *LPREMOVEBODIES;

//----------------------------------------------------------------------------------
// ENUMFOLDERSIZE
//----------------------------------------------------------------------------------
typedef struct tagENUMFOLDERSIZE {
    DWORD           cbFile;
    DWORD           cbFreed;
    DWORD           cbStreams;
} ENUMFOLDERSIZE, *LPENUMFOLDERSIZE; 

//----------------------------------------------------------------------------------
// FOLDERENUMINFO
//----------------------------------------------------------------------------------
typedef struct tagFOLDERENUMINFO {
    FOLDERID   *prgFIDArray;
    DWORD       dwNumFolderIDs;
    DWORD       dwCurrentIdx;
} FOLDERENUMINFO;

//----------------------------------------------------------------------------------
// COMPACTCOOKIE
//----------------------------------------------------------------------------------
typedef struct tagCOMPACTCOOKIE {
    HWND        hwndParent;
    BOOL        fUI;
    CProgress  *pProgress;
} COMPACTCOOKIE, *LPCOMPACTCOOKIE;
  
//----------------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------------
HRESULT FixPOP3UIDLFile(IDatabase *pDB);
HRESULT HashChildren(IMessageStore *pStore, FOLDERID idParent, IHashTable *pHash,
                     LPSTR *ppszPath, DWORD dwChildOffset, DWORD *pdwAlloc);
HRESULT FlattenHierarchyHelper(IMessageStore *pStore, FOLDERID idParent,
                               BOOL fIncludeParent, BOOL fSubscribedOnly,
                               FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                               LPDWORD pdwUsed);

const static char c_szFolderFileSep[] = " - ";

// --------------------------------------------------------------------------------
// CreateMessageTable
// --------------------------------------------------------------------------------
HRESULT CreateMessageTable(FOLDERID idFolder, BOOL fThreaded, IMessageTable **ppTable)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERSORTINFO  SortInfo;
    IMessageTable  *pTable=NULL;

    // Trace
    TraceCall("CreateMessageTable");

    // Init
    *ppTable = NULL;

    // Allocate the Table
    IF_NULLEXIT(pTable = new CMessageTable);

    // Initialize the Message Table
    IF_FAILEXIT(hr = pTable->Initialize(idFolder, NULL, FALSE, NULL));

    // Get the Current Sort Info
    IF_FAILEXIT(hr = pTable->GetSortInfo(&SortInfo));

    // Set fThread
    SortInfo.fThreaded = fThreaded;

    // Sort It...
    IF_FAILEXIT(hr = pTable->SetSortInfo(&SortInfo, NULL));

    // Return It
    *ppTable = pTable;

    // Don't Release It
    pTable = NULL;

exit:
    // Cleanup
    SafeRelease(pTable);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// GetAvailableDiskSpace
// --------------------------------------------------------------------------------
HRESULT GetAvailableDiskSpace(
	/* in */        LPCSTR                      pszFilePath,
	/* out */       DWORDLONG                   *pdwlFree)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szDrive[5];
    DWORD       dwSectorsPerCluster;
    DWORD       dwBytesPerSector;
    DWORD       dwNumberOfFreeClusters;
    DWORD       dwTotalNumberOfClusters;

    // Trace
    TraceCall("GetAvailableDiskSpace");

    // Invalid Args
    Assert(pszFilePath && pszFilePath[1] == ':' && pdwlFree);

    // Split the path
    szDrive[0] = *pszFilePath;
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = '\0';
    
    // Get free disk space - if it fails, lets pray we have enought disk space
    if (!GetDiskFreeSpace(szDrive, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
	    hr = TraceResult(E_FAIL);
	    goto exit;
    }

    // Return Amount of Free Disk Space
    *pdwlFree = (dwNumberOfFreeClusters * (dwSectorsPerCluster * dwBytesPerSector));

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// GetFolderAccountName
//--------------------------------------------------------------------------
HRESULT GetFolderAccountName(LPFOLDERINFO pFolder, LPSTR pszAccountName)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];

    // Trace
    TraceCall("GetFolderAccountName");

    // Get Folder AccountId
    IF_FAILEXIT(hr = GetFolderAccountId(pFolder, szAccountId, ARRAYSIZE(szAccountId)));

    // Find the Account
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));

    // Get the Account Name
    IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, pszAccountName, CCHMAX_ACCOUNT_NAME));

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// BuildFriendlyFolderFileName
//--------------------------------------------------------------------------
HRESULT BuildFriendlyFolderFileName(LPCSTR pszDir, LPFOLDERINFO pFolder, 
    LPSTR pszFilePath, DWORD cchFilePathMax, LPCSTR pszCurrentFile,
    BOOL *pfChanged)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFileName=NULL;
    LPSTR           pszTemp=NULL;
    DWORD_PTR       i;
    CHAR            szFile[MAX_PATH];
    CHAR            szAccountName[CCHMAX_ACCOUNT_NAME];
    DWORD           cchFileName;

    // Validate
    Assert(pszDir && pFolder && pFolder->pszName && pszFilePath && cchFilePathMax >= MAX_PATH);

    // Init
    if (pfChanged)
        *pfChanged = TRUE;

    // Keep the names basic (i.e. no account prefix) for news and local folders.
    if (FOLDER_NEWS == pFolder->tyFolder || FOLDER_LOCAL == pFolder->tyFolder)
    {
        // No Account name Prefix
        *szAccountName = '\0';
    }

    // Otherwise
    else
    {
        // Get Folder Account Name
        IF_FAILEXIT(hr = GetFolderAccountName(pFolder, szAccountName));
    }

    // Build the name
    DWORD cchSize = (lstrlen(szAccountName) + lstrlen(pFolder->pszName) + lstrlen(c_szFolderFileSep) + 1);
    IF_NULLEXIT(pszFileName = PszAllocA(cchSize));

    // Format the Name
    cchFileName = wnsprintf(pszFileName, cchSize, "%s%s%s", szAccountName, *szAccountName ? c_szFolderFileSep : c_szEmpty, pFolder->pszName);

    // Cleanup the filename
    CleanupFileNameInPlaceA(CP_ACP, pszFileName);

    // Same As Current ?
    if (pszCurrentFile)
    {
        // Add a .dbx extension to pszFilename
        DWORD cchSizeTemp = (cchFileName + lstrlen(c_szDbxExt) + 1);
        IF_NULLEXIT(pszTemp = PszAllocA(cchSizeTemp));

        // Format psztemp
        wnsprintf(pszTemp, cchSizeTemp, "%s%s", pszFileName, c_szDbxExt);

        // Not Changed ?
        if (0 == lstrcmpi(pszTemp, pszCurrentFile))
        {
            // Not Changed
            if (pfChanged)
                *pfChanged = FALSE;

            // Done
            goto exit;
        }
    }

    // Build szDstFile
    hr = GenerateUniqueFileName(pszDir, pszFileName, c_szDbxExt, pszFilePath, cchFilePathMax);

    // If that failed, then try to generate a unqiue name
    if (FAILED(hr))
    {
        // Reset hr
        hr = S_OK;

        // Loop
        for (i=(DWORD_PTR)pFolder->idFolder;;i++)
        {
            // Format the File Name
            wnsprintf(szFile, ARRAYSIZE(szFile), "%08d%s", i, c_szDbxExt);

            // Make the file path
            IF_FAILEXIT(hr = MakeFilePath(pszDir, szFile, c_szEmpty, pszFilePath, cchFilePathMax));

            // If the file still exists, renumber szFile until it doesn't exist
            if (FALSE == PathFileExists(pszFilePath))
                break;
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);
    SafeMemFree(pszTemp);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// PutMessagesIntoFolder
//--------------------------------------------------------------------------
HRESULT PutMessagesIntoFolder(CProgress *pProgress, IDatabase *pStreams, 
    IMessageFolder *pFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};
    STREAMINFO      Stream={0};

    // Walk through the Folder
    IF_FAILEXIT(hr = pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Walk It
    while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Has a idStream ?
        if (Message.idStreamOld)
        {
            // Initialize Message
            Message.faStream = 0;
            Message.Offsets.cbSize = 0;
            Message.Offsets.pBlobData = NULL;
            Message.idParentOld = 0;
            Message.ThreadIdOld.pBlobData = 0;
            Message.ThreadIdOld.cbSize = 0;
            Message.pszUserNameOld = NULL;

            // Set the Streamid
            Stream.idStream = Message.idStreamOld;

            // Find the Stream
            if (DB_S_FOUND == pStreams->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Stream, NULL))
            {
                // faStream ?
                if (Stream.faStream)
                {
                    // Copy the Stream
                    IF_FAILEXIT(hr = pStreams->CopyStream(pFolder, Stream.faStream, &Message.faStream));

                    // Save the Offsets
                    Message.Offsets = Stream.Offsets;
                }

                // Free
                pStreams->FreeRecord(&Stream);
            }

            // Clear idStreamOld
            Message.idStreamOld = 0;
        }

        // Update the Record
        IF_FAILEXIT(hr = pFolder->UpdateRecord(&Message));

        // Cleanup
        pFolder->FreeRecord(&Message);

        // Update Progress
        pProgress->HrUpdate(1);
    }

exit:
    // Cleanup
    pStreams->FreeRecord(&Stream);
    pFolder->FreeRecord(&Message);
    pFolder->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// GetRidOfMessagesODSFile
//--------------------------------------------------------------------------
HRESULT GetRidOfMessagesODSFile(void)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    CHAR            szStoreRoot[MAX_PATH];
    CHAR            szMessagesFile[MAX_PATH];
    CHAR            szFile[MAX_PATH];
    CHAR            szSrcFile[MAX_PATH + MAX_PATH];
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    CHAR            szRes[255];
    IDatabase      *pStreams=NULL;
    IMessageFolder *pFolder=NULL;
    HROWSET         hRowset=NULL;
    DWORD           cRecords;
    DWORD           cTotal=0;
    DWORD           cbFile;
    DWORDLONG       dwlDiskFree;
    BOOL            fErrorDisplayed=FALSE;
    LPSTR           pszExt=NULL;
    CProgress       cProgress;

    // Trace
    TraceCall("GetRidOfMessagesODSFile");

    // Validate
    Assert(g_pDBSession);

    // Error Box
    AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsMigrateMessagesODS), 0, MB_OK | MB_ICONEXCLAMATION);

    // Get Uidcache file path
    IF_FAILEXIT(hr = GetStoreRootDirectory(szStoreRoot, sizeof(szStoreRoot)));

    // Make File Path
    IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, "messages.ods", c_szEmpty, szMessagesFile, sizeof(szMessagesFile)));

    // Allocate Table Object
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szMessagesFile, NOFLAGS, &g_StreamTableSchema, NULL, &pStreams));

    // Do a file size Check...
    IF_FAILEXIT(hr = pStreams->GetSize(&cbFile, NULL, NULL, NULL));

    // Get Available DiskSpace
    IF_FAILEXIT(hr = GetAvailableDiskSpace(szStoreRoot, &dwlDiskFree));

    // Not Enought Disk Space
    if (((DWORDLONG) cbFile) > dwlDiskFree)
    {
        // Locals
        CHAR szRes[255];
        CHAR szMsg[255];
        CHAR szSize[50];

        // cbFile is DWORD and in this case we can downgrade dwlDiskFree to DWORD
        // Format the Size Needed
        StrFormatByteSizeA(cbFile - ((DWORD) dwlDiskFree), szSize, ARRAYSIZE(szSize));

        // Load the REs
        AthLoadString(idsMigMsgsODSNoDiskSpace, szRes, ARRAYSIZE(szRes));

        // Format the Message
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, szSize, szStoreRoot);

        // Display the Message
        AthMessageBox(NULL, MAKEINTRESOURCE(idsAthena), szMsg, 0, MB_OK | MB_ICONEXCLAMATION);

        // Error Displayed
        fErrorDisplayed = TRUE;

        // Build
        hr = TraceResult(DB_E_DISKFULL);

        // Done
        goto exit;
    }

    // Enumerate through subscribed folders....
    IF_FAILEXIT(hr = g_pStore->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Loop
    while (S_OK == g_pStore->QueryRowset(hRowset, 1, (LPVOID *)&Folder, NULL))
    {
        // Open the folder
        if (Folder.pszFile && SUCCEEDED(g_pStore->OpenFolder(Folder.idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder)))
        {
            // Cleanup
            g_pStore->FreeRecord(&Folder);

            // Refetch the folderinfo because opening a folder can update the folder info...
            IF_FAILEXIT(hr = g_pStore->GetFolderInfo(Folder.idFolder, &Folder));

            // Get Extension
            pszExt = PathFindExtensionA(Folder.pszFile);

            // Get Record Count
            IF_FAILEXIT(hr = pFolder->GetRecordCount(IINDEX_PRIMARY, &cRecords));

            // Put the messages into the folder
            cTotal += cRecords;

            // If not a .dbx file yet
            if (NULL == pszExt || lstrcmpi(pszExt, c_szDbxExt) != 0)
            {
                // Build szSrcFile
                IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, Folder.pszFile, c_szEmpty, szSrcFile, sizeof(szSrcFile)));

                // Release
                SafeRelease(pFolder);

                // Build Friendly Name
                IF_FAILEXIT(hr = BuildFriendlyFolderFileName(szStoreRoot, &Folder, szDstFile, ARRAYSIZE(szDstFile), NULL, NULL));

                // Delete the Dest
                DeleteFile(szDstFile);

                // Store 
                if (0 == MoveFile(szSrcFile, szDstFile))
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }

                // Get the new pszFile...
                Folder.pszFile = PathFindFileName(szDstFile);

                // Update the Record
                IF_FAILEXIT(hr = g_pStore->UpdateRecord(&Folder));
            }

            // Release
            SafeRelease(pFolder);
        }

        // Otherwise, if there is a file name, lets reset it
        else if (Folder.pszFile)
        {
            // Cleanup
            g_pStore->FreeRecord(&Folder);

            // Refetch the folderinfo because opening a folder can update the folder info...
            IF_FAILEXIT(hr = g_pStore->GetFolderInfo(Folder.idFolder, &Folder));

            // Get the new pszFile...
            Folder.pszFile = NULL;

            // Update the Record
            IF_FAILEXIT(hr = g_pStore->UpdateRecord(&Folder));
        }

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Get the Title
    AthLoadString(idsMigDBXTitle, szRes, ARRAYSIZE(szRes));

    // Create a Progress Meter...
    cProgress.Init(NULL, szRes, NULL, cTotal, idanCompact, FALSE);

    // Show the Progress
    cProgress.Show();

    // Seek the rowset
    IF_FAILEXIT(hr = g_pStore->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, 0, NULL));

    // Loop
    while (S_OK == g_pStore->QueryRowset(hRowset, 1, (LPVOID *)&Folder, NULL))
    {
        // Open the folder
        if (Folder.pszFile && SUCCEEDED(g_pStore->OpenFolder(Folder.idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder)))
        {
            // Set the Message
            cProgress.SetMsg(Folder.pszName);

            // Put the messages into the folder
            IF_FAILEXIT(hr = PutMessagesIntoFolder(&cProgress, pStreams, pFolder));

            // Release
            SafeRelease(pFolder);
        }

        // Better not have a file
        else
            Assert(NULL == Folder.pszFile);

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Release the Streams File so that I can delete it
    SafeRelease(pStreams);

    // Delete messages.ods
    DeleteFile(szMessagesFile);

exit:
    // Cleanup
    SafeRelease(pStreams);
    SafeRelease(pFolder);
    g_pStore->CloseRowset(&hRowset);
    g_pStore->FreeRecord(&Folder);

    // Show an Error
    if (FAILED(hr) && FALSE == fErrorDisplayed)
    {
        // Show an Error
        AthErrorMessageW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsMigMsgsODSError), hr);
    }

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderIdFromMsgTable
//----------------------------------------------------------------------------------
HRESULT GetFolderIdFromMsgTable(IMessageTable *pTable, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    IMessageFolder     *pFolder=NULL;
    IServiceProvider   *pService=NULL;

    // Trace
    TraceCall("GetFolderIdFromMsgTable");

    // Invalid Args
    Assert(pTable && pidFolder);

    // Get IServiceProvider
    IF_FAILEXIT(hr = pTable->QueryInterface(IID_IServiceProvider, (LPVOID *)&pService));

    // Get IID_IMessageFolder
    IF_FAILEXIT(hr = pService->QueryService(IID_IMessageFolder, IID_IMessageFolder, (LPVOID *)&pFolder));

    // Get the Folder id
    IF_FAILEXIT(hr = pFolder->GetFolderId(pidFolder));

exit:
    // Cleanup
    SafeRelease(pFolder);
    SafeRelease(pService);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// EmptyMessageFolder
//----------------------------------------------------------------------------------
HRESULT EmptyMessageFolder(LPFOLDERINFO pFolder, BOOL fReset, CProgress *pProgress)
{
    // Locals
    HRESULT         hr=S_OK;
    CMessageFolder *pObject=NULL;

    // Trace
    TraceCall("EmptyMessageFolder");

    // Invalid Args
    Assert(pFolder);

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        goto exit;

    // Root
    if (FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // No File
    if (NULL == pFolder->pszFile)
        goto exit;

    // New CMessageFolder
    IF_NULLEXIT(pObject = new CMessageFolder);

    // Open the folder
    if (FAILED(pObject->Initialize(g_pStore, NULL, OPEN_FOLDER_NOCREATE, pFolder->idFolder)))
        goto exit;
    
    // If this is a news folder ?
    if (fReset)
    {
        // Update pFolder
        pFolder->dwClientHigh = pFolder->dwClientLow = 0;
        pFolder->dwNotDownloaded = 0;
        pFolder->Requested.cbSize = 0;
        pFolder->Requested.pBlobData = NULL;

        // Update the Folder
        IF_FAILEXIT(hr = g_pStore->UpdateRecord(pFolder));
    }

    // Delete All Record
    IF_FAILEXIT(hr = pObject->DeleteMessages(DELETE_MESSAGE_NOPROMPT | DELETE_MESSAGE_NOTRASHCAN, NULL, NULL, (IStoreCallback *)pProgress));

exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// DeleteAllRecords
//----------------------------------------------------------------------------------
HRESULT DeleteAllRecords(LPCTABLESCHEMA pSchema, IDatabase *pDB,
    CProgress *pProgress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPVOID          pBinding=NULL;
    HROWSET         hRowset=NULL;
    HLOCK           hNotifyLock=NULL;

    // Trace
    TraceCall("DeleteAllRecords");

    // Lock Down Notifications
    pDB->LockNotify(NOFLAGS, &hNotifyLock);
    
    // Allocate a record
    IF_NULLEXIT(pBinding = ZeroAllocate(pSchema->cbBinding));

    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // While we have a node address
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)pBinding, NULL))
    {
        // Delete this record
        IF_FAILEXIT(hr = pDB->DeleteRecord(pBinding));

        // Free Record Data
        pDB->FreeRecord(pBinding);

        // Do Progress
        if (pProgress)
        {
            // Do Some Progress
            IF_FAILEXIT(hr = pProgress->HrUpdate(1));
        }
    }

exit:
    // Cleanup
    if (pBinding)
    {
        pDB->FreeRecord(pBinding);
        g_pMalloc->Free(pBinding);
    }

    // Close Rowset
    pDB->CloseRowset(&hRowset);

    // Lock Down Notifications
    pDB->UnlockNotify(&hNotifyLock);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// GetFolderServerId
// --------------------------------------------------------------------------------
HRESULT GetFolderServerId(FOLDERID idFolder, LPFOLDERID pidServer)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Server={0};

    // Trace
    TraceCall("GetFolderServerId");

    // Get the Server Info
    IF_FAILEXIT(hr = GetFolderServer(idFolder, &Server));

    // Return Server
    *pidServer = Server.idFolder;

exit:
    // Cleanup
    g_pStore->FreeRecord(&Server);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderServer
//----------------------------------------------------------------------------------
HRESULT GetFolderServer(FOLDERID idFolder, LPFOLDERINFO pServer)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetFolderServer");

    // Walk the Parent Chain
    while (1)
    {
        // Get Folder Info
        hr = g_pStore->GetFolderInfo(idFolder, pServer);
        if (FAILED(hr))
            goto exit;

        // Is this a server ?
        if (ISFLAGSET(pServer->dwFlags, FOLDER_SERVER))
            goto exit;

        // Set Next
        idFolder = pServer->idParent;

        // Free
        g_pStore->FreeRecord(pServer);
    }

exit:
    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderType
//----------------------------------------------------------------------------------
FOLDERTYPE GetFolderType(FOLDERID idFolder)
{
    // Locals
    FOLDERINFO Folder;

    // Trace
    TraceCall("GetFolderType");

    // Get Folder Info
    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
    {
        // Get the Type
        FOLDERTYPE tyFolder = Folder.tyFolder;

        // Cleanup
        g_pStore->FreeRecord(&Folder);

        // Done
        return(tyFolder);
    }

    // Done
    return(FOLDER_ROOTNODE);
}

//----------------------------------------------------------------------------------
// FHasChildren
//----------------------------------------------------------------------------------
BOOL FHasChildren(LPFOLDERINFO pFolder, BOOL fSubscribed)
{
    // Locals
    HRESULT             hr=S_OK;
    BOOL                fHasChildren=FALSE;
    FOLDERINFO          Folder;
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("FHasChildren");

    // Create Enumerator
    IF_FAILEXIT(hr = g_pStore->EnumChildren(pFolder->idFolder, fSubscribed, &pChildren));

    // Get first row
    if (S_OK == pChildren->Next(1, &Folder, NULL))
    {
        // Has Children
        fHasChildren = TRUE;

        // Free Record
        g_pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    SafeRelease(pChildren);

    // Done
    return(fHasChildren);
}

//----------------------------------------------------------------------------------
// GetFolderAccountId
//----------------------------------------------------------------------------------
HRESULT GetFolderAccountId(LPFOLDERINFO pFolder, LPSTR pszAccountId, DWORD cchSize)
{
    Assert(g_pStore);
    if (!g_pStore)
        return E_UNEXPECTED;

    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Server={0};

    // Trace
    TraceCall("GetFolderAccountId");

    // Args
    Assert(pFolder && pszAccountId);

    // If this is a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
    {
        // Validate
        Assert(!FIsEmptyA(pFolder->pszAccountId));

        // Copy It
        StrCpyN(pszAccountId, pFolder->pszAccountId, cchSize);

        // Done
        goto exit;
    }

    // Validate
    Assert(FIsEmptyA(pFolder->pszAccountId));

    // Get Server Info
    IF_FAILEXIT(hr = GetFolderServer(pFolder->idFolder, &Server));

    // Copy Account Id
    if (FIsEmptyA(Server.pszAccountId))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Copy It
    StrCpyN(pszAccountId, Server.pszAccountId, cchSize);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Server);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// CreateMessageServerType
//----------------------------------------------------------------------------------
HRESULT CreateMessageServerType(FOLDERTYPE tyFolder, IMessageServer **ppServer)
{
    // Locals
    HRESULT     hr=S_OK;
    IUnknown   *pUnknown=NULL;

    // Trace
    TraceCall("CreateMessageServerType");

    // Handle Folder
    switch(tyFolder)
    {
    case FOLDER_NEWS:
        IF_FAILEXIT(hr = CreateNewsStore(NULL, &pUnknown));
        break;

    case FOLDER_IMAP:
        IF_FAILEXIT(hr = CreateImapStore(NULL, &pUnknown));
        break;

    case FOLDER_HTTPMAIL:
        IF_FAILEXIT(hr = CreateHTTPMailStore(NULL, &pUnknown));
        break;

    default:
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // QI Unknown
    IF_FAILEXIT(hr = pUnknown->QueryInterface(IID_IMessageServer, (LPVOID *)ppServer));

exit:
    // Cleanup
    SafeRelease(pUnknown);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetDefaultServerId
//----------------------------------------------------------------------------------
HRESULT GetDefaultServerId(ACCTTYPE tyAccount, LPFOLDERID pidServer)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    FOLDERID        idServer;
    DWORD           dwServers;
    CHAR            szAcctId[CCHMAX_ACCOUNT_NAME];

    // Trace
    TraceCall("GetDefaultServerId");

    // Invalid Args
    Assert(pidServer);

    // Get the Default Account
    IF_FAILEXIT(hr = g_pAcctMan->GetDefaultAccount(tyAccount, &pAccount));

    // Get Server Types
    IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));

    // If POP3, special case to the local store
    if (ISFLAGSET(dwServers, SRV_POP3))
    {
        // Set Id
        *pidServer = FOLDERID_LOCAL_STORE;

        // Done
        goto exit;
    }

    // Get the Account Id
    IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAcctId, ARRAYSIZE(szAcctId)));

    // Get the Server Id
    IF_FAILEXIT(hr = g_pStore->FindServerId(szAcctId, pidServer));

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// IsSubFolder
//----------------------------------------------------------------------------------
HRESULT IsSubFolder(FOLDERID idFolder, FOLDERID idParent)
{
    // Locals
    HRESULT     hr = S_OK;
    FOLDERINFO  Folder={0};
    FOLDERID    idCurrent = idFolder;

    // Trace
    TraceCall("IsSubFolder");

    // Invalid Args
    Assert(idFolder != FOLDERID_INVALID);
    Assert(idParent != FOLDERID_INVALID);

    // Walk up the parent chain
    while (SUCCEEDED(hr = g_pStore->GetFolderInfo(idCurrent, &Folder)))
    {
        // Done ?
        if (Folder.idParent == idParent)
        {
            // Cleanup
            g_pStore->FreeRecord(&Folder);

            // Done
            break;
        }

        // Goto Parent
        idCurrent = Folder.idParent;

        // Cleanup
        g_pStore->FreeRecord(&Folder);

#ifdef _WIN64
		INT_PTR p = (INT_PTR) idCurrent;
		INT_PTR n = (INT_PTR) FOLDERID_INVALID;
		if ((((int) p) & 0xffffffff) == (((int) n) & 0xffffffff))
#else
        if (idCurrent == FOLDERID_INVALID)
#endif // _WIN64
        {
            hr = S_FALSE;
            break;
        }
    }

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetMessageInfo
//----------------------------------------------------------------------------------
HRESULT GetMessageInfo(IDatabase *pDB, MESSAGEID idMessage,
    LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("GetMessageInfo");

    // Set pInfo
    pInfo->idMessage = idMessage;

    // Return
    IF_FAILEXIT(hr = pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pInfo, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

    // Found
    hr = S_OK;

exit:
    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderIdFromName
//----------------------------------------------------------------------------------
HRESULT GetFolderIdFromName(IMessageStore *pStore, LPCSTR pszName, FOLDERID idParent, 
    LPFOLDERID pidFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("GetFolderIdFromName");

    // Invalid Args
    if (NULL == pszName)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *pidFolder = FOLDERID_INVALID;

    // Fill Folder
    Folder.idParent = idParent;
    Folder.pszName = (LPSTR)pszName;

    // Do a Find Record
    IF_FAILEXIT(hr = pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

    // Return
    *pidFolder = Folder.idFolder;

exit:
    // Cleanup
    pStore->FreeRecord(&Folder);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// GetFolderStoreInfo
//----------------------------------------------------------------------------------
HRESULT GetFolderStoreInfo(FOLDERID idFolder, LPFOLDERINFO pStore)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERID    idCurrent=idFolder;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("GetFolderStoreInfo");

    // Walk the Parent Chain
    while (1)
    {
        // Get Current Folder Info
        IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idCurrent, &Folder));

        // No Parent
        if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        {
            // Copy to pStore
            CopyMemory(pStore, &Folder, sizeof(FOLDERINFO));

            // Don't Free It
            ZeroMemory(&Folder, sizeof(FOLDERINFO));

            // Done
            goto exit;
        }

        // Goto Parent
        idCurrent = Folder.idParent;
    
        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// GetFolderIcon
//----------------------------------------------------------------------------------
int GetFolderIcon(FOLDERID idFolder, BOOL fNoStateIcons)
{
    // Locals
    HRESULT     hr=S_OK;
    int         iIcon=iFolderClosed;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("GetFolderIcon");

    // Get Info
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

    // Get the Icon
    iIcon = GetFolderIcon(&Folder);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return iIcon;
}

//----------------------------------------------------------------------------------
// GetFolderIcon
//----------------------------------------------------------------------------------
int GetFolderIcon(LPFOLDERINFO pFolder, BOOL fNoStateIcons)
{
    // Locals
    int iIcon=iFolderClosed;

    // Trace
    TraceCall("GetFolderIcon");

    // Invalid Args
    if (NULL == pFolder)
        return TraceResult(E_INVALIDARG);

    if (FOLDER_ROOTNODE == pFolder->tyFolder)
    {
        if (g_dwAthenaMode & MODE_NEWSONLY)
        {
            iIcon = iNewsRoot;
        }
        else
        {
            iIcon = iMailNews;

        }
    }

    // News
    else if (FOLDER_NEWS == pFolder->tyFolder)
    {
        // New Server ?
        if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        {
            // Subscribed Server
            if (ISFLAGSET(pFolder->dwFlags, FOLDER_SUBSCRIBED))
                iIcon = iNewsServer;

            // Otherwise, non-subscribed new server
            else
                iIcon = iUnsubServer;
        }

        // Synchronize...
        else if (!fNoStateIcons && !!(pFolder->dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)))
            iIcon = iNewsGroupSync;

        // Subscribed ?
        else if (ISFLAGSET(pFolder->dwFlags, FOLDER_SUBSCRIBED))
            iIcon = iNewsGroup;

        // Otherwise, not subscribed
        else
            iIcon = iUnsubGroup;
    }

    // Local Store, IMAP and HTTP servers
    else
    {
        // Local Folders
        if (FOLDERID_LOCAL_STORE == pFolder->idFolder)
            iIcon = iLocalFolders;

        // Mail Server
        else if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        {
            // msn branded server
            if (ISFLAGSET(pFolder->dwFlags, FOLDER_MSNSERVER))
                iIcon = iMsnServer;

            // otherwise, generic mail server
            else
                iIcon = iMailServer;
        }

        // Not Special
        else if (FOLDER_NOTSPECIAL == pFolder->tySpecial)
        {
            if (!fNoStateIcons && !!(pFolder->dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)))
                iIcon = iFolderDownload;
            else
                iIcon = iFolderClosed;
        }

        // Otherwise, base off of special folder type
        // but we don't have a special icon for Bulk mail folder
        else if (!fNoStateIcons && !!(pFolder->dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)))
            iIcon = (iInboxDownload + (((pFolder->tySpecial == FOLDER_BULKMAIL) ? FOLDER_JUNK : pFolder->tySpecial) - 1));
        else
            iIcon = (iInbox + (((pFolder->tySpecial == FOLDER_BULKMAIL) ? FOLDER_JUNK : pFolder->tySpecial) - 1));
    }

    // Done
    return iIcon;
}


//----------------------------------------------------------------------------------
// GetStoreRootDirectory
//----------------------------------------------------------------------------------
HRESULT GetStoreRootDirectory(LPSTR pszDir, DWORD cchMaxDir)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cb, cch;
    DWORD       dwType;

    // Trace
    TraceCall("GetStoreRootDirectory");

    // Get the Root Directory
    cb = (cchMaxDir * sizeof(pszDir[0]));
    if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szRegStoreRootDir, &dwType, (LPBYTE)pszDir, &cb))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Expand the string's enviroment vars
    if (dwType == REG_EXPAND_SZ)
    {
        // Locals
        CHAR szExpanded[MAX_PATH];

        // Expand enviroment strings
        cch = ExpandEnvironmentStrings(pszDir, szExpanded, ARRAYSIZE(szExpanded));

        // Failure
        if (cch == 0 || cch > ARRAYSIZE(szExpanded))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Copy into szRoot
        StrCpyN(pszDir, szExpanded, cchMaxDir);
    }

    // Get the length
    cch = lstrlen(pszDir);

    // No root
    if (0 == cch)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Fixup the end
    PathRemoveBackslash(pszDir);

    // If the directory doesn't exist yet ?
    if (FALSE == PathIsDirectory(pszDir))
    {
        // Our default directory doesn't exist, so create it
        IF_FAILEXIT(hr = OpenDirectory(pszDir));
    }

exit:
    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// CreateFolderViewObject
//----------------------------------------------------------------------------------
HRESULT CreateFolderViewObject(FOLDERID idFolder, HWND hwndOwner, 
    REFIID riid, LPVOID * ppvOut)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CreateFolderViewObject");

    // Get Folder Info
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

    // Root Object
    if (FOLDERID_ROOT == idFolder)
    {
        CFrontPage *pFP = new CFrontPage();
        if (pFP)
        {
            if (SUCCEEDED(pFP->HrInit(idFolder)))
            {
                hr = pFP->QueryInterface(riid, ppvOut);
            }
            pFP->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
    {
        CAccountView *pAV = new CAccountView();

        if (pAV)
        {
            if (SUCCEEDED(pAV->HrInit(idFolder)))
            {
                hr = pAV->QueryInterface(riid, ppvOut);
            }
            pAV->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        CMessageView *pMV = new CMessageView();
        if (pMV)
        {
            if (SUCCEEDED(pMV->Initialize(idFolder)))
            {
                hr = pMV->QueryInterface(riid, ppvOut);
            }
            pMV->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// OpenUidlCache
//----------------------------------------------------------------------------------
HRESULT OpenUidlCache(IDatabase **ppDB)
{
    // Locals
    HRESULT       hr=S_OK;
    CHAR          szStoreRoot[MAX_PATH];
    CHAR          szFilePath[MAX_PATH];
    IDatabase    *pDB=NULL;

    // Trace
    TraceCall("OpenUidlCache");

    // Get Uidcache file path
    IF_FAILEXIT(hr = GetStoreRootDirectory(szStoreRoot, sizeof(szStoreRoot)));

    // Make File Path
    IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, c_szPop3UidlFile, c_szEmpty, szFilePath, sizeof(szFilePath)));

    // Allocate Table Object
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_UidlTableSchema, NULL, &pDB));

    // Fix the file 
    SideAssert(SUCCEEDED(FixPOP3UIDLFile(pDB)));

    // Return It
    *ppDB = pDB;
    pDB = NULL;

exit:
    // Cleanup
    SafeRelease(pDB);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// FixPOP3UIDLFile
//----------------------------------------------------------------------------------
const char c_szFixedPOP3UidlFile[] = "FixedPOP3UidlFile";

typedef struct tagSERVERNAME {
    CHAR        szServer[CCHMAX_SERVER_NAME];
    CHAR        szAccountId[CCHMAX_ACCOUNT_NAME];
} SERVERNAME, *LPSERVERNAME;

HRESULT FixPOP3UIDLFile(IDatabase *pDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               fFixed=FALSE;
    DWORD               cb;
    DWORD               dwType;
    IImnAccount        *pAccount=NULL;
    IImnEnumAccounts   *pEnum=NULL;
    DWORD               dwTemp;
    DWORD               cServers;
    LPSERVERNAME        prgServerName=NULL;
    HROWSET             hRowset=NULL;
    UIDLRECORD          UidlInfo={0};
    DWORD               i;

    // Trace
    TraceCall("FixPOP3UIDLFile");

    // Need to fixup the UIDL cache ?
    cb = sizeof(fFixed);
    if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szFixedPOP3UidlFile, &dwType, (LPBYTE)&fFixed, &cb))
        fFixed = FALSE;
    else if (fFixed)
        return(S_OK);

    // First try to see if we can find such a server.
    IF_FAILEXIT(hr = g_pAcctMan->Enumerate(SRV_POP3, &pEnum));

    // Count
    IF_FAILEXIT(hr = pEnum->GetCount(&cServers));

    // If no POP3 servers
    if (0 == cServers)
    {
        // Delete all the records...
        IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

        // Loop
        while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
        {
            // Delete the Record
            pDB->DeleteRecord(&UidlInfo);

            // Free It
            pDB->FreeRecord(&UidlInfo);
        }

        // Fixed
        fFixed = TRUE;

        // Done
        goto exit;
    }

    // Allocate
    IF_NULLEXIT(prgServerName = (LPSERVERNAME)g_pMalloc->Alloc(cServers * sizeof(SERVERNAME)));

    // Reset cServers
    cServers = 0;

    // Enumerate the POP3 servers
    while (SUCCEEDED(pEnum->GetNext(&pAccount)))
    {
        // Get the server name
        if (SUCCEEDED(pAccount->GetPropSz(AP_POP3_SERVER, prgServerName[cServers].szServer, ARRAYSIZE(prgServerName[cServers].szServer))))
        {
            // Get the pop3 username
            if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, prgServerName[cServers].szAccountId, ARRAYSIZE(prgServerName[cServers].szAccountId))))
            {
                // Increment
                cServers++;
            }
        }

        // Release the Account
        SafeRelease(pAccount);
    }

    // Delete all the records...
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
    {
        // Does UidlInfo.pszServer exist in prgServerName
        if (UidlInfo.pszServer)
        {
            // Delete the Record
            pDB->DeleteRecord(&UidlInfo);

            // Reset fExist
            for (i=0; i<cServers; i++)
            {
                // Is this it
                if (lstrcmpi(UidlInfo.pszServer, prgServerName[i].szServer) == 0)
                {
                    // Update the Record
                    UidlInfo.pszAccountId = prgServerName[i].szAccountId;

                    // Update the Record
                    pDB->InsertRecord(&UidlInfo);
                }
            }
        }

        // Free It
        pDB->FreeRecord(&UidlInfo);
    }

    // Compact
    pDB->Compact(NULL, 0);

    // Fixed
    fFixed = TRUE;

exit:
    // Cleanup
    if (pDB && hRowset)
        pDB->CloseRowset(&hRowset);
    SafeRelease(pAccount);
    SafeRelease(pEnum);
    SafeMemFree(prgServerName);

    // Set the Value
    SideAssert(ERROR_SUCCESS == AthUserSetValue(NULL, c_szFixedPOP3UidlFile, REG_DWORD, (LPBYTE)&fFixed, sizeof(fFixed)));

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// SetStoreDirectory
//----------------------------------------------------------------------------------
HRESULT SetStoreDirectory(
        /* in */        LPCSTR                      pszRoot)
{                                                   
    // Locals
    HRESULT         hr=S_OK;
    LPCSTR          psz;
    CHAR            szProfile[MAX_PATH];
    DWORD           cb;
    DWORD           type;

    // Trace
    TraceCall("SetStoreDirectory");

    // Invalid Args
    Assert(pszRoot);

    // Bad Root
    if (lstrlen(pszRoot) >= MAX_PATH || FIsEmptyA(pszRoot))
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    type = AddEnvInPath(pszRoot, szProfile, ARRAYSIZE(szProfile)) ? REG_EXPAND_SZ : REG_SZ;

    // Store the Value in the Registry
    if (ERROR_SUCCESS != AthUserSetValue(NULL, c_szRegStoreRootDir, type, (LPBYTE)szProfile, lstrlen(szProfile) + 1))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// InitializeLocalStoreDirectory
//----------------------------------------------------------------------------------
HRESULT InitializeLocalStoreDirectory(
        /* in */        HWND                    hwndOwner, 
        /* in */        BOOL                    fNoCreate)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szPath[MAX_PATH];

    // Trace
    TraceCall("InitializeLocalStoreDirectory");

    // Get root directory
    if (SUCCEEDED(GetStoreRootDirectory(szPath, ARRAYSIZE(szPath))))
        goto exit;

    // Don't create
    if (fNoCreate)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Get Default Root
    IF_FAILEXIT(hr = GetDefaultStoreRoot(hwndOwner, szPath, ARRAYSIZE(szPath)));

    // If the directory doesn't exist yet ?
    if (FALSE == PathIsDirectory(szPath))
    {
        // Our default directory doesn't exist, so create it
        IF_FAILEXIT(hr = OpenDirectory(szPath));
    }

    // Set the Store Directory
    IF_FAILEXIT(hr = SetStoreDirectory(szPath));

exit:
    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// CloneMessageIDList
//----------------------------------------------------------------------------------
HRESULT CloneMessageIDList(LPMESSAGEIDLIST pSourceList, LPMESSAGEIDLIST *ppNewList)
{
    LPMESSAGEIDLIST pNewList = NULL;
    LPMESSAGEID     pNewMsgIDArray = NULL;
    BOOL            fResult;

    TraceCall("CloneMessageIDList");
    Assert(NULL != ppNewList);

    if (NULL == pSourceList)
    {
        *ppNewList = NULL;
        return S_OK;
    }

    // Init return values
    *ppNewList = NULL;

    if (!MemAlloc((LPVOID *)&pNewList, sizeof(MESSAGEIDLIST) + pSourceList->cMsgs * sizeof(MESSAGEID)))
        return TraceResult(E_OUTOFMEMORY);

    // Fill in fields, allocate and copy prgidMsg array
    pNewList->cAllocated = 0;
    pNewList->cMsgs = pSourceList->cMsgs;
    pNewMsgIDArray = (LPMESSAGEID)((LPBYTE)pNewList + sizeof(MESSAGEIDLIST));
    CopyMemory(pNewMsgIDArray, pSourceList->prgidMsg, pSourceList->cMsgs * sizeof(MESSAGEID));
    pNewList->prgidMsg = pNewMsgIDArray;
    *ppNewList = pNewList;
    return S_OK;
}



HRESULT CloneAdjustFlags(LPADJUSTFLAGS pFlags, LPADJUSTFLAGS *ppNewFlags)
{
    LPADJUSTFLAGS pNewFlags;

    if (!MemAlloc((LPVOID *)&pNewFlags, sizeof(ADJUSTFLAGS)))
        return TraceResult(E_OUTOFMEMORY);

    CopyMemory(pNewFlags, pFlags, sizeof(ADJUSTFLAGS));
    *ppNewFlags = pNewFlags;
    return S_OK;
}


//----------------------------------------------------------------------------------
// ConnStateIsEqual
//----------------------------------------------------------------------------------
BOOL ConnStateIsEqual(IXPSTATUS ixpStatus, CONNECT_STATE csState)
{
    BOOL    fResult = FALSE;

    TraceCall("ConnStateIsEqual");

    switch (csState)
    {
        case CONNECT_STATE_CONNECT:
            // Remember IXP_CONNECTED doesn't necessarily mean we're authenticated
            if (IXP_AUTHORIZED == ixpStatus)
                fResult = TRUE;

            break;

        case CONNECT_STATE_DISCONNECT:
            if (IXP_DISCONNECTED == ixpStatus)
                fResult = TRUE;

            break;

        default:
            AssertSz(FALSE, "I've never heard of this CONNECT_STATE!");
            break;
    } // switch

    return fResult;
}

//----------------------------------------------------------------------------------
// RelocateStoreDirectory
//----------------------------------------------------------------------------------
// Extensions associated with OE v5 Store
const static TCHAR *rgszWildCards[] = 
{
    "*.dbx",
    "*.dbl",
    "*.log",
};

// Lengths of the above strings
const static int rgcchWilds[] = 
{
    5,
    5,
    5,
};

// Build a string of the form:
// C:\\foo\\*.bar\0C:\\foo\\*.car\0\0

// Return E_FAIL if we run out of memory
// Return S_FALSE if there are no *.bar or *.car files in C:\foo
// Return S_OK otherwise
HRESULT GenerateWildCards(LPTSTR pszBuf, DWORD cchBuf, LPTSTR pszSource, DWORD cchSource)
{
    UINT    i;
    DWORD   cchWildCard = 0;
    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;
    HANDLE  hFound;
    TCHAR   szTempBuf[MAX_PATH];
    BOOL    fFound;
    DWORD   cchOrig;

    // Form common root
    if(lstrlen(pszSource) >= sizeof(szTempBuf) / sizeof(szTempBuf[0])) return E_FAIL;
    StrCpyN(szTempBuf,pszSource, ARRAYSIZE(szTempBuf));
    if (_T('\\') == *CharPrev(szTempBuf, szTempBuf + cchSource))
        // Avoid \\foo and \_foo
        cchSource--;
    else
        szTempBuf[cchSource] = _T('\\');
        
    // Go through list of extensions we are interested in
    for (i = 0; i < ARRAYSIZE(rgszWildCards); i++)
    {
        // Add the extension to the common root
        StrCpyN(&szTempBuf[cchSource+1], rgszWildCards[i],ARRAYSIZE(szTempBuf)-cchSource-1);
        
        // Should we bother with this wildcard?
        fFound = FALSE;
        hFound = FindFirstFile(szTempBuf, &fd);
        if (INVALID_HANDLE_VALUE != hFound)
        {
            do
            {
                if (!ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
                    fFound = TRUE;

            }
            while (!fFound && FindNextFile(hFound, &fd));

            FindClose(hFound);

            if (fFound)
            {
                // Do we have enough space for this wildcard?

                // 3 = 1 for slash + 2 for double null termination 
                if (cchWildCard + cchSource + rgcchWilds[i] + 3 > cchBuf)
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }

                hr = S_OK;

                // Add extension to the list
                StrCpyN(&pszBuf[cchWildCard], szTempBuf, cchBuf-cchWildCard);
                
                // 2 = 1 for slash + 1 to skip over NULL
                cchWildCard += cchSource + rgcchWilds[i] + 2;
            }
        }
    }
        
    // Double Null-term
    pszBuf[cchWildCard] = '\0';

exit:
    return hr;
}

HRESULT RelocateStoreDirectory(HWND hwnd, LPCSTR pszDstDir, BOOL fMove)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrT;
    DWORD           cchDstDir;
    DWORD           cchSrcDir;
    CHAR            szWildCard[MAX_PATH * ARRAYSIZE(rgszWildCards)];
    CHAR            szSrcDir[MAX_PATH];
    CHAR            szDstDir[MAX_PATH];
    CHAR            szDrive[4] = "x:\\";
    CHAR            szRes[255];
    SHFILEOPSTRUCT  op;
    BOOL            fSome;

    Assert(pszDstDir && *pszDstDir);
    
    // Trace
    TraceCall("RelocateStoreDirectory");

    // Get the Current Root Store Location (won't have trailing slash)
    IF_FAILEXIT(hr = GetStoreRootDirectory(szWildCard, ARRAYSIZE(szWildCard)));

    // Make a copy of pszDstDir, stripping out any relative path padding
    PathCanonicalize(szDstDir, pszDstDir);    

    // Make sure the destination directory exists (it came from the reg...)
    IF_FAILEXIT(hr=OpenDirectory(szDstDir));

    // Strip out any relative path padding
    PathCanonicalize(szSrcDir, szWildCard);

    // Get Dest Dir Length
    cchDstDir = lstrlen(szDstDir);
    
    // Remove any slash termination
    if (_T('\\') == *CharPrev(szDstDir, szDstDir+cchDstDir))
        szDstDir[--cchDstDir] = 0;

    // BUGBUG: This isn't a very thorough test...
    // Source and Destination are the Same ?
    if (lstrcmpi(szSrcDir, szDstDir) == 0)
    {
        hr = TraceResult(S_FALSE);
        goto exit;
    }

    // Get Source Dir Length
    cchSrcDir = lstrlen(szSrcDir);

    // Normally, GetStoreRootDir should have have removed the backslash
    // But maybe we move to C:\
    //Assert(*CharPrev(szSrcDir, szSrcDir+cchSrcDir) != _T('\\'));

    // Set Drive Number
    szDrive[0] = szDstDir[0];

    // If destination is not a fixed drive, failure
    if (DRIVE_FIXED != GetDriveType(szDrive))
    {
        hr = TraceResult(S_FALSE);
        goto exit;
    }

    if (fMove)
    {
        // Enough space for one more character
        if (cchSrcDir + 2 >= ARRAYSIZE(szSrcDir))
        {
            hr = TraceResult(S_FALSE);
            goto exit;
        }

        // Double Null-term
        szSrcDir[cchSrcDir + 1] = _T('\0');

        // Validate
        Assert(szSrcDir[cchSrcDir] == _T('\0') && szSrcDir[cchSrcDir + 1] == _T('\0'));

        // Enough space for one more character
        if (cchDstDir + 1 >= ARRAYSIZE(szDstDir))
        {
            // This is never going to work so tell caller not to bother us again
            hr = TraceResult(S_FALSE);
            goto exit;
        }

        // Double Null-term
        szDstDir[cchDstDir + 1] = '\0';

        // Validate
        Assert(szDstDir[cchDstDir] == '\0' && szDstDir[cchDstDir + 1] == '\0');
        hrT = GenerateWildCards(szWildCard, ARRAYSIZE(szWildCard), szDstDir, cchDstDir);

        if (FAILED(hrT))
        {
            hr = TraceResult(S_FALSE);
            goto exit;
        }
        else if (S_OK == hrT)
        {
            // Delete the Files from the target location
            ZeroMemory(&op, sizeof(SHFILEOPSTRUCT));
            op.hwnd = hwnd;
            op.wFunc = FO_DELETE;
            op.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_FILESONLY | FOF_NORECURSION;
            op.pFrom = szWildCard;
            op.fAnyOperationsAborted = FALSE;

            // Delete the files 
            if (SHFileOperation(&op) != 0)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
        }

        // Make the file source paths
        hrT = GenerateWildCards(szWildCard, ARRAYSIZE(szWildCard), szSrcDir, cchSrcDir);

        if (FAILED(hrT))
        {
            hr = TraceResult(S_FALSE);
            goto exit;
        }
        else if (S_OK == hrT)
        {
            // Load the Progress String
            LoadString(g_hLocRes, idsMoveStoreProgress, szRes, ARRAYSIZE(szRes));

            // Setup for the file move operation
            ZeroMemory(&op, sizeof(SHFILEOPSTRUCT));
            op.hwnd = hwnd;
            op.wFunc = FO_COPY;
            op.fFlags = FOF_NOCONFIRMMKDIR | FOF_SIMPLEPROGRESS | FOF_FILESONLY | FOF_NORECURSION;
            op.lpszProgressTitle = szRes;
            op.fAnyOperationsAborted = FALSE;
            op.pFrom = szWildCard;
            op.pTo = szDstDir;

            // Did that succeed and was not aborted
            if (SHFileOperation(&op) == 0 && FALSE == op.fAnyOperationsAborted)
            {
                // Update the Store Root Directory
                // Use original string        
                SideAssert(SUCCEEDED(SetStoreDirectory(pszDstDir)));
            }

            // Canceled
            else
            {
                // Failure ?
                hr = (op.fAnyOperationsAborted ? S_FALSE : E_FAIL);

                // Delete what we moved
                hrT = GenerateWildCards(szWildCard, ARRAYSIZE(szWildCard), szDstDir, cchDstDir);
            }

            if (S_OK == hrT)
            {
                // Delete the Files from the original location
                op.wFunc = FO_DELETE;
                op.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_FILESONLY | FOF_NORECURSION;

                // Delete the files
                SHFileOperation(&op);
            }
        }
        else
            AssertSz(FALSE, "We're moving the store, but found no store to move!");
    }
    else
        SideAssert(SUCCEEDED(SetStoreDirectory(pszDstDir)));

    
exit:
    // Done
    return(hr);
}


//----------------------------------------------------------------------------------
// FlattenHierarchy
//----------------------------------------------------------------------------------
// Not the most efficient way to flatten a hierarchy, but it's quick impl
// Later enhancements can include implementing a stack to flatten hierarchy
// in real-time using enumerator functions
HRESULT FlattenHierarchy(IMessageStore *pStore, FOLDERID idParent,
                        BOOL fIncludeParent, BOOL fSubscribedOnly,
                        FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                        LPDWORD pdwUsed)
{
    TraceCall("FlattenHierarchy");
    Assert(NULL != pStore);
    Assert(NULL != pprgFIDArray);
    Assert(NULL != pdwAllocated);
    Assert(NULL != pdwUsed);

    // Initialize values
    *pprgFIDArray = NULL;
    *pdwAllocated = 0;
    *pdwUsed = 0;

    return FlattenHierarchyHelper(pStore, idParent, fIncludeParent, fSubscribedOnly,
        pprgFIDArray, pdwAllocated, pdwUsed);
} // FlattenHierarchy


HRESULT FlattenHierarchyHelper(IMessageStore *pStore, FOLDERID idParent,
                               BOOL fIncludeParent, BOOL fSubscribedOnly,
                               FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                               LPDWORD pdwUsed)
{
    HRESULT             hrResult = S_OK;
    IEnumerateFolders  *pEnumFldr = NULL;

    TraceCall("FlattenHierarchy");
    Assert(NULL != pStore);
    Assert(NULL != pprgFIDArray);
    Assert(NULL != pdwAllocated);
    Assert(NULL != pdwUsed);
    Assert(*pdwAllocated >= *pdwUsed);
    Assert(*pdwUsed + FIDARRAY_GROW >= *pdwAllocated);

    // Check for invalid folder ID's
    if (FOLDERID_INVALID == idParent)
    {
        hrResult = S_OK;
        goto exit; // Nothing to do here!
    }

    // Check if we need to grow the FolderID Array
    if (*pdwUsed + 1 > *pdwAllocated)
    {
        BOOL    fResult;

        fResult = MemRealloc((void **)pprgFIDArray,
            (*pdwAllocated + FIDARRAY_GROW) * sizeof(FOLDERID));
        if (FALSE == fResult)
        {
            hrResult = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        *pdwAllocated += FIDARRAY_GROW;
    }

    // First thing we do is add current node to the ID array
    if (fIncludeParent)
    {
        (*pprgFIDArray)[*pdwUsed] = idParent;
        *pdwUsed += 1;
    }

    // OK, now add child folders
    hrResult = pStore->EnumChildren(idParent, fSubscribedOnly, &pEnumFldr);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    do
    {
        const BOOL  fINCLUDE_PARENT = TRUE;
        FOLDERINFO  fiFolderInfo;

        // Get info on next child folder
        hrResult = pEnumFldr->Next(1, &fiFolderInfo, NULL);
        if (S_OK != hrResult)
        {
            TraceError(hrResult);
            break;
        }

        // Recurse on child
        hrResult = FlattenHierarchyHelper(pStore, fiFolderInfo.idFolder, fINCLUDE_PARENT,
            fSubscribedOnly, pprgFIDArray, pdwAllocated, pdwUsed);
        pStore->FreeRecord(&fiFolderInfo);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            break;
        }
    } while (1);


exit:
    if (NULL != pEnumFldr)
        pEnumFldr->Release();

    return hrResult;
} // FlattenHierarchyHelper

HRESULT GetInboxId(IMessageStore    *pStore, 
                        FOLDERID    idParent,
                        FOLDERID    **pprgFIDArray,
                        LPDWORD     pdwUsed)
{
    BOOL                fResult;
    HRESULT             hrResult;
    IEnumerateFolders  *pEnumFldr = NULL;

    Assert(NULL != pStore);
    Assert(NULL != pprgFIDArray);
    Assert(NULL != pdwUsed);

    fResult = MemAlloc((void **)pprgFIDArray, sizeof(FOLDERID));
    if (FALSE == fResult)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    hrResult = pStore->EnumChildren(idParent, FALSE, &pEnumFldr);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    do
    {
        FOLDERINFO  fiFolderInfo;

        // Get info on next child folder
        hrResult = pEnumFldr->Next(1, &fiFolderInfo, NULL);
        if (S_OK != hrResult)
        {
            TraceError(hrResult);
            break;
        }

        if (fiFolderInfo.tySpecial == FOLDER_INBOX)
        {
            (*pprgFIDArray)[*pdwUsed] = fiFolderInfo.idFolder;
            *pdwUsed += 1;
            break;
        }
        pStore->FreeRecord(&fiFolderInfo);
    } while (1);

exit:
    if (NULL != pEnumFldr)
        pEnumFldr->Release();

    return hrResult;

}

//----------------------------------------------------------------------------------
// RecurseFolderHierarchy
//----------------------------------------------------------------------------------
HRESULT RecurseFolderHierarchy(FOLDERID idFolder, RECURSEFLAGS dwFlags,
    DWORD dwReserved, DWORD_PTR dwCookie, PFNRECURSECALLBACK pfnCallback)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    DWORD               cIndent=dwReserved;
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("RecurseFolderHierarchy");

    // Include idFolder ?
    if (ISFLAGSET(dwFlags, RECURSE_INCLUDECURRENT))
    {
        // Process idFolder
        IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

        // No Local Store
        if (!ISFLAGSET(dwFlags, RECURSE_NOLOCALSTORE) || FOLDERID_LOCAL_STORE != Folder.idFolder)
        {
            // Call the Callback
            IF_FAILEXIT(hr = (*(pfnCallback))(&Folder, ISFLAGSET(dwFlags, RECURSE_SUBFOLDERS), cIndent, dwCookie));
        }

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Don't include current anymore
    FLAGCLEAR(dwFlags, RECURSE_INCLUDECURRENT);

    // Do Sub Folders ?
    if (ISFLAGSET(dwFlags, RECURSE_SUBFOLDERS))
    {
        // No Local Store
        if (!ISFLAGSET(dwFlags, RECURSE_NOLOCALSTORE) || FOLDERID_LOCAL_STORE != idFolder)
        {
            // Create Enumerator for the Children
            IF_FAILEXIT(hr = g_pStore->EnumChildren(idFolder, ISFLAGSET(dwFlags, RECURSE_ONLYSUBSCRIBED), &pChildren));

            // Loop
            while (S_OK == pChildren->Next(1, &Folder, NULL))
            {
                // No Local Store
                if (((!ISFLAGSET(dwFlags, RECURSE_NOLOCALSTORE) || FOLDERID_LOCAL_STORE != Folder.idFolder)) &&
                            ((!ISFLAGSET(dwFlags, RECURSE_ONLYLOCAL) || FOLDER_LOCAL == Folder.tyFolder)) &&
                            ((!ISFLAGSET(dwFlags, RECURSE_ONLYNEWS) || FOLDER_NEWS == Folder.tyFolder)))
                {
                    // Call the Callback
                    IF_FAILEXIT(hr = (*(pfnCallback))(&Folder, ISFLAGSET(dwFlags, RECURSE_SUBFOLDERS), cIndent, dwCookie));

                    // Enumerate Children
                    IF_FAILEXIT(hr = RecurseFolderHierarchy(Folder.idFolder, dwFlags, cIndent + 1, dwCookie, pfnCallback));
                }

                // Free Folder
                g_pStore->FreeRecord(&Folder);
            }
        }
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pChildren);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// RecurseFolderCounts
//----------------------------------------------------------------------------------
HRESULT RecurseFolderCounts(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    LPDWORD pcMsgs=(LPDWORD)dwCookie;

    // Trace
    TraceCall("RecurseFolderCounts");

    // If not a server
    if (FALSE == ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) && FOLDERID_ROOT != pFolder->idFolder)
    {
        // Increment Max
        (*pcMsgs) += pFolder->cMessages;
    }

    // Done
    return(S_OK);
}

//----------------------------------------------------------------------------------
// DoCompactionError
//----------------------------------------------------------------------------------
HRESULT DoCompactionError(HWND hwndParent, LPCSTR pszFolder, LPCSTR pszFile,
    BOOL fSubFolders, HRESULT hrError)
{
    // Determine Message Box Flags
    UINT    uAnswer;
    UINT    uFlags = (fSubFolders ? MB_OKCANCEL | MB_ICONSTOP : MB_OK | MB_ICONSTOP);
    CHAR    szRes[255];
    CHAR    szReason[255];
    CHAR    szMsg[1024];

    // Trace
    TraceCall("DoCompactionError");

    // Should be a failure
    Assert(FAILED(hrError));

    // Cancel
    if (hrUserCancel == hrError)
        return(hrUserCancel);

    // General message
    AthLoadString(idsFailACacheCompact, szRes, ARRAYSIZE(szRes));

    // Disk Full
    if (hrError == hrDiskFull || hrError == DB_E_DISKFULL)
    {
        // Load the Disk Full Error
        AthLoadString(idsDiskFull, szReason, ARRAYSIZE(szRes));

        // Append It to the String
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, pszFolder, szReason, pszFile, hrError);

        // Show It
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Access Denied
    else if (hrError == DB_E_ACCESSDENIED)
    {
        // Load the Disk Full Error
        AthLoadString(idsDBAccessDenied, szReason, ARRAYSIZE(szRes));

        // Append It to the String
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, pszFolder, szReason, pszFile, hrError);

        // Show It
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Memory
    else if (hrError == hrMemory || hrError == E_OUTOFMEMORY)
    {
        // Load the Error
        AthLoadString(idsMemory, szReason, ARRAYSIZE(szReason));

        // Append It to the String
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, pszFolder, szReason, pszFile, hrError);

        // Show the Error
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Show general error
    else
    {
        // Load the String
        AthLoadString(idsFailACacheCompactReason, szRes, ARRAYSIZE(szRes));

        // Append It to the String
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, pszFolder, szReason, pszFile, hrError);

        // Show the Error
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Return hrError
    return(uAnswer == IDCANCEL ? hrUserCancel : S_OK);
}

//----------------------------------------------------------------------------------
// RecurseCompactFolders
//----------------------------------------------------------------------------------
HRESULT RecurseCompactFolders(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    IMessageFolder *pFolderObject=NULL;
    LPCOMPACTCOOKIE pCompact=(LPCOMPACTCOOKIE)dwCookie;

    // Trace
    TraceCall("RecurseCompactFolders");

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        goto exit;
    
    // Root
    if (FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Open the Folder...
    if (FAILED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
        goto exit;
    
    // Set Msg
    pCompact->pProgress->SetMsg(pFolder->pszName);

    // Cleanup this folder
    hr = pFolderObject->Compact((IDatabaseProgress *)pCompact->pProgress, 0);

    // Failure
    if (FAILED(hr))
    {
        // Do UI
        if (pCompact->fUI && hrUserCancel == DoCompactionError(pCompact->hwndParent, pFolder->pszName, pFolder->pszFile, fSubFolders, hr))
            goto exit;
    }

    // Reset hr
    hr = S_OK;

exit:
    // Cleanup
    SafeRelease(pFolderObject);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CompactSpecialDatabase
// --------------------------------------------------------------------------------
HRESULT CompactSpecialDatabase(LPCOMPACTCOOKIE pCompact, LPCSTR pszFile, 
    IDatabase *pDB, UINT idName)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[255];

    // Trace
    TraceCall("CompactSpecialDatabase");

    // No Database
    if (NULL == pDB)
        goto exit;

    // Load the String
    LoadString(g_hLocRes, idName, szRes, ARRAYSIZE(szRes));

    // Set Msg
    pCompact->pProgress->SetMsg(szRes);

    // Cleanup this folder
    hr = pDB->Compact((IDatabaseProgress *)pCompact->pProgress, 0);

    // Failure
    if (FAILED(hr))
    {
        // Do UI
        if (pCompact->fUI && hrUserCancel == DoCompactionError(pCompact->hwndParent, szRes, pszFile, TRUE, hr))
            goto exit;
    }

    // Reset hr
    hr = S_OK;

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CompactFolders
// --------------------------------------------------------------------------------
HRESULT CompactFolders(HWND hwndParent, RECURSEFLAGS dwRecurse, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cTotal=0;
    DWORD           cRecords;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    CHAR            szRootDir[MAX_PATH + MAX_PATH];
    CHAR            szTitle[255];
    COMPACTCOOKIE   Compact;
    IDatabase      *pUidlCache=NULL;
    IDatabase      *pOffline=NULL;
    CProgress      *pProgress=NULL;

    // Trace
    TraceCall("CompactFolders");

    // Get the Root Store Directory
    IF_FAILEXIT(hr = GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir)));

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&cTotal, (PFNRECURSECALLBACK)RecurseFolderCounts));

    // Compacting All
    if (FOLDERID_ROOT == idFolder && ISFLAGSET(dwRecurse, RECURSE_SUBFOLDERS))
    {
        // Get Folders Record Count
        IF_FAILEXIT(hr = g_pStore->GetRecordCount(IINDEX_PRIMARY, &cRecords));

        // Increment cTotal
        cTotal += cRecords;

        // Make File Path
        IF_FAILEXIT(hr = MakeFilePath(szRootDir, c_szPop3UidlFile, c_szEmpty, szFilePath, sizeof(szFilePath)));

        // If file exists
        if (PathFileExists(szFilePath))
        {
            // Allocate Table Object
            IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_UidlTableSchema, NULL, &pUidlCache));

            // Get Record Count
            IF_FAILEXIT(hr = pUidlCache->GetRecordCount(IINDEX_PRIMARY, &cRecords));

            // Increment cTotal
            cTotal += cRecords;
        }

        // Open Offline Transaction Log
        IF_FAILEXIT(hr = MakeFilePath(szRootDir, c_szOfflineFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // If the file exists
        if (PathFileExists(szFilePath))
        {
            // Create pOffline
            IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_SyncOpTableSchema, NULL, &pOffline));

            // Get Record Count
            IF_FAILEXIT(hr = pOffline->GetRecordCount(IINDEX_PRIMARY, &cRecords));

            // Increment cTotal
            cTotal += cRecords;
        }
    }

    // Create progress meter
    IF_NULLEXIT(pProgress = new CProgress);

    // Dialog title
    AthLoadString(idsCompacting, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // Init progress meter
    pProgress->Init(hwndParent, szTitle, (LPSTR)NULL, cTotal, idanCompact, TRUE, FALSE);

    // Show progress
    pProgress->Show(0);

    // Setup Compact Cookie
    Compact.hwndParent = hwndParent;
    Compact.pProgress = pProgress;
    Compact.fUI = (ISFLAGSET(dwRecurse, RECURSE_NOUI) == TRUE) ? FALSE : TRUE;

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&Compact, (PFNRECURSECALLBACK)RecurseCompactFolders));

    // Compacting All
    if (FOLDERID_ROOT == idFolder && ISFLAGSET(dwRecurse, RECURSE_SUBFOLDERS))
    {
        // Compact Special Databae
        IF_FAILEXIT(hr = CompactSpecialDatabase(&Compact, c_szPop3UidlFile, pUidlCache, idsPop3UidlFile));

        // Compact Special Databae
        IF_FAILEXIT(hr = CompactSpecialDatabase(&Compact, c_szOfflineFile, pOffline, idsOfflineFile));

        // Compact Special Databae
        IF_FAILEXIT(hr = CompactSpecialDatabase(&Compact, c_szFoldersFile, g_pStore, idsFoldersFile));
    }

exit:
    // Cleanup
    SafeRelease(pProgress);
    SafeRelease(pUidlCache);
    SafeRelease(pOffline);

    // Done
    return (hrUserCancel == hr) ? S_OK : hr;
}

// --------------------------------------------------------------------------------
// RecurseRemoveMessageBodies
// --------------------------------------------------------------------------------
HRESULT RecurseRemoveMessageBodies(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Message={0};
    BOOL            fRemoveBody;
    HROWSET         hRowset=NULL;
    IMessageFolder *pFolderObject=NULL;
    IDatabase      *pDB=NULL;
    FILETIME        ftCurrent;
    LPREMOVEBODIES  pRemove=(LPREMOVEBODIES)dwCookie;

    // Trace
    TraceCall("RecurseRemoveMessageBodies");

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        goto exit;

    // Root
    if (FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Open the folder...
    if (FAILED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
        goto exit;

    // Get the database
    IF_FAILEXIT(hr = pFolderObject->GetDatabase(&pDB));

    // Set Msg
    pRemove->pProgress->SetMsg(pFolder->pszName);

    // Adjust cExpireDays
    if (pRemove->cExpireDays <= 0)
        pRemove->cExpireDays = 5;

    // Get Current Time
    GetSystemTimeAsFileTime(&ftCurrent);

    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Only if this message has a body
        if (!ISFLAGSET(Message.dwFlags, ARF_KEEPBODY) && !ISFLAGSET(Message.dwFlags, ARF_WATCH) && 0 != Message.faStream)
        {
            // Reset Bits
            fRemoveBody = FALSE;

            // Otherwise, remove body ?
            if (ISFLAGSET(pRemove->dwFlags, CLEANUP_REMOVE_ALL))
            {
                // Remove the Body
                fRemoveBody = TRUE;
            }

            // Otherwise
            else
            {
                // Removing Read and this message is read ?
                if (ISFLAGSET(pRemove->dwFlags, CLEANUP_REMOVE_READ) && ISFLAGSET(Message.dwFlags, ARF_READ))
                {
                    // Remove the Body
                    fRemoveBody = TRUE;
                }

                // Otherwise, if expiring...
                if (FALSE == fRemoveBody && ISFLAGSET(pRemove->dwFlags, CLEANUP_REMOVE_EXPIRED))
                {
                    // If difference
                    if ((UlDateDiff(&Message.ftDownloaded, &ftCurrent) / SECONDS_INA_DAY) >= pRemove->cExpireDays)
                    {
                        // Remove the Body
                        fRemoveBody = TRUE;
                    }
                }
            }

            // Otherwise, fRemoveBody ?
            if (fRemoveBody)
            {
                // Save the Address
                FILEADDRESS faDelete = Message.faStream;

                // Zero out the record's strema
                Message.faStream = 0;

                // Fixup the Record
                FLAGCLEAR(Message.dwFlags, ARF_HASBODY);
                FLAGCLEAR(Message.dwFlags, ARF_ARTICLE_EXPIRED);

                // Clear downloaded time
                ZeroMemory(&Message.ftDownloaded, sizeof(FILETIME));

                // Update the Record
                IF_FAILEXIT(hr = pDB->UpdateRecord(&Message));

                // Delete the Stream
                SideAssert(SUCCEEDED(pDB->DeleteStream(faDelete)));
            }
        }

        // Free Current
        pDB->FreeRecord(&Message);

        // Update the Progress
        if (pRemove->pProgress && hrUserCancel == pRemove->pProgress->HrUpdate(1))
            break;
    }

exit:
    // Cleanup
    if (pDB)
    {
        pDB->FreeRecord(&Message);
        pDB->CloseRowset(&hRowset);
        pDB->Release();
    }
    SafeRelease(pFolderObject);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// RemoveMessageBodies
// --------------------------------------------------------------------------------
HRESULT RemoveMessageBodies(HWND hwndParent, RECURSEFLAGS dwRecurse, 
    FOLDERID idFolder, CLEANUPFOLDERFLAGS dwFlags, DWORD cExpireDays)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cTotal=0;
    CHAR            szTitle[255];
    REMOVEBODIES    RemoveBodies;
    CProgress      *pProgress=NULL;

    // Trace
    TraceCall("CompactFolders");

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&cTotal, (PFNRECURSECALLBACK)RecurseFolderCounts));

    // Create progress meter
    IF_NULLEXIT(pProgress = new CProgress);

    // Dialog title
    AthLoadString(idsCleaningUp, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // Init progress meter
    pProgress->Init(hwndParent, szTitle, (LPSTR)NULL, cTotal, idanCompact, TRUE, FALSE);

    // Show progress
    pProgress->Show(0);

    // Setup Compact Cookie
    RemoveBodies.pProgress = pProgress;
    RemoveBodies.dwFlags = dwFlags;
    RemoveBodies.cExpireDays = cExpireDays;

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&RemoveBodies, (PFNRECURSECALLBACK)RecurseRemoveMessageBodies));

exit:
    // Cleanup
    SafeRelease(pProgress);

    // Done
    return (hrUserCancel == hr) ? S_OK : hr;
}

// --------------------------------------------------------------------------------
// RecurseDeleteMessages
// --------------------------------------------------------------------------------
HRESULT RecurseDeleteMessages(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    LPDELETEMSGS    pDelete=(LPDELETEMSGS)dwCookie;

    // Trace
    TraceCall("RecurseDeleteMessages");

    // Set Msg
    pDelete->pProgress->SetMsg(pFolder->pszName);

    // If not a server
    IF_FAILEXIT(hr = EmptyMessageFolder(pFolder, pDelete->fReset, pDelete->pProgress));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupDeleteMessages
// --------------------------------------------------------------------------------
HRESULT CleanupDeleteMessages(HWND hwndParent, RECURSEFLAGS dwRecurse, 
    FOLDERID idFolder, BOOL fReset)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cTotal=0;
    CHAR            szTitle[255];
    DELETEMSGS      DeleteMsgs;
    CProgress      *pProgress=NULL;

    // Trace
    TraceCall("CompactFolders");

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&cTotal, (PFNRECURSECALLBACK)RecurseFolderCounts));

    // Create progress meter
    IF_NULLEXIT(pProgress = new CProgress);

    // Dialog title
    AthLoadString(idsCleaningUp, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // Init progress meter
    pProgress->Init(hwndParent, szTitle, (LPSTR)NULL, cTotal, idanCompact, TRUE, FALSE);

    // Show progress
    pProgress->Show(0);

    // Setup Compact Cookie
    DeleteMsgs.pProgress = pProgress;
    DeleteMsgs.fReset = fReset;

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&DeleteMsgs, (PFNRECURSECALLBACK)RecurseDeleteMessages));

exit:
    // Cleanup
    SafeRelease(pProgress);

    // Done
    return (hrUserCancel == hr) ? S_OK : hr;
}

// --------------------------------------------------------------------------------
// CleanupFolder
// --------------------------------------------------------------------------------
HRESULT CleanupFolder(HWND hwndParent, RECURSEFLAGS dwRecurse, FOLDERID idFolder, 
    CLEANUPFOLDERTYPE tyCleanup)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CleanupFolder");

    // Handle Cleanup Type
    if (CLEANUP_COMPACT == tyCleanup)
    {
        // Compact
        IF_FAILEXIT(hr = CompactFolders(hwndParent, dwRecurse, idFolder));
    }

    // Delete ?
    else if (CLEANUP_DELETE == tyCleanup)
    {
        // Delete all the headers
        IF_FAILEXIT(hr = CleanupDeleteMessages(hwndParent, dwRecurse, idFolder, FALSE));
    }

    // Reset
    else if (CLEANUP_RESET == tyCleanup)
    {
        // Delete all the headers
        IF_FAILEXIT(hr = CleanupDeleteMessages(hwndParent, dwRecurse, idFolder, TRUE));
    }

    // Remove Message Bodies
    else if (CLEANUP_REMOVEBODIES == tyCleanup)
    {
        // RemoveMessageBodies
        IF_FAILEXIT(hr = RemoveMessageBodies(hwndParent, dwRecurse, idFolder, CLEANUP_REMOVE_ALL | CLEANUP_PROGRESS, 0));
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// InitFolderPickerEdit
// --------------------------------------------------------------------------------
HRESULT InitFolderPickerEdit(HWND hwndEdit, FOLDERID idSelected)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};
    TCHAR       sz[CCHMAX_STRINGRES];
    LPTSTR      psz;

    // Trace
    TraceCall("InitFolderPickerEdit");

    // Fix Selected ?
    if (FAILED(g_pStore->GetFolderInfo(idSelected, &Folder)))
    {
        // Try to get the Root
        IF_FAILEXIT(hr = g_pStore->GetFolderInfo(FOLDERID_ROOT, &Folder));
    }

    // SetWndThisPtr
    SetWndThisPtr(hwndEdit, Folder.idFolder);

    if ((g_dwAthenaMode & MODE_OUTLOOKNEWS) && (idSelected == 0))
    {
        LoadString(g_hLocRes, idsOutlookNewsReader, sz, ARRAYSIZE(sz));
        psz = sz;
    }
    else
    {
        psz = Folder.pszName;
    }

    // Set the Text
    SetWindowText(hwndEdit, psz);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// GetFolderIdFromEdit
// --------------------------------------------------------------------------------
FOLDERID GetFolderIdFromEdit(HWND hwndEdit)
{
    // Trace
    TraceCall("GetFolderIdFromEdit");

    // GetWndThisPtr
    return(FOLDERID)(GetWndThisPtr(hwndEdit));
}

// --------------------------------------------------------------------------------
// PickFolderInEdit
// --------------------------------------------------------------------------------
HRESULT PickFolderInEdit(HWND hwndParent, HWND hwndEdit, FOLDERDIALOGFLAGS dwFlags, 
    LPCSTR pszTitle, LPCSTR pszText, LPFOLDERID pidSelected)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("PickFolderInEdit");

    // Invalid Args
    Assert(hwndParent && hwndEdit && pidSelected);

    // Select Folder
    IF_FAILEXIT(hr = SelectFolderDialog(hwndParent, SFD_SELECTFOLDER, GetFolderIdFromEdit(hwndEdit), dwFlags | FD_FORCEINITSELFOLDER, pszTitle, pszText, pidSelected));

    // Fix Selected ?
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(*pidSelected, &Folder));

    // SetWndThisPtr
    SetWndThisPtr(hwndEdit, Folder.idFolder);

    // Set the Text
    SetWindowText(hwndEdit, Folder.pszName);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// LighweightOpenMessage
// --------------------------------------------------------------------------------
HRESULT LighweightOpenMessage(IDatabase *pDB, LPMESSAGEINFO pHeader,
    IMimeMessage **ppMessage)
{
    // Locals
    HRESULT             hr=S_OK;
    IStream            *pStream=NULL;
    IMimeMessage       *pMessage;

    // Invalid Args
    Assert(pDB && pHeader && ppMessage);

    // No Stream
    if (0 == pHeader->faStream)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Need to create a message ?
    if (NULL == *ppMessage)
    {
        // Create a Message
        IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMessage));

        // Set pMessage
        (*ppMessage) = pMessage;
    }

    // Otherwise, InitNew
    else
    {
        // Set pMesage
        pMessage = (*ppMessage);

        // InitNew
        pMessage->InitNew();
    }

    // Open the Stream from the Store
    IF_FAILEXIT(hr = pDB->OpenStream(ACCESS_READ, pHeader->faStream, &pStream));

    // If there is an offset table
    if (pHeader->Offsets.cbSize > 0)
    {
        // Create a ByteStream Object
        CByteStream cByteStm(pHeader->Offsets.pBlobData, pHeader->Offsets.cbSize);

        // Load the Offset Table Into the message
        pMessage->LoadOffsetTable(&cByteStm);

        // Take the bytes back out of the bytestream object (so that it doesn't try to free it)
        cByteStm.AcquireBytes(&pHeader->Offsets.cbSize, &pHeader->Offsets.pBlobData, ACQ_DISPLACE);
    }

    // Load the pMessage
    IF_FAILEXIT(hr = pMessage->Load(pStream));

exit:
    // Cleanup
    SafeRelease(pStream);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// RecurseFolderSizeInfo
// --------------------------------------------------------------------------------
HRESULT RecurseFolderSizeInfo(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cbFile;
    DWORD               cbFreed;
    DWORD               cbStreams;
    IMessageFolder     *pObject=NULL;
    LPENUMFOLDERSIZE    pEnumSize=(LPENUMFOLDERSIZE)dwCookie;

    // Trace
    TraceCall("RecurseFolderSizeInfo");

    // If not hidden
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_HIDDEN) || FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Open the Folder Database
    if (SUCCEEDED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pObject)))
    {
        // Get Size Information
        IF_FAILEXIT(hr = pObject->GetSize(&cbFile, NULL, &cbFreed, &cbStreams));

        // Increment
        pEnumSize->cbFile += cbFile;
        pEnumSize->cbFreed += cbFreed;
        pEnumSize->cbStreams += cbStreams;
    }

exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// DisplayFolderSizeInfo
// --------------------------------------------------------------------------------
HRESULT DisplayFolderSizeInfo(HWND hwnd, RECURSEFLAGS dwRecurse, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szSize[255];
    CHAR            szRes[255];
    CHAR            szMsg[255];
    ENUMFOLDERSIZE  EnumSize={0};

    // Trace
    TraceCall("DisplayFolderSizeInfo");

    // Recurse and Get File Size Information...
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&EnumSize, (PFNRECURSECALLBACK)RecurseFolderSizeInfo));

    // Total Size
    StrFormatByteSizeA(EnumSize.cbFile, szSize, ARRAYSIZE(szSize));

    // Display the Text
    SetWindowText(GetDlgItem(hwnd, idcTotalSize), szSize);

    // Size of the Streams
    StrFormatByteSizeA(EnumSize.cbStreams, szSize, ARRAYSIZE(szSize));

    // Wasted Space
    StrFormatByteSizeA(EnumSize.cbFreed, szSize, ARRAYSIZE(szSize));

    // Wasted Space
    AthLoadString(idsWastedKB, szRes, ARRAYSIZE(szRes));

    // Format the String
    wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, szSize, (EnumSize.cbFile != 0) ? ((EnumSize.cbFreed * 100) / EnumSize.cbFile) : 0);

    // Show the Text
    SetWindowText(GetDlgItem(hwnd, idcWastedSpace), szMsg);

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MigrateLocalStore
// --------------------------------------------------------------------------------
HRESULT MigrateLocalStore(HWND hwndParent, LPTSTR pszSrc, LPTSTR pszDest)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dw, cb;
    CHAR                szFilePath[MAX_PATH];
    CHAR                szExpanded[MAX_PATH];
    CHAR                szCommand[MAX_PATH+20];
    LPSTR               psz=(LPSTR)c_szMigrationExe;
    PROCESS_INFORMATION pi;
    STARTUPINFO         sti;
    HKEY                hkey;

    // Try to find the path to oemig50.exe
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szFilePath);    
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szInstallRoot, 0, &dw, (LPBYTE)szFilePath, &cb))
        {
            if (REG_EXPAND_SZ == dw)
            {
                ExpandEnvironmentStrings(szFilePath, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }
            else
                psz = szFilePath;

            // Append backslash
            PathAddBackslash(psz); 

            // Add in oemig50.exe
            StrCatBuff(psz, c_szMigrationExe, MAX_PATH);
        }
        RegCloseKey(hkey);
    }

    // Form the command
    wnsprintf(szCommand, ARRAYSIZE(szCommand), "%s /type:V1+V4-V5 /src:%s /dst:%s", psz, pszSrc, pszDest);

    // Zero startup info
    ZeroMemory(&sti, sizeof(sti));
    sti.cb = sizeof(STARTUPINFO);

    // run oemig50.exe
    if (CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi))
    {
        // Wait for the process to finish
        WaitForSingleObject(pi.hProcess, INFINITE);

        // Get the Exit Process Code
        if (0 == GetExitCodeProcess(pi.hProcess, &dw))
        {
            // General Failure
            dw = TraceResult(E_FAIL);
        }

        // Close the Thread
        CloseHandle(pi.hThread);

        // Close the Process
        CloseHandle(pi.hProcess);

        // Failure ?
        if (MIGRATE_E_NOCONTINUE == (HRESULT)dw)
        {
            // Abort this process
            ExitProcess(dw);

            // Set hr
            hr = TraceResult(E_FAIL);
        }

        // Success
        else
            hr = S_OK;
    }

    // Failure
    else
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

HRESULT CopyMoveMessages(HWND hwnd, FOLDERID src, FOLDERID dst, LPMESSAGEIDLIST pList, COPYMESSAGEFLAGS dwFlags)
{
    HRESULT hr;
    IMessageFolder *pFolderSrc, *pFolderDst;

    Assert(pList != NULL);
    Assert(hwnd != NULL);

    hr = g_pStore->OpenFolder(src, NULL, 0, &pFolderSrc);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->OpenFolder(dst, NULL, 0, &pFolderDst);
        if (SUCCEEDED(hr))
        {
            hr = CopyMessagesProgress(hwnd, pFolderSrc, pFolderDst, dwFlags, pList, NULL);

            pFolderDst->Release();
        }

        pFolderSrc->Release();
    }

    return(hr);
}

// --------------------------------------------------------------------------------
// CallbackOnLogonPrompt
// --------------------------------------------------------------------------------
HRESULT CallbackOnLogonPrompt(HWND hwndParent, LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    DWORD           apidUserName;
    DWORD           apidPassword;
    DWORD           apidPromptPwd;

    // Trace
    TraceCall("CallbackOnLogonPrompt");

    // Invalid Args
    Assert(g_pAcctMan && hwndParent && IsWindow(hwndParent) && pServer);

    switch (ixpServerType)
    {
        case IXP_POP3:
            apidUserName = AP_POP3_USERNAME;
            apidPassword = AP_POP3_PASSWORD;
            apidPromptPwd = AP_POP3_PROMPT_PASSWORD;
            break;

        case IXP_SMTP:
            apidUserName = AP_SMTP_USERNAME;
            apidPassword = AP_SMTP_PASSWORD;
            apidPromptPwd = AP_SMTP_PROMPT_PASSWORD;
            break;

        case IXP_NNTP:
            apidUserName = AP_NNTP_USERNAME;
            apidPassword = AP_NNTP_PASSWORD;
            apidPromptPwd = AP_NNTP_PROMPT_PASSWORD;
            break;

        case IXP_IMAP:
            apidUserName = AP_IMAP_USERNAME;
            apidPassword = AP_IMAP_PASSWORD;
            apidPromptPwd = AP_IMAP_PROMPT_PASSWORD;
            break;

        case IXP_HTTPMail:
            apidUserName = AP_HTTPMAIL_USERNAME;
            apidPassword = AP_HTTPMAIL_PASSWORD;
            apidPromptPwd = AP_HTTPMAIL_PROMPT_PASSWORD;
            break;

        default:
            AssertSz(FALSE, "Not a valid server type");
            hr = TraceResult(E_FAIL);
            goto exit;
    }

    // Find the Account for pServer
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pServer->szAccount, &pAccount));

    // Call Task Util
    IF_FAILEXIT(hr = TaskUtil_OnLogonPrompt(pAccount, NULL, hwndParent, pServer, apidUserName, apidPassword, apidPromptPwd, TRUE));

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CallbackOnPrompt
// --------------------------------------------------------------------------------
HRESULT CallbackOnPrompt(HWND hwndParent, HRESULT hrError, LPCTSTR pszText, 
    LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Trace
    TraceCall("CallbackOnPrompt");

    // Invalid Arg
    Assert(pszText && pszCaption && piUserResponse);

    // Do the message box
    *piUserResponse = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), (LPSTR)pszText, NULL, uType | MB_TASKMODAL);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CallbackOnTimeout
// --------------------------------------------------------------------------------
HRESULT CallbackOnTimeout(LPINETSERVER pServer, IXPTYPE ixpServerType, DWORD dwTimeout,
                          ITimeoutCallback *pCallback, LPHTIMEOUT phTimeout)
{
    // Locals
    HWND         hwndTimeout;

    // Trace
    TraceCall("CallbackOnTimeout");

    // Invalid Args
    Assert(pServer && phTimeout);

    // Set hwndTimeout
    hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

    // We are already showing a timeout dialog
    if (NULL == hwndTimeout)
    {
        LPCSTR  pszProtocol;

        // Do the Dialog
        GetProtocolString(&pszProtocol, ixpServerType);
        hwndTimeout = TaskUtil_HwndOnTimeout(pServer->szServerName, pServer->szAccount, pszProtocol, dwTimeout, pCallback);

        // Cast to phTimeout
        *phTimeout = (HTIMEOUT)hwndTimeout;

        // Store It
        TlsSetValue(g_dwTlsTimeout, (LPVOID)hwndTimeout);
    }

    // Done
    return(S_OK);
}



// --------------------------------------------------------------------------------
// CallbackCloseTimeout
// --------------------------------------------------------------------------------
HRESULT CallbackCloseTimeout(LPHTIMEOUT phTimeout)
{
    // Locals
    HWND    hwndTimeout=NULL;

    // Trace
    TraceCall("CallbackCloseTimeout");

    // Invalid Args
    Assert(phTimeout);

    // Nothing to Close
    if (NULL == *phTimeout)
        return(S_OK);

    // Get Timeout
    hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

    // Must Equal hwndTimeout
    Assert(hwndTimeout == (HWND)*phTimeout);

    // Kill the Window
    if (hwndTimeout && IsWindow(hwndTimeout) && hwndTimeout == (HWND)*phTimeout)
    {
        // Kil It
        DestroyWindow(hwndTimeout);
    }

    // Not Timeout
    TlsSetValue(g_dwTlsTimeout, NULL);

    // Null phTmieout
    *phTimeout = NULL;

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CallbackOnTimeoutResponse
// --------------------------------------------------------------------------------
HRESULT CallbackOnTimeoutResponse(TIMEOUTRESPONSE eResponse, IOperationCancel *pCancel, 
    LPHTIMEOUT phTimeout)
{
    // Trace
    TraceCall("CallbackOnTimeoutResponse");

    // better have a Cancel
    Assert(pCancel);

    // Handle the timeout
    switch(eResponse)
    {
    case TIMEOUT_RESPONSE_STOP:
        if (pCancel)
            pCancel->Cancel(CT_ABORT);
        break;

    case TIMEOUT_RESPONSE_WAIT:
        CallbackCloseTimeout(phTimeout);
        break;

    default:
        Assert(FALSE);
        break;
    }

    // Kill the timeout dialog
    CallbackCloseTimeout(phTimeout);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CallbackCanConnect
// --------------------------------------------------------------------------------
HRESULT CallbackCanConnect(LPCSTR pszAccountId, HWND hwndParent, BOOL fPrompt)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CallbackCanConnect");

    // Validate the Args
    Assert(pszAccountId);

    Assert(hwndParent);

    // We Should hav g_pConMan
    Assert(g_pConMan);

    // Call Into It
    if (g_pConMan)
    {
        // Can We Connect
        hr = g_pConMan->CanConnect((LPSTR)pszAccountId);

        if ((hr != S_OK) && (hr != HR_E_DIALING_INPROGRESS) && (fPrompt))
        {
            //We go ahead and connect
            hr = g_pConMan->Connect((LPSTR)pszAccountId, hwndParent, fPrompt);
        }
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CallbackDisplayError
// --------------------------------------------------------------------------------
HRESULT CallbackDisplayError(HWND hwndParent, HRESULT hrResult, LPSTOREERROR pError)
{
    // Locals
    CHAR            sz[CCHMAX_STRINGRES + 512];
    LPSTR           pszError = NULL;

    // Trace
    TraceCall("CallbackDisplayError");

    // Do not show errors that are caused by explicit user action
    switch (hrResult)
    {
        case HR_E_OFFLINE_FOLDER_CREATE:
            LoadString(g_hLocRes, idsErrOfflineFldrCreate, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case HR_E_OFFLINE_FOLDER_MOVE:
            LoadString(g_hLocRes, idsErrOfflineFldrMove, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case HR_E_OFFLINE_FOLDER_DELETE:
            LoadString(g_hLocRes, idsErrOfflineFldrDelete, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case HR_E_OFFLINE_FOLDER_RENAME:
            LoadString(g_hLocRes, idsErrOfflineFldrRename, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case STORE_E_OPERATION_CANCELED:
        case HR_E_USER_CANCEL_CONNECT:
        case HR_E_OFFLINE:
        case HR_E_DIALING_INPROGRESS:
        case STORE_E_EXPIRED:
        case STORE_E_NOREMOTESPECIALFLDR: // Note should handle this case itself
        case IXP_E_USER_CANCEL:
        case IXP_E_HTTP_NOT_MODIFIED:
        case hrUserCancel:
            return(S_OK);

    }

    // Figure out error description string, if none provided
    if (NULL == pError || pError->pszProblem == NULL || '\0' == pError->pszProblem[0])
    {
        UINT            idsError = IDS_IXP_E_UNKNOWN;
        LPCTASKERROR    pTaskError=NULL;
        char            szRes[CCHMAX_STRINGRES];

        if (pError)
        {
            // Try to locate an Error Info
            pTaskError = PTaskUtil_GetError(pError->hrResult, NULL);
        }

        // Try to locate an Error Info
        if (NULL == pTaskError)
        {
            // Try to find a task error
            pTaskError = PTaskUtil_GetError(hrResult, NULL);
        }

        // If we have a task error
        if (pTaskError)
        {
            // Set the String
            idsError = pTaskError->ulStringId;
        }

        // Better Succeed
        SideAssert(LoadString(g_hLocRes, idsError, szRes, ARRAYSIZE(szRes)) > 0);

        // Add any extra information to the error string that might be necessary
        switch (idsError)
        {
            // Requires account name
            case idsNNTPErrUnknownResponse:
            case idsNNTPErrNewgroupsFailed:
            case idsNNTPErrListFailed:
            case idsNNTPErrPostFailed:
            case idsNNTPErrDateFailed:
            case idsNNTPErrPasswordFailed:
            case idsNNTPErrServerTimeout:
                wnsprintf(sz, ARRAYSIZE(sz), szRes, (pError && pError->pszAccount ? pError->pszAccount : TEXT("")));
                break;
        
            // Group name, then account name
            case idsNNTPErrListGroupFailed:
            case idsNNTPErrGroupFailed:
            case idsNNTPErrGroupNotFound:
                wnsprintf(sz, ARRAYSIZE(sz), szRes, (pError && pError->pszFolder ? pError->pszFolder : TEXT("")), (pError && pError->pszAccount ? pError->pszAccount : TEXT("")));
                break;

            // Group name only
            case idsNNTPErrHeadersFailed:
            case idsNNTPErrXhdrFailed:
                wnsprintf(sz, ARRAYSIZE(sz), szRes, (pError->pszFolder ? pError->pszFolder : TEXT("")));
                break;

            default:
                StrCpyN(sz, szRes, ARRAYSIZE(sz));
                break;
        }

        pszError = sz;
    }
    else
        // Provided error string should always override generic HRESULT error str
        pszError = pError->pszProblem;

    // No pError ?
    if (pError)
    {
        INETMAILERROR   ErrorInfo={0};

        // Setup the Error Structure
        ErrorInfo.dwErrorNumber = pError->uiServerError;
        ErrorInfo.hrError = pError->hrResult;
        ErrorInfo.pszServer = pError->pszServer;
        ErrorInfo.pszAccount = pError->pszAccount;
        ErrorInfo.pszMessage = pszError;
        ErrorInfo.pszUserName = pError->pszUserName;
        ErrorInfo.pszProtocol = pError->pszProtocol;
        ErrorInfo.pszDetails = pError->pszDetails;
        ErrorInfo.dwPort = pError->dwPort;
        ErrorInfo.fSecure = pError->fSSL;

        // Beep
        MessageBeep(MB_OK);

        // Show the error
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddInetMailError), hwndParent, InetMailErrorDlgProc, (LPARAM)&ErrorInfo);
    }

    // Otherwise, show an error
    else
    {
        // Beep
        MessageBeep(MB_OK);

        // Show an error
        AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), pszError, NULL, MB_OK | MB_TASKMODAL);
    }

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CompareTableIndexes
// --------------------------------------------------------------------------------
HRESULT CompareTableIndexes(LPCTABLEINDEX pIndex1, LPCTABLEINDEX pIndex2)
{
    // Locals
    DWORD i;

    // Trace
    TraceCall("CompareTableIndexes");

    // Different Number of Keys
    if (pIndex1->cKeys != pIndex2->cKeys)
        return(S_FALSE);

    // Loop through the keys
    for (i=0; i<pIndex1->cKeys; i++)
    {
        // Different Column
        if (pIndex1->rgKey[i].iColumn != pIndex2->rgKey[i].iColumn)
            return(S_FALSE);

        // Different Compare Flags
        if (pIndex1->rgKey[i].bCompare != pIndex2->rgKey[i].bCompare)
            return(S_FALSE);

        // Different Compare Bits
        if (pIndex1->rgKey[i].dwBits != pIndex2->rgKey[i].dwBits)
            return(S_FALSE);
    }

    // Equal
    return(S_OK);
}

// --------------------------------------------------------------------------------
// EmptyFolder
// --------------------------------------------------------------------------------
HRESULT EmptyFolder(HWND hwndParent, FOLDERID idFolder)
{
    // Locals
    char            sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("EmptyFolder");

    // Open the Folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder));

    // Delete all the messages from the folder
    IF_FAILEXIT(hr = DeleteMessagesProgress(hwndParent, pFolder, DELETE_MESSAGE_NOPROMPT | DELETE_MESSAGE_NOTRASHCAN, NULL));

    // Delete Sub Folders..
    IF_FAILEXIT(hr = DeleteFolderProgress(hwndParent, idFolder, DELETE_FOLDER_CHILDRENONLY | DELETE_FOLDER_RECURSIVE));

exit:
    // Cleanup
    SafeRelease(pFolder);

    // Error Message
    if (FAILED(hr))
    {
        g_pStore->GetFolderInfo(idFolder, &Folder);
        AthLoadString(idsErrDeleteOnExit, sz, ARRAYSIZE(sz));
        wnsprintf(szT, ARRAYSIZE(szT), sz, Folder.pszName);
        AthErrorMessage(g_hwndInit, MAKEINTRESOURCE(idsAthenaMail), szT, hr);
        g_pStore->FreeRecord(&Folder);
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// EmptySpecialFolder
// --------------------------------------------------------------------------------
HRESULT EmptySpecialFolder(HWND hwndParent, SPECIALFOLDER tySpecial)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("EmptySpecialFolder");

    // Get special folder information
    IF_FAILEXIT(hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, tySpecial, &Folder));

    // Delete all the messages from the folder
    IF_FAILEXIT(hr = EmptyFolder(hwndParent, Folder.idFolder));

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// IsParentDeletedItems
//----------------------------------------------------------------------------------
HRESULT IsParentDeletedItems(FOLDERID idFolder, LPFOLDERID pidDeletedItems,
    LPFOLDERID pidServer)
{
    // Locals
    BOOL        fInTrashCan=FALSE;
    FOLDERID    idCurrent=idFolder;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("IsParentDeletedItems");
    
    // Invalid Arg
    Assert(pidDeletedItems && pidServer);

    // Initialize
    *pidDeletedItems = FOLDERID_INVALID;
    *pidServer = FOLDERID_INVALID;

    // Walk up the parent chain
    while (SUCCEEDED(g_pStore->GetFolderInfo(idCurrent, &Folder)))
    {
        // If this is the deleted items folder
        if (FOLDER_DELETED == Folder.tySpecial)
        {
            // idFolder is a child of the deleted items folder...
            fInTrashCan = TRUE;

            // Save the Id
            *pidDeletedItems = Folder.idFolder;
        }

        // If This is a Server, done
        if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        {
            // Return Server
            *pidServer = Folder.idFolder;

            // Done
            break;
        }

        // Set idCurrent
        idCurrent = Folder.idParent;

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Validate
    Assert(FOLDERID_INVALID != *pidServer);

    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(TRUE == fInTrashCan ? S_OK : S_FALSE);
}

HRESULT CreateTempNewsAccount(LPCSTR pszServer, DWORD dwPort, BOOL fSecure, IImnAccount **ppAcct)
{
    IImnAccount        *pAcct, *pDefAcct;
    IImnEnumAccounts   *pEnum;
    DWORD               dwTemp;
    char                szServer[1024];
    HRESULT             hr;
    
    *ppAcct = NULL;
    
    if (lstrlen(pszServer) >= CCHMAX_SERVER_NAME)
        return(E_FAIL);

    // First try to see if we can find such a server.
    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_NNTP, &pEnum)))
    {
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_SERVER, szServer, ARRAYSIZE(szServer))))
            {
                if (0 == lstrcmpi(pszServer, szServer))
                {
                    // The server names are the same, but we also need to make
                    // sure the port numbers are the same as well
                    if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_PORT, &dwTemp)) && dwTemp == dwPort)
                    {
                        // This is really bizzare.  Since this value doesn't seem to have a default 
                        // setting, if it hasn't been set yet, it returns E_NoPropData.
                        hr = pAcct->GetPropDw(AP_NNTP_SSL, &dwTemp);
                        if (hr == E_NoPropData || (SUCCEEDED(hr) && dwTemp == (DWORD) fSecure))
                        {
                            *ppAcct = pAcct;
                            break;
                        }
                    }
                }
            }
            pAcct->Release();
        }
        pEnum->Release();
    }
    
    if (*ppAcct)
        return (S_OK);
    
    // Try to create a new account object
    if (FAILED(hr = g_pAcctMan->CreateAccountObject(ACCT_NEWS, &pAcct)))
        return (hr);
    
    // We have the object, so set the account name and server name to pszServer.
    StrCpyN(szServer, pszServer, ARRAYSIZE(szServer));
    g_pAcctMan->GetUniqueAccountName(szServer, ARRAYSIZE(szServer));
    pAcct->SetPropSz(AP_ACCOUNT_NAME, szServer);
    pAcct->SetPropSz(AP_NNTP_SERVER, (LPSTR)pszServer);
    pAcct->SetPropDw(AP_NNTP_PORT, dwPort);
    pAcct->SetPropDw(AP_NNTP_SSL, fSecure);
    
    // Load the default news account
    if (SUCCEEDED(hr = g_pAcctMan->GetDefaultAccount(ACCT_NEWS, &pDefAcct)))
    {
        // Copy the User Name
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_DISPLAY_NAME, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, szServer);
        
        // Copy the Org
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_ORG_NAME, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_ORG_NAME, szServer);
        
        // Copy the email
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, szServer);
        
        // Copy the reply to
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szServer);
        
        pDefAcct->Release();
    }
    
    // Tag this account as a temporary account
    pAcct->SetPropDw(AP_TEMP_ACCOUNT, (DWORD)TRUE);
    
    // save the changes
    pAcct->SaveChanges();
    
    *ppAcct = pAcct;
    
    return (S_OK);
}

void CleanupTempNewsAccounts()
{
    IImnAccount        *pAcct;
    IImnEnumAccounts   *pEnum;
    DWORD               dwTemp;
    BOOL                fSub;
    FOLDERID            idAcct;
    HRESULT             hr;
    FOLDERINFO          info;
    char                szAcct[CCHMAX_ACCOUNT_NAME];
    
    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_NNTP, &pEnum)))
    {
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            if (SUCCEEDED(pAcct->GetPropDw(AP_TEMP_ACCOUNT, &dwTemp)) && dwTemp)
            {
                if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szAcct, ARRAYSIZE(szAcct))))
                {
                    // if it doesn't have any subscribed children,
                    // we can delete it

                    fSub = FALSE;

                    hr = g_pStore->FindServerId(szAcct, &idAcct);
                    if (SUCCEEDED(hr))
                    {
                        IEnumerateFolders  *pFldrEnum;

                        // News accounts only have ONE level, so enumerate immediate
                        // subscribed children to see if there is at least one of them
                        hr = g_pStore->EnumChildren(idAcct, TRUE, &pFldrEnum);
                        if (SUCCEEDED(hr))
                        {
                            hr = pFldrEnum->Next(1, &info, NULL);
                            if (S_OK == hr)
                            {
                                if (info.dwFlags & FOLDER_SUBSCRIBED)
                                    fSub = TRUE;
                                
                                g_pStore->FreeRecord(&info);
                            }
                            pFldrEnum->Release();
                        }
                    }

                    if (fSub)
                        pAcct->SetPropDw(AP_TEMP_ACCOUNT, (DWORD)FALSE);
                    else
                        pAcct->Delete();
                }
            }
            pAcct->Release();
        }
        pEnum->Release();
    }
}

HRESULT FindGroupAccount(LPCSTR pszGroup, LPSTR pszAccount, UINT cchAccount)
{
    IImnEnumAccounts *pEnum;
    IImnAccount *pAcct;
    FOLDERID idAcct;
    HRESULT hr;
    HLOCK hLock;
    FOLDERINFO Folder;
    char szAccount[CCHMAX_ACCOUNT_NAME], szDefAcct[CCHMAX_ACCOUNT_NAME];
    UINT cScore, cScoreMax = 0;
    
    *szDefAcct = 0;
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccount(ACCT_NEWS, &pAcct)))
    {
        pAcct->GetPropSz(AP_ACCOUNT_ID, szDefAcct, ARRAYSIZE(szDefAcct));
        pAcct->Release();
    }

    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_NNTP, &pEnum)))
    {
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szAccount, ARRAYSIZE(szAccount))) &&
                SUCCEEDED(g_pStore->FindServerId(szAccount, &idAcct)) &&
                SUCCEEDED(g_pStore->Lock(&hLock)))
            {
                cScore = 0;
    
                ZeroMemory(&Folder, sizeof(FOLDERINFO));
                Folder.idParent = idAcct;
                Folder.pszName = (LPSTR)pszGroup;
                
                if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
                {
                    // look for it in the group list
                    cScore += 1;
                    
                    // check to see if it is subscribed
                    if (!!(Folder.dwFlags & FOLDER_SUBSCRIBED))
                        cScore += 4;
                    
                    g_pStore->FreeRecord(&Folder);
                }
                
                if (cScore)
                {
                    // is this the default account?
                    if (0 == lstrcmpi(szAccount, szDefAcct))
                        cScore += 2;
                    
                    if (cScore > cScoreMax)
                    {
                        cScoreMax = cScore;
                        StrCpyN(pszAccount, szAccount, cchAccount);
                    }
                }
                
                g_pStore->Unlock(&hLock);
            }

            pAcct->Release();
        } 

        pEnum->Release();
    }

    return(cScoreMax > 0 ? S_OK : E_FAIL);
}

HRESULT GetNewsGroupFolderId(LPCSTR pszAccount, LPCSTR pszGroup, FOLDERID *pid)
{
    FOLDERID idAcct;
    HRESULT hr;
    HLOCK hLock;
    FOLDERINFO Folder = {0};
    
    Assert(pszAccount != NULL);
    Assert(pszGroup != NULL);
    Assert(pid != NULL);
    
    hr = g_pStore->FindServerId(pszAccount, &idAcct);
    if (FAILED(hr))
        return(hr);
    
    hr = g_pStore->Lock(&hLock);
    if (FAILED(hr))
        return(hr);
    
    Folder.idParent = idAcct;
    Folder.pszName = (LPSTR)pszGroup;
    
    if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        *pid = Folder.idFolder;
        
        g_pStore->FreeRecord(&Folder);
    }
    else
    {
        ZeroMemory(&Folder, sizeof(FOLDERINFO));
        Folder.idParent = idAcct;
        Folder.tySpecial = FOLDER_NOTSPECIAL;
        Folder.pszName = (LPSTR)pszGroup;

        hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &Folder, NULL);           
        if (SUCCEEDED(hr))
            *pid = Folder.idFolder;
    }
    
    g_pStore->Unlock(&hLock);
    
    return(hr);
}

HRESULT GetFolderIdFromNewsUrl(LPCSTR pszServer, UINT uPort, LPCSTR pszGroup, BOOL fSecure, FOLDERID *pid)
{
    char            szAccount[CCHMAX_ACCOUNT_NAME];
    IImnAccount    *pAcct;
    HRESULT         hr;

    Assert(pid != NULL);

    *pid = FOLDERID_INVALID;

    // Bug #20448 - Handle IE 2.0's "news:netnews" and "news:*".  These
    //              should just cause us to launch normally.
    if (0 == lstrcmpi(pszGroup, c_szURLNetNews) || 
        0 == lstrcmpi(pszGroup, g_szAsterisk))
    {
        pszGroup = NULL;
    }

    *szAccount = 0;

    if (uPort == -1)
        uPort = fSecure ? DEF_SNEWSPORT : DEF_NNTPPORT;

    if (pszServer != NULL &&
        SUCCEEDED(CreateTempNewsAccount(pszServer, uPort, fSecure, &pAcct)))
    {
        pAcct->GetPropSz(AP_ACCOUNT_ID, szAccount, ARRAYSIZE(szAccount));
        pAcct->Release();
    }
    else
    {
        if (pszGroup == NULL || FAILED(FindGroupAccount(pszGroup, szAccount, ARRAYSIZE(szAccount))))
        {
            if (FAILED(g_pAcctMan->GetDefaultAccount(ACCT_NEWS, &pAcct)))
                return(E_FAIL);

            pAcct->GetPropSz(AP_ACCOUNT_ID, szAccount, ARRAYSIZE(szAccount));
            pAcct->Release();
        }
    }

    if (pszGroup != NULL)
    {
        hr = GetNewsGroupFolderId(szAccount, pszGroup, pid);
    }
    else
    {
        hr = g_pStore->FindServerId(szAccount, pid);
    }

    return(hr);
}



#define CHASH_BUCKETS   50

HRESULT CreateFolderHash(IMessageStore *pStore, FOLDERID idRoot, IHashTable **ppHash)
{
    IHashTable  *pHash=0;
    HRESULT     hr;
    LPSTR       pszTemp;
    DWORD       dwTemp;

    hr = MimeOleCreateHashTable(CHASH_BUCKETS, TRUE, &pHash);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }        

    pszTemp = NULL;
    dwTemp = 0;
    hr = HashChildren(pStore, idRoot, pHash, &pszTemp, 0, &dwTemp);
    SafeMemFree(pszTemp);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    *ppHash = pHash;
    pHash = NULL;
        
exit:
    ReleaseObj(pHash);
    return hr;
}

HRESULT HashChildren(IMessageStore *pStore, FOLDERID idParent, IHashTable *pHash,
                     LPSTR *ppszPath, DWORD dwChildOffset, DWORD *pdwAlloc)
{
    FOLDERINFO			fi;
    HRESULT				hr=S_OK;
	IEnumerateFolders	*pFldrEnum=0;
    LPSTR               pszInsertPt;

    pszInsertPt = *ppszPath + dwChildOffset;
    hr = pStore->EnumChildren(idParent, FALSE, &pFldrEnum);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    while (pFldrEnum->Next(1, &fi, NULL)==S_OK)
    {
        DWORD dwFldrNameLen;

        // Check if path buffer is large enough to accommodate current
        // foldername + hierarchy char + null term
        dwFldrNameLen = lstrlen(fi.pszName);
        if (dwFldrNameLen + dwChildOffset + 1 >= *pdwAlloc)
        {
            BOOL    fResult;
            DWORD   dwNewSize;

            dwNewSize = dwChildOffset + dwFldrNameLen + 51; // 1 byte for HC, 50 bytes worth of insurance
            Assert(dwNewSize > *pdwAlloc);
            fResult = MemRealloc((void **) ppszPath, dwNewSize * sizeof(**ppszPath));
            if (FALSE == fResult)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                pStore->FreeRecord(&fi);
                goto exit;
            }

            *pdwAlloc = dwNewSize;
            pszInsertPt = *ppszPath + dwChildOffset;
        }

        // Construct current folder path, insert into table
        StrCpyN(pszInsertPt, fi.pszName, *pdwAlloc - (int) (pszInsertPt - *ppszPath));
        hr = pHash->Insert(*ppszPath, (LPVOID)fi.idFolder, NOFLAGS);
        if (FAILED(hr))
        {
            TraceResult(hr);
            pStore->FreeRecord(&fi);
            goto exit;
        }
    
        // if this folder has kids, recurse into it's child folders
        if (fi.dwFlags & FOLDER_HASCHILDREN)
        {
            // Append hierarchy character to current foldername
            IxpAssert(0 != fi.bHierarchy && 0xFF != fi.bHierarchy);
            Assert(dwFldrNameLen + 1 + dwChildOffset < *pdwAlloc); // Hierarchy char is guaranteed to fit (see above)
            pszInsertPt[dwFldrNameLen] = fi.bHierarchy;
            pszInsertPt[dwFldrNameLen + 1] = '\0'; // Don't need to null-term

            hr = HashChildren(pStore, fi.idFolder, pHash, ppszPath,
                dwChildOffset + dwFldrNameLen + 1, pdwAlloc);
            if (FAILED(hr))
            {
                TraceResult(hr);
                pStore->FreeRecord(&fi);
                goto exit;
            }

            // Recalculate pszInsertPt, in case HashChildren re-alloc'ed
            pszInsertPt = *ppszPath + dwChildOffset;
        }
        pStore->FreeRecord(&fi);
    }

exit:
    ReleaseObj(pFldrEnum);
    return hr;
}

#define CMAX_DELETE_SEARCH_BLOCK 50
HRESULT UnsubscribeHashedFolders(IMessageStore *pStore, IHashTable *pHash)
{
    ULONG   cFound=0;
    LPVOID  *rgpv;

    pHash->Reset();

    while (SUCCEEDED(pHash->Next(CMAX_DELETE_SEARCH_BLOCK, &rgpv, &cFound)))
    {
        while(cFound--)
        {
            pStore->SubscribeToFolder((FOLDERID)rgpv[cFound], FALSE, NULL);
        }

        SafeMemFree(rgpv);
    }
    return S_OK;
}


#ifdef DEBUG
LPCSTR sotToSz(STOREOPERATIONTYPE sot)
{

    switch (sot)
    {
    case SOT_INVALID:
        return "Invalid";
    
    case SOT_CONNECTION_STATUS:
        return "ConnectionStatus";

    case SOT_SYNC_FOLDER:
        return "SyncFolder";

    case SOT_GET_MESSAGE:
        return "GetMessage";

    case SOT_PUT_MESSAGE:
        return "PutMessage";

    case SOT_COPYMOVE_MESSAGE:
        return "CopyMoveMessage";

    case SOT_SYNCING_STORE:
        return "SyncStore";

    case SOT_CREATE_FOLDER:
        return "CreateFolder";

    case SOT_SEARCHING:
        return "Search";

    case SOT_DELETING_MESSAGES:
        return "DeleteMessage";

    case SOT_SET_MESSAGEFLAGS:
        return "SetMessageFlags";

	case SOT_MOVE_FOLDER:
        return "MoveFolder";

	case SOT_DELETE_FOLDER:
        return "DeleteFolder";

	case SOT_RENAME_FOLDER:
        return "RenameFolder";

	case SOT_SUBSCRIBE_FOLDER:
        return "SubscribeFolder";

	case SOT_UPDATE_FOLDER:
        return "UpdateFolderCounts";

    case SOT_GET_NEW_GROUPS:
        return "GetNewGroups";

    case SOT_PURGING_MESSAGES:
        return "PurgeMessages";

    case SOT_NEW_MAIL_NOTIFICATION:
        return "NewMailNotify";

    default:
        return "<SOT_UNKNOWN>";
    }
}
#endif

HRESULT SetSynchronizeFlags(FOLDERID idFolder, DWORD flags)
{
    FOLDERINFO info;
    HRESULT hr;

    Assert(0 == (flags & ~(FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)));

    hr = g_pStore->GetFolderInfo(idFolder, &info);
    if (SUCCEEDED(hr))
    {
        info.dwFlags &= ~(FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL);
        if (flags != 0)
            info.dwFlags |= flags;

        hr = g_pStore->UpdateRecord(&info);

        g_pStore->FreeRecord(&info);
    }

    return(hr);
}


HRESULT CreateMessageFromInfo(MESSAGEINFO *pInfo, IMimeMessage **ppMessage, FOLDERID folderID)
{
    IMimeMessage   *pMsg=0;
    HRESULT         hr;
    PROPVARIANT     pv;

    if (!ppMessage || !pInfo)
        return TraceResult(E_INVALIDARG);

    *ppMessage = NULL;

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    
    // sent-time
    pv.vt = VT_FILETIME;
    CopyMemory(&pv.filetime, &pInfo->ftSent, sizeof(FILETIME));
    pMsg->SetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv);

    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, pInfo->pszMessageId);
    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, pInfo->pszSubject);
    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, pInfo->pszFromHeader);
    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, pInfo->pszDisplayTo);

    if (FOLDERID_INVALID != folderID)
    {
        FOLDERINFO  fi;
        hr = g_pStore->GetFolderInfo(folderID, &fi);
        if (SUCCEEDED(hr))
        {
            if (FOLDER_NEWS == fi.tyFolder)
            {
                if (0 == (FOLDER_SERVER & fi.dwFlags))
                    hr = MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, fi.pszName);
            }
            g_pStore->FreeRecord(&fi);
        }
    }

    HrSetAccount(pMsg, pInfo->pszAcctName);

    *ppMessage = pMsg;
    pMsg = NULL;
    hr = S_OK;

exit:
    ReleaseObj(pMsg);
    return hr;
}


HRESULT CommitMessageToStore(IMessageFolder *pFolder, ADJUSTFLAGS *pflags, MESSAGEID idMessage, LPSTREAM pstm)
{
    HRESULT         hr;
    IMimeMessage    *pMsg=0;
    DWORD           dwFlags=0,
                    dwAddFlags=0,
                    dwRemoveFlags=0;
    MESSAGEIDLIST   rMsgList;
    ADJUSTFLAGS     rAdjFlags;

    TraceCall("CIMAPSync::_OnMessageDownload");

    Assert (pFolder);

    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pMsg->Load(pstm);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    if (SUCCEEDED(pMsg->GetFlags(&dwFlags)))
        dwAddFlags = ConvertIMFFlagsToARF(dwFlags);

    // We always want to remove ARF_DOWNLOAD when downloading a message body
    dwRemoveFlags |= ARF_DOWNLOAD;

    rMsgList.cAllocated = 0;
    rMsgList.cMsgs = 1;
    rMsgList.prgidMsg = &idMessage;

    if (pflags==NULL)
    {
        pflags = &rAdjFlags;
        
        rAdjFlags.dwRemove = 0;
        rAdjFlags.dwAdd = 0;
    }
        
    pflags->dwAdd |= dwAddFlags;
    pflags->dwRemove |= dwRemoveFlags;
    hr = pFolder->SetMessageFlags(&rMsgList, pflags, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->SetMessageStream(idMessage, pstm);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }


exit:
    ReleaseObj(pMsg);
    return hr;
}

HRESULT CreatePersistentWriteStream(IMessageFolder *pFolder, IStream **ppStream, LPFILEADDRESS pfaStream)
{
    HRESULT hr=S_OK;

    TraceCall("CreateOpenStream");

    Assert(NULL != pFolder && NULL != ppStream && NULL != pfaStream);
    if (NULL == pFolder || NULL == ppStream || NULL == pfaStream)
        return E_INVALIDARG;

    *ppStream = NULL;
    *pfaStream = 0;

    hr = pFolder->CreateStream(pfaStream);
    if (!FAILED(hr))
    {
        hr = pFolder->OpenStream(ACCESS_WRITE, *pfaStream, ppStream);
        if (FAILED(hr))
        {
            pFolder->DeleteStream(*pfaStream);
            *pfaStream = 0;
        }
    }

    return hr;
}

HRESULT GetHighestCachedMsgID(IMessageFolder *pFolder, DWORD_PTR *pdwHighestCachedMsgID)
{
    HRESULT     hr;
    HROWSET     hRowSet = HROWSET_INVALID;
    MESSAGEINFO miMsgInfo = {0};

    TraceCall("GetHighestCachedMsgID");
    Assert(NULL != pdwHighestCachedMsgID);

    hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowSet);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->SeekRowset(hRowSet, SEEK_ROWSET_END, 0, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->QueryRowset(hRowSet, 1, (void **)&miMsgInfo, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (HROWSET_INVALID != hRowSet)
    {
        HRESULT hrTemp;

        // Record but otherwise ignore error
        hrTemp = pFolder->CloseRowset(&hRowSet);
        TraceError(hrTemp);
    }

    // Return highest cached UID
    if (DB_E_NORECORDS == hr)
    {
        // No problem, no records means highest cached UID = 0
        *pdwHighestCachedMsgID = 0;
        hr = S_OK;
    }
    else if (SUCCEEDED(hr))
    {
        *pdwHighestCachedMsgID = (DWORD_PTR) miMsgInfo.idMessage;
        pFolder->FreeRecord(&miMsgInfo);
    }

    return hr;
}

HRESULT DeleteMessageFromStore(MESSAGEINFO * pMsgInfo, IDatabase *pDB, IDatabase * pUidlDB)
{
    // Locals
    HRESULT         hr = S_OK;
    UIDLRECORD      UidlInfo = {0};

    // Trace
    TraceCall("DeleteMessageFromStore");

    Assert(NULL != g_pStore);
    
    // Check incoming params
    if ((NULL == pMsgInfo) || (NULL == pDB))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Delete the message
    IF_FAILEXIT(hr = pDB->DeleteRecord(pMsgInfo));

    // Update UIDL Cache ?
    if (pUidlDB && !FIsEmptyA(pMsgInfo->pszUidl) && !FIsEmptyA(pMsgInfo->pszServer))
    {
        // Set Search Key
        UidlInfo.pszUidl = pMsgInfo->pszUidl;
        UidlInfo.pszServer = pMsgInfo->pszServer;
        UidlInfo.pszAccountId = pMsgInfo->pszAcctId;

        // Loop it up
        if (DB_S_FOUND == pUidlDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &UidlInfo, NULL))
        {
            // Deleted on client
            UidlInfo.fDeleted = TRUE;

            // Set the prop
            pUidlDB->UpdateRecord(&UidlInfo);

            // Free the Record
            pUidlDB->FreeRecord(&UidlInfo);
        }
    }

    hr = S_OK;
    
exit:
    // Done
    return(hr);
}

BOOL FFolderIsServer(FOLDERID id)
{
    FOLDERINFO fi = {0};
    HRESULT    hr;
    BOOL       fServer = FALSE;

    // Get Folder Info
    hr = g_pStore->GetFolderInfo(id, &fi);
    if (FAILED(hr))
        return (FALSE);

    // Is this a server ?
    fServer = ISFLAGSET(fi.dwFlags, FOLDER_SERVER);

    g_pStore->FreeRecord(&fi);
    return (fServer);
}

HRESULT GetIdentityStoreRootDirectory(IUserIdentity *pId, LPSTR pszDir, DWORD cchMaxDir)
{
    // Locals
    HKEY        hkey;
    char        szProfile[MAX_PATH];
    HRESULT     hr=S_OK;
    DWORD       cb;
    DWORD       dwType;

    Assert(pId != NULL);
    Assert(pszDir != NULL);
    Assert(cchMaxDir >= MAX_PATH);

    hr = pId->OpenIdentityRegKey(KEY_ALL_ACCESS, &hkey);
    if (FAILED(hr))
        return(hr);

    // Get the Root Directory
    cb = cchMaxDir;
    if (ERROR_SUCCESS != SHGetValue(hkey, c_szRegRoot, c_szRegStoreRootDir, &dwType, (LPBYTE)pszDir, &cb))
    {
        // Get Default Root
        IF_FAILEXIT(hr = MU_GetIdentityDirectoryRoot(pId, pszDir, cchMaxDir));

        // If the directory doesn't exist yet ?
        if (FALSE == PathIsDirectory(pszDir))
        {
            // Our default directory doesn't exist, so create it
            IF_FAILEXIT(hr = OpenDirectory(pszDir));
        }

        // Set the Store Directory
        dwType = AddEnvInPath(pszDir, szProfile, ARRAYSIZE(szProfile)) ? REG_EXPAND_SZ : REG_SZ;
        SHSetValue(hkey, c_szRegRoot, c_szRegStoreRootDir, dwType, pszDir, lstrlen(pszDir) + 1);
    }

    // Get the length
    cb = lstrlen(pszDir);

    // No root
    if (0 == cb)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Fixup the end
    PathRemoveBackslash(pszDir);
    
    // If the directory doesn't exist yet ?
    if (FALSE == PathIsDirectory(pszDir))
    {
        // Our default directory doesn't exist, so create it
        IF_FAILEXIT(hr = OpenDirectory(pszDir));
    }

exit:
    RegCloseKey(hkey);

    return hr;
}

HRESULT ImportSubNewsGroups(IUserIdentity *pId, IImnAccount *pAcct, LPCSTR pszGroups)
{
    HRESULT hr;
    FOLDERINFO Folder;
    IMessageStore *pStore;
    FOLDERID idServer;
    char szStoreDir[MAX_PATH + MAX_PATH];

    Assert(pszGroups != NULL);

    if (pId == NULL)
    {
        Assert(g_pLocalStore != NULL);
        pStore = g_pLocalStore;
        pStore->AddRef();
    }
    else
    {
        hr = GetIdentityStoreRootDirectory(pId, szStoreDir, ARRAYSIZE(szStoreDir));
        if (FAILED(hr))
            return(hr);

        hr = CoCreateInstance(CLSID_MessageStore, NULL, CLSCTX_INPROC_SERVER, IID_IMessageStore, (LPVOID *)&pStore);
        if (FAILED(hr))
            return(hr);

        hr = pStore->Initialize(szStoreDir);
        if (FAILED(hr))
        {
            pStore->Release();
            return(hr);
        }
    }

    hr = pStore->CreateServer(pAcct, NOFLAGS, &idServer);
    if (SUCCEEDED(hr))
    {
        while (*pszGroups != 0)
        {
            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.pszName = (LPSTR)pszGroups;
            Folder.idParent = idServer;

            if (DB_S_FOUND == pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                if ((Folder.dwFlags & FOLDER_SUBSCRIBED) == 0)
                {
                    Folder.dwFlags |= FOLDER_SUBSCRIBED;
                    
                    pStore->UpdateRecord(&Folder);
                }

                pStore->FreeRecord(&Folder);
            }
            else
            {
                Folder.tySpecial = FOLDER_NOTSPECIAL;
                Folder.dwFlags = FOLDER_SUBSCRIBED;

                hr = pStore->CreateFolder(NOFLAGS, &Folder, NULL);           
                Assert(hr != STORE_S_ALREADYEXISTS);

                if (FAILED(hr))
                    break;
            }

            pszGroups += (lstrlen(pszGroups) + 1);
        }
    }

    pStore->Release();

    return(hr);
}

HRESULT DoNewsgroupSubscribe()
{
    HKEY hkey, hkeyT, hkeyUser;
    char szKey[MAX_PATH];
    DWORD cAccts, iAcct, cb;
    LONG lResult, cch, i;
    LPSTR psz;
    BOOL fDelete;
    HRESULT hr;
    IImnAccount *pAcct;

    fDelete = TRUE;
    hkeyUser = MU_GetCurrentUserHKey();

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyUser, c_szRegRootSubscribe, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cAccts, NULL, NULL, NULL, NULL, NULL, NULL, NULL) &&
            cAccts > 0)
        {
            for (iAcct = 0; iAcct < cAccts; iAcct++)
            {
                cb = sizeof(szKey);
                lResult = RegEnumKeyEx(hkey, iAcct, szKey, &cb, 0, NULL, NULL, NULL);
    
                // No more items
                if (lResult == ERROR_NO_MORE_ITEMS)
                    break;
    
                // Error, lets move onto the next account
                if (lResult != ERROR_SUCCESS)
                {
                    Assert(FALSE);
                    continue;
                }

                hr = S_OK;

                if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szKey, &pAcct)))
                {
                    if (ERROR_SUCCESS == RegQueryValue(hkey, szKey, NULL, &cch) && cch > 0)
                    {
                        hr = E_FAIL;

                        cch++;
                        if (MemAlloc((void **)&psz, cch))
                        {
                            if (ERROR_SUCCESS == RegQueryValue(hkey, szKey, psz, &cch))
                            {
                                for (i = 0; i < cch; i++)
                                {
                                    if (psz[i] == ',')
                                        psz[i] = 0;
                                }
                                psz[cch] = 0;

                                hr = ImportSubNewsGroups(NULL, pAcct, psz);
                            }

                            MemFree(psz);
                        }
                    }

                    pAcct->Release();
                }

                if (SUCCEEDED(hr))
                    RegDeleteKey(hkey, szKey);
                else
                    fDelete = FALSE;
            }
        }

        RegCloseKey(hkey);

        if (fDelete)
            RegDeleteKey(hkeyUser, c_szRegRootSubscribe);
    }

    return(S_OK);
}

void GetProtocolString(LPCSTR *ppszResult, IXPTYPE ixpServerType)
{
    switch (ixpServerType)
    {
        case IXP_POP3:
            *ppszResult = "POP3";
            break;

        case IXP_SMTP:
            *ppszResult = "SMTP";
            break;

        case IXP_NNTP:
            *ppszResult = "NNTP";
            break;

        case IXP_IMAP:
            *ppszResult = "IMAP";
            break;

        case IXP_HTTPMail:
            *ppszResult = "HTTPMail";
            break;

        default:
            *ppszResult = "Unknown";
            break;
    }
}

INT_PTR CALLBACK UpdateNewsgroup(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    char sz[CCHMAX_STRINGRES];
    BOOL fEnabled;
    HICON hicon;
    static PUPDATENEWSGROUPINFO puni = 0;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Get the init info
            puni = (PUPDATENEWSGROUPINFO) lParam;
            Assert(puni);             
        
            if (!puni->fNews)
            {
                AthLoadString(idsSyncFolderTitle, sz, ARRAYSIZE(sz));
                SetWindowText(hwnd, sz);

                hicon = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiDLMail));
                SendDlgItemMessage(hwnd, idcStatic1, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hicon);
            }

            // Initialize the dialog settings
            fEnabled = (puni->dwGroupFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL));
            Button_SetCheck(GetDlgItem(hwnd, IDC_GET_CHECK), fEnabled);
        
            Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
            Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
            Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);
        
            // Check the right radio button
            if (fEnabled)
            {
                if (puni->dwGroupFlags & FOLDER_DOWNLOADHEADERS)
                    Button_SetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), TRUE);
                if (puni->dwGroupFlags & FOLDER_DOWNLOADNEW)
                    Button_SetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), TRUE);
                if (puni->dwGroupFlags & FOLDER_DOWNLOADALL)
                    Button_SetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), TRUE);
            }
            else if (puni->fNews)
            {
                Button_SetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), TRUE);
            }
            else
            {
                Button_SetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), TRUE);
            }

            Button_SetCheck(GetDlgItem(hwnd, IDC_GETMARKED_CHECK), puni->cMarked != 0);
            EnableWindow(GetDlgItem(hwnd, IDC_GETMARKED_CHECK), puni->cMarked != 0);

            EnableWindow(GetDlgItem(hwnd, IDOK), fEnabled || puni->cMarked != 0);
            return (TRUE);
        
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_GET_CHECK:
                    // Check to see whether this is actually checked or not
                    fEnabled = Button_GetCheck(GET_WM_COMMAND_HWND(wParam, lParam));
            
                    // Enable or disable the radio buttons
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);
            
                    EnableWindow(GetDlgItem(hwnd, IDOK), fEnabled || Button_GetCheck(GetDlgItem(hwnd, IDC_GETMARKED_CHECK)));
                    return (TRUE);
            
                case IDC_GETMARKED_CHECK:
                    EnableWindow(GetDlgItem(hwnd, IDOK), Button_GetCheck(GET_WM_COMMAND_HWND(wParam, lParam)) || Button_GetCheck(GetDlgItem(hwnd, IDC_GET_CHECK)));
                    return(TRUE);

                case IDOK:
                    // Set up the return value
                    if (Button_GetCheck(GetDlgItem(hwnd, IDC_GET_CHECK)))
                    {
                        if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO)))
                            puni->idCmd |= DELIVER_OFFLINE_HEADERS;
                        else if (Button_GetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO)))
                            puni->idCmd |= DELIVER_OFFLINE_ALL;
                        else if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO)))
                            puni->idCmd |= DELIVER_OFFLINE_NEW;
                    }
            
                    if (Button_GetCheck(GetDlgItem(hwnd, IDC_GETMARKED_CHECK)))
                    {
                        puni->idCmd |= DELIVER_OFFLINE_MARKED;
                    }
            
                    EndDialog(hwnd, 0);
                    return (TRUE);
            
                case IDCANCEL:
                    puni->idCmd = -1;
                    EndDialog(hwnd, 0);
                    return (TRUE);
            }
            return (FALSE);
    }
    
    return (FALSE);
}

HRESULT HasMarkedMsgs(FOLDERID idFolder, BOOL *pfMarked)
{
    HRESULT hr;
    HROWSET hRowset;
    MESSAGEINFO MsgInfo;
    IMessageFolder *pFolder;

    Assert(pfMarked != NULL);

    *pfMarked = FALSE;

    hr = g_pStore->OpenFolder(idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder);
    if (FAILED(hr))
        return(hr);

    hr = pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (SUCCEEDED(hr))
    {
	    while (S_OK == pFolder->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
        {
            if (!!(MsgInfo.dwFlags & (ARF_DOWNLOAD | ARF_WATCH)) && 0 == (MsgInfo.dwFlags & ARF_HASBODY))
            {
                pFolder->FreeRecord(&MsgInfo);
    
                *pfMarked = TRUE;
                break;
            }

            // Free the header info
            pFolder->FreeRecord(&MsgInfo);
        }

        // Release Lock
        pFolder->CloseRowset(&hRowset);
    }
    
    pFolder->Release();

    return (hr);
}

HRESULT SimpleInitStoreForDir(LPCSTR szStoreDir)
{
    CStoreSync *pStore;
    HRESULT hr = S_OK;

    if (g_pStore == NULL)
    {
        Assert(g_pLocalStore == NULL);

        g_pLocalStore = new CMessageStore(FALSE);
        if (g_pLocalStore == NULL)
            return(E_OUTOFMEMORY);

        hr = g_pLocalStore->Initialize(szStoreDir);
        if (SUCCEEDED(hr))
        {
            pStore = new CStoreSync;
            if (pStore == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = pStore->Initialize(g_pLocalStore);
                if (SUCCEEDED(hr))
                {
                    g_pStore = pStore;
                    hr = g_pLocalStore->Validate(STORE_VALIDATE_DONTSYNCWITHACCOUNTS);
                }
                else
                {
                    pStore->Release();
                }
            }
        }
    }

    return(hr);
}

HRESULT SimpleStoreInit(GUID *guid, LPCSTR szStoreDir)
{
    HRESULT hr = S_OK;

    // Init options
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        goto exit;
    }

    // Create account manger
    if (NULL == g_pAcctMan)
    {
        hr = AcctUtil_CreateAccountManagerForIdentity(guid ? guid : PGUIDCurrentOrDefault(), &g_pAcctMan);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    // Create the global connection manager
    if (NULL == g_pConMan)
    {
        g_pConMan = new CConnectionManager();
        if (NULL == g_pConMan)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        // CoIncrementInit the Connection Manager
        hr = g_pConMan->HrInit(g_pAcctMan);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    hr = SimpleInitStoreForDir(szStoreDir);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    return hr;
}

HRESULT SimpleStoreRelease()
{
    HRESULT hr = S_OK;

    SafeRelease(g_pLocalStore);
    SafeRelease(g_pStore);

    SafeRelease(g_pConMan);
    SafeRelease(g_pAcctMan);
    DeInitGlobalOptions();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\storutil.h ===
//--------------------------------------------------------------------------
// Storutil.h
//--------------------------------------------------------------------------
#ifndef __STORUTIL_H
#define __STORUTIL_H

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "newfldr.h"

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CProgress;
typedef struct tagTHREADINGINFO *LPTHREADINGINFO;

//--------------------------------------------------------------------------
// HTIMEOUT
//--------------------------------------------------------------------------
DECLARE_HANDLE(HTIMEOUT);
typedef HTIMEOUT *LPHTIMEOUT;

//--------------------------------------------------------------------------
// HFOLDERENUM
//--------------------------------------------------------------------------
DECLARE_HANDLE(HFOLDERENUM);
typedef HFOLDERENUM *LPHFOLDERENUM;
const HFOLDERENUM HFOLDERENUM_INVALID = NULL;

//--------------------------------------------------------------------------
// SUBSCRIBED BOOLS
//--------------------------------------------------------------------------
#define SUBSCRIBED      TRUE
#define ALL             FALSE

//--------------------------------------------------------------------------
// CLEANUPFOLDERFLAGS
//--------------------------------------------------------------------------
typedef DWORD CLEANUPFOLDERFLAGS;
#define CLEANUP_REMOVE_READ     0x00000001
#define CLEANUP_REMOVE_EXPIRED  0x00000002
#define CLEANUP_REMOVE_ALL      0x00000004
#define CLEANUP_PROGRESS        0x00000008

//--------------------------------------------------------------------------
// CLEANUPFOLDERTYPE
//--------------------------------------------------------------------------
typedef enum tagCLEANUPFOLDERTYPE {
    CLEANUP_COMPACT,
    CLEANUP_DELETE,
    CLEANUP_RESET,
    CLEANUP_REMOVEBODIES
} CLEANUPFOLDERTYPE;

//--------------------------------------------------------------------------
// PFNRECURSECALLBACK
//--------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNRECURSECALLBACK)(LPFOLDERINFO pFolder, 
    BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie);

//--------------------------------------------------------------------------
// RECURSEFLAGS
//--------------------------------------------------------------------------
typedef DWORD RECURSEFLAGS;
#define RECURSE_INCLUDECURRENT      0x00000001
#define RECURSE_ONLYSUBSCRIBED      0x00000002
#define RECURSE_SUBFOLDERS          0x00000004
#define RECURSE_NOLOCALSTORE        0x00000008
#define RECURSE_NOUI                0x00000010
#define RECURSE_ONLYLOCAL           0x00000020
#define RECURSE_ONLYNEWS            0x00000040

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT FlattenHierarchy(IMessageStore *pStore, FOLDERID idParent, BOOL fIncludeParent,
                         BOOL fSubscribedOnly, FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                         LPDWORD pdwUsed);
HRESULT RecurseFolderHierarchy(FOLDERID idFolder, RECURSEFLAGS dwFlags, DWORD dwReserved, DWORD_PTR dwCookie,  PFNRECURSECALLBACK pfnCallback);
HRESULT RecurseFolderCounts(LPFOLDERINFO pFolder, BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie);
int     GetFolderIcon(LPFOLDERINFO pFolder, BOOL fNoStateIcons = FALSE);
int     GetFolderIcon(FOLDERID idFolder, BOOL fNoStateIcons = FALSE);
HRESULT GetFolderStoreInfo(FOLDERID idFolder, LPFOLDERINFO pStore);
HRESULT GetFolderIdFromName(IMessageStore *pStore, LPCSTR pszName, FOLDERID idParent, LPFOLDERID pidFolder);
HRESULT GetStoreRootDirectory(LPSTR pszDir, DWORD cchMaxDir);
HRESULT CreateFolderViewObject(FOLDERID idFolder, HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
HRESULT InitializeLocalStoreDirectory(HWND hwndOwner, BOOL fNoCreate);
HRESULT RelocateStoreDirectory(HWND hwnd,  LPCSTR pszDestBase, BOOL fMove);
HRESULT MigrateLocalStore(HWND hwndParent, LPTSTR pszSrc, LPTSTR pszDest);
HRESULT CreateTempNewsAccount(LPCSTR pszServer, DWORD dwPort, BOOL fSecure, IImnAccount **ppAcct);
HRESULT GetFolderIdFromNewsUrl(LPCTSTR pszServer, UINT uPort, LPCTSTR pszGroup, BOOL fSecure, LPFOLDERID pidFolder);
HRESULT OpenUidlCache(IDatabase **ppDB);
HRESULT GetMessageInfo(IDatabase *pDB, MESSAGEID idMessage, LPMESSAGEINFO pInfo);
HRESULT IsSubFolder(FOLDERID idFolder, FOLDERID idParent);
HRESULT GetDefaultServerId(ACCTTYPE tyAccount, LPFOLDERID pidServer);
HRESULT CloneMessageIDList(LPMESSAGEIDLIST pSourceList, LPMESSAGEIDLIST *ppNewList);
HRESULT CloneAdjustFlags(LPADJUSTFLAGS pFlags, LPADJUSTFLAGS *ppNewFlags);
BOOL    ConnStateIsEqual(IXPSTATUS ixpStatus, CONNECT_STATE csState);
HRESULT CompactFolders(HWND hwndParent, RECURSEFLAGS dwFlags, FOLDERID idFolder);
HRESULT CleanupFolder(HWND hwndParent, RECURSEFLAGS dwRecurse, FOLDERID idFolder, CLEANUPFOLDERTYPE tyCleanup);
HRESULT InitFolderPickerEdit(HWND hwndEdit, FOLDERID idSelected);
FOLDERID GetFolderIdFromEdit(HWND hwndEdit);
HRESULT PickFolderInEdit(HWND hwndParent, HWND hwndEdit, FOLDERDIALOGFLAGS dwFlags, LPCSTR pszTitle, LPCSTR pszText, LPFOLDERID pidSelected);
HRESULT DisplayFolderSizeInfo(HWND hwnd, RECURSEFLAGS dwRecurse, FOLDERID idFolder);
HRESULT GetFolderServerId(FOLDERID idFolder, LPFOLDERID pidServer);
HRESULT CopyMoveMessages(HWND hwnd, FOLDERID src, FOLDERID dst, LPMESSAGEIDLIST pList, COPYMESSAGEFLAGS dwFlags);
HRESULT CompareTableIndexes(LPCTABLEINDEX pIndex1, LPCTABLEINDEX pIndex2);
HRESULT EmptyFolder(HWND hwndParent, FOLDERID idFolder);
HRESULT EmptySpecialFolder(HWND hwndParent, SPECIALFOLDER tySpecial);
HRESULT IsParentDeletedItems(FOLDERID idFolder, LPFOLDERID pidDeletedItems, LPFOLDERID pidServer);
void CleanupTempNewsAccounts(void);
HRESULT CreateMessageServerType(FOLDERTYPE tyFolder, IMessageServer **ppServer);
HRESULT GetFolderAccountId(LPFOLDERINFO pFolder, LPSTR pszAccountId, DWORD cchSize);
HRESULT GetFolderAccountName(LPFOLDERINFO pFolder, LPSTR pszAccountName);
BOOL FHasChildren(LPFOLDERINFO pFolder, BOOL fSubscribed);
FOLDERTYPE GetFolderType(FOLDERID idFolder);
HRESULT GetFolderServer(FOLDERID idFolder, LPFOLDERINFO pServer);
HRESULT SetSynchronizeFlags(FOLDERID idFolder, DWORD flags);
HRESULT EmptyMessageFolder(LPFOLDERINFO pFolder, BOOL fReset, CProgress *pProgress);
HRESULT DeleteAllRecords(LPCTABLESCHEMA pSchema, IDatabase *pDB, CProgress *pProgress);
HRESULT GetFolderIdFromMsgTable(IMessageTable *pTable, LPFOLDERID pidFolder);
HRESULT GetHighestCachedMsgID(IMessageFolder *pFolder, DWORD_PTR *pdwHighestCachedMsgID);
HRESULT DeleteMessageFromStore(MESSAGEINFO * pMsgInfo, IDatabase *pDB, IDatabase *pUidlDB);
BOOL FFolderIsServer(FOLDERID id);
HRESULT LighweightOpenMessage(IDatabase *pDB, LPMESSAGEINFO pHeader, IMimeMessage **ppMessage);
HRESULT GetInboxId(IMessageStore    *pStore, FOLDERID    idParent, FOLDERID    **pprgFIDArray, LPDWORD     pdwUsed);
void GetProtocolString(LPCSTR *ppszResult, IXPTYPE ixpServerType);
HRESULT DoNewsgroupSubscribe(void);
HRESULT GetRidOfMessagesODSFile(void);
HRESULT BuildFriendlyFolderFileName(LPCSTR pszDir, LPFOLDERINFO pFolder, LPSTR pszFilePath, DWORD cchFilePathMax, LPCSTR pszCurrentFile, BOOL *pfChanged);
INT_PTR CALLBACK UpdateNewsgroup(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT HasMarkedMsgs(FOLDERID idFolder, BOOL *pfMarked);
HRESULT CreateMessageTable(FOLDERID idFolder, BOOL fThreaded, IMessageTable **ppTable);
HRESULT SimpleStoreInit(GUID *guid, LPCSTR pszStoreDir);
HRESULT SimpleStoreRelease(void);

//--------------------------------------------------------------------------
// IStoreCallback Utilities
//--------------------------------------------------------------------------
HRESULT CallbackOnLogonPrompt(HWND hwndParent, LPINETSERVER pServer, IXPTYPE ixpServerType);
HRESULT CallbackOnPrompt(HWND hwndParent, HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
HRESULT CallbackCanConnect(LPCSTR pszAccountId, HWND hwndParent, BOOL fPrompt);
HRESULT CallbackCloseTimeout(LPHTIMEOUT phTimeout);
HRESULT CallbackOnTimeout(LPINETSERVER pServer, IXPTYPE ixpServerType, DWORD dwTimeout,
                          ITimeoutCallback *pCallback, LPHTIMEOUT phTimeout);
HRESULT CallbackOnTimeoutResponse(TIMEOUTRESPONSE eResponse, IOperationCancel *pCancel, LPHTIMEOUT phTimeout);
HRESULT CallbackDisplayError(HWND hwndParent, HRESULT hrResult, LPSTOREERROR pError);

//---------------------------------------------------------------------------
// Folder hierarchy hash table helpers
//---------------------------------------------------------------------------
HRESULT CreateFolderHash(IMessageStore *pStore, FOLDERID idRoot, IHashTable **ppHash);
HRESULT UnsubscribeHashedFolders(IMessageStore *pStore, IHashTable *pHash);

//---------------------------------------------------------------------------
// Creating a MimeMessage from the cache
//---------------------------------------------------------------------------
HRESULT CreateMessageFromInfo(MESSAGEINFO *pInfo, IMimeMessage **ppMessage, FOLDERID folderID);

//---------------------------------------------------------------------------
// Adding a MimeMessage from the cache
//---------------------------------------------------------------------------
HRESULT CommitMessageToStore(IMessageFolder *pFolder, ADJUSTFLAGS *pflags, MESSAGEID idMessage, LPSTREAM pstm);

//---------------------------------------------------------------------------
// Creating a new persistent stream
//---------------------------------------------------------------------------
HRESULT CreatePersistentWriteStream(IMessageFolder *pFolder, IStream **ppStream, LPFILEADDRESS pfaStream);

//---------------------------------------------------------------------------
// Debugging helpers
//---------------------------------------------------------------------------
#ifdef DEBUG
LPCSTR sotToSz(STOREOPERATIONTYPE sot);
#endif

#endif // __STORUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\store\sync.h ===
#ifndef _INC_SYNC_H
#define _INC_SYNC_H

#include <syncop.h>

class COfflineSync : public IUnknown
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COfflineSync(void);
    ~COfflineSync(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT Initialize(void);
    HRESULT SetMessageFlags(IMessageFolder *pFolder, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags);
    HRESULT CreateMessage(IMessageFolder *pFolder, LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage);
    HRESULT DeleteMessages(IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList);
    HRESULT CopyMessages(IMessageFolder *pFolder, IMessageFolder *pFolderDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags);

    HRESULT DoPlayback(HWND hwnd, FOLDERID *pId, DWORD cId, FOLDERID idFolderSel);

    HRESULT GetRecordCount(LPDWORD pcRecords) {
        *pcRecords = 0;
        if (m_pDB)
            return(m_pDB->GetRecordCount(IINDEX_PRIMARY, pcRecords));
        return(TraceResult(E_FAIL));
    }

private:
    HRESULT _FindExistingOperation(FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage, DWORD typeSrc, DWORD typeDest, LPSYNCOPINFO pInfo);
    HRESULT _PlaybackServer(HWND hwnd, FOLDERID idServer);
    HRESULT _SetMessageFlags(IMessageFolder *pFolder, FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage, MESSAGEFLAGS dwFlags, LPADJUSTFLAGS pFlags);

    LONG            m_cRef;
    IDatabase      *m_pDB;
};

extern COfflineSync *g_pSync;

#endif // _INC_SYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\exchrep\defguid.h ===
DEFINE_GUID (IID_ExchRep, 0x4abdeb80, 0x98ef, 0x11cf, 0xab, 0x21, 0x00, 0xaa, 0x00, 0xb5, 0x10, 0x52);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\exchrep\exchole.cpp ===
#define INITGUID
#define USES_IID_IMessage
#define USES_IID_IExchExt
#define USES_IID_IExchExtSessionEvents

#include <ole2.h>
#include <initguid.h>
#include <MAPIX.H>
#include <MAPIUTIL.H>
#include <MAPIFORM.H>
#include <MAPIGUID.H>
#include <EXCHEXT.H>
#include "DEFGUID.H"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\exchrep\mapiconv.cpp ===
// =====================================================================================
// m a p c o n v . c p p
// conver a MAPI message to and from an RFC 822/RFC 1521 (mime) internet message
// =====================================================================================
#include "pch.hxx"
#include "Imnapi.h"
#include "Exchrep.h"
#include "Mapiconv.h"
#include "Error.h"

HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb);

// =====================================================================================
// MAPI Message Properties that I want
// =====================================================================================
enum 
{ 
    colSenderAddrType,
    colSenderName,
    colSenderEMail,
    colSubject, 
    colDeliverTime,
    colBody,
    colPriority,
    colLast1
};

SizedSPropTagArray (colLast1, sptMessageProps) = 
{ 
	colLast1, 
	{
        PR_SENDER_ADDRTYPE,
        PR_SENDER_NAME,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SUBJECT,
        PR_MESSAGE_DELIVERY_TIME,
        PR_BODY,
        PR_PRIORITY
    }
};

// =====================================================================================
// MAPI Recip Props
// =====================================================================================
enum 
{ 
    colRecipAddrType,
    colRecipName,
    colRecipAddress,
    colRecipType,
    colLast2
};

SizedSPropTagArray (colLast2, sptRecipProps) = 
{ 
	colLast2, 
	{
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_RECIPIENT_TYPE
    }
};

// =====================================================================================
// MAPI Attachment Props
// =====================================================================================
enum 
{ 
    colAttMethod,
    colAttNum,
    colAttLongFilename,
    colAttLongPathname,
    colAttPathname,
    colAttTag,
    colAttFilename,
    colAttExtension,
    colAttSize,
    colLast3
};

SizedSPropTagArray (colLast3, sptAttProps) = 
{ 
	colLast3, 
	{
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM,
        PR_ATTACH_LONG_FILENAME,
        PR_ATTACH_LONG_PATHNAME,
        PR_ATTACH_PATHNAME,
        PR_ATTACH_TAG,
        PR_ATTACH_FILENAME,
        PR_ATTACH_EXTENSION,
        PR_ATTACH_SIZE
    }
};

// =============================================================================================
// StringDup - duplicates a string
// =============================================================================================
LPTSTR StringDup (LPCTSTR lpcsz)
{
    // Locals
    LPTSTR       lpszDup;

    if (lpcsz == NULL)
        return NULL;

    INT nLen = lstrlen (lpcsz) + 1;

    lpszDup = (LPTSTR)malloc (nLen * sizeof (TCHAR));

    if (lpszDup)
        CopyMemory (lpszDup, lpcsz, nLen);

    return lpszDup;
}

// =====================================================================================
// HrMapiToImsg
// =====================================================================================
HRESULT HrMapiToImsg (LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    // Locals
    HRESULT         hr = S_OK;
    ULONG           cProp, i;
	LPSPropValue	lpMsgPropValue = NULL;
    LPSRowSet       lpRecipRows = NULL, lpAttRows = NULL;
    LPMAPITABLE     lptblRecip = NULL, lptblAtt = NULL;
    LPATTACH        lpAttach = NULL;
    LPMESSAGE       lpMsgAtt = NULL;
    LPSTREAM        lpstmRtfComp = NULL, lpstmRtf = NULL;

    // Zero init
    ZeroMemory (lpImsg, sizeof (IMSG));

    // Get the propsw
    hr = lpMessage->GetProps ((LPSPropTagArray)&sptMessageProps, 0, &cProp, &lpMsgPropValue);
    if (FAILED (hr))
        goto exit;

    // Subject
    if (PROP_TYPE(lpMsgPropValue[colSubject].ulPropTag) != PT_ERROR)
        lpImsg->lpszSubject = StringDup (lpMsgPropValue[colSubject].Value.lpszA);

    // Body
    if (PROP_TYPE(lpMsgPropValue[colBody].ulPropTag) != PT_ERROR)
        lpImsg->lpszBody = StringDup (lpMsgPropValue[colBody].Value.lpszA);

    // RTF
    if (!FAILED (lpMessage->OpenProperty (PR_RTF_COMPRESSED, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpstmRtfComp)))
        if (!FAILED (WrapCompressedRTFStream (lpstmRtfComp, 0, &lpstmRtf)))
            if (!FAILED (CreateStreamOnHFile (NULL, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpstmRtf)))
                HrCopyStream (lpstmRtf, lpImsg->lpstmRtf, NULL);

    // Delivery Time
    if (PROP_TYPE(lpMsgPropValue[colDeliverTime].ulPropTag) != PT_ERROR)
        CopyMemory (&lpImsg->ftDelivery, &lpMsgPropValue[colDeliverTime].Value.ft, sizeof (FILETIME));

    // Priority
    lpImsg->wPriority = PRI_NORMAL;
    if (PROP_TYPE(lpMsgPropValue[colPriority].ulPropTag) != PT_ERROR)
    {
        switch (lpMsgPropValue[colPriority].Value.l)
        {
        case PRIO_NORMAL:
            lpImsg->wPriority = PRI_NORMAL;
            break;

        case PRIO_URGENT:
            lpImsg->wPriority = PRI_HIGH;
            break;

        case PRIO_NONURGENT:
        default:
            lpImsg->wPriority = PRI_LOW;
            break;
        }
    }

    // Get the recipient table
    hr = lpMessage->GetRecipientTable (0, &lptblRecip);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = HrQueryAllRows (lptblRecip, (LPSPropTagArray)&sptRecipProps, NULL, NULL, 0, &lpRecipRows);
    if (FAILED (hr))
        goto exit;

    // Allocate Recipient Array
    lpImsg->cAddress = lpRecipRows->cRows + 1;
    lpImsg->lpIaddr =  (LPIADDRINFO)malloc (sizeof (IADDRINFO) * lpImsg->cAddress);
    if (lpImsg->lpIaddr == NULL)
        goto exit;

    // Originator of the message "From: "
    lpImsg->lpIaddr[0].dwType = IADDR_FROM;

    if (PROP_TYPE(lpMsgPropValue[colSenderName].ulPropTag) != PT_ERROR)
    {
        lpImsg->lpIaddr[0].lpszDisplay = StringDup (lpMsgPropValue[colSenderName].Value.lpszA);
        lpImsg->lpIaddr[0].lpszAddress = StringDup (lpMsgPropValue[colSenderName].Value.lpszA);
    }
    
    if (PROP_TYPE(lpMsgPropValue[colSenderEMail].ulPropTag) != PT_ERROR &&
        PROP_TYPE(lpMsgPropValue[colSenderAddrType].ulPropTag) != PT_ERROR &&
        lstrcmpi (lpMsgPropValue[colSenderAddrType].Value.lpszA, "SMTP") == 0)
    {
        lpImsg->lpIaddr[0].lpszAddress = StringDup (lpMsgPropValue[colSenderEMail].Value.lpszA);
    }

    // Add in the rest of the recipients
	for (i=0; i<lpRecipRows->cRows; i++)
	{	
        assert (i+1 < lpImsg->cAddress);

        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipType].ulPropTag) != PT_ERROR)
        {
            switch (lpRecipRows->aRow[i].lpProps[colRecipType].Value.ul)
            {
            case MAPI_TO:
                lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                break;

            case MAPI_ORIG:
                lpImsg->lpIaddr[i+1].dwType = IADDR_FROM;
                break;

            case MAPI_CC:
                lpImsg->lpIaddr[i+1].dwType = IADDR_CC;
                break;

            case MAPI_BCC:
                lpImsg->lpIaddr[i+1].dwType = IADDR_BCC;
                break;

            default:
                Assert (FALSE);
                lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                break;
            }
        }
        else
            lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
        
        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipName].ulPropTag) != PT_ERROR)
        {
            lpImsg->lpIaddr[i+1].lpszDisplay = StringDup (lpRecipRows->aRow[i].lpProps[colRecipName].Value.lpszA); 
            lpImsg->lpIaddr[i+1].lpszAddress = StringDup (lpRecipRows->aRow[i].lpProps[colRecipName].Value.lpszA); 
        }
    
        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipName].ulPropTag) != PT_ERROR &&
            PROP_TYPE(lpMsgPropValue[colRecipAddrType].ulPropTag) != PT_ERROR &&
            lstrcmpi (lpMsgPropValue[colRecipAddrType].Value.lpszA, "SMTP") == 0)
        {
            lpImsg->lpIaddr[i+1].lpszAddress = StringDup (lpRecipRows->aRow[i].lpProps[colRecipAddress].Value.lpszA);
        }
	}

    // Free Rows
    if (lpRecipRows)
        FreeProws (lpRecipRows);
    lpRecipRows = NULL;

    // Attachments
    hr = lpMessage->GetAttachmentTable (0, &lptblAtt);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = HrQueryAllRows (lptblAtt, (LPSPropTagArray)&sptAttProps, NULL, NULL, 0, &lpAttRows);
    if (FAILED (hr))
        goto exit;

    // Allocate files list
    if (lpAttRows->cRows == 0)
        goto exit;

    // Allocate memory
    lpImsg->cAttach = lpAttRows->cRows;
    lpImsg->lpIatt = (LPIATTINFO)malloc (sizeof (IATTINFO) * lpImsg->cAttach);
    if (lpImsg->lpIatt == NULL)
        goto exit;

    // Zero init
    ZeroMemory (lpImsg->lpIatt, sizeof (IATTINFO) * lpImsg->cAttach);

    // Walk the rows
	for (i=0; i<lpAttRows->cRows; i++)
	{	
        if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttMethod].ulPropTag) != PT_ERROR &&
            PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttNum].ulPropTag) != PT_ERROR)
        {
            // Basic Properties
            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttPathname].ulPropTag) != PT_ERROR)
                lpImsg->lpIatt[i].lpszPathName = StringDup (lpAttRows->aRow[i].lpProps[colAttPathname].Value.lpszA);      

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttFilename].ulPropTag) != PT_ERROR)
                lpImsg->lpIatt[i].lpszFileName = StringDup (lpAttRows->aRow[i].lpProps[colAttFilename].Value.lpszA);      

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttExtension].ulPropTag) != PT_ERROR)
                lpImsg->lpIatt[i].lpszExt = StringDup (lpAttRows->aRow[i].lpProps[colAttExtension].Value.lpszA);     

            // Open the attachment
            hr = lpMessage->OpenAttach (lpAttRows->aRow[i].lpProps[colAttNum].Value.l, NULL, MAPI_BEST_ACCESS, &lpAttach);
            if (FAILED (hr))
            {
                lpImsg->lpIatt[i].fError = TRUE;
                continue;
            }

            // Handle the attachment method
            switch (lpAttRows->aRow[i].lpProps[colAttMethod].Value.ul)
            {
            case NO_ATTACHMENT:
                lpImsg->lpIatt[i].dwType = 0;
                lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_RESOLVE:
            case ATTACH_BY_VALUE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_BIN, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_ONLY:
            case ATTACH_BY_REFERENCE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = CreateStreamOnHFile (lpImsg->lpIatt[i].lpszPathName, GENERIC_READ,  FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_EMBEDDED_MSG:
                lpImsg->lpIatt[i].dwType = IATT_MSG;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_OBJ, (LPIID)&IID_IMessage, 0, 0, (LPUNKNOWN *)&lpMsgAtt);
                if (FAILED (hr) || lpMsgAtt == NULL)
                    lpImsg->lpIatt[i].fError = TRUE;
                else
                {
                    lpImsg->lpIatt[i].lpImsg = (LPIMSG)malloc (sizeof (IMSG));
                    if (lpImsg->lpIatt[i].lpImsg == NULL)
                        lpImsg->lpIatt[i].fError = TRUE;
                    else
                    {
                        hr = HrMapiToImsg (lpMsgAtt, lpImsg->lpIatt[i].lpImsg);
                        if (FAILED (hr))
                            lpImsg->lpIatt[i].fError = TRUE;
                    }    
                    lpMsgAtt->Release ();
                    lpMsgAtt = NULL;
                }
                break;

            case ATTACH_OLE:
            default:
                lpImsg->lpIatt[i].dwType = IATT_OLE;
                lpImsg->lpIatt[i].fError = TRUE;
                break;
            }

            // Free Attachment
            if (lpAttach)
                lpAttach->Release ();
            lpAttach = NULL;
        }
    }

exit:
    // Cleanup
    if (lpAttach)
        lpAttach->Release ();
    if (lptblAtt)
        lptblAtt->Release ();
    if (lpAttRows)
        FreeProws (lpAttRows);
    if (lpRecipRows)
        FreeProws (lpRecipRows);
    if (lpMsgPropValue)
        MAPIFreeBuffer (lpMsgPropValue);
    if (lptblRecip)
        lptblRecip->Release ();
    if (lpMsgAtt)
        lpMsgAtt->Release ();
    if (lpstmRtfComp)
        lpstmRtfComp->Release ();
    if (lpstmRtf)
        lpstmRtf->Release ();

    // Done
    return hr;
}


void AssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    static const char rgch1[]     = "File %s, line %d:";
    static const char rgch2[]     = "Unknown file:";
    static const char szAssert[]  = "Assert Failure";

    char    rgch[512];
    char   *lpsz;
    int     ret, cch;

    if (szFile)
        wnsprintf(rgch, ARRAYSIZE(rgch),rgch1, szFile, nLine);
    else
        StrCpyN(rgch, rgch2,ARRAYSIZE(rgch));

    cch = lstrlen(rgch);
    Assert(lstrlen(szMsg)<(512-cch-3));
    lpsz = &rgch[cch];
    *lpsz++ = '\n';
    *lpsz++ = '\n';
    StrCpyN(lpsz, szMsg, (ARRAYSIZE(rgch)-cch-2));

    ret = MessageBox(GetActiveWindow(), rgch, szAssert, MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND);

    if (ret != IDIGNORE)
        DebugBreak();

    /* Force a hard exit w/ a GP-fault so that Dr. Watson generates a nice stack trace log. */
    if (ret == IDABORT)
        *(LPBYTE)0 = 1; // write to address 0 causes GP-fault
}

// =====================================================================================
// HrCopyStream - caller must do the commit
// =====================================================================================
HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead = 0, cbTotal = 0;

    do
    {
        hr = lpstmIn->Read (buf, sizeof (buf), &cbRead);
        if (FAILED (hr))
            goto exit;

        if (cbRead == 0) break;
        
        hr = lpstmOut->Write (buf, cbRead, NULL);
        if (FAILED (hr))
            goto exit;

        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:    
    if (pcb)
        *pcb = cbTotal;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\exchrep\mapiconv.h ===
// =====================================================================================
// MAPI IMessage to IMN message
// =====================================================================================
#ifndef __MAPICONV_H
#define __MAPICONV_H

#ifdef DEBUG
void AssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine);
#endif

HRESULT HrMapiToImsg (LPMESSAGE lpMessage, LPIMSG lpImsg);

#endif // __MAPICONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\exchrep\exchrep.h ===
// =====================================================================================
// Exchange Rep Header
// =====================================================================================
#ifndef __EXCHREP_H
#define __EXCHREP_H

// =====================================================================================
// Required Headers
// =====================================================================================
#include "MAPI.H"
#include "MAPIX.H"
#include "MAPIUTIL.H"
#include "MAPIFORM.H"
#include "EXCHEXT.H"
#include "ASSERT.H"

// =====================================================================================
// Globals
// =====================================================================================
extern HINSTANCE g_hInst;

// =====================================================================================
// IMNAPI typedefs
// =====================================================================================
typedef HRESULT (STDAPICALLTYPE *PFNHRIMNROUTEMESSAGE)(LPIADDRINFO lpIaddrRoute, ULONG cAddrRoute, LPIMSG lpImsg);
typedef HRESULT (STDAPICALLTYPE *PFNMAILNEWSDLLINIT)(BOOL fInit);

// =====================================================================================
// C Interface Call Back from Exchange
// =====================================================================================
extern "C"
{
    LPEXCHEXT CALLBACK ExchEntryPoint(void);
}

// =====================================================================================
// Main Extension Interface Class
// =====================================================================================
class CExchRep : public IExchExt, IExchExtSessionEvents
{
private:
	ULONG				 m_uRef;
    LPMAPISESSION        m_lpSession;
    HWND                 m_hwnd;
    TCHAR                m_szDisplayTo[255];
    TCHAR                m_szAddressTo[255];
    TCHAR                m_szMailNewsPath[MAX_PATH];
    HINSTANCE            m_hMailNews;
    PFNHRIMNROUTEMESSAGE m_lpfnHrImnRouteMessage;
    PFNMAILNEWSDLLINIT   m_lpfnMailNewsDllInit;
    
public:
	// =====================================================================================
	// Construct
	// =====================================================================================
	CExchRep ();
	~CExchRep ();

	// =====================================================================================
	// punk stuff
	// =====================================================================================
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID *ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	// =====================================================================================
	// IExchExt
	// =====================================================================================
	STDMETHODIMP Install (LPEXCHEXTCALLBACK lpExchCallback, ULONG mecontext, ULONG ulFlags);

	// =====================================================================================
	// IExchExtSessionEvents
	// =====================================================================================
    STDMETHODIMP OnDelivery (LPEXCHEXTCALLBACK lpExchCallback);	

	// =====================================================================================
	// My Functions
	// =====================================================================================
    VOID LoadConfig (VOID);
};

#endif __EXCHREP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\imntnef\imntnef.cpp ===
// ==============================================================================
// I M N T N E F . C P P
// ==============================================================================
#define INITGUID
#define USES_IID_IMessage
#define USES_IID_IMAPIPropData

#include <windows.h>
#include <assert.h>
#include <ole2.h>
#include <initguid.h>
#include <mapiguid.h>
#include <mapi.h>
#include <mapix.h>
#include <mapiutil.h>
#include <tnef.h>

// =====================================================================================
// G L O B A L S
// =====================================================================================
HINSTANCE       g_hInst = NULL;
LPMAPISESSION   g_lpSession = NULL;
LPADRBOOK       g_lpAdrBook = NULL;

// =====================================================================================
// S T R U C T U R E S
// =====================================================================================
class CImnMsg : public IMessage
{
private:
    ULONG               m_cRef;
    LPPROPDATA          m_lpPropData;

public:
    // =====================================================================================
	// Creation
	// =====================================================================================
    CImnMsg ();
    ~CImnMsg ();

    // =====================================================================================
	// IUnknown
	// =====================================================================================
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID *ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

    // =====================================================================================
	// IMAPIProp
	// =====================================================================================
    STDMETHODIMP CopyProps (LPSPropTagArray lpIncludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems);
    STDMETHODIMP CopyTo (ULONG ciidExclude, LPCIID rgiidExclude, LPSPropTagArray lpExcludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems);
    STDMETHODIMP DeleteProps (LPSPropTagArray lpPropTagArray, LPSPropProblemArray FAR * lppProblems);
    STDMETHODIMP GetIDsFromNames (ULONG cPropNames, LPMAPINAMEID FAR * lppPropNames, ULONG ulFlags, LPSPropTagArray FAR * lppPropTags);
    STDMETHODIMP GetLastError (HRESULT hResult, ULONG ulFlags, LPMAPIERROR FAR * lppMAPIError);
    STDMETHODIMP GetNamesFromIDs (LPSPropTagArray FAR * lppPropTags, LPGUID lpPropSetGuid, ULONG ulFlags, ULONG FAR * lpcPropNames, LPMAPINAMEID FAR * FAR * lpppPropNames);
    STDMETHODIMP GetPropList (ULONG ulFlags, LPSPropTagArray FAR * lppPropTagArray);
    STDMETHODIMP GetProps (LPSPropTagArray lpPropTagArray, ULONG ulFlags, ULONG FAR * lpcValues, LPSPropValue FAR * lppPropArray);
    STDMETHODIMP OpenProperty (ULONG ulPropTag, LPCIID lpiid, ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN FAR * lppUnk);
    STDMETHODIMP SaveChanges (ULONG ulFlags);
    STDMETHODIMP SetProps (ULONG cValues, LPSPropValue lpPropArray, LPSPropProblemArray FAR * lppProblems);

    // =====================================================================================
	// IMessage
	// =====================================================================================
    STDMETHODIMP CreateAttach (LPCIID lpInterface, ULONG ulFlags, ULONG FAR * lpulAttachmentNum, LPATTACH FAR * lppAttach);
    STDMETHODIMP DeleteAttach (ULONG ulAttachmentNum, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags);
    STDMETHODIMP GetAttachmentTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable);	
    STDMETHODIMP GetRecipientTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable);
    STDMETHODIMP ModifyRecipients (ULONG ulFlags, LPADRLIST lpMods);
    STDMETHODIMP OpenAttach (ULONG ulAttachmentNum, LPCIID lpInterface, ULONG ulFlags, LPATTACH FAR * lppAttach);
    STDMETHODIMP SetReadFlag (ULONG ulFlags);
    STDMETHODIMP SubmitMessage (ULONG ulFlags);
};

// =====================================================================================
// P R O T O T Y P E S
// =====================================================================================
HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb);
HRESULT HrRewindStream (LPSTREAM lpstm);

// =====================================================================================
// D l l M a i n
// =====================================================================================
int APIENTRY DllMain (HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInstance;
        return 1;

    case DLL_PROCESS_DETACH:
        return 1;
    }

    // Done
	return 0;
}

// =====================================================================================
// H r I n i t
// =====================================================================================
HRESULT HrInit (BOOL fInit)
{
    // Locals
    HRESULT         hr = S_OK;

    // If initing
    if (fInit)
    {
        // iNIT
        hr = MAPIInitialize (NULL);
        if (FAILED (hr))
            goto exit;

        // Logon to mapi
        if (g_lpSession == NULL)
        {
            hr = MAPILogonEx (0, NULL, NULL, MAPI_NO_MAIL | MAPI_USE_DEFAULT, &g_lpSession);
            if (FAILED (hr))
            {
                if (g_lpSession)
                {
                    g_lpSession->Release ();
                    g_lpSession = NULL;
                }
                goto exit;
            }
        }

        // Get an address book object
        if (g_lpAdrBook == NULL)
        {
            hr = g_lpSession->OpenAddressBook (0, NULL, AB_NO_DIALOG, &g_lpAdrBook);
            if (FAILED (hr))
            {
                if (g_lpAdrBook)
                {
                    g_lpAdrBook->Release ();
                    g_lpAdrBook = NULL;
                }
                goto exit;
            }
        }
    }

    else
    {
        // Release Address Book
        if (g_lpAdrBook)
        {
            g_lpAdrBook->Release ();
            g_lpAdrBook = NULL;
        }

        // Log off session
        if (g_lpSession)
        {
            g_lpSession->Logoff (0, 0, 0);
            g_lpSession->Release ();
            g_lpSession = NULL;
        }

        // MAPI de-init
        MAPIUninitialize ();
    }

exit:
    // Done
    return hr;
}

// =====================================================================================
// HrGetTnefRtfStream
// =====================================================================================
HRESULT HrGetTnefRtfStream (LPSTREAM lpstmTnef, LPSTREAM lpstmRtf)
{
    // Locals
    HRESULT             hr = S_OK;
    SYSTEMTIME          st;
    WORD                wKey;
    LPITNEF             lpTnef = NULL;
    LPSTREAM            lpstmRtfComp = NULL, lpstmRtfUncomp = NULL;
    CImnMsg            *lpImnMsg = NULL;
    ULONG               cValues;
    LPSPropValue        lpPropValue = NULL;

    SizedSPropTagArray (1, spa) = {1, { PR_RTF_COMPRESSED } };

    // Bad init
    if (!g_lpSession || !g_lpAdrBook || !lpstmTnef || !lpstmRtf)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Bullet style uniquification for wKey
    GetSystemTime (&st);
    wKey = (st.wHour << 8) + st.wSecond;

    // Create one of my message objects
    lpImnMsg = new CImnMsg;
    if (lpImnMsg == NULL)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Initiates a TNEF session
    hr = OpenTnefStreamEx (NULL, lpstmTnef, "WINMAIL.DAT", TNEF_DECODE,
                           (LPMESSAGE)lpImnMsg, wKey, g_lpAdrBook, &lpTnef);
    if (FAILED (hr))
        goto exit;

    // ExtractProps
    hr = lpTnef->ExtractProps (TNEF_PROP_INCLUDE, (SPropTagArray *)&spa, NULL);
    if (FAILED (hr))
        goto exit;

    // RTF stream
    hr = lpImnMsg->GetProps ((SPropTagArray *)&spa, 0, &cValues, &lpPropValue);
    if (FAILED (hr))
        goto exit;

    // Property not found ?
    if (PROP_TYPE (lpPropValue[0].ulPropTag) == PT_ERROR)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Create Hglobal
    hr = CreateStreamOnHGlobal (NULL, TRUE, &lpstmRtfComp);
    if (FAILED (hr))
        goto exit;

    // Write my binary into lpstmRtfComp
    hr = lpstmRtfComp->Write (lpPropValue[0].Value.bin.lpb, lpPropValue[0].Value.bin.cb, NULL);
    if (FAILED (hr))
        goto exit;

    // Commit and rewind the stream
    hr = lpstmRtfComp->Commit (STGC_DEFAULT);
    if (FAILED (hr))
        goto exit;

    // Rewind
    hr = HrRewindStream (lpstmRtfComp);
    if (FAILED (hr))
        goto exit;

    // un compress it
    hr = WrapCompressedRTFStream (lpstmRtfComp, 0, &lpstmRtfUncomp);
    if (FAILED (hr))
        goto exit;

    // Copy strem
    hr = HrCopyStream (lpstmRtfUncomp, lpstmRtf, NULL);
    if (FAILED (hr))
        goto exit;

    // Rewind lpstmRtf
    hr = HrRewindStream (lpstmRtf);
    if (FAILED (hr))
        goto exit;

exit:
    // Cleanup
    if (lpPropValue)
        MAPIFreeBuffer (lpPropValue);
    if (lpTnef)
        lpTnef->Release ();
    if (lpstmRtfComp)
        lpstmRtfComp->Release ();
    if (lpstmRtfUncomp)
        lpstmRtfUncomp->Release ();
    if (lpImnMsg)
        lpImnMsg->Release ();

    // Done
    return hr;
}

// =====================================================================================
// HrCopyStream - caller must do the commit
// =====================================================================================
HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead = 0, cbTotal = 0;

    do
    {
        hr = lpstmIn->Read (buf, sizeof (buf), &cbRead);
        if (FAILED (hr))
            goto exit;

        if (cbRead == 0) break;
        
        hr = lpstmOut->Write (buf, cbRead, NULL);
        if (FAILED (hr))
            goto exit;

        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:    
    if (pcb)
        *pcb = cbTotal;
    return hr;
}

// =====================================================================================
// HrRewindStream
// =====================================================================================
HRESULT HrRewindStream (LPSTREAM lpstm)
{
    LARGE_INTEGER  liOrigin = {0,0};
    return lpstm->Seek (liOrigin, STREAM_SEEK_SET, NULL);
}

// =====================================================================================
// CImnMsg::~CImnMsg
// =====================================================================================
CImnMsg::CImnMsg ()
{
    m_cRef = 1;
    CreateIProp (&IID_IMAPIPropData, (ALLOCATEBUFFER *)MAPIAllocateBuffer,
                 (ALLOCATEMORE *)MAPIAllocateMore, (FREEBUFFER *)MAPIFreeBuffer, 
                 NULL, &m_lpPropData);
    assert (m_lpPropData);
}

// =====================================================================================
// CImnMsg::~CImnMsg
// =====================================================================================
CImnMsg::~CImnMsg ()
{
    if (m_lpPropData)
        m_lpPropData->Release ();
}

// =====================================================================================
// Add Ref
// =====================================================================================
STDMETHODIMP_(ULONG) CImnMsg::AddRef () 
{												  	
	++m_cRef; 								  
	return m_cRef; 						  
}

// =====================================================================================
// Release 
// =====================================================================================
STDMETHODIMP_(ULONG) CImnMsg::Release () 
{ 
    ULONG uCount = --m_cRef;
    if (!uCount) 
        delete this; 
   return uCount;
}

// =====================================================================================
// CImnMsg::QueryInterface
// =====================================================================================
STDMETHODIMP CImnMsg::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	// Locals
    HRESULT hr = S_OK;

    // Init
    *ppvObj = NULL;

    // IUnknown or IExchExt interface, this is it dude
    if (IID_IUnknown == riid)
    {
		*ppvObj = (LPUNKNOWN)(IUnknown *)this;
    }
   
	// IID_IMessage
	else if (IID_IMessage == riid) 
	{
		*ppvObj = (LPUNKNOWN)(IMessage *)this;
    }
 
	// IID_IMAPIProp
	else if (IID_IMAPIPropData == riid) 
	{
        assert (m_lpPropData);
		*ppvObj = (LPUNKNOWN)(IMAPIProp *)m_lpPropData;
    }

    // Else, interface is not supported
	else 
        hr = E_NOINTERFACE;

    // Increment Reference Count
	if (NULL != *ppvObj) 
        ((LPUNKNOWN)*ppvObj)->AddRef();

	// Done
    return hr;
}

// =====================================================================================
// CImnMsg::CopyProps
// =====================================================================================
STDMETHODIMP CImnMsg::CopyProps (LPSPropTagArray lpIncludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->CopyProps (lpIncludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
}

// =====================================================================================
// CImnMsg::CopyTo
// =====================================================================================
STDMETHODIMP CImnMsg::CopyTo (ULONG ciidExclude, LPCIID rgiidExclude, LPSPropTagArray lpExcludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->CopyTo (ciidExclude, rgiidExclude, lpExcludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
}

// =====================================================================================
// CImnMsg::DeleteProps
// =====================================================================================
STDMETHODIMP CImnMsg::DeleteProps (LPSPropTagArray lpPropTagArray, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->DeleteProps (lpPropTagArray, lppProblems);
}

// =====================================================================================
// CImnMsg::GetIDsFromNames
// =====================================================================================
STDMETHODIMP CImnMsg::GetIDsFromNames (ULONG cPropNames, LPMAPINAMEID FAR * lppPropNames, ULONG ulFlags, LPSPropTagArray FAR * lppPropTags)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetIDsFromNames (cPropNames, lppPropNames, ulFlags, lppPropTags);
}

// =====================================================================================
// CImnMsg::GetLastError
// =====================================================================================
STDMETHODIMP CImnMsg::GetLastError (HRESULT hResult, ULONG ulFlags, LPMAPIERROR FAR * lppMAPIError)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetLastError (hResult, ulFlags, lppMAPIError);
}

// =====================================================================================
// CImnMsg::GetNamesFromIDs
// =====================================================================================
STDMETHODIMP CImnMsg::GetNamesFromIDs (LPSPropTagArray FAR * lppPropTags, LPGUID lpPropSetGuid, ULONG ulFlags, ULONG FAR * lpcPropNames, LPMAPINAMEID FAR * FAR * lpppPropNames)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetNamesFromIDs (lppPropTags, lpPropSetGuid, ulFlags, lpcPropNames, lpppPropNames);
}

// =====================================================================================
// CImnMsg::GetPropList
// =====================================================================================
STDMETHODIMP CImnMsg::GetPropList (ULONG ulFlags, LPSPropTagArray FAR * lppPropTagArray)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetPropList (ulFlags, lppPropTagArray);
}

// =====================================================================================
// CImnMsg::GetProps
// =====================================================================================
STDMETHODIMP CImnMsg::GetProps (LPSPropTagArray lpPropTagArray, ULONG ulFlags, ULONG FAR * lpcValues, LPSPropValue FAR * lppPropArray)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetProps (lpPropTagArray, ulFlags, lpcValues, lppPropArray);
}

// =====================================================================================
// CImnMsg::OpenProperty
// =====================================================================================
STDMETHODIMP CImnMsg::OpenProperty (ULONG ulPropTag, LPCIID lpiid, ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN FAR * lppUnk)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->OpenProperty (ulPropTag, lpiid, ulInterfaceOptions, ulFlags, lppUnk);
}

// =====================================================================================
// CImnMsg::SaveChanges
// =====================================================================================
STDMETHODIMP CImnMsg::SaveChanges (ULONG ulFlags)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->SaveChanges (ulFlags);
}

// =====================================================================================
// CImnMsg::SetProps
// =====================================================================================
STDMETHODIMP CImnMsg::SetProps (ULONG cValues, LPSPropValue lpPropArray, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->SetProps (cValues, lpPropArray, lppProblems);
}

// =====================================================================================
// CImnMsg::CreateAttach
// =====================================================================================
STDMETHODIMP CImnMsg::CreateAttach (LPCIID lpInterface, ULONG ulFlags, ULONG FAR * lpulAttachmentNum, LPATTACH FAR * lppAttach)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::DeleteAttach
// =====================================================================================
STDMETHODIMP CImnMsg::DeleteAttach (ULONG ulAttachmentNum, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::GetAttachmentTable
// =====================================================================================
STDMETHODIMP CImnMsg::GetAttachmentTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::GetRecipientTable
// =====================================================================================
STDMETHODIMP CImnMsg::GetRecipientTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::ModifyRecipients
// =====================================================================================
STDMETHODIMP CImnMsg::ModifyRecipients (ULONG ulFlags, LPADRLIST lpMods)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::OpenAttach
// =====================================================================================
STDMETHODIMP CImnMsg::OpenAttach (ULONG ulAttachmentNum, LPCIID lpInterface, ULONG ulFlags, LPATTACH FAR * lppAttach)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::SetReadFlag
// =====================================================================================
STDMETHODIMP CImnMsg::SetReadFlag (ULONG ulFlags)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::SubmitMessage
// =====================================================================================
STDMETHODIMP CImnMsg::SubmitMessage (ULONG ulFlags)
{
    assert (FALSE);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\exchrep\exchrep.cpp ===
// =====================================================================================
// Exchange Plus ! Main
// =====================================================================================
#include "pch.hxx"
#include "Imnapi.h"
#include "Exchrep.h"
#include "mapiconv.h"

// =====================================================================================
// Defines
// =====================================================================================
#define REGPATH             "Software\\Microsoft\\Exchange Internet Mail Router"
#define MAILNEWS_PATH       "MailNews Path"
#define ROUTE_TO_DISPLAY    "Route To Display"
#define ROUTE_TO_ADDRESS    "Route To Address"

#define ROUTER_DISPLAY      "Microsoft Exchange Internet Mail Router"
#define ROUTER_ADDRESS      "exchrep"

// =====================================================================================
// Globals
// =====================================================================================
HINSTANCE   g_hInst;

// =====================================================================================
// Prototypes
// =====================================================================================
VOID FreeImsg (LPIMSG lpImsg);

// =====================================================================================
// Dll entry point
// =====================================================================================
int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
    case DLL_PROCESS_ATTACH:
	    g_hInst = hInstance;
	    return 1;

	case DLL_PROCESS_DETACH:
        return 1;
   }

	// Not Handled
	return 0;
}

// =====================================================================================
// Exchange Interface entry point
// =====================================================================================
LPEXCHEXT CALLBACK ExchEntryPoint(void)
{
	// Create and return Exchange Interface Object
	return (IExchExt *)new CExchRep;
}

// =====================================================================================
// Inst my exchange interface object
// =====================================================================================
CExchRep::CExchRep () 
{ 
    m_uRef = 1; 
    m_lpSession = NULL;
    m_hwnd = NULL;
    m_hMailNews = NULL;
    m_lpfnHrImnRouteMessage = NULL;
    m_lpfnMailNewsDllInit = NULL;
}

// =====================================================================================
// Inst my exchange interface object
// =====================================================================================
CExchRep::~CExchRep () 
{ 
    if (m_lpSession)
        m_lpSession->Release ();
    if (m_hMailNews)
    {
        if (m_lpfnMailNewsDllInit)
            (*m_lpfnMailNewsDllInit)(FALSE);
        FreeLibrary (m_hMailNews);
    }
}

// =====================================================================================
// Add Ref
// =====================================================================================
STDMETHODIMP_(ULONG) CExchRep::AddRef () 
{												  	
	++m_uRef; 								  
	return m_uRef; 						  
}

// =====================================================================================
// Release 
// =====================================================================================
STDMETHODIMP_(ULONG) CExchRep::Release () 
{ 
    ULONG uCount = --m_uRef;
    if (!uCount) 
        delete this; 
   return uCount;
}

// =====================================================================================
// IExchExt - tells exchange what interfaces I am supporting
// =====================================================================================
STDMETHODIMP CExchRep::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	// Locals
    HRESULT hr = S_OK;

    *ppvObj = NULL;

    // IUnknown or IExchExt interface, this is it dude
    if ((IID_IUnknown == riid) || (IID_IExchExt == riid))
    {
		*ppvObj = (LPUNKNOWN)(IExchExt *)this;
    }
   
	// IExchExtCommands interface ?
	else if (IID_IExchExtSessionEvents == riid) 
	{
		*ppvObj = (LPUNKNOWN)(IExchExtSessionEvents *)this;
    }
 
	// Else, interface is not supported
	else hr = E_NOINTERFACE;

    // Increment Reference Count
	if (NULL != *ppvObj) ((LPUNKNOWN)*ppvObj)->AddRef();

	// Done
    return hr;
}

// =====================================================================================
// Install is called
// =====================================================================================
STDMETHODIMP CExchRep::Install (LPEXCHEXTCALLBACK lpExchCallback, ULONG mecontext, ULONG ulFlags)
{
    // Locals
    HRESULT			    hr = S_OK;

    // Only in session context
    if (mecontext != EECONTEXT_SESSION)
        return S_OK;

    // Get Window Handle
    lpExchCallback->GetWindow (&m_hwnd);

    // Get Session Object
    hr = lpExchCallback->GetSession (&m_lpSession, NULL);
    if (FAILED (hr) || !m_lpSession)
    {
        MessageBox (m_hwnd, "IExchExtCallback::GetSession Failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Load Config
    LoadConfig ();

exit:
    // Done
    return S_OK;
}

// =====================================================================================
// LoadConfig
// =====================================================================================
VOID CExchRep::LoadConfig (VOID)
{
    // Locals
    HKEY                hReg = NULL;
    ULONG               cbRegData;
    DWORD               dwType;

    // Open the Reg Key
    if (RegOpenKeyEx (HKEY_CURRENT_USER, REGPATH, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
    {
        MessageBox (m_hwnd, "Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Display To
    cbRegData = sizeof (m_szDisplayTo);
    dwType = REG_SZ;
    if (RegQueryValueEx (hReg, ROUTE_TO_DISPLAY, 0, &dwType, (LPBYTE)m_szDisplayTo, &cbRegData) != ERROR_SUCCESS)
    {
        MessageBox (m_hwnd, "Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Address To
    cbRegData = sizeof (m_szAddressTo);
    dwType = REG_SZ;
    if (RegQueryValueEx (hReg, ROUTE_TO_ADDRESS, 0, &dwType, (LPBYTE)m_szAddressTo, &cbRegData) != ERROR_SUCCESS)
    {
        MessageBox (m_hwnd, "Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Get mail news dll path
    cbRegData = sizeof (m_szMailNewsPath);
    dwType = REG_SZ;
    if (RegQueryValueEx (hReg, MAILNEWS_PATH, 0, &dwType, (LPBYTE)m_szMailNewsPath, &cbRegData) == ERROR_SUCCESS)
    {
        // Lets Load mailnews.dll
        m_hMailNews = LoadLibrary ("c:\\thor\\build\\debug\\mailnews.dll");
        if (m_hMailNews == NULL)
        {
            MessageBox (m_hwnd, "Unable to load mailnews.dll. Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
            goto exit;
        }

        // Fixup Procedure addresses
        m_lpfnHrImnRouteMessage = (PFNHRIMNROUTEMESSAGE)GetProcAddress (m_hMailNews, "HrImnRouteMessage");
        m_lpfnMailNewsDllInit = (PFNMAILNEWSDLLINIT)GetProcAddress (m_hMailNews, "MailNewsDllInit");;

        // Could get proc addresses
        if (!m_lpfnHrImnRouteMessage || !m_lpfnMailNewsDllInit)
        {
            FreeLibrary (m_hMailNews);
            m_hMailNews = NULL;
            goto exit;
        }

        // Init the dll
        (*m_lpfnMailNewsDllInit)(TRUE);
    }

exit:
    // Cleanup
    if (hReg)
        RegCloseKey (hReg);

    // Done
    return;
}

// =====================================================================================
// OnDeliver - This function never fail
// =====================================================================================
STDMETHODIMP CExchRep::OnDelivery (LPEXCHEXTCALLBACK lpExchCallback)
{
    // Locals
    HRESULT             hr = S_OK;
    LPMDB               lpMdb = NULL;
    LPMESSAGE           lpMessage = NULL;
    IMSG                rImsg;
    IADDRINFO           rIaddr[2];

    // No mailnews.dll
    if (!m_hMailNews || !m_lpfnHrImnRouteMessage || !m_lpfnMailNewsDllInit)
        goto exit;

    // Get object (IMessage
    hr = lpExchCallback->GetObject(&lpMdb, (LPMAPIPROP *)&lpMessage);
    if (FAILED (hr) || !lpMessage)
    {
        MessageBox (m_hwnd, "IExchExtCallback::GetObject failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Convert MAPI Message to mime message
    hr = HrMapiToImsg (lpMessage, &rImsg);
    if (FAILED (hr))
    {
        MessageBox (m_hwnd, "HrMapiToImsg failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Set the rout to address
    rIaddr[0].dwType = IADDR_TO;
    rIaddr[0].lpszDisplay = m_szDisplayTo;
    rIaddr[0].lpszAddress = m_szAddressTo;
    rIaddr[1].dwType = IADDR_FROM;
    rIaddr[1].lpszDisplay = ROUTER_DISPLAY;
    rIaddr[1].lpszAddress = ROUTER_ADDRESS;

    // Send the message
    hr = (*m_lpfnHrImnRouteMessage)(rIaddr, 2, &rImsg);
    if (FAILED (hr))
    {
        MessageBox (m_hwnd, "HrImnRouteMessage failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

exit:
    // Cleanup
    if (lpMdb)
        lpMdb->Release ();
    if (lpMessage)
        lpMessage->Release ();
    FreeImsg (&rImsg);

    // Done
    return S_OK;
}

// =====================================================================================
// FreeImsg
// =====================================================================================
VOID FreeImsg (LPIMSG lpImsg)
{
    // Locals
    ULONG           i;

    // Nothing
    if (lpImsg == NULL)
        return;

    // Free Stuff
    if (lpImsg->lpszSubject)
        free (lpImsg->lpszSubject);
    lpImsg->lpszSubject = NULL;
    
    if (lpImsg->lpszBody)
        free (lpImsg->lpszBody);
    lpImsg->lpszBody = NULL;

    if (lpImsg->lpstmRtf)
        lpImsg->lpstmRtf->Release ();
    lpImsg->lpstmRtf = NULL;

    // Walk Address list
    for (i=0; i<lpImsg->cAddress; i++)
    {
        if (lpImsg->lpIaddr[i].lpszAddress)
            free (lpImsg->lpIaddr[i].lpszAddress);
        lpImsg->lpIaddr[i].lpszAddress = NULL;

        if (lpImsg->lpIaddr[i].lpszDisplay)
            free (lpImsg->lpIaddr[i].lpszDisplay);
        lpImsg->lpIaddr[i].lpszDisplay = NULL;
    }

    // Free Address list
    if (lpImsg->lpIaddr)
        free (lpImsg->lpIaddr);
    lpImsg->lpIaddr = NULL;

    // Walk Attachment list
    for (i=0; i<lpImsg->cAttach; i++)
    {
        if (lpImsg->lpIatt[i].lpszFileName)
            free (lpImsg->lpIatt[i].lpszFileName);
        lpImsg->lpIatt[i].lpszFileName = NULL;

        if (lpImsg->lpIatt[i].lpszPathName)
            free (lpImsg->lpIatt[i].lpszPathName);
        lpImsg->lpIatt[i].lpszPathName = NULL;

        if (lpImsg->lpIatt[i].lpszExt)
            free (lpImsg->lpIatt[i].lpszExt);
        lpImsg->lpIatt[i].lpszExt = NULL;

        if (lpImsg->lpIatt[i].lpImsg)
        {
            FreeImsg (lpImsg->lpIatt[i].lpImsg);
            free (lpImsg->lpIatt[i].lpImsg);
            lpImsg->lpIatt[i].lpImsg = NULL;
        }

        if (lpImsg->lpIatt[i].lpstmAtt)
            lpImsg->lpIatt[i].lpstmAtt->Release ();
        lpImsg->lpIatt[i].lpstmAtt = NULL;
    }

    // Free the att list
    if (lpImsg->lpIatt)
        free (lpImsg->lpIatt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\util\imntnef\imntnef.h ===
// ==============================================================================
// I M N T N E F . H
// ==============================================================================
#ifndef __IMNTNEF_H
#define __IMNTNEF_H

#define IMNTNEF_DLL "imntnef.dll"

typedef HRESULT (STDAPICALLTYPE *PFNHRGETTNEFRTFSTREAM)(LPSTREAM lpstmTnef, LPSTREAM *lppstmRtf);
typedef HRESULT (STDAPICALLTYPE *PFNHRINIT)(BOOL fInit);

#endif // __IMNTNEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\makefile.inc ===
$O\msimn.res : selfreg.inf

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\view\listevt.h ===
#pragma once

#include "msoedisp.h"

//////////////////////////////////////////////////////////////////////////////
// CProxy_MessageListEvents
template <class T>
class CProxy_MessageListEvents : public IConnectionPointImpl<T, &DIID__MessageListEvents, CComDynamicUnkArray>
{
public:
//methods:
//_MessageListEvents : IDispatch
public:
    HRESULT Fire_OnMessageAvailable(MESSAGEID idMessage, HRESULT hrComplete)
    {
        HRESULT hr;
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[2];
        if(!pvars)
            return E_OUTOFMEMORY;
        
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I8;
                pvars[0].ullVal= (ULONGLONG)idMessage;
                pvars[1].vt = VT_ERROR;
                pvars[1].scode = hrComplete;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                hr = pDispatch->Invoke(DISPID_LISTEVENT_ONMESSAGEAVAILABLE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
        return hr;
    }


    void Fire_OnSelectionChanged(long cSelected)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= cSelected;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_SELECTIONCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnFocusChanged(long fFocus)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= fFocus;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_FOCUSCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnMessageCountChanged(IMessageTable *pTable)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[3];
        if(!pvars)
            return;
        for (int i = 0; i < 3; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {                
                pvars[0].vt = VT_I4;
                if (pTable)
                {
                    pTable->GetCount(MESSAGE_COUNT_ALL, (DWORD *) &(pvars[0].lVal));
                }

                pvars[1].vt = VT_I4;
                if (pTable)
                {
                    pTable->GetCount(MESSAGE_COUNT_UNREAD, (DWORD *) &(pvars[1].lVal));
                }

                pvars[2].vt = VT_I4;
                if (pTable)
                {
                    pTable->GetCount(MESSAGE_COUNT_NOTDOWNLOADED, (DWORD *) &(pvars[2].lVal));
                }
                DISPPARAMS disp = { pvars, NULL, 3, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_COUNTCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnUpdateStatus(LPCTSTR pszStatus)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {   
                TCHAR szBuf[CCHMAX_STRINGRES];

                // If this is a string resource ID, load it first
                if (IS_INTRESOURCE(pszStatus))
                {
                    AthLoadString(PtrToUlong(pszStatus), szBuf, ARRAYSIZE(szBuf));
                    pszStatus = szBuf;
                }
/*
                CComBSTR cString(pszStatus);
*/
                pvars->vt = VT_BSTR;
                pvars->bstrVal = (BSTR) pszStatus;

                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_UPDATESTATUS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnUpdateProgress(long lProgress, long lMax = 100, long lState = PROGRESS_STATE_DEFAULT)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[3];
        if(!pvars)
            return;
        for (int i = 0; i < 3; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= lProgress;
                pvars[1].vt = VT_I4;
                pvars[1].lVal = lMax;
                pvars[2].vt = VT_I4;
                pvars[2].lVal = lState;
                DISPPARAMS disp = { pvars, NULL, 3, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_UPDATEPROGRESS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }


    void Fire_OnError(DWORD ids)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= ids;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_ERROR, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnItemActivate(void)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_ITEMACTIVATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_OnUpdateCommandState(void)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_UPDATECOMMANDSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
    
    void Fire_OnFilterChanged(RULEID ridFilter)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I8;
                pvars[0].ullVal= (ULONGLONG) ridFilter;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_FILTERCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnAdUrlAvailable(LPSTR   pszAdUrl)
    {
        VARIANT     varResult;
        BSTR        Bstr;

        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                if SUCCEEDED(HrLPSZToBSTR(pszAdUrl, &Bstr))
                {                
                    pvars[0].vt         = VT_BSTR;
                
                    pvars[0].bstrVal    = Bstr;

                    DISPPARAMS disp = { pvars, NULL, 1, 0 };

                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(DISPID_LISTEVENT_ADURL_AVAILABLE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);

                    SysFreeString(Bstr);
                }
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\view\msglist.h ===
// msglist.h : Declaration of the CMessageList

#ifndef __MESSAGELIST_H_
#define __MESSAGELIST_H_

#include "resource.h"       // main symbols
#include "columns.h"
#include "thormsgs.h"
#include "msoeobj.h"
#include "listevt.h"
#include "mimeole.h"
#include "storutil.h"
#include "util.h"

#define WM_FOLDER_LOADED WM_USER + 1

interface IMessageTable;
interface IMessageViewNotify;
interface IFindNext;
interface IListSelector;

#define     NOT_KNOWN           0x0
#define     CONNECTED           0x1
#define     NOT_CONNECTED       0x2

/////////////////////////////////////////////////////////////////////////////
// Creator Function
//
HRESULT CreateMessageList(IUnknown *pUnkOuter, IMessageList **ppList);


/////////////////////////////////////////////////////////////////////////////
// CMessageList
//
class ATL_NO_VTABLE CMessageList : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMessageList, &CLSID_MessageList>,
    public CComControl<CMessageList>,
    public IDispatchImpl<IOEMessageList, &IID_IOEMessageList, &LIBID_MSOEOBJ>,
    public IProvideClassInfo2Impl<&CLSID_MessageList, &DIID__MessageListEvents, &LIBID_MSOEOBJ>,
    public IPersistStreamInitImpl<CMessageList>,
    public IPersistStorageImpl<CMessageList>,
    public IQuickActivateImpl<CMessageList>,
    public IOleControlImpl<CMessageList>,
    public IOleObjectImpl<CMessageList>,
    public IOleInPlaceActiveObjectImpl<CMessageList>,
    public IViewObjectExImpl<CMessageList>,
    public IOleInPlaceObjectWindowlessImpl<CMessageList>,
    public IDataObjectImpl<CMessageList>,
    public CProxy_MessageListEvents<CMessageList>,
    public IConnectionPointContainerImpl<CMessageList>,
    public IPropertyNotifySinkCP<CMessageList>,
    public ISpecifyPropertyPagesImpl<CMessageList>,
    public IOleCommandTarget, 
    public IDropSource,
    public IStoreCallback,
    public IMessageTableNotify,
    public IFontCacheNotify,
    public IMessageList,
    public ITimeoutCallback,
    public IConnectionNotify
{
public:

    // Declare our own window class that doesn't have the CS_HREDRAW etc set
    static CWndClassInfo& GetWndClassInfo() 
    { 
        static CWndClassInfo wc = 
        { 
            { sizeof(WNDCLASSEX), 0, StartWindowProc, 
              0, 0, 0, 0, 0, 0, 0, "Outlook Express Message List", 0 }, 
            NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
        }; 
        return wc; 
    }

    DECLARE_NO_REGISTRY()

    /////////////////////////////////////////////////////////////////////////////
    // This is our QueryInterface implementation
    //
    BEGIN_COM_MAP(CMessageList)
        COM_INTERFACE_ENTRY(IOEMessageList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IDataObject)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IDropSource)
        COM_INTERFACE_ENTRY(IStoreCallback)
        COM_INTERFACE_ENTRY(IMessageTableNotify)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY(IFontCacheNotify)
        COM_INTERFACE_ENTRY(IMessageList)
        COM_INTERFACE_ENTRY(ITimeoutCallback)
        COM_INTERFACE_ENTRY(IConnectionNotify)
    END_COM_MAP()

    /////////////////////////////////////////////////////////////////////////////
    // Maps Dispatch IDs to property description strings for automation
    //
    BEGIN_PROPERTY_MAP(CMessageList)
        // Example entries
        // PROP_ENTRY("Property Description", dispid, clsid)
        PROP_ENTRY("Count",             DISPID_LISTPROP_COUNT,               CLSID_StockColorPage)
        PROP_ENTRY("ExpandGroups",      DISPID_LISTPROP_EXPAND_GROUPS,       CLSID_StockColorPage)
        PROP_ENTRY("Folder",            DISPID_LISTPROP_FOLDER,              CLSID_StockColorPage)
        PROP_ENTRY("GroupMessages",     DISPID_LISTPROP_GROUP_MESSAGES,      CLSID_StockColorPage)
        PROP_ENTRY("MessageTips",       DISPID_LISTPROP_MESSAGE_TIPS,        CLSID_StockColorPage)
        PROP_ENTRY("PreviewMessage",    DISPID_LISTPROP_COUNT,               CLSID_StockColorPage)
        PROP_ENTRY("ScrollTips",        DISPID_LISTPROP_SCROLL_TIPS,         CLSID_StockColorPage)
        PROP_ENTRY("SelectedCount",     DISPID_LISTPROP_SELECTED_COUNT,      CLSID_StockColorPage)
        PROP_ENTRY("SelectFirstUnread", DISPID_LISTPROP_SELECT_FIRST_UNREAD, CLSID_StockColorPage)
        PROP_ENTRY("UnreadCount",       DISPID_LISTPROP_UNREAD_COUNT,        CLSID_StockColorPage)
        PROP_ENTRY("FilterMessages",    DISPID_LISTPROP_FILTER_MESSAGES,     CLSID_StockColorPage)
        PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()

    /////////////////////////////////////////////////////////////////////////////
    // This are our outgoing connection points
    //
    BEGIN_CONNECTION_POINT_MAP(CMessageList)
        CONNECTION_POINT_ENTRY(DIID__MessageListEvents)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP()


    /////////////////////////////////////////////////////////////////////////
    // Creation and Initialization
    //
public:
    CMessageList();
    ~CMessageList();

    HRESULT FinalConstruct(void);

    /////////////////////////////////////////////////////////////////////////
    // Overrides of base class members
    //

    // IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);
    
    // CComControl
    HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

    // IOleInPlaceActiveObject
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);

public:
    /////////////////////////////////////////////////////////////////////////
    // IMessageList interface
    //
    STDMETHOD(SetFolder)(FOLDERID idFolder, IMessageServer *pServer, BOOL fSubFolders, FINDINFO *pFindInfo, IStoreCallback *pCallback);
    STDMETHOD(SetViewOptions)(FOLDER_OPTIONS *pOptions);
    STDMETHOD(GetViewOptions)(FOLDER_OPTIONS *pOptions);
    STDMETHOD(OnClose)(void);
    STDMETHOD(GetRect)(LPRECT prcList);
    STDMETHOD(SetRect)(RECT rc);
    STDMETHOD(HasFocus)(void);
    STDMETHOD(OnPopupMenu)(HMENU hMenu, DWORD idPopup);
    STDMETHOD(GetSelected)(DWORD *pdwFocused, DWORD *pcSelected, DWORD **prgSelected);
    STDMETHOD(GetSelectedCount)(DWORD *pdwCount);
    STDMETHOD(GetMessage)(DWORD dwRow, BOOL fDownload, BOOL fBookmark, IUnknown **ppMessage);
    STDMETHOD(GetMessageInfo)(DWORD dwRow, MESSAGEINFO **ppMsgInfo);
    STDMETHOD(GetRowFolderId)(DWORD dwRow, LPFOLDERID pidFolder);
    STDMETHOD(MarkMessage)(DWORD dwRow, MARK_TYPE mark);
    STDMETHOD(FreeMessageInfo)(MESSAGEINFO *pMsgInfo);
    STDMETHOD(MarkRead)(BOOL fBookmark, DWORD dwRow);
    STDMETHOD(GetMessageTable)(IMessageTable **ppTable);
    STDMETHOD(CreateList)(HWND hwndParent, IUnknown *pFrame, HWND *phwndList);
    STDMETHOD(GetListSelector)(IListSelector **ppListSelector);
    STDMETHOD(GetMessageCounts)(DWORD *cTotal, DWORD *cUnread, DWORD *cOnServer);
    STDMETHOD(GetMessageServer)(IMessageServer **ppServer);
    STDMETHOD(GetFocusedItemState)(DWORD *pdwState);
    STDMETHOD(ProcessReceipt)(IMimeMessage *pMessage);
    STDMETHOD(GetAdBarUrl)(void);

    /////////////////////////////////////////////////////////////////////////
    // IOEMessageList interface
    //
    STDMETHOD(get_Folder)(/*[out, retval]*/ ULONGLONG *pVal);
    STDMETHOD(put_Folder)(/*[in]*/ ULONGLONG newVal);
    STDMETHOD(get_ExpandGroups)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ExpandGroups)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_GroupMessages)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_GroupMessages)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_SelectFirstUnread)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_SelectFirstUnread)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_MessageTips)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_MessageTips)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_ScrollTips)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ScrollTips)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_UnreadCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_SelectedCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PreviewMessage)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FilterMessages)(/*[out, retval]*/ ULONGLONG *pVal);
    STDMETHOD(put_FilterMessages)(/*[in]*/ ULONGLONG newVal);
    STDMETHOD(get_ShowDeleted)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ShowDeleted)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_ShowReplies)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ShowReplies)(/*[in]*/ BOOL newVal);

    /////////////////////////////////////////////////////////////////////////
    // IDropSource interface
    //
    STDMETHOD(QueryContinueDrag)(BOOL fEscPressed, DWORD grfKeyState);
    STDMETHOD(GiveFeedback)(DWORD dwEffect);

    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget interface
    //
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                           OLECMDTEXT *pCmdText); 
    STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                    VARIANTARG *pvaIn, VARIANTARG *pvaOut);    

    /////////////////////////////////////////////////////////////////////////
    // IFontCacheNotify
    //
	STDMETHOD(OnPreFontChange)(void);
	STDMETHOD(OnPostFontChange)(void);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback interface
    //
    STDMETHOD(OnBegin)(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHOD(OnProgress)(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHOD(OnTimeout)(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHOD(CanConnect)(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHOD(OnLogonPrompt)(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHOD(OnComplete)(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHOD(OnPrompt)(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHOD(GetParentWindow)(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // IMessageTableNotify interface
    //
    STDMETHOD(OnInsertRows)(DWORD cRows, LPROWINDEX prgiRow, BOOL fExpanded);
    STDMETHOD(OnDeleteRows)(DWORD cRows, LPROWINDEX prgiRow, BOOL fCollapsed);
    STDMETHOD(OnUpdateRows)(ROWINDEX iRowMin, ROWINDEX iRowMax);
    STDMETHOD(OnRedrawState)(BOOL fRedraw);
    STDMETHOD(OnResetView)(void);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback
    //
    STDMETHOD(OnTimeoutResponse)(TIMEOUTRESPONSE eResponse);

    /////////////////////////////////////////////////////////////////////////
    // IConnectioNotify
    //
    STDMETHOD(OnConnectionNotify)(CONNNOTIFY    nCode, LPVOID   pvData, CConnectionManager  *pconman);

    /////////////////////////////////////////////////////////////////////////
    // Window Message Handlers
    //
protected:
    BEGIN_MSG_MAP(CMessageList)
        // These are all the normal window messages we handle
        MESSAGE_HANDLER(WM_PAINT,               OnPaint)
        MESSAGE_HANDLER(WM_NOTIFY,              OnNotify)
        MESSAGE_HANDLER(WM_SIZE,                OnSize)
        MESSAGE_HANDLER(WM_SETFOCUS,            OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS,           OnKillFocus)
        MESSAGE_HANDLER(WM_CREATE,              OnCreate)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE,      OnSysColorChange)
        MESSAGE_HANDLER(WM_WININICHANGE,        OnSysColorChange)
        MESSAGE_HANDLER(WM_TIMECHANGE,          OnTimeChange)
        MESSAGE_HANDLER(WM_CONTEXTMENU,         OnContextMenu)
        MESSAGE_HANDLER(WM_TIMER,               OnTimer)
        MESSAGE_HANDLER(MVM_REDOCOLUMNS,        OnRedoColumns)
        MESSAGE_HANDLER(WM_DESTROY,             OnDestroy)
        MESSAGE_HANDLER(WM_SELECTROW,           OnSelectRow)
        
    // ListView
    ALT_MSG_MAP(1)
        MESSAGE_HANDLER(WM_SETCURSOR,           OnListSetCursor)
        MESSAGE_HANDLER(WM_VSCROLL,             OnListVScroll)
#ifdef OLDTOOLTIPS
        MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnListMouseEvent)
        MESSAGE_HANDLER(WM_MOUSEMOVE,           OnListMouseMove)
        MESSAGE_HANDLER(WM_MOUSELEAVE,          OnListMouseLeave)
    // Scroll Bar tooltip
#endif // OLDTIPS
    ALT_MSG_MAP(2)

    END_MSG_MAP()

    HRESULT OnDraw(ATL_DRAWINFO& di);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimeChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRedoColumns(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSelectRow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyGetInfoTip(LPARAM lParam);

    LRESULT OnHeaderStateChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUpdateAndRefocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDiskFull(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnArticleProgress(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnBodyError(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnBodyAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnStatusChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnListVScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
#ifdef OLDTOOLTIPS
    LRESULT OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
#endif // OLDTIPS
    LRESULT OnListSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    /////////////////////////////////////////////////////////////////////////
    // Command Target Handlers
    //
    HRESULT CmdSelectAll(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCopyClipboard(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdProperties(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdExpandCollapse(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdColumnsDlg(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdSort(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdSaveAs(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdMark(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdMarkTopic(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdGetNextItem(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdGetHeaders(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdMoveCopy(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdDelete(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFind(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFindNext(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdPurgeFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdSpaceAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdWatchIgnore(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void    _UpdateListViewCount(void);
    HRESULT _GetSelectedCachedMessage(BOOL fSecure, IMimeMessage **ppMessage);
    HRESULT _ExpandCollapseThread(int iItem);
    BOOL    _IsSelectedMessage(DWORD dwState, BOOL fCondition, BOOL fAll, BOOL fThread = FALSE);
    void    _SelectDefaultRow(void);
    void    _LoadAndFormatString(LPTSTR pszOut, int cchOut, const TCHAR *pFmt, ...);
    BOOL    _IsSelectionDeletable(void);


    LRESULT _OnColumnClick(int iColumn, int iSortType);
    void    _OnBeginDrag(NM_LISTVIEW *pnmlv);
    void    _OnGetDisplayInfo(LV_DISPINFO *plvdi);
    LRESULT _OnCustomDraw(NMCUSTOMDRAW *pnmcd);
    void    _GetColumnText(MESSAGEINFO *pInfo, COLUMN_ID idColumn, LPTSTR pszText, DWORD cchTextMax);
    void    _GetColumnImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, COLUMN_ID idColumn, int *piImage);
    void    _GetColumnStateImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, LV_DISPINFO *plvdi);
    void    _FilterView(RULEID ridFilter);
    HRESULT _EnablePopupMenu(HMENU hPopup);
    void    _SetColumnSet(FOLDERID id, BOOL fFind);
    void    _ResetView(MESSAGEID idSel);

#ifdef OLDTOOLTIPS
    BOOL    _UpdateViewTip(int x, int y, BOOL fForceUpdate = FALSE);
    LRESULT _OnViewTipShow(void);
    LRESULT _OnViewTipGetDispInfo(LPNMTTDISPINFO pttdi);
    BOOL    _IsItemTruncated(int iItem, int iSubItem);
#endif // OLDTIPS
    FNTSYSTYPE _GetRowFont(int iItem);
    HRESULT  PromptToGoOnline();
    HRESULT  Resynchronize();
    void     UpdateConnInfo();
    void    _DoColumnCheck(COLUMN_ID id);
    void    _DoFilterCheck(RULEID ridFilter);
    BOOL    _PollThisAccount(FOLDERID id);

    /////////////////////////////////////////////////////////////////////////
    // Class Member Data
    //
private:
    CContainedWindow        m_ctlList;
    CColumns                m_cColumns;
    HWND                    m_hwndParent;
    BOOL                    m_fInOE;
    BOOL                    m_fMailFolder;
    BOOL                    m_fGroupSubscribed;
    BOOL                    m_fColumnsInit;

    // Settings
    FOLDERID                m_idFolder;
    BOOL                    m_fJunkFolder;
    BOOL                    m_fFindFolder;
    BOOL                    m_fAutoExpandThreads;
    BOOL                    m_fThreadMessages;
    BOOL                    m_fShowDeleted;
    BOOL                    m_fShowReplies;
    BOOL                    m_fSelectFirstUnread;
    COLUMN_SET_TYPE         m_ColumnSetType;
    BOOL                    m_fViewTip;
    BOOL                    m_fScrollTip;
    BOOL                    m_fInFire;
    DWORD                   m_clrWatched;
    DWORD                   m_dwGetXHeaders;

    // Groovy Pointers
    IMessageTable          *m_pTable;
    IOleCommandTarget      *m_pCmdTarget;
    CEmptyList              m_cEmptyList;
    UINT                    m_idsEmptyString;

    BOOL                    m_fRtDrag;          // The user is dragging a message with the right mouse button
    DWORD                   m_iColForPopup;     // Column that the user context menued over
    BOOL                    m_fViewMenu;

    // Bookmarks, etc
    RULEID                  m_ridFilter;
    MESSAGEID               m_idPreDelete;
    MESSAGEID               m_idSelection;
    MESSAGEID               m_idGetMsg;
    DWORD                   m_ulExpect;
    IListSelector          *m_pListSelector;

    HMENU                   m_hMenuPopup;
    POINT                   m_ptMenuPopup;

    DWORD                   m_cSortItems;
    DWORD                   m_cSortCurrent;
    HTIMEOUT                m_hTimeout;
    BOOL                    m_fNotifyRedraw;

    DWORD                   m_dwFontCacheCookie;        // For the Advise on the font cache

    LPSTR                   m_pszSubj;                  // cached subject of current message
    MESSAGEID               m_idMessage;                // currently downloading message
    STOREOPERATIONTYPE      m_tyCurrent;
    IOperationCancel       *m_pCancel;
    DWORD                   m_dwPollInterval;

#ifdef OLDTOOLTIPS
    // Scrolling Tooltips
    CContainedWindow        m_ctlScrollTip;
    BOOL                    m_fScrollTipVisible;

    // Trucated listview items Tooltips
    CContainedWindow        m_ctlViewTip;
    BOOL                    m_fViewTipVisible;
    BOOL                    m_fTrackSet;
    int                     m_iItemTip;
    int                     m_iSubItemTip;
#endif // OLDTIPS
    FOLDERINFO              m_FolderInfo;

    // Find
    HWND                    m_hwndFind;
    IFindNext              *m_pFindNext;
    MESSAGEID               m_idFindFirst;
    DWORD                   m_cFindWrap;

    BOOL                    m_fSyncAgain;
    DWORD                   m_dwConnectState;

    HCHARSET                m_hCharset;
};



/////////////////////////////////////////////////////////////////////////////
// CListSelector
//

class CListSelector : public IListSelector
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CListSelector();
    ~CListSelector();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IListSelector
    //
    STDMETHODIMP SetActiveRow(ROWINDEX iRow);
    STDMETHODIMP Advise(HWND hwndAdvise);
    STDMETHODIMP Unadvise(void);

private:
    ULONG m_cRef;
    HWND  m_hwndAdvise;
};

#endif //__MESSAGELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\view\msglist.cpp ===
// msglist.cpp : Implementation of CMessageList

#include "pch.hxx"
#include "msoeobj.h"
#include "msglist.h"
#include "msgtable.h"
#include "fonts.h"
#include "imagelst.h"
#include "goptions.h"
#include "note.h"
#include "mimeutil.h"
#include "xputil.h"
#include "menuutil.h"
#include "instance.h"
#include <oerules.h>
#include "msgprop.h"
#include "storutil.h"
#include "ipab.h"
#include "shlwapip.h" 
#include "newfldr.h"
#include "storutil.h"
#include "menures.h"
#include "dragdrop.h"
#include "find.h"
#include <storecb.h>
#include "util.h"
#include <ruleutil.h>
#include "receipts.h"
#include "msgtable.h"
#include "demand.h"
#include "mirror.h"
#define SERVER_HACK

/////////////////////////////////////////////////////////////////////////////
// Types 
//
#define C_RGBCOLORS 16
extern const DWORD rgrgbColors16[C_RGBCOLORS];

// Indiciates the sort direction for calls to OnColumnClick
typedef enum tagSORT_TYPE {
    LIST_SORT_ASCENDING = 0,
    LIST_SORT_DESCENDING,
    LIST_SORT_TOGGLE,
    LIST_SORT_DEFAULT
};

// Selection change timer ID
#define IDT_SEL_CHANGE_TIMER 1002
#define IDT_SCROLL_TIP_TIMER 1003
#define IDT_POLLMSGS_TIMER   1004
#define IDT_VIEWTIP_TIMER    1005

//--------------------------------------------------------------------------
// Mail Icons
//--------------------------------------------------------------------------
#define ICONF_UNSENT    8               // +------- Unsent
#define ICONF_SIGNED    4               // | +----- Signed
#define ICONF_ENCRYPTED 2               // | | +--- Encrypted
#define ICONF_UNREAD    1               // | | | +- Unread
                                        // | | | |
static const int c_rgMailIconTable[16] = {
    iiconReadMail,                      // 0 0 0 0
    iiconUnReadMail,                    // 0 0 0 1
    iiconMailReadEncrypted,             // 0 0 1 0
    iiconMailUnReadEncrypted,           // 0 0 1 1
    iiconMailReadSigned,                // 0 1 0 0
    iiconMailUnReadSigned,              // 0 1 0 1
    iiconMailReadSignedAndEncrypted,    // 0 1 1 0
    iiconMailUnReadSignedAndEncrypted,  // 0 1 1 1
    iiconUnSentMail,                    // 1 0 0 0
    iiconUnSentMail,                    // 1 0 0 1
    iiconMailReadEncrypted,             // 1 0 1 0
    iiconMailUnReadEncrypted,           // 1 0 1 1
    iiconMailReadSigned,                // 1 1 0 0
    iiconMailUnReadSigned,              // 1 1 0 1
    iiconMailReadSignedAndEncrypted,    // 1 1 1 0
    iiconMailUnReadSignedAndEncrypted   // 1 1 1 1
};

//--------------------------------------------------------------------------
// News Icons
//--------------------------------------------------------------------------
                                        // +------- Unsent
#define ICONF_FAILED    4               // | +----- Failed
#define ICONF_HASBODY   2               // | | +--- HasBody
                                        // | | | +- Unread
                                        // | | | |
static const int c_rgNewsIconTable[16] = {
    iiconNewsHeaderRead,                // 0 0 0 0
    iiconNewsHeader,                    // 0 0 0 1
    iiconNewsRead,                      // 0 0 1 0
    iiconNewsUnread,                    // 0 0 1 1
    iiconNewsFailed,                    // 0 1 0 0
    iiconNewsFailed,                    // 0 1 0 1
    iiconNewsFailed,                    // 0 1 1 0
    iiconNewsFailed,                    // 0 1 1 1
    iiconNewsUnsent,                    // 1 0 0 0
    iiconNewsUnsent,                    // 1 0 0 1
    iiconNewsUnsent,                    // 1 0 1 0
    iiconNewsUnsent,                    // 1 0 1 1
    iiconNewsFailed,                    // 1 1 0 0
    iiconNewsFailed,                    // 1 1 0 1
    iiconNewsFailed,                    // 1 1 1 0
    iiconNewsFailed,                    // 1 1 1 1
};


//
//  FUNCTION:   CreateMessageList()
//
//  PURPOSE:    Creates the CMessageList object and returns it's IUnknown 
//              pointer.
//
//  PARAMETERS: 
//      [in]  pUnkOuter - Pointer to the IUnknown that this object should
//                        aggregate with.
//      [out] ppUnknown - Returns the pointer to the newly created object.
//
HRESULT CreateMessageList(IUnknown *pUnkOuter, IMessageList **ppList)
{
    HRESULT     hr;
    IUnknown   *pUnknown;

    TraceCall("CreateMessageList");

    // Get the class factory for the MessageList object
    IClassFactory *pFactory = NULL;
    hr = _Module.GetClassObject(CLSID_MessageList, IID_IClassFactory, 
                                (LPVOID *) &pFactory);

    // If we got the factory, then get an object pointer from it
    if (SUCCEEDED(hr))
    {
        hr = pFactory->CreateInstance(pUnkOuter, IID_IOEMessageList, 
                                      (LPVOID *) &pUnknown);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IMessageList, (LPVOID *) ppList);
            pUnknown->Release();
        }
        pFactory->Release();
    }

    return (hr);
}


/////////////////////////////////////////////////////////////////////////////
// CMessageList
//

CMessageList::CMessageList() : m_ctlList(_T("SysListView32"), this, 1)
{ 
    m_bWindowOnly = TRUE; 

    m_hwndParent = 0;
    m_fInOE = FALSE;
    m_fMailFolder = FALSE;
    m_fColumnsInit = FALSE;

    m_idFolder = FOLDERID_INVALID;
    m_fJunkFolder = FALSE;
    m_fFindFolder = FALSE;
    m_fAutoExpandThreads = FALSE;
    m_fThreadMessages = FALSE;
    m_fShowDeleted = TRUE;
    m_fShowReplies = FALSE;
    m_fSelectFirstUnread = TRUE;
    m_ColumnSetType = COLUMN_SET_MAIL;

//     m_fViewTip = TRUE;
    m_fScrollTip = TRUE;    
    m_fNotifyRedraw = TRUE;
    m_clrWatched = 0;
    m_dwGetXHeaders = 0;
    m_fInFire = FALSE;

    m_pTable = NULL;
    m_pCmdTarget = NULL;
    m_idsEmptyString = idsEmptyView;

    m_fRtDrag = FALSE;
    m_iColForPopup = -1;
    m_fViewMenu = TRUE;

    m_ridFilter = RULEID_VIEW_ALL;
    m_idPreDelete = 0;
    m_idSelection = 0;
    m_idGetMsg = 0;
    m_ulExpect = 0;
    m_hTimeout = NULL;
    m_pListSelector = NULL;

    m_hMenuPopup = 0;
    m_ptMenuPopup.x = 0;
    m_ptMenuPopup.y = 0;

    m_cSortItems = 0;

    m_dwFontCacheCookie = 0;
    m_tyCurrent = SOT_INVALID;
    m_pCancel = NULL;

#ifdef OLDTIPS
    m_fScrollTipVisible = FALSE;

    m_fViewTipVisible = FALSE;
    m_fTrackSet = FALSE;
    m_iItemTip = -1;
    m_iSubItemTip = -1;
#endif // OLDTIPS

    m_hwndFind = NULL;
    m_pFindNext = NULL;
    m_pszSubj = NULL;
    m_idFindFirst = 0;

    m_idMessage = MESSAGEID_INVALID;
    m_dwPollInterval = OPTION_OFF;
    m_fSyncAgain        = FALSE;
    
    m_dwConnectState    = NOT_KNOWN;

    m_hCharset      = NULL;

    // Initialize the applicaiton
    g_pInstance->DllAddRef();
    CoIncrementInit("CMessageList::CMessageList", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}


CMessageList::~CMessageList()
{
    if (m_pFindNext)
    {
        m_pFindNext->Close();
        m_pFindNext->Release();
    }
    
    // Register Notify
    if (m_pTable)
    {
        m_pTable->UnregisterNotify((IMessageTableNotify *)this);
        m_pTable->ConnectionRelease();
        m_pTable->Close();
        m_pTable->Release();
        m_pTable = NULL;
    }

    SafeMemFree(m_pszSubj);
    CallbackCloseTimeout(&m_hTimeout);

    if (g_pConMan)
    {
        g_pConMan->Unadvise((IConnectionNotify*)this);
    }

    g_pInstance->DllRelease();
    CoDecrementInit("CMessageList::CMessageList", NULL);
}


//
//  FUNCTION:   CMessageList::FinalConstruct()
//
//  PURPOSE:    This function get's called after the class is created but 
//              before the call to CClassFactory::CreateInstance() returns.
//              Perform any inititalization that can fail here.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageList::FinalConstruct(void)
{
    TraceCall("CMessageList::FinalConstruct");
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::GetViewStatus()
//
//  PURPOSE:    We override this member of IViewObjectEx to return the view 
//              status flags that are appropriate to our object.
//
//  PARAMETERS: 
//      [out] pdwStatus - Returns the status flags for our object
//
STDMETHODIMP CMessageList::GetViewStatus(DWORD* pdwStatus)
{
    TraceCall("IViewObjectExImpl::GetViewStatus");
    *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;

    return S_OK;
}


//
//  FUNCTION:   CMessageList::CreateControlWindow()
//
//  PURPOSE:    Creates our Message List window.  We override this from 
//              CComControl so we can add the WS_EX_CONTROLPARENT style.
//
//  PARAMETERS: 
//      [in] hWndParent - Handle of the window that will be our parent
//      [in] rcPos      - Initial position of the window
//
HWND CMessageList::CreateControlWindow(HWND hWndParent, RECT& rcPos)
{
    TraceCall("CMessageList::CreateControlWindow");

    m_hwndParent = hWndParent;

    return (Create(hWndParent, rcPos, NULL, WS_VISIBLE | WS_CHILD | 
                   WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_CONTROLPARENT));
}


STDMETHODIMP CMessageList::TranslateAccelerator(LPMSG pMsg)
{
    if (IsWindow(m_hwndFind) && m_pFindNext)
    {
        return m_pFindNext->TranslateAccelerator(pMsg);
    }

    return (S_FALSE);        
}


//
//  FUNCTION:   CMessageList::QueryContinueDrag()
//
//  PURPOSE:    While the user is dragging an item out of our ListView, this 
//              function get's called so we can define what the behavior of 
//              keys like ALT or CTRL have on the drop.
//
//  PARAMETERS: 
//      [in] fEscPressed - TRUE if the user has pressed the Escape key
//      [in] grfKeyState - Status of the keys being pressed while dragging
//
//  RETURN VALUE:
//      DRAGDROP_S_CANCEL
//      DRAGDROP_S_DROP
//
STDMETHODIMP CMessageList::QueryContinueDrag(BOOL fEscPressed, DWORD grfKeyState)
{
    TraceCall("CMessageList::QueryContinueDrag");

    // If the user presses Escape, we abort
    if (fEscPressed)
        return (DRAGDROP_S_CANCEL);

    // If the user was dragging with the left mouse button, and then clicks the
    // right button, we abort.  If they let go of the left button, we drop.  If
    // the user is dragging with the right mouse button, same actions only 
    // reversed.
    if (!m_fRtDrag)
    {
        if (grfKeyState & MK_RBUTTON)
            return (DRAGDROP_S_CANCEL);
        if (!(grfKeyState & MK_LBUTTON))
            return (DRAGDROP_S_DROP);
    }
    else
    {
        if (grfKeyState & MK_LBUTTON)
            return (DRAGDROP_S_CANCEL);
        if (!(grfKeyState & MK_RBUTTON))
            return (DRAGDROP_S_DROP);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::GiveFeedback()
//
//  PURPOSE:    Allows the drag source to give feedback during a drag-drop.
//              We just let OLE do it's natural thing.
//
//  PARAMETERS: 
//      [in] dwEffect - The effect returned by the drop target.
//
//  RETURN VALUE:
//      DRAGDROP_S_USEDEFAULTCURSORS 
//
STDMETHODIMP CMessageList::GiveFeedback(DWORD dwEffect)
{
    TraceCall("CMessageList::GiveFeedback");
    return (DRAGDROP_S_USEDEFAULTCURSORS);
}


// 
//  FUNCTION:   CMessageList::QueryStatus()
//
//  PURPOSE:    Allows the caller to determine if a command supported by this
//              object is currently enabled or disabled.
//
//  PARAMETERS:
//      [in] pguidCmdGroup - GUID identifing this array of commands
//      [in] cCmds         - Number of commands in prgCmds
//      [in,out] prgCmds   - Array of commands the caller is requesting status for
//      [out] pCmdText     - Status text for the requested command
//
STDMETHODIMP CMessageList::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                       OLECMD *prgCmds, OLECMDTEXT *pCmdText)
{
    DWORD     dwState;
    COLUMN_ID idSort;
    BOOL      fAscending;

    // Verify these commands are ones that we support
    if (pguidCmdGroup && (*pguidCmdGroup != CMDSETID_OEMessageList) && (*pguidCmdGroup != CMDSETID_OutlookExpress))
        return (OLECMDERR_E_UNKNOWNGROUP);

    // Gather some initial information about ourselves
    HWND hwndFocus = GetFocus();
    BOOL fItemFocus = (hwndFocus == m_ctlList) /* || fPreviewFocus */;
    UINT cSel = ListView_GetSelectedCount(m_ctlList);
    int  iSel = ListView_GetFirstSel(m_ctlList);
    int  iFocus = ListView_GetFocusedItem(m_ctlList);
    
    // If the user is trying to get command text, tell them we're too lame
    if (pCmdText)
        return (E_FAIL);
                            
    // Loop through the commands 
    for (DWORD i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // Default to supported.  If it's not, we'll remove it later
            prgCmds[i].cmdf = OLECMDF_SUPPORTED;

            // Check to see if this is the sort menu
            if (prgCmds[i].cmdID >= ID_SORT_MENU_FIRST && prgCmds[i].cmdID <= ID_SORT_MENU_FIRST + m_cSortItems)
            {
                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                if (prgCmds[i].cmdID == m_cSortCurrent)
                    prgCmds[i].cmdf |= OLECMDF_NINCHED;
            }
            else
            {
                switch (prgCmds[i].cmdID)
                {
                    case ID_SAVE_AS:
                        // One item selected and it must be downloaded
                        if (cSel == 1 && iSel != -1 && _IsSelectedMessage(ROW_STATE_HAS_BODY, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_PROPERTIES:
                        // One item is selected
                        if (hwndFocus == m_ctlList)
                        {
                            if (cSel == 1 && _IsSelectedMessage(ROW_STATE_HAS_BODY, TRUE, FALSE))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        else
                        {
                            // If we're in OE we can assume that any children of our 
                            // parent is either us or the preview pane.
                            if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            else
                                prgCmds[i].cmdf = 0;
                        }
                        break;

                    case ID_COPY:
                        // One item is selected and it has it's body, and the focus is in 
                        // the ListView
                        if ((hwndFocus == m_ctlList) && (iSel != -1) && (cSel == 1) && _IsSelectedMessage(ROW_STATE_HAS_BODY, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        else
                        {
                            // Do this so the preview pane get's it.
                            if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
                                prgCmds[i].cmdf = 0;
                        }
                        break;

                    case ID_SELECT_ALL:
                    {
                        DWORD cItems = 0;

                        // The focus must be in the ListView or TreeView and there 
                        // must be items.
                        cItems = ListView_GetItemCount(m_ctlList);

                        if (hwndFocus == m_ctlList)
                        {
                            if (cItems > 0 && ListView_GetSelectedCount(m_ctlList) != cItems)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        else
                        {
                            if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
                                prgCmds[i].cmdf = 0;
                        }
                        break;
                    }

                    case ID_PURGE_DELETED:
                        // only available for IMAP
                        prgCmds[i].cmdf = (GetFolderType(m_idFolder) == FOLDER_IMAP) ? OLECMDF_SUPPORTED|OLECMDF_ENABLED:OLECMDF_SUPPORTED;
                        break;

                    case ID_MOVE_TO_FOLDER:
                        // The current folder cannot be a newsgroup.
                        if (GetFolderType(m_idFolder) != FOLDER_NEWS && cSel != 0)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_COPY_TO_FOLDER:
                        // Something must be selected
                        if (cSel)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;
                 
                    case ID_DELETE:
                    case ID_DELETE_NO_TRASH:
                        // Some of the selected items aren't already deleted
#if 0
                        if (GetFolderType(m_idFolder) != FOLDER_NEWS && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
#endif
                        if (_IsSelectionDeletable() && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_UNDELETE:
                        // Some of the selected items are deleted
                        if ((m_fFindFolder || GetFolderType(m_idFolder) == FOLDER_IMAP) && fItemFocus && 
                            _IsSelectedMessage(ROW_STATE_DELETED, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_FIND_NEXT:
                    case ID_FIND_IN_FOLDER:
                        // There must be something here
                        if (ListView_GetItemCount(m_ctlList))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;
            
                    case ID_SORT_ASCENDING:
                        // Make sure the right one is radio-buttoned
                        m_cColumns.GetSortInfo(&idSort, &fAscending);
                        if (fAscending)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_SORT_DESCENDING:
                        // All of these items always work
                        m_cColumns.GetSortInfo(&idSort, &fAscending);
                        if (!fAscending)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_COLUMNS:
                    case ID_POPUP_SORT:
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_EXPAND:
                        // Expand will only be enabled if the selected item is
                        // expandable, and only if one item is selected.
                        if (cSel == 1 && m_fThreadMessages && iSel != -1)
                        {
                            if (SUCCEEDED(m_pTable->GetRowState(iSel, ROW_STATE_HAS_CHILDREN | ROW_STATE_EXPANDED, &dwState)))
                            {
                                if ((dwState & ROW_STATE_HAS_CHILDREN) && !(dwState & ROW_STATE_EXPANDED))
                                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            }
                        }
                        break;

                    case ID_COLLAPSE:
                        // Collapse is enabled if the selected item is collapsable and
                        // there is only one item selected.
                        if (cSel == 1 && m_fThreadMessages && iSel != -1)
                        {
                            if (SUCCEEDED(m_pTable->GetRowState(iSel, ROW_STATE_HAS_CHILDREN | ROW_STATE_EXPANDED, &dwState)))
                            {
                                if ((dwState & ROW_STATE_HAS_CHILDREN) && (dwState & ROW_STATE_EXPANDED))
                                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            }
                        }
                        break;

                    case ID_NEXT_MESSAGE:
                        // There must be an item focused and the focused item must not be the last item 
                        if ((-1 != iFocus) && (iSel < ListView_GetItemCount(m_ctlList) - 1))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_PREVIOUS:
                        // There must be a focused item and it cannot be the first item
                        if (0 < iFocus)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_NEXT_UNREAD_MESSAGE:
                        // There must be a focused item
                        if (iFocus != -1 /* && (iFocus < ListView_GetItemCount(m_ctlList) - 1) */ )
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_NEXT_UNREAD_THREAD:
                        // There must be a focused item and we must be threaded
                        if ((-1 != iFocus) && m_fThreadMessages /* && (iFocus < ListView_GetItemCount(m_ctlList) - 1) */ )
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_STOP:
                        // We must have a stop callback
                        if (m_pCancel)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_FLAG_MESSAGE:
                        // At least one item must be selected
                        if (cSel != 0)
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                              
                            if (iFocus != -1)
                            {
                                m_pTable->GetRowState(iFocus, ROW_STATE_FLAGGED, &dwState);
                                if (dwState & ROW_STATE_FLAGGED)
                                    prgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }             
                        }
                        break;

                    case ID_MARK_READ:
                        // Some of the selected items are unread
                        if (_IsSelectedMessage(ROW_STATE_READ, FALSE, FALSE) && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_UNREAD:
                        // Some of the selected items are read
                        if (_IsSelectedMessage(ROW_STATE_READ, TRUE, FALSE) && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_ALL_READ:
                        // Must have items in the view that are unread
                        if (ListView_GetItemCount(m_ctlList) > 0)
                        {
                            DWORD dwCount = 0; 

                            if (m_pTable && SUCCEEDED(m_pTable->GetCount(MESSAGE_COUNT_UNREAD, &dwCount)) && dwCount)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        break;

                    case ID_MARK_RETRIEVE_ALL:
                        // Must have items in the view
                        if (GetFolderType(m_idFolder) != FOLDER_LOCAL && ListView_GetItemCount(m_ctlList) > 0)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_POPUP_RETRIEVE:
                        // Always there except local
                        if (GetFolderType(m_idFolder) != FOLDER_LOCAL)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_UNMARK_MESSAGE:
                        if (cSel >= 1 && 
                            _IsSelectedMessage(ROW_STATE_MARKED_DOWNLOAD, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_RETRIEVE_MESSAGE:
                        // Something must be selected that is not downloaded and does
                        // not already have a body.
                        if (cSel >= 1 && 
                            _IsSelectedMessage(ROW_STATE_MARKED_DOWNLOAD | ROW_STATE_HAS_BODY, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_THREAD_READ:
                        // The focus is in the listview or preview pane and one item 
                        // is selected. 
                        if (m_fThreadMessages&& 1 == cSel  /* &&
                            _IsSelectedMessage(ROW_STATE_READ, FALSE, FALSE, TRUE) */)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_WATCH_THREAD:
                        // At least one item must be selected
                        if (cSel > 0)
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                              
                            if (iFocus != -1)
                            {
                                m_pTable->GetRowState(iFocus, ROW_STATE_WATCHED, &dwState);
                                if (dwState & ROW_STATE_WATCHED)
                                    prgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }             
                        }
                        break;

                    case ID_IGNORE_THREAD:
                        // At least one item must be selected
                        if (cSel > 0)
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                              
                            if (iFocus != -1)
                            {
                                m_pTable->GetRowState(iFocus, ROW_STATE_IGNORED, &dwState);
                                if (dwState & ROW_STATE_IGNORED)
                                    prgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }             
                        }
                        break;

                    case ID_MARK_RETRIEVE_THREAD:
                        // The focus is in the listview or preview pane and one item 
                        // is selected. 
                        if (m_fThreadMessages && 1 == cSel &&
                            _IsSelectedMessage(ROW_STATE_MARKED_DOWNLOAD | ROW_STATE_HAS_BODY, FALSE, FALSE, TRUE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_REFRESH_INNER:
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_GET_HEADERS:
                        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    default:
                        prgCmds[i].cmdf = 0;
                }
            }
        }
    }

    return (S_OK);
}

                                           
STDMETHODIMP CMessageList::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                                VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    // Verify these commands are ones that we support
    if (pguidCmdGroup && (*pguidCmdGroup != CMDSETID_OutlookExpress))
        return (OLECMDERR_E_UNKNOWNGROUP);

    // Check first to see if this is our sort menu
    if (nCmdID >= ID_SORT_MENU_FIRST && nCmdID < (ID_SORT_MENU_FIRST + m_cSortItems))
    {
        DWORD rgOrder[COLUMN_MAX];
        DWORD cOrder;

        // Get the count of columns in the header
        HWND hwndHeader = ListView_GetHeader(m_ctlList);
        cOrder = Header_GetItemCount(hwndHeader);

        // The columns might have been reordered by the user, so get the order 
        // arrray from the ListView
        ListView_GetColumnOrderArray(m_ctlList, cOrder, rgOrder);

        _OnColumnClick(rgOrder[nCmdID - ID_SORT_MENU_FIRST], LIST_SORT_DEFAULT);
        return (S_OK);
    }

    // Dispatch the commands appropriately
    switch (nCmdID)
    {
        case ID_SAVE_AS:
            return CmdSaveAs(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_PROPERTIES:
            return CmdProperties(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COPY:
            return CmdCopyClipboard(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_SELECT_ALL:
            return CmdSelectAll(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_PURGE_DELETED:
            return CmdPurgeFolder(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_MOVE_TO_FOLDER:
        case ID_COPY_TO_FOLDER:
            // We don't know where user wants to put message, so
            // set pvaIn param to NULL
            return CmdMoveCopy(nCmdID, nCmdExecOpt, NULL, pvaOut);

        case ID_DELETE:
        case ID_DELETE_NO_TRASH:
        case ID_UNDELETE:
            return CmdDelete(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_FIND_NEXT:
            return CmdFindNext(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
            
        case ID_FIND_IN_FOLDER:
            return CmdFind(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_SORT_ASCENDING:
        case ID_SORT_DESCENDING:
            return CmdSort(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COLUMNS:
            return CmdColumnsDlg(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_EXPAND:
        case ID_COLLAPSE:
            return CmdExpandCollapse(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_NEXT_MESSAGE:
        case ID_PREVIOUS:
        case ID_NEXT_UNREAD_MESSAGE:
        case ID_NEXT_UNREAD_THREAD:
            return CmdGetNextItem(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_STOP:
            return CmdStop(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_FLAG_MESSAGE:
        case ID_MARK_READ:
        case ID_MARK_UNREAD:
        case ID_MARK_ALL_READ:
        case ID_MARK_RETRIEVE_ALL:
        case ID_MARK_RETRIEVE_MESSAGE:
        case ID_UNMARK_MESSAGE:
            return CmdMark(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_WATCH_THREAD:
        case ID_IGNORE_THREAD:
            return CmdWatchIgnore(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_MARK_THREAD_READ:
        case ID_MARK_RETRIEVE_THREAD:
            return CmdMarkTopic(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REFRESH_INNER:
            return CmdRefresh(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_GET_HEADERS:
            return CmdGetHeaders(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_RESYNCHRONIZE:
            return Resynchronize();

        case ID_SPACE_ACCEL:
            return CmdSpaceAccel(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
    }

    return (OLECMDERR_E_NOTSUPPORTED);
}


//
//  FUNCTION:   CMessageList::SetFolder()
//
//  PURPOSE:    Tells the Message List to view the contents of the specified 
//              folder.
//
//  PARAMETERS: 
//      [in] tyStore
//      [in] pAccountId
//      [in] pFolderId
//      [in] pSync
//
STDMETHODIMP CMessageList::SetFolder(FOLDERID idFolder, IMessageServer *pServer,
                                     BOOL fSubFolders, FINDINFO *pFindInfo, 
                                     IStoreCallback *pCallback)
{
    HRESULT           hr = S_OK;
    IServiceProvider *pSP=NULL;
    ULONG             ulDisplay;
    DWORD             dwChunks, dwPollInterval;
    COLUMN_ID         idSort;
    BOOL              fAscending;
    FOLDERINFO        fiFolderInfo;
    FOLDERSORTINFO    SortInfo;
    IMessageFolder   *pFolder;
    FOLDERUSERDATA    UserData = {0};

    TraceCall("CMessageList::SetFolder");

    // If we already have a message table, release it.
    if (m_pTable)
    {
        // Unload the ListView
        if (IsWindow(m_ctlList))
        {
            ListView_UnSelectAll(m_ctlList);
            ListView_SetItemCount(m_ctlList, 0);
        }
        m_pTable->ConnectionRelease();
        m_pTable->Close();
        m_pTable->Release();
        m_pTable = NULL;
    }

    // If the caller passed FOLDERID_INVALID, then we don't load a new table
    if (idFolder == FOLDERID_INVALID)
        goto exit;

    // Create a Message Table
    IF_NULLEXIT(m_pTable = new CMessageTable);

    // Tell the table which folder to look at
    if (FAILED(hr = m_pTable->Initialize(idFolder, pServer, pFindInfo ? TRUE : FALSE, this)))
    {
        m_pTable->Release();
        m_pTable = 0;
        goto exit;
    }

    m_pTable->ConnectionAddRef();
    m_pTable->SetOwner(this);

    // Command Target ?
    if (FAILED(m_pTable->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)))
        goto exit;

    // Get the IMessageFolder from the Table
    if (FAILED(pSP->QueryService(IID_IMessageFolder, IID_IMessageFolder, (LPVOID *)&pFolder)))
        goto exit;
        
    // Get the user data to get the filter id
    if (FAILED(pFolder->GetUserData(&UserData, sizeof(FOLDERUSERDATA))))
        goto exit;

    m_ridFilter = UserData.ridFilter;

    // If this is a find, then get the folder id from the table
    if (pFindInfo)
    {
        // Get the Real folder id
        pFolder->GetFolderId(&m_idFolder);
    }
    // Otherwise, just use id idFolder
    else
    {
        // Hang on to this
        m_idFolder = idFolder;
    }

    // Release pFolder
    pFolder->Release();
        
    hr = g_pStore->GetFolderInfo(m_idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {   
        m_fJunkFolder = (FOLDER_LOCAL == fiFolderInfo.tyFolder) && (FOLDER_JUNK == fiFolderInfo.tySpecial);
        m_fMailFolder = (FOLDER_LOCAL == fiFolderInfo.tyFolder) || (FOLDER_IMAP == fiFolderInfo.tyFolder) || (FOLDER_HTTPMAIL == fiFolderInfo.tyFolder);
        m_fGroupSubscribed = !!(fiFolderInfo.dwFlags & FOLDER_SUBSCRIBED);
        g_pStore->FreeRecord(&fiFolderInfo);
    }
    else
        m_fMailFolder = FALSE;

    // Set up our columns
    m_fFindFolder = pFindInfo != 0;
    _SetColumnSet(m_idFolder, m_fFindFolder);

    // Set Sort Information
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Tell the table to change its sort order
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);
    
    // Register Notify
    m_pTable->RegisterNotify(REGISTER_NOTIFY_NOADDREF, (IMessageTableNotify *) this);

    // Get the new count of items in the table
    m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &ulDisplay);

    // Tell the ListView about it
    ListView_SetItemCountEx(m_ctlList, ulDisplay, LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);

    if (m_fThreadMessages)
        ListView_SetImageList(m_ctlList, GetImageList(GIML_STATE), LVSIL_STATE);
    else
        ListView_SetImageList(m_ctlList, NULL, LVSIL_STATE);

    // Tell the table to go sync any headers from the server
    if (GetFolderType(m_idFolder) == FOLDER_NEWS)
    {
        if (OPTION_OFF != m_dwGetXHeaders)
            hr = m_pTable->Synchronize(SYNC_FOLDER_XXX_HEADERS | SYNC_FOLDER_NEW_HEADERS, m_dwGetXHeaders, this);
        else
            hr = m_pTable->Synchronize(NOFLAGS, 0, this);
    }
    else
    {
        hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
    }

    // Check to see if we need to put up the empty list warning.
    if (!pFindInfo && 0 == ulDisplay && ((FAILED(hr) && hr != E_PENDING) || hr == S_FALSE))
    {
        m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
    }

    // Set any options
    //_FilterView(m_ridFilter);
    
    // Update the focused item
    _SelectDefaultRow();

    // Update the status
    Fire_OnMessageCountChanged(m_pTable);
    
    // Send the update notification
    Fire_OnFilterChanged(m_ridFilter);

    // Tell the table which folder to look at
    if (pFindInfo)
    {
        // Execute the find
        m_pTable->StartFind(pFindInfo, pCallback);
    }

    if (m_dwPollInterval != OPTION_OFF)
    {
        FOLDERTYPE  ftFolderType;

        ftFolderType = GetFolderType(m_idFolder);
        if (FOLDER_NEWS == ftFolderType || FOLDER_IMAP == ftFolderType)
        {
            if (_PollThisAccount(m_idFolder))
            {
                Assert(m_dwPollInterval);
                UpdateConnInfo();
                SetTimer(IDT_POLLMSGS_TIMER, m_dwPollInterval, NULL);
            }
        }
    }

exit:
    SafeRelease(pSP);
    return (hr);
}


//
//  FUNCTION:   CMessageList::GetSelected()
//
//  PURPOSE:    Returns an array of all the selected rows.
//
//  PARAMETERS: 
//      [out] pcSelected - Pointer to the number of items in prgSelected
//      [out] prgSelected - Array containing the rows that are selected
//
//  RETURN VALUE:
//      
//
STDMETHODIMP CMessageList::GetSelected(DWORD *pdwFocused, DWORD *pcSelected, DWORD **prgSelected)
{
    TraceCall("CMessageList::GetSelected");

    // If one is focused, do that first
    if (pdwFocused)
        *pdwFocused = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);

    // First determine how many are selected
    if (pcSelected)
    {
        *pcSelected = ListView_GetSelectedCount(m_ctlList);

        if (prgSelected)
        {
            // If nothing is selected, bail
            if (*pcSelected == 0)
            {
                *prgSelected = NULL;
                return (S_OK);
            }

            // Allocate an array for the selected rows
            if (!MemAlloc((LPVOID *) prgSelected, (sizeof(DWORD) * (*pcSelected))))
                return (E_OUTOFMEMORY);
        
            DWORD *pRow = *prgSelected;

            // Loop through all the selected rows
            int iRow = -1;
            while (-1 != (iRow = ListView_GetNextItem(m_ctlList, iRow, LVNI_SELECTED)))
            {
                *pRow = iRow;
                pRow++;
            }
        }
    }
    
    return S_OK;
}


//
//  FUNCTION:   CMessageList::GetSelectedCount()
//
//  PURPOSE:    Allows the caller to retrieve the number of selected rows in
//              the ListView.
//
//  PARAMETERS: 
//      [out] pdwCount - Returns the number of selected rows.
//
//  RETURN VALUE:
//      S_OK, E_INVALIDARG 
//
STDMETHODIMP CMessageList::GetSelectedCount(DWORD *pdwCount)
{
    TraceCall("CMessageList::GetSelectedCount");

    if (!pdwCount)
        return (E_INVALIDARG);

    *pdwCount = ListView_GetSelectedCount(m_ctlList);
    return S_OK;
}


//
//  FUNCTION:   CMessageList::SetViewOptions()
//
//  PURPOSE:    Allows the caller to set various options that control how
//              we display the list of messages.
//
//  PARAMETERS: 
//      [in] pOptions - Struct containing the settings the caller want's 
//                      changed.
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::SetViewOptions(FOLDER_OPTIONS *pOptions)
{
    BOOL fUpdateSort = FALSE;

    TraceCall("CMessageList::SetViewOptions");

    if (!pOptions || pOptions->cbSize != sizeof(FOLDER_OPTIONS))
        return (E_INVALIDARG);

    // Thread Messages
    if (pOptions->dwMask & FOM_THREAD)
    {
        if (m_fThreadMessages != pOptions->fThread)
        {
            m_fThreadMessages = pOptions->fThread;
        }
    }

    // Auto Expand Threads
    if (pOptions->dwMask & FOM_EXPANDTHREADS)
    {
        // Only set this if the value is different
        if (pOptions->fExpandThreads != m_fAutoExpandThreads)
        {
            // Save the setting
            m_fAutoExpandThreads = !!pOptions->fExpandThreads;
            fUpdateSort = TRUE;        
        }    
    }

    // Select first unread message 
    if (pOptions->dwMask & FOM_SELECTFIRSTUNREAD)
    {
        if (m_fSelectFirstUnread != pOptions->fSelectFirstUnread)
        {
            // Save the value.  We don't change any selection however.
            m_fSelectFirstUnread = pOptions->fSelectFirstUnread;
        }
    }

    // Message List Tips
    if (pOptions->dwMask & FOM_MESSAGELISTTIPS)
    {
#ifdef OLDTIPS
        m_fViewTip = pOptions->fMessageListTips;
#endif // OLDTIPS
        m_fScrollTip = pOptions->fMessageListTips;
    }

    // Watched message color
    if (pOptions->dwMask & FOM_COLORWATCHED)
    {
        m_clrWatched = pOptions->clrWatched;
        m_ctlList.InvalidateRect(0, 0);
    }

    // Download chunks
    if (pOptions->dwMask & FOM_GETXHEADERS)
    {
        m_dwGetXHeaders = pOptions->dwGetXHeaders;
    }

    // Show Deleted messages
    if (pOptions->dwMask & FOM_SHOWDELETED)
    {
        m_fShowDeleted = pOptions->fDeleted;
    }

    // Show Deleted messages
    if (pOptions->dwMask & FOM_SHOWREPLIES)
    {
        m_fShowReplies = m_fThreadMessages ? pOptions->fReplies : FALSE;
    }

    if (fUpdateSort)
    {
        if (m_pTable)
        {
            COLUMN_ID idSort;
            BOOL fAscending;
            FOLDERSORTINFO SortInfo;

            // Get the current sort information
            m_cColumns.GetSortInfo(&idSort, &fAscending);

            // Get the current selection
            DWORD iSel = ListView_GetFirstSel(m_ctlList);

            // Bookmark the current selection
            MESSAGEID idSel = 0;
            if (iSel != -1)
                m_pTable->GetRowMessageId(iSel, &idSel);

            // Fill a SortInfo
            SortInfo.idColumn = idSort;
            SortInfo.fAscending = fAscending;
            SortInfo.fThreaded = m_fThreadMessages;
            SortInfo.fExpandAll = m_fAutoExpandThreads;
            SortInfo.ridFilter = m_ridFilter;
            SortInfo.fShowDeleted = m_fShowDeleted;
            SortInfo.fShowReplies = m_fShowReplies;

            // Update the message list
            m_pTable->SetSortInfo(&SortInfo, this);

            // Make sure the filter got set correctly
            _DoFilterCheck(SortInfo.ridFilter);
            
            // Reset the list view
            _ResetView(idSel);
        }

        // Update the count of items 
        _UpdateListViewCount();
    }

    if (pOptions->dwMask & FOM_POLLTIME)
    {
        if (pOptions->dwPollTime != m_dwPollInterval)
        {
            FOLDERTYPE  ftFolderType;

            ftFolderType = GetFolderType(m_idFolder);

            if (m_pTable != NULL &&
                ((ftFolderType == FOLDER_NEWS) || (ftFolderType == FOLDER_IMAP)))
            {
                if (pOptions->dwPollTime == OPTION_OFF)
                {
                    KillTimer(IDT_POLLMSGS_TIMER);
                }
                else
                {
                    Assert(pOptions->dwPollTime != 0);
                    SetTimer(IDT_POLLMSGS_TIMER, pOptions->dwPollTime, NULL);
                }
            }

            m_dwPollInterval = pOptions->dwPollTime;
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::GetViewOptions()
//
//  PURPOSE:    Allows the caller to get various options that control how
//              we display the list of messages.
//
//  PARAMETERS: 
//      [in] pOptions - Struct containing the settings the caller want's 
//                      changed.
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::GetViewOptions(FOLDER_OPTIONS *pOptions)
{
    BOOL fUpdateSort = FALSE;

    TraceCall("CMessageList::GetViewOptions");

    if (!pOptions || pOptions->cbSize != sizeof(FOLDER_OPTIONS))
        return (E_INVALIDARG);

    // Thread Messages
    if (pOptions->dwMask & FOM_THREAD)
        pOptions->fThread = m_fThreadMessages;

    // Auto Expand Threads
    if (pOptions->dwMask & FOM_EXPANDTHREADS)
        pOptions->fExpandThreads = m_fAutoExpandThreads;

    // Select first unread message 
    if (pOptions->dwMask & FOM_SELECTFIRSTUNREAD)
        pOptions->fSelectFirstUnread = m_fSelectFirstUnread;

    // Message List Tips
    if (pOptions->dwMask & FOM_MESSAGELISTTIPS)
        pOptions->fMessageListTips = m_fViewTip;

    // Watched message color
    if (pOptions->dwMask & FOM_COLORWATCHED)
        pOptions->clrWatched = m_clrWatched;

    // Download chunks
    if (pOptions->dwMask & FOM_GETXHEADERS)
        pOptions->dwGetXHeaders = m_dwGetXHeaders;

    // Show Deleted messages
    if (pOptions->dwMask & FOM_SHOWDELETED)
        pOptions->fDeleted = m_fShowDeleted;

    // Show Replies messages
    if (pOptions->dwMask & FOM_SHOWREPLIES)
        pOptions->fReplies = m_fShowReplies;

    return (S_OK);
}

HRESULT CMessageList::GetRowFolderId(DWORD dwRow, LPFOLDERID pidFolder)
{
    HRESULT hr;

    TraceCall("CMessageList::GetRowFolderId");

    if (!pidFolder || !m_pTable)
        return (E_INVALIDARG);

    hr = m_pTable->GetRowFolderId(dwRow, pidFolder);
    return (hr);
}

//
//  FUNCTION:   CMessageList::GetMessageInfo()
//
//  PURPOSE:    Allows the caller to retreive the message header information
//              for a particular row.
//
//  PARAMETERS: 
//      [in]  dwRow - Row the caller is interested in
//      [out] pMsgInfo - Returned structure containing the information
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageList::GetMessageInfo(DWORD dwRow, MESSAGEINFO **ppMsgInfo)
{
    HRESULT hr;

    TraceCall("CMessageList::GetMessageInfo");

    if (!ppMsgInfo || !m_pTable)
        return (E_INVALIDARG);

    hr = m_pTable->GetRow(dwRow, ppMsgInfo);
    return (hr);
}

HRESULT CMessageList::MarkMessage(DWORD dwRow, MARK_TYPE mark)
{
    HRESULT hr;

    TraceCall("CMessageList::MarkMessage");

    if (!m_pTable)
        return (E_INVALIDARG);

    hr = m_pTable->Mark(&dwRow, 1, APPLY_SPECIFIED, mark, this);
    return (hr);
}

HRESULT CMessageList::FreeMessageInfo(MESSAGEINFO *pMsgInfo)
{
    TraceCall("CMessageList::FreeMessageInfo");

    if (!pMsgInfo || !m_pTable)
        return (E_INVALIDARG);

    return m_pTable->ReleaseRow(pMsgInfo);
}

//
//  FUNCTION:   CMessageList::GetSelectedMessage()
//
//  PURPOSE:    Returns the contents of the selected message.
//
//  PARAMETERS: 
//      [out] ppMsg - 
//      [in] pfMarkRead
//      BOOL fDownload
//      LONG * pidErr
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::GetMessage(DWORD dwRow, BOOL fDownload, BOOL fBookmark, IUnknown ** ppMsg)
{
    DWORD   iSel=dwRow;
    BOOL    fCached;
    HRESULT hr = E_FAIL;
    DWORD   dwState;
    DWORD   flags = 0;
    IMimeMessage *pMessage = 0;

    TraceCall("CMessageList::GetSelectedMessage");

    if (!ppMsg)
        return (E_INVALIDARG);

    // If we don't have a table, this will be really hard.
    if (!m_pTable)
        return (E_UNEXPECTED);

    // Initialize these
    *ppMsg = NULL;

    // Get the row state to see if it already has a body or not
    m_pTable->GetRowState(dwRow, ROW_STATE_HAS_BODY | ROW_STATE_READ, &dwState);

    // If the row does not have a body and we're not allowed to download the
    // message, then we bail.
    if ((ROW_STATE_HAS_BODY != (dwState & ROW_STATE_HAS_BODY)) && !fDownload)
    {
        return (STORE_E_NOBODY);
    }

    // Try to retrieve the message
    hr = m_pTable->OpenMessage(dwRow, 0, &pMessage, 
                               (IStoreCallback *) this);
    if (pMessage)
        pMessage->QueryInterface(IID_IUnknown, (LPVOID *) ppMsg);

    // If the caller wanted us to bookmark this row, do it
    if (FAILED(m_pTable->GetRowMessageId(ListView_GetFocusedItem(m_ctlList), &m_idGetMsg)))
        m_idGetMsg = 0;

    SafeRelease(pMessage);
    return (hr);
}


//
//  FUNCTION:   CMessageList::OnClose()
//
//  PURPOSE:    Called to tell the list to persist it's settings.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageList::OnClose(void)
{
    FOLDERINFO info;
    HRESULT hr;
    char sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];

    if (Header_GetItemCount(ListView_GetHeader(m_ctlList)))
    {
        // Save the column set only if there are columns in the listview
        m_cColumns.Save(0, 0);
    }
    
    hr = g_pStore->GetFolderInfo(m_idFolder, &info);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder == FOLDER_NEWS)
        {
            if (0 == (info.dwFlags & FOLDER_SUBSCRIBED) && !m_fGroupSubscribed)
            {
                AthLoadString(idsWantToSubscribe, sz, ARRAYSIZE(sz));
                wnsprintf(szT, ARRAYSIZE(szT), sz, info.pszName);

                if (IDYES == DoDontShowMeAgainDlg(m_hWnd, c_szRegAskSubscribe, MAKEINTRESOURCE(idsAthena), szT, MB_YESNO))
                {
                    g_pStore->SubscribeToFolder(m_idFolder, TRUE, NOSTORECALLBACK);
                }
            }

            // If this is a newsgroup, and the user has the option to "Mark All Read when ...",
            // then mark everything read
            if (DwGetOption(OPT_MARKALLREAD))
            {
                if (m_pTable)
                    m_pTable->Mark(NULL, 0, APPLY_SPECIFIED, MARK_MESSAGE_READ, this);
            }
        }

        g_pStore->FreeRecord(&info);
    }

    if (m_pTable)
    {
        IServiceProvider *pService;

        m_pTable->UnregisterNotify((IMessageTableNotify *)this);

        if (SUCCEEDED(m_pTable->QueryInterface(IID_IServiceProvider, (void **)&pService)))
        {
            IIMAPStore *pIMAPStore;

            if (SUCCEEDED(pService->QueryService(SID_MessageServer, IID_IIMAPStore, (void **)&pIMAPStore)))
            {
                pIMAPStore->ExpungeOnExit();
                pIMAPStore->Release();
            }

            pService->Release();
        }
    }

    // Release our view pointer
    SafeRelease(m_pCmdTarget);

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::SetRect()
//
//  PURPOSE:    Allows the caller to position the control window.
//
//  PARAMETERS: 
//      RECT rc
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::SetRect(RECT rc)
{
    TraceCall("CMessageList::SetRect");

    if (IsWindow(m_hWnd))
    {
        // Update the position of our window
        SetWindowPos(NULL, rc.left, rc.top, rc.right, rc.bottom, SWP_NOACTIVATE | SWP_NOZORDER);
    }
    return S_OK;
}


//
//  FUNCTION:   CMessageList::GetRect()
//
//  PURPOSE:    Allows the caller to get the position of the outer control window.
//
//  PARAMETERS: 
//      [out] prcList - contains the position of the window if visible.
//
STDMETHODIMP CMessageList::GetRect(LPRECT prcList)
{
    TraceCall("CMessageList::GetRect");

    // Make sure the caller gave us a return value pointer
    if (!prcList)
        return (E_INVALIDARG);

    // If the window exists
    if (IsWindow(m_hWnd))
    {
        // Get the rect for it
        GetWindowRect(prcList);
        return (S_OK);
    }

    return (E_FAIL);
}


STDMETHODIMP CMessageList::MarkRead(BOOL fBookmark, DWORD dwRow)
{
    ROWINDEX iRow = -1;
    HRESULT  hr = S_OK;
    DWORD    dwState = 0;

    // Figure out which row to mark
    if (fBookmark)
        hr = m_pTable->GetRowIndex(m_idGetMsg, &iRow);
    else
        iRow = dwRow;

    if (SUCCEEDED(hr))
    {
        // Check to see if the message is actually unread
        if (SUCCEEDED(m_pTable->GetRowState(iRow, ROW_STATE_READ, &dwState)))
        {
            if ((ROW_STATE_READ & dwState) == 0)
            {
                hr = m_pTable->Mark(&iRow, 1, APPLY_SPECIFIED, MARK_MESSAGE_READ, this);

                if (m_fInOE && m_fMailFolder && NULL != g_pInstance)
                    g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
            }
        }
    }
    return (hr);
}

STDMETHODIMP CMessageList::ProcessReceipt(IMimeMessage *pMessage)
{
    ROWINDEX iRow = -1;
    HRESULT  hr = S_OK;
    DWORD    dwState = 0;

    hr = m_pTable->GetRowIndex(m_idGetMsg, &iRow);
    if (SUCCEEDED(hr))
    {
        ProcessReturnReceipts(m_pTable, (IStoreCallback*)this, iRow, READRECEIPT, m_idFolder, pMessage);
    }
    return (hr);
}

STDMETHODIMP CMessageList::GetMessageTable(IMessageTable **ppTable) 
{
    if (ppTable) 
    {
        *ppTable = m_pTable;
        m_pTable->AddRef();
        return S_OK;
    }

    return E_INVALIDARG;
}


STDMETHODIMP CMessageList::GetListSelector(IListSelector **ppListSelector)
{
    if (ppListSelector) 
    {
        Assert(m_pListSelector);
        *ppListSelector = m_pListSelector;
        m_pListSelector->AddRef();
        return S_OK;
    }

    return E_INVALIDARG;
}


STDMETHODIMP CMessageList::GetMessageCounts(DWORD *pcTotal, DWORD *pcUnread, DWORD *pcOnServer)
{
    if (pcTotal && pcUnread && pcOnServer)
    {
        // If we haven't been initialized with a table yet, everything is zero
        if (!m_pTable)
        {
            *pcTotal = 0;
            *pcUnread = 0;
            *pcOnServer = 0;
        }
        else
        {
            m_pTable->GetCount(MESSAGE_COUNT_ALL, pcTotal);
            m_pTable->GetCount(MESSAGE_COUNT_UNREAD, pcUnread);
            m_pTable->GetCount(MESSAGE_COUNT_NOTDOWNLOADED, pcOnServer);
        }

        return (S_OK);
    }
    
    return (E_INVALIDARG);
}


STDMETHODIMP CMessageList::GetMessageServer(IMessageServer **ppServer)
{
    IServiceProvider *pSP = NULL;
    HRESULT           hr = E_FAIL;

    
    // HACKHACK: BUG #43642. This method is called by the msgview when it is fishing for a server
    // object so that is can reuse the connection. If there is an operation in progress, then we
    // don't want to use this connection as it may take a while to complete, so we fail this
    // and the msgview makes a new server object
    if (m_tyCurrent != SOT_INVALID)
        return E_FAIL;

        if (m_pTable && SUCCEEDED(m_pTable->QueryInterface(IID_IServiceProvider, (LPVOID *) &pSP)))
        {
            hr = pSP->QueryService(SID_MessageServer, IID_IMessageServer, (LPVOID *) ppServer);
            pSP->Release();    
        }
    return (hr);
}


STDMETHODIMP CMessageList::GetFocusedItemState(DWORD *pdwState)
{
    int iFocused;
    
    if (!pdwState)
        return (E_INVALIDARG);

    // Figure out who has the focus
    iFocused = ListView_GetFocusedItem(m_ctlList);

    // It's possible for nothing to be focused
    if (-1 == iFocused)
    {
        iFocused = 0;
        ListView_SetItemState(m_ctlList, iFocused, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    // Check to see if that item is selected
    *pdwState = ListView_GetItemState(m_ctlList, iFocused, LVIS_SELECTED);

    return (S_OK);
}


STDMETHODIMP CMessageList::CreateList(HWND hwndParent, IUnknown *pFrame, HWND *phwndList)
{
    HWND hwnd;
    RECT rcPos = { 0, 0, 10, 10 };

    hwnd = CreateControlWindow(hwndParent, rcPos);
    if (phwndList)
        *phwndList = hwnd;

    // Get the command target from the frame
    Assert(pFrame);

    pFrame->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pCmdTarget);

    // This is only called to create us as part of OE
    m_fInOE = TRUE;

    if (g_pConMan)
    {
        g_pConMan->Advise((IConnectionNotify*)this);
    }

    return (S_OK);
}



//
//  FUNCTION:   CMessageList::OnPreFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache before it changes the fonts we're 
//              using.  In response we tell the ListView to dump any custom 
//              font's it's using.
//
STDMETHODIMP CMessageList::OnPreFontChange(void)
{
    m_ctlList.SendMessage(WM_SETFONT, 0, 0);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnPostFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache after it updates the font's we're
//              using.  In response, we set the new font for the current charset.
//
STDMETHODIMP CMessageList::OnPostFontChange(void)
{
    m_hCharset = GetListViewCharset();
    SetListViewFont(m_ctlList, m_hCharset, TRUE);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnCreate()
//
//  PURPOSE:    Creates our child control, initializes options on that ListView, 
//              and initializes the columns and font in that ListView.
//
LRESULT CMessageList::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnCreate");

    RECT rcPos = {0, 0, 10, 10};

    // Create the ListView control first
    HWND hwndList;
    hwndList = m_ctlList.Create(m_hWnd, rcPos, "Outlook Express Message List", WS_CHILD | WS_VISIBLE |  
                     WS_TABSTOP | WS_CLIPCHILDREN | LVS_SHOWSELALWAYS |  
                     LVS_OWNERDATA | LVS_SHAREIMAGELISTS | LVS_REPORT |
                     WS_BORDER, WS_EX_CLIENTEDGE);

    if (!hwndList)
        return (-1);


    // Get the listview charset
    m_hCharset = GetListViewCharset();

    // Set the callback mask and image lists
    ListView_SetCallbackMask(m_ctlList, LVIS_STATEIMAGEMASK);
    ListView_SetImageList(m_ctlList, GetImageList(GIML_SMALL), LVSIL_SMALL);
    
    // Set some extended styles
    ListView_SetExtendedListViewStyle(m_ctlList, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_INFOTIP);
    // ListView_SetExtendedListViewStyleEx(m_ctlList, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_INFOTIP | LVS_EX_LABELTIP, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_INFOTIP | LVS_EX_LABELTIP);

    // Initialize the columns class
    m_cColumns.Initialize(m_ctlList, m_ColumnSetType);

    // Set the font for the ListView
    m_ctlList.SendMessage(WM_SETFONT, NULL, 0);
    SetListViewFont(m_ctlList, m_hCharset, TRUE);
 
#ifdef OLDTIPS
    // Create the tooltips second
    m_ctlScrollTip.Create(m_hWnd, rcPos, NULL, TTS_NOPREFIX);

    // Add the tool
    TOOLINFO ti = {0};
    ti.cbSize   = sizeof(TOOLINFO);
    ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd     = m_hWnd;
    ti.uId      = (UINT_PTR)(HWND) m_ctlList;
    ti.lpszText = "";
    
    m_ctlScrollTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM) &ti);

    // Create the ListView tooltip
    if (m_fViewTip)
    {
        m_ctlViewTip.Create(m_hWnd, rcPos, NULL, TTS_NOPREFIX);

        // Add the tool
        ti.cbSize   = sizeof(TOOLINFO);
        ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
        ti.hwnd     = m_hWnd;
        ti.uId      = (UINT_PTR)(HWND) m_ctlList;
        ti.lpszText = "";
        ti.lParam   = 0;

        m_ctlViewTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM) &ti);
        m_ctlViewTip.SendMessage(TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM) 500);

        // m_ctlViewTip.SendMessage(TTM_SETTIPBKCOLOR, GetSysColor(COLOR_WINDOW), 0);
        // m_ctlViewTip.SendMessage(TTM_SETTIPTEXTCOLOR, GetSysColor(COLOR_WINDOWTEXT), 0);
    }
#endif // OLDTIPS

#if 0
    // $REVIEW - Debug create the table 
    ACCOUNTID aid;
    aid.type = ACTID_NAME;
    aid.pszName = _T("red-msg-52");

    FOLDERID fid;
    fid.type = FLDID_HFOLDER;
    fid.hFolder = 1;
    SetFolder(STORE_ACCOUNT, &aid, &fid, NULL, NULL);
#endif

    // If there is a global font cache running around, register for
    // notifications.
    if (g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Advise((IUnknown *)(IFontCacheNotify *) this, &m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    // Do this so we can hand this badboy off to the notes
    m_pListSelector = new CListSelector();
    if (m_pListSelector)
        m_pListSelector->Advise(m_hWnd);

    return (0);
}


LRESULT CMessageList::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Let the base classes have a crack at it
    CComControlBase::OnSetFocus(uMsg, wParam, lParam, bHandled);

    // Make sure the focus is set to the ListView
    m_ctlList.SetFocus();

    return (0);
}


LRESULT CMessageList::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    int iSel;

    // Resize the ListView to fit within the parent window
    if (IsWindow(m_ctlList))
    {
        m_ctlList.SetWindowPos(NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), 
                               SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

        // Make sure the selected item is still visible
        iSel = ListView_GetFocusedItem(m_ctlList);
        if (-1 != iSel)
            ListView_EnsureVisible(m_ctlList, iSel, FALSE);
    }

    return (0);
}


//
//  FUNCTION:   CMessageList::OnNotify()
//
//  PURPOSE:    Processes notification messages from our ListView.
//
LRESULT CMessageList::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    NMHDR            *pnmhdr = (LPNMHDR) lParam;
    NM_LISTVIEW      *pnmlv =  (NM_LISTVIEW *) lParam;
    HD_NOTIFY        *phdn =   (HD_NOTIFY *) lParam;
    LV_KEYDOWN       *plvkd =  (LV_KEYDOWN *) lParam;
    NM_ODSTATECHANGE *pnm =    (PNM_ODSTATECHANGE) lParam;
    NMLVCACHEHINT    *plvch =  (NMLVCACHEHINT *) lParam;

    switch (pnmhdr->code)
    {
        // Send the cache hint's to the message table
        case LVN_ODCACHEHINT:
        {
            //m_pTable->CacheHint(plvch->iFrom, plvch->iTo);
            break;
        }

        // Open the selected items
        case LVN_ITEMACTIVATE:
        {
            // Tell our host to open the selected items
            Fire_OnItemActivate();
            break;
        }

        // This notification is only used for threading.  All activation is 
        // handled by LVN_ITEMACTIVATE and NM_DBLCLK
        case NM_CLICK:
        {
            if (pnmhdr->hwndFrom == m_ctlList)
            {
                DWORD          dwPos;
                LV_HITTESTINFO lvhti;

                // Find out where the click happened
                dwPos = GetMessagePos();
                lvhti.pt.x = (int)(short) LOWORD(dwPos);
                lvhti.pt.y = (int)(short) HIWORD(dwPos);
                m_ctlList.ScreenToClient(&lvhti.pt);

                // Have the ListView tell us what element this was on
                if (-1 != ListView_SubItemHitTest(m_ctlList, &lvhti))
                {
                    if (lvhti.flags & LVHT_ONITEM)
                    {
                        if (m_cColumns.GetId(lvhti.iSubItem) == COLUMN_FLAG)
                        {
                            CmdMark(ID_FLAG_MESSAGE, 0, NULL, NULL);
                            break;
                        }

                        if (m_cColumns.GetId(lvhti.iSubItem) == COLUMN_DOWNLOADMSG)
                        {
                            HRESULT hr;
                            DWORD nCmdID, dwState = 0;

                            hr = m_pTable->GetRowState(lvhti.iItem, ROW_STATE_MARKED_DOWNLOAD, &dwState);
                            Assert(SUCCEEDED(hr));
        
                            if (!!(dwState & ROW_STATE_MARKED_DOWNLOAD))
                                nCmdID = ID_UNMARK_MESSAGE;
                            else
                                nCmdID = ID_MARK_RETRIEVE_MESSAGE;

                            CmdMark(nCmdID, 0, NULL, NULL);
                            break;
                        }
                        
                        if (m_cColumns.GetId(lvhti.iSubItem) == COLUMN_THREADSTATE)
                        {
                            HRESULT hr;
                            DWORD nCmdID, dwState = 0;

                            hr = m_pTable->GetRowState(lvhti.iItem, ROW_STATE_WATCHED, 
                                                       &dwState);
                            Assert(SUCCEEDED(hr));

                            if (0 != (dwState & ROW_STATE_WATCHED))
                            {
                                nCmdID = ID_IGNORE_THREAD;
                            }
                            else
                            {
                                hr = m_pTable->GetRowState(lvhti.iItem, ROW_STATE_IGNORED, &dwState);
                                Assert(SUCCEEDED(hr));

                                if (0 != (dwState & ROW_STATE_IGNORED))
                                {
                                    nCmdID = ID_IGNORE_THREAD;
                                }
                                else
                                {
                                    nCmdID = ID_WATCH_THREAD;
                                }
                            }
                            
                            CmdWatchIgnore(nCmdID, 0, NULL, NULL);
                            break;
                        }
                    }

                    if (m_fThreadMessages && (lvhti.flags & LVHT_ONITEMSTATEICON) && !(lvhti.flags & LVHT_ONITEMLABEL))
                        _ExpandCollapseThread(lvhti.iItem);
                }
            }

            break;
        }

        // We change the font etc based on the row.
        case NM_CUSTOMDRAW:
        {
            if (pnmhdr->hwndFrom == m_ctlList)
                return _OnCustomDraw((NMCUSTOMDRAW *) pnmhdr);
            break;
        }

        // Check asynchronously if we need to redo our columns.
        case HDN_ENDDRAG:
        {
            PostMessage(MVM_REDOCOLUMNS, 0, 0);
            break;
        }

        // Update our internal column data when columns are resized
        case HDN_ENDTRACK:
        {
            m_cColumns.SetColumnWidth(phdn->iItem, phdn->pitem->cxy);
            break;
        }

        // When the user double clicks on a header divider, we're supposed to
        // autosize that column.
        case HDN_DIVIDERDBLCLICK:
        {
            m_cColumns.SetColumnWidth(phdn->iItem, ListView_GetColumnWidth(m_ctlList, phdn->iItem));
            break;
        }

        // If the keystrokes are either VK_RIGHT or VK_LEFT then we need to 
        // expand or collapse the thread.
        case LVN_KEYDOWN:
        {
            DWORD iNewSel;
            int iSel = ListView_GetFocusedItem(m_ctlList);

            if (plvkd->wVKey == VK_RIGHT)
            {
                if (m_fThreadMessages && iSel != -1 && m_pTable)
                {
                    DWORD dwState;

                    if (SUCCEEDED(m_pTable->GetRowState(iSel, -1, &dwState)))
                    {
                        m_pTable->GetRelativeRow(iSel, RELATIVE_ROW_CHILD, &iNewSel);
                        if (iNewSel != -1)
                            ListView_SelectItem(m_ctlList, iNewSel);
                        break;
                    }
                }
            }

            if (plvkd->wVKey == VK_ADD)
            {
                CmdExpandCollapse(ID_EXPAND, 0, 0, 0);                
                return (TRUE);
            }

            if (plvkd->wVKey == VK_LEFT)
            {
                if (m_fThreadMessages && iSel != -1 && m_pTable)
                {
                    DWORD dwState;

                    if (SUCCEEDED(m_pTable->GetRowState(iSel, -1, &dwState)))
                    {
                        m_pTable->GetRelativeRow(iSel, RELATIVE_ROW_PARENT, &iNewSel);
                        if (iNewSel != -1)
                            ListView_SelectItem(m_ctlList, iNewSel);
                        break;
                    }
                }
            }

            if (plvkd->wVKey == VK_SUBTRACT)
            {
                CmdExpandCollapse(ID_COLLAPSE, 0, 0, 0);                
                return (TRUE);
            }

            break;
        }

        // When the user clicks on a column header, we need to resort on that
        // column.
        case LVN_COLUMNCLICK:
        {
            COLUMN_ID idSort;
            BOOL      fAscending;
            
            // Get the column we're currently sorted on
            m_cColumns.GetSortInfo(&idSort, &fAscending);

            // If the user clicked on the column we're already sorted on, then
            // we toggle the direction
            if (idSort == m_cColumns.GetId(pnmlv->iSubItem))
                _OnColumnClick(pnmlv->iSubItem, LIST_SORT_TOGGLE);
            else
                _OnColumnClick(pnmlv->iSubItem, LIST_SORT_DEFAULT);

            break;
        }

        // When the selection changes, we set a timer so we can update the
        // preview pane once the user stops moving the selection.
        case LVN_ODSTATECHANGED:
        {
            UINT uChanged;
            MESSAGEID idMessage;
            BOOL fChanged;

            // Figure out if it's the selection that changed
            uChanged = pnm->uNewState ^ pnm->uOldState;
            if (uChanged & LVIS_SELECTED)
            {
                idMessage = m_idSelection;

                // Bookmark the currently select row
                int iRow = ListView_GetFocusedItem(m_ctlList);
                m_pTable->GetRowMessageId(iRow, &m_idSelection);

                fChanged = (idMessage != m_idSelection);

                if (fChanged)
                    SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);
            }

            break;
        }

        // If the selection changes we set a timer to delay update the 
        // preview pane.
        case LVN_ITEMCHANGED:
        {
            UINT uChanged;
            MESSAGEID idMessage;
            BOOL fChanged = FALSE;
            DWORD dwState = 0;

            if (pnmlv->uChanged & LVIF_STATE)
            {
                uChanged = pnmlv->uNewState ^ pnmlv->uOldState;
                if (uChanged & LVIS_SELECTED || uChanged & LVIS_FOCUSED)
                {
                    idMessage = m_idSelection;

                    // Check to see if the focused item has selection too
                    int iRow = ListView_GetFocusedItem(m_ctlList);
                    if (-1 != iRow)                    
                        dwState = ListView_GetItemState(m_ctlList, iRow, LVIS_SELECTED);

                    if (dwState)
                    {
                        // Create a bookmark on the newly selected row
                        if (pnmlv->iItem >= 0)
                            m_pTable->GetRowMessageId(pnmlv->iItem, &m_idSelection);

                        // Compare 'em
                        fChanged = (idMessage != m_idSelection);

                        // Set the delay timer
                        if (fChanged)
                            SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);
                    }
                    else
                    {
                        // See if _anything_ is selected
                        if (0 == ListView_GetSelectedCount(m_ctlList))
                        {
                            SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);

                            // Free the previous bookmark
                            if (m_idSelection)
                            {
                                m_idSelection = 0;
                            }
                        }
                    }
                }
            }

            break;
        }

        // Focus changes need to be sent back to the host
        case NM_KILLFOCUS:
        {
            Fire_OnFocusChanged(FALSE);
            break;
        }

        // Focus changes need to be sent back to the host
        case NM_SETFOCUS:
        {
            Fire_OnFocusChanged(TRUE);
            Fire_OnUpdateCommandState();
            break;
        }

        // This is called when the ListView needs information to fill in a 
        // row.
        case LVN_GETDISPINFO:
        {
            _OnGetDisplayInfo((LV_DISPINFO *) pnmhdr);
            break;
        }

        // Prevents drag-selecting things
        case LVN_MARQUEEBEGIN:
            return (1);

        // Start a Drag & Drop operation
        case LVN_BEGINDRAG:
        {
            m_fRtDrag = FALSE;
            _OnBeginDrag(pnmlv);
            break;
        }

        // Start a Drag & Drop operation
        case LVN_BEGINRDRAG:
        {
            m_fRtDrag = TRUE;
            _OnBeginDrag(pnmlv);
            break;
        }
        case LVN_GETINFOTIP:
        {
           OnNotifyGetInfoTip(lParam);
           break;
        }
        // User is typing
        case LVN_ODFINDITEM:
        {
            NMLVFINDITEM *plvfi = (NMLVFINDITEM *) lParam;
            ROWINDEX iNext;

            // Ask the message table to find that next row for us
            if (m_pTable && SUCCEEDED(m_pTable->FindNextRow(plvfi->iStart, plvfi->lvfi.psz,
                                      FINDNEXT_TYPEAHEAD, FALSE, &iNext, NULL)))
                return (iNext);
            else
                return -1;

            break;
        }
    }

    return (0);
}

LRESULT CMessageList::OnNotifyGetInfoTip(LPARAM lParam)
{
    NMLVGETINFOTIP *plvgit = (NMLVGETINFOTIP *) lParam;

    if (plvgit->dwFlags & LVGIT_UNFOLDED)
    {
        // If this is not a messenger item and the text
        // isn't truncated do not display a tooltip.

        plvgit->pszText[0] = L'\0';
    }

    return 0;
}
//
//  FUNCTION:   CMessageList::_OnGetDisplayInfo()
//
//  PURPOSE:    Handles the LVN_GETDISPINFO notification by returning the 
//              appropriate information from the table.
//
void CMessageList::_OnGetDisplayInfo(LV_DISPINFO *plvdi)
{
    LPMESSAGEINFO pInfo;
    COLUMN_ID idColumn;

    TraceCall("CMessageList::_OnGetDisplayInfo");

    // IF we don't have a table object, we can't display information
    if (!m_pTable)
        return;

    // Get the row from the table
    if (FAILED(m_pTable->GetRow(plvdi->item.iItem, &pInfo)))
        return;

    // Convert the iSubItem to a COLUMN_ID
    idColumn = m_cColumns.GetId(plvdi->item.iSubItem);

    // The ListView needs text for this row
    if (plvdi->item.mask & LVIF_TEXT)
    {
        _GetColumnText(pInfo, idColumn, plvdi->item.pszText, plvdi->item.cchTextMax);
    }

    // The ListView needs an image
    if (plvdi->item.mask & LVIF_IMAGE)
    {
        _GetColumnImage(plvdi->item.iItem, plvdi->item.iSubItem, pInfo, idColumn, &(plvdi->item.iImage));
    }

    // The ListView needs the indent level
    if (plvdi->item.mask & LVIF_INDENT)
    {
        if (m_fThreadMessages)
            m_pTable->GetIndentLevel(plvdi->item.iItem, (LPDWORD) &(plvdi->item.iIndent));
        else
            plvdi->item.iIndent = 0;
    }

    // The ListView needs the state image
    if (plvdi->item.mask & LVIF_STATE)
    {
        _GetColumnStateImage(plvdi->item.iItem, plvdi->item.iSubItem, pInfo, plvdi);
    }

    // Free the memory
    m_pTable->ReleaseRow(pInfo);
}


//
//  FUNCTION:   CMessageList::_GetColumnText()
//
//  PURPOSE:    This function looks up the appropriate text for a column in 
//              the requested row.
//
void CMessageList::_GetColumnText(MESSAGEINFO *pInfo, COLUMN_ID idColumn, LPTSTR pszText, DWORD cchTextMax)
{
    Assert(pszText);
    Assert(cchTextMax);

    *pszText = 0;

    switch (idColumn)
    {
        case COLUMN_TO:
            if (pInfo->pszDisplayTo)
                lstrcpyn(pszText, pInfo->pszDisplayTo, cchTextMax);
            break;

        case COLUMN_FROM:
            if (pInfo->pszDisplayFrom)
                lstrcpyn(pszText, pInfo->pszDisplayFrom, cchTextMax);
            break;

        case COLUMN_SUBJECT:
            if (pInfo->pszSubject)
                lstrcpyn(pszText, pInfo->pszSubject, cchTextMax);
            break;

        case COLUMN_RECEIVED:
            if (!!(pInfo->dwFlags & ARF_PARTIAL_RECVTIME))
                CchFileTimeToDateTimeSz(&pInfo->ftReceived, pszText, cchTextMax, DTM_NOTIMEZONEOFFSET | DTM_NOTIME);
            else if (pInfo->ftReceived.dwLowDateTime || pInfo->ftReceived.dwHighDateTime)
                CchFileTimeToDateTimeSz(&pInfo->ftReceived, pszText, cchTextMax, DTM_NOSECONDS);
            break;

        case COLUMN_SENT:
            if (pInfo->ftSent.dwLowDateTime || pInfo->ftSent.dwHighDateTime)
                CchFileTimeToDateTimeSz(&pInfo->ftSent, pszText, cchTextMax, DTM_NOSECONDS);
            break;

        case COLUMN_SIZE:
            AthFormatSizeK(pInfo->cbMessage, pszText, cchTextMax);
            break;

        case COLUMN_FOLDER:
            if (pInfo->pszFolder)
                lstrcpyn(pszText, pInfo->pszFolder, cchTextMax);
            break;

        case COLUMN_ACCOUNT:
            if (pInfo->pszAcctName)
                lstrcpyn(pszText, pInfo->pszAcctName, cchTextMax);
            break;

        case COLUMN_LINES:
            wnsprintf(pszText, cchTextMax, "%lu", pInfo->cLines);
            break;
    }
}


//
//  FUNCTION:   CMessageList::_GetColumnImage()
//
//  PURPOSE:    Figures out the right image to show for a column in the 
//              specified row.
//
void CMessageList::_GetColumnImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, 
                                   COLUMN_ID idColumn, int *piImage)
{
    WORD wIcon = 0;
    DWORD dwState = 0;

    *piImage = -1;

    TraceCall("CMessageList::_GetColumnImage");

    if (!m_pTable)
        return;

    // Get the row state flags
    m_pTable->GetRowState(iRow, -1, &dwState);

    // Column zero always contains the message state (read, etc)
    if (iColumn == 0)
    {
        // Set some basic information first
        if (pInfo->dwFlags & ARF_UNSENT)
            wIcon |= ICONF_UNSENT;
    
        if (0 == (dwState & ROW_STATE_READ))
            wIcon |= ICONF_UNREAD;

        // Voice Mail Messages
        if (pInfo->dwFlags & ARF_VOICEMAIL)
        {
            *piImage = iiconVoiceMail;
            return;
        }

        // News Messages
        if (pInfo->dwFlags & ARF_NEWSMSG)
        {
            if ((pInfo->dwFlags & ARF_ARTICLE_EXPIRED) || (pInfo->dwFlags & ARF_ENDANGERED))
                wIcon |= ICONF_FAILED;
            else if (pInfo->dwFlags & ARF_HASBODY)
                wIcon |= ICONF_HASBODY;
            
            if (pInfo->dwFlags & ARF_SIGNED)
            {
                if (0 == (dwState & ROW_STATE_READ))
                    *piImage = iiconNewsUnreadSigned;
                else 
                    *piImage = iiconNewsReadSigned;

                return;
            }
            
            *piImage = c_rgNewsIconTable[wIcon];
            return;
        }

        // Mail Messages
        if (pInfo->dwFlags & (ARF_ARTICLE_EXPIRED | ARF_ENDANGERED))
        {
            *piImage = iiconMailDeleted;
            return;
        }

        if (!ISFLAGSET(pInfo->dwFlags, ARF_HASBODY))
        {
            *piImage = iiconMailHeader;
            return;
        }
        
        // Look up S/MIME flags
        if (pInfo->dwFlags & ARF_SIGNED)
            wIcon |= ICONF_SIGNED;
        
        if (pInfo->dwFlags & ARF_ENCRYPTED)
            wIcon |= ICONF_ENCRYPTED;

        *piImage = c_rgMailIconTable[wIcon];
        return;
    }

    else if (idColumn == COLUMN_PRIORITY)
    {
        if (IMSG_PRI_HIGH == pInfo->wPriority)
            *piImage = iiconPriHigh;
        else if (IMSG_PRI_LOW == pInfo->wPriority)
            *piImage = iiconPriLow;

        return;
    }

    else if (idColumn == COLUMN_ATTACHMENT)
    {
        if (ARF_HASATTACH & pInfo->dwFlags)
            *piImage = iiconAttach;

        return;
    }

    else if (idColumn == COLUMN_FLAG)
    {
        if (ARF_FLAGGED & pInfo->dwFlags)
            *piImage = iiconFlag;
    }

    else if (idColumn == COLUMN_DOWNLOADMSG)
    {
        if (ARF_DOWNLOAD & pInfo->dwFlags)
            *piImage = iiconDownload;
    }
    
    else if (idColumn == COLUMN_THREADSTATE)
    {
        if (ROW_STATE_WATCHED & dwState)
            *piImage = iiconWatchThread;
        else if (ROW_STATE_IGNORED & dwState)
            *piImage = iiconIgnoreThread;
    }
}


void CMessageList::_GetColumnStateImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, LV_DISPINFO *plvdi)
{
    DWORD dwState = 0;
    int   iIcon = 0;

    if (!m_pTable)
        return;

    if (0 == iColumn)
    {
        if (SUCCEEDED(m_pTable->GetRowState(iRow, -1, &dwState)))
        {
            if (m_fThreadMessages && (dwState & ROW_STATE_HAS_CHILDREN))
            {
                if (dwState & ROW_STATE_EXPANDED)
                    iIcon = iiconStateExpanded + 1;
                else
                    iIcon = iiconStateCollapsed + 1;
            }

            // Replied or forwarded flags
            if (pInfo && (pInfo->dwFlags & ARF_REPLIED))
            {
                plvdi->item.state |= INDEXTOOVERLAYMASK(OVERLAY_REPLY);
                plvdi->item.stateMask |= LVIS_OVERLAYMASK;
            }

            else if (pInfo && (pInfo->dwFlags & ARF_FORWARDED))
            {
                plvdi->item.state |= INDEXTOOVERLAYMASK(OVERLAY_FORWARD);
                plvdi->item.stateMask |= LVIS_OVERLAYMASK;
            }
        }

        plvdi->item.state |= INDEXTOSTATEIMAGEMASK(iIcon);
    }
}


LRESULT CMessageList::_OnCustomDraw(NMCUSTOMDRAW *pnmcd)
{
    FNTSYSTYPE fntType;
    LPMESSAGEINFO pInfo = NULL;    
    DWORD dwState;
    
    // If this is a prepaint notification, we tell the control we're interested
    // in further notfications.
    if (pnmcd->dwDrawStage == CDDS_PREPAINT && m_pTable)
        return (CDRF_NOTIFYITEMDRAW);
    
    // If this is an Item prepaint notification, then we do some work
    if ((pnmcd->dwDrawStage == CDDS_ITEMPREPAINT) || (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM)))
    {
        // Determine the right font for this row
        fntType = _GetRowFont((DWORD)(pnmcd->dwItemSpec));
        
        // We should get the "system" font of the codepage from the Default_Codepage
        // in the registry.
        SelectObject(pnmcd->hdc, HGetCharSetFont(fntType, m_hCharset));
        
        // Figure out if this row is highlighted
        if(SUCCEEDED(m_pTable->GetRow((DWORD)(pnmcd->dwItemSpec), &pInfo)))
        {
            if (pInfo->wHighlight > 0 && pInfo->wHighlight <= 16)
            {
                LPNMLVCUSTOMDRAW(pnmcd)->clrText = rgrgbColors16[pInfo->wHighlight - 1];
                
            }
            else if (SUCCEEDED(m_pTable->GetRowState((DWORD)(pnmcd->dwItemSpec), -1, &dwState)))
            {
                if ((dwState & ROW_STATE_WATCHED) && (m_clrWatched > 0 && m_clrWatched <=16))
                {
                    // If the row already doesn't have a color from a rule, check to see if
                    // it's watched or ignored.
                    LPNMLVCUSTOMDRAW(pnmcd)->clrText = rgrgbColors16[m_clrWatched - 1];
                }
                else if (dwState & ROW_STATE_IGNORED)
                {
                    LPNMLVCUSTOMDRAW(pnmcd)->clrText = GetSysColor(COLOR_GRAYTEXT);
                }
            }
            m_pTable->ReleaseRow(pInfo);
            
            // Do some extra work here to not show the selection on the priority or
            // attachment sub columns.
            if (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT|CDDS_SUBITEM) &&
                (m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_PRIORITY ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_ATTACHMENT ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_FLAG ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_DOWNLOADMSG ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_THREADSTATE))
                pnmcd->uItemState &= ~(CDIS_SELECTED|CDIS_FOCUS);
            return CDRF_NEWFONT|CDRF_NOTIFYSUBITEMDRAW;
        }
        else
            return(CDRF_SKIPDEFAULT);
    }
    
    return (CDRF_DODEFAULT);
}


LRESULT CMessageList::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Need to forward this notifications to our child windows
    if (IsWindow(m_ctlList))
        m_ctlList.SendMessage(uMsg, wParam, lParam);

    return (0);
}


LRESULT CMessageList::OnTimeChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Force the ListView to repaint
    m_ctlList.InvalidateRect(NULL);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnContextMenu()
//
//  PURPOSE:    
//
LRESULT CMessageList::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HMENU       hPopup = 0;
    HWND        hwndHeader;
    int         id = 0;
    POINT       pt = { (int)(short) LOWORD(lParam), (int)(short) HIWORD(lParam) };
    COLUMN_ID   idSort;
    BOOL        fAscending;
    IOleCommandTarget *pTarget = 0;

    TraceCall("CMessageList::OnContextMenu");

    // Figure out if this came from the keyboard or not
    if (lParam == -1)
    {
        Assert((HWND) wParam == m_ctlList);
        int i = ListView_GetFirstSel(m_ctlList);
        if (i == -1)
            return (0);

        ListView_GetItemPosition(m_ctlList, i, &pt);
        m_ctlList.ClientToScreen(&pt);
    }

    // Get the window handle of the header in the ListView
    hwndHeader = ListView_GetHeader(m_ctlList);

    // Check to see if the click was on the header
    if (WindowFromPoint(pt) == hwndHeader)
    {
        HD_HITTESTINFO hht;

        hht.pt = pt;
        ::ScreenToClient(hwndHeader, &hht.pt);
        ::SendMessage(hwndHeader, HDM_HITTEST, 0, (LPARAM) &hht);
        m_iColForPopup = hht.iItem;

        // Popup the context menu
        hPopup = LoadPopupMenu(IDR_COLUMNS_POPUP);
        if (!hPopup)
            goto exit;

        // Disable sort options if it's a bad column
        if (m_iColForPopup == -1 || m_iColForPopup >= COLUMN_MAX)
        {
            EnableMenuItem(hPopup, ID_SORT_ASCENDING, MF_GRAYED | MF_DISABLED);
            EnableMenuItem(hPopup, ID_SORT_DESCENDING, MF_GRAYED | MF_DISABLED);
        }
        else
        {
            // If we've clicked on a column that is sorted, check it
            m_cColumns.GetSortInfo(&idSort, &fAscending);
            if (m_cColumns.GetId(m_iColForPopup) == idSort)
            {
                CheckMenuItem(hPopup, fAscending ? ID_SORT_ASCENDING : ID_SORT_DESCENDING,
                              MF_BYCOMMAND | MF_CHECKED);
            }
        }
    }
    else if ((HWND) wParam == m_ctlList)
    {
        // We clicked on the ListView, or focus is in the listview for keyboard
        // context menu goo.  
        int idMenuRes;
        FOLDERTYPE ty = GetFolderType(m_idFolder);

        if (m_fFindFolder)
            idMenuRes = IDR_FIND_MESSAGE_POPUP;
        else if (ty == FOLDER_LOCAL)
            idMenuRes = IDR_LOCAL_MESSAGE_POPUP;
        else if (ty == FOLDER_IMAP)
            idMenuRes = IDR_IMAP_MESSAGE_POPUP;
        else if (ty == FOLDER_HTTPMAIL)
            idMenuRes = IDR_HTTP_MESSAGE_POPUP;
        else if (ty == FOLDER_NEWS)
            idMenuRes = IDR_NEWS_MESSAGE_POPUP;
        else
        {
            Assert(FALSE);
            return (0);
        }
        
        hPopup = LoadPopupMenu(idMenuRes);
        if (!hPopup)
            goto exit;

        MenuUtil_SetPopupDefault(hPopup, ID_OPEN);

        // Figure out which command target to use
        if (m_pCmdTarget)
            pTarget = m_pCmdTarget;
        else
            pTarget = this;

        MenuUtil_EnablePopupMenu(hPopup, pTarget);
    }

    if (hPopup)
    {
        m_hMenuPopup = hPopup;
        m_ptMenuPopup = pt;
        id = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, m_hwndParent, NULL);
        m_hMenuPopup = NULL;
    }

    if (id)
    {
        if (pTarget)
        {
            pTarget->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }
        else
        {
            // Just route it through ourselves, eh?
            Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }
    }

exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnTimer()
//
//  PURPOSE:    When the timer fires and the selection has changed, we tell
//              the host so they can update the preview pane.
//
LRESULT CMessageList::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnTimer");

    DWORD dwMsgId;
    int   iSel;
    int   iSelOld = -1;

#ifdef OLDTIPS
    if (wParam == IDT_SCROLL_TIP_TIMER)
    {
        Assert(m_fScrollTipVisible);

        if (!GetAsyncKeyState(GetSystemMetrics(SM_SWAPBUTTON) ? VK_RBUTTON : VK_LBUTTON))
        {
            KillTimer(IDT_SCROLL_TIP_TIMER);
            m_fScrollTipVisible = FALSE;

            TOOLINFO ti = { 0 };
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd   = m_hWnd;
            ti.uId    = (UINT_PTR)(HWND) m_ctlList;

            m_ctlScrollTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
        }
    }
    else 
#endif //OLDTIPS
    if (wParam == IDT_SEL_CHANGE_TIMER)
    {
        // Turn this off
        KillTimer(IDT_SEL_CHANGE_TIMER);

        // Check to see if something was bookmarked
        if (m_idSelection)
        {
            // Check to see if the selection has changed
            iSel = ListView_GetSelFocused(m_ctlList);

            // Get the row index from the bookmark
            if (m_pTable)
                m_pTable->GetRowIndex(m_idSelection, (DWORD *) &iSelOld);
            if(!m_fInFire)
            {
                m_fInFire = TRUE;
                Fire_OnSelectionChanged(ListView_GetSelectedCount(m_ctlList));
                m_fInFire = FALSE;
            }
        }
        else
        {
            // If there was no previous selection, go ahead and fire
            // the notification
            if(!m_fInFire)
            {
                m_fInFire = TRUE;
                Fire_OnSelectionChanged(ListView_GetSelectedCount(m_ctlList));
                m_fInFire = FALSE;
            }
        }
    }

    else if (wParam == IDT_POLLMSGS_TIMER)
    {
        if (m_dwConnectState == CONNECTED)
        {
            if (m_pTable)
                m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }

#ifdef OLDTIPS
    else if (wParam == IDT_VIEWTIP_TIMER)
    {
        KillTimer(IDT_VIEWTIP_TIMER);

        POINT pt;
        GetCursorPos(&pt);
        ::ScreenToClient(m_ctlList, &pt);
        _UpdateViewTip(pt.x, pt.y, TRUE);
    }
#endif // OLDTIPS

    return (0);
}


//
//  FUNCTION:   CMessageList::OnRedoColumns()
//
//  PURPOSE:    Asynchronously update the column order.
//
LRESULT CMessageList::OnRedoColumns(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    COLUMN_SET *rgColumns;
    DWORD       cColumns;

    TraceCall("CMessageList::OnRedoColumns");

    // Update the order array from the ListView
    m_cColumns.GetColumnInfo(NULL, &rgColumns, &cColumns);

    // Update the ListView so the order array is always at it's 
    // most efficient and so the image columns are never column zero.
    m_cColumns.SetColumnInfo(rgColumns, cColumns);
    g_pMalloc->Free(rgColumns);            
    return (0);
}


HRESULT CMessageList::OnDraw(ATL_DRAWINFO& di)
{
    RECT& rc = *(RECT*)di.prcBounds;
    Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    DrawText(di.hdcDraw, _T("Outlook Express Message List Control"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    return S_OK;
}


//
//  FUNCTION:   CmdSelectAll()
//
//  PURPOSE:    Selects all of the messages in the ListView.
//
HRESULT CMessageList::CmdSelectAll(DWORD nCmdID, DWORD nCmdExecOpt, 
                                   VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("OnSelectAll");

    // Make sure the focus is in the ListView
    HWND hwndFocus = GetFocus();

    if (!IsWindow(m_ctlList))
        return (OLECMDERR_E_DISABLED);

    if (hwndFocus != m_ctlList)
    {
        if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
            return (OLECMDERR_E_NOTSUPPORTED);
        else
            return (OLECMDERR_E_DISABLED);
    }
    
    // Select everything
    ListView_SelectAll(m_ctlList);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdCopyClipboard()
//
//  PURPOSE:    Copies the selected message to the ClipBoard
//
HRESULT CMessageList::CmdCopyClipboard(DWORD nCmdID, DWORD nCmdExecOpt, 
                                       VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr = S_OK;
    IMimeMessage *pMessage = NULL;
    IDataObject  *pDataObj = NULL;

    TraceCall("CMessageList::CmdCopy");

    // Make sure the focus is in the ListView
    HWND hwndFocus = GetFocus();

    if (!IsWindow(m_ctlList))
        return (OLECMDERR_E_DISABLED);

    if (hwndFocus != m_ctlList)
    {
        if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
            return (OLECMDERR_E_NOTSUPPORTED);
        else
            return (OLECMDERR_E_DISABLED);
    }
    
    // If the message is not cached, then we cannot copy
    if (FAILED(_GetSelectedCachedMessage(TRUE, &pMessage)))
        return (OLECMDERR_E_DISABLED);

    // Query the message for it's IDataObject interface
    if (FAILED(hr = pMessage->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObj)))
    {
        pMessage->Release();
        return (hr);
    }

    // Set it to the ClipBoard
    hr = OleSetClipboard(pDataObj);

    // Free everything
    pDataObj->Release();
    pMessage->Release();

    return (hr);
}

//
//  FUNCTION:   CMessageList::CmdPurgeFolder()
//
//  PURPOSE:    Purge deleted messages from an IMAP folder
//
HRESULT CMessageList::CmdPurgeFolder(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    return m_pTable ? m_pTable->Synchronize(SYNC_FOLDER_PURGE_DELETED, 0, this) : E_FAIL;
}

//
//  FUNCTION:   CMessageList::CmdProperties()
//
//  PURPOSE:    Displays a property sheet for the selected message.
//
HRESULT CMessageList::CmdProperties(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    LPMESSAGEINFO pInfo = NULL;
    HRESULT hr = S_OK;

    TraceCall("CMessageList::CmdProperties");

    if (m_fInOE && !::IsChild(m_hwndParent, GetFocus()))
        return (OLECMDERR_E_NOTSUPPORTED);

    int iSel = ListView_GetFirstSel(m_ctlList);
    if (-1 != iSel)
    {
        // Get the row info
        if (SUCCEEDED(m_pTable->GetRow(iSel, &pInfo)))
        {
            // Fill out one of these badboys
            MSGPROP msgProp = {0};

            msgProp.hwndParent = m_hWnd;
            msgProp.type = (pInfo->dwFlags & ARF_NEWSMSG) ? MSGPROPTYPE_NEWS : MSGPROPTYPE_MAIL;
            msgProp.mpStartPage = MP_GENERAL;
            msgProp.fSecure = (pInfo->dwFlags & ARF_SIGNED) || (pInfo->dwFlags & ARF_ENCRYPTED);
            msgProp.dwFlags = pInfo->dwFlags;

            FOLDERINFO rFolderInfo = { 0 };
            if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rFolderInfo)))
            {
                msgProp.szFolderName = rFolderInfo.pszName;
            }

            hr = m_pTable->OpenMessage(iSel, OPEN_MESSAGE_CACHEDONLY, &msgProp.pMsg, this);

            if(FAILED(hr))
            {
                AthErrorMessageW(m_hWnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsProperyAccessDenied), hr);
                goto exit;
            }

            if (msgProp.fSecure)
            {
                m_pTable->OpenMessage(iSel, OPEN_MESSAGE_CACHEDONLY | OPEN_MESSAGE_SECURE, &msgProp.pSecureMsg, 
                                     this);
                HrGetWabalFromMsg(msgProp.pSecureMsg, &msgProp.lpWabal);
            }

            msgProp.fFromListView = TRUE;

            HrMsgProperties(&msgProp);

exit:
            ReleaseObj(msgProp.lpWabal);
            ReleaseObj(msgProp.pMsg);
            ReleaseObj(msgProp.pSecureMsg);
            if (rFolderInfo.pAllocated)
                g_pStore->FreeRecord(&rFolderInfo);

            m_pTable->ReleaseRow(pInfo);
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdExpandCollapse()
//
//  PURPOSE:    Expands or collapses the currently selected thread.
//
HRESULT CMessageList::CmdExpandCollapse(DWORD nCmdID, DWORD nCmdExecOpt,
                                        VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CMessageList::CmdExpandCollapse");

    _ExpandCollapseThread(ListView_GetFocusedItem(m_ctlList));
    return (S_OK);
}
    

//
//  FUNCTION:   CMessageList::CmdColumnsDlg()
//
//  PURPOSE:    Expands or collapses the currently selected thread.
//
HRESULT CMessageList::CmdColumnsDlg(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CMessageList::CmdColumnsDlg");

    if (nCmdExecOpt == OLECMDEXECOPT_DODEFAULT || nCmdExecOpt == OLECMDEXECOPT_PROMPTUSER)
    {
        m_cColumns.ColumnsDialog(m_ctlList);
        return (S_OK);
    }

    return (OLECMDERR_E_DISABLED);
}


//
//  FUNCTION:   CMessageList::CmdSort()
//
//  PURPOSE:    Sorts the ListView based on the selected column
//
HRESULT CMessageList::CmdSort(DWORD nCmdID, DWORD nCmdExecOpt,
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CMessageList::CmdSort");
    
    // If m_iColForPopup is -1, then this came from the menu bar as opposed to
    // a context menu on the header itself.
    if (m_iColForPopup != -1)
    {
        COLUMN_ID idSort;
        BOOL      fAscending;
        
        // Get the current sort information
        m_cColumns.GetSortInfo(&idSort, &fAscending);
        
        // If the column to sort on changed, or the sort order changed, then go
        // ahead and perform the sort.
        if (idSort != m_cColumns.GetId(m_iColForPopup) || fAscending != (ID_SORT_ASCENDING == nCmdID))
            _OnColumnClick(m_iColForPopup, nCmdID == ID_SORT_ASCENDING ? LIST_SORT_ASCENDING : LIST_SORT_DESCENDING);
    }
    else
    {
        // Change the sort direction on the column that we're already sorted on
        _OnColumnClick(-1, nCmdID == ID_SORT_ASCENDING ? LIST_SORT_ASCENDING : LIST_SORT_DESCENDING);
    }
    
    return (S_OK);
    
}

//
//  FUNCTION:   CMessageList::CmdSaveAs()
//
//  PURPOSE:    Takes the selected message and saves it to a file.
//
HRESULT CMessageList::CmdSaveAs(DWORD nCmdID, DWORD nCmdExecOpt,
                                VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    IMimeMessage *pMessage = NULL;
    IMimeMessage *pSecMsg  = NULL;
    LPMESSAGEINFO pInfo = NULL;
    int           iSelectedMessage;
    HRESULT       hr = S_OK;
    
    TraceCall("CMessageList::CmdSaveAs");

    // Without a message table this doesn't work
    if (!m_pTable)
        return (OLECMDERR_E_DISABLED);
    
    // Get the selected message
    iSelectedMessage = ListView_GetFirstSel(m_ctlList);
    if (iSelectedMessage == -1)
        return (OLECMDERR_E_DISABLED);
        
    // Get the message type from the row        
    if (SUCCEEDED(m_pTable->GetRow(iSelectedMessage, &pInfo)))
    {
        // Retrieve the selected message from the cache
        hr = _GetSelectedCachedMessage(FALSE, &pMessage);
        if (SUCCEEDED(hr))
        {
            _GetSelectedCachedMessage(TRUE, &pSecMsg);
            HrSaveMessageToFile(m_hWnd, pSecMsg, pMessage, pInfo->dwFlags & ARF_NEWSMSG, FALSE);
            SafeRelease(pSecMsg); 
            SafeRelease(pMessage); 
        }
        else
            AthErrorMessageW(m_hWnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsUnableToSaveMessage), hr);

        m_pTable->ReleaseRow(pInfo);
    }
    
    return (S_OK);
    
}                                    


//
//  FUNCTION:    CMessageList::CmdMark()
//
//  PURPOSE:     Enumerates the selected rows and applies the selected marks
//               those rows.
//
HRESULT CMessageList::CmdMark(DWORD nCmdID, DWORD nCmdExecOpt,
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr=S_OK;
    ROWINDEX   *rgRows = NULL, *pRow;
    DWORD       dwRows=0, iItem;
    MARK_TYPE   mark;    
    HCURSOR     hCursor;
    BOOL        fRemoveTrayIcon = FALSE;
    
    // This could potentially take some time
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    if (nCmdID != ID_MARK_ALL_READ && nCmdID != ID_MARK_RETRIEVE_ALL)
    {
        // Figure out how many rows have been selected
        dwRows = ListView_GetSelectedCount(m_ctlList);
    
        // Make sure there is something selected
        if (0 == dwRows)
            return (OLECMDERR_E_DISABLED);        
    
        // Allocate an array of Row ID's for all of the selected rows
        if (!MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * dwRows))
            return (E_OUTOFMEMORY);
        
        // Build an array of the selected row indexes
        iItem = -1;
        pRow = rgRows;
        while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
            *pRow++ = iItem;
    }
        
    // Figure out the mark to apply
    if (nCmdID == ID_MARK_READ || nCmdID == ID_MARK_ALL_READ)
    {
        fRemoveTrayIcon = TRUE;
        mark = MARK_MESSAGE_READ;
    }
    else if (nCmdID == ID_MARK_UNREAD)
        mark = MARK_MESSAGE_UNREAD;
    else if (nCmdID == ID_MARK_RETRIEVE_MESSAGE)
        mark = MARK_MESSAGE_DOWNLOAD;
    else if (nCmdID == ID_FLAG_MESSAGE)
    {
        // Get the row state for the focused item.  That will determine whether
        // or not this is a flag or un-flag.
        iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
        if (-1 == iItem)
            iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED);

        DWORD dwState = 0;
        hr = m_pTable->GetRowState(iItem, ROW_STATE_FLAGGED, &dwState);
        Assert(SUCCEEDED(hr));
        
        if (dwState & ROW_STATE_FLAGGED)
            mark = MARK_MESSAGE_UNFLAGGED;
        else
        {
            mark = MARK_MESSAGE_FLAGGED;

            _DoColumnCheck(COLUMN_FLAG);
        }
    }
    else if (nCmdID == ID_MARK_RETRIEVE_ALL)
    {
        mark = MARK_MESSAGE_DOWNLOAD;
    }
    else if (nCmdID == ID_UNMARK_MESSAGE)
    {
        mark = MARK_MESSAGE_UNDOWNLOAD;
    }
    else
    {
        AssertSz(FALSE, "How did we get here?");        
    }

    // Tell the table to mark these messages
    if (m_pTable)
    {
        hr = m_pTable->Mark(rgRows, dwRows, m_fThreadMessages ? APPLY_COLLAPSED : APPLY_SPECIFIED, mark, this);
        if (fRemoveTrayIcon && m_fInOE && m_fMailFolder && NULL != g_pInstance)
            g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
    }
    
    // Free the array of rows
    SafeMemFree(rgRows);
    
    // Change the cursor back and notify the host that the unread count etc. 
    // might have changed.
    if (SUCCEEDED(hr))
    {
        Fire_OnMessageCountChanged(m_pTable);
        Fire_OnUpdateCommandState();
    }
    
    SetCursor(hCursor);
    return (hr);   
}    

//
//  FUNCTION:   CMessageList::CmdWatchIgnore()
//
//  PURPOSE:    Enumerates the selected rows and either marks the row as
//              watched or ignored.
//
HRESULT CMessageList::CmdWatchIgnore(DWORD nCmdID, DWORD nCmdExecOpt, 
                                     VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr;
    ROWINDEX   *rgRows = NULL, *pRow;
    DWORD       dwRows, iItem;
    MARK_TYPE   mark;    
    HCURSOR     hCursor;
    ROWINDEX    iParent;
    DWORD       cRows = 0;
    DWORD       dwState = 0;

    // This could potentially take some time
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // Start by building an array of thread parents
    dwRows = ListView_GetSelectedCount(m_ctlList);
    
    // Make sure there is something selected
    if (0 == dwRows)
        return (OLECMDERR_E_DISABLED);        
    
    // Allocate an array of Row ID's for the maximum number of rows
    if (!MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * dwRows))
        return (E_OUTOFMEMORY);
        
    // Build an array of the selected row indexes
    iItem = -1;
    while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
    {
        // Get the thread parent
        if (SUCCEEDED(hr = m_pTable->GetRelativeRow(iItem, RELATIVE_ROW_ROOT, &iParent)))
        {
            // Check to see if we've already inserted that one
            if (cRows == 0 || (cRows != 0 && rgRows[cRows - 1] != iParent))
            {
                rgRows[cRows] = iParent;
                cRows++;
            }
        }
        else
        {
            rgRows[cRows] = iItem;
            cRows++;
        }
    }
        
    // Figure out the mark to apply
    if (nCmdID == ID_WATCH_THREAD)
    {
        // Get the row state for the focused item.  That will determine whether
        // or not this is a flag or un-flag.
        iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
        if (-1 == iItem)
            iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED);

        hr = m_pTable->GetRowState(iItem, ROW_STATE_WATCHED, &dwState);
        Assert(SUCCEEDED(hr));

        if (dwState & ROW_STATE_WATCHED)
            mark = MARK_MESSAGE_NORMALTHREAD;
        else
        {
            mark = MARK_MESSAGE_WATCH;
            _DoColumnCheck(COLUMN_THREADSTATE);
        }
    }
    else if (nCmdID == ID_IGNORE_THREAD)
    {
        // Get the row state for the focused item.  That will determine whether
        // or not this is a flag or un-flag.
        iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
        if (-1 == iItem)
            iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED);

        hr = m_pTable->GetRowState(iItem, ROW_STATE_IGNORED, &dwState);
        Assert(SUCCEEDED(hr));
        
        if (dwState & ROW_STATE_IGNORED)
            mark = MARK_MESSAGE_NORMALTHREAD;
        else
            mark = MARK_MESSAGE_IGNORE;
    }

    // Tell the table to mark these messages
    if (m_pTable)
        hr = m_pTable->Mark(rgRows, cRows, APPLY_CHILDREN, mark, this);
    
    // Free the array of rows
    SafeMemFree(rgRows);
    
    // Change the cursor back and notify the host that the unread count etc. 
    // might have changed.
    if (SUCCEEDED(hr))
    {
        Fire_OnMessageCountChanged(m_pTable);
        Fire_OnUpdateCommandState();
    }
    
    SetCursor(hCursor);
    return (hr);   
}
                                
//
//  FUNCTION:   CMessageList::CmdMarkTopic()
// 
//  PURPOSE:    Marks the message contained within the selected topic.
//
HRESULT CMessageList::CmdMarkTopic(DWORD nCmdID, DWORD nCmdExecOpt,
                                   VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr;
    DWORD       iItemSel, iItemRoot;
    MARK_TYPE   mark;
    HCURSOR     hCursor;

    // If we don't have a table, bail
    if (!m_pTable)
        return (OLECMDERR_E_DISABLED);
    
    // This might take a while
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // Make sure there is a selected message
    iItemSel = ListView_GetFirstSel(m_ctlList);
    if (-1 == iItemSel)
        return (OLECMDERR_E_DISABLED);
        
    // Get the mark type
    if (nCmdID == ID_MARK_THREAD_READ)
        mark = MARK_MESSAGE_READ;
    else if (nCmdID == ID_MARK_RETRIEVE_THREAD)
        mark = MARK_MESSAGE_DOWNLOAD;
        
    // Get the parent of the thread
    if (SUCCEEDED(hr = m_pTable->GetRelativeRow(iItemSel, RELATIVE_ROW_ROOT, &iItemRoot)))
    {
        hr = m_pTable->Mark(&iItemRoot, 1, APPLY_CHILDREN, mark, this);
    }
    
    // Set the cursor back and update the host
    SetCursor(hCursor);    
    if (SUCCEEDED(hr))
        Fire_OnMessageCountChanged(m_pTable);
    
    return (hr);
}


//
//  FUNCTION:   CMessageList::CmdGetNextItem()
//
//  PURPOSE:    Selects the next or previous message based on the specified
//              criteria.
//
HRESULT CMessageList::CmdGetNextItem(DWORD nCmdID, DWORD nCmdExecOpt,
                                     VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwNext = -1;
    int             iFocused; 
    GETNEXTFLAGS    flag=0;
    GETNEXTTYPE     tyDirection;
    ROWMESSAGETYPE  tyMessage=ROWMSG_ALL;

    TraceCall("CMessageList::CmdGetNextItem");

    // No table - no next item
    if (!m_pTable)
        return (OLECMDERR_E_DISABLED);
    
    // Figure out what the current item is
    iFocused = ListView_GetFocusedItem(m_ctlList);

    // Convert the command ID to the appropriate mark flag
    if (nCmdID == ID_NEXT_MESSAGE)
        tyDirection = GETNEXT_NEXT;
    else if (nCmdID == ID_PREVIOUS)
        tyDirection = GETNEXT_PREVIOUS;
    else if (nCmdID == ID_NEXT_UNREAD_THREAD)
    {
        tyDirection = GETNEXT_NEXT;
        flag = GETNEXT_UNREAD | GETNEXT_THREAD;
    }
    else if (nCmdID == ID_NEXT_UNREAD_MESSAGE)
    {
        tyDirection = GETNEXT_NEXT;
        flag = GETNEXT_UNREAD;
    }
    
    // Ask the table what the next item is
    hr = m_pTable->GetNextRow(iFocused, tyDirection, tyMessage, flag, &dwNext);
    if (SUCCEEDED(hr) && dwNext != -1)
    {
        ListView_UnSelectAll(m_ctlList);
        ListView_SelectItem(m_ctlList, dwNext);
        ListView_EnsureVisible(m_ctlList, dwNext, FALSE);
    }
    else
    {
        if (FALSE == m_fFindFolder && (nCmdID == ID_NEXT_UNREAD_THREAD || nCmdID == ID_NEXT_UNREAD_MESSAGE))
        {
            if (IDYES == AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
                                       MAKEINTRESOURCEW(idsNoMoreUnreadMessages),
                                       0, MB_YESNO))
            {
                HWND hwndBrowser = GetTopMostParent(m_ctlList);
                ::PostMessage(hwndBrowser, WM_COMMAND, ID_NEXT_UNREAD_FOLDER, 0);
            }
        }
        else
        {
            MessageBeep(MB_OK);
        }
    }
    
    return (hr);    
}


//
//  FUNCTION:   CMessageList::CmdStop()
//
//  PURPOSE:    Stops the current operation.
//
HRESULT CMessageList::CmdStop(DWORD nCmdID, DWORD nCmdExecOpt,
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (m_pCancel)
    {
        m_pCancel->Cancel(CT_CANCEL);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdRefresh()
//
//  PURPOSE:    Refreshes the contents of the ListView.
//
HRESULT CMessageList::CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt,
                                 VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr = E_FAIL;

    //Since this is an action explicitly initiated from the menus, so go online if we are offline
    if (PromptToGoOnline() == S_OK)
    {
        // Tell the message table to hit the server and look for new messages
        if (m_pTable)
        {
            hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }

    if (m_pTable)
    {
        FOLDERSORTINFO SortInfo;

        if (SUCCEEDED(m_pTable->GetSortInfo(&SortInfo)))
        {
            _FilterView(SortInfo.ridFilter);
        }
    }
    return (hr);
}


//
//  FUNCTION:   CMessageList::CmdGetHeaders()
//
//  PURPOSE:    Refreshes the contents of the ListView.
//
HRESULT CMessageList::CmdGetHeaders(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr = E_FAIL;
    DWORD   cHeaders;

    //Since this is an action explicitly initiated from the menus, so go online if we are offline
    if (PromptToGoOnline() == S_OK)
    {
        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
        {
            if (OPTION_OFF != m_dwGetXHeaders)
                hr = m_pTable->Synchronize(SYNC_FOLDER_XXX_HEADERS, m_dwGetXHeaders, this);
            else
                hr = m_pTable->Synchronize(NOFLAGS, 0, this);
        }
        else
        {
            hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }
    return (hr);
}


//
//  FUNCTION:   CMessageList::CmdMoveCopy()
//
//  PURPOSE:    Moves or copies the selected messages to another folder.
//
//  PARAMS:     nCmdID
//                  ID_MOVE_TO_FOLDER or ID_COPY_TO_FOLDER
//              nCmdExecOpt
//                  Unused
//              pvaIn
//                  NULL or a VT_I4 specifying destination folder id (0 for unknown)
//              pvaOut
//                  Unused
HRESULT CMessageList::CmdMoveCopy(DWORD nCmdID, DWORD nCmdExecOpt, 
                                  VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    int      idsTitle, idsCaption;
    DWORD    dwFlags;
    DWORD    dwCopyFlags;
    FOLDERID idFolderDest = FOLDERID_INVALID;
    HRESULT  hr;

    TraceCall("CMessageList::CmdMoveCopy");

    // Set up the move versus copy options
    if (nCmdID == ID_MOVE_TO_FOLDER)
    {
        idsTitle    = idsMove;
        idsCaption  = idsMoveCaption;
        dwFlags     = FD_MOVEFLAGS | FD_DISABLESERVERS | TREEVIEW_NONEWS;
        dwCopyFlags = COPY_MESSAGE_MOVE;
    }
    else
    {
        Assert(nCmdID == ID_COPY_TO_FOLDER);
        idsTitle    = idsCopy;
        idsCaption  = idsCopyCaption;
        dwFlags     = FD_COPYFLAGS | FD_DISABLESERVERS | TREEVIEW_NONEWS;
        dwCopyFlags = 0;
    }

    // If the user passed in a folder ID, we don't need to ask this.
    if (!pvaIn || (pvaIn && !pvaIn->lVal))
    {
        // Let the user select the destination folder
        hr = SelectFolderDialog(m_hWnd, SFD_SELECTFOLDER, m_idFolder, dwFlags, (LPCTSTR)IntToPtr(idsTitle),
                                (LPCTSTR)IntToPtr(idsCaption), &idFolderDest);
    }
    else
    {
        Assert(pvaIn->vt == VT_I4);
        idFolderDest = (FOLDERID)((LONG_PTR)pvaIn->lVal);
    }

    if (idFolderDest != FOLDERID_INVALID)
    {
        IMessageFolder *pDest;

        hr = g_pStore->OpenFolder(idFolderDest, NULL, NOFLAGS, &pDest);
        if (SUCCEEDED(hr))
        {
            // Gather the information together to do the move
            IServiceProvider *pService;
            IMessageFolder   *pFolder;
            MESSAGEIDLIST     rMsgIDList;
            ROWINDEX         *rgRows;
            MESSAGEINFO       rInfo;
            DWORD             i = 0;
            DWORD             iRow = -1;
            DWORD             cRows;

            // Figure out how many rows there are selected
            cRows = ListView_GetSelectedCount(m_ctlList);

            // Allocate an array
            if (MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * cRows))
            {
                // Loop through the rows getting their row indexs
                while (-1 != (iRow = ListView_GetNextItem(m_ctlList, iRow, LVNI_SELECTED)))
                {
                    rgRows[i++] = iRow;
                }

                // Now ask the table for a message ID list
                if (SUCCEEDED(m_pTable->GetMessageIdList(FALSE, cRows, rgRows, &rMsgIDList)))
                {
                    hr = m_pTable->QueryInterface(IID_IServiceProvider, (void **)&pService);
                    if (SUCCEEDED(hr))
                    {
                        hr = pService->QueryService(IID_IMessageFolder, IID_IMessageFolder, (void **)&pFolder);
                        if (SUCCEEDED(hr))
                        {
                            hr = CopyMessagesProgress(GetTopMostParent(m_hWnd), pFolder, pDest, dwCopyFlags, &rMsgIDList, NULL);
                            if (FAILED(hr))
                                AthErrorMessageW(GetTopMostParent(m_hWnd), MAKEINTRESOURCEW(idsAthena), 
                                                ISFLAGSET(dwCopyFlags, COPY_MESSAGE_MOVE) ? 
                                                    MAKEINTRESOURCEW(idsErrMoveMsgs) : 
                                                    MAKEINTRESOURCEW(idsErrCopyMsgs), hr); 

                            pFolder->Release();
                        }

                        pService->Release();
                    }
                }

                SafeMemFree(rMsgIDList.prgidMsg);
                MemFree(rgRows);
            }

            pDest->Release();

            // If we're in OE, then we remove the tray icon if this is the inbox
            if (m_fInOE && m_fMailFolder && NULL != g_pInstance)
                g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
        }
    }

    return (S_OK);                                    
}


//
//  FUNCTION:   CMessageList::CmdDelete()
//
//  PURPOSE:    Deletes the selected messages from the folder.
//
HRESULT CMessageList::CmdDelete(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    DELETEMESSAGEFLAGS dwFlags = NOFLAGS;
    DWORD              dwState = 0;
    BOOL               fOnce = TRUE;

    TraceCall("CMessageList::CmdDelete");

    // Check to see if this is enabled
    if (!_IsSelectedMessage(ROW_STATE_DELETED, ID_UNDELETE == nCmdID, FALSE))
    {
        return (OLECMDERR_E_DISABLED);
    }

    // news folders only allow permanent deletes from local store
    if ((nCmdID == ID_DELETE) && GetFolderType(m_idFolder) == FOLDER_NEWS)
        nCmdID = ID_DELETE_NO_TRASH;

    // Figure out what operation we're doing here
    if (nCmdID == ID_UNDELETE)
        dwFlags = DELETE_MESSAGE_UNDELETE;
    else if (nCmdID == ID_DELETE_NO_TRASH)
        dwFlags = DELETE_MESSAGE_NOTRASHCAN;

    // Get the number of selected rows
    DWORD cRows = ListView_GetSelectedCount(m_ctlList);

    // Allocate an array large enough for that array
    if (cRows && m_pTable)
    {
        ROWINDEX *rgRows = 0;
        if (MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * cRows))
        {
            // Loop through the rows and copy them into the array
            DWORD index = 0, row = -1;
        
            while (-1 != (row = ListView_GetNextItem(m_ctlList, row, LVNI_SELECTED)))
            {
                if (m_fThreadMessages && fOnce && nCmdID != ID_UNDELETE)
                {
                    if (SUCCEEDED(m_pTable->GetRowState(row, ROW_STATE_HAS_CHILDREN | ROW_STATE_EXPANDED, &dwState)))
                    {
                        if ((dwState & ROW_STATE_HAS_CHILDREN) && (0 == (dwState & ROW_STATE_EXPANDED)))
                        {
                            fOnce = FALSE;

                            // Tell the user that we're going to delete everything in the thread
                            if (!DwGetDontShowAgain(c_szRegWarnDeleteThread) &&
                                (IDNO == DoDontShowMeAgainDlg(m_hWnd, c_szRegWarnDeleteThread, 
                                                             MAKEINTRESOURCE(idsAthena),
                                                             MAKEINTRESOURCE(idsDSDeleteCollapsedThread),
                                                             MB_YESNO)))
                            {
                                MemFree(rgRows);
                                return (S_OK);
                            }
                        }
                    }
                }

                rgRows[index] = row;
                index++;

                Assert(index <= cRows);
            }

            // Delete or Undelete
            m_pTable->DeleteRows(dwFlags, cRows, rgRows, TRUE, this);

            // Free the memory
            MemFree(rgRows);

            // If we're in OE and we deleted, we remove the tray icon
            if (m_fInOE && m_fMailFolder && nCmdID == ID_DELETE && g_pInstance)
                g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdFind()
//
//  PURPOSE:    Creates a find dialog so the user can search for messages in
//              this folder.
//
HRESULT CMessageList::CmdFind(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    // Create the class
    if (!m_pFindNext)
    {
        m_pFindNext = new CFindNext();
        if (!m_pFindNext)
            return (E_OUTOFMEMORY);
    }

    // Initialize some state so we can show a lot of dialogs later
    int iFocus = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
    if (iFocus == -1)
        iFocus = 0;

    if (FAILED(m_pTable->GetRowMessageId(iFocus, &m_idFindFirst)))
        return (E_UNEXPECTED);

    m_cFindWrap = 0;

    // Show the find dialog
    if (FAILED(m_pFindNext->Show(m_hWnd, &m_hwndFind)))
        return (E_UNEXPECTED);

    CmdFindNext(nCmdID, nCmdExecOpt, pvaIn, pvaOut);        
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdFindNext()
//
//  PURPOSE:    Get's called whenever the user clicks Find Next in the find
//              window.  In return, we move the listview select to the next
//              item in the list that matches the find criteria.
//
HRESULT CMessageList::CmdFindNext(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TCHAR    sz[CCHMAX_FIND];
    FINDINFO rFindInfo = { 0 };
    ROWINDEX iNextRow;
    BOOL     fBodies = 0;
    ROWINDEX iFirstRow = -1;
    BOOL     fWrapped = FALSE;
	
    TraceCall("CMessageList::OnFindMsg");
	
    // Check to see if the user has done a "Find" first
    if (!m_pFindNext)
        return CmdFind(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
	
    // Get the find information
    if (SUCCEEDED(m_pFindNext->GetFindString(sz, ARRAYSIZE(sz), &fBodies)))
    {
        int iFocus = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
		if(iFocus < 0)
			iFocus = 0;
		
        // Do the find
        m_pTable->FindNextRow((DWORD) iFocus, sz, FINDNEXT_ALLCOLUMNS, fBodies, &iNextRow, &fWrapped);
		
        if (iNextRow == -1 || fWrapped)
        {
            // We passed our starting position
			if(iFocus > 0)
			{
				if (IDYES == AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
					MAKEINTRESOURCEW(idsFindNextFinished), 0,
					MB_YESNO | MB_ICONEXCLAMATION))
				{
					m_pTable->FindNextRow(0, sz, FINDNEXT_ALLCOLUMNS, fBodies, &iNextRow, &fWrapped);
					if (iNextRow == -1)
					{
						// We failed to find the search string
						AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
							MAKEINTRESOURCEW(idsFindNextFinishedFailed), 0,
							MB_OK | MB_ICONEXCLAMATION);
					}
					else
					{
						ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
						ListView_SetItemState(m_ctlList, iNextRow, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
						ListView_EnsureVisible(m_ctlList, iNextRow, FALSE);
					}
				}
            }
            else if (iNextRow == -1)
			{
				// We failed to find the search string
				AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
					MAKEINTRESOURCEW(idsFindNextFinishedFailed), 0,
					MB_OK | MB_ICONEXCLAMATION);
			}
        }
        else
        {
            ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
            ListView_SetItemState(m_ctlList, iNextRow, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            ListView_EnsureVisible(m_ctlList, iNextRow, FALSE);
        }
    }
	
#if 0
	// Figure out where we started
	Assert(m_bmFindFirst);
	m_pTable->GetRowIndex(m_bmFindFirst, &iFirstRow);
	
	// Figure out if we've wrapped
	m_cFindWrap += (!!fWrapped);
	
	// Here's where we do a lot of stuff to display some useless dialogs
	if (iNextRow == -1)
	{
		// We failed to find the search string
		AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
			MAKEINTRESOURCEW(idsFindNextFinishedFailed), 0,
			MB_OK | MB_ICONEXCLAMATION);
		iNextRow = iFocus;
	}
	else if (m_cFindWrap >= 2 || (m_cFindWrap == 1 && iNextRow >= iFirstRow))
	{
		// We passed our starting position
		AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
			MAKEINTRESOURCEW(idsFindNextFinished), 0,
			MB_OK | MB_ICONEXCLAMATION);
		m_cFindWrap = 0;
	}
	else
	{           
		ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
		ListView_SetItemState(m_ctlList, iNextRow, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		ListView_EnsureVisible(m_ctlList, iNextRow, FALSE);
	}
}

#endif 
return (0);
}


//
//  FUNCTION:   CMessageList::CmdSpaceAccel()
//
//  PURPOSE:    If the user presses <SPACE> while in the view, we need to
//              go to the next message unless the focused item is not 
//              selected.
//
HRESULT CMessageList::CmdSpaceAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    int     iFocused;
    DWORD   dwState = 0;
    HRESULT hr;
    
    // Figure out who has the focus
    iFocused = ListView_GetFocusedItem(m_ctlList);

    // It's possible for nothing to be focused
    if (-1 == iFocused)
    {
        iFocused = 0;
        ListView_SetItemState(m_ctlList, iFocused, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    // Check to see if that item is selected
    if (0 == ListView_GetItemState(m_ctlList, iFocused, LVIS_SELECTED))
    {
        // Select that item
        if (GetAsyncKeyState(VK_CONTROL) < 0)
        {
            ListView_SetItemState(m_ctlList, iFocused, LVIS_SELECTED, LVIS_SELECTED);
        }
        else
        {
            ListView_SetItemState(m_ctlList, -1, 0, LVIS_SELECTED);
            ListView_SetItemState(m_ctlList, iFocused, LVIS_SELECTED, LVIS_SELECTED);
        }
    }
    else
    {
        // If the selection is on a collapsed thread, expand it first
        if (m_fThreadMessages)
        {
            hr = m_pTable->GetRowState(iFocused, ROW_STATE_EXPANDED | ROW_STATE_HAS_CHILDREN, &dwState);
            if (SUCCEEDED(hr) && (dwState & ROW_STATE_HAS_CHILDREN) && (0 == (dwState & ROW_STATE_EXPANDED)))
            {
                _ExpandCollapseThread(iFocused);
            }
        }
        
        // Go to the next item        
        CmdGetNextItem(ID_NEXT_MESSAGE, 0, NULL, NULL);
    }

    return (S_OK);
}


//
//  FUNCTION:   _UpdateListViewCount()
//
//  PURPOSE:    Gets the number of items in the message table and tells the
//              listview to display that many rows.
//
void CMessageList::_UpdateListViewCount(void)
{
    DWORD dwCount = 0;

    TraceCall("_UpdateListViewCount");

    // Get the number of items from the table
    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount);

    // If that count is not the same as the number of items already in the 
    // ListView, update the control.
    if (dwCount != (DWORD) ListView_GetItemCount(m_ctlList))
    {
        ListView_SetItemCount(m_ctlList, dwCount);
        Fire_OnMessageCountChanged(m_pTable);
    }
}


//
//  FUNCTION:   CMessageList::_GetSelectedCachedMessage()
//
//  PURPOSE:    Retrieves the selected message if the body has already been 
//              downloaded into the cache.
//
//  PARAMETERS: 
//      [in]  fSecure   -
//      [out] ppMessage -
//
HRESULT CMessageList::_GetSelectedCachedMessage(BOOL fSecure, IMimeMessage **ppMessage)
{
    int     iSelectedMessage;
    BOOL    fCached = FALSE;
    DWORD   dwState = 0;
    HRESULT hr = E_FAIL;

    TraceCall("CMessageList::_GetSelectedCachedMessage");

    // Without a table there's nothing to get
    if (!m_pTable)
        return (E_UNEXPECTED);

    // Get the selected article header index
    iSelectedMessage = ListView_GetFirstSel(m_ctlList);

    // If there was a selected message, see if the body is preset
    if (-1 != iSelectedMessage)
    {
        m_pTable->GetRowState(iSelectedMessage, ROW_STATE_HAS_BODY, &dwState);
        if (dwState & ROW_STATE_HAS_BODY)
        {
            hr = m_pTable->OpenMessage(iSelectedMessage, OPEN_MESSAGE_CACHEDONLY | (fSecure ? OPEN_MESSAGE_SECURE : 0), ppMessage, this);
        }
    }

    return (hr);
}


//
//  FUNCTION:   CMessageList::_ExpandCollapseThread()
//
//  PURPOSE:    Takes the sepecified item in the ListView and toggles it's
//              expanded or collapsed state.
//
//  PARAMETERS: 
//      [in] iItem - item to expand or collapse
//
HRESULT CMessageList::_ExpandCollapseThread(int iItem)
{
    DWORD   dwState;
    LV_ITEM lvi = { 0 };
    HRESULT hr;

    TraceCall("CMessageList::_ExpandCollapseThread");

    // There's nothing to expand or collapse if there's no table
    if (!m_pTable)
        return (E_FAIL);

    // If we're not threaded right now, this is silly
    if (!m_fThreadMessages)
        return (E_FAIL);

    // Make sure this selected item has children
    hr = m_pTable->GetRowState(iItem, ROW_STATE_EXPANDED | ROW_STATE_HAS_CHILDREN, &dwState);
    if (SUCCEEDED(hr) && (dwState & ROW_STATE_HAS_CHILDREN))
    {
        // If the item is expanded
        if (dwState & ROW_STATE_EXPANDED)
        {
            // Loop through all the selected rows which are children of the row being collapsed.
            int i = iItem;
            while (-1 != (i = ListView_GetNextItem(m_ctlList, i, LVNI_SELECTED | LVNI_ALL)))
            {
                hr = m_pTable->IsChild(iItem, i);
                if (S_OK == hr)
                {
                    ListView_SelectItem(m_ctlList, iItem);
                    break;
                }
            }

            // Collapse the branch
            m_pTable->Collapse(iItem);
        }
        else
        {
            // Expand the branch
            m_pTable->Expand(iItem);
        }

        // Redraw the item that was expanded or collapsed so the + or - is 
        // correct.
        ListView_RedrawItems(m_ctlList, iItem, iItem);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::_IsSelectedMessage()
//
//  PURPOSE:    Checks to see if all or some of the selected messages in the 
//              listview have the specified state bits set.
//
//  PARAMETERS: 
//      [in] dwState    - State bits to check on each selected row.
//      [in] fCondition - Whether the state bits should be there or not.
//      [in] fAll       - The caller requires that ALL selected message meet the 
//                        criteria.
//
BOOL CMessageList::_IsSelectedMessage(DWORD dwState, BOOL fCondition, BOOL fAll, BOOL fThread)
{
    TraceCall("CMessageList::_IsSelectedMessage");

    DWORD   iItem = -1;
    DWORD   dw;
    DWORD   cRowsChecked = 0;

    // No table, no service
    if (!m_pTable)
        return (FALSE);

    while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
    {
        // Get the state for the row
        if (SUCCEEDED(m_pTable->GetRowState(iItem, dwState, &dw)))
        {
            if (fAll)
            {
                // If all must match and this one doesn't, then we can quit now.
                if (0 == (fCondition == !!(dwState & dw)))
                    return (FALSE);
            }
            else
            {
                // If only one needs to match and this one does, then we can
                // quit now.
                if (fCondition == !!(dwState & dw))
                    return (TRUE);
            }
        }

        // This is a perf safeguard.  We only look at 100 rows.  If we didn't
        // find anything in those rows to invalidate the criteria we assume it
        // will succeed.  
        cRowsChecked++;
        if (cRowsChecked > 100)
            return (TRUE);
    }

    // If the user wanted all to match, and we get here all did match.  If the
    // user wanted only one to match and we get here, then none matched and we
    // fail.
    return (fAll);
}


//
//  FUNCTION:   CMessageList::_SelectDefaultRow()
//
//  PURPOSE:    Selects the first unread item in the folder, or if that fails
//              the first or last item based on the sort order.
//
void CMessageList::_SelectDefaultRow(void)
{
    DWORD iItem, cItems;
    DWORD dwState;
    DWORD iItemFocus = -1;

    TraceCall("CMessageList::_SelectDefaultRow");

    if (-1 == ListView_GetFirstSel(m_ctlList))
    {
        // Get the total number of items in the view
        cItems = ListView_GetItemCount(m_ctlList);

        // If this folder has the "Select first unread" property, then find
        // that row.
        if (m_fSelectFirstUnread)
        {
            for (iItem = 0; iItem < cItems; iItem++)
            {
                if (SUCCEEDED(m_pTable->GetRowState(iItem, ROW_STATE_READ, &dwState)))
                {
                    if (0 == (dwState & ROW_STATE_READ))
                    {
                        iItemFocus = iItem;
                        goto exit;
                    }
                }
            }
        }

        // If we didn't set the selection because there aren't any unread, or
        // the setting was not to find the first unread, then set the selection
        // either the first or last item depending on the sort direction.
        if (cItems)
        {
            BOOL fAscending;
            COLUMN_ID idSort;

            // Get the sort direction
            m_cColumns.GetSortInfo(&idSort, &fAscending);
            if (fAscending && (idSort == COLUMN_SENT || idSort == COLUMN_RECEIVED))
                iItemFocus = cItems - 1;
            else
                iItemFocus = 0;
        }
    }

exit:
    if (iItemFocus != -1)
    {
        if (m_fSelectFirstUnread)
        {
            ListView_SetItemState(m_ctlList, iItemFocus, LVIS_FOCUSED, LVIS_FOCUSED);
        }
        else
        {
            ListView_SelectItem(m_ctlList, iItemFocus);
        }

        ListView_EnsureVisible(m_ctlList, iItemFocus, FALSE);    
    }
}


//
//  FUNCTION:   CMessageList::_LoadAndFormatString()
//
//  PURPOSE:    This function loads the string resource ID provided, merges the
//              variable argument list into the string, and copies that all into
//              pszOut.
//
void CMessageList::_LoadAndFormatString(LPTSTR pszOut, int cchOut, const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT;
    TCHAR       szFmt[CCHMAX_STRINGRES];

    TraceCall("CMessageList::_LoadAndFormatString");

    // If we were passed a string resource ID, then load it
    if (0 == HIWORD(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;

    // Format the string
    va_start(pArgs, pFmt);
    i = wvnsprintf(pszOut, cchOut, pszT, pArgs);
    va_end(pArgs);    
}


//
//  FUNCTION:   CMessageList::OnHeaderStateChange()
//
//  PURPOSE:    Whenever the state of a header changes, we need to redraw that 
//              item.
//
//  PARAMETERS: 
//      [in] wParam - lower index of the items which changed.  -1 for everything.
//      [in] lParam - upper index of the items which changed
//
LRESULT CMessageList::OnHeaderStateChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnHeaderStateChange");

    // If this is the case, then we redraw everything
    if (wParam == -1)
    {
        ListView_RedrawItems(m_ctlList, 0, ListView_GetItemCount(m_ctlList));
    }
    else 
    {
        // If this is the case, we just redraw the one item
        if (0 == lParam)
        {
            ListView_RedrawItems(m_ctlList, wParam, wParam);
        }
        else
        {
            // If this is the case, we want to invalidate just the 
            // intersection of (wParam, lParam) and the items visible
            DWORD dwTop, dwBottom;
            dwTop = ListView_GetTopIndex(m_ctlList);
            dwBottom = dwTop + ListView_GetCountPerPage(m_ctlList) + 1;

            // Make sure they intersect
            if ((dwTop > (DWORD) lParam) || (dwBottom < wParam))
                goto exit;

            ListView_RedrawItems(m_ctlList,
                                 max((int) wParam, (int) dwTop),
                                 min((int) lParam, (int) dwBottom));
        }
    }

exit:
    Fire_OnMessageCountChanged(m_pTable);
    Fire_OnUpdateCommandState();
    return (0);
}


//
//  FUNCTION:   CMessageList::OnUpdateAndRefocus()
//
//  PURPOSE:    This was originally called by the table after calls to GetNext()
//              to update the ListView count and select a message.  The usage
//              looks pretty suspect.
//
LRESULT CMessageList::OnUpdateAndRefocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnUpdateAndRefocus");
    AssertSz(0, "why is this called?");
    return (0);
}



//
//  FUNCTION:   CMessageList::OnDiskFull()
//
//  PURPOSE:    Sent when the table cannot write to disk because it is full.
//
//  PARAMETERS: 
//      [in] wParam - Contains the HRESULT with the error.
//
LRESULT CMessageList::OnDiskFull(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = (HRESULT) wParam;
    UINT    ids;

    TraceCall("CMessageList::OnDiskFull");

    if (hr == STG_E_MEDIUMFULL)
        ids = idsHTMLDiskOutOfSpace;
    else
        ids = idsHTMLErrNewsCantOpen;

    // Update the host
    Fire_OnError(ids);
    Fire_OnUpdateProgress(0);
    Fire_OnMessageCountChanged(m_pTable);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnArticleProgress()
//
//  PURPOSE:    Sent by the sync to provide article download progress.
//
//  PARAMETERS: 
//      [in] wParam - Progress
//      [in] lParam - Progress max
//
LRESULT CMessageList::OnArticleProgress(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TCHAR szBuf[CCHMAX_STRINGRES + 40];

    TraceCall("CMessageList::OnArticleProgress");

    if (lParam)
    {
        _LoadAndFormatString(szBuf, ARRAYSIZE(szBuf), (LPTSTR) idsDownloadingArticle, min(100, (wParam * 100) / lParam));
        Fire_OnUpdateStatus(szBuf);
        Fire_OnUpdateProgress((DWORD)((wParam * 100) / lParam));
    }

    return (0);
}


//
//  FUNCTION:   CMessageList::OnBodyError()
//
//  PURPOSE:    Sent when there is an error downloading a message body
//
//  PARAMETERS: 
//      [in] lParam - Pointer to a CNNTPResponse class with the details of 
//                    the error.
//
LRESULT CMessageList::OnBodyError(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnBodyError");

#ifdef NEWSISBROKE
    CNNTPResponse *pResp;
    LPNNTPRESPONSE pr;

    pResp = (CNNTPResponse *) lParam;
    pResp->Get(&pr);

    // If the error is that the message is not available, then don't show the error -- it
    // happens way to frequently.
    if (pr->rIxpResult.hrResult != IXP_E_NNTP_ARTICLE_FAILED)
        XPUtil_DisplayIXPError(m_ Parent, &pr->rIxpResult, pr->pTransport);

    pResp->Release();
#endif
    return (0);
}


//
//  FUNCTION:   CMessageList::OnBodyAvailable()
//
//  PURPOSE:    Sent when the table has finished downloading the body of a 
//              message.
//
//  PARAMETERS: 
//      [in] wParam - Message ID of the new message body.
//      [in] lParam - HRESULT indicating success or failure.
//
LRESULT CMessageList::OnBodyAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr = (HRESULT) wParam;
    DWORD_PTR   dwMsgId = (DWORD_PTR) lParam;
    int         iSel;
    RECT        rcFirst, rcLast, rcUnion;
    UINT        ids = 0;

    TraceCall("CMessageList::OnBodyAvailable");

    // If the user has a context menu visible right now, force it to repaint 
    // since the status of some of the items might be changed now.
    if (m_hMenuPopup)
    {
        MenuUtil_EnablePopupMenu(m_hMenuPopup, this);

        GetMenuItemRect(m_hWnd, m_hMenuPopup, 0, &rcFirst);
        GetMenuItemRect(m_hWnd, m_hMenuPopup, GetMenuItemCount(m_hMenuPopup) - 1, &rcLast);
        UnionRect(&rcUnion, &rcFirst, &rcLast);
        OffsetRect(&rcUnion, m_ptMenuPopup.x - rcUnion.left, m_ptMenuPopup.y - rcUnion.top);
        ::RedrawWindow(NULL, &rcUnion, NULL, RDW_INVALIDATE|RDW_UPDATENOW|RDW_ALLCHILDREN);
    }

    // Figure which item has the selection
    iSel = ListView_GetSelFocused(m_ctlList);

    // If there is a focused item, then update the preview pane
    if (-1 != iSel)
    {
        // Get the row info
        LPMESSAGEINFO pInfo;

        if (m_pTable)
        {
            m_pTable->GetRow(iSel, &pInfo);

            // If that message id is the one we just downloaded, update
            if ((DWORD_PTR)pInfo->idMessage == dwMsgId)
            {
                if (FAILED(hr))
                {            
                    // Convert the error to a string to show in the preview
                    // pane.
                    switch (hr)
                    {
                        case E_INVALIDARG:
                            ids = idsHTMLErrNewsExpired;
                            break;

                        case hrUserCancel:
                            ids = idsHTMLErrNewsDLCancelled;
                            break;

                        case IXP_E_FAILED_TO_CONNECT:
                            ids = idsHTMLErrArticleNotCached;
                            break;

                        case STG_E_MEDIUMFULL:
                            ids = idsHTMLDiskOutOfSpace;
                            break;

                        default:
                            ids = idsHTMLErrNewsCantOpen;
                            break;
                    }
                }
                Fire_OnError(ids);
            }

            m_pTable->ReleaseRow(pInfo);
        }
    }

    Fire_OnUpdateProgress(0);
    Fire_OnMessageCountChanged(m_pTable);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnStatusChange()
//
//  PURPOSE:    We simply forward this notification to our parent
//
LRESULT CMessageList::OnStatusChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnStatusChange");

    return ::SendMessage(m_hwndParent, uMsg, wParam, lParam);
}


//
//  FUNCTION:   CMessageList::_FilterView()
//
//  PURPOSE:    Tells the table to filter itself, while preserving the 
//              selection if possible.
//
void CMessageList::_FilterView(RULEID ridFilter)
{
    COLUMN_ID idSort;
    BOOL fAscending;
    FOLDERSORTINFO SortInfo;

    TraceCall("CMessageList::_FilterView");
   
    m_ridFilter = ridFilter;

    // It is possible to get here and not have a table
    if (!m_pTable)
        return;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Get the current sort information
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill sort info
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Tell the table to change its sort order
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reset the view
    _ResetView(idSel);

    Fire_OnMessageCountChanged(m_pTable);
}

void CMessageList::_ResetView(MESSAGEID idSel)
{
    // Reset the ListView count
    DWORD dwItems, iSel;
    m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwItems);
    ListView_SetItemCount(m_ctlList, dwItems);

    // Get the new index from the bookmark
    if (idSel)
    {
        if (FAILED(m_pTable->GetRowIndex(idSel, &iSel)) || iSel == -1)
        {
            COLUMN_ID idSort;
            BOOL      fAscending;

            // Get the current sort information
            m_cColumns.GetSortInfo(&idSort, &fAscending);

            if (fAscending)
                iSel = dwItems - 1;
            else
                iSel = 0;
        }

        // Reset the selection
        ListView_UnSelectAll(m_ctlList);
        if (iSel < dwItems)
        {
            ListView_SelectItem(m_ctlList, iSel);
            ListView_EnsureVisible(m_ctlList, iSel, FALSE);
        }
        else
        {
            if(!m_fInFire)
            {
                m_fInFire = TRUE;
                Fire_OnSelectionChanged(ListView_GetSelectedCount(m_ctlList));
                m_fInFire = FALSE;
            }
        }
    }

    // Check to see if we need to reset the empty list thing
    if (0 == dwItems)
    {
        m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
    }
    else
    {
        m_cEmptyList.Hide();
    }

    m_ctlList.InvalidateRect(NULL, TRUE);
}

//
//  FUNCTION:   CMessageList::_OnColumnClick()
//
//  PURPOSE:    Called to resort the ListView based on the provided column
//              and direction.
//
//  PARAMETERS: 
//      [in] iColumn   - Index of the column to sort on
//      [in] iSortType - Type of sorting to do.
//
LRESULT CMessageList::_OnColumnClick(int iColumn, int iSortType)
{
    HCURSOR     hcur;
    MESSAGEID   idMessage = 0;
    DWORD       iSel;

    TraceCall("CMessageList::_OnColumnClick");

    // In case this takes a while
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Clear old sort arrow image from the column header
    COLUMN_ID idSort;
    BOOL      fAscending;

    // Get the current sort information
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // If the caller passed in a new sort column, get it's id
    if (iColumn != -1)
    {
        idSort = m_cColumns.GetId(iColumn);
    }
        
    // Figure out what the new sort order will be
    if (iSortType == LIST_SORT_TOGGLE)
        fAscending = !fAscending;
    else if (iSortType == LIST_SORT_ASCENDING)
        fAscending = TRUE;
    else if (iSortType == LIST_SORT_DESCENDING)
        fAscending = FALSE;

    // Update the sort information
    m_cColumns.SetSortInfo(idSort, fAscending);

    // Now resort the table
    if (m_pTable)
    {
        // Locals
        FOLDERSORTINFO SortInfo;

        // Save the selection
        if (-1 != (iSel = ListView_GetFirstSel(m_ctlList)))
            m_pTable->GetRowMessageId(iSel, &idMessage);

        // Fill a SortInfo
        SortInfo.idColumn = idSort;
        SortInfo.fAscending = fAscending;
        SortInfo.fThreaded = m_fThreadMessages;
        SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
        SortInfo.ridFilter = m_ridFilter;
        SortInfo.fShowDeleted = m_fShowDeleted;
        SortInfo.fShowReplies = m_fShowReplies;

        // Sort the table
        m_pTable->SetSortInfo(&SortInfo, this);

        // Make sure the filter got set correctly
        _DoFilterCheck(SortInfo.ridFilter);
        
        // Sorting can change the threading, which affects the item count
        _UpdateListViewCount();

        // Restore the selected message
        if (idMessage != 0)
        {
            // Convert the bookmark to a item number
            m_pTable->GetRowIndex(idMessage, &iSel);
            if (iSel == -1)
            {
                // we couldn't find the item that previously had the focus, so
                // select the first item.
                iSel = 0;
            }

            // Tell the ListView to select the correct item and make sure it's 
            // visible.
            ListView_UnSelectAll(m_ctlList);
            ListView_SelectItem(m_ctlList, iSel);
            ListView_EnsureVisible(m_ctlList, iSel, FALSE);
        }

        // With a new sort order we should redraw the ListView viewing area
        m_ctlList.InvalidateRect(NULL, TRUE);
    }
            
    // Let the user get back to work
    SetCursor(hcur);
    return (0);
}

void CMessageList::_OnBeginDrag(NM_LISTVIEW *pnmlv)
{
    CMessageDataObject *pDataObject = 0;
    HRESULT             hr = S_OK;
    DWORD               dwEffectOk = DROPEFFECT_COPY;
    DWORD               dwEffect = 0;
    MESSAGEIDLIST       rMsgIDList;
    ROWINDEX           *rgRows;
    DWORD               i = 0;
    DWORD               cRows;
    int                 iItem = -1;

    // Create the data object
    if (0 == (pDataObject = new CMessageDataObject()))
        return;

    // Figure out how many rows there are selected
    cRows = ListView_GetSelectedCount(m_ctlList);

    // Allocate an array
    if (!MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * cRows))
        goto exit;

    // Loop through the rows getting their row indexs
    while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
    {
        rgRows[i++] = iItem;
    }

    // Now ask the table for a message ID list
    if (FAILED(m_pTable->GetMessageIdList(FALSE, cRows, rgRows, &rMsgIDList)))
        goto exit;

    // Initialize the data object
    pDataObject->Initialize(&rMsgIDList, m_idFolder);

    // If this folder is a news folder, then we only allow copies
    if (FOLDER_NEWS != GetFolderType(m_idFolder))
        dwEffectOk |= DROPEFFECT_MOVE;

    // AddRef() the drop source while we do this
    ((IDropSource *) this)->AddRef();
    hr = DoDragDrop(pDataObject, (IDropSource *) this, dwEffectOk, &dwEffect);
    ((IDropSource *) this)->Release();

exit:
    SafeMemFree(rgRows);
    SafeMemFree(rMsgIDList.prgidMsg);
    SafeRelease(pDataObject);

    return;
}

HRESULT CMessageList::OnResetView(void)
{
    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Sel change notification should happen here
    SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);

    // Reset the view
    _ResetView(idSel);

    // Done
    return(S_OK);
}

HRESULT CMessageList::OnRedrawState(BOOL fRedraw)
{
    // Just take the state
    m_fNotifyRedraw = fRedraw;

    // No Redraw ?
    if (FALSE == m_fNotifyRedraw)
        SetWindowRedraw(m_ctlList, FALSE);
    else
        SetWindowRedraw(m_ctlList, TRUE);

    // Done
    return(S_OK);
}


HRESULT CMessageList::OnInsertRows(DWORD cRows, LPROWINDEX prgiRow, BOOL fExpanded)
{
    // Trace
    TraceCall("CMessageList::OnInsertRows");

    BOOL        fScroll;
    LV_ITEM     lvi = {0};
    COLUMN_ID   idSort;
    BOOL        fAscending;
    DWORD       top, count, page;

    // If we have the empty list window visible, hide it
    m_cEmptyList.Hide();

    // Get the current sort column and direction
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Gather the information we need to determine if we should scroll
    top = ListView_GetTopIndex(m_ctlList);
    page = ListView_GetCountPerPage(m_ctlList);
    count = ListView_GetItemCount(m_ctlList);

    // We scroll if the user is sorted by date and the new item would
    // be off the bottom of the page.
    fScroll = fAscending && (idSort == COLUMN_SENT || idSort == COLUMN_RECEIVED) &&
              (top + page >= count - 1);

    // Insert the row
    for (ULONG i=0; i<cRows; i++)
    {
        lvi.iItem = prgiRow[i];
        ListView_InsertItem(m_ctlList, &lvi);
    }

#ifdef OLDTIPS
    // If we have tooltips turned on, update them too
    if (m_fViewTip && m_ctlViewTip)
    {
        POINT pt;
        GetCursorPos(&pt);
        ::ScreenToClient(m_ctlList, &pt);
        _UpdateViewTip(pt.x, pt.y, TRUE);
    }
#endif // OLDTIPS

    // Scroll if we need to
    if (fScroll && m_fMailFolder)
        ListView_EnsureVisible(m_ctlList, ListView_GetItemCount(m_ctlList) - 1, FALSE);

    int iFocus = ListView_GetFocusedItem(m_ctlList);
    
    if (!m_fMailFolder && iFocus != -1 && !fExpanded)
        ListView_EnsureVisible(m_ctlList, iFocus, TRUE);

    // Update the host
    Fire_OnMessageCountChanged(m_pTable);
    return (S_OK);
}

HRESULT CMessageList::OnDeleteRows(DWORD cDeleted, LPROWINDEX rgdwDeleted, BOOL fCollapsed)
{
    int     iItemFocus = -1;
    DWORD   dwCount;
    DWORD   iNewSel;
    BOOL    fFocusDeleted = FALSE;
    BOOL    fFocusHasSel = FALSE;

    // Can't delete that which we do not have
    if (!m_pTable)
        return (0);

    // If we're going to delete everything
    if (cDeleted == (DWORD) -1)
    {
        iItemFocus = ListView_GetFirstSel(m_ctlList);
        if (iItemFocus != -1)
        {
            m_pTable->GetRowMessageId(iItemFocus, &m_idPreDelete);
        }
        else
            m_idPreDelete = 0;
    }
    else if (cDeleted != 0)
    {
        // Figure out which row has the focus.
        iItemFocus = ListView_GetFocusedItem(m_ctlList);

        // Figure out if the focused item was selected
        if (iItemFocus != -1)
            fFocusHasSel = !!(ListView_GetItemState(m_ctlList, iItemFocus, LVIS_SELECTED));

        for (ULONG i = 0; i < cDeleted; i++)
        {
            // If we're removing the row that has the focus, we're going to 
            // need to fix up the selection later.
            if (0 != ListView_GetItemState(m_ctlList, rgdwDeleted[i], LVIS_FOCUSED))
                fFocusDeleted = TRUE;

            ListView_DeleteItem(m_ctlList, rgdwDeleted[i]);
        }

        // Check to see if we deleted the item that had focus
        if (fFocusDeleted && fFocusHasSel)
        {
            // Get the new row with focus.  This ListView keeps moving the focus
            // as we delete rows.
            iItemFocus = ListView_GetFocusedItem(m_ctlList);

            // Select that item now.
            ListView_SelectItem(m_ctlList, iItemFocus);
        }

        // ListView_EnsureVisible(m_ctlList, iItemFocus, FALSE);

#ifdef OLDTIPS
        // If we have tooltips turned on, update them too
        if (m_fViewTip && m_ctlViewTip)
        {
            POINT pt;
            GetCursorPos(&pt);
            ::ScreenToClient(m_ctlList, &pt);
            _UpdateViewTip(pt.x, pt.y, TRUE);
        }
#endif // OLDTIPS
    }
    else
    {
        // If cDel is zero, then we should just reset the count of messages
        // with what's in the container.
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount);

        // Get the first selected item
        iItemFocus = ListView_GetFirstSel(m_ctlList);

        // Set the new number of items
        ListView_SetItemCountEx(m_ctlList, dwCount, LVSICF_NOSCROLL);

        // If there are messages then make sure the focus is appropriate
        if (dwCount)
        {
            if (iItemFocus != -1)
            {
                if (m_idPreDelete != 0)
                {
                    // Get the index of the bookmarked row
                    m_pTable->GetRowIndex(m_idPreDelete, &iNewSel);
                    if (iNewSel != -1)
                        iItemFocus = (int) iNewSel;
                    m_idPreDelete = 0;
                }

                // Clear the selection, then select this item and ensure it's 
                // visible.
                ListView_UnSelectAll(m_ctlList);
                ListView_SelectItem(m_ctlList, min((int) iItemFocus, (int) dwCount - 1));
                ListView_EnsureVisible(m_ctlList, min((int) iItemFocus, (int) dwCount - 1), FALSE);
            }
            else
            {
                ListView_UnSelectAll(m_ctlList);
                _SelectDefaultRow();
            }
        }
    }

    // Check to see if we need to put up the empty list warning.
    if (SUCCEEDED(m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount)))
    {
        if (0 == dwCount)
        {
            m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
        }
    }

    Fire_OnMessageCountChanged(m_pTable);

    // Done
    return(S_OK);
}

HRESULT CMessageList::OnUpdateRows(ROWINDEX iRowMin, ROWINDEX iRowMax)
{
    // Locals
    BOOL fHandled;

    // Trace
    TraceCall("CMessageList::OnUpdateRows");

    // Just do it
    OnHeaderStateChange(IMC_HDRSTATECHANGE, iRowMin, iRowMax, fHandled);

    // Done
    return(S_OK);
}

HRESULT CMessageList::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    // If this isn't NULL, then we forgot to free it last time.
    Assert(m_tyCurrent == SOT_INVALID);

    m_tyCurrent = tyOperation;

    if (tyOperation == SOT_GET_MESSAGE && pOpInfo)
    {
        // cache the current get message, for the oncomplete notification
        m_idMessage = pOpInfo->idMessage;        
    }

    // Got to hang on to this
    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();

        // Update the toolbar to activate ID_STOP.
        Fire_OnUpdateCommandState();
    }

    // Start the progress parade
    Fire_OnUpdateProgress(0, 0, PROGRESS_STATE_BEGIN);

    SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
    return (S_OK);
}


HRESULT CMessageList::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}


HRESULT CMessageList::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


HRESULT CMessageList::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndParent, pServer, ixpServerType);
}


HRESULT CMessageList::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, 
                               UINT uType, INT *piUserResponse) 
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndParent, hrError, pszText, pszCaption, uType, piUserResponse);
}


HRESULT CMessageList::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent,
                                 DWORD dwMax, LPCSTR pszStatus)
{
    TCHAR szRes[CCHMAX_STRINGRES];
    TCHAR szBuf[CCHMAX_STRINGRES];
    TCHAR szProg[MAX_PATH + CCHMAX_STRINGRES];

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Deal with universal progress types
    switch (tyOperation)
    {
        // pszStatus == Server Name, dwCurrent = IXPSTATUS
        case SOT_CONNECTION_STATUS:
        {
            Assert(dwCurrent < IXP_LAST);

            // Create some lovely status text
            if (dwCurrent == IXP_DISCONNECTED)
            {
                AthLoadString(idsNotConnectedTo, szRes, ARRAYSIZE(szRes));
                wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, pszStatus);
                Fire_OnUpdateStatus(szBuf);
            }
            else
            {
                int ids = XPUtil_StatusToString((IXPSTATUS) dwCurrent);
                AthLoadString(ids, szRes, ARRAYSIZE(szRes));
            
                // Hit our host with this lovely string
                Fire_OnUpdateStatus(szRes);
            }
            break;
        }

        case SOT_NEW_MAIL_NOTIFICATION:
            ::PostMessage(m_hwndParent, WM_NEW_MAIL, 0, 0);
            break;
    }

    // If we're expecting progress for one command, but this ain't it, blow
    // it off.
    if (m_tyCurrent != tyOperation)
        return (S_OK);

    // Deal with the the various operation types
    switch (tyOperation)
    {
        case SOT_SORTING:
        {
            static CHAR s_szSorting[255]={0};
            if ('\0' == *s_szSorting)
                AthLoadString(idsSortingFolder, s_szSorting, ARRAYSIZE(s_szSorting));
            DWORD dwPercent = dwMax > 0 ? ((dwCurrent * 100) / dwMax) : 0;
            wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szSorting, dwPercent);
            Fire_OnUpdateStatus(szBuf);
            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
            break;
        }

        // pszStatus == folder name
        case SOT_SYNC_FOLDER:
        {
            // Create some lovely status text
            AthLoadString(idsIMAPDnldProgressFmt, szRes, ARRAYSIZE(szRes));
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, dwCurrent, dwMax);
            Fire_OnUpdateStatus(szBuf);

            // Also update the progress bar too
            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
            break;
        }

        case SOT_SET_MESSAGEFLAGS:
        {
            // If we were given status text, then tell our host
            if (pszStatus)
            {
                // Create some lovely status text
                AthLoadString(idsMarkingMessages, szRes, ARRAYSIZE(szRes));
                Fire_OnUpdateStatus(szRes);
            }

            // Also update the progress bar too
            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
            break;
        }
    
        case SOT_GET_MESSAGE:
        {
            ROWINDEX    iRow;
            LPMESSAGEINFO pInfo;
            
            if (!m_pszSubj)
            {
                if (m_pTable && (!FAILED(m_pTable->GetRowIndex(m_idMessage, &iRow))))
                {
                    if (!FAILED(m_pTable->GetRow(iRow, &pInfo)))
                    {
                        // clip subject to MAX_PATH chars to avoid buffer overrun
                        m_pszSubj = PszDupLenA(pInfo->pszSubject, MAX_PATH-1);
                        m_pTable->ReleaseRow(pInfo);
                    }
                } 
            }
            
            if (m_pszSubj)
            {
                // Show "Downloading Message: '<subject>'" (<subject> is clipped to MAX_PATH)
                AthLoadString(idsFmtDownloadingMessage, szRes, ARRAYSIZE(szRes));
                wnsprintf(szProg, ARRAYSIZE(szProg), szRes, m_pszSubj);
                Fire_OnUpdateStatus(szProg);
            }

            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
        }

    }

    return (S_OK);
}


HRESULT CMessageList::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete,
                                 LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    if (m_tyCurrent != tyOperation)
        return S_OK;

    // AddRef
    ((IStoreCallback *) this)->AddRef();

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    if (tyOperation == SOT_GET_ADURL )
    {
        if (SUCCEEDED(hrComplete) && pOpInfo)
            Fire_OnAdUrlAvailable(pOpInfo->pszUrl);

        if (m_pCancel)
        {
            m_pCancel->Release();
            m_pCancel = NULL;
        }

        // Close any timeout dialog, if present
        CallbackCloseTimeout(&m_hTimeout);
        Fire_OnUpdateProgress(0, 0, PROGRESS_STATE_END);

        goto exit;
    }

    if (tyOperation == SOT_GET_MESSAGE)
    {
        // message-download complete, fire a notification to
        // our host
    
        // supress article expired failures, we want to update the preview pane anyway
        // and it will update with an error that it has expired
        if (hrComplete == IXP_E_NNTP_ARTICLE_FAILED && pErrorInfo && 
            (pErrorInfo->uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_NUM || pErrorInfo->uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_FOUND))
            hrComplete = STORE_E_EXPIRED;

        // if call to OnMessageAvailable reutrn S_OK, then it has been handled so supress
        // error messages
        if (Fire_OnMessageAvailable(m_idMessage, hrComplete)==S_OK)
            hrComplete = S_OK;

        m_idMessage = MESSAGEID_INVALID;
        SafeMemFree(m_pszSubj);
    }

    // Release our cancel pointer
    if (m_pCancel)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
        Fire_OnUpdateCommandState();
    }

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // We're done now
    Fire_OnUpdateProgress(0, 0, PROGRESS_STATE_END);

    // Display an Error on Failures
    if (FAILED(hrComplete) && hrComplete != HR_E_OFFLINE)
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndParent, hrComplete, pErrorInfo);
    }

    if (NULL != m_pTable && tyOperation == SOT_SYNC_FOLDER || tyOperation == SOT_SEARCHING)
    {
        DWORD dwCount;  

        Assert (m_pTable);

        // Get the current selection
        DWORD iSel = ListView_GetFirstSel(m_ctlList);

        // Bookmark the current selection
        MESSAGEID idSel = 0;
        if (iSel != -1)
            m_pTable->GetRowMessageId(iSel, &idSel);

        // If this succeeds reset the view
        if (SUCCEEDED(m_pTable->OnSynchronizeComplete()))
        {
            // Reset the view
            _ResetView(idSel);

            // Update the status
            Fire_OnMessageCountChanged(m_pTable);
        }

        // Check to see if we need to put up the empty list warning.
        if (SUCCEEDED(m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount)))
        {
            if (0 == dwCount)
            {
                m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
            }
        }
    }
    
exit:
    m_tyCurrent = SOT_INVALID;

    // Release
    ((IStoreCallback *) this)->Release();

    return (S_OK);
}


HRESULT CMessageList::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hrResult;

    TraceCall("CMessageList::GetParentWindow");
    if (IsWindow(m_hwndParent))
    {
        *phwndParent = m_hwndParent;
        hrResult = S_OK;
    }
    else
    {
        *phwndParent = NULL;
        hrResult = E_FAIL;
    }

    return hrResult;
}


HRESULT CMessageList::CanConnect(LPCSTR pszAccountId, DWORD dwFlags) 
{ 
    BOOL        fPrompt = FALSE;
    HWND        hwndParent;
    DWORD       dwReserved = 0;
    HRESULT     hr;

    //Irrespective of the operation, prompt if we are not offline
    fPrompt = (g_pConMan->IsGlobalOffline() == FALSE);

    if (GetParentWindow(dwReserved, &hwndParent) != S_OK)
    {
        fPrompt = FALSE;
    }

    if (CC_FLAG_DONTPROMPT & dwFlags)
        fPrompt = FALSE;

    hr = CallbackCanConnect(pszAccountId, hwndParent, fPrompt);

    if ((hr == HR_E_DIALING_INPROGRESS) && (m_tyCurrent == SOT_SYNC_FOLDER))
    {
        //this sync operation will eventually fail. But we sync again when we get called in Resynchronize
        m_fSyncAgain = TRUE;
    }
    return hr;
}

HRESULT CMessageList::Resynchronize()
{
    DWORD       dwChunks;
    HRESULT     hr = S_OK;

    if (m_fSyncAgain)
    {
        m_fSyncAgain = FALSE;

        //If we are offline, that is because the user hit cancel or work offline on dialer UI
        if (g_pConMan && (g_pConMan->IsGlobalOffline()))
        {
            g_pConMan->SetGlobalOffline(FALSE);
        }

        // Tell the table to go sync any headers from the server
        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
        {
            if (OPTION_OFF != m_dwGetXHeaders)
                hr = m_pTable->Synchronize(SYNC_FOLDER_XXX_HEADERS, m_dwGetXHeaders, this);
            else
                hr = m_pTable->Synchronize(NOFLAGS, 0, this);
        }
        else
        {
            hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }
    return hr;
}

HRESULT CMessageList::HasFocus(void)
{
    if (GetFocus() == m_ctlList)
        return (S_OK);
    else
        return (S_FALSE);
}


#define MF_CHECKFLAGS(b)    (MF_BYCOMMAND|(b?MF_CHECKED:MF_UNCHECKED))
HRESULT CMessageList::OnPopupMenu(HMENU hMenu, DWORD idPopup)
{
    MENUITEMINFO    mii;
    
    // Edit Menu
    if (idPopup == ID_POPUP_EDIT)
    {
        // Figure out which item is focused
        int iItem = ListView_GetFocusedItem(m_ctlList);
        if (-1 != iItem && m_pTable)
        {
            DWORD dwState;

            m_pTable->GetRowState(iItem, ROW_STATE_FLAGGED, &dwState);
            CheckMenuItem(hMenu, ID_FLAG_MESSAGE, MF_BYCOMMAND | (dwState & ROW_STATE_FLAGGED) ? MF_CHECKED : MF_UNCHECKED);
        }
    } 

    // View Menu
    else if (idPopup == ID_POPUP_VIEW)
    {
        // Get the handle of the "Sort" menu
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU;
    
        if (GetMenuItemInfo(hMenu, ID_POPUP_SORT, FALSE, &mii))
        {
            // Add the sort menu information
            m_cColumns.FillSortMenu(mii.hSubMenu, ID_SORT_MENU_FIRST, &m_cSortItems, &m_cSortCurrent);                
            m_iColForPopup = -1;
        }
    }    
    return (S_OK);
}


LRESULT CMessageList::OnListVScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT     lResult;
    int         iTopIndex;
    TOOLINFO    ti = {0};
    TCHAR       sz[1024];
    BOOL        fLogicalLeft = FALSE;

    // Let the ListView have the scroll message first
    lResult = m_ctlList.DefWindowProc(uMsg, wParam, lParam);

    // We only do the scroll tips if m_fScrollTip is TRUE
    if (!m_fScrollTip)
        return (lResult);

    // If the user is dragging the thumb, then update our tooltip
    if (LOWORD(wParam) == SB_THUMBTRACK)
    {
        // Figure out what the top most index is
        iTopIndex = ListView_GetTopIndex(m_ctlList);

        // Set the tip text
        ti.cbSize   = sizeof(TOOLINFO);
        ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
        ti.hwnd     = m_hWnd;
        ti.uId      = (UINT_PTR)(HWND) m_ctlList;

        COLUMN_ID idSort;
        BOOL      fAscending;
        DWORD     col;
        
        // Get the column we're currently sorted on
        m_cColumns.GetSortInfo(&idSort, &fAscending);

        // Get the row from the table
        LPMESSAGEINFO pInfo;

        if (SUCCEEDED(m_pTable->GetRow(iTopIndex, &pInfo)))
        {
            // Get the display text for this row
            if (idSort != COLUMN_SUBJECT)
                _GetColumnText(pInfo, idSort, sz, ARRAYSIZE(sz));
            else if (pInfo->pszNormalSubj)
                lstrcpyn(sz, pInfo->pszNormalSubj, ARRAYSIZE(sz));
            else
                //Bug #101352 - (erici) Don't pass NULL src to lstrcpyn.  It will fail and not initialize this buffer.
                memset(&sz, 0, sizeof(sz));

            if (*sz == 0)
                AthLoadString(idsNoSubject, sz, ARRAYSIZE(sz));

            ti.lpszText = sz;
#ifdef OLDTIPS
            m_ctlScrollTip.SendMessage(TTM_UPDATETIPTEXT, 0, (LPARAM) &ti);
    
            // Update the position.  The y position will be where the mouse 
            // cursor is.  The x position is either fixed to the right edge
            // of the scroll bar, or the left edge depending on how close
            // the edge of the screen is.
            POINT pt;
            RECT rc;
            RECT rcTip;
            DWORD cxScreen;
            BOOL bMirrored = IS_WINDOW_RTL_MIRRORED(m_hWnd);
            // Get the mouse position, the window position, and the screen
            // width.
            GetCursorPos(&pt);
            GetWindowRect(&rc);
            m_ctlScrollTip.GetWindowRect(&rcTip);
            cxScreen = GetSystemMetrics(SM_CXSCREEN);

            // Check to see if we're too close to the screen edge
            if (((cxScreen - pt.x > 100) && !bMirrored) || ((pt.x > 100) && bMirrored))
            {
               if(bMirrored)
               {
                    pt.x = rc.left - GetSystemMetrics(SM_CXBORDER);

                    // Make sure the tip isn't wider than the screen.
                    m_ctlScrollTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, pt.x);
                    pt.x -= (rcTip.right - rcTip.left);
               
               }
               else
               {
                    pt.x = rc.right + GetSystemMetrics(SM_CXBORDER);

                    // Make sure the tip isn't wider than the screen.
                    m_ctlScrollTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, cxScreen - pt.x);
                }
            }
            else
            {
                // So we can verify later
                fLogicalLeft = TRUE;

                // Figure out how wide the string will be
                SIZE size;
                HDC hdcTip = m_ctlScrollTip.GetDC();
                GetTextExtentPoint32(hdcTip, sz, lstrlen(sz), &size);
                m_ctlScrollTip.ReleaseDC(hdcTip);

                // Figure out if the string is wider than our window
                if (size.cx > (rc.right - rc.left))
                {
                    if(bMirrored)
                    {
                        pt.x = rc.right - (rcTip.right - rcTip.left);                    
                    }
                    else
                    {
                        pt.x = rc.left;
                    }    
                }
                else
                {
                    RECT rcMargin;
                    m_ctlScrollTip.SendMessage(TTM_GETMARGIN, 0, (LPARAM) &rcMargin);
                    if(bMirrored)
                    {
                        pt.x = rc.left + GetSystemMetrics(SM_CXHTHUMB);                    
                    }
                    else
                    {
                        pt.x = rc.right - GetSystemMetrics(SM_CXHTHUMB) - rcMargin.left - rcMargin.right - size.cx;
                    }
                }

                // Make sure the tip isn't wider than the window
                m_ctlScrollTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, rc.right - rc.left);
            }

            // Show the tooltip
            if (!m_fScrollTipVisible)
            {               
                m_ctlScrollTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
                m_fScrollTipVisible = TRUE;

                // Set the autohide timer
                SetTimer(IDT_SCROLL_TIP_TIMER, 250, NULL);
            }
            
            // Update the tip position
            m_ctlScrollTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));

            if (fLogicalLeft)
            {
                // Get the position of the tip

                int x;
                m_ctlScrollTip.GetWindowRect(&rcTip);
                
                if(bMirrored)
                {
                    x = rc.left + GetSystemMetrics(SM_CXHTHUMB) + 4;
                    
                }
                else
                {
                    x = rc.right - GetSystemMetrics(SM_CXHTHUMB) - (rcTip.right - rcTip.left) - 4;
                }
                m_ctlScrollTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(x, rcTip.top));

            }
#endif //OLDTIPS
            m_pTable->ReleaseRow(pInfo);
        }
    }

    return (lResult);
}



//
//  FUNCTION:   CMessageList::OnDestroy()
//
//  PURPOSE:    When we get destroyed, we need to make sure we destroy the tooltips
//              as well.  If we don't we will fault on shutdown.
//
LRESULT CMessageList::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    KillTimer(IDT_POLLMSGS_TIMER);

    // Don't care about these any more
    if (m_pListSelector)
    {
        m_pListSelector->Unadvise();
        m_pListSelector->Release();
    }

#ifdef OLDTIPS
    if (IsWindow(m_ctlScrollTip))
    {
        m_ctlScrollTip.SendMessage(TTM_POP, 0, 0);
        m_ctlScrollTip.DestroyWindow();
    }

    if (IsWindow(m_ctlViewTip))
    {
        m_ctlViewTip.SendMessage(TTM_POP, 0, 0);
        m_ctlViewTip.DestroyWindow();
    }
#endif // OLDTIPS

    // Release the font cache if we are advised on it.
    if (m_dwFontCacheCookie && g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Unadvise(m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    return (0);
}


//
//  FUNCTION:   CMessageList::OnSelectRow()
//
//  PURPOSE:    This get's called when the user does a next / prev in the notes.
//
LRESULT CMessageList::OnSelectRow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (lParam < ListView_GetItemCount(m_ctlList))
    {
        ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
        ListView_SetItemState(m_ctlList, lParam, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        ListView_EnsureVisible(m_ctlList, lParam, FALSE);
    }

    return (0);
}


#ifdef OLDTIPS
//
//  FUNCTION:   CMessageList::OnListMouseEvent()
//
//  PURPOSE:    Whenever we get our first mouse event in a series, we call
//              TrackMouseEvent() so we know when the mouse leaves the ListView.
//
LRESULT CMessageList::OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If we have the view tooltip, then we track all mouse events
    if (!m_fTrackSet && m_fViewTip && (uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST))
    {
        TRACKMOUSEEVENT tme;

        tme.cbSize = sizeof(tme);
        tme.hwndTrack = m_ctlList;
        tme.dwFlags = TME_LEAVE;

        if (_TrackMouseEvent(&tme))
            m_fTrackSet = TRUE;
    }

    bHandled = FALSE;
    return (0);
}


//
//  FUNCTION:   CMessageList::OnListMouseMove()
//
//  PURPOSE:    If the ListView tooltips are turned on, we need to relay mouse
//              move messages to the tooltip control and update our cached 
//              information about what the mouse is over.
//
LRESULT CMessageList::OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    MSG msg;
    LVHITTESTINFO lvhti;

    // If we're displaying view tips, then we need to figure out if the mouse is
    // over the same item or not.
    if (m_fViewTip && m_ctlViewTip)
    {
        if (_UpdateViewTip(LOWORD(lParam), HIWORD(lParam)))
        {
            /*
            msg.hwnd    = m_ctlList;
            msg.message = uMsg;
            msg.wParam  = wParam;
            msg.lParam  = lParam;
            m_ctlViewTip.SendMessage(TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
            */
        }
    }

    bHandled = FALSE;
    return (0);
}


//
//  FUNCTION:   CMessageList::OnListMouseLeave()
//
//  PURPOSE:    When the mouse leaves the ListView window, we need to make
//              sure we hide the tooltip.
//
LRESULT CMessageList::OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TOOLINFO ti = {0};

    if (m_fViewTip && m_ctlViewTip)
    {
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)(HWND) m_ctlList;

        // Hide the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
        m_fViewTipVisible = FALSE;

        // Reset our item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        // Tracking is no longer set
        m_fTrackSet = FALSE;
    }

    bHandled = FALSE;
    return (0);
}
#endif // OLDTIPS


LRESULT CMessageList::OnListSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If an operation is pending and the cursor would be the arrow, change it
    // into the appstart arrow
    if (m_pCancel && LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        return (1);
    }
        
    // Find out what the default is
    return ::DefWindowProc(m_ctlList, uMsg, wParam, lParam);
}


#ifdef OLDTIPS
BOOL CMessageList::_UpdateViewTip(int x, int y, BOOL fForceUpdate)
{
    LVHITTESTINFO lvhti;
    TOOLINFO      ti = {0};
    FNTSYSTYPE    fntType;
    RECT          rc;
    LPMESSAGEINFO pInfo;
    COLUMN_ID     idColumn;
    TCHAR         szText[256] = _T("");
    POINT         pt;
    LVITEM        lvi;
    int           top, page;

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd   = m_hWnd;
    ti.uId    = (UINT_PTR)(HWND) m_ctlList;

    // Get the item and subitem the mouse is currently over
    lvhti.pt.x = x;
    lvhti.pt.y = y;
    ListView_SubItemHitTest(m_ctlList, &lvhti);

    top = ListView_GetTopIndex(m_ctlList);
    page = ListView_GetCountPerPage(m_ctlList);

    // If the item doesn't exist, then the above call returns the item -1.  If
    // we encounter -1, we break the loop and return FALSE.
    if (lvhti.iItem < top || lvhti.iItem > (top + page) || -1 == lvhti.iItem || !_IsItemTruncated(lvhti.iItem, lvhti.iSubItem) || !::IsChild(GetForegroundWindow(), m_ctlList))
    {
        // Hide the tip
        if (m_fViewTipVisible)
        {
            m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
            m_fViewTipVisible = FALSE;
        }

        // Reset the item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        return (FALSE);
    }

    // If we don't have the tooltip visible right now, then delay before we display it
    if (!m_fViewTipVisible && !fForceUpdate)
    {
        ::SetTimer(m_hWnd, IDT_VIEWTIP_TIMER, 500, NULL);
        return (FALSE);
    }

    // If the newly found item & subitem is different from what we're already
    // set up to show, then update the tooltip
    if (fForceUpdate || (m_iItemTip != lvhti.iItem || m_iSubItemTip != lvhti.iSubItem))
    {
        // Update our cached item / subitem
        m_iItemTip = lvhti.iItem;
        m_iSubItemTip = lvhti.iSubItem;

        // Set the font for the tooltip
        fntType = _GetRowFont(m_iItemTip);
        m_ctlViewTip.SendMessage(WM_SETFONT, (WPARAM) HGetCharSetFont(fntType, m_hCharset), 0);

        // Get the row from the table
        if (m_pTable && SUCCEEDED(m_pTable->GetRow(m_iItemTip, &pInfo)))
        {
            // Convert the iSubItem to a COLUMN_ID
            idColumn = m_cColumns.GetId(m_iSubItemTip);

            // Get the display text for this row
            _GetColumnText(pInfo, idColumn, szText, ARRAYSIZE(szText));

            ti.lpszText = szText;
            m_ctlViewTip.SendMessage(TTM_UPDATETIPTEXT, 0, (LPARAM) &ti);

            // Figure out where to place the tip
            ListView_GetSubItemRect(m_ctlList, m_iItemTip, m_iSubItemTip, LVIR_LABEL, &rc);
            m_ctlList.MapWindowPoints(HWND_DESKTOP, (LPPOINT)&rc, 2);

            // Make sure the tip is no wider than our window
            RECT rcWindow;
            GetWindowRect(&rcWindow);
            m_ctlViewTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, rcWindow.right - rc.left);

            // Do some voodoo to line up the tooltip
            pt.x = rc.left;
            pt.y = rc.top;

            // Figure out if this column has an image
            lvi.mask = LVIF_IMAGE;
            lvi.iItem = m_iItemTip;
            lvi.iSubItem = m_iSubItemTip;
            ListView_GetItem(m_ctlList, &lvi);

            if (lvi.iImage == -1)
            {                
                RECT rcHeader;
                HWND hwndHeader = ListView_GetHeader(m_ctlList);
                Header_GetItemRect(hwndHeader, m_iSubItemTip, &rcHeader);
                ::MapWindowPoints(hwndHeader, HWND_DESKTOP, (LPPOINT) &rcHeader,2);
                pt.x = rcHeader.left + (GetSystemMetrics(SM_CXEDGE) * 2) - 1;
            }
            else
                pt.x -= GetSystemMetrics(SM_CXBORDER);

            // Update the tooltip position
            pt.y -= 2 * GetSystemMetrics(SM_CXBORDER);

            m_ctlViewTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));

            // Update the tooltip
            m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
            m_fViewTipVisible = TRUE;

            m_pTable->ReleaseRow(pInfo);

            return (TRUE);
        }
    }

    return (FALSE);
}


//
//  FUNCTION:   CMessageList::_OnViewTipShow()
//
//  PURPOSE:    When the tooltip for the ListView get's shown, we need to 
//              update the font and position for the tip.
//
LRESULT CMessageList::_OnViewTipShow(void)
{
    RECT       rc;
    FNTSYSTYPE fntType;

    // We only get the text for items that exist
    if (m_iItemTip != -1 && m_iSubItemTip != -1)
    {
        // Set the font for the tooltip
        fntType = _GetRowFont(m_iItemTip);
        m_ctlViewTip.SendMessage(WM_SETFONT, (WPARAM) HGetCharSetFont(fntType, m_hCharset), 0);
                                 
        // Figure out where to place the tip
        ListView_GetSubItemRect(m_ctlList, m_iItemTip, m_iSubItemTip, LVIR_LABEL, &rc);
        m_ctlList.ClientToScreen(&rc);

        // Set the position of the tip
        m_ctlViewTip.SetWindowPos(NULL, rc.left - GetSystemMetrics(SM_CXBORDER), 
                                  rc.top - GetSystemMetrics(SM_CXBORDER), 0, 0, 
                                  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    }

    return (0);
}


LRESULT CMessageList::_OnViewTipGetDispInfo(LPNMTTDISPINFO pttdi)
{
    LPMESSAGEINFO pInfo;
    COLUMN_ID idColumn;

    // If this is the case, there's nothing to provide
    if (-1 == m_iItemTip || !m_pTable)
        return (0);

    // Sanity check
    if (m_iItemTip > (ListView_GetItemCount(m_ctlList) - 1))
    {
        Assert(FALSE);
        m_iItemTip = -1;
        return (0);
    }

    // Get the row from the table
    if (FAILED(m_pTable->GetRow(m_iItemTip, &pInfo)))
        return (0);

    // Convert the iSubItem to a COLUMN_ID
    idColumn = m_cColumns.GetId(m_iSubItemTip);

    // Get the text for the item from the table
    _GetColumnText(pInfo, idColumn, pttdi->szText, ARRAYSIZE(pttdi->szText));

    m_pTable->ReleaseRow(pInfo);

    if (*pttdi->szText == 0)
        return (0);

    return (1);
}


BOOL CMessageList::_IsItemTruncated(int iItem, int iSubItem)
{
    HDC     hdc;
    SIZE    size;
    BOOL    bRet = TRUE;
    LVITEM  lvi;
    TCHAR   szText[256] = _T("");
    int     cxEdge;
    BOOL    fBold;
    RECT    rcText;
    int     cxWidth;
    HFONT   hf;

    // Get the text of the specified item
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;
    lvi.iItem = iItem;
    lvi.iSubItem = iSubItem;
    lvi.pszText = szText;
    lvi.cchTextMax = ARRAYSIZE(szText);
    ListView_GetItem(m_ctlList, &lvi);

    // If there's no text, it's not truncated, eh?
    if (0 == *szText)
        return (FALSE);

    // ListView uses this for padding
    cxEdge = GetSystemMetrics(SM_CXEDGE);

    // Get the sub item rect from the ListView
    ListView_GetSubItemRect(m_ctlList, iItem, iSubItem, LVIR_LABEL, &rcText);

    // Figure out the width
    cxWidth = rcText.right - rcText.left;
    if (lvi.iImage == -1)
        cxWidth -= (4 * cxEdge);
    else
        cxWidth -= (2 * cxEdge);

    // Figure out the width of the string
    hdc = m_ctlList.GetDC();
    hf = SelectFont(hdc, HGetCharSetFont(_GetRowFont(iItem), m_hCharset));

    GetTextExtentPoint(hdc, szText, lstrlen(szText), &size);

    SelectFont(hdc, hf);
    m_ctlList.ReleaseDC(hdc);

    return (cxWidth < size.cx);
}
#endif // OLDTIPS


FNTSYSTYPE CMessageList::_GetRowFont(int iItem)
{
    HFONT      hFont;
    FNTSYSTYPE fntType;
    DWORD      dwState;

    // Get the row state information
    m_pTable->GetRowState(iItem, ROW_STATE_DELETED, &dwState);

    // Determine the right font for this row
    if (dwState & ROW_STATE_DELETED)
        fntType = FNT_SYS_ICON_STRIKEOUT;
    else
    {
        m_pTable->GetRowState(iItem, ROW_STATE_READ, &dwState);
        if (dwState & ROW_STATE_READ)
            fntType = FNT_SYS_ICON;
        else
            fntType = FNT_SYS_ICON_BOLD;
    }        

    return (fntType);
}


void CMessageList::_SetColumnSet(FOLDERID id, BOOL fFind)
{
    FOLDERINFO      rFolder;
    COLUMN_SET_TYPE set;
    HRESULT         hr;

    // If we've already initialized, bail
    if (m_fColumnsInit)
        return;

    // Get the folder type from the store
    hr = g_pStore->GetFolderInfo(id, &rFolder);
    if (FAILED(hr))
        return;

    // Local store
    if (FOLDER_LOCAL == rFolder.tyFolder)
    {
        // Find
        if (fFind)
            set = COLUMN_SET_FIND;
        else 
        {
            // If this is the Outbox or Sent Items folder, we use the outbound
            // folder columns.
            if (rFolder.tySpecial == FOLDER_OUTBOX || rFolder.tySpecial == FOLDER_SENT || rFolder.tySpecial == FOLDER_DRAFT)
                set = COLUMN_SET_OUTBOX;
            else
                set = COLUMN_SET_MAIL;
        }
    }
    else if (FOLDER_IMAP == rFolder.tyFolder)
    {
        // If this is the Outbox or Sent Items folder, we use the outbound
        // folder columns.
        if (rFolder.tySpecial == FOLDER_OUTBOX || rFolder.tySpecial == FOLDER_SENT)
            set = COLUMN_SET_IMAP_OUTBOX;
        else
            set = COLUMN_SET_IMAP;
    }
    else if (FOLDER_NEWS == rFolder.tyFolder)
    {
        if (fFind)
            set = COLUMN_SET_FIND;
        else
            set = COLUMN_SET_NEWS;
    }
    else if (FOLDER_HTTPMAIL == rFolder.tyFolder)
    {
        if (rFolder.tySpecial == FOLDER_OUTBOX || rFolder.tySpecial == FOLDER_SENT)
            set = COLUMN_SET_HTTPMAIL_OUTBOX;
        else
            set = COLUMN_SET_HTTPMAIL;
    }

    // Save it
    m_ColumnSetType = set;

    // If the ListView has already been created, update the columns.
    if (IsWindow(m_ctlList))
    {
        BYTE rgBuffer[256];
        DWORD cb = ARRAYSIZE(rgBuffer);

        m_cColumns.Initialize(m_ctlList, m_ColumnSetType);

        // Get the column info from the table
        m_cColumns.ApplyColumns(COLUMN_LOAD_REGISTRY, 0, 0);
    }

    g_pStore->FreeRecord(&rFolder);
    m_fColumnsInit = TRUE;
}

HRESULT CMessageList::get_Folder(ULONGLONG *pVal)
{
    if (pVal)
    {
        *pVal = (ULONGLONG) m_idFolder;
        return (S_OK);
    }

    return (E_FAIL);
}


HRESULT CMessageList::put_Folder(ULONGLONG newVal)
{
    HRESULT hr = S_OK;

    if (FireOnRequestEdit(DISPID_LISTPROP_FOLDER) == S_FALSE)
        return S_FALSE;

    if (SUCCEEDED(hr = SetFolder((FOLDERID) newVal, NULL, FALSE, NULL, this)))
    {
        FireOnChanged(DISPID_LISTPROP_FOLDER);
        return (S_OK);
    }

    return (hr);
}


HRESULT CMessageList::get_ExpandGroups(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fAutoExpandThreads;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ExpandGroups(BOOL newVal)
{
    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_EXPAND_GROUPS) == S_FALSE)
        return S_FALSE;

    // Save it.  If we haven't got a table yet we'll save the value for later.
    m_fAutoExpandThreads = newVal;

    // Only party if we have a message table, eh?
    if (m_pTable)
    {
        // Do it
        if (m_fAutoExpandThreads)
            m_pTable->Expand(-1);
        else
            m_pTable->Collapse(-1);

        _UpdateListViewCount();
    }

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_EXPAND_GROUPS);

    return (S_OK);
}


HRESULT CMessageList::get_GroupMessages(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fThreadMessages;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_GroupMessages(BOOL newVal)
{
    // Update the ListView
    COLUMN_ID       idSort;
    BOOL            fAscending;
    FOLDERSORTINFO  SortInfo;

    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_GROUP_MESSAGES) == S_FALSE)
        return S_FALSE;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Save the new setting
    m_fThreadMessages = newVal;

    // Adjust show replies filter
    m_fShowReplies = m_fThreadMessages ? m_fShowReplies : FALSE;
   
    // Get the Sort Info
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Set the Sort Info
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reload the table.
    _ResetView(idSel);

    if (m_fThreadMessages)
        ListView_SetImageList(m_ctlList, GetImageList(GIML_STATE), LVSIL_STATE);
    else
        ListView_SetImageList(m_ctlList, NULL, LVSIL_STATE);

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_GROUP_MESSAGES);

    return S_OK;
}


HRESULT CMessageList::get_SelectFirstUnread(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fSelectFirstUnread;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_SelectFirstUnread(BOOL newVal)
{
    if (FireOnRequestEdit(DISPID_LISTPROP_SELECT_FIRST_UNREAD) == S_FALSE)
        return S_FALSE;

    // Save the value.  We don't change any selection however.
    m_fSelectFirstUnread = newVal;

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_SELECT_FIRST_UNREAD);

    return S_OK;
}


HRESULT CMessageList::get_MessageTips(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fViewTip;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_MessageTips(BOOL newVal)
{
    if (FireOnRequestEdit(DISPID_LISTPROP_MESSAGE_TIPS) == S_FALSE)
        return S_FALSE;

    m_fViewTip = newVal;

    FireOnChanged(DISPID_LISTPROP_MESSAGE_TIPS);
    return (S_OK);
}


HRESULT CMessageList::get_ScrollTips(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fScrollTip;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ScrollTips(BOOL newVal)
{
    if (FireOnRequestEdit(DISPID_LISTPROP_SCROLL_TIPS) == S_FALSE)
        return S_FALSE;

    m_fScrollTip = newVal;

    FireOnChanged(DISPID_LISTPROP_SCROLL_TIPS);
    return (S_OK);
}


HRESULT CMessageList::get_Count(long *pVal)
{
    if (pVal)
    {
        if (m_pTable)
            m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *) pVal);
        else 
            *pVal = 0;

        return S_OK;
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::get_UnreadCount(long *pVal)
{
    if (pVal)
    {
        if (m_pTable)
            m_pTable->GetCount(MESSAGE_COUNT_UNREAD, (ULONG *) pVal);
        else 
            *pVal = 0;

        return S_OK;
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::get_SelectedCount(long *pVal)
{
    if (pVal)
    {
        if (IsWindow(m_ctlList))
            *pVal = ListView_GetSelectedCount(m_ctlList);
        else 
            *pVal = 0;

        return S_OK;
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::get_PreviewMessage(BSTR *pbstr)
{
    IMimeMessage    *pMsg;
    IStream         *pstm;
 
    *pbstr = NULL;
    
    // hack for HOTMAIL demo
    if (SUCCEEDED(_GetSelectedCachedMessage(TRUE, &pMsg)))
    {
        if (pMsg->GetMessageSource(&pstm, 0)==S_OK)
        {
            WriteStreamToFile(pstm, "c:\\oe_prev$.eml", CREATE_ALWAYS, GENERIC_WRITE);
            pstm->Release();
        }
        *pbstr = SysAllocString(L"c:\\oe_prev$.eml");
        pMsg->Release();
    }
    
    return (S_OK);
}

HRESULT CMessageList::get_FilterMessages(ULONGLONG *pVal)
{
    if (pVal)
    {
        *pVal = (ULONGLONG) m_ridFilter;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_FilterMessages(ULONGLONG newVal)
{
    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_FILTER_MESSAGES) == S_FALSE)
        return S_FALSE;

    // Reload the table.
    _FilterView((RULEID) newVal);

    // Tell people about it    
    FireOnChanged(DISPID_LISTPROP_FILTER_MESSAGES);

    // Send the update notification
    Fire_OnFilterChanged(m_ridFilter);
    
    return S_OK;
}

HRESULT CMessageList::get_ShowDeleted(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fShowDeleted;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ShowDeleted(BOOL newVal)
{
    // Update the ListView
    COLUMN_ID       idSort;
    BOOL            fAscending;
    FOLDERSORTINFO  SortInfo;

    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_SHOW_DELETED) == S_FALSE)
        return S_FALSE;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Save the new setting
    m_fShowDeleted = newVal;
   
    // Get the Sort Info
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Set the Sort Info
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reload the table.
    _ResetView(idSel);

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_SHOW_DELETED);

    return S_OK;
}

HRESULT CMessageList::get_ShowReplies(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fShowReplies;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ShowReplies(BOOL newVal)
{
    // Update the ListView
    COLUMN_ID       idSort;
    BOOL            fAscending;
    FOLDERSORTINFO  SortInfo;

    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_SHOW_REPLIES) == S_FALSE)
        return S_FALSE;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Save the new setting
    m_fShowReplies = newVal;
   
    // Get the Sort Info
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Gots to be threaded
    if (m_fShowReplies)
        m_fThreadMessages = TRUE;

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Set the Sort Info
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reload the table.
    _ResetView(idSel);

    if (m_fThreadMessages)
        ListView_SetImageList(m_ctlList, GetImageList(GIML_STATE), LVSIL_STATE);
    else
        ListView_SetImageList(m_ctlList, NULL, LVSIL_STATE);

    // The counts Change Here...
    Fire_OnMessageCountChanged(m_pTable);

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_SHOW_REPLIES);

    return S_OK;
}


HRESULT CMessageList::PromptToGoOnline()
{
    HRESULT     hr;

    if (g_pConMan->IsGlobalOffline())
    {
        if (IDYES == AthMessageBoxW(m_hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))    
        {
            g_pConMan->SetGlobalOffline(FALSE);
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT CMessageList::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, 
                                         CConnectionManager *pConMan)
{
    m_dwConnectState = 0L;
    if ((nCode == CONNNOTIFY_WORKOFFLINE && pvData) || 
        (nCode == CONNNOTIFY_DISCONNECTING) || 
        (nCode == CONNNOTIFY_DISCONNECTED))
    {
        m_dwConnectState = NOT_CONNECTED;
    }
    else
    if (nCode == CONNNOTIFY_CONNECTED)
    {
        m_dwConnectState = CONNECTED;
    }
    else
    if (nCode == CONNNOTIFY_WORKOFFLINE && !pvData)
    {  
        UpdateConnInfo();
    }

    return S_OK;
}

void CMessageList::UpdateConnInfo()
{
    FOLDERINFO      rFolderInfo = {0};
    TCHAR           AccountId[CCHMAX_ACCOUNT_NAME];

    if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rFolderInfo)))
    {
        if (SUCCEEDED(GetFolderAccountId(&rFolderInfo, AccountId, ARRAYSIZE(AccountId))))
        {
            if (g_pConMan)
            {
                if (g_pConMan->CanConnect(AccountId) == S_OK)
                {
                    m_dwConnectState = CONNECTED;
                }
                else
                {
                    m_dwConnectState = NOT_CONNECTED;
                }
            }
        }
        g_pStore->FreeRecord(&rFolderInfo);
    }
}


void CMessageList::_DoColumnCheck(COLUMN_ID id)
{
    // Check to see if the user has the column visible
    BOOL fVisible = FALSE;

    m_cColumns.IsColumnVisible(id, &fVisible);
    if (!fVisible)
    {
        if (IDYES == DoDontShowMeAgainDlg(m_ctlList, c_szRegColumnHidden, (LPTSTR) idsAthena,
                                  (LPTSTR) idsColumnHiddenWarning, MB_YESNO))
        {
            m_cColumns.InsertColumn(id, 0);
        }
    }
}

void CMessageList::_DoFilterCheck(RULEID ridFilter)
{
    // Make sure the filter got set correctly
    if (m_ridFilter != ridFilter)
    {
        m_ridFilter = ridFilter; 
    }
    
    // Reset the empty string
    if (RULEID_VIEW_ALL == m_ridFilter)
    {
        if (FALSE != m_fFindFolder)
        {
            m_idsEmptyString = idsMonitoring;
        }
        else if ((FALSE != m_fJunkFolder) && (0 != (g_dwAthenaMode & MODE_JUNKMAIL)) && (FALSE == DwGetOption(OPT_FILTERJUNK)))
        {
            m_idsEmptyString = idsEmptyJunkMail;
        }
        else
        {
            m_idsEmptyString = idsEmptyView;
        }
    }
    else
    {
        m_idsEmptyString = idsEmptyFilteredView;
    }
}


BOOL CMessageList::_IsSelectionDeletable(void)
{
    BOOL      fReturn = FALSE;
    DWORD     cRows;
    ROWINDEX *rgiRow = 0;

    // Make sure we have a table
    if (!m_pTable)
        return (FALSE);

    // First we need to come up with an array for the row indicies
    cRows = ListView_GetSelectedCount(m_ctlList);
    if (!cRows)
        return (FALSE);

    // Allocate the array
    if (MemAlloc((LPVOID *) &rgiRow, sizeof(ROWINDEX) * cRows))
    {
        // Loop through all the selected rows
        int       iRow = -1;
        ROWINDEX *pRow = rgiRow;

        while (-1 != (iRow = ListView_GetNextItem(m_ctlList, iRow, LVNI_SELECTED)))
        {
            *pRow = iRow;
            pRow++;
        }

        DWORD dwState = 0;

        if (SUCCEEDED(m_pTable->GetSelectionState(cRows, rgiRow, SELECTION_STATE_DELETABLE,
                                                  m_fThreadMessages, &dwState)))
        {
            // the return value here seems backward.  
            fReturn = !(dwState & SELECTION_STATE_DELETABLE) || (GetFolderType(m_idFolder) == FOLDER_NEWS);
        }

        MemFree(rgiRow);
    }

    return (fReturn);
}


BOOL CMessageList::_PollThisAccount(FOLDERID id)
{
    HRESULT      hr;
    FOLDERINFO   fi;
    TCHAR        szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAccount = 0;
    BOOL         fReturn = FALSE;
    DWORD        dw;

    // Get the server for this folder
    if (SUCCEEDED(hr = GetFolderServer(id, &fi)))
    {
        // Get the account ID for the server
        if (SUCCEEDED(hr = GetFolderAccountId(&fi, szAccountId, ARRAYSIZE(szAccountId))))
        {
            // Get the account interface
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount)))
            {
                if (SUCCEEDED(hr = pAccount->GetPropDw(AP_NNTP_POLL, &dw)))
                {
                    fReturn = (0 != dw);
                }

                pAccount->Release();
            }
        }
        g_pStore->FreeRecord(&fi);
    }

    return (fReturn);
}

HRESULT CMessageList::GetAdBarUrl()
{
    HRESULT     hr = S_OK;

    if (m_pTable)
    {
        IF_FAILEXIT(hr = m_pTable->GetAdBarUrl(this));
    }

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CListSelector
//

CListSelector::CListSelector()
{
    m_cRef = 1;
    m_hwndAdvise = 0;
}

CListSelector::~CListSelector()
{
}


//
//  FUNCTION:   CListSelector::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CListSelector::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CListSelector::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) this;
    else if (IsEqualIID(riid, IID_IListSelector))
        *ppvObj = (LPVOID) (IListSelector *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CListSelector::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CListSelector::AddRef(void)
{
    TraceCall("CListSelector::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CListSelector::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CListSelector::Release(void)
{
    TraceCall("CListSelector::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


HRESULT CListSelector::SetActiveRow(ROWINDEX iRow)
{
    if (m_hwndAdvise && IsWindow(m_hwndAdvise))
    {
        PostMessage(m_hwndAdvise, WM_SELECTROW, 0, iRow);
    }

    return (S_OK);
}


HRESULT CListSelector::Advise(HWND hwndAdvise)
{
    if (0 == m_hwndAdvise && IsWindow(hwndAdvise))
    {
        m_hwndAdvise = hwndAdvise;
        return (S_OK);
    }

    return (E_UNEXPECTED);
}


HRESULT CListSelector::Unadvise(void)
{
    m_hwndAdvise = 0;
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\mapitest.c ===
#include "pch.h"
#include "resource.h"

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow);
BOOL CALLBACK SendMailDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
void LoadFunctions(HWND hwnd);
void UnloadFunctions();
void SendMail(HWND hwnd);
void SendDocuments(HWND hwnd);
void Address(HWND hwnd) ;
void ResolveName(HWND hwnd) ;
void Details(HWND hwnd);
void FindNext(HWND hwnd);
void ReadMail(HWND hwnd);
void SaveMail(HWND hwnd);
void DeleteMail(HWND hwnd);



HINSTANCE                       g_hInstMAPI = NULL;
LPMAPILOGON                     g_pfnMAPILogon = NULL;
LPMAPILOGOFF            g_pfnMAPILogoff = NULL;
LPMAPISENDMAIL          g_pfnMAPISendMail = NULL;
LPMAPISENDDOCUMENTS g_pfnMAPISendDocuments = NULL ;
LPMAPIADDRESS           g_pfnMAPIAddress = NULL ;
LPMAPIRESOLVENAME       g_pfnMAPIResolveName = NULL ;
LPMAPIDETAILS           g_pfnMAPIDetails = NULL ;
LPMAPIFREEBUFFER        g_pfnMAPIFreeBuffer = NULL ;
LPMAPIFINDNEXT      g_pfnMAPIFindNext=NULL;
LPMAPIREADMAIL      g_pfnMAPIReadMail=NULL;
LPMAPISAVEMAIL      g_pfnMAPISaveMail=NULL;
LPMAPIDELETEMAIL    g_pfnMAPIDeleteMail=NULL;



// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine;

    pszCmdLine = GetCommandLine();
	


    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
	/*
	 * Scan, and skip over, subsequent characters until
	 * another double-quote or a null is encountered.
	 */
	while ( *++pszCmdLine && (*pszCmdLine
	     != TEXT('\"')) );
	/*
	 * If we stopped on a double-quote (usual case), skip
	 * over it.
	 */
	if ( *pszCmdLine == TEXT('\"') )
	    pszCmdLine++;
    }
    else {
	while (*pszCmdLine > TEXT(' '))
	    pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
	pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
		   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    ExitProcess(i);

    return i;
}

int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow)
{
    return DialogBox(hInst, MAKEINTRESOURCE(IDD_SENDMAIL), NULL, SendMailDlgProc);
}


BOOL CALLBACK SendMailDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    HWND hCombo ;
    switch (msg)
	{
	case WM_INITDIALOG:
	    hCombo = GetDlgItem(hwnd,IDC_DLLCOMBO);

	    //SetDlgItemText(hwnd, IDC_DLLCOMBO, "c:\\winnt\\system32\\mapi32.dll");

	    SendMessage(hCombo,CB_ADDSTRING,(WPARAM)0,(LPARAM)(LPCTSTR)"c:\\winnt\\system32\\mapi32.dll") ;
	    SendMessage(hCombo,CB_ADDSTRING,(WPARAM)0,(LPARAM)(LPCTSTR)"c:\\nt\\drop\\debug\\msoe.dll") ;

	    SetDlgItemText(hwnd, IDC_DLLPATH, "c:\\winnt\\system32\\mapi32.dll");
	    CheckRadioButton(hwnd, IDC_RECIP_NONE, IDC_RECIP_AMBIG, IDC_RECIP_NONE); 
	    CheckRadioButton(hwnd, IDC_EXITPROC, IDC_WAITRETURN, IDC_WAITRETURN);
	    return TRUE;

	case WM_DESTROY:
	    UnloadFunctions();
	    break;

	case WM_CLOSE:
	    EndDialog(hwnd, IDOK);
	    return TRUE;

	case WM_COMMAND:
	    switch (GET_WM_COMMAND_ID(wp, lp))
		{
		case IDOK:
		    EndDialog(hwnd, IDOK);
		    break;
		case IDC_LOADDLL:
		    LoadFunctions(hwnd);
		    break;
		case IDC_SEND:
		    SendMail(hwnd);
		    break;
				case IDC_SENDDOC:
					SendDocuments(hwnd) ;
					break;
				case IDC_MAPIADDRESS:
					Address(hwnd) ;
					break;
				case IDC_MAPIRESOLVENAME:
					ResolveName(hwnd);
					break;
				case IDC_MAPIDETAILS:
					Details(hwnd) ;
					break;
		case IDC_FINDNEXT:
		    FindNext(hwnd);
		    break;
		case IDC_READMAIL:
		    ReadMail(hwnd);
		    break;
		case IDC_SAVEMAIL:
		    SaveMail(hwnd);
		    break;
		case IDC_DELETEMAIL:
		    DeleteMail(hwnd);
		    break;
		}
	    return TRUE;

	case WM_TIMER:
	    if (wp == 1)
		OutputDebugString("MAPITEST: WM_TIMER\r\n");
	    else if (wp == 2)
		ExitProcess(0);
	    return TRUE;
	}
    return FALSE;
}

void LoadFunctions(HWND hwnd)
{
    TCHAR szDLL[MAX_PATH];
	DWORD dwError =0;

    UnloadFunctions();
    
    GetDlgItemText(hwnd, IDC_DLLPATH, szDLL, ARRAYSIZE(szDLL));
    g_hInstMAPI = LoadLibrary(szDLL);
	dwError = GetLastError() ;
    if (!g_hInstMAPI)
	{
	MessageBox(hwnd, "LoadLibrary() failed.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
	return;
	}

    g_pfnMAPILogon = (LPMAPILOGON)GetProcAddress(g_hInstMAPI, "MAPILogon");
    g_pfnMAPILogoff = (LPMAPILOGOFF)GetProcAddress(g_hInstMAPI, "MAPILogoff");
    g_pfnMAPISendMail = (LPMAPISENDMAIL)GetProcAddress(g_hInstMAPI, "MAPISendMail");
    g_pfnMAPISendDocuments = (LPMAPISENDDOCUMENTS)GetProcAddress(g_hInstMAPI, "MAPISendDocuments");
	g_pfnMAPIAddress = (LPMAPIADDRESS)GetProcAddress(g_hInstMAPI,"MAPIAddress") ;
	g_pfnMAPIResolveName = (LPMAPIRESOLVENAME) GetProcAddress(g_hInstMAPI,"MAPIResolveName") ;
    g_pfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(g_hInstMAPI,"MAPIFreeBuffer") ;
	g_pfnMAPIDetails = (LPMAPIDETAILS)GetProcAddress(g_hInstMAPI,"MAPIDetails") ;
    g_pfnMAPIFindNext= (LPMAPIFINDNEXT)GetProcAddress(g_hInstMAPI,"MAPIFindNext");
    g_pfnMAPIReadMail= (LPMAPIREADMAIL)GetProcAddress(g_hInstMAPI,"MAPIReadMail");
    g_pfnMAPISaveMail= (LPMAPISAVEMAIL)GetProcAddress(g_hInstMAPI,"MAPISaveMail");
    g_pfnMAPIDeleteMail=(LPMAPIDELETEMAIL)GetProcAddress(g_hInstMAPI,"MAPIDeleteMail");

    if (!(g_pfnMAPILogon && g_pfnMAPILogoff && g_pfnMAPISendMail && g_pfnMAPISendDocuments && g_pfnMAPIAddress && g_pfnMAPIResolveName && g_pfnMAPIFreeBuffer && g_pfnMAPIDetails && g_pfnMAPIFindNext && g_pfnMAPIReadMail && g_pfnMAPISaveMail && g_pfnMAPIDeleteMail))
	MessageBox(hwnd, "GetProcAddress() failed.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
}

void UnloadFunctions()
{
    if (g_hInstMAPI)
	{
	FreeLibrary(g_hInstMAPI);
	g_hInstMAPI = NULL;
	g_pfnMAPILogon = NULL;   
	g_pfnMAPILogoff = NULL;  
	g_pfnMAPISendMail = NULL;
	}

}

void SendMail(HWND hwnd)
{
    ULONG           ulRet;
    FLAGS           fl = 0;
    MapiMessage     mm;
    MapiRecipDesc   mr,mo;
    LHANDLE         lhSession = 0;
    TCHAR           szBuf[MAX_PATH];
    MapiRecipDesc   recips[1];  

    // Just for testing lpEntryID - Begin
    char                    rgchSeedMsgID[513];
    char                    rgchMsgID[513];
    lpMapiMessage           rgMessage;

    // Just for testing lpEntryID - End

    if (!g_pfnMAPISendMail)
	{
	MessageBox(hwnd, "Need to load MAPI first.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
	return;
	}

    // Just for testing lpEntryID in MAPISendMail - Begin

     ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    
 
   
    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}  
    
    //   Just for testing lpEntryID in MAPISEndMail - End



    mm.ulReserved           = 0;
    mm.lpszSubject          = "Ha Ha Ha. Subject";
    mm.lpszNoteText         = "Ha Ha Ha. I got it Body\r\nLine 2";
    mm.lpszMessageType      = NULL;
    mm.lpszDateReceived     = NULL;
    mm.lpszConversationID   = NULL;
    mm.flFlags              = 0;
    mm.lpOriginator         = NULL;
    mm.nFileCount           = 0;
    mm.lpFiles              = NULL;
    mm.nRecipCount          = 1;



    if (IsDlgButtonChecked(hwnd, IDC_RECIP_NONE))
	{
	mm.nRecipCount = 0;
	mm.lpRecips = NULL;
	}
    else
	{
	mr.ulReserved = 0;
	mr.ulRecipClass = MAPI_TO;
	mr.ulEIDSize = 0;
	mr.lpEntryID = 0;
	if (IsDlgButtonChecked(hwnd, IDC_RECIP_RESOLVED))
	    {
	    mr.lpszName = "Senthil Kumar Natarajan";
	    mr.lpszAddress = "v-snatar@microsoft.com";
	    }
	else
	    {
	    mr.lpszName = "Senthil";
	    mr.lpszAddress = NULL;
	    }
	mm.nRecipCount = 1;
	mm.lpRecips = &mr;    
	}

   	mo.ulReserved = 0;
	mo.ulRecipClass = MAPI_ORIG	;
	mo.ulEIDSize = 0;
	mo.lpEntryID = 0;
    mo.lpszName = "Senthil Kumar Natarajan";
    mo.lpszAddress = "v-snatar@microsoft.com";


    if (IsDlgButtonChecked(hwnd, IDC_MAPI_DIALOG))
	fl |= MAPI_DIALOG;
    if (IsDlgButtonChecked(hwnd, IDC_MAPI_LOGON_UI))
	fl |= MAPI_LOGON_UI;
    if (IsDlgButtonChecked(hwnd, IDC_MAPI_NEW_SESSION))
	fl |= MAPI_NEW_SESSION;

    SetTimer(hwnd, 1, 500, NULL);
    if (IsDlgButtonChecked(hwnd, IDC_EXITPROC))
	SetTimer(hwnd, 2, 3000, NULL);

    mr.ulReserved = 0;
	mr.ulRecipClass = MAPI_TO;
	mr.ulEIDSize = rgMessage->lpRecips[0].ulEIDSize ;//0;
	mr.lpEntryID = rgMessage->lpRecips[0].lpEntryID ;//0;
    mr.lpszName = NULL;//"Senthil Kumar Natarajan";
	mr.lpszAddress = NULL;//"v-snatar@microsoft.com";

    mm.lpRecips = &mr; 
    mm.nRecipCount = 1;

    ulRet = (*g_pfnMAPISendMail)(lhSession, (ULONG)hwnd, &mm, fl, 0);

    KillTimer(hwnd, 1);
    KillTimer(hwnd, 2);

    wsprintf(szBuf, "MAPISendMail() returned %lu.", ulRet);
    MessageBox(hwnd, szBuf, "MAPITest", MB_OK);

    // Just to test lpEntryID - Begin

    ulRet = (*g_pfnMAPIFreeBuffer)(rgMessage);
    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFreeBuffer  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    // Just to test lpentryID - End
}

void SendDocuments(HWND hwnd)
{
    ULONG           ulRet;
    FLAGS           fl = 0;
    MapiMessage     mm;
    MapiRecipDesc   mr;
    LHANDLE         lhSession = 0;
    TCHAR           szBuf[MAX_PATH];

    if (!g_pfnMAPISendDocuments)
	{
	MessageBox(hwnd, "Need to load MAPI first.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
	return;
	}

    //ulRet = (*g_pfnMAPISendDocuments)((ULONG)hwnd,";","c:\\nt\\drop\\debug\\wab.exe","Junk Fellows",0);

    ulRet = (*g_pfnMAPISendDocuments)((ULONG)hwnd,";","c:\\nt\\drop\\debug\\wab.exe;c:\\nt\\drop\\debug\\wab.exe;c:\\dos\\append.exe;c:\\Program files\\common files\\mscreate.dir",NULL,0);

    wsprintf(szBuf, "MAPISendDocuments() returned %lu.", ulRet);
    MessageBox(hwnd, szBuf, "MAPITest", MB_OK);
}

void Address(HWND hwnd)
{
	ULONG err,ulret;
	MapiRecipDesc recips[4],temprecips[4],     // this message needs two recipients.
				 *tempRecip[3] ;//,*finalRecip[3];  // for use by MAPIResolveName and MAPIAddress
	 
	lpMapiRecipDesc finalRecip;
	//MapiRecipDesc *finalRecip ;

    TCHAR           szBuf[MAX_PATH];
	MapiMessage             note ;
	FLAGS                   fl=0 ;
	ULONG                   ulOut ;
	

	// create the same file attachment as in the previous example.
	MapiFileDesc attachment = {0,         // ulReserved, must be 0
							   0,         // no flags; this is a data file
							   (ULONG)-1, // position not specified
							   "c:\\dos\\append.exe",  // pathname
							   "append",      // original filename
							   NULL};               // MapiFileTagExt unused
	

    /*
    
	// get Senthil Kumar Natarajan as the MAPI_TO recipient:
	err = (*g_pfnMAPIResolveName)(0L,            // implicit session
								  0L,            // no UI handle
								  "Senthil Kumar Natarajan", // friendly name
								  0L,            // no flags, no UI allowed
								  0L,            // reserved; must be 0
								  &tempRecip[0]);// where to put the result
	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[0].ulReserved   = tempRecip[0]->ulReserved;
		recips[0].ulRecipClass = MAPI_TO;
		recips[0].lpszName     = tempRecip[0]->lpszName;
		recips[0].lpszAddress  = tempRecip[0]->lpszAddress;
		recips[0].ulEIDSize    = tempRecip[0]->ulEIDSize;
		recips[0].lpEntryID    = tempRecip[0]->lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Senthil Kumar Natarajan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

	


	// get the Marketing alias as the MAPI_CC recipient:
	err = (*g_pfnMAPIResolveName)(0L,                                       // implicit session
								 0L,                                    // no UI handle
								 "Shyam Sundar Rajagopalan",   // friendly name
								 0L,                                    // no flags, no UI allowed
								 0L,                                    // reserved; must be 0
								 &tempRecip[1]);                // where to put the result

	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[1].ulReserved   = tempRecip[1]->ulReserved;
		recips[1].ulRecipClass = MAPI_CC;
		recips[1].lpszName     = tempRecip[1]->lpszName;
		recips[1].lpszAddress  = tempRecip[1]->lpszAddress;
		recips[1].ulEIDSize    = tempRecip[1]->ulEIDSize;
		recips[1].lpEntryID    = tempRecip[1]->lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Shyam Sundar Rajagopalan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

		// get Senthil Kumar Natarajan as the MAPI_TO recipient:
	err = (*g_pfnMAPIResolveName)(0L,            // implicit session
								  0L,            // no UI handle
								  "Venkatesh Sundaresan", // friendly name
								  0L,            // no flags, no UI allowed
								  0L,            // reserved; must be 0
								  &tempRecip[2]);// where to put the result
	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[2].ulReserved   = tempRecip[2]->ulReserved;
		recips[2].ulRecipClass = MAPI_BCC;
		recips[2].lpszName     = tempRecip[2]->lpszName;
		recips[2].lpszAddress  = tempRecip[2]->lpszAddress;
		recips[2].ulEIDSize    = tempRecip[2]->ulEIDSize;
		recips[2].lpEntryID    = tempRecip[2]->lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Venkatesh Sundaresan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
	
    
	  
	if (IsDlgButtonChecked(hwnd, IDC_MAPI_LOGON_UI))
		fl |= MAPI_LOGON_UI;
    if (IsDlgButtonChecked(hwnd, IDC_MAPI_NEW_SESSION))
	fl |= MAPI_NEW_SESSION;
	*/
    
    recips[0].lpszName = "Sone Sone" ;    
    recips[0].lpszAddress ="sone@sone.com";
    recips[0].ulRecipClass=MAPI_BCC;
    recips[0].ulEIDSize=0;

    recips[1].lpszName = "Zebra" ;    
    recips[1].lpszAddress ="zebra@zebra.com";
    recips[1].ulRecipClass=MAPI_TO;
    recips[1].ulEIDSize=0;

    recips[2].lpszName = "Sone Sone" ;    
    recips[2].lpszAddress ="sone@sone.com";
    recips[2].ulRecipClass=MAPI_CC;
    recips[2].ulEIDSize=0;


    recips[3].lpszName = "yahoooo" ;
    recips[3].lpszAddress ="yahoo@everywhere.com";
    recips[3].ulRecipClass=MAPI_TO;
    recips[3].ulEIDSize=0;
   

    
	//ulret = (*g_pfnMAPIAddress)(0L,(ULONG)hwnd,"My Address Book",2,"",3,recips,fl,0,&ulOut,&finalRecip);
	ulret = (*g_pfnMAPIAddress)(0L,(ULONG)hwnd,"My Address Book",3,"Hello",4,recips,fl,0,&ulOut,&finalRecip);

	if (ulret != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIAddress Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

	if (0)
	{       
		note.ulReserved=0;
		note.lpszSubject= "Budget Proposal";
		note.lpszNoteText="Here is my budget proposal.\r\n";
		note.lpszMessageType= NULL ;
		note.lpszDateReceived= NULL;
		note.lpszConversationID= NULL;
		note.flFlags=0;
		note.lpOriginator= NULL;
		note.nRecipCount=2;
		note.lpRecips=recips;
		note.nFileCount=1;
		note.lpFiles=&attachment;

		if (IsDlgButtonChecked(hwnd, IDC_MAPI_DIALOG))
			fl |= MAPI_DIALOG;
		if (IsDlgButtonChecked(hwnd, IDC_MAPI_LOGON_UI))
			fl |= MAPI_LOGON_UI;
		if (IsDlgButtonChecked(hwnd, IDC_MAPI_NEW_SESSION))
			fl |= MAPI_NEW_SESSION;

		err = (*g_pfnMAPISendMail) (0L,    // use implicit session.
									0L,    // ulUIParam; 0 is always valid
									&note,  //&note, // the message being sent
									fl,    // do not allow the user to edit the message
									0L);   // reserved; must be 0
		if (err != SUCCESS_SUCCESS )
		{
			wsprintf(szBuf, "SendMail Failed");
			MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
		}
	}

    err = (*g_pfnMAPIFreeBuffer)((LPVOID)&(*finalRecip)); 

    if (err != SUCCESS_SUCCESS)
    { 
	wsprintf(szBuf,"MAPIFreeBuffer failed");
	MessageBox(hwnd,szBuf,"MAPITest",MB_OK);
    }
  }
    


void ResolveName(HWND hwnd)
{
	ULONG err,ulret;
	MapiRecipDesc recips[3];//,temprecips[1],     // this message needs two recipients.
	 
	lpMapiRecipDesc finalRecip;

    TCHAR           szBuf[MAX_PATH];
	MapiMessage             note ;
	FLAGS                   fl=0 ;
	ULONG                   ulOut ;

	// create the same file attachment as in the previous example.
	MapiFileDesc attachment = {0,         // ulReserved, must be 0
							   0,         // no flags; this is a data file
							   (ULONG)-1, // position not specified
							   "c:\\dos\\append.exe",  // pathname
							   "append",      // original filename
							   NULL};               // MapiFileTagExt unused
	

	if (IsDlgButtonChecked(hwnd, IDC_MAPI_DIALOG))
		fl |= MAPI_DIALOG;
	
	// get Senthil Kumar Natarajan as the MAPI_TO recipient:
	err = (*g_pfnMAPIResolveName)(0L,            // implicit session
								  (ULONG)hwnd,
								  "Senthil Kumar Natarajan", // friendly name
								  fl,
								  0L,            // reserved; must be 0
								  &finalRecip);// where to put the result
	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[0].ulReserved   = (*finalRecip).ulReserved;
		recips[0].ulRecipClass = MAPI_TO;
		recips[0].lpszName     = (*finalRecip).lpszName;
		recips[0].lpszAddress  = (*finalRecip).lpszAddress;
		recips[0].ulEIDSize    = (*finalRecip).ulEIDSize;
		recips[0].lpEntryID    = (*finalRecip).lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Senthil Kumar Natarajan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    err = (*g_pfnMAPIFreeBuffer)((LPVOID)&(*finalRecip)); 

    if (err != SUCCESS_SUCCESS)
    { 
	wsprintf(szBuf,"MAPIFreeBuffer failed");
	MessageBox(hwnd,szBuf,"MAPITest",MB_OK);
    }
}

void Details(HWND hwnd)
{
	ULONG err,ulret;
	MapiRecipDesc recips[3];         
	lpMapiRecipDesc finalRecip;

    TCHAR           szBuf[MAX_PATH];
	MapiMessage             note ;
	FLAGS                   fl=0 ;
	ULONG                   ulOut ;
    
    ulret = (*g_pfnMAPIAddress)(0L,(ULONG)hwnd,"My Address Book",2,"",0,NULL,fl,0,&ulOut,&finalRecip);
    
    if (ulret != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    


    if (IsDlgButtonChecked(hwnd, IDC_MAPI_AB_NOMODIFY))
	    fl |= MAPI_AB_NOMODIFY;

    recips[0].lpszName = "Sone Sone" ;    
    recips[0].lpszAddress ="SMTP:sone@sone.com";
    recips[0].ulRecipClass=MAPI_BCC;
    recips[0].ulEIDSize=0;

	ulret = (*g_pfnMAPIDetails)(0L,(ULONG)hwnd,&finalRecip[0],fl,0);

	if (ulret != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    err = (*g_pfnMAPIFreeBuffer)((LPVOID)&(*finalRecip)); 

    if (err != SUCCESS_SUCCESS)
    { 
	wsprintf(szBuf,"MAPIFreeBuffer failed");
	MessageBox(hwnd,szBuf,"MAPITest",MB_OK);
    }
}

void FindNext(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513]="10";
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    int                     i;
    LPSTR                   pszTemp=NULL;

    
   
    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchSeedMsgID);


    for (i=1;i<=10;i++)
    {  
        ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,rgchSeedMsgID,MAPI_LONG_MSGID,0,rgchMsgID);
        lstrcpy(rgchSeedMsgID,rgchMsgID);
    }


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    

   


}

void ReadMail(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513]="1";
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    lpMapiMessage           rgMessage;


    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    
   
    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    /*
    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    */
    



    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}


    MessageBox(NULL,rgMessage->lpszNoteText,"Text",MB_OK);

    ulRet = (*g_pfnMAPIFreeBuffer)(rgMessage);
    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFreeBuffer  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

}

void SaveMail(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513];
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    MapiMessage             rgMessage;//=new MapiMessage;
    MapiMessage             mm;
    MapiRecipDesc           mr;


    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    
    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    

    mm.ulReserved           = 0;
    mm.lpszSubject          = "MAPISendMail Subject";
    mm.lpszNoteText         = "MAPISendMail Body\r\nLine 2";
    mm.lpszMessageType      = NULL;
    mm.lpszDateReceived     = NULL;
    mm.lpszConversationID   = NULL;
    mm.flFlags              = 0;
    mm.lpOriginator         = NULL;
    mm.nFileCount           = 0;
    mm.lpFiles              = NULL;
    mm.nRecipCount          = 1;

    mr.ulReserved = 0;
	mr.ulRecipClass = MAPI_TO;
	mr.ulEIDSize = 0;
	mr.lpEntryID = 0;
    mr.lpszName = "Senthil Kumar Natarajan";
	mr.lpszAddress = "v-snatar@microsoft.com";

    mm.nRecipCount = 1;
	mm.lpRecips = &mr;      


    //rgchMsgID[0]='0';

    ulRet = (*g_pfnMAPISaveMail)(lhSession,(ULONG)hwnd,&mm,0,0,rgchMsgID);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
}

void DeleteMail(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513];
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    lpMapiMessage           rgMessage;


    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    
     ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    MessageBox(NULL,rgMessage->lpszNoteText,"Text",MB_OK);


    ulRet = (*g_pfnMAPIDeleteMail)(lhSession,(ULONG)hwnd,rgchMsgID,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDelete  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}



    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\pch.h ===
#include <windows.h>
#include <windowsx.h>
#include <mapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\view\msgview.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     msgview.cpp
//
//  PURPOSE:    Implements the Outlook Express view class that handles 
//              displaying the contents of folders with messages.
//

#include "pch.hxx"
#include "msgview.h"
#include "browser.h"
#include "thormsgs.h"
#include "msglist.h"
#include "msoedisp.h"
#include "statbar.h"
#include "ibodyobj.h"
#include "mehost.h"
#include "util.h"
#include "shlwapip.h" 
#include "menuutil.h"
#include "storutil.h"
#include "ruleutil.h"
#include "note.h"
#include "newsutil.h"
#include "menures.h"
#include "ipab.h"
#include "order.h"
#include <inetcfg.h>
#include "instance.h"

/////////////////////////////////////////////////////////////////////////////
// Global Data
//

static const char s_szMessageViewWndClass[] = TEXT("Outlook Express Message View");

extern BOOL g_fBadShutdown;

/////////////////////////////////////////////////////////////////////////////
// Prototypes
//


/////////////////////////////////////////////////////////////////////////////
// Message Macros
//

// void OnPostCreate(HWND hwnd)
#define HANDLE_WM_POSTCREATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_POSTCREATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_POSTCREATE, 0L, 0L)

// LRESULT OnTestGetMsgId(HWND hwnd)
#define HANDLE_WM_TEST_GETMSGID(hwnd, wParam, lParam, fn) \
    (LRESULT)((fn)(hwnd))
#define FORWARD_WM_TEST_GETMSGID(hwnd, fn) \
    (LRESULT)(fn)((hwnd), WM_TEST_GETMSGID, 0L, 0L)

// LRESULT OnTestSaveMessage(HWND hwnd)
#define HANDLE_WM_TEST_SAVEMSG(hwnd, wParam, lParam, fn) \
    (LRESULT)((fn)(hwnd))
#define FORWARD_WM_TEST_SAVEMSG(hwnd, fn) \
    (LRESULT)(fn)((hwnd), WM_TEST_SAVEMSG, 0L, 0L)

/////////////////////////////////////////////////////////////////////////////
// Constructors, Destructors, and Initialization
//

CMessageView::CMessageView()
{
    m_cRef = 1;

    m_hwnd = NULL;
    m_hwndParent = NULL;

    m_pBrowser = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_pDropTarget = NULL;

    m_pMsgList = NULL;
    m_pMsgListCT = NULL;
    m_pMsgListAO = NULL;
    m_dwCookie = 0;
    m_pServer = NULL;

    m_pPreview = NULL;
    m_pPreviewCT = NULL;

    m_fSplitHorz = TRUE;
    SetRect(&m_rcSplit, 0, 0, 0, 0);
    m_dwSplitVertPct = 50;
    m_dwSplitHorzPct = 50;
    m_fDragging = FALSE;

    m_uUIState = SVUIA_DEACTIVATE;
    m_cUnread = 0;
    m_cItems = 0;
    m_pGroups = NULL;
    m_idMessageFocus = MESSAGEID_INVALID;
    m_pProgress = NULL;
    m_fNotDownloaded = FALSE;
    m_cLastChar = GetTickCount();

    m_pViewMenu = NULL;
}


CMessageView::~CMessageView()
{
    SafeRelease(m_pViewMenu);
    if (m_pGroups != NULL)
    {
        m_pGroups->Close();
        m_pGroups->Release();
    }
    SafeRelease(m_pBrowser);
    SafeRelease(m_pMsgList);
    SafeRelease(m_pMsgListCT);
    SafeRelease(m_pMsgListAO);
    SafeRelease(m_pPreview);
    SafeRelease(m_pPreviewCT);
    SafeRelease(m_pProgress);
    SafeRelease(m_pDropTarget);
    Assert(NULL == m_pServer);
}


//
//  FUNCTION:   CMessageView::Initialize()
//
//  PURPOSE:    Get's called to initialize the object and tell it what folder
//              it will be looking at.
//
//  PARAMETERS: 
//      [in]  pidl
//      [in] *pFolder
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::Initialize(FOLDERID idFolder)
{
    TraceCall("CMessageView::Initialize");

    // Copy the pidl, we'll use it later
    m_idFolder = idFolder;

    return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown
//

HRESULT CMessageView::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IOleWindow))
        *ppvObj = (LPVOID) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IViewWindow))
        *ppvObj = (LPVOID) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IMessageWindow))
        *ppvObj = (LPVOID) (IMessageWindow *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;
    else if (IsEqualIID(riid, IID_IBodyOptions))
        *ppvObj = (LPVOID) (IBodyOptions *) this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, DIID__MessageListEvents))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, IID_IServerInfo))
        *ppvObj = (LPVOID) (IServerInfo *) this;

    if (NULL == *ppvObj)
        return (E_NOINTERFACE);

    AddRef();
    return S_OK;
}


ULONG CMessageView::AddRef(void)
{
    return InterlockedIncrement((LONG *) &m_cRef);
}

ULONG CMessageView::Release(void)
{
    InterlockedDecrement((LONG *) &m_cRef);
    if (0 == m_cRef)
    {
        delete this;
        return (0);
    }
    return (m_cRef);
}

/////////////////////////////////////////////////////////////////////////////
// IOleWindow
//

HRESULT CMessageView::GetWindow(HWND *pHwnd)
{
    if (!pHwnd)
        return (E_INVALIDARG);
    
    if (m_hwnd)
    {
        *pHwnd = m_hwnd;
        return (S_OK);
    }

    return (E_FAIL);
}


HRESULT CMessageView::ContextSensitiveHelp(BOOL fEnterMode)
{
    return (E_NOTIMPL);
}


/////////////////////////////////////////////////////////////////////////////
// IViewWindow
//


//
//  FUNCTION:   CMessageView::TranslateAccelerator()
//
//  PURPOSE:    Called by the frame window to give us first crack at messages.
//
//  PARAMETERS: 
//      [in] pMsg - The current message to be processed.
//
//  RETURN VALUE:
//      S_OK if the message was handled here and should not be processed further.
//      S_FALSE if the message should continued to be processed elsewhere.
// 
HRESULT CMessageView::TranslateAccelerator(LPMSG pMsg)
{
    DWORD dwState = 0;

    // See if the Preview Pane is interested
    if (m_pPreview)
    {
        if (S_OK == m_pPreview->HrTranslateAccelerator(pMsg))
            return (S_OK);
    
        if (IsChild(m_hwnd, GetFocus()))
        {
            if (pMsg->message == WM_KEYDOWN && pMsg->wParam != VK_SPACE)
                m_cLastChar = GetTickCount();

            if (pMsg->message == WM_KEYDOWN && 
                pMsg->wParam == VK_SPACE &&
                GetTickCount() - m_cLastChar > 1000)
            {
                if (m_fNotDownloaded)
                {
                    _UpdatePreviewPane(TRUE);
                }
                else if (SUCCEEDED(m_pMsgList->GetFocusedItemState(&dwState)) && dwState != 0)
                {
                    if (m_pPreview->HrScrollPage()!=S_OK)
                        m_pMsgListCT->Exec(NULL, ID_SPACE_ACCEL, 0, NULL, NULL);
                }
                else
                    m_pMsgListCT->Exec(NULL, ID_SPACE_ACCEL, 0, NULL, NULL);
            
                return S_OK;
            }
        }
    }

    // See if the message list is interested
    if (m_pMsgListAO)
    {
        if (S_OK == m_pMsgListAO->TranslateAccelerator(pMsg))
            return (S_OK);
    }

    return (S_FALSE);
}


//
//  FUNCTION:   CMessageView::UIActivate()
//
//  PURPOSE:    Called to notify the view when different activation and 
//              deactivation events occur.
//
//  PARAMETERS: 
//      [in] uState - SVUIA_ACTIVATE_FOCUS, SVUIA_ACTIVATE_NOFOCUS, and
//                    SVUIA_DEACTIVATE.
//
//  RETURN VALUE:
//      Returns S_OK all the time.
//
HRESULT CMessageView::UIActivate(UINT uState)
{
    if (uState != SVUIA_DEACTIVATE)
    {
        // If the focus stays within our frame, bug goes outside our view,
        // i.e. the folder list get's focus, then we get an 
        // SVUIA_ACTIVATE_NOFOCUS.  We need to UI Deactivate the preview
        // pane when this happens.
        if (uState == SVUIA_ACTIVATE_NOFOCUS && m_pPreview)
            m_pPreview->HrUIActivate(FALSE);

        if (m_uUIState != uState)
        {
            // Update our internal state
            m_uUIState = uState;

            // Update the toolbar state
            m_pBrowser->UpdateToolbar();
        }            
    }
    else
    {
        // Only deactivate if we're not already deactivated
        if (m_uUIState != SVUIA_DEACTIVATE)
        {
            // Update our internal state
            m_uUIState = uState;
        }
    }
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CreateViewWindow()
//
//  PURPOSE:    Called when it's time for the view to create it's window.
//
//  PARAMETERS: 
//      [in]  pPrevView - Pointer to the previous view if there was one
//      [in]  pBrowser - Pointer to the browser that hosts this view
//      [in]  prcView - Initial position and size of the view
//      [out] pHwnd - Returns the HWND of the newly created view window
//
//  RETURN VALUE:
//      S_OK if the view window was created successfully.  
//      E_FAIL if the window couldn't be created for some reason or another.
//
HRESULT CMessageView::CreateViewWindow(IViewWindow *pPrevView, IAthenaBrowser *pBrowser,
                                       RECT *prcView, HWND *pHwnd)
{
    WNDCLASS wc;

    // Without a browser pointer nothing will ever work.  
    if (!pBrowser)
        return (E_INVALIDARG);

    // Hang on to the browser pointer
    m_pBrowser = pBrowser;
    m_pBrowser->AddRef();

    // Get the window handle of the browser
    m_pBrowser->GetWindow(&m_hwndParent);
    Assert(IsWindow(m_hwndParent));

    // Load our persisted settings.  If this fails will just run with defaults.
    // _LoadSettings();

    // Register our window class if we haven't already
    if (!GetClassInfo(g_hInst, s_szMessageViewWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = CMessageView::ViewWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = s_szMessageViewWndClass;

        if (!RegisterClass(&wc))
            return (E_FAIL);
    }

    // Create the view window
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT , s_szMessageViewWndClass, NULL, 
                            WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                            prcView->left, prcView->top, prcView->right - prcView->left,
                            prcView->bottom - prcView->top, m_hwndParent, NULL,
                            g_hInst, (LPVOID) this);
    if (!m_hwnd)
        return (E_FAIL);

    *pHwnd = m_hwnd;

    // Get the message folder object from the previous folder here.
    _ReuseMessageFolder(pPrevView);

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::DestroyViewWindow()
//
//  PURPOSE:    Called by the browser to destroy the view window.
//
//  RETURN VALUE:
//      S_OK is returned always.
//
HRESULT CMessageView::DestroyViewWindow(void)
{
    // This is of course only interesting if we actually _have_ a window to 
    // destroy.
    if (m_hwnd)
    {
        // Tell the message list we're done with this folder
        if (m_pMsgList)
        {
            m_pMsgList->SetFolder(FOLDERID_INVALID, NULL, 0, 0, 0);
        }

        // Unadvise our connection point
        if (m_dwCookie)
        {
            AtlUnadvise(m_pMsgList, DIID__MessageListEvents, m_dwCookie);
            m_dwCookie = 0;
        }

        // $REVIEW - PreDestroyViewWindow() used to be called here to tell the subclasses
        //           of the iminent destruction.

        // Set our cached HWND to NULL before destroying prevents us from 
        // handling notifications after important stuff has been freed.
        HWND hwndDest = m_hwnd;
        m_hwnd = NULL;
        DestroyWindow(hwndDest);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::SaveViewState()
//
//  PURPOSE:    Called by the browser to give the view a chance to save it's 
//              settings before it is destroyed.
//
//  RETURN VALUE:
//      E_NOTIMPL
//
HRESULT CMessageView::SaveViewState(void)
{
    FOLDERTYPE ft = GetFolderType(m_idFolder);

    // Tell the message list to save it's state
    if (m_pMsgList)
    {
        m_pMsgList->OnClose();

        // We also need to save any settings that might have changed
        FOLDER_OPTIONS fo = { 0 };

        fo.cbSize = sizeof(FOLDER_OPTIONS);
        fo.dwMask = FOM_THREAD | FOM_OFFLINEPROMPT | FOM_SHOWDELETED | FOM_SHOWREPLIES;

        if (SUCCEEDED(m_pMsgList->GetViewOptions(&fo)))
        {
            switch (ft)
            {
                case FOLDER_NEWS:
                    SetDwOption(OPT_NEWS_THREAD, fo.fThread, 0, 0);
                    break;

                case FOLDER_LOCAL:
                case FOLDER_HTTPMAIL:
                    SetDwOption(OPT_MAIL_THREAD, fo.fThread, 0, 0);
                    break;

                case FOLDER_IMAP:
                    SetDwOption(OPT_MAIL_THREAD, fo.fThread, 0, 0);
                    break;
            }
            SetDwOption(OPT_SHOW_DELETED, (DWORD) (fo.fDeleted), 0, 0);
            SetDwOption(OPT_SHOW_REPLIES, (DWORD) (fo.fReplies), 0, 0);
        }
    }

    // Reset the contents of the status bar
    CStatusBar *pStatusBar;
    m_pBrowser->GetStatusBar(&pStatusBar);
    if (pStatusBar)
    {
        pStatusBar->SetStatusText("");
        pStatusBar->Release();
    }

    return (S_OK);
}

//
//  FUNCTION:   CMessageView::OnPopupMenu()
//
//  PURPOSE:    Called whenever the frame receives a WM_INITMENUPOPUP 
//              notification.  The view adds any menu items or sets any
//              check marks that are appropriate.
//
//  PARAMETERS: 
//      [in] hMenu - The handle of the root menu bar
//      [in] hMenuPopup -  The handle of the specific popup menu
//      [in] uID - The ID of the popup menu
//
//  RETURN VALUE:
//      Unused 
//
HRESULT CMessageView::OnPopupMenu(HMENU hMenu, HMENU hMenuPopup, UINT uID)
{
    MENUITEMINFO mii;
    UINT         uItem;
    HCHARSET     hCharset;

    // Handle our items
    switch (uID)
    {
        case ID_POPUP_LANGUAGE:
        {
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_SUBMENU;
            UINT uiCodepage = 0;
            HMENU hLangMenu = NULL;
            m_pPreview->HrGetCharset(&hCharset);
            uiCodepage = CustomGetCPFromCharset(hCharset, TRUE);
            if(m_pBrowser->GetLanguageMenu(&hLangMenu, uiCodepage) == S_OK)
            {
                if(IsMenu(hMenuPopup))
                    DestroyMenu(hMenuPopup);

                hMenuPopup = mii.hSubMenu = hLangMenu;
                SetMenuItemInfo(hMenu, ID_POPUP_LANGUAGE, FALSE, &mii);
            }  
            
            break;
        }

        case ID_POPUP_VIEW:
        {
            if (NULL == m_pViewMenu)
            {
                // Create the view menu
                HrCreateViewMenu(0, &m_pViewMenu);
            }
            
            if (NULL != m_pViewMenu)
            {
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU;
                
                if (FALSE == GetMenuItemInfo(hMenuPopup, ID_POPUP_FILTER, FALSE, &mii))
                {
                    break;
                }
                
                // Remove the old filter submenu
                if(IsMenu(mii.hSubMenu))
                    DestroyMenu(mii.hSubMenu);

                // Replace the view menu
                if (FAILED(m_pViewMenu->HrReplaceMenu(0, hMenuPopup)))
                {
                    break;
                }
            }
            break;
        }
        
        case ID_POPUP_FILTER:
        {
            if (NULL != m_pViewMenu)
            {
                m_pViewMenu->UpdateViewMenu(0, hMenuPopup, m_pMsgList);
            }
            break;
        }
    }

    // Let the message list update it's menus
    if (m_pMsgList)
        m_pMsgList->OnPopupMenu(hMenuPopup, uID);

    // Let the preview pane update it's menus
    if (m_pPreview)
        m_pPreview->HrOnInitMenuPopup(hMenuPopup, uID);


    return (S_OK);
}



HRESULT CMessageView::OnFrameWindowActivate(BOOL fActivate)
{
    if (m_pPreview)
        return m_pPreview->HrFrameActivate(fActivate);
    
    return (S_OK);
}

HRESULT CMessageView::UpdateLayout(BOOL fVisible, BOOL fHeader, BOOL fVert, 
                                   BOOL fUpdate)
{
    // If we haven't created the preview pane yet, and the call is telling
    // us to make it visible, then we need to initialize it first.
    if (!m_pPreview && fVisible)
    {
        if (!_InitPreviewPane())
            return (E_UNEXPECTED);
    }

    // Header on / off
    if (m_pPreview)
    {
        m_pPreview->HrSetStyle(fHeader ? MESTYLE_PREVIEW : MESTYLE_MINIHEADER);
    }

    // Split direction
    if (m_pPreview)
    {
        RECT rcClient;

        m_fSplitHorz = !fVert;
        GetClientRect(m_hwnd, &rcClient);
        OnSize(m_hwnd, SIZE_RESTORED, rcClient.right, rcClient.bottom);
    }

    //
    // [PaulHi] 6/11/99  Raid 79491
    // Backing out this fix that BrettM made for Raid 63739 because of problems
    // with security message warnings.
    //
#if 0
    if (fVisible)
    {
        // if showing update the preview pane
        _UpdatePreviewPane();
    }
    else
    {
        // if hiding, clear the contents
        if (NULL != m_pPreview)
            m_pPreview->HrUnloadAll(NULL, 0);
    }
#endif

    return (S_OK);
}

HRESULT CMessageView::GetMessageList(IMessageList ** ppMsgList)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == ppMsgList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppMsgList = NULL;

    // Get the message list
    if (NULL != m_pMsgList)
    {
        *ppMsgList = m_pMsgList;
        (*ppMsgList)->AddRef();
    }

    // Set the return value
    hr = (NULL == *ppMsgList) ? S_FALSE : S_OK;
    
exit:
    return hr;
}

HRESULT CMessageView::GetCurCharSet(UINT *cp)
{
    HCHARSET     hCharset;

    if(_IsPreview())
    {
        m_pPreview->HrGetCharset(&hCharset);
        *cp = CustomGetCPFromCharset(hCharset, TRUE);
    }
    else
        *cp = GetACP();

    return S_OK;
}

//
//  FUNCTION:   CMessageView::QueryStatus()
//
//  PURPOSE:    Called by the browser to determine if a list of commands should
//              should be enabled or disabled.
//
//  PARAMETERS: 
//      [in] pguidCmdGroup - Group the commands are part of (unused)
//      [in] cCmds - Number of commands to be evaluated
//      [in] prgCmds - List of commands
//      [out] pCmdText - Description text for a command
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                  OLECMDTEXT *pCmdText) 
{
    DWORD   cSel;
    HRESULT hr;
    HWND    hwndFocus = GetFocus();
    BOOL    fChildFocus = (hwndFocus != NULL && IsChild(m_hwnd, hwndFocus));
    DWORD   cFocus;
    DWORD  *rgSelected = 0;
    FOLDERTYPE ftType;

    // Let the sub objects look first
    if (m_pMsgListCT)
    {
        hr = m_pMsgListCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    if (_IsPreview() && m_pPreviewCT)
    {
        hr = m_pPreviewCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // Up front some work
    m_pMsgList->GetSelected(&cFocus, &cSel, &rgSelected);

    // Now loop through the commands in the prgCmds array looking for ones the 
    // sub objects didn't handle.
    for (UINT i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // If this command is from the language menu
            if (prgCmds[i].cmdID >= ID_LANG_FIRST && prgCmds[i].cmdID <= ID_LANG_LAST)
            {
                HCHARSET     hCharset;

                m_pPreview->HrGetCharset(&hCharset);

                // Enable only the supported languages
                if (prgCmds[i].cmdID < (UINT) (ID_LANG_FIRST + GetIntlCharsetLanguageCount()))
                {
#if 0
                    if(SetMimeLanguageCheckMark(CustomGetCPFromCharset(hCharset, TRUE), prgCmds[i].cmdID - ID_LANG_FIRST))
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
#else
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | SetMimeLanguageCheckMark(CustomGetCPFromCharset(hCharset, TRUE), prgCmds[i].cmdID - ID_LANG_FIRST);
#endif
                }
                else
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                continue;
            }

            // if the command id from the View.Current View menu
            if ((ID_VIEW_FILTER_FIRST <= prgCmds[i].cmdID) && (ID_VIEW_FILTER_LAST >= prgCmds[i].cmdID))
            {
                if (NULL == m_pViewMenu)
                {
                    // Create the view menu
                    HrCreateViewMenu(0, &m_pViewMenu);
                }
            
                if (NULL != m_pViewMenu)
                {
                    m_pViewMenu->QueryStatus(m_pMsgList, &(prgCmds[i]));
                }

                continue;
            }
            
            // Look to see if it's a command we provide
            switch (prgCmds[i].cmdID)
            {
                case ID_OPEN:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    m_pMsgList->GetSelectedCount(&cSel);
                    if (cSel)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_REPLY:
                case ID_REPLY_ALL:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0 && (0 == (pInfo->dwFlags & ARF_UNSENT)))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }

                case ID_SAVE_AS:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (_IsPreview() && (cSel == 1))
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }


                case ID_PRINT:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is more than one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (_IsPreview() && cSel > 0)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }

                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel > 0)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        // Default to success
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        for (DWORD iItem = 0; iItem < cSel && (prgCmds[i].cmdf & OLECMDF_ENABLED); iItem++)
                        {
                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[iItem], &pInfo)))
                            {
                                if (pInfo->faStream == 0 || (0 != (pInfo->dwFlags & ARF_UNSENT)))
                                {
                                    prgCmds[i].cmdf &= ~OLECMDF_ENABLED;
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }

                    break;
                }

                case ID_REPLY_GROUP:
                {
                    // Enabled only if there is one news message selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0 && (pInfo->dwFlags & ARF_NEWSMSG)  && (0 == (pInfo->dwFlags & ARF_UNSENT)))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }

                case ID_CANCEL_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (DwGetOption(OPT_CANCEL_ALL_NEWS))
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    else
                    {
                        if (cSel == 1)
                        {
                            LPMESSAGEINFO pInfo;

                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                            {
                                if (NewsUtil_FCanCancel(m_idFolder, pInfo))
                                {
                                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }
                    break;
                }

                case ID_POPUP_FILTER:
                case ID_PREVIEW_PANE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
                }

                case ID_POPUP_LANGUAGE_DEFERRED:
                case ID_POPUP_LANGUAGE:
                case ID_POPUP_LANGUAGE_MORE:
                case ID_LANGUAGE:
                {
                    // These are OK if the preview pane is visible and not empty
                    if (cSel > 0 && _IsPreview())
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    break;
                }

                case ID_PREVIEW_SHOW:
                case ID_PREVIEW_BELOW:
                case ID_PREVIEW_BESIDE:
                case ID_PREVIEW_HEADER:
                {
                    FOLDERTYPE  ftType;
                    DWORD       dwOpt;
                    LAYOUTPOS   pos;
                    BOOL        fVisible;
                    DWORD       dwFlags;

                    // Default return value
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    
                    // Get the folder type
                    m_pBrowser->GetFolderType(&ftType);
                    if (ftType == FOLDER_NEWS)
                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
                    else
                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

                    // Get the settings from the browser
                    m_pBrowser->GetViewLayout(dwOpt, &pos, &fVisible, &dwFlags, NULL);
                    
                    switch (prgCmds[i].cmdID)
                    {
                        case ID_PREVIEW_SHOW:
                        {
                            // Always enabled, checked if already visible
                            if (fVisible)
                                prgCmds[i].cmdf |= (OLECMDF_ENABLED | OLECMDF_LATCHED);
                            else
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            break;
                        }

                        case ID_PREVIEW_BESIDE:
                        case ID_PREVIEW_BELOW:
                        {
                            // The command is enabled only if the preview pane
                            // is visible.
                            if (fVisible)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            // If the preview pane is already beside, it should be latched etc.
                            if ((pos == LAYOUT_POS_LEFT && prgCmds[i].cmdID == ID_PREVIEW_BESIDE) ||
                                (pos == LAYOUT_POS_BOTTOM && prgCmds[i].cmdID == ID_PREVIEW_BELOW))
                                prgCmds[i].cmdf |= OLECMDF_NINCHED;

                            break;
                        }

                        case ID_PREVIEW_HEADER:
                        {
                            // Always enabled, checked if already visible
                            if (dwFlags)
                                prgCmds[i].cmdf |= (OLECMDF_ENABLED | OLECMDF_LATCHED);
                            else
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            break;
                        }
                    }

                    break;
                }

                case ID_REFRESH:
                {
                    // Best I can tell, these are always enabled
                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    break;
                }

                case ID_GET_HEADERS:
                {
                    // Only in news
                    m_pBrowser->GetFolderType(&ftType);
                    if (ftType != FOLDER_LOCAL)
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    break;
                }

                case ID_ADD_SENDER:
                case ID_BLOCK_SENDER:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected and
                    // we have access to the from address
                    // Not in IMAP or HTTPMAIL
                    m_pBrowser->GetFolderType(&ftType);
                    if (cSel == 1 &&
                        (prgCmds[i].cmdID == ID_ADD_SENDER || (FOLDER_HTTPMAIL != ftType && FOLDER_IMAP != ftType)))
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0])) || (0 != pInfo->faStream))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }
                
                case ID_CREATE_RULE_FROM_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected
                    // Not in IMAP or HTTPMAIL
                    m_pBrowser->GetFolderType(&ftType);
                    if ((cSel == 1) && (FOLDER_HTTPMAIL != ftType) && (FOLDER_IMAP != ftType))
                    {
                        LPMESSAGEINFO pInfo;
                        
                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }
                
                case ID_COMBINE_AND_DECODE:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    m_pMsgList->GetSelectedCount(&cSel);
                    if (cSel > 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

            }
        }
    }

    SafeMemFree(rgSelected);

    return (S_OK);
}

HRESULT CMessageView::_StoreCharsetOntoRows(HCHARSET hCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    INETCSETINFO    CsetInfo;
    IMessageTable  *pTable=NULL;
    DWORD          *rgRows=NULL;
    DWORD           cRows=0;
    HCURSOR         hCursor=NULL;

    // Trace
    TraceCall("CMessageView::_StoreCharsetOntoRows");

    // Invalid Args
    if (NULL == m_pMsgList || NULL == hCharset)
        return(TraceResult(E_INVALIDARG));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Get charset info
    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CsetInfo));

    // Get selected rows
    IF_FAILEXIT(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows));

    // Get the message table
    IF_FAILEXIT(hr = m_pMsgList->GetMessageTable(&pTable));

    // Set the Language
    SideAssert(SUCCEEDED(pTable->SetLanguage(cRows, rgRows, CsetInfo.cpiInternet)));

exit:
    // Cleanup
    SafeRelease(pTable);
    SafeMemFree(rgRows);

    // Reset Cursor
    if (hCursor)
        SetCursor(hCursor);

    // Done
    return(hr);
}

//
//  FUNCTION:   CMessageView::Exec()
//
//  PURPOSE:    Called to execute a verb that this view supports
//
//  PARAMETERS: 
//      [in]  pguidCmdGroup - unused
//      [in]  nCmdID - ID of the command to execute
//      [in]  nCmdExecOpt - Options that define how the command should execute
//      [in]  pvaIn - Any arguments for the command
//      [out] pvaOut - Any return values for the command
//
//  RETURN VALUE:
//       
//
HRESULT CMessageView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                           VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    // See if our message list wants the command
    if (m_pMsgListCT)
    {
        if (OLECMDERR_E_NOTSUPPORTED != m_pMsgListCT->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut))
            return (S_OK);
    }

    if (m_pPreviewCT)
    {
        if (OLECMDERR_E_NOTSUPPORTED != m_pPreviewCT->Exec(&CMDSETID_OutlookExpress, nCmdID, nCmdExecOpt, pvaIn, pvaOut))
            return (S_OK);
    }

    // If the sub objects didn't support the command, then we should see if
    // it's one of ours

    // Language menu first
    if (nCmdID >= ID_LANG_FIRST && nCmdID <= ID_LANG_LAST)
    {
        HCHARSET    hCharset = NULL;
        HCHARSET    hOldCharset = NULL;
        HRESULT hr = S_OK;

        if(!m_pPreview)
            return S_OK;

        m_pPreview->HrGetCharset(&hOldCharset);

        hCharset = GetMimeCharsetFromMenuID(nCmdID);

        if(!hCharset || (hOldCharset == hCharset))
            return(S_OK);

        Assert (hCharset);

        if(FAILED(hr = m_pPreview->HrSetCharset(hCharset)))
        {
            AthMessageBoxW(  m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                        MAKEINTRESOURCEW((hr == hrIncomplete)?idsViewLangMimeDBBad:idsErrViewLanguage), 
                        NULL, MB_OK|MB_ICONEXCLAMATION);
            return E_FAIL;
        }

        // Set the charset onto the selected rows....
        _StoreCharsetOntoRows(hCharset);

        // SetDefaultCharset(hCharset);

        // SwitchLanguage(nCmdID, TRUE);
        return (S_OK);
    }

    // Handle the View.Current View menu
    if ((ID_VIEW_FILTER_FIRST <= nCmdID) && (ID_VIEW_FILTER_LAST >= nCmdID))
    {
        if (NULL == m_pViewMenu)
        {
            // Create the view menu
            HrCreateViewMenu(0, &m_pViewMenu);
        }
        
        if (NULL != m_pViewMenu)
        {
            // What we get from the browser is of type VT_I8, but rules only needs filter id which 
            // is a dword. So changing the type here is safe. Bug# 74275
            pvaIn->vt = VT_I4;
            if (SUCCEEDED(m_pViewMenu->Exec(m_hwnd, nCmdID, m_pMsgList, pvaIn, pvaOut)))
            {
                return (S_OK);
            }
        }
    }
    
    // Go through the rest of the commands
    switch (nCmdID)
    {
        case ID_OPEN:
            return CmdOpen(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REPLY:
        case ID_REPLY_ALL:
        case ID_FORWARD:
        case ID_FORWARD_AS_ATTACH:
        case ID_REPLY_GROUP:
            return CmdReplyForward(nCmdID, nCmdExecOpt, pvaIn, pvaOut);            

        case ID_CANCEL_MESSAGE:
            return CmdCancelMessage(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_DOWNLOAD_MESSAGE:
            return CmdFillPreview(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_PREVIEW_PANE:
        case ID_PREVIEW_SHOW:
        case ID_PREVIEW_BELOW:
        case ID_PREVIEW_BESIDE:
        case ID_PREVIEW_HEADER:
            return CmdShowPreview(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REFRESH:
            return CmdRefresh(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_BLOCK_SENDER:
            return CmdBlockSender(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_CREATE_RULE_FROM_MESSAGE:
            return CmdCreateRule(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_VIEW_SOURCE:
        case ID_VIEW_MSG_SOURCE:
            if (m_pPreview)
                return m_pPreview->HrViewSource((ID_VIEW_SOURCE==nCmdID)?MECMD_VS_HTML:MECMD_VS_MESSAGE);
            else
                break;

        case ID_ADD_SENDER:
            return CmdAddToWab(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COMBINE_AND_DECODE:
            return CmdCombineAndDecode(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
    }

    return (E_FAIL);
}


//
//  FUNCTION:   CMessageView::Invoke()
//
//  PURPOSE:    This is where we receive notifications from the message list.
//
//  PARAMETERS: 
//      <too many to list>
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                             WORD wFlags, DISPPARAMS* pDispParams, 
                             VARIANT* pVarResult, EXCEPINFO* pExcepInfo, 
                             unsigned int* puArgErr)
{
    switch (dispIdMember)
    {

        // Fired whenever the selection in the ListView changes
        case DISPID_LISTEVENT_SELECTIONCHANGED:
        {
            // Need to load the preview pane with the new selected message
            if (_IsPreview())
                _UpdatePreviewPane();

            // Tell the browser to update it's toolbar
            if (m_pBrowser)
                m_pBrowser->UpdateToolbar();
            
            break;
        }

        // Fired whenever the ListView get's or loses focus.
        case DISPID_LISTEVENT_FOCUSCHANGED:
        {
            // If the ListView is getting the focus, we need to UI deactivate
            // the preview pane.
            if (pDispParams->rgvarg[0].lVal)
            {
                if (m_pPreview)
                {
                    m_pPreview->HrUIActivate(FALSE);
                    m_pBrowser->OnViewWindowActive(this);
                }
            }
            break;
        }

        // Fired when the number of messages or unread messages changes
        case DISPID_LISTEVENT_COUNTCHANGED:
        {
            // If we have a browser, update the status bar
            if (m_pBrowser && !m_pProgress)
            {
                DWORD cTotal, cUnread, cOnServer;

                // Readability forces me to do this
                cTotal = pDispParams->rgvarg[0].lVal;
                cUnread = pDispParams->rgvarg[1].lVal;
                cOnServer = pDispParams->rgvarg[2].lVal;

                // Got to update the status bar if there is one
                CStatusBar *pStatusBar = NULL;
                m_pBrowser->GetStatusBar(&pStatusBar);

                if (pStatusBar)
                {
                    TCHAR szStatus[CCHMAX_STRINGRES + 20];
                    TCHAR szFmt[CCHMAX_STRINGRES];
                    DWORD ids;

                    // If there are still messages on server load a different
                    // status string.
                    if (cOnServer)
                    {
                        AthLoadString(idsXMsgsYUnreadZonServ, szFmt, ARRAYSIZE(szFmt));
                        wnsprintf(szStatus, ARRAYSIZE(szStatus), szFmt, cTotal, cUnread, cOnServer);
                    }
                    else
                    {
                        AthLoadString(idsXMsgsYUnread, szFmt, ARRAYSIZE(szFmt));
                        wnsprintf(szStatus, ARRAYSIZE(szStatus), szFmt, cTotal, cUnread);
                    }

                    pStatusBar->SetStatusText(szStatus);
                    pStatusBar->Release();
                }

                // Also update the toolbar since commands like "Mark as Read" might
                // change.  However, we only do this if we go between zero and some or
                // vice versa.
                if ((m_cItems == 0 && cTotal) || (m_cItems != 0 && cTotal == 0) ||
                    (m_cUnread == 0 && cUnread) || (m_cUnread != 0 && cUnread == 0))
                {
                    m_pBrowser->UpdateToolbar();
                }

                // Save this for next time.
                m_cItems = cTotal;
                m_cUnread = cUnread;
            }
            break;
        }

        // Fired when the message list want's to show status text
        case DISPID_LISTEVENT_UPDATESTATUS:
        {
            _SetProgressStatusText(pDispParams->rgvarg->bstrVal);
            break;
        }

        // Fired when progress happens
        case DISPID_LISTEVENT_UPDATEPROGRESS:
        {
            CBands *pCoolbar = NULL;

            // If this is a begin, then we start animating the logo
            if (pDispParams->rgvarg[2].lVal == PROGRESS_STATE_BEGIN)
            {
                if (SUCCEEDED(m_pBrowser->GetCoolbar(&pCoolbar)))
                {
                    pCoolbar->Invoke(idDownloadBegin, NULL);
                    pCoolbar->Release();
                }
            }

            // If this is a continue, then we might get progress numbers
            else if (pDispParams->rgvarg[2].lVal == PROGRESS_STATE_DEFAULT)
            {
                if (!m_pProgress)
                {
                    if (m_pBrowser->GetStatusBar(&m_pProgress)==S_OK)
                        m_pProgress->ShowProgress(pDispParams->rgvarg[1].lVal);
                }

                if (m_pProgress)
                    m_pProgress->SetProgress(pDispParams->rgvarg[0].lVal);
            }

            // Or if this is an end, stop animating and clean up the status bar
            else if (pDispParams->rgvarg[2].lVal == PROGRESS_STATE_END)
            {
                if (m_pProgress)
                {
                    m_pProgress->HideProgress();
                    m_pProgress->Release();
                    m_pProgress = NULL;
                }

                if (SUCCEEDED(m_pBrowser->GetCoolbar(&pCoolbar)))
                {
                    pCoolbar->Invoke(idDownloadEnd, NULL);
                    pCoolbar->Release();
                }

                // Reset the status bar back to it's default state
                _SetDefaultStatusText();
            }

            break;
        }

        // Fired when the user double clicks an item in the ListView
        case DISPID_LISTEVENT_ITEMACTIVATE:
        {
            CmdOpen(ID_OPEN, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            break;
        }

        // Fired when we need to call update toolbar
        case DISPID_LISTEVENT_UPDATECOMMANDSTATE:
        {
            PostMessage(m_hwndParent, CM_UPDATETOOLBAR, 0, 0L);
            break;
        }

        
        // Fired when a message has been downloaded by the messagelist
        case DISPID_LISTEVENT_ONMESSAGEAVAILABLE:
        {
            return _OnMessageAvailable((MESSAGEID)((LONG_PTR)pDispParams->rgvarg[0].lVal), (HRESULT)pDispParams->rgvarg[1].scode);
        }

        // Fired when the filter changes
        case DISPID_LISTEVENT_FILTERCHANGED:
        {
            // If we have a browser, update the status bar
            if (m_pBrowser && !m_pProgress)
            {
                // Got to update the status bar if there is one
                CStatusBar *pStatusBar = NULL;
                m_pBrowser->GetStatusBar(&pStatusBar);

                if (pStatusBar)
                {
                    pStatusBar->SetFilter((RULEID)((ULONG_PTR)pDispParams->rgvarg[0].ulVal));
                    pStatusBar->Release();
                }

                CBands*  pBands;
                if (m_pBrowser->GetCoolbar(&pBands) == S_OK)
                {
                    pBands->Invoke(idNotifyFilterChange, &pDispParams->rgvarg[0].ulVal);
                    pBands->Release();
                }
            }
            break;
        }

        case DISPID_LISTEVENT_ADURL_AVAILABLE:
        {
            if (m_pBrowser)
            {
                m_pBrowser->ShowAdBar(pDispParams->rgvarg[0].bstrVal);
            }   
            break;
        }

    }

    return (S_OK);
}


HRESULT CMessageView::GetMarkAsReadTime(LPDWORD pdwSecs)
{
    if (!pdwSecs)
    {
        AssertSz(FALSE, "Null Pointer");
        return (E_INVALIDARG);
    }

    *pdwSecs = DwGetOption(OPT_MARKASREAD);
    
    return (S_OK);
}

HRESULT CMessageView::GetAccount(IImnAccount **ppAcct)
{
    FOLDERINFO      FolderInfo;
    HRESULT         hr = E_FAIL;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    
    if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
    {
        if (SUCCEEDED(GetFolderAccountId(&FolderInfo, szAccountId, ARRAYSIZE(szAccountId)) && *szAccountId))
        {
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, ppAcct);  
            // If local store then we can fail
            if(FAILED(hr))
            {
                DWORD   dwRow = 0;
                DWORD   cSel = 0;
                if (SUCCEEDED(m_pMsgList->GetSelected(&dwRow, &cSel, NULL)))
                {
                    LPMESSAGEINFO pMsgInfo;
                    if (SUCCEEDED(m_pMsgList->GetMessageInfo(dwRow, &pMsgInfo)))
                    {
                        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pMsgInfo->pszAcctId, ppAcct);  
                        m_pMsgList->FreeMessageInfo(pMsgInfo);
                    }
                }
            }
        }
        g_pStore->FreeRecord(&FolderInfo);
    }
    return(hr);
}

HRESULT CMessageView::GetFlags(LPDWORD pdwFlags)
{
    FOLDERTYPE ftType;

    if (!pdwFlags)
    {
        AssertSz(FALSE, "Null Pointer");
        return (E_INVALIDARG);
    }

    *pdwFlags = BOPT_AUTOINLINE | BOPT_HTML | BOPT_INCLUDEMSG | BOPT_FROMSTORE;

    if (m_pMsgList)
    {
        DWORD   dwRow = 0;
        DWORD   cSel = 0;
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwRow, &cSel, NULL)))
        {
            LPMESSAGEINFO pMsgInfo;

            if (cSel > 1)
                *pdwFlags |= BOPT_MULTI_MSGS_SELECTED;

            if (SUCCEEDED(m_pMsgList->GetMessageInfo(dwRow, &pMsgInfo)))
            {
                if (0 == (pMsgInfo->dwFlags & ARF_READ))
                    *pdwFlags |= BOPT_UNREAD;
                if (0 == (pMsgInfo->dwFlags & ARF_NOSECUI))
                    *pdwFlags |= BOPT_SECURITYUIENABLED;
                m_pMsgList->FreeMessageInfo(pMsgInfo);
            }
        }
    }

    m_pBrowser->GetFolderType(&ftType);
    if (FOLDER_NEWS != ftType)
        *pdwFlags |= BOPT_MAIL;

    return (S_OK);
}



//
//  FUNCTION:   CMessageView::EventOccurred()
//
//  PURPOSE:    Get's hit whenever an interesting event happens in the preview 
//              pane.
//
//  PARAMETERS: 
//      DWORD nCmdID
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::EventOccurred(DWORD nCmdID, IMimeMessage *pMessage)
{
    TraceCall("CMessageView::EventOccurred");

    switch (nCmdID)
    {
        case MEHC_CMD_DOWNLOAD:    
            Assert(m_fNotDownloaded);
            
            // If we're offline, we can make the reasonable assumption that
            // the user wants to be online since they said they wanted to 
            // download this message.
            if (g_pConMan && g_pConMan->IsGlobalOffline())
                g_pConMan->SetGlobalOffline(FALSE);

            _UpdatePreviewPane(TRUE);
            break;

        case MEHC_CMD_MARK_AS_READ:
            if (m_pMsgList)
                m_pMsgList->MarkRead(TRUE, 0);
            break;

        case MEHC_CMD_CONNECT:
            if (g_pConMan)
                g_pConMan->SetGlobalOffline(FALSE);
            _UpdatePreviewPane();
            break;

        case MEHC_BTN_OPEN:
        case MEHC_BTN_CONTINUE:
            // Update the toolbar state
            m_pBrowser->UpdateToolbar();
            break;

        case MEHC_UIACTIVATE:
            m_pBrowser->OnViewWindowActive(this);
            break;

        case MEHC_CMD_PROCESS_RECEIPT:
            if (m_pMsgList)
                m_pMsgList->ProcessReceipt(pMessage);
            break;

        default:
           /*  AssertSz(FALSE, "CMessageView::EventOccured() - Unhandled Event."); */ // Valid situation - Warning message for S/MIME
            break;
    }

    return (S_FALSE);
}


HRESULT CMessageView::GetFolderId(FOLDERID *pID)
{
    if (pID)
    {
        *pID = m_idFolder;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageView::GetMessageFolder(IMessageServer **ppServer)
{
    if (m_pMsgList)
        return (m_pMsgList->GetMessageServer(ppServer));

    return (E_NOTIMPL);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Window Message Handling
//


//
//  FUNCTION:   CMessageView::ViewWndProc()
//
//  PURPOSE:    Callback handler for the view window.  This function grabs the
//              correct this pointer for the window and uses that to dispatch
//              the message to the private message handler.
//
LRESULT CALLBACK CMessageView::ViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                           LPARAM lParam)
{
    LRESULT       lResult;
    CMessageView *pThis;

    // WM_NCCREATE is the first message our window will receive.  The lParam
    // will have the pointer to the object that created this instance of the
    // window.
    if (uMsg == WM_NCCREATE)
    {
        // Save the object pointer in the window's extra bytes.
        pThis = (CMessageView *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
    {
        // If this is any other message, we need to get the object pointer
        // from the window before dispatching the message.
        pThis = (CMessageView *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    // If this ain't true, we're in trouble.
    if (pThis)
    {
        return (pThis->_WndProc(hwnd, uMsg, wParam, lParam));
    }
    else
    {
        Assert(pThis);
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}


//
//  FUNCTION:   CMessageView::_WndProc()
//
//  PURPOSE:    This private message handler dispatches messages to the 
//              appropriate handler.
//
LRESULT CALLBACK CMessageView::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_POSTCREATE,     OnPostCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN,    OnLButtonDown);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,      OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONUP,      OnLButtonUp);
        HANDLE_MSG(hwnd, WM_NOTIFY,         OnNotify);
        HANDLE_MSG(hwnd, WM_DESTROY,        OnDestroy);
        HANDLE_MSG(hwnd, WM_SETFOCUS,       OnSetFocus);
        HANDLE_MSG(hwnd, WM_TEST_GETMSGID,  OnTestGetMsgId);
        HANDLE_MSG(hwnd, WM_TEST_SAVEMSG,   OnTestSaveMessage);

        case WM_FOLDER_LOADED:
            OnFolderLoaded(hwnd, wParam, lParam);
            break;

        case WM_NEW_MAIL:
            // Propagate up to browser
            PostMessage(m_hwndParent, WM_NEW_MAIL, 0, 0);
            break;

        case NVM_GETNEWGROUPS:
            if (m_pGroups != NULL)
            {
                m_pGroups->HandleGetNewGroups();
                m_pGroups->Release();
                m_pGroups = NULL;
            }
            return(0);

        case WM_UPDATE_PREVIEW:
            if (m_idMessageFocus == (MESSAGEID)wParam)
            {
                _UpdatePreviewPane();
            }
            break;

        case CM_OPTIONADVISE:
            _OptionUpdate((DWORD) wParam);
            break;

        case WM_MENUSELECT:
            // HANDLE_WM_MENUSELECT() has a bug that prevents popups from displaying correctly.
            OnMenuSelect(hwnd, wParam, lParam);
            return (0);

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            if (m_pMsgList)
            {
                IOleWindow *pWindow;
                if (SUCCEEDED(m_pMsgList->QueryInterface(IID_IOleWindow, (LPVOID *) &pWindow)))
                {
                    HWND hwndList;
                    pWindow->GetWindow(&hwndList);
                    SendMessage(hwndList, uMsg, wParam, lParam);
                    pWindow->Release();
                }
            }
            return (0);
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}
 
// PURPOSE: WM_FOLDER_LOADED message is sent when messagelist is done loading the cached headers/messages etc
void CMessageView::OnFolderLoaded(HWND  hwnd, WPARAM wParam, LPARAM lParam)
{
    FOLDERINFO      FolderInfo;
    if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
    {
        CHAR szAccountId[CCHMAX_ACCOUNT_NAME];

        if (SUCCEEDED(GetFolderAccountId(&FolderInfo, szAccountId, ARRAYSIZE(szAccountId))))
        {
            HRESULT     hr;

            if (g_pConMan)
            {
                hr = g_pConMan->CanConnect(szAccountId);
                if ((hr != S_OK) && (hr != HR_E_DIALING_INPROGRESS) && (hr != HR_E_OFFLINE))
                    g_pConMan->Connect(szAccountId, hwnd, TRUE);
            }
        }
        g_pStore->FreeRecord(&FolderInfo);
    }
}

//
//  FUNCTION:   CMessageView::OnCreate()
//
//  PURPOSE:    Handler for the WM_CREATE message.  In return we create our 
//              dependant objects and initialize them.
//
//  PARAMETERS: 
//      [in] hwnd - Handle of the window being created
//      [in] lpCreateStruct - Pointer to a structure with information about the
//                            creation.
//
//  RETURN VALUE:
//      Returns FALSE if something fails and the window should not be created,
//      and returns TRUE if everything works fine.
//
BOOL CMessageView::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    HRESULT hr;
    HWND hwndList;

    TraceCall("CMessageView::OnCreate");

    // Save the window handle
    m_hwnd = hwnd;

    // Create the message list object
    if (!_InitMessageList())
        return (FALSE);

    // Create the preview pane.  If it fails that's OK, we'll just
    // run without it.
    _InitPreviewPane();

    // Get updates when options change
    OptionAdvise(m_hwnd);

    // For later
    PostMessage(m_hwnd, WM_POSTCREATE, 0, 0);

    return (TRUE);
}


//
//  FUNCTION:   CMessageView::OnPostCreate()
//
//  PURPOSE:    Notifies when the view has finished being created.  Any 
//              initialization that takes time can happen here, like loading
//              the message table etc.
//
//  PARAMETERS: 
//      [in] hwnd - Handle of the window
//
void CMessageView::OnPostCreate(HWND hwnd)
{
    HRESULT     hr;
    FOLDERTYPE  FolderType;
    FOLDERINFO  fiServerNode = {0};
    HRESULT     hrTemp;

    TraceCall("CMessageView::OnPostCreate");

    if (!g_pStore)
        return;

    FolderType = GetFolderType(m_idFolder);
    
    ProcessICW(hwnd, FolderType);

    // BETA-2: If this is IMAP folder, check if IMAP folderlist is dirty.
    // If so, prompt user to refresh folderlist

    hrTemp = GetFolderServer(m_idFolder, &fiServerNode);
    TraceError(hrTemp);
    if (SUCCEEDED(hrTemp))
    {
        if (FOLDER_IMAP == FolderType)
            CheckIMAPDirty(fiServerNode.pszAccountId, hwnd, fiServerNode.idFolder, NOFLAGS);
    }

    // Tell the Message List control to load itself
    if (m_pMsgList)
    {
        // Tell the message list to change folders
        hr = m_pMsgList->SetFolder(m_idFolder, m_pServer, FALSE, NULL, NOSTORECALLBACK);
        if (FAILED(hr) && hr != E_PENDING && m_pPreview)
        {
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_FldrFail);
        }
    }

    
    if (m_pServer)
    {
        m_pServer->ConnectionRelease();
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Create a drop target
    m_pDropTarget = new CDropTarget();
    if (m_pDropTarget)
    {
        if (SUCCEEDED(m_pDropTarget->Initialize(m_hwnd, m_idFolder)))
        {
            RegisterDragDrop(m_hwnd, m_pDropTarget);
        }
    }

    if (FolderType == FOLDER_NEWS)
        NewsUtil_CheckForNewGroups(hwnd, m_idFolder, &m_pGroups);

    // If its HTTP folder (Should have been hotmail folder), and if we are connected we ask for the ad url.
    if ((FolderType == FOLDER_HTTPMAIL) &&
        (g_pConMan && (S_OK == g_pConMan->CanConnect(fiServerNode.pszAccountId))))
    {
        m_pMsgList->GetAdBarUrl();
    }

    g_pStore->FreeRecord(&fiServerNode);
}

#define SPLIT_SIZE 3

void CMessageView::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rc = {0, 0, cxClient, cyClient};
    int  split;

    // If we are displaying the preview pane, we need to split the client area
    // based on the position of the split bar.
    if (_IsPreview())
    {
        // Line the windows up based on the split direction
        if (m_fSplitHorz)
        {
            // Determine the split height
            split = (cyClient * m_dwSplitHorzPct) / 100;

            // Save the rect that the split bar occupies
            SetRect(&m_rcSplit, 0, split, cxClient, split + SPLIT_SIZE);

            // Set the position of the preview pane
            rc.top = m_rcSplit.bottom;
            rc.bottom = cyClient;
            
            if (m_pPreview)
                m_pPreview->HrSetSize(&rc);

            // Set the position of the message list
            SetRect(&rc, -1, 0, cxClient + 2, split);
            m_pMsgList->SetRect(rc);
        }
        else
        {
            // Determine the split width
            split = (cxClient * m_dwSplitVertPct) / 100;

            // Save the rect that the split bar occupies
            SetRect(&m_rcSplit, split, 0, split + SPLIT_SIZE, cyClient);

            // Set the position of the message list
            rc.right = split;
            m_pMsgList->SetRect(rc);

            // Set the position of the preview pane
            rc.left = m_rcSplit.right;
            rc.right = cxClient;
            
            if (m_pPreview)
                m_pPreview->HrSetSize(&rc);
        }
    }
    else
    {
        SetRect(&rc, -1, 0, cxClient + 2, cyClient);
        m_pMsgList->SetRect(rc);
    }

    return;
}


//
//  FUNCTION:   CMessageView::OnLButtonDown
//
//  PURPOSE:    We check to see if we're over the splitter bar and if so start
//              a drag operation.
//
//  PARAMETERS:
//      hwnd         - Handle to the view window.
//      fDoubleClick - TRUE if this is a double click.
//      x, y         - Position of the mouse in client coordinates.
//      keyFlags     - State of the keyboard.
//    
void CMessageView::OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    POINT       pt = {x, y};

    // Check to see if the mouse is over the split bar
    if (_IsPreview() && PtInRect(&m_rcSplit, pt))
    {
        // Capture the mouse
        SetCapture(m_hwnd);

        // Start dragging
        m_fDragging = TRUE;
    }
}


//
//  FUNCTION:   CMessageView::OnMouseMove
//
//  PURPOSE:    We update any drag and drop information in response to mouse
//              moves if a drag and drop is in progress.
//
//  PARAMETERS:
//      hwnd     - Handle to the view window.
//      x, y     - Position of the mouse in client coordinates.
//      keyFlags - State of the keyboard.
//
void CMessageView::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    HCURSOR hcur;
    POINT pt = {x, y};
    RECT  rcClient;

    // If we're dragging the split bar, update the window sizes
    if (m_fDragging)
    {
        // Get the size of the window
        GetClientRect(m_hwnd, &rcClient);

        // Calculate the new split percentage
        if (m_fSplitHorz)
        {
            // Make sure the user hasn't gone off the deep end
            if (y > 32 && y < (rcClient.bottom - 32))
                m_dwSplitHorzPct = (y * 100) / rcClient.bottom;
        }
        else
        {
            // Make sure the user hasn't gone off the deep end
            if (x > 32 && x < (rcClient.right - 32))
                m_dwSplitVertPct = (x * 100) / rcClient.right;
        }

        // Update the window sizes
        OnSize(m_hwnd, SIZE_RESTORED, rcClient.right, rcClient.bottom);
    }
    else
    {
        // Just update the cursor
        if (PtInRect(&m_rcSplit, pt))
            {
            if (m_fSplitHorz)
                hcur = LoadCursor(NULL, MAKEINTRESOURCE(IDC_SIZENS));
            else
                hcur = LoadCursor(NULL, MAKEINTRESOURCE(IDC_SIZEWE));    
            }
        else
            hcur = LoadCursor(NULL, IDC_ARROW);

        SetCursor(hcur);
    }
}

//
//  FUNCTION:   CMessageView::OnLButtonUp
//
//  PURPOSE:    If a drag opteration is currently in progress (as determined
//              by the g_fDragging variable) then this function handles 
//              ending the drag and updating the split position.
//
//  PARAMETERS:
//      hwnd     - handle of the window receiving the message
//      x        - horizontal mouse position in client coordinates
//      y        - vertical mouse position in client coordinates
//      keyFlags - Indicates whether various virtual keys are down
//
void CMessageView::OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    DWORD       dwHeader;
    DWORD       dwSize;
    BOOL        fVisible;
    DWORD       dwOpt;
    FOLDERTYPE  ftType;

    if (m_fDragging)
    {
        ReleaseCapture();
        m_fDragging = FALSE;

        // Get the old settings
        m_pBrowser->GetFolderType(&ftType);
        if (ftType == FOLDER_NEWS)
            dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
        else
            dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

        m_pBrowser->GetViewLayout(dwOpt, 0, &fVisible, &dwHeader, &dwSize);

        // Update the new splits
        if (m_fSplitHorz)
            dwSize = MAKELONG(m_dwSplitHorzPct, 0);
        else
            dwSize = MAKELONG(0, m_dwSplitVertPct);

        // Set the settings back to the browser
        m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, fVisible, dwHeader, dwSize);
    }
}


//
//  FUNCTION:   CMessageView::OnMenuSelect()
//
//  PURPOSE:    Put's helpful text on the status bar describing the selected
//              menu item.
//
void CMessageView::OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // Let the preview pane have it first
    if (m_pPreview)
    {
        if (S_OK == m_pPreview->HrWMMenuSelect(hwnd, wParam, lParam))
            return;
    }

    // Handle it ourselves
    CStatusBar *pStatusBar = NULL;
    m_pBrowser->GetStatusBar(&pStatusBar);
    HandleMenuSelect(pStatusBar, wParam, lParam);
    pStatusBar->Release();
}


//
//  FUNCTION:   CMessageView::OnNotify
//
//  PURPOSE:    Processes the various notifications we receive from our child
//              controls.
//
//  PARAMETERS:
//      hwnd    - Handle of the view window.
//      idCtl   - identifies the control sending the notification
//      pnmh    - points to a NMHDR struct with more information regarding the
//                notification
//
//  RETURN VALUE:
//      Dependant on the specific notification.
//
LRESULT CMessageView::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    switch (pnmhdr->code)
    {
        case BDN_HEADERDBLCLK:
        {
            if (m_pPreview)
            {
                DWORD dw = 0;
                BOOL  f = 0;
                FOLDERTYPE ftType;
                DWORD dwOpt;

                m_pBrowser->GetFolderType(&ftType);
                if (ftType == FOLDER_NEWS)
                    dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
                else
                    dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

                m_pBrowser->GetViewLayout(dwOpt, 0, &f, &dw, 0);
                m_pPreview->HrSetStyle(!dw ? MESTYLE_PREVIEW : MESTYLE_MINIHEADER);
                m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, f, !dw, 0);
            }
            break;
        }
        case BDN_MARKASSECURE:
        {
            if (m_pMsgList)
            {
                DWORD dwRow = 0;
                if (SUCCEEDED(m_pMsgList->GetSelected(&dwRow, NULL, NULL)))
                    m_pMsgList->MarkMessage(dwRow, MARK_MESSAGE_NOSECUI);
            }
            break;
        }
    }

    return (0);
}


void CMessageView::OnDestroy(HWND hwnd)
{
    if (m_pDropTarget)
    {
        RevokeDragDrop(hwnd);
        m_pDropTarget->Release();
        m_pDropTarget = 0;
    }

    // Stop advising for option changes
    OptionUnadvise(m_hwnd);

    // Release the preview pane
    if (m_pPreview)
    {
        m_pPreview->HrUnloadAll(NULL, 0);
        m_pPreview->HrClose();
    }
}


void CMessageView::OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    IOleWindow *pWindow = 0;
    HWND        hwndList = 0;

    if (m_pMsgList)
    {
        if (SUCCEEDED(m_pMsgList->QueryInterface(IID_IOleWindow, (LPVOID *) &pWindow)))
        {
            if (SUCCEEDED(pWindow->GetWindow(&hwndList)))
            {
                SetFocus(hwndList);
            }
            pWindow->Release();
        }
    }
}


//
//  FUNCTION:   CMessageView::OnTestGetMsgId()
//
//  PURPOSE:    This function is for the testing team.  Please consult Racheli
//              before modifying it in any way.
//
LRESULT CMessageView::OnTestGetMsgId(HWND hwnd)
{
    DWORD       cSel;
    DWORD      *rgSelected = NULL;
    LRESULT     lResult = -1;
    LPMESSAGEINFO pInfo;

    TraceCall("CMessageView::OnTestGetMsgId");

    // Only handle this if we're in test mode
    if (!DwGetOption(OPT_TEST_MODE))
        return (-1);

    // Get the range of selected messages
    if (SUCCEEDED(m_pMsgList && m_pMsgList->GetSelected(NULL, &cSel, &rgSelected)))
    {
        // Get the message info for the selected row
        if (cSel && SUCCEEDED(m_pMsgList->GetMessageInfo(*rgSelected, &pInfo)))
        {
            lResult = (LRESULT) pInfo->idMessage;
            m_pMsgList->FreeMessageInfo(pInfo);
        }

        MemFree(&rgSelected);
    }

    return (lResult);
}


//
//  FUNCTION:   CMessageView::OnTestSaveMessage()
//
//  PURPOSE:    This method is for the testing team.  Please consult Racheli
//              before making any changes.
//
LRESULT CMessageView::OnTestSaveMessage(HWND hwnd)
{
    DWORD         cSel;
    DWORD        *rgSelected = NULL;
    TCHAR         szFile[MAX_PATH];
    IUnknown     *pUnkMessage;
    IMimeMessage *pMessage = NULL;
    LRESULT       lResult = -1;

    TraceCall("CMessageView::OnTestSaveMessage");

    // Make sure we only do this in test mode
    if (!DwGetOption(OPT_TEST_MODE))
        return (-1);

    // Get the dump file name
    if (!GetOption(OPT_DUMP_FILE, szFile, ARRAYSIZE(szFile)))
        return (-1);

    // Get the selected range
    if (SUCCEEDED(m_pMsgList->GetSelected(NULL, &cSel, &rgSelected)))
    {
        // Load the first selected message from the store
        if (cSel && SUCCEEDED(m_pMsgList->GetMessage(*rgSelected, FALSE, FALSE, &pUnkMessage)))
        {
            // Get the IMimeMessage interface from the message
            if (pUnkMessage && SUCCEEDED(pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage)))
            {
                // Save the message 
                HrSaveMsgToFile(pMessage, (LPTSTR) szFile);
                pMessage->Release();
                lResult = 0;
            }

            pUnkMessage->Release();
        }

        MemFree(rgSelected);
    }

    return (lResult);
}


//
//  FUNCTION:   CMessageView::CmdOpen()
//
//  PURPOSE:    Opens the selected messages.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr;

    TraceCall("CMessageView::CmdOpen");

    // If more than 10 messages are selected, warn the user with a "Don't show
    // me again" dialog that this could be bad.
    DWORD dwSel = 0;
    
    m_pMsgList->GetSelectedCount(&dwSel);
    if (dwSel > 10)
    {
        TCHAR szBuffer[CCHMAX_STRINGRES];
        LRESULT lResult;

        AthLoadString(idsErrOpenManyMessages, szBuffer, ARRAYSIZE(szBuffer));
        lResult = DoDontShowMeAgainDlg(m_hwnd, c_szRegManyMsgWarning, 
                                       MAKEINTRESOURCE(idsAthena), szBuffer, 
                                       MB_OKCANCEL);
        if (IDCANCEL == lResult)
            return (S_OK);
    }

    // Get the array of selected rows from the message list
    DWORD *rgRows = NULL;
    DWORD cRows = 0;

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    LPMESSAGEINFO  pInfo;
    IMessageTable *pTable = NULL;

    hr = m_pMsgList->GetMessageTable(&pTable);
    if (SUCCEEDED(hr))
    {
        for (DWORD i = 0; (i < cRows && m_pMsgList != NULL); i++)
        {
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[i], &pInfo)))
            {
                INIT_MSGSITE_STRUCT initStruct;
                DWORD dwCreateFlags;
                initStruct.initTable.pListSelect = NULL;
                m_pMsgList->GetListSelector(&initStruct.initTable.pListSelect);
                
                // Initialize note struct
                initStruct.dwInitType = OEMSIT_MSG_TABLE;
                initStruct.initTable.pMsgTable = pTable;
                initStruct.folderID = m_idFolder;
                initStruct.initTable.rowIndex = rgRows[i];

                // Decide whether it is news or mail
                if (pInfo->dwFlags & ARF_NEWSMSG)
                    dwCreateFlags = OENCF_NEWSFIRST;
                else
                    dwCreateFlags = 0;

                m_pMsgList->FreeMessageInfo(pInfo);

                // Create and Open Note
                hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct, m_hwnd);
                ReleaseObj(initStruct.initTable.pListSelect);

                if (FAILED(hr))
                    break;
            }
        }
        pTable->Release();
    }

    if (SUCCEEDED(hr) && g_pInstance)
    {
        FOLDERTYPE ft = GetFolderType(m_idFolder);
        if (ft == FOLDER_IMAP || ft == FOLDER_LOCAL || ft == FOLDER_HTTPMAIL)
            g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
    }

    SafeMemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CmdReply()
//
//  PURPOSE:    Replies or Reply-All's to the selected message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;
    OLECMD          cmd;
    IMessageTable  *pTable = NULL;
    PROPVARIANT     var;

    // We can hit this via accelerators.  Since accelerators don't go through 
    // QueryStatus(), we need to make sure this should really be enabled.
    cmd.cmdID = nCmdID;
    cmd.cmdf = 0;
    if (FAILED(QueryStatus(NULL, 1, &cmd, NULL)) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
        return (S_OK);

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            INIT_MSGSITE_STRUCT rInitSite;
            DWORD               dwCreateFlags;
            DWORD               dwAction = 0;

            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            if ((1 < cRows) && ((ID_FORWARD == nCmdID) || (ID_FORWARD_AS_ATTACH == nCmdID)))
            {
                IMimeMessage   *pMsgFwd = NULL;
                BOOL            fErrorsOccured = FALSE,
                                fCreateNote = TRUE;

                hr = HrCreateMessage(&pMsgFwd);
                if (FAILED(hr))
                    goto exit;

                // Raid 80277; Set default charset
                if (NULL == g_hDefaultCharsetForMail) 
                    ReadSendMailDefaultCharset();

                pMsgFwd->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
                
                rInitSite.dwInitType = OEMSIT_MSG;
                rInitSite.pMsg = pMsgFwd;
                rInitSite.folderID = m_idFolder;

                dwCreateFlags = 0;
                dwAction = OENA_COMPOSE;

                for (DWORD i = 0; i < cRows; i++)
                {
                    DWORD           iRow = rgRows[i];
                    IMimeMessage   *pMsg = NULL;

                    // Since this command is 
                    hr = pTable->OpenMessage(iRow, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK);
                    if (SUCCEEDED(hr))
                    {
                        // If this is the first message, get the account ID from it
                        if (i == 0)
                        {
                            var.vt = VT_LPSTR;
                            if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
                            {
                                pMsgFwd->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
                            }
                        }

                        if (FAILED(pMsgFwd->AttachObject(IID_IMimeMessage, (LPVOID)pMsg, NULL)))
                            fErrorsOccured = TRUE;
                        pMsg->Release();
                    }
                    else
                        fErrorsOccured = TRUE;
                }

                if (fErrorsOccured)
                {
                    if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                            MAKEINTRESOURCEW(idsErrorAttachingMsgsToNote), NULL, MB_OKCANCEL) == IDCANCEL)
                        fCreateNote = FALSE;
                }

                if (fCreateNote)
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd);                
                pMsgFwd->Release();
            }
            else
            {
                LPMESSAGEINFO   pInfo;

                // Get some information about the message
                if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
                {
                    // Determine if this is a news or mail message.
                    if (pInfo->dwFlags & ARF_NEWSMSG)
                        dwCreateFlags = OENCF_NEWSFIRST;
                    else
                        dwCreateFlags = 0;

                    // Reply or forward
                    if (nCmdID == ID_FORWARD)
                        dwAction = OENA_FORWARD;
                    else if (nCmdID == ID_FORWARD_AS_ATTACH)
                        dwAction = OENA_FORWARDBYATTACH;
                    else if (nCmdID == ID_REPLY)
                        dwAction = OENA_REPLYTOAUTHOR;
                    else if (nCmdID == ID_REPLY_ALL)
                        dwAction = OENA_REPLYALL;
                    else if (nCmdID == ID_REPLY_GROUP)
                        dwAction = OENA_REPLYTONEWSGROUP;
                    else
                        AssertSz(FALSE, "Didn't ask for a valid action");

                    // Fill out the initialization information
                    rInitSite.dwInitType = OEMSIT_MSG_TABLE;
                    rInitSite.initTable.pMsgTable = pTable;
                    rInitSite.initTable.pListSelect = NULL;
                    rInitSite.folderID  = m_idFolder;
                    rInitSite.initTable.rowIndex  = dwFocused;

                    m_pMsgList->FreeMessageInfo(pInfo);

                    // Create the note object
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd);
                }
            }
        }
    }

exit:
    ReleaseObj(pTable);
    SafeMemFree(rgRows);
    return (S_OK);
}

HRESULT CMessageView::CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            IMessageTable  *pTable = NULL;
            LPMESSAGEINFO   pInfo;
            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            // Get some information about the message
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
            {
                hr = NewsUtil_HrCancelPost(m_hwnd, m_idFolder, pInfo);

                m_pMsgList->FreeMessageInfo(pInfo);
            }
            pTable->Release();
        }
    }

exit:
    SafeMemFree(rgRows);
    return (S_OK);
}

//
//  FUNCTION:   CMessageView::CmdFillPreview()
//
//  PURPOSE:    Fills the preview pane with the selected & focused message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdFillPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    AssertSz(FALSE, "NYI");
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CMessageView::CmdShowPreview()
//
//  PURPOSE:    Handles updating the settings dealing with the preview pane.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdShowPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    FOLDERTYPE  ftType;
    DWORD       dwOpt;
    LAYOUTPOS   pos;
    BOOL        fVisible;
    DWORD       dwFlags;

    // Get the folder type
    m_pBrowser->GetFolderType(&ftType);
    if (ftType == FOLDER_NEWS)
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
    else
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

    // Get the current settings from the browser
    m_pBrowser->GetViewLayout(dwOpt, NULL, &fVisible, &dwFlags, NULL);

    // Update the settings just based on the command
    switch (nCmdID)
    {
        case ID_PREVIEW_PANE:
        case ID_PREVIEW_SHOW:
        {
            // Set the complement of the visible bit
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, !fVisible, dwFlags, NULL);
            if (!fVisible)
            {
                // if showing update the preview pane
                _UpdatePreviewPane();
            }
            else
            {
                // if hiding, clear the contents
                m_pPreview->HrUnloadAll(NULL, 0);
            }

            break;
        }

        case ID_PREVIEW_BELOW:
        {
            // Update the position
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_BOTTOM, fVisible, dwFlags, NULL);
            break;
        }

        case ID_PREVIEW_BESIDE:
        {
            // Update the position
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_LEFT, fVisible, dwFlags, NULL);
            break;
        }

        case ID_PREVIEW_HEADER:
        {
            // Toggle the header flags
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, fVisible, !dwFlags, NULL);
            break;
        }

        default:
            Assert(FALSE);
    }

    return (S_OK);
}



//
//  FUNCTION:   CMessageView::CmdRefresh()
//
//  PURPOSE:    Refreshes the contents of the message list.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr = E_FAIL;
    FOLDERINFO  FolderInfo;

    TraceCall("CMessageView::CmdRefresh");

    // Call into the message list now and let it refresh
    if (m_pMsgListCT)
        hr = m_pMsgListCT->Exec(NULL, ID_REFRESH_INNER, nCmdExecOpt, pvaIn, pvaOut);

    // If we succeeded in refreshing the message list, also try to reload the 
    // preview pane.
    _UpdatePreviewPane();

    // If this is a local folder and this isn't newsonly mode, in the past we 
    // do a Send & Recieve.
    if (FOLDER_LOCAL == GetFolderType(m_idFolder) && 0 == (g_dwAthenaMode & MODE_NEWSONLY))
        PostMessage(m_hwndParent, WM_COMMAND, ID_SEND_RECEIVE, 0);

    return (hr);
}


//
//  FUNCTION:   CMessageView::CmdBlockSender()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr = S_OK;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;
    LPSTR           pszEmailFrom = NULL;
    ADDRESSPROPS    rSender = {0};
    CHAR            szRes[CCHMAX_STRINGRES];
    LPSTR           pszResult = NULL;
    IOERule *       pIRule = NULL;
    BOOL            fMsgInfoFreed = FALSE;

    TraceCall("CMessageView::CmdBlockSender");

    hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows);
    if (FAILED(hr))
    {
        goto exit;
    }

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we already have the address?
    if ((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0]))
    {
        pszEmailFrom = PszDupA(pInfo->pszEmailFrom);
        if (NULL == pszEmailFrom)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

    }
    else
    {
        // Load that message from the store
        hr = m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        if (NULL == pUnkMessage)
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Get the IMimeMessage interface from the message
        hr = pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage);
        if (FAILED(hr))
        {
            goto exit;
        }

        rSender.dwProps = IAP_EMAIL;
        hr = pMessage->GetSender(&rSender);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));
        if ((NULL == rSender.pszEmail) || ('\0' == rSender.pszEmail[0]))
        {
            hr = E_FAIL;
            goto exit;
        }

        pszEmailFrom = PszDupA(rSender.pszEmail);
        if (NULL == pszEmailFrom)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // We don't need the message anymore
        g_pMoleAlloc->FreeAddressProps(&rSender);
        ZeroMemory(&rSender, sizeof(rSender));
        SafeRelease(pMessage);
    }

    // Free up the info
    m_pMsgList->FreeMessageInfo(pInfo);
    fMsgInfoFreed = TRUE;

    // Bring up the rule editor for this message
    hr = RuleUtil_HrAddBlockSender((0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, pszEmailFrom);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Load the template string
    AthLoadString(idsSenderAddedPrompt, szRes, sizeof(szRes));

    // Allocate the space to hold the final string
    DWORD cchSize = (lstrlen(szRes) + lstrlen(pszEmailFrom) + 1);
    hr = HrAlloc((VOID **) &pszResult, sizeof(*pszResult) * cchSize);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the warning string
    wnsprintf(pszResult, cchSize, szRes, pszEmailFrom);

    // Show the success dialog
    if (IDYES == AthMessageBox(m_hwnd, MAKEINTRESOURCE(idsAthena), pszResult, NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        // Create a block sender rule
        hr = HrBlockSendersFromFolder(m_hwnd, 0, m_idFolder, &pszEmailFrom, 1);
        if (FAILED(hr))
        {
            goto exit;
        }        
    }

    hr = S_OK;

exit:
    SafeRelease(pIRule);
    SafeMemFree(pszResult);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    SafeRelease(pMessage);
    SafeRelease(pUnkMessage);
    SafeMemFree(pszEmailFrom);
    if (FALSE == fMsgInfoFreed)
    {
        m_pMsgList->FreeMessageInfo(pInfo);
    }
    SafeMemFree(rgRows);
    if (FAILED(hr))
    {
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSenderError), NULL, MB_OK | MB_ICONERROR);
    }
    return (hr);
}


//
//  FUNCTION:   CMessageView::CmdCreateRule()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;

    TraceCall("CMessageView::CmdCreateRule");

    // Get the array of selected rows from the message list

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo)))
    {
        // Load that message from the store
        if (S_OK == m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage))
        {
            // Get the IMimeMessage interface from the message
            if (NULL != pUnkMessage)
            {
                pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage);
            }
        }
        
        // Bring up the rule editor for this message
        hr = HrCreateRuleFromMessage(m_hwnd, (0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? 
                    CRFMF_NEWS : CRFMF_MAIL, pInfo, pMessage);
    }

    SafeRelease(pMessage);
    SafeRelease(pUnkMessage);
    m_pMsgList->FreeMessageInfo(pInfo);
    SafeMemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CmdAddToWab()
//
//  PURPOSE:    Add the sender of the selected messages to the WAB
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdAddToWab(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr = S_OK;
    DWORD      *rgRows = NULL;
    DWORD       cRows = 0;
    LPMESSAGEINFO pInfo;
    LPWAB       pWAB = 0;

    TraceCall("CMessageView::CmdAddToWab");

    // Get the array of selected rows from the message list
    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // Get the header info for the message
    if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo)))
    {
        // Get a WAB object
        if (SUCCEEDED(hr = HrCreateWabObject(&pWAB)))
        {
            // Add the sender to the WAB
            if (FAILED(hr = pWAB->HrAddNewEntryA(pInfo->pszDisplayFrom, pInfo->pszEmailFrom)))
            {
                if (hr == MAPI_E_COLLISION)
                    AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrAddrDupe), 0, MB_OK | MB_ICONSTOP);
                else
                    AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrAddToWabSender), 0, MB_OK | MB_ICONSTOP);
            }

            pWAB->Release();
        }
        
        m_pMsgList->FreeMessageInfo(pInfo);
    }

    SafeMemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CmdCombineAndDecode()
//
//  PURPOSE:    Combines the selected messages into a single message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    DWORD             *rgRows = NULL;
    DWORD              cRows = 0;
    CCombineAndDecode *pDecode = NULL;
    HRESULT            hr;

    // Create the decoder object
    pDecode = new CCombineAndDecode();
    if (!pDecode)
        return (S_OK);

    // Get the array of selected rows from the message list
    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // Get a pointer to the message table
    IMessageTable *pTable = NULL;
    if (SUCCEEDED(m_pMsgList->GetMessageTable(&pTable)))
    {
        // Initialize the decoder
        pDecode->Start(m_hwnd, pTable, rgRows, cRows, m_idFolder);
    }

    SafeMemFree(rgRows);
    pDecode->Release();
    pTable->Release();

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::_SetListOptions()
//
//  PURPOSE:    Maps the folder that we're about to view to the correct column
//              set and various options.
//
//  RETURN VALUE:
//      Returns S_OK if the column set was identified and set correctly.  Returns
//      a standard error HRESULT otherwise.
//
HRESULT CMessageView::_SetListOptions(void)
{
    HRESULT     hr;
    BOOL        fSelectFirst = FALSE;
    FOLDERTYPE  ft = GetFolderType(m_idFolder);

    // Make sure this badboy exists
    if (!m_pMsgList)
        return (E_UNEXPECTED);

    FOLDER_OPTIONS fo     = {0};
    fo.cbSize             = sizeof(FOLDER_OPTIONS);
    fo.dwMask             = FOM_EXPANDTHREADS | FOM_SELECTFIRSTUNREAD | FOM_THREAD | FOM_MESSAGELISTTIPS | FOM_POLLTIME | FOM_COLORWATCHED | FOM_GETXHEADERS | FOM_SHOWDELETED | FOM_SHOWREPLIES;
    fo.fExpandThreads     = DwGetOption(OPT_AUTOEXPAND);
    fo.fMessageListTips   = DwGetOption(OPT_MESSAGE_LIST_TIPS);
    fo.dwPollTime         = DwGetOption(OPT_POLLFORMSGS);
    fo.clrWatched         = DwGetOption(OPT_WATCHED_COLOR);
    fo.dwGetXHeaders      = DwGetOption(OPT_DOWNLOADCHUNKS);
    fo.fDeleted           = DwGetOption(OPT_SHOW_DELETED);
    fo.fReplies           = DwGetOption(OPT_SHOW_REPLIES);

    switch (ft)
    {
        case FOLDER_NEWS:
            fo.fThread = DwGetOption(OPT_NEWS_THREAD);
            fo.fSelectFirstUnread = TRUE;
            break;

        case FOLDER_LOCAL:
        case FOLDER_HTTPMAIL:
            fo.fThread = DwGetOption(OPT_MAIL_THREAD);
            fo.fSelectFirstUnread = FALSE;
            break;

        case FOLDER_IMAP:
            fo.fThread = DwGetOption(OPT_MAIL_THREAD);
            fo.fSelectFirstUnread = FALSE;
            break;
    }

    hr = m_pMsgList->SetViewOptions(&fo);
    return (hr);
}


BOOL CMessageView::_IsPreview(void)
{
    FOLDERTYPE  ftType;
    DWORD       dwOpt;

    // Get the folder type
    m_pBrowser->GetFolderType(&ftType);
    if (ftType == FOLDER_NEWS)
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
    else
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

    // Ask the browser if it should be on or off
    BOOL f = FALSE;
    if (m_pBrowser)
        m_pBrowser->GetViewLayout(dwOpt, 0, &f, 0, 0);

    return f;
}


BOOL CMessageView::_InitMessageList(void)
{
    HWND hwndList;

    // Create the message list object
    if (FAILED(CreateMessageList(NULL, &m_pMsgList)))
        return (FALSE);

    // Initialize the message list
    m_pMsgList->CreateList(m_hwnd, (IViewWindow *) this, &hwndList);

    // Get the command target interface for the list
    m_pMsgList->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pMsgListCT);
    m_pMsgList->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *) &m_pMsgListAO);

    // Request Notifications 
    AtlAdvise(m_pMsgList, (IUnknown *)(IViewWindow *) this, DIID__MessageListEvents, &m_dwCookie);

    // Set the column set for the message list
    _SetListOptions();

    return (TRUE);
}



//
//  FUNCTION:   CMessageView::_InitPreviewPane()
//
//  PURPOSE:    Creates the Preview Pane object and initializes it.
//
//  RETURN VALUE:
//      TRUE if the object was created and initialized, FALSE otherwise.
//
BOOL CMessageView::_InitPreviewPane(void)
{
    CMimeEditDocHost   *pDocHost = NULL;
    CStatusBar         *pStatusBar = NULL;
    DWORD               dwHeader;
    LAYOUTPOS           pos;
    BOOL                fVisible;
    DWORD               dwOpt;
    HRESULT             hr;
    FOLDERTYPE          ftType;
    DWORD               dwSize;

    TraceCall("CMessageView::_InitPreviewPane");

    // We only create the preview pane if it's supposed to be visible.
    m_pBrowser->GetFolderType(&ftType);
    if (ftType == FOLDER_NEWS)
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
    else
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

    // Get the settings from the browser
    m_pBrowser->GetViewLayout(dwOpt, &pos, &fVisible, &dwHeader, &dwSize);

    // Stash this info
    m_dwSplitHorzPct = LOWORD(dwSize);
    m_dwSplitVertPct = HIWORD(dwSize);

    if (fVisible)
    {
        // Create the dochost
        pDocHost = new CMimeEditDocHost(MEBF_OUTERCLIENTEDGE);
        if (!pDocHost)
            goto error;
    
        // We want to get the IBodyObj2 interface from it.
        pDocHost->QueryInterface(IID_IBodyObj2, (LPVOID *) &m_pPreview);
        if (!m_pPreview)
            goto error;
        pDocHost->Release();

        // Also get the IOleCommandTarget interface from it.  If it fails, that's OK.
        m_pPreview->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pPreviewCT);

        if (m_pBrowser->GetStatusBar(&pStatusBar)==S_OK)
        {
            m_pPreview->HrSetStatusBar(pStatusBar);
            pStatusBar->Release();
        }

        // Create the preview window
        if (FAILED(m_pPreview->HrInit(m_hwnd, IBOF_DISPLAYTO|IBOF_TABLINKS, (IBodyOptions *) this)))
            goto error;

        hr = m_pPreview->HrShow(fVisible);
        if (FAILED(hr))
            goto error;

        m_pPreview->HrSetText(MAKEINTRESOURCE(idsHTMLEmptyPreviewSel));    
    
        UpdateLayout(fVisible, dwHeader, pos == LAYOUT_POS_LEFT, FALSE);

        // Give the preview pane our event sink interface
        m_pPreview->SetEventSink((IMimeEditEventSink *) this);
                
        return (TRUE);
    }

error:
    SafeRelease(pDocHost);
    SafeRelease(m_pPreview);

    return (FALSE);
}


void CMessageView::_UpdatePreviewPane(BOOL fForceDownload)
{
    DWORD     dwFocused;
    DWORD     cSelected;
    DWORD    *rgSelected = 0;
    IUnknown *pUnkMessage = 0;
    HRESULT   hr;


    if (m_pMsgList && m_pPreview)
    {
        m_idMessageFocus = MESSAGEID_INVALID;
        m_fNotDownloaded = FALSE;

        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cSelected, &rgSelected)))
        {
            // If there is a focused item 
            if (-1 == dwFocused || 0 == cSelected)
            {
                m_pPreview->HrUnloadAll(idsHTMLEmptyPreviewSel, 0);
            }
            else
            {
                // Load that message from the store
                hr = m_pMsgList->GetMessage(dwFocused, fForceDownload || DwGetOption(OPT_AUTOFILLPREVIEW), TRUE, &pUnkMessage);
                
                switch (hr)
                {
                    case MIME_E_SECURITY_CANTDECRYPT:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeEncrypt);
                        break;

#ifdef SMIME_V3
                    case MIME_E_SECURITY_LABELACCESSDENIED:
                    case MIME_E_SECURITY_LABELACCESSCANCELLED:
                    case MIME_E_SECURITY_LABELCORRUPT:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeLabel);
                        break;
#endif // SMIME_V3
                    case STORE_E_EXPIRED:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_Expired);
                        break;
                    
                    case STORE_E_NOBODY:
                        AssertSz(DwGetOption(OPT_AUTOFILLPREVIEW)==FALSE, "AutoPreview is on, download should have been started!");
                        if (g_pConMan->IsGlobalOffline())
                            m_pPreview->LoadHtmlErrorPage(c_szErrPage_Offline);
                        else
                            m_pPreview->LoadHtmlErrorPage(c_szErrPage_NotDownloaded);
                        m_fNotDownloaded = TRUE;
                        break;
                    
                    case DB_E_DISKFULL:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_DiskFull);
                        break;

                    case DB_S_NOTFOUND:
                    {
                        FOLDERINFO      FolderInfo;

                        //I don't think we need this coz its being handled in callbackcanconnect

                        //If the message is not found in the store, we ask it to download.
                        if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
                        {
                            if(g_pConMan && !(g_pConMan->IsGlobalOffline()))
                            {
                                CHAR szAccountId[CCHMAX_ACCOUNT_NAME];

                                if (SUCCEEDED(GetFolderAccountId(&FolderInfo, szAccountId, ARRAYSIZE(szAccountId))))
                                {
                                    if (g_pConMan->Connect(szAccountId, m_hwnd, TRUE)== S_OK)
                                        hr = m_pMsgList->GetMessage(dwFocused, TRUE, TRUE, &pUnkMessage);            
                                }
                            }
                            g_pStore->FreeRecord(&FolderInfo);
                        }
                        break;
                    }


                    case STORE_S_ALREADYPENDING:
                    case E_PENDING:
                    {
                        // if the message is being downloaded, let's store the message-id and wait for an update    
                        LPMESSAGEINFO pInfo;

                        // clear the contents waiting for the new message to download
                        m_pPreview->HrUnloadAll(NULL, 0);

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
                        {
                            m_idMessageFocus = pInfo->idMessage;
                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                        break;
                    }

                    case E_NOT_ONLINE:
                    {
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_Offline);
                        break;
                    }

                    case S_OK:
                    {
                        // Get the IMimeMessage interface from the message
                        IMimeMessage *pMessage = 0;

                        if (pUnkMessage && SUCCEEDED(pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage)))
                        {
                            // bobn, brianv says we have to remove this...
                            /*if (g_dwBrowserFlags == 1)
                            {
                                LPSTR lpsz = NULL;
                                if (SUCCEEDED(MimeOleGetBodyPropA(pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpsz)))
                                {
                                    if (0 == strcmp(lpsz, "Credits"))
                                        g_dwBrowserFlags |= 2;
                                    else
                                        g_dwBrowserFlags = 0;

                                    SafeMimeOleFree(lpsz);
                                }
                            }*/

                            if (_DoEmailBombCheck(pMessage)==S_OK)
                            {
                                // Get the load interface from the preview pane object
                                IPersistMime *pPersistMime = 0;

                                if (SUCCEEDED(m_pPreview->QueryInterface(IID_IPersistMime, (LPVOID *) &pPersistMime)))
                                {
                                    DWORD               dwHeader;
                                    LAYOUTPOS           pos;
                                    BOOL                fVisible;
                                    DWORD               dwOpt;
                                    DWORD               dwSize;
                                    FOLDERTYPE          ftType;

                                    CStatusBar         *pStatusBar = NULL;

                                    // remember focus
                                    BOOL fFocused = ((m_pPreview->HrHasFocus() == S_OK) ? TRUE : FALSE);

                                    m_pBrowser->GetFolderType(&ftType);
                                    if (ftType == FOLDER_NEWS)
                                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
                                    else
                                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

                                    // Get the settings from the browser
                                    m_pBrowser->GetViewLayout(dwOpt, &pos, &fVisible, &dwHeader, &dwSize);
                                    m_pPreview->HrResetDocument();
                                    m_pPreview->HrSetStyle(dwHeader ? MESTYLE_PREVIEW : MESTYLE_MINIHEADER);
                                    // Give the preview pane our event sink interface
                                    m_pPreview->SetEventSink((IMimeEditEventSink *) this);
                                    pPersistMime->Load(pMessage);
                                    pPersistMime->Release();

                                    // restore status bar
                                    if (m_pBrowser->GetStatusBar(&pStatusBar)==S_OK)
                                    {
                                        m_pPreview->HrSetStatusBar(pStatusBar);
                                        pStatusBar->Release();
                                    }

                                    // return focus
                                    if(fFocused)
                                        m_pPreview->HrSetUIActivate();
                                }
                            }
                            pMessage->Release();
                        }
                        pUnkMessage->Release();
                        break;
                    }
                    default:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_GenFailure);
                        break;
                }
            }

            if (rgSelected)
                MemFree(rgSelected);
        }
    }
}


//
//  FUNCTION:   CMessageView::_SetProgressStatusText()
//
//  PURPOSE:    Takes the provided BSTR, converts it to ANSI, and smacks it
//              on the status bar.
//
//  PARAMETERS: 
//      [in] bstr - henious BSTR to put on the status bar.
//
void CMessageView::_SetProgressStatusText(BSTR bstr)
{
    LPTSTR      psz = NULL;
    CStatusBar *pStatusBar = NULL;
    m_pBrowser->GetStatusBar(&pStatusBar);

    
    if (pStatusBar)
    {   
        pStatusBar->SetStatusText((LPTSTR) bstr);
    /*
        CComBSTR cString(bstr);

        // Allocate a string large enough
        if (MemAlloc((LPVOID *) &psz, 2 * cString.Length()))
        {
            WideCharToMultiByte(CP_ACP, 0, cString, -1,
                                psz, 2 * cString.Length(), NULL, NULL);
            pStatusBar->SetStatusText((LPTSTR) psz);
            MemFree(psz);
        }
    */
        pStatusBar->Release();
    }
}

//
//  FUNCTION:   CMessageView::_OnMessageAvailable()
//
//  PURPOSE:    Fired by the listview when a message has completed downloading
//              if the message is the currently selected message in the preview
//              then we update it. If it is not, we ignore the notification.
//              We check for downloading errors and display and appropriate message
//
//  PARAMETERS: 
//      [in] idMessage      - message id of the message that was downloaded
//      [in] hrCompletion   - hresult indicating possible error failure
//
HRESULT CMessageView::_OnMessageAvailable(MESSAGEID idMessage, HRESULT hrCompletion)
{
    if (m_idMessageFocus != idMessage)
        return S_FALSE;

    switch (hrCompletion)
    {
        // if we get a STORE_E_EXPIRED, then reload the preview pane to show error
        case S_OK:
        case STORE_E_EXPIRED:
            // we post a message to ourselves to update the preview pane. We do this because
            // any refcounts on the IStream into the store at this point have it locked for write
            // if we post, then the stack is unwound after the notifications are fired and we're in a
            // good state.
            PostMessage(m_hwnd, WM_UPDATE_PREVIEW, (WPARAM)idMessage, 0);
            break;

        case S_FALSE:
        case STORE_E_OPERATION_CANCELED:
        case hrUserCancel:
        case IXP_E_USER_CANCEL:
            // S_FALSE means the operation was canceled
            if (m_idMessageFocus != MESSAGEID_INVALID)
                m_pPreview->LoadHtmlErrorPage(c_szErrPage_DownloadCanceled);
            break;

        case STG_E_MEDIUMFULL:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_DiskFull);
            break;

        case HR_E_USER_CANCEL_CONNECT:
        case HR_E_OFFLINE:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_Offline);
            break;

        case MIME_E_SECURITY_CANTDECRYPT:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeEncrypt);
            break;

#ifdef SMIME_V3
        case MIME_E_SECURITY_LABELACCESSDENIED:
        case MIME_E_SECURITY_LABELACCESSCANCELLED:
        case MIME_E_SECURITY_LABELCORRUPT:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeLabel);
            break;
#endif // SMIME_V3

        default:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_GenFailure);
            break;
    }
    return S_OK;
}


//
//  FUNCTION:   CMessageView::_DoEmailBombCheck
//
//  PURPOSE:    Validates to ensure that the last time we closed OE we shutdown
//              correctly. If we did not shutdown correctly, we look at the msgid stamp 
//              that we stored in the registry for the last selected preview message
//              if it was the message we are about to preview, we do not show the
//              message, to prevent jscript attacks etc.
//
//  PARAMETERS: 
//              none
//
HRESULT CMessageView::_DoEmailBombCheck(LPMIMEMESSAGE pMsg)
{
    FILETIME    ft;
    PROPVARIANT va;
    DWORD       dwType,
                cb;

    va.vt = VT_FILETIME;
    if (pMsg && pMsg->GetProp(PIDTOSTR(STR_HDR_DATE), 0, &va)==S_OK)
    {
        if (g_fBadShutdown)
        {
            g_fBadShutdown=FALSE;
            
            cb = sizeof(FILETIME);
            
            if (AthUserGetValue(NULL, c_szLastMsg, &dwType, (LPBYTE)&ft, &cb)==S_OK &&
                (ft.dwLowDateTime == va.filetime.dwLowDateTime && 
                ft.dwHighDateTime == va.filetime.dwHighDateTime))
            {
                // possible the same dude
                m_pPreview->LoadHtmlErrorPage(c_szErrPage_MailBomb);
                return S_FALSE;
            }
        }
        AthUserSetValue(NULL, c_szLastMsg, REG_BINARY, (LPBYTE)&va.filetime, sizeof(FILETIME));
    }
    
    return S_OK;
}


void CMessageView::_OptionUpdate(DWORD dwUpdate)
{
    if (m_pMsgList &&
        (dwUpdate == OPT_AUTOEXPAND || 
         dwUpdate == OPT_MESSAGE_LIST_TIPS || 
         dwUpdate == OPT_POLLFORMSGS || 
         dwUpdate == OPT_WATCHED_COLOR ||
         dwUpdate == OPT_DOWNLOADCHUNKS))
    {
        FOLDER_OPTIONS fo     = {0};
        
        fo.cbSize             = sizeof(FOLDER_OPTIONS);
        fo.dwMask             = FOM_EXPANDTHREADS | FOM_MESSAGELISTTIPS | FOM_POLLTIME | FOM_COLORWATCHED | FOM_GETXHEADERS;
        fo.fExpandThreads     = DwGetOption(OPT_AUTOEXPAND);
        fo.fMessageListTips   = DwGetOption(OPT_MESSAGE_LIST_TIPS);
        fo.dwPollTime         = DwGetOption(OPT_POLLFORMSGS);
        fo.clrWatched         = DwGetOption(OPT_WATCHED_COLOR);
        fo.dwGetXHeaders      = DwGetOption(OPT_DOWNLOADCHUNKS);

        m_pMsgList->SetViewOptions(&fo);
    }
}


void CMessageView::_SetDefaultStatusText(void)
{
    DWORD       cTotal;
    DWORD       cUnread;
    DWORD       cOnServer;
    CStatusBar *pStatusBar = NULL;
    TCHAR       szStatus[CCHMAX_STRINGRES + 20];
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       ids;

    // If we don't have a browser pointer, we can't get the status bar
    if (!m_pBrowser || !m_pMsgList)
        return;

    // Get the status bar if there is one.
    m_pBrowser->GetStatusBar(&pStatusBar);
    if (pStatusBar)
    {
        // Get the counts from the table
        if (SUCCEEDED(m_pMsgList->GetMessageCounts(&cTotal, &cUnread, &cOnServer)))
        {
            // If there are still messages on server load a different
            // status string.
            if (cOnServer)
            {
                AthLoadString(idsXMsgsYUnreadZonServ, szFmt, ARRAYSIZE(szFmt));
                wnsprintf(szStatus, ARRAYSIZE(szStatus), szFmt, cTotal, cUnread, cOnServer);
            }
            else
            {
                AthLoadString(idsXMsgsYUnread, szFmt, ARRAYSIZE(szFmt));
                wnsprintf(szStatus, ARRAYSIZE(szStatus), szFmt, cTotal, cUnread);
            }
            pStatusBar->SetStatusText(szStatus);

            // Also update the toolbar since commands like "Mark as Read" might
            // change.  However, we only do this if we go between zero and some or
            // vice versa.
            if ((m_cItems == 0 && cTotal) || (m_cItems != 0 && cTotal == 0) ||
                (m_cUnread == 0 && cUnread) || (m_cUnread != 0 && cUnread == 0))
            {
                m_pBrowser->UpdateToolbar();
            }

            // Save this for next time.
            m_cItems = cTotal;
            m_cUnread = cUnread;
        }

        pStatusBar->Release();
    }
}


BOOL CMessageView::_ReuseMessageFolder(IViewWindow *pPrevView)
{
    IServerInfo *pInfo = NULL;
    FOLDERID     idPrev = FOLDERID_INVALID;
    FOLDERID     idServerPrev = FOLDERID_INVALID;
    FOLDERID     idServerCur = FOLDERID_INVALID;
    BOOL         fReturn = FALSE;

    if (pPrevView && SUCCEEDED(pPrevView->QueryInterface(IID_IServerInfo, (LPVOID *) &pInfo)))
    {
        if (SUCCEEDED(pInfo->GetFolderId(&idPrev)))
        {
            if (SUCCEEDED(GetFolderServerId(idPrev, &idServerPrev)))
            {
                if (SUCCEEDED(GetFolderServerId(m_idFolder, &idServerCur)))
                {
                    if (idServerPrev == idServerCur)
                    {
                        if (S_OK == pInfo->GetMessageFolder(&m_pServer))
                        {
                            m_pServer->ConnectionAddRef();
                            fReturn = TRUE;
                        }
                    }
                }
            }
        }

        pInfo->Release();
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\view\msgview.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     msgview.h
//
//  PURPOSE:    Defines the Outlook Express view class that handles 
//              displaying the contents of folders with messages.
//

#pragma once

#include "browser.h"
#include "ibodyopt.h"
#include "mimeole.h"
#include "ibodyobj.h"
#include "dragdrop.h"

#define HANDLE_WM_FOLDER_LOADED(hwnd, wParam, lParam, fn)    \
    OnFolderLoaded((hwnd), (wParam), (lParam))


/////////////////////////////////////////////////////////////////////////////
// Forward References
//

interface IMessageList;
interface IBodyObj2;
class CGetNewGroups;
class CViewMenu;

class CMessageView : IViewWindow,
                     IMessageWindow,
                     IDispatch,
                     IOleCommandTarget,
                     IBodyOptions,
                     IMimeEditEventSink,
                     IServerInfo
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructors, Destructors, and Initialization
    //
    CMessageView();
    ~CMessageView();

    HRESULT Initialize(FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    /////////////////////////////////////////////////////////////////////////
    // IOleWindow
    //
    STDMETHOD(GetWindow)(HWND *pHwnd);                         
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);            
                                         
    /////////////////////////////////////////////////////////////////////////
    // IViewWindow
    //
    STDMETHOD(TranslateAccelerator)(THIS_ LPMSG pMsg);
    STDMETHOD(UIActivate)(THIS_ UINT uState);
    STDMETHOD(CreateViewWindow)(THIS_ IViewWindow *pPrevView, IAthenaBrowser *pBrowser,
                                RECT *prcView, HWND *pHwnd);
    STDMETHOD(DestroyViewWindow)(THIS);
    STDMETHOD(SaveViewState)(THIS);
    STDMETHOD(OnPopupMenu)(THIS_ HMENU hMenu, HMENU hMenuPopup, UINT uID);

    /////////////////////////////////////////////////////////////////////////
    // IMessageWindow
    //
    STDMETHOD(OnFrameWindowActivate)(THIS_ BOOL fActivate);
    STDMETHOD(GetCurCharSet)(THIS_ UINT *cp);
    STDMETHOD(UpdateLayout)(THIS_ BOOL fPreviewVisible, BOOL fPreviewHeader, 
                            BOOL fPreviewVert, BOOL fReload);
    STDMETHOD(GetMessageList)(THIS_ IMessageList ** ppMsgList);
    
    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                           OLECMDTEXT *pCmdText); 
    STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                    VARIANTARG *pvaIn, VARIANTARG *pvaOut); 
    
    /////////////////////////////////////////////////////////////////////////
    // IDispatch
    //
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                             LCID lcid, DISPID *rgDispId)
    {
        return (E_NOTIMPL);
    }
    STDMETHOD(GetTypeInfo)(unsigned int iTInfo, LCID lcid, ITypeInfo **ppTInfo)
    {
        return (E_NOTIMPL);
    }
    STDMETHOD(GetTypeInfoCount)(unsigned int FAR* pctinfo)
    {
        return (E_NOTIMPL);
    }
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
                      DISPPARAMS* pDispParams, VARIANT* pVarResult,
                      EXCEPINFO* pExcepInfo, unsigned int* puArgErr);

    /////////////////////////////////////////////////////////////////////////
    // IBodyOptions
    //
    STDMETHOD(SignatureEnabled)(BOOL fAuto)
    { 
        return (E_NOTIMPL);
    }
    STDMETHOD(GetSignature)(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr)
    { 
        return (E_NOTIMPL);
    }
    STDMETHOD(GetMarkAsReadTime)(LPDWORD pdwSecs);
    STDMETHOD(GetFlags)(LPDWORD pdwFlags);
    STDMETHOD(GetInfo)(BODYOPTINFO *pBOI)
    { 
        return (E_NOTIMPL);
    }
    STDMETHOD(GetAccount)(IImnAccount **ppAcct);

    /////////////////////////////////////////////////////////////////////////
    // IMimeEditEventSink
    //
    STDMETHOD(EventOccurred)(DWORD cmdID, IMimeMessage *pMessage);

    /////////////////////////////////////////////////////////////////////////
    // IServerInfo
    //
    STDMETHOD(GetFolderId)(FOLDERID *pID);
    STDMETHOD(GetMessageFolder)(IMessageServer **ppServer);

    /////////////////////////////////////////////////////////////////////////
    // Window Handling 
    //
protected:
    static LRESULT CALLBACK ViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnPostCreate(HWND hwnd);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    void    OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void    OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void    OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
    void    OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void    OnDestroy(HWND hwnd);
    void    OnSetFocus(HWND hwnd, HWND hwndOldFocus);
    void    OnFolderLoaded(HWND  hwnd, WPARAM wParam, LPARAM  lParam);
    LRESULT OnTestGetMsgId(HWND hwnd);
    LRESULT OnTestSaveMessage(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Command Handlers
    //
    HRESULT CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFillPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdShowPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdAddToWab(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    //
    BOOL    _InitMessageList(void);
    BOOL    _InitPreviewPane(void);
    HRESULT _SetListOptions(void);
    BOOL    _IsPreview(void);
    void    _UpdatePreviewPane(BOOL fForceDownload=FALSE);
    void    _SetProgressStatusText(BSTR bstr);
    void    _SetDefaultStatusText(void);
    HRESULT _OnMessageAvailable(MESSAGEID idMessage, HRESULT hrCompletion);
    HRESULT _DoEmailBombCheck(LPMIMEMESSAGE pMsg);
    void    _OptionUpdate(DWORD dwUpdate);
    BOOL    _ReuseMessageFolder(IViewWindow *pPrevView);
    HRESULT _StoreCharsetOntoRows(HCHARSET hCharset);

    /////////////////////////////////////////////////////////////////////////
    // Member Data
private:
    ULONG                   m_cRef;

    // Handy window handles
    HWND                    m_hwnd;
    HWND                    m_hwndParent;
    HWND                    m_hwndList;

    // Shell stuff
    IAthenaBrowser         *m_pBrowser;
    FOLDERID                m_idFolder;
    CDropTarget            *m_pDropTarget;

    // Message List
    IMessageList           *m_pMsgList;
    IOleCommandTarget      *m_pMsgListCT;
    IOleInPlaceActiveObject *m_pMsgListAO;
    DWORD                   m_dwCookie;
    IMessageServer         *m_pServer;

    // Preview Pane
    IBodyObj2              *m_pPreview;
    IOleCommandTarget      *m_pPreviewCT;
    MESSAGEID               m_idMessageFocus;
    CStatusBar              *m_pProgress;
    BOOL                    m_fNotDownloaded;

    // Layout
    BOOL                    m_fSplitHorz;
    RECT                    m_rcSplit;
    DWORD                   m_dwSplitVertPct;
    DWORD                   m_dwSplitHorzPct;
    BOOL                    m_fDragging;

    // State
    UINT                    m_uUIState;
    DWORD                   m_cItems;
    DWORD                   m_cUnread;
    DWORD                   m_cLastChar;

    CGetNewGroups          *m_pGroups;

    // For View.Current View menu
    CViewMenu              *m_pViewMenu;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mapitest.rc
//
#define IDC_SENDDOC                     1015
#define IDC_MAPIADDRESS                 1016
#define IDC_SAVEMAIL                    1021
#define IDC_DELETEMAIL                  1022
#define IDC_READMAIL                    1023
#define IDC_FINDNEXT                    1024

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\bitmap.h ===
/*
 -  B I T M A P . H
 *  
 *  Purpose:
 *      Definitions for the Owner-Drawn Listbox bitmap stuff.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */


/* Listbox string formatting defines */

#define chBOLD              TEXT('\b')
#define chUNDERLINE         TEXT('\v')
#define chTAB               TEXT('\t')
#define chBITMAP            TEXT('\001')

#define BMWIDTH             16
#define BMHEIGHT            16
#define NUMBMPS             4
#define RGBREPLACE          ((DWORD)0x00FF0000) // solid blue


/* Font style of font to use in listbox */

typedef struct
{
    int     lfHeight;
    int     lfWeight;
    BYTE    lfItalic;
    TCHAR   lfFaceName[LF_FACESIZE];
} FONTSTYLE;


/* Function Prototypes */

VOID    DrawItem(LPDRAWITEMSTRUCT pDI);
VOID    MeasureItem(HANDLE hwnd, LPMEASUREITEMSTRUCT mis);
VOID    SetRGBValues(void);
BOOL    InitBmps(HWND hwnd, int idLB);
VOID    DeInitBmps(void);
BOOL    LoadBitmapLB(void);
VOID    DeleteBitmapLB(void);
VOID    ConvertDateRec(LPSTR lpszDateRec, LPSTR lpszDateDisplay);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\resource.h ===
#define IDD_SENDMAIL                    101
#define IDC_MAPI_DIALOG                 1000
#define IDC_MAPI_LOGON_UI               1001
#define IDC_MAPI_NEW_SESSION            1002
#define IDC_RECIP_NONE                  1006
#define IDC_RECIP_RESOLVED              1007
#define IDC_RECIP_AMBIG                 1008
#define IDC_DLLPATH                     1009
#define IDC_LOADDLL                     1010
#define IDC_EXITPROC                    1011
#define IDC_MAPILOGOFF                  1012
#define IDC_WAITRETURN                  1013
#define IDC_SEND                        1014
#define IDC_SENDDOC						1015
#define IDC_MAPIADDRESS					1016
#define IDC_MAPIRESOLVENAME				1017
#define IDC_MAPIDETAILS					1018
#define IDC_MAPI_AB_NOMODIFY			1019
#define IDC_DLLCOMBO                    1020
#define IDC_FINDNEXT                    1021
#define IDC_READMAIL                    1022
#define IDC_SAVEMAIL                    1023
#define IDC_DELETEMAIL                  1024
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\pdkver.h ===
#define rmj     4
#define rmm     934
#define rup     0
#define szVerName   ""
#define szVerUser   "TDSRC"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\bitmap.c ===
/*
 -  B I T M A P . C
 -
 *  Purpose:
 *      Bitmap and Listbox support functions for InBox in sample mail client.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <windowsx.h>
#ifdef _WIN32
#include <objerror.h>
#include <objbase.h>
#endif
#ifdef WIN16
#include <compobj.h>
#endif
#include <mapiwin.h>
#include <mapidbg.h>
#include <mapi.h>
#include <mapix.h>
#include "bitmap.h"
#include "client.h"

// Fonts to use in dialogs

#ifdef _WIN32
#define SHELL_FONT "MS Shell Dlg"
#define SHELL_FONT_SIZE 8
#else
#define SHELL_FONT "MS Sans Serif"
#define SHELL_FONT_SIZE 8
#endif

/*
 *  globals
 */
 
DWORD   rgbWindowColor = 0xFF000000;    // variables for the current
DWORD   rgbHiliteColor = 0xFF000000;    // system color settings.
DWORD   rgbWindowText  = 0xFF000000;    // on a WM_SYSCOLORCHANGE
DWORD   rgbHiliteText  = 0xFF000000;    // we check to see if we need
DWORD   rgbGrayText    = 0xFF000000;    // to reload our bitmap.
DWORD   rgbDDWindow    = 0xFF000000;    //
DWORD   rgbDDHilite    = 0xFF000000;    // 0xFF000000 is an invalid RGB

// an array of integers containing the tab stops, in pixels. The tab 
// stops must be sorted in ascending order; back tabs are not allowed. 

int     rgTabs[] = { 2, 28, 135, 292 };
int     dxbmpLB, dybmpLB;   // dx and dy of listbox bmps

HDC     hdcMemory = 0;      // hdc to hold listbox bitmaps (for speed)
HBITMAP hbmpOrigMemBmp = 0; // original null bitmap in hdcMemory
HBITMAP hbmpLB = 0;         // cached listbox bitmaps
HFONT   hfontLB = 0;        // hfont of LB
HWND    hwndLB = 0;         // hwnd of LB

FONTSTYLE fontStyle = { SHELL_FONT_SIZE, FW_NORMAL, 0, TEXT(SHELL_FONT) };

extern HANDLE hInst;


/*
 -  DeInitBmps
 -  
 *  Purpose:
 *      cleans up LB hfonts, hdc, and hbmps
 */
 
VOID DeInitBmps(VOID)
{
    DeleteBitmapLB();
    if(hdcMemory)
    {
        DeleteDC(hdcMemory);
        hdcMemory = 0;
    }

    if(hfontLB)
    {
        SetWindowFont(hwndLB, GetStockObject(SYSTEM_FONT), FALSE);
        DeleteObject(hfontLB);
        hfontLB = 0;
    }
}


/*
 -  SetLBFont
 -  
 *  Purpose:
 *      creates a font from the global fontStyle
 *      sets global hfontLB to new font and WM_SETFONTs
 *      the hwndLB to the new font
 */
 
VOID SetLBFont(VOID)
{
    LOGFONT lf;

    lf.lfHeight = fontStyle.lfHeight;
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = fontStyle.lfWeight;
    lf.lfItalic = fontStyle.lfItalic;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
    lstrcpy(lf.lfFaceName, fontStyle.lfFaceName);

    hfontLB = CreateFontIndirect(&lf);
    if(hfontLB)
        SetWindowFont(hwndLB, hfontLB, FALSE);        
}


/*
 -  InitBmps
 -  
 *  Purpose:
 *      inits listbox globals, creates listbox
 *  
 *  Arguments:
 *      HWND    main hwnd of app (parent of LB)
 *  
 *  Returns:
 *      TRUE - success; FALSE - failed
 */
 
BOOL InitBmps(HWND hwnd, int idLB)
{
    HDC     hdcScreen;
    HBITMAP hbmpTemp;

    hdcScreen = GetDC(0);
    if(!hdcScreen)
        goto CantInit;
    hdcMemory = CreateCompatibleDC(hdcScreen);
    if(!hdcMemory)
        goto ReleaseScreenDC;

    hbmpTemp = CreateCompatibleBitmap(hdcMemory, 1, 1);
    if(!hbmpTemp)
        goto ReleaseMemDC;
    hbmpOrigMemBmp = SelectObject(hdcMemory, hbmpTemp); // get hbmp of NULL
    if(!hbmpOrigMemBmp)                                 // bmp for hdcMemory
        goto ReleaseMemDC;                              // for when we delete
    SelectObject(hdcMemory, hbmpOrigMemBmp);            // it later in life
    DeleteObject(hbmpTemp);
    ReleaseDC(0, hdcScreen);

    SetRGBValues();     // set the global RGB values
    LoadBitmapLB();     // load the bmps into hdcMemory

    hwndLB = GetDlgItem(hwnd, idLB);
    
    SetLBFont();    // set the font of our listbox
    return TRUE;

/* Error recovery exits */
ReleaseMemDC:
    DeleteDC(hdcMemory);
    hdcMemory = 0;

ReleaseScreenDC:
    ReleaseDC(0, hdcScreen);

CantInit:
    return FALSE;
}


/*
 -  SetRGBValues
 -  
 *  Purpose:
 *      To set various system colors in static variables.  Called at
 *      init time and when system colors change.
 */
 
VOID SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}


/*
 -  MeasureItem
 -  
 *  Purpose:
 *      called from msg WM_MEASUREITEM: returns max dy of listbox items
 *  
 *  Arguments:
 *      HWND        hwnd of main window
 *      pmis        measureitemstruct from WM_MEASUREITEM call
 */
 
VOID MeasureItem(HANDLE hwnd, LPMEASUREITEMSTRUCT pmis)
{
    HDC        hDC = GetDC(hwnd);
    HANDLE     hFont = hfontLB;
    TEXTMETRIC TM;

    if(!hFont)
        hFont = GetStockObject(SYSTEM_FONT);
    hFont = SelectObject(hDC, hFont);
    GetTextMetrics(hDC, &TM);
    SelectObject(hDC, hFont);
    ReleaseDC(hwnd, hDC);

    // set the height to be max of (dyfont or dybitmap)
    pmis->itemHeight = max(dybmpLB, TM.tmHeight);
}


/*
 -  OutTextFormat
 -  
 *  Purpose:
 *      to parse the string in the listbox and draw it accordingly:
 *      first char == chBOLD: line is bold
 *      first char == chUNDERLINE: line is underlined (can follow chBOLD)
 *      char == chTAB: go to next column in rgTabs
 *      '/001#': bitblt that numbered bitmap.
 *      otherwise, outtext the line
 *  
 *  Arguments:
 *      pDI     from DrawItem from WM_DRAWITEM msg
 */
 
VOID OutTextFormat(LPDRAWITEMSTRUCT pDI)
{
    TCHAR   szDateRec[32];
    TCHAR   szItem[256];
    TCHAR   szTemp[4];
    TCHAR   szDots[4] = {"..."};
    TCHAR   *pch;
    INT     nT;
    INT     nTab = 0;           // current tab we is on
    INT     nBmp;               // index of envelope bitmap
    HFONT   hfDef = 0;
    HFONT   hfOld = 0;          // bold or underlined font
    TCHAR   *pchBuff = NULL;
    LPMSGID lpMsgId = (LPMSGID)pDI->itemData;

    pch = szItem;

    // Format a string from the info in lpMsgNode
    // First, calculate the index to the desired bitmap
    
    nBmp = ((!lpMsgId->fUnRead) * 2) + ((!!lpMsgId->fHasAttach) * 1 );

    // Convert our received date and build string
    
    ConvertDateRec (lpMsgId->lpszDateRec, szDateRec);

    // Limit our subject size
    
    szTemp[0] = '\0';
    
    if(lpMsgId->lpszSubject && (lstrlen(lpMsgId->lpszSubject) > 32))
    {
        memcpy(szTemp, &lpMsgId->lpszSubject[28], 4);
        memcpy(&lpMsgId->lpszSubject[28], szDots, 4);
    }
    
    wsprintf(szItem, "\001%d\t%s\t%s\t%s", nBmp, 
            (lpMsgId->lpszFrom ? lpMsgId->lpszFrom : ""),
            (lpMsgId->lpszSubject ? lpMsgId->lpszSubject : ""),
            szDateRec);

    // erase background
    ExtTextOut(pDI->hDC, 0, 0, ETO_OPAQUE, &pDI->rcItem, NULL, 0, NULL);

    // underline or bold this line?  Only check first & second char
    if(*pch == chBOLD || *pch == chUNDERLINE)
    {
        LOGFONT     lf;

        hfOld = GetWindowFont(pDI->hwndItem);
        if(!hfOld)
            hfOld = GetStockObject(SYSTEM_FONT);
        GetObject(hfOld, sizeof(lf), &lf);

        if(*pch == chBOLD)
        {
            lf.lfWeight = FW_BOLD;
            pch++;
        }
        if(*pch == chUNDERLINE)
        {
            lf.lfUnderline = TRUE;
            pch++;
        }

        hfDef = CreateFontIndirect(&lf);
        if(hfDef)
            SelectObject(pDI->hDC, hfDef);
    }

    // selected or nonselected bmps?
    nT = (ODS_SELECTED & pDI->itemState) ? (BMWIDTH * NUMBMPS) : 0;

    // parse the string
    for(; *pch; pch++)
    {
        TCHAR   *pchT;
        RECT    rc;

        if(*pch == chBITMAP)     // do we have a bitmap?
        {
            ++pch;
            // draw the bitmap
            BitBlt(pDI->hDC, pDI->rcItem.left + rgTabs[nTab],
                pDI->rcItem.top, BMWIDTH, BMHEIGHT, hdcMemory,
                nT + (int)(*pch - TEXT('0')) * BMWIDTH, 0, SRCCOPY);
            continue;
        }

        if(*pch == chTAB)    // move to next tabstop?
        {
            nTab++;
            continue;
        }

        pchT = pch;     // find end of the column of text
        while(*pchT && (*pchT != chTAB))
            pchT++;

        // set rect to drawtext in
        SetRect(&rc, pDI->rcItem.left + rgTabs[nTab], pDI->rcItem.top, 
            pDI->rcItem.right, pDI->rcItem.bottom);

        // draw the text
        ExtTextOut(pDI->hDC, rc.left, rc.top + 1, ETO_OPAQUE | ETO_CLIPPED,
            &rc, pch, pchT - pch, NULL);
        pch = pchT - 1; // move to end of this column
    }

    if(hfDef)   // delete underline or bold font if we created it
    {
        SelectObject(pDI->hDC, hfOld);
        DeleteObject(hfDef);
    }

    if(szTemp[0] != '\0')
    {
        memcpy(&lpMsgId->lpszSubject[28], szTemp, 4);
    }
}


/*
 -  DrawItem
 -
 *  Purpose:
 *      Handles WM_DRAWITEM for both drive and directory listboxes.
 *
 *  Parameters:
 *      pDI     LPDRAWITEMSTRUCT passed from the WM_DRAWITEM message.
 */
 
VOID DrawItem(LPDRAWITEMSTRUCT pDI)
{
    COLORREF    crText, crBack;

    if((int)pDI->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pDI->itemAction)
    {
        if(pDI->itemState & ODS_SELECTED)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pDI->hDC, rgbHiliteText);
            crBack = SetBkColor(pDI->hDC, rgbHiliteColor);
        }

        // parse and spit out bmps and text
        OutTextFormat(pDI);

        // Restore original colors if we changed them above.
        if(pDI->itemState & ODS_SELECTED)
        {
            SetTextColor(pDI->hDC, crText);
            SetBkColor(pDI->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pDI->itemAction) || (ODS_FOCUS & pDI->itemState))
        DrawFocusRect(pDI->hDC, &pDI->rcItem);
}


/*
 -  ConvertDateRec
 -
 *  Purpose:
 *      To convert the lpszDateReceived field of a message to a
 *      more paletable display format; namely: mm/dd/yy hh:mmAM.
 *
 *  Parameters:
 *      lpszDateRec         - Original format
 *      lpszDateDisplay     - Display format
 */

VOID ConvertDateRec (LPSTR lpszDateRec, LPSTR lpszDateDisplay)
{
    char  szDateTmp[32];
    LPSTR lpszYear;
    LPSTR lpszMonth;
    LPSTR lpszDay;
    LPSTR lpszHour;
    LPSTR lpszMinute;
    int nHour;
    static char szFoo[2][3] =
    {"AM", "PM"};

    *lpszDateDisplay = 0;
    if (!lpszDateRec || !*lpszDateRec)
        return;

    lstrcpy(szDateTmp, lpszDateRec);

    lpszYear = strtok (szDateTmp, "/ :");
    lpszMonth = strtok (NULL, "/ :");
    lpszDay = strtok (NULL, "/ :");
    lpszHour = strtok (NULL, "/ :");
    lpszMinute = strtok (NULL, "/ :");

    if(lpszHour)
        nHour = atoi (lpszHour);
    else
        nHour = 0;

    if (nHour > 12)
        wsprintf (lpszHour, "%d", nHour - 12);

    wsprintf (lpszDateDisplay, "%s/%s/%s %s:%s%s", lpszMonth,
        (lpszDay ? lpszDay : ""),
        (lpszYear ? lpszYear : ""),
        (lpszHour ? lpszHour : ""),
        (lpszMinute ? lpszMinute : ""),
        szFoo[(nHour > 11 ? 1 : 0)]);
}


/*
 *  RgbInvertRgb
 *  
 *  Purpose:
 *      To reverse the byte order of the RGB value (for file format
 *  
 *  Arguments:
 *  
 *  Returns:
 *      New color value (RGB to BGR)
 */
 
#define RgbInvertRgb(_rgbOld) \
    (DWORD)RGB(GetBValue(_rgbOld), GetGValue(_rgbOld), GetRValue(_rgbOld))


/*
 *  LoadAlterBitmap (mostly stolen from commdlg)
 *  
 *  Purpose:
 *      Loads the IDB_ENVELOPE bitmap and gives all the pixels that are
 *      RGBREPLACE a new color.
 *
 *  Assumption:
 *      This function will work on one bitmap during it's lifetime.
 *      (Due to the fact that it finds RGBREPLACE once and then
 *      operates on that offset whenever called again because under NT,
 *      it appears that the bitmap is cached, so the second time you go
 *      looking for RGBREPLACE, it won't be found.) You could load the
 *      resource, copy it, then modify the copy as a workaround. But I
 *      chose the cheap way out as I will only ever modify one bmp.
 *  
 *  Arguments:
 *      rgbInstead  rgb value to replace defined RGBREPLACE with
 *  
 *  Returns:
 *      NULL - failed or hbmp of new modified bitmap
 */

HBITMAP LoadAlterBitmap(DWORD rgbInstead)
{
    HANDLE              hbmp = 0;
    LPBITMAPINFOHEADER  qbihInfo;
    HDC                 hdcScreen;
    HRSRC               hresLoad;
    HGLOBAL             hres;
    LPBYTE              qbBits;
    DWORD               rgbReplace = 0;
    DWORD               *rgdw = NULL;
    DWORD               *lpdw = NULL;
    ULONG               cb = 0;
    
    if (rgbInstead)
        rgbReplace = RGBREPLACE;

    // load our listbox bmps resource
    hresLoad = FindResource(hInst, MAKEINTRESOURCE(IDB_ENVELOPE), RT_BITMAP);
    if(hresLoad == 0)
        return 0;
    hres = LoadResource(hInst, hresLoad);
    if(hres == 0)
        return 0;

    rgbReplace = RgbInvertRgb(rgbReplace);
    rgbInstead = RgbInvertRgb(rgbInstead);
    qbihInfo = (LPBITMAPINFOHEADER)LockResource(hres);

    // Skip over the header structure
    qbBits = (LPBYTE)(qbihInfo + 1);

    // Skip the color table entries, if any
    qbBits += (1 << (qbihInfo->biBitCount)) * sizeof(RGBQUAD);

    // Copy the resource into writable memory so we can
    // munge the color table to set our background color
    cb = (ULONG)(qbBits - (LPBYTE)qbihInfo) + qbihInfo->biSizeImage;
    rgdw = (DWORD *)GlobalAllocPtr(GMEM_MOVEABLE, cb);
    
    CopyMemory((LPVOID)rgdw, (LPVOID)qbihInfo, cb);
    
    // find the color to replace in the color table
    for(lpdw = (DWORD *)((LPBYTE)rgdw + qbihInfo->biSize); ; lpdw++)
    {
        if(*lpdw == rgbReplace)
            break;
    }

    // replace that color value with our new one
    *lpdw = (DWORD)rgbInstead;

    // Create a color bitmap compatible with the display device
    hdcScreen = GetDC(0);
    if(hdcScreen != 0)
    {
        hbmp = CreateDIBitmap(hdcScreen, (LPBITMAPINFOHEADER)rgdw, 
                (LONG)CBM_INIT, qbBits, (LPBITMAPINFO) rgdw, DIB_RGB_COLORS);
        ReleaseDC(0, hdcScreen);
    }

    UnlockResource(hres);
    FreeResource(hres);

    GlobalFreePtr(rgdw);
    
    return hbmp;
}


/*
 *  DeleteBitmapLB
 *  
 *  Purpose:
 *      Get rid of hbmpLB, if it exists
 */
 
VOID DeleteBitmapLB(VOID)
{
    if(hbmpOrigMemBmp)
    {
        SelectObject(hdcMemory, hbmpOrigMemBmp);
        if(hbmpLB != 0)
        {
            DeleteObject(hbmpLB);
            hbmpLB = 0;
        }
    }
}


/*
 *  LoadBitmapLB (mostly stolen from commdlg)
 *  
 *  Purpose:
 *      Creates the listbox bitmap. If an appropriate bitmap
 *      already exists, it just returns immediately.  Otherwise, it
 *      loads the bitmap and creates a larger bitmap with both regular
 *      and highlight colors.
 *
 *  Returns:
 *      TRUE - success; FALSE - failure
 */
 
BOOL LoadBitmapLB(VOID)
{
    BITMAP  bmp;
    HANDLE  hbmp, hbmpOrig;
    HDC     hdcTemp;
    BOOL    bWorked = FALSE;

    // check for existing bitmap and validity
    if( (hbmpLB != 0) &&
        (rgbWindowColor == rgbDDWindow) &&
        (rgbHiliteColor == rgbDDHilite))
    {
        if(SelectObject(hdcMemory, hbmpLB))
            return TRUE;
    }

    DeleteBitmapLB();

    rgbDDWindow = rgbWindowColor;
    rgbDDHilite = rgbHiliteColor;

    if(!(hdcTemp = CreateCompatibleDC(hdcMemory)))
        goto LoadExit;

    if(!(hbmp = LoadAlterBitmap(rgbWindowColor)))
        goto DeleteTempDC;

    GetObject(hbmp, sizeof(BITMAP), (LPBYTE) &bmp);
    dybmpLB = bmp.bmHeight;
    dxbmpLB = bmp.bmWidth;

    hbmpOrig = SelectObject(hdcTemp, hbmp);

    hbmpLB = CreateDiscardableBitmap(hdcTemp, dxbmpLB*2, dybmpLB);
    if(!hbmpLB)
        goto DeleteTempBmp;

    if(!SelectObject(hdcMemory, hbmpLB))
    {
        DeleteBitmapLB();
        goto DeleteTempBmp;
    }

    BitBlt(hdcMemory, 0, 0, dxbmpLB, dybmpLB,   // copy unhighlited bmps
           hdcTemp, 0, 0, SRCCOPY);             // into hdcMemory
    SelectObject(hdcTemp, hbmpOrig);

    DeleteObject(hbmp);

    if(!(hbmp = LoadAlterBitmap(rgbHiliteColor)))
        goto DeleteTempDC;

    hbmpOrig = SelectObject(hdcTemp, hbmp);
    BitBlt(hdcMemory, dxbmpLB, 0, dxbmpLB, dybmpLB, // copy highlited bmps
        hdcTemp, 0, 0, SRCCOPY);                    // into hdcMemory
    SelectObject(hdcTemp, hbmpOrig);

    bWorked = TRUE;

DeleteTempBmp:
    DeleteObject(hbmp);
DeleteTempDC:
    DeleteDC(hdcTemp);
LoadExit:
    return bWorked;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\mapidbg.c ===
/*
 *  MAPIDBG.C
 *
 *  MAPI Debugging Utilities
 *
 *  Copyright (C) 1986-1996 Microsoft Corporation. All rights reserved.
 */

#ifdef DEBUG

#pragma warning(disable:4100)   /* unreferenced formal parameter */
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4201)   /* nameless struct/union */
#pragma warning(disable:4206)   /* translation unit is empty */
#pragma warning(disable:4209)   /* benign typedef redefinition */
#pragma warning(disable:4214)   /* bit field types other than int */
#pragma warning(disable:4001)   /* single line comments */
#pragma warning(disable:4050)   /* different code attributes */

#ifdef _MAC
#define INC_OLE2
#include <windows.h>
#include <macname1.h>
#include <macos\menus.h>
#include <stdio.h>
#include <mapiprof.h>

#define GetPrivateProfileIntA       MAPIGetPrivateProfileInt

#elif defined(WIN16) || defined(_WIN32)
#pragma warning(disable:4115)   /* named type definition in parentheses */
#include <windows.h>
#include <mapiwin.h>

#ifdef _WIN32
#pragma warning(disable:4001)   /* single line comments */
#pragma warning(disable:4115)   /* named type definition in parentheses */
#pragma warning (disable:4514)  /* unreferenced inline function */
#include <objerror.h>
#endif

#else

#include <stdio.h>
void __far __pascal OutputDebugString(char __far *);
#define wvsprintf           vsprintf
#define wsprintf            sprintf

#endif      /* _MAC */

#ifdef DOS
#define lstrcpyA            strcpy
#define lstrlenA            strlen
#define lstrcatA            strcat
#define wvsprintfA          wvsprintf
#define wsprintfA           wsprintf
#define OutputDebugStringA  OutputDebugString
#endif

#include <mapidbg.h>
#include <mapidefs.h>
#include <mapitags.h>
#include <mapicode.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>
#ifdef _MAC
#include <macname2.h>
#endif

#if defined(DBCS) && defined(DOS)
#include <gapidos.h>
#endif

#if defined(DEBUG) && defined(_WINNT)
#include <lmcons.h>
#include <lmalert.h>
#endif

/*  Patch/Hack for 16bit, optimized builds.
 *
 *  memcpy with a size of 0 bytes causes a
 *  crash.
 */

#ifndef __MEMCPY_H_
#define __MEMCPY_H_

#if defined(WIN16) && !defined(DEBUG)
#define MemCopy(_dst,_src,_cb)      do                                  \
                                    {                                   \
                                        size_t __cb = (size_t)(_cb);    \
                                        if (__cb)                       \
                                            memcpy(_dst,_src,__cb);     \
                                    } while (FALSE)
#else
#define MemCopy(_dst,_src,_cb)  memcpy(_dst,_src,(size_t)(_cb))
#endif

#endif

#if (defined(WIN16) || defined(DOS)) && !defined(NO_BASED_DEBUG)
#define BASED_DEBUG __based(__segname("DEBUG_DATA"))
#else
#define BASED_DEBUG
#endif

#if defined(WIN16)
#define BASED_CODE          __based(__segname("_CODE"))
#else
#define BASED_CODE
#endif



#if defined(WIN16) || defined(_WIN32)
static BOOL fTraceEnabled               = -1;
static BOOL fUseEventLog                = -1;
static BOOL fAssertLeaks                = -1;
#if defined(_WIN32) && !defined(_MAC)
BOOL fInhibitTrapThread                 = 2;
#endif

static char szKeyTraceEnabled[]         = "DebugTrace";
static char szKeyInhibitTrapThread[]    = "TrapOnSameThread";
static char szKeyEventLog[]             = "EventLog";
static char szKeyUseVirtual[]           = "VirtualMemory";
static char szKeyAssertLeaks[]          = "AssertLeaks";
static char szKeyCheckOften[]           = "CheckHeapOften";
static char szKeyFillRandom[]           = "MemoryFillRandom";
static char szSectionDebug[]            = "General";
static char szDebugIni[]                = "MAPIDBG.INI";
#endif

#ifndef VTABLE_FILL
#ifdef _MAC
#define VTABLE_FILL     NULL,
#else
#define VTABLE_FILL
#endif
#endif

#if defined(DEBUG) && defined(_WINNT)
typedef BOOL  (WINAPI   *ReportEventFN)(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPCTSTR *, LPVOID);
typedef HANDLE (WINAPI  *RegisterEventSourceAFN)(LPCTSTR, LPCTSTR);

ReportEventFN pfnReportEvent = NULL;
RegisterEventSourceAFN pfnRegisterEventSourceA = NULL;
#endif


#ifdef  WIN16
#pragma code_seg("Debug")
#endif  

#if defined( _WINNT)

/*++

Routine Description:

    This routine returns if the service specified is running interactively
    (not invoked \by the service controller).

Arguments:

    None

Return Value:

    BOOL - TRUE if the service is an EXE.


Note:

--*/

BOOL WINAPI IsDBGServiceAnExe( VOID )
{
    HANDLE hProcessToken = NULL;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid = NULL;
    PSID ServiceSid = NULL;
    DWORD i;

    // Start with assumption that process is an EXE, not a Service.
    BOOL fExe = TRUE;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
        goto ret;

    if (groupInfo == NULL)
        goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
        groupLength, &groupLength))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            goto ret;

        LocalFree(groupInfo);
        groupInfo = NULL;
    
        groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);
    
        if (groupInfo == NULL)
            goto ret;
    
        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
            groupLength, &groupLength))
        {
            goto ret;
        }
    }

    //
    //  We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //  The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
        0, 0, 0, 0, 0, &InteractiveSid))
    {
        goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
        0, 0, 0, 0, &ServiceSid))
    {
        goto ret;
    }

    for (i = 0; i < groupInfo->GroupCount ; i += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
        PSID Sid = sanda.Sid;
    
        //
        //  Check to see if the group we're looking at is one of
        //  the 2 groups we're interested in.
        //
    
        if (EqualSid(Sid, InteractiveSid))
        {
            //
            //  This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  an EXE.
            //
            goto ret;
        }
        else if (EqualSid(Sid, ServiceSid))
        {
            //
            //  This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account.
            //
            fExe = FALSE;
            goto ret;
        }
    }

    //
    //  Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //
    fExe = FALSE;

ret:

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    if (ServiceSid)
        FreeSid(ServiceSid);

    if (groupInfo)
        LocalFree(groupInfo);

    if (hProcessToken)
        CloseHandle(hProcessToken);

    return(fExe);
}

#endif

/* LogIt */

#ifndef _MAC
void    LogIt(LPSTR plpcText, BOOL  fUseAlert)
{
#if defined(DEBUG) && defined(_WINNT)
    LPSTR           llpcStr[2];
    static HANDLE   hEventSource = NULL;

    if (pfnRegisterEventSourceA == NULL)
    {
        /* This handle is not important as the lib will be freed on exit (and it's debug only) */
        HINSTANCE       lhLib = LoadLibraryA("advapi32.dll");
        
        if (!lhLib)
            return;
        
        pfnRegisterEventSourceA = (RegisterEventSourceAFN) GetProcAddress(lhLib, "RegisterEventSourceA");
        pfnReportEvent = (ReportEventFN) GetProcAddress(lhLib, "ReportEventA");
        
        if (!pfnRegisterEventSourceA || !pfnReportEvent)
            return;
    }
        
    if (!hEventSource)                                      
        hEventSource = pfnRegisterEventSourceA(NULL, "MAPIDebug");

    llpcStr[0] = "MAPI Debug Log";
    llpcStr[1] = plpcText;

    pfnReportEvent(hEventSource,    /* handle of event source */
        EVENTLOG_ERROR_TYPE,        /* event type             */
        0,                          /* event category         */
        0,                          /* event ID               */
        NULL,                       /* current user's SID     */
        2,                          /* strings in lpszStrings */
        0,                          /* no bytes of raw data   */
        llpcStr,                    /* array of error strings */
        NULL);                      /* no raw data            */
        
    /* Now we generate an Alert! */
    /* This code is adapted from PierreC's stuff, and NEEDS TO BE UNICODE!!!! */
    if (fUseAlert)
    {
#define MAX_LINE        256

typedef NET_API_STATUS  (WINAPI *NAREFN)(TCHAR *, ADMIN_OTHER_INFO *, ULONG, TCHAR *);

        BYTE                rgb[sizeof(ADMIN_OTHER_INFO) + (sizeof(WCHAR) * MAX_LINE)];
        ADMIN_OTHER_INFO *  poi     = (ADMIN_OTHER_INFO *) rgb;
        WCHAR *             pch     = (WCHAR *) (rgb + sizeof(ADMIN_OTHER_INFO));
        NET_API_STATUS      nas;
        static   NAREFN     fnNetAlertRaiseEx = NULL;
        
        /* Resolve function here, never free library as it's debug only */
        if (!fnNetAlertRaiseEx)
        {
            HINSTANCE       lhLib = LoadLibrary("NETAPI32.DLL");
            if (lhLib)
                fnNetAlertRaiseEx = (NAREFN) GetProcAddress(lhLib, "NetAlertRaiseEx");
        }
        
        if (fnNetAlertRaiseEx)
        {
            poi->alrtad_errcode = (DWORD) -1;
            poi->alrtad_numstrings = 1;
            
            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, plpcText, -1, pch, MAX_LINE))
            {
                nas = fnNetAlertRaiseEx(
                            (TCHAR *) L"ADMIN",
                            poi, 
                            sizeof(ADMIN_OTHER_INFO) + ((lstrlenW(pch) + 1) * sizeof(WCHAR)),
                            (TCHAR *) L"MAPI Assert");
                    
                        
            }
        }
    }
    
#endif /* DEBUG && NT */
}
#endif /* !_MAC */

/* DebugOutputFn ------------------------------------------------------------ */

char BASED_CODE szCR[] = "\r";

void DebugOutputFn(char *psz)
{
#if defined(_MAC)

    OutputDebugString(psz);

#else

#if defined(WIN16) || defined(_WIN32)
    if (fTraceEnabled == -1)
    {
        fTraceEnabled = GetPrivateProfileIntA(szSectionDebug, szKeyTraceEnabled,
            0, szDebugIni);

        fUseEventLog = GetPrivateProfileIntA(szSectionDebug, szKeyEventLog,
            0, szDebugIni);     
    }

    if (!fTraceEnabled)
        return;

    if (fUseEventLog)
#else
    if (FALSE)
#endif
        LogIt(psz, FALSE);

#ifdef WIN16
    OutputDebugString(psz);
    OutputDebugString(szCR);
#else
    OutputDebugStringA(psz);
    OutputDebugStringA(szCR);
#endif
    
#endif  /* _MAC */
}


/* DebugTrapFn -------------------------------------------------------------- */

#if defined(_WIN32) && !defined(_MAC)

typedef struct {
    char *      sz1;
    char *      sz2;
    UINT        rgf;
    int         iResult;
} MBContext;

DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
    if (fUseEventLog)
    {
        LogIt(pmbc->sz1, TRUE);
        pmbc->iResult = IDIGNORE;
    }
    else
        pmbc->iResult = MessageBoxA(NULL, pmbc->sz1, pmbc->sz2,
            pmbc->rgf | MB_SETFOREGROUND);

    return(0);
}

int MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
    HANDLE      hThread;
    DWORD       dwThreadId;
    MBContext   mbc;

    mbc.sz1     = sz1;
    mbc.sz2     = sz2;
    mbc.rgf     = rgf;
    mbc.iResult = IDRETRY;

    #if defined(_WIN32) && !defined(_MAC)
    if (fInhibitTrapThread == 2)
        fInhibitTrapThread = GetPrivateProfileIntA(szSectionDebug,
            szKeyInhibitTrapThread, 0, szDebugIni);
    #endif

    if (fInhibitTrapThread)
    {
        MessageBoxFnThreadMain(&mbc);
    }
    else
    {
        hThread = CreateThread(NULL, 0,
            (PTHREAD_START_ROUTINE)MessageBoxFnThreadMain, &mbc, 0, &dwThreadId);

        if (hThread != NULL) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    }

    return(mbc.iResult);
}
#else
#define MessageBoxFn(sz1, sz2, rgf)     MessageBoxA(NULL, sz1, sz2, rgf)
#endif

int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
    char    sz[512];
    va_list vl;

    #if defined(WIN16) || defined(_WIN32)
    int     id;
    #endif
    #if defined(_WIN32) && !defined(_MAC)
    static int iServiceFlag = -1;
    #endif

    lstrcpyA(sz, "++++ MAPI Debug Trap (");
    _strdate(sz + lstrlenA(sz));
    lstrcatA(sz, " ");
    _strtime(sz + lstrlenA(sz));
    lstrcatA(sz, ")\n");
    DebugOutputFn(sz);

    va_start(vl, pszFormat);
    wvsprintfA(sz, pszFormat, vl);
    va_end(vl);

    wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    DebugOutputFn(sz);

    #if defined(DOS)
    _asm { int 3 }
    #endif

#if defined(WIN16) || defined(_WIN32)
    /* Hold down control key to prevent MessageBox */
    if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
    {
        UINT uiFlags = MB_ABORTRETRYIGNORE;

        if (fFatal)
            uiFlags |= MB_DEFBUTTON1;
        else
            uiFlags |= MB_DEFBUTTON3;

        #ifdef WIN16
        uiFlags |= MB_ICONEXCLAMATION | MB_SYSTEMMODAL;
        #else
        uiFlags |= MB_ICONSTOP | MB_TASKMODAL;
        #endif

        #if defined(_WIN32) && !defined(_MAC)
        if (iServiceFlag == -1)
        {
            DWORD dwVersion = GetVersion();

            if (dwVersion & 0x80000000)
            {
                if (LOBYTE(LOWORD(dwVersion)) < 4)
                {
                    //  NT 3.51
                    iServiceFlag = 0x00040000;
                }
                else
                {
                    //  NT 4.0+
                    iServiceFlag = 0x00200000;
                }
            }
            else
                //  not NT, skip this
                iServiceFlag = 0;
        }

        if (!IsDBGServiceAnExe())
            uiFlags |= (UINT) iServiceFlag;
        #endif

        id = MessageBoxFn(sz, "MAPI Debug Trap", uiFlags);

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }
#endif

    return(0);
}

/* DebugTraceFn ------------------------------------------------------------- */

int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...)
{
    char    sz[768];
    int     fAutoLF = 0;
    va_list vl;

    if (*pszFormat == '~') {
        pszFormat += 1;
        fAutoLF = 1;
    }

    va_start(vl, pszFormat);
    wvsprintfA(sz, pszFormat, vl);
    va_end(vl);

#ifndef _MAC
    if (fAutoLF)
        lstrcatA(sz, "\n");
#endif

    DebugOutputFn(sz);

    return(0);
}

/* DebugTraceProblemsFn */

void EXPORTDBG __cdecl DebugTraceProblemsFn(LPSTR sz, LPVOID pv)
{
    LPSPropProblemArray pprobs = (LPSPropProblemArray)pv;
    SPropProblem *      pprob = pprobs->aProblem;
    int                 cprob = (int)pprobs->cProblem;

    DebugTraceFn("%s: SetProps problem\n", sz);
    while (cprob--)
    {
        DebugTraceFn("Property %s (index %ld): failed with %s\n",
            SzDecodeUlPropTagFn(pprob->ulPropTag),
            pprob->ulIndex,
            SzDecodeScodeFn(pprob->scode));
    }
}

/* SCODE & PropTag decoding ------------------------------------------------- */

typedef struct
{
    char *          psz;
    unsigned long   ulPropTag;
} PT;

typedef struct
{
    char *  psz;
    SCODE   sc;
} SC;

#define Pt(_ptag)   {#_ptag, _ptag}
#define Sc(_sc)     {#_sc, _sc}

#if !defined(DOS)
static PT BASED_DEBUG rgpt[] = {
    
#include "_tags.h"
    
/*
 * Property types
 */
    Pt(PR_NULL),
    Pt(PT_UNSPECIFIED),
    Pt(PT_NULL),
    Pt(PT_I2),
    Pt(PT_LONG),
    Pt(PT_R4),
    Pt(PT_DOUBLE),
    Pt(PT_CURRENCY),
    Pt(PT_APPTIME),
    Pt(PT_ERROR),
    Pt(PT_BOOLEAN),
    Pt(PT_OBJECT),
    Pt(PT_I8),
    Pt(PT_STRING8),
    Pt(PT_UNICODE),
    Pt(PT_SYSTIME),
    Pt(PT_CLSID),
    Pt(PT_BINARY),
    Pt(PT_TSTRING),
    Pt(PT_MV_I2),
    Pt(PT_MV_LONG),
    Pt(PT_MV_R4),
    Pt(PT_MV_DOUBLE),
    Pt(PT_MV_CURRENCY),
    Pt(PT_MV_APPTIME),
    Pt(PT_MV_SYSTIME),
    Pt(PT_MV_STRING8),
    Pt(PT_MV_BINARY),
    Pt(PT_MV_UNICODE),
    Pt(PT_MV_CLSID),
    Pt(PT_MV_I8)
};

#define cpt (sizeof(rgpt) / sizeof(PT))

static SC BASED_DEBUG rgsc[] = {

/* FACILITY_NULL error codes from OLE */

    Sc(S_OK),
    Sc(S_FALSE),

    Sc(E_UNEXPECTED),
    Sc(E_NOTIMPL),
    Sc(E_OUTOFMEMORY),
    Sc(E_INVALIDARG),
    Sc(E_NOINTERFACE),
    Sc(E_POINTER),
    Sc(E_HANDLE),
    Sc(E_ABORT),
    Sc(E_FAIL),
    Sc(E_ACCESSDENIED),

/* MAPI error codes from MAPICODE.H */
#include "_scode.h"
                    
};

#define csc (sizeof(rgsc) / sizeof(SC))
#endif

char * EXPORTDBG __cdecl
SzDecodeScodeFn(SCODE sc)
{
    static char rgch[64];

    #if !defined(DOS)
    int isc;
    for (isc = 0; isc < csc; ++isc)
        if (sc == rgsc[isc].sc)
            return rgsc[isc].psz;
    #endif

    wsprintfA (rgch, "%08lX", sc);
    return rgch;
}

char * EXPORTDBG __cdecl
SzDecodeUlPropTypeFn(unsigned long ulPropType)
{
    static char rgch[8];

    switch (ulPropType)
    {
    case PT_UNSPECIFIED:    return("PT_UNSPECIFIED");   break;
    case PT_NULL:           return("PT_NULL");          break;
    case PT_I2:             return("PT_I2");            break;
    case PT_LONG:           return("PT_LONG");          break;
    case PT_R4:             return("PT_R4");            break;
    case PT_DOUBLE:         return("PT_DOUBLE");        break;
    case PT_CURRENCY:       return("PT_CURRENCY");      break;
    case PT_APPTIME:        return("PT_APPTIME");       break;
    case PT_ERROR:          return("PT_ERROR");         break;
    case PT_BOOLEAN:        return("PT_BOOLEAN");       break;
    case PT_OBJECT:         return("PT_OBJECT");        break;
    case PT_I8:             return("PT_I8");            break;
    case PT_STRING8:        return("PT_STRING8");       break;
    case PT_UNICODE:        return("PT_UNICODE");       break;
    case PT_SYSTIME:        return("PT_SYSTIME");       break;
    case PT_CLSID:          return("PT_CLSID");         break;
    case PT_BINARY:         return("PT_BINARY");        break;
    }

    wsprintfA(rgch, "0x%04lX", ulPropType);
    return rgch;
}

char *  EXPORTDBG __cdecl
SzDecodeUlPropTagFn(unsigned long ulPropTag)
{
    static char rgch[64];

    #if !defined(DOS)
    int ipt;
    for (ipt = 0; ipt < cpt; ++ipt)
        if (ulPropTag == rgpt[ipt].ulPropTag)
            return rgpt[ipt].psz;
    #endif

    wsprintfA(rgch, "PROP_TAG(%s, 0x%04lX)",
        SzDecodeUlPropType(PROP_TYPE(ulPropTag)),
        PROP_ID(ulPropTag));
    return rgch;
}

SCODE  EXPORTDBG __cdecl
ScodeFromSzFn(char *psz)
{
    #if !defined(DOS)
    int isc;
    for (isc = 0; isc < csc; ++isc)
        {
        if (lstrcmpA(psz, rgsc[isc].psz) == 0)
            {
            return rgsc[isc].sc;
            }
        }
    #endif
    return 0;
}

unsigned long EXPORTDBG __cdecl
UlPropTagFromSzFn(char *psz)
{
    #if !defined(DOS)
    int ipt;
    for (ipt = 0; ipt < cpt; ++ipt)
        {
        if (lstrcmpA(psz, rgpt[ipt].psz) == 0)
            {
            return rgpt[ipt].ulPropTag;
            }
        }
    #endif
    return 0;
}

/* ScCheckScFn -------------------------------------------------------------- */

#if !defined(DOS)

SCODE EXPORTDBG __cdecl ScCheckScFn(    SCODE   sc,
                    SCODE * lpscLegal,
                    char *  lpszMethod,
                    char *  lpszFile,
                    int     iLine)
{
    BOOL fIsQueryInterface = (lpscLegal == IUnknown_QueryInterface_Scodes);

    if (sc == S_OK)
        return(sc);

    while( *lpscLegal != S_OK && sc != *lpscLegal )
    {
        lpscLegal++;
    }

    if ( *lpscLegal == S_OK )
    {
        SCODE *lpscNextCommon = Common_Scodes;

        /* see if this is a common scode */
            if ( !fIsQueryInterface )
                while(  *lpscNextCommon != S_OK &&
                        sc != *lpscNextCommon )
                {
                    lpscNextCommon++;
                }

        /* this is an illegal error or an RPC error */
           if ( (*lpscNextCommon == S_OK || fIsQueryInterface) &&
                ( SCODE_FACILITY(sc) != FACILITY_RPC) )
           {
                DebugTrace( "Unrecognized scode %s from %s\n\t in file %s line %d\n",
                        SzDecodeScode( sc ), lpszMethod, lpszFile, iLine);
            }
    }

    return(sc);
}
#endif

/* SCODE lists -------------------------------------------------------------- */

#if !defined(DOS)

#define STANDARD_OPENENTRY_SCODES \
    E_NOINTERFACE,  \
    MAPI_E_NOT_FOUND

SCODE BASED_DEBUG Common_Scodes[] =
{
    MAPI_E_BAD_CHARWIDTH,
    MAPI_E_CALL_FAILED,
    MAPI_E_INVALID_ENTRYID,
    MAPI_E_INVALID_OBJECT,
    MAPI_E_INVALID_PARAMETER,
    MAPI_E_NO_ACCESS,
    MAPI_E_NO_SUPPORT,
    MAPI_E_NOT_ENOUGH_MEMORY,
    MAPI_E_UNKNOWN_FLAGS,
    S_OK
};

SCODE BASED_DEBUG MAPILogon_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    MAPI_E_LOGON_FAILED,
    S_OK
};

SCODE BASED_DEBUG MAPIAllocateBuffer_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    S_OK
};

SCODE BASED_DEBUG MAPIAllocateMore_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    S_OK
};

SCODE BASED_DEBUG MAPIFreeBuffer_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IUnknown_QueryInterface_Scodes[] =
{
    E_INVALIDARG,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IUnknown_GetLastError_Scodes[] =
{
    MAPI_E_EXTENDED_ERROR,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_CopyTo_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_E_INVALID_TYPE,
    MAPI_E_FOLDER_CYCLE,
    MAPI_E_DECLINE_COPY,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_CopyProps_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_W_PARTIAL_COMPLETION,
    MAPI_E_INVALID_TYPE,
    MAPI_E_FOLDER_CYCLE,
    MAPI_E_DECLINE_COPY,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_DeleteProps_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_E_INVALID_TYPE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetIDsFromNames_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_E_TABLE_TOO_BIG,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetLastError_Scodes[] =
{
    MAPI_E_EXTENDED_ERROR,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetNamesFromIDs_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetPropList_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetProps_Scodes[] =
{
    MAPI_E_NOT_FOUND,
    MAPI_E_OBJECT_DELETED,
    MAPI_W_ERRORS_RETURNED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_OpenProperty_Scodes[] =
{
    MAPI_E_INTERFACE_NOT_SUPPORTED,
    MAPI_E_NOT_FOUND,
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_SetProps_Scodes[] =
{
    MAPI_E_COMPUTED,
    MAPI_E_UNEXPECTED_TYPE,
    MAPI_E_INVALID_TYPE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_SaveChanges_Scodes[] =
{
    MAPI_E_NOT_ENOUGH_DISK,
    MAPI_E_OBJECT_CHANGED,
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IStream_Read_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Write_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Seek_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_SetSize_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Tell_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_LockRegion_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_UnlockRegion_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Clone_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_CopyTo_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Revert_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Stat_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Commit_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPITable_GetLastError_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_Advise_Scodes[] =
{
    S_OK
};
SCODE BASED_DEBUG IMAPITable_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_GetStatus_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SetColumns_Scodes[] =
{
    MAPI_E_BUSY,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_QueryColumns_Scodes[] =
{
    MAPI_E_BUSY,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_GetRowCount_Scodes[] =
{
    MAPI_E_BUSY,
    MAPI_W_APPROX_COUNT,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_SeekRow_Scodes[] =
{
    MAPI_E_INVALID_BOOKMARK,
    MAPI_E_UNABLE_TO_COMPLETE,
    MAPI_W_POSITION_CHANGED,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_SeekRowApprox_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_QueryPosition_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_FindRow_Scodes[] =
{
    MAPI_E_INVALID_BOOKMARK,
    MAPI_E_NOT_FOUND,
    MAPI_W_POSITION_CHANGED,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_Restrict_Scodes[] =
{
    MAPI_E_BUSY,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_CreateBookmark_Scodes[] =
{
    MAPI_E_UNABLE_TO_COMPLETE,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_FreeBookmark_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SortTable_Scodes[] =
{
    MAPI_E_TOO_COMPLEX,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_QuerySortOrder_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_QueryRows_Scodes[] =
{
    MAPI_E_INVALID_BOOKMARK,
    MAPI_W_POSITION_CHANGED,
    S_OK
};

SCODE BASED_DEBUG IMAPITable_Abort_Scodes[] =
{
    MAPI_E_UNABLE_TO_ABORT,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_ExpandRow_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_CollapseRow_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_WaitForCompletion_Scodes[] =
{
    MAPI_E_TIMEOUT,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_GetCollapseState_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SetCollapseState_Scodes[] = {S_OK};


SCODE BASED_DEBUG IMAPISession_LogOff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Release_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_GetLastError_Scodes[] =
{
    MAPI_E_EXTENDED_ERROR,
    S_OK
};
SCODE BASED_DEBUG IMAPISession_GetMsgStoresTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_GetStatusTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_OpenMsgStore_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_OpenAddressBook_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPISession_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    S_OK
};

SCODE BASED_DEBUG IMAPISession_OpenProfileSection_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Advise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_MessageOptions_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_QueryDefaultMessageOpt_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_EnumAdrTypes_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_QueryIdentity_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMsgStore_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMsgStore_SetReceiveFolder_Scodes[] =
{
    MAPI_E_BAD_CHARWIDTH,
    MAPI_E_NOT_FOUND,
    S_OK
};

SCODE BASED_DEBUG IMsgStore_GetReceiveFolder_Scodes[] =
{
    MAPI_E_BAD_CHARWIDTH,
    S_OK
};

SCODE BASED_DEBUG IMsgStore_GetReceiveFolderTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_StoreLogoff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_Advise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_GetOutgoingQueue_Scodes[] = {
    MAPI_E_NO_SUPPORT,
    S_OK};
SCODE BASED_DEBUG IMsgStore_SetLockState_Scodes[] = {
    MAPI_E_NO_SUPPORT,
    MAPI_E_NOT_FOUND,
    S_OK};
SCODE BASED_DEBUG IMsgStore_FinishedMsg_Scodes[] = {
    MAPI_E_NO_SUPPORT,
    S_OK};
SCODE BASED_DEBUG IMsgStore_AbortSubmit_Scodes[] = {
    MAPI_E_UNABLE_TO_ABORT,
    MAPI_E_NOT_IN_QUEUE,
    S_OK};
SCODE BASED_DEBUG IMsgStore_NotifyNewMail_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPIFolder_GetContentsTable_Scodes[] =
{
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetHierarchyTable_Scodes[] =
{
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SaveContentsSort_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CreateMessage_Scodes[] =
{
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CopyMessages_Scodes[] =
{
    E_NOINTERFACE,
    MAPI_E_SUBMITTED,
    MAPI_E_DECLINE_COPY,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_DeleteMessages_Scodes[] =
{
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CreateFolder_Scodes[] =
{
    E_NOINTERFACE,
    MAPI_E_COLLISION,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CopyFolder_Scodes[] =
{
    E_NOINTERFACE,
    MAPI_E_COLLISION,
    MAPI_E_FOLDER_CYCLE,
    MAPI_E_DECLINE_COPY,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_DeleteFolder_Scodes[] =
{
    MAPI_E_HAS_FOLDERS,
    MAPI_E_HAS_MESSAGES,
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetSearchCriteria_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetSearchCriteria_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    MAPI_E_CORRUPT_STORE,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetReadFlags_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetMessageStatus_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetMessageStatus_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_EmptyFolder_Scodes[] =
{
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMessage_GetAttachmentTable_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMessage_OpenAttach_Scodes[] =
{
    MAPI_E_NOT_FOUND,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMessage_CreateAttach_Scodes[] =
{
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMessage_DeleteAttach_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMessage_GetRecipientTable_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMessage_ModifyRecipients_Scodes[] =
{
    MAPI_E_NOT_FOUND,
    S_OK
};

SCODE BASED_DEBUG IMessage_SubmitMessage_Scodes[] =
{
    MAPI_E_NO_RECIPIENTS,
    MAPI_E_NON_STANDARD,
    S_OK
};

SCODE BASED_DEBUG IMessage_SetReadFlag_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IAttach_SaveChanges_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IAddrBook_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    S_OK
};

SCODE BASED_DEBUG IAddrBook_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_CreateOneOff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_ResolveName_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_Address_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_Details_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_RecipOptions_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_QueryDefaultRecipOpt_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_ButtonPress_Scodes[] = {S_OK};
SCODE BASED_DEBUG IABContainer_GetContentsTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IABContainer_GetHierarchyTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG INotifObj_ChangeEvMask_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_ChangePassword_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_FlushQueues_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_SettingsDialog_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_ValidateState_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPILogon_Scodes[] = {
    MAPI_E_LOGON_FAILED,
    S_OK};
SCODE BASED_DEBUG SMAPI_MAPILogoff_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIFreeBuffer_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISendMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISendDocuments_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIFindNext_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIReadMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISaveMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIDeleteMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIAddress_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIResolveName_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIDetails_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMSProvider_Logon_Scodes[] = {
    MAPI_E_UNCONFIGURED,
    MAPI_E_FAILONEPROVIDER,
    MAPI_E_STRING_TOO_LONG,
    MAPI_E_LOGON_FAILED,
    MAPI_E_CORRUPT_STORE,
    MAPI_E_USER_CANCEL,
    S_OK};
SCODE BASED_DEBUG IMSProvider_Deinit_Scodes[] = {
    S_OK};
SCODE BASED_DEBUG IMSProvider_Shutdown_Scodes[] = {
    S_OK};

SCODE BASED_DEBUG IMSProvider_Init_Scodes[] = {
    MAPI_E_VERSION,
    S_OK};
SCODE BASED_DEBUG IMSProvider_SpoolerLogon_Scodes[] = {
    MAPI_E_LOGON_FAILED,
    S_OK};

SCODE BASED_DEBUG IMSLogon_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    S_OK
};

SCODE BASED_DEBUG IMSLogon_OpenStatusEntry_Scodes[] = {
    S_OK};

SCODE BASED_DEBUG IMSLogon_CompareEntryIDs_Scodes[] = {
    S_OK};

SCODE BASED_DEBUG IMSLogon_Advise_Scodes[] = {
    S_OK};
SCODE BASED_DEBUG IMSLogon_Unadvise_Scodes[] = {
    S_OK};
SCODE BASED_DEBUG IMSLogon_Logoff_Scodes[] = {
    S_OK};
#endif

/* DBGMEM ------------------------------------------------------------------- */

#undef  INTERFACE
#define INTERFACE struct _DBGMEM
DECLARE_INTERFACE(DBGMEM_)
{
    BEGIN_INTERFACE
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE; \
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE; \
    STDMETHOD_(ULONG,Release)       (THIS) PURE; \
    STDMETHOD_(void FAR*, Alloc)    (THIS_ ULONG cb) PURE; \
    STDMETHOD_(void FAR*, Realloc)  (THIS_ void FAR* pv, ULONG cb) PURE; \
    STDMETHOD_(void, Free)          (THIS_ void FAR* pv) PURE; \
    STDMETHOD_(ULONG, GetSize)      (THIS_ void FAR* pv) PURE; \
    STDMETHOD_(int, DidAlloc)       (THIS_ void FAR* pv) PURE; \
    STDMETHOD_(void, HeapMinimize)  (THIS) PURE; \
};

extern DBGMEM_Vtbl vtblDBGMEM;

typedef struct _DBGMEM  DBGMEM,  FAR *PDBGMEM;
typedef struct _BLK     BLK,     *PBLK;
typedef struct _BLK UNALIGNED * PUABLK;
typedef struct _BLKTAIL BLKTAIL, *PBLKTAIL;

struct _DBGMEM {
    DBGMEM_Vtbl *       lpVtbl;
    ULONG               cRef;
    LPMALLOC            pmalloc;
    char                szSubsys[16];
    ULONG               ulAllocNum;
    ULONG               ulAllocAt;
    ULONG               ulFailureAt;
    BOOL                fCheckOften;
    BOOL                fUnleakable;
    ULONG               cbVirtual;
    BOOL                fFillRandom;
    int                 cbExtra;
    int                 cbTail;
    PBLK                pblkHead;
#if defined(_WIN32) && defined(_X86_)
    CRITICAL_SECTION    cs;
#endif
};

#define NCALLERS    12

struct _BLK {
    PDBGMEM         pdbgmem;        /* pointer to the allocator */
    PBLK            pblkNext;       /* next link in chain of allocated blocks */
    PBLK            pblkPrev;       /* prev link in chain of allocated blocks */
    ULONG           ulAllocNum;     /* internal allocation number */
    BOOL            fUnleakable;    /* TRUE if leak code should ignore block */
    #if defined(_WIN32) && defined(_X86_)
    FARPROC         pfnCallers[NCALLERS];
    #endif
    PBLKTAIL        pblktail;       /* pointer to block tail */
};

struct _BLKTAIL {
    PBLK            pblk;           /* pointer back to beginning of the block */
};

#define PblkToPv(pblk)          ((LPVOID)((PBLK)(pblk) + 1))
#define PvToPblk(pblk)          ((PBLK)(pv) - 1)
#define PblkClientSize(pblk)    ((ULONG)((char *)(pblk)->pblktail - (char *)PblkToPv(pblk)))
#define PblkAllocSize(pblk)     (PblkClientSize(pblk) + sizeof(BLK) + (pblk)->pdbgmem->cbTail)

#if defined(_WIN32) && defined(_X86_)
#define DBGMEM_EnterCriticalSection(pdbgmem)    \
        EnterCriticalSection(&(pdbgmem)->cs)
#define DBGMEM_LeaveCriticalSection(pdbgmem)    \
        LeaveCriticalSection(&(pdbgmem)->cs)
#else
#define DBGMEM_EnterCriticalSection(pdbgmem)
#define DBGMEM_LeaveCriticalSection(pdbgmem)
#endif

#define INITGUID
#include <initguid.h>

DEFINE_OLEGUID(DBGMEM_IID_IUnknown,     0x00000000L, 0, 0);
DEFINE_OLEGUID(DBGMEM_IID_IMalloc,      0x00000002L, 0, 0);
DEFINE_OLEGUID(DBGMEM_IID_IBaseMalloc,  0x000203FFL, 0, 0);

/* Forward Declarations ----------------------------------------------------- */

BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, char ** pszReason);
BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, char * pszFunc);
STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void * pv);

/* Call Stack (_WIN32) ------------------------------------------------------- */

#if defined(_WIN32) && defined(_X86_)

#ifdef _WIN95
#define dwStackLimit    0x00400000      /*  4MB for Windows 95 */
#else
#define dwStackLimit    0x00010000      /*  64KB for NT */
#endif

void EXPORTDBG __cdecl GetCallStack(DWORD *pdwCaller, int cSkip, int cFind)
{
    DWORD * pdwStack;
    DWORD * pdwStackPrev = (DWORD *)0;
    DWORD   dwCaller;

    __asm mov pdwStack, ebp

    memset(pdwCaller, 0, cFind * sizeof(DWORD));

    while (cSkip + cFind > 0)
    {
        pdwStack = (DWORD *)*pdwStack;

        if (    pdwStack <= (DWORD *)dwStackLimit
            ||  pdwStackPrev >= pdwStack
            ||  IsBadReadPtr(pdwStack, 2 * sizeof(DWORD)))
            break;

        dwCaller = *(pdwStack + 1);

        if (dwCaller <= dwStackLimit)
            break;
        else if (cSkip > 0)
            cSkip -= 1;
        else
        {
            *pdwCaller++ = dwCaller;
            cFind -= 1;

            pdwStackPrev = pdwStack;
        }
    }
}

#endif

/* Virtual Memory Support (_WIN32) ------------------------------------------- */

#if defined(_WIN32) && (defined(_X86_) || defined(_PPC_) || defined(_MIPS_))

#define PAGE_SIZE       4096
#define PvToVMBase(pv)  ((void *)((ULONG)pv & 0xFFFF0000))

BOOL VMValidatePvEx(void *pv, ULONG cbCluster)
{
    void *  pvBase;
    BYTE *  pb;

    pvBase = PvToVMBase(pv);

    pb = (BYTE *)pvBase + sizeof(ULONG);

    while (pb < (BYTE *)pv) {
        if (*pb++ != 0xAD) {
            TrapSz1("VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv);
            return(FALSE);
        }
    }

    if (cbCluster != 1)
    {
        ULONG cb = *((ULONG *)pvBase);
        ULONG cbPad = 0;

        if (cb % cbCluster)
            cbPad = (cbCluster - (cb % cbCluster));

        if (cbPad)
        {
            BYTE *pbMac;

            pb = (BYTE *)pv + cb;
            pbMac = pb + cbPad;

            while (pb < pbMac)
            {
                if (*pb++ != 0xBC)
                {
                    TrapSz1("VMValidatePvEx(pv=%08lX): Block trailer has been "
                        "overwritten", pv);
                    return(FALSE);
                }
            }
        }
    }

    return(TRUE);
}

void * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
    return VMAllocEx(cb, 1);
}

void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
    ULONG   cbAlloc;
    void *  pvR;
    void *  pvC;
    ULONG   cbPad   = 0;

    // a cluster size of 0 means don't use the virtual allocator.

    AssertSz(cbCluster != 0, "Cluster size is zero.");

    if (cb > 0x100000)
        return(0);

    if (cb % cbCluster)
        cbPad = (cbCluster - (cb % cbCluster));

    cbAlloc = sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1;
    cbAlloc -= cbAlloc % PAGE_SIZE;
    cbAlloc += PAGE_SIZE;

    pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS);

    if (pvR == 0)
        return(0);

    pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

    if (pvC != pvR)
    {
        VirtualFree(pvR, 0, MEM_RELEASE);
        return(0);
    }

    *(ULONG *)pvC = cb;

    memset((BYTE *)pvC + sizeof(ULONG), 0xAD,
        (UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE);

    if (cbPad)
        memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC,
            (UINT) cbPad);

    return((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE));
}

void EXPORTDBG __cdecl VMFree(void *pv)
{
    VMFreeEx(pv, 1);
}

void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster)
{
    VMValidatePvEx(pv, cbCluster);

    if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE))
        TrapSz2("VMFreeEx(pv=%08lX): VirtualFree failed (%08lX)",
            pv, GetLastError());
}

void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb)
{
    return VMReallocEx(pv, cb, 1);
}

void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster)
{
    void *  pvNew = 0;
    ULONG   cbCopy;

    VMValidatePvEx(pv, cbCluster);

    cbCopy = *(ULONG *)PvToVMBase(pv);
    if (cbCopy > cb)
        cbCopy = cb;

    pvNew = VMAllocEx(cb, cbCluster);

    if (pvNew)
    {
        MemCopy(pvNew, pv, cbCopy);
        VMFreeEx(pv, cbCluster);
    }

    return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(void *pv)
{
    return VMGetSizeEx(pv, 1);
}

ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG cbCluster)
{
    return(*(ULONG *)PvToVMBase(pv));
}

#endif

/* Virtual Memory Support (WIN16) ------------------------------------------- */

#ifdef WIN16

#define PvToVMBase(pv)  ((void *)((ULONG)pv & 0xFFFF0000))

BOOL VMValidatePvEx(void *pv, ULONG cbCluster)
{
    void *  pvBase;
    BYTE *  pb;

    pvBase = PvToVMBase(pv);

    pb = (BYTE *)pvBase + sizeof(ULONG);

    while (pb < (BYTE *)pv) {
        if (*pb++ != 0xAD) {
            TrapSz1("VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv);
            return(FALSE);
        }
    }

    if (cbCluster != 1)
    {
        ULONG cb = *((ULONG *)pvBase);
        ULONG cbPad = 0;

        if (cb % cbCluster)
            cbPad = (cbCluster - (cb % cbCluster));

        if (cbPad)
        {
            BYTE *pbMac;

            pb = (BYTE *)pv + cb;
            pbMac = pb + cbPad;

            while (pb < pbMac)
            {
                if (*pb++ != 0xBC)
                {
                    TrapSz1("VMValidatePvEx(pv=%08lX): Block trailer has been "
                        "overwritten", pv);
                    return(FALSE);
                }
            }
        }
    }

    return(TRUE);
}

BOOL VMValidatePv(void *pv)
{
    return VMValidatePvEx(pv, 1);
}

void * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
    return VMAllocEx(cb, 1);
}

void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
    HGLOBAL hGlobal;
    ULONG   cbAlloc;
    ULONG   cbAllocFromSys;
    void *  pvAlloc;
    ULONG   cbPad   = 0;

    if (cb > 0x10000 - sizeof(ULONG))
        return(0);

    if (cb % cbCluster)
        cbPad = (cbCluster - (cb % cbCluster));

    cbAlloc = sizeof(ULONG) + cb + cbPad;

    if (cbAlloc > 0x10000)
        return(0);

#ifdef SIMPLE_MAPI
    hGlobal = GlobalAlloc(GPTR | GMEM_SHARE, cbAlloc);
#else   
    hGlobal = GlobalAlloc(GPTR, cbAlloc);
#endif  

    if (hGlobal == 0)
        return(0);

    cbAllocFromSys = GlobalSize(hGlobal);

    Assert(cbAllocFromSys >= cbAlloc);

    cbAlloc = cbAllocFromSys;

    pvAlloc = GlobalLock(hGlobal);

    if (pvAlloc == 0) {
        GlobalFree(hGlobal);
        return(0);
    }

    Assert(((ULONG)pvAlloc & 0x0000FFFF) == 0);

    *(ULONG *)pvAlloc = cb;

    memset((BYTE *)pvAlloc + sizeof(ULONG), 0xAD,
        (size_t)(cbAlloc - cb - cbPad - sizeof(ULONG)));

    if (cbPad)
        memset((BYTE *)pvAlloc + cbAlloc - cbPad, 0xBC, (size_t) cbPad);

    return((BYTE *)pvAlloc + (cbAlloc - cb - cbPad));
}

void EXPORTDBG __cdecl VMFree(void *pv)
{
    VMFreeEx(pv, 1);
}

void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster)
{
    if (VMValidatePvEx(pv, cbCluster))
    {
        HGLOBAL hGlobal;
        ULONG cb = *(ULONG *)PvToVMBase(pv);

        memset(pv, 0xFE, (size_t)cb);

        hGlobal = (HGLOBAL)((ULONG)pv >> 16);
        GlobalFree(hGlobal);
    }
}

void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb)
{
    return VMReallocEx(pv, cb, 1);
}

void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster)
{
    void *  pvNew = 0;
    ULONG   cbCopy;

    if (VMValidatePvEx(pv, cbCluster)) {
        cbCopy = *(ULONG *)PvToVMBase(pv);
        if (cbCopy > cb)
            cbCopy = cb;

        pvNew = VMAllocEx(cb, cbCluster);

        if (pvNew) {
            MemCopy(pvNew, pv, (size_t)cbCopy);
            VMFreeEx(pv, cbCluster);
        }
    }

    return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(void *pv)
{
    return VMGetSizeEx(pv, 1);
}

ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG ulCluster)
{
    if (VMValidatePvEx(pv, ulCluster))
        return(*(ULONG *)PvToVMBase(pv));

    return(0);
}

#endif

/* Virtual Memory Support (Others) ------------------------------------------ */
/*
 *  The VM Allocators do not currently work on:
 *      ALPHA
 *      MAC
 */
#if defined(MAC) || defined(_ALPHA_)
#define VMAlloc(cb)             0
#define VMAllocEx(cb, ul)       0
#define VMRealloc(pv, cb)       0
#define VMReallocEx(pv, cb, ul) 0
#define VMFree(pv)
#define VMFreeEx(pv, ul)
#define VMGetSize(pv)           0
#define VMGetSizeEx(pv, ul)     0
#endif

/* PblkEnqueue / PblkDequeue ------------------------------------------------ */

void PblkEnqueue(PBLK pblk)
{
    pblk->pblkNext          = pblk->pdbgmem->pblkHead;
    pblk->pblkPrev          = 0;
    pblk->pdbgmem->pblkHead = pblk;

    if (pblk->pblkNext)
        pblk->pblkNext->pblkPrev = pblk;

}

void PblkDequeue(PBLK pblk)
{
    if (pblk->pblkNext)
        pblk->pblkNext->pblkPrev = pblk->pblkPrev;

    if (pblk->pblkPrev)
        pblk->pblkPrev->pblkNext = pblk->pblkNext;
    else
        pblk->pdbgmem->pblkHead  = pblk->pblkNext;
}

/* QueryInterface/AddRef/Release -------------------------------------------- */

STDMETHODIMP DBGMEM_QueryInterface(PDBGMEM pdbgmem, REFIID riid, LPVOID FAR* ppvObj)
{
    if (memcmp(riid, &DBGMEM_IID_IBaseMalloc, sizeof(IID)) == 0) {
        pdbgmem->pmalloc->lpVtbl->AddRef(pdbgmem->pmalloc);
        *ppvObj = pdbgmem->pmalloc;
        return(0);
    }

    if (memcmp(riid, &DBGMEM_IID_IMalloc, sizeof(IID)) == 0 ||
        memcmp(riid, &DBGMEM_IID_IUnknown, sizeof(IID)) == 0) {
        ++pdbgmem->cRef;
        *ppvObj = pdbgmem;
        return(0);
    }

    *ppvObj = NULL; /* OLE requires zeroing [out] parameter */
    return(ResultFromScode(E_NOINTERFACE));
}

STDMETHODIMP_(ULONG) DBGMEM_AddRef(PDBGMEM pdbgmem)
{
    ULONG cRef;

    DBGMEM_EnterCriticalSection(pdbgmem);
    cRef = ++pdbgmem->cRef;
    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(cRef);
}

STDMETHODIMP_(ULONG) DBGMEM_Release(PDBGMEM pdbgmem)
{
    ULONG       cRef;
    LPMALLOC    pmalloc;

    DBGMEM_EnterCriticalSection(pdbgmem);
    cRef = --pdbgmem->cRef;
    DBGMEM_LeaveCriticalSection(pdbgmem);

    if (cRef == 0) {
        DBGMEM_CheckMemFn(pdbgmem, TRUE);
        pmalloc = pdbgmem->pmalloc;
        pdbgmem->lpVtbl = 0;
        #if defined(_WIN32) && defined(_X86_)
        DeleteCriticalSection(&pdbgmem->cs);
        #endif
        pmalloc->lpVtbl->Free(pmalloc, pdbgmem);
        pmalloc->lpVtbl->Release(pmalloc);
    }

    return(cRef);
}

/* IMalloc::Alloc ----------------------------------------------------------- */

STDMETHODIMP_(void FAR *) DBGMEM_Alloc(PDBGMEM pdbgmem, ULONG cb)
{
    PBLK    pblk;
    ULONG   cbAlloc;
    LPVOID  pvAlloc = 0;
    BYTE    bFill   = 0xFA;

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pdbgmem->fCheckOften)
        DBGMEM_CheckMemFn(pdbgmem, FALSE);

    cbAlloc = sizeof(BLK) + cb + pdbgmem->cbTail;

    if (pdbgmem->ulFailureAt != 0)
    {
        if (pdbgmem->ulFailureAt != pdbgmem->ulAllocAt)
            ++pdbgmem->ulAllocAt;
        else
            cbAlloc = 0;
    }

    if (cbAlloc < cb)
        pblk = 0;
    else if (pdbgmem->cbVirtual)
        pblk = VMAllocEx(cbAlloc, pdbgmem->cbVirtual);
    else
        pblk = (PBLK)pdbgmem->pmalloc->lpVtbl->Alloc(pdbgmem->pmalloc, cbAlloc);

    if (pblk) {
        pblk->pdbgmem       = pdbgmem;
        pblk->ulAllocNum    = ++pdbgmem->ulAllocNum;
        pblk->fUnleakable   = FALSE;
        pblk->pblktail      = (PBLKTAIL)((char *)pblk + sizeof(BLK) + cb);

        if (!pdbgmem->cbVirtual)
            *((PUABLK UNALIGNED * )
            &((struct _BLKTAIL UNALIGNED *) pblk->pblktail)->pblk) = pblk;

        PblkEnqueue(pblk);

        #if defined(_WIN32) && defined(_X86_)
        GetCallStack((DWORD *)pblk->pfnCallers, 0, NCALLERS);
        #endif

        if (pdbgmem->fCheckOften)
            DBGMEM_CheckMemFn(pdbgmem, FALSE);

        pvAlloc = PblkToPv(pblk);

        if (pdbgmem->fFillRandom)
            bFill = (BYTE)pblk->ulAllocNum;

        memset(pvAlloc, bFill, (size_t)cb);

        if (pdbgmem->cbExtra)
            memset(pblk->pblktail + 1, 0xAE, pdbgmem->cbExtra * sizeof(ULONG));
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(pvAlloc);
}

/* IMalloc::Realloc --------------------------------------------------------- */

STDMETHODIMP_(void FAR *) DBGMEM_Realloc(PDBGMEM pdbgmem, void FAR* pv, ULONG cb)
{
    ULONG   cbAlloc;
    LPVOID  pvAlloc = 0;
    BYTE    bFill = 0xFA;

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pdbgmem->fCheckOften)
        DBGMEM_CheckMemFn(pdbgmem, FALSE);

    if (pv == 0) {
        TrapSz1("DBGMEM_Realloc(pv=NULL,cb=%ld): IMalloc::Realloc is being used allocate a new memory block.  Explicit use of IMalloc::Alloc is preferred.", cb);
        pvAlloc = DBGMEM_Alloc(pdbgmem, cb);
    } else if (cb == 0) {
        TrapSz1("DBGMEM_Realloc(pv=%08lX,cb=0): IMalloc::Realloc is being used to free a memory block.  Explicit use of IMalloc::Free is preferred.", pv);
        DBGMEM_Free(pdbgmem, pv);
        pvAlloc = 0;
    } else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_Realloc")) {
        PBLK    pblk    = PvToPblk(pv);
        ULONG   cbOld   = PblkClientSize(pblk);
        PBLK    pblkNew;

        PblkDequeue(pblk);

        cbAlloc = sizeof(BLK) + cb + pdbgmem->cbTail;

        if (pdbgmem->ulFailureAt != 0)
        {
            if (pdbgmem->ulFailureAt != pdbgmem->ulAllocAt)
                ++pdbgmem->ulAllocAt;
            else
                cbAlloc = 0;
        }

        if (cbAlloc < cb)
            pblkNew = 0;
        else if (pdbgmem->cbVirtual)
            pblkNew = (PBLK)VMReallocEx(pblk, cbAlloc, pdbgmem->cbVirtual);
        else
            pblkNew = (PBLK)pdbgmem->pmalloc->lpVtbl->Realloc(pdbgmem->pmalloc, pblk, cbAlloc);

        if (pblkNew == 0) {
            PblkEnqueue(pblk);
            pvAlloc = 0;
        } else {
            pblkNew->pblktail = (PBLKTAIL)((char *)pblkNew + sizeof(BLK) + cb);

            if (!pdbgmem->cbVirtual)
                *((PUABLK UNALIGNED * )
                &((struct _BLKTAIL UNALIGNED *) pblkNew->pblktail)->pblk) = pblkNew;

            PblkEnqueue(pblkNew);

            pvAlloc = PblkToPv(pblkNew);

            if (pdbgmem->fFillRandom)
                bFill = (BYTE)pblkNew->ulAllocNum;

            if (cb > cbOld)
                memset((char *)pvAlloc + cbOld, bFill, (size_t)(cb - cbOld));

            if (pdbgmem->cbExtra)
                memset(pblkNew->pblktail + 1, 0xAE, pdbgmem->cbExtra * sizeof(ULONG));
        }
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(pvAlloc);
}

/* IMalloc::Free ------------------------------------------------------------ */

STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void FAR * pv)
{
    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pdbgmem->fCheckOften)
        DBGMEM_CheckMemFn(pdbgmem, FALSE);

    if (pv && DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_Free")) {
        PBLK pblk = PvToPblk(pv);

        PblkDequeue(pblk);

        memset(pblk, 0xDC, (size_t)PblkAllocSize(pblk));

        if (pdbgmem->cbVirtual)
            VMFreeEx(pblk, pdbgmem->cbVirtual);
        else
            pdbgmem->pmalloc->lpVtbl->Free(pdbgmem->pmalloc, pblk);
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* IMalloc::GetSize --------------------------------------------------------- */

STDMETHODIMP_(ULONG) DBGMEM_GetSize(PDBGMEM pdbgmem, void FAR * pv)
{
    ULONG ulResult = (ULONG)(-1);

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pv == 0)
        TrapSz("Although technically not an error, I bet you didn't really want to pass a NULL pointer to IMalloc::GetSize, did you?  I hope you can deal with a size of -1, because that's the offical answer.  Good luck.");
    else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_GetSize"))
        ulResult = PblkClientSize(PvToPblk(pv));

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(ulResult);
}

/* IMalloc::DidAlloc -------------------------------------------------------- */

STDMETHODIMP_(int) DBGMEM_DidAlloc(PDBGMEM pdbgmem, void FAR * pv)
{
    PBLK    pblk;
    char *  pszReason;
    int     iResult = 0;

    DBGMEM_EnterCriticalSection(pdbgmem);

    for (pblk = pdbgmem->pblkHead; pblk; pblk = pblk->pblkNext)
    {
        AssertSz2(DBGMEM_ValidatePblk(pdbgmem,pblk,&pszReason)==TRUE,
                 "Block header (pblk=%08lX) is invalid\n%s",
                 pblk, pszReason);
        if (PblkToPv(pblk) == pv) {
            iResult = 1;
            break;
        }
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(iResult);
}

/* IMalloc::HeapMinimize ---------------------------------------------------- */

STDMETHODIMP_(void) DBGMEM_HeapMinimize(PDBGMEM pdbgmem)
{
    pdbgmem->pmalloc->lpVtbl->HeapMinimize(pdbgmem->pmalloc);
}

/* DBGMEM_ValidatePblk ------------------------------------------------------ */

BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, char ** pszReason)
{
    #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
    if (IsBadWritePtr(pblk, sizeof(BLK))) {
        *pszReason = "Block header cannot be written to";
        goto err;
    }
    #endif

    if (pblk->pdbgmem != pdbgmem) {
        *pszReason = "Block header does not have correct pointer back to allocator";
        goto err;
    }

    if (pblk->pblkNext) {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (IsBadWritePtr(pblk->pblkNext, sizeof(BLK))) {
            *pszReason = "Block header has invalid next link pointer";
            goto err;
        }
        #endif

        if (pblk->pblkNext->pblkPrev != pblk) {
            *pszReason = "Block header points to a next block which doesn't point back to it";
            goto err;
        }
    }

    if (pblk->pblkPrev) {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (IsBadWritePtr(pblk->pblkPrev, sizeof(BLK))) {
            *pszReason = "Block header has invalid prev link pointer";
            goto err;
        }
        #endif

        if (pblk->pblkPrev->pblkNext != pblk) {
            *pszReason = "Block header points to a prev block which doesn't point back to it";
            goto err;
        }
    } else if (pdbgmem->pblkHead != pblk) {
        *pszReason = "Block header has a zero prev link but the allocator doesn't believe it is the first block";
        goto err;
    }

    if (pblk->ulAllocNum > pdbgmem->ulAllocNum) {
        *pszReason = "Block header has an invalid internal allocation number";
        goto err;
    }

    if (!pdbgmem->cbVirtual) {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (IsBadWritePtr(pblk->pblktail, pdbgmem->cbTail)) {
            *pszReason = "Block header has invalid pblktail pointer";
            goto err;
        }
        #endif

        if (*((PUABLK UNALIGNED * )
            &((struct _BLKTAIL UNALIGNED *) pblk->pblktail)->pblk) != pblk) {
       