rac.h ===
//-----------------------------------------------------------------------------
//
//
//  File: basetrac.h
//
//  Description:    Defines class designed for tracking call stacks.  Designed
//      for use in tracking Addref/Release... but can also be used to track
//      any user
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/28/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __BASETRAC_H__
#define __BASETRAC_H__

#include "baseobj.h"

#define DEFAULT_CALL_STACKS         10
#define DEFAULT_CALL_STACK_DEPTH    20
#define TRACKING_OBJ_SIG            'jbOT'

#ifndef DEBUG //Retail

//In retail... just map to straight COM AddRef/Release functionality
typedef CBaseObject             CBaseTrackingObject;

#else //DEBUG - add support for tracking Addref/Release by default

class   CDebugTrackingObject;
typedef CDebugTrackingObject    CBaseTrackingObject;

#endif //DEBUG

//---[ eObjectTrackingReasons ]------------------------------------------------
//
//
//  Description:   An enum that describes some basic tracking reasons.  If 
//      an implementor of a subclass need more reasons, then simply create
//      a subclass specific enum that start with the value of
//      TRACKING_OBJECT_START_USER_DEFINED.
//  
//-----------------------------------------------------------------------------
enum eObjectTrackingReasons
{
    TRACKING_OBJECT_UNUSED = 0,
    TRACKING_OBJECT_CONSTRUCTOR,
    TRACKING_OBJECT_DESTRUCTOR,
    TRACKING_OBJECT_ADDREF,
    TRACKING_OBJECT_RELEASE,
    TRACKING_OBJECT_START_USER_DEFINED,
};

//---[ CCallStackEntry_Base ]--------------------------------------------------
//
//
//  Description: 
//      The base class for store call stack entry information.  This class 
//      is not inteded to be instantiated directly... and exists primarily
//      for use by a debugger extension.
//  Hungarian: (think CDB and windbg command to get call stacks) 
//      kbeb, pkbeb
//  
//-----------------------------------------------------------------------------
class CCallStackEntry_Base
{
  public:
    DWORD       m_dwCallStackType;
    DWORD       m_dwCallStackDepth;
    DWORD_PTR  *m_pdwptrCallers;
    CCallStackEntry_Base();
    void GetCallers();
};

//---[ CCallStackEntry ]-------------------------------------------------------
//
//
//  Description: 
//      A default subclas of CCallStackEntry_Base.  Provides storage for 
//      a call stack of depth DEFAULT_CALL_STACK_DEPTH.
//  Hungarian: 
//      kbe, pkbe
//  
//-----------------------------------------------------------------------------
class CCallStackEntry : public CCallStackEntry_Base
{
  protected:
    //Storage for call stack data
    DWORD_PTR   m_rgdwptrCallers[DEFAULT_CALL_STACK_DEPTH];
  public:
    CCallStackEntry() 
    {
        m_pdwptrCallers = m_rgdwptrCallers;
        m_dwCallStackDepth = DEFAULT_CALL_STACK_DEPTH;
    };
};

//---[ CDebugTrackingObject_Base ]----------------------------------------------
//
//
//  Description: 
//      A class that provides the neccessary primitives for tracking call
//      stacks.  Like CCallStackEntry_Base it is designed to be used through
//      a subclass that provides storage for the required number call stack 
//      entries.
//
//      To effectively create a subclass... you will need to create a subclass
//      That contains (or allocates) the memory required to hold the 
//      tracking data, and set the following 3 protected member variables:
//          m_cCallStackEntries
//          m_cbCallStackEntries
//          m_pkbebCallStackEntries
//  Hungarian: 
//      tracb, ptracb
//  
//-----------------------------------------------------------------------------
class CDebugTrackingObject_Base : public CBaseObject
{
  private:
    DWORD   m_dwSignature;
    //A running total of the number of stack entires recorded
    //The index of the next call stack entry is defined as:
    //      m_cCurrentStackEntries % m_cCallStackEntries
    DWORD   m_cCurrentStackEntries; 
    
  protected:
    //The following 2 values are stored in memory as a way to have size
    //independent implementations... child classes may wish to implement 
    //a subclass with more (or less) entries... or store more debug 
    //information.  By having an explicit self-decriptive in-memory format, 
    //we can use a single implementation to handle getting the call stack 
    //and a single debugger extension can be used to dump all sizes of entries.
    DWORD                   m_cCallStackEntries;    //Number of callstacks kept
    DWORD                   m_cbCallStackEntries;   //Size of each callstack entry
    
    CCallStackEntry_Base   *m_pkbebCallStackEntries;
    
    //Used to internally log TRACKING events
    void LogTrackingEvent(DWORD dwTrackingReason);
  public:
    CDebugTrackingObject_Base();
    ~CDebugTrackingObject_Base();
};

//---[ CDebugTrackingObject ]---------------------------------------------------
//
//
//  Description: 
//      The default subclass for CDebugTrackingObject_Base.  It provides storage
//      for DEFAULT_CALL_STACKS CCallStackEntry objects
//  Hungarian: 
//      trac, ptrac
//  
//-----------------------------------------------------------------------------
class CDebugTrackingObject : 
    public CDebugTrackingObject_Base
{
  protected:
    CCallStackEntry m_rgkbeCallStackEntriesDefault[DEFAULT_CALL_STACKS];
  public:
    CDebugTrackingObject::CDebugTrackingObject()
    {
        m_cbCallStackEntries = sizeof(CCallStackEntry);
        m_cCallStackEntries = DEFAULT_CALL_STACKS;
        m_pkbebCallStackEntries = m_rgkbeCallStackEntriesDefault;
        LogTrackingEvent(TRACKING_OBJECT_CONSTRUCTOR);
    };
    CDebugTrackingObject::~CDebugTrackingObject()
    {
        LogTrackingEvent(TRACKING_OBJECT_DESTRUCTOR);
    };
    ULONG AddRef();
    ULONG Release();
};

#endif //__BASETRAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\cdns.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        cdns.h

   Abstract:

        This module defines the DNS connection class.

   Author:

           Rohan Phillips    ( Rohanp )    07-May-1998

   Project:


   Revision History:

--*/

# ifndef _ADNS_CLIENT_HXX_
# define _ADNS_CLIENT_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/
#include <dnsreci.h>

//
//  Redefine the type to indicate that this is a call-back function
//
typedef  ATQ_COMPLETION   PFN_ATQ_COMPLETION;

/************************************************************
 *     Symbolic Constants
 ************************************************************/

//
//  Valid & Invalid Signatures for Client Connection object
//  (Ims Connection USed/FRee)
//
# define   DNS_CONNECTION_SIGNATURE_VALID    'DNSU'
# define   DNS_CONNECTION_SIGNATURE_FREE     'DNSF'

//
// POP3 requires a minimum of 10 minutes before a timeout
// (SMTP doesn't specify, but might as well follow POP3)
//
# define   MINIMUM_CONNECTION_IO_TIMEOUT        (10 * 60)   // 10 minutes
//
//

#define DNS_TCP_DEFAULT_PACKET_LENGTH   (0x4000)

enum DNSLASTIOSTATE
     {
       DNS_READIO, DNS_WRITEIO
     };

typedef struct _DNS_OVERLAPPED
{
    OVERLAPPED   Overlapped;
    DNSLASTIOSTATE    LastIoState;
}   DNS_OVERLAPPED;

/************************************************************
 *    Type Definitions
 ************************************************************/

/*++
    class CLIENT_CONNECTION

      This class is used for keeping track of individual client
       connections established with the server.

      It maintains the state of the connection being processed.
      In addition it also encapsulates data related to Asynchronous
       thread context used for processing the request.

--*/
class CAsyncDns
{
 private:


    ULONG   m_signature;            // signature on object for sanity check

    LONG    m_cPendingIoCount;

    LONG    m_cThreadCount;

    DWORD    m_cbReceived;
    
    DWORD    m_BytesToRead;

    DWORD    m_dwIpServer;

    BOOL    m_fUdp;

    BOOL    m_FirstRead;

    PDNS_MESSAGE_BUFFER m_pMsgRecv;

    BYTE  *m_pMsgRecvBuf;

    PDNS_MESSAGE_BUFFER m_pMsgSend;

    BYTE *m_pMsgSendBuf;

    WORD  m_cbSendBufSize;

    SOCKADDR_IN     m_RemoteAddress;
    
    PATQ_CONTEXT    m_pAtqContext;

    SOCKET  m_DnsSocket;         // socket for this connection

    BOOL m_fIsGlobalDnsList;

 protected:

    DWORD         m_dwFlags;
    char          m_HostName [MAX_PATH];
    CDnsServerList *m_pTcpRegIpList;


    //
    // The overlapped structure for reads (one outstanding read at a time)
    // -- writes will dynamically allocate them
    //

    DNS_OVERLAPPED m_ReadOverlapped;
    DNS_OVERLAPPED m_WriteOverlapped;

    SOCKET QuerySocket( VOID) const
      { return ( m_DnsSocket); }


    PATQ_CONTEXT QueryAtqContext( VOID) const
      { return ( m_pAtqContext); }

    LPOVERLAPPED QueryAtqOverlapped( void ) const
    { return ( m_pAtqContext == NULL ? NULL : &m_pAtqContext->Overlapped ); }

    DWORD QueryDnsServer() { return m_dwIpServer; }

    BOOL IsUdp() { return m_fUdp; }

    //
    // DNS server failover is disabled if this query was a TCP failover query
    // kicked off because of UDP truncation.
    //
    BOOL FailoverDisabled() { return ((m_dwFlags == DNS_FLAGS_NONE) && !m_fUdp); }

public:

    CAsyncDns();

    virtual  ~CAsyncDns(VOID);


    DNS_STATUS DnsSendRecord();

    DNS_STATUS Dns_OpenTcpConnectionAndSend();

    DNS_STATUS Dns_Send( );
    DNS_STATUS SendPacket( void);

    DNS_STATUS Dns_QueryLib(
        DNS_NAME pszQuestionName,
        WORD wQuestionType,
        DWORD dwFlags,
        BOOL fUdp,
        CDnsServerList *pTcpRegIpList,
        BOOL fIsGlobalDnsList);

    SOCKET Dns_CreateSocket( IN  INT         SockType );
    

    //BOOL MakeDnsConnection(void);
    //
    //  IsValid()
    //  o  Checks the signature of the object to determine
    //
    //  Returns:   TRUE on success and FALSE if invalid.
    //
    BOOL IsValid( VOID) const
    {
        return ( m_signature == DNS_CONNECTION_SIGNATURE_VALID);
    }

    //-------------------------------------------------------------------------
    // Virtual method that MUST be defined by derived classes.
    //
    // Processes a completed IO on the connection for the client.
    //
    // -- Calls and maybe called from the Atq functions.
    //
    virtual BOOL ProcessClient(
                                IN DWORD            cbWritten,
                                IN DWORD            dwCompletionStatus,
                                IN OUT  OVERLAPPED * lpo
                              ) ;

    CDnsServerList *GetDnsList()
    {
        return m_pTcpRegIpList;
    }

    //
    // Returns a copy the IP_ARRAY in the DNS-serverlist for this CAsyncDns
    // Returns NULL if the DNS-serverlist is the default global-list of DNS
    // servers on this box. Otherwise, the pipArray returned should be deleted
    // using ReleaseDnsIpArray() by the caller. On failure to allocate memory,
    // FALSE is returned.
    //

    BOOL GetDnsIpArrayCopy(PIP_ARRAY *ppipArray)
    {
        if(m_fIsGlobalDnsList) {
            *ppipArray = NULL;
            return TRUE;
        }

        return m_pTcpRegIpList->CopyList(ppipArray);
    }
        
    void ReleaseDnsIpArray(PIP_ARRAY pipArray)
    {
        if(pipArray)
            delete pipArray;
    }

    LONG IncPendingIoCount(void)
    {
        LONG RetVal;

        RetVal = InterlockedIncrement( &m_cPendingIoCount );

        return RetVal;
    }

    LONG DecPendingIoCount(void) { return   InterlockedDecrement( &m_cPendingIoCount );}

    LONG IncThreadCount(void)
    {
        LONG RetVal;

        RetVal = InterlockedIncrement( &m_cThreadCount );

        return RetVal;
    }

    LONG DecThreadCount(void) { return   InterlockedDecrement( &m_cThreadCount );}

    BOOL ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            );

    BOOL WriteFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            );

    BOOL ProcessReadIO(IN      DWORD InputBufferLen,
                       IN      DWORD dwCompletionStatus,
                       IN OUT  OVERLAPPED * lpo);

    void DisconnectClient(void);

    // Virtual functions to implement app-specific processing
    virtual void DnsProcessReply(
        IN DWORD dwStatus,
        IN PDNS_RECORD pRecordList) = 0;

    virtual BOOL RetryAsyncDnsQuery(BOOL fUdp) = 0;

public:

    //
    //  LIST_ENTRY object for storing client connections in a list.
    //
    LIST_ENTRY  m_listEntry;

    LIST_ENTRY & QueryListEntry( VOID)
     { return ( m_listEntry); }

};

typedef CAsyncDns * PCAsyncDns;

class CAsyncMxDns : public CAsyncDns
{
protected:
    //
    // SMTP DNS specific members
    //
    DWORD                  m_LocalPref;
    BOOL                   m_SeenLocal;
    DWORD                  m_Index;
    DWORD                  m_Weight [100];
    DWORD                  m_Prefer [100];
    BOOL                   m_fUsingMx;
    char                   m_FQDNToDrop [MAX_PATH];
    PSMTPDNS_RECS          m_AuxList;
    BOOL                   m_fMxLoopBack;

public:
    CAsyncMxDns(char *MyFQDN);

    BOOL GetMissingIpAddresses(PSMTPDNS_RECS pDnsList);
    BOOL GetIpFromDns(PSMTPDNS_RECS pDnsRec, DWORD Count);
    BOOL CheckMxLoopback();

    void ProcessMxRecord(PDNS_RECORD pnewRR);
    void ProcessARecord(PDNS_RECORD pnewRR);
    BOOL SortMxList(void);
    BOOL CheckList(void);

    void DnsProcessReply(
        IN DWORD dwStatus,
        IN PDNS_RECORD pRecordList);

    //
    // The following functions allow SMTP to do SMTP connection specific
    // processing after the MX resolution is over
    //
    virtual void HandleCompletedData(DNS_STATUS) = 0;
    virtual BOOL IsShuttingDown() = 0;
    virtual BOOL IsAddressMine(DWORD dwIp) = 0;
};

//
// Auxiliary functions
//

INT ShutAndCloseSocket( IN SOCKET sock);

DWORD ResolveHost(
    LPSTR pszHost,
    PIP_ARRAY pipDnsServers,
    DWORD fOptions,
    DWORD *rgdwIpAddresses,
    DWORD *pcbIpAddresses);

# endif

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\baseobj.h ===
/*==========================================================================*\

    Module:        baseobj.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Owner:         mikepurt

    Descriptions:  Provide OLE COM consistent reference counting.

\*==========================================================================*/


#ifndef __BASEOBJ_H__
#define __BASEOBJ_H__

#include "dbgtrace.h" //make sure we get _ASSERT

class CBaseObject {
public:
    CBaseObject()
    { m_lReferences = 1; };  // consistent with OLE COM
    
    virtual ~CBaseObject() {};
    
    // Included so the vtable is in a standard format ...
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
          IID FAR& riid,
          LPVOID FAR* ppvObj) { return E_NOTIMPL; } 

    ULONG   AddRef()
    { return (ULONG)(InterlockedExchangeAdd(&m_lReferences, 1) + 1); };
    
    ULONG   Release() 
    {
        LONG lRef;
        
        lRef = InterlockedExchangeAdd(&m_lReferences, -1) - 1;
        
        _ASSERT(lRef >= 0);
        _ASSERT(lRef < 0x00100000);  // Sanity check against freed memory.
        
        if (0 == lRef)
            delete this;    // Don't touch any member vars after this.
        
        return (ULONG)lRef;
    };

protected:
    LONG m_lReferences;
        
    CBaseObject(CBaseObject&);  // Force an error in instances where a copy constructor
                                //   was needed, but none was provided.
};

#endif  // __BASEOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\cdoconstimsg.h ===
#ifndef __IConstructIMessageFromIMailMsg_INTERFACE_DEFINED__
#define __IConstructIMessageFromIMailMsg_INTERFACE_DEFINED__

/* interface IConstructIMessageFromIMailMsg */
/* [unique][helpstring][dual][uuid][hidden][object] */ 


EXTERN_C const IID IID_IConstructIMessageFromIMailMsg;

    MIDL_INTERFACE("CD000080-8B95-11D1-82DB-00C04FB1625D")
    IConstructIMessageFromIMailMsg : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Construct( 
            /* [in] */ CdoEventType eEventType,
            /* [in] */ IUnknown __RPC_FAR *pMailMessage) = 0;
        
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\crchash.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.h

Abstract:
	CRC Hash function
*/

#ifndef __CRCHASH_H
#define __CRCHASH_H

#define POLY 0x48000000L    /* 31-bit polynomial (avoids sign problems) */

extern long CrcTable[128];
void crcinit();

DWORD CRCHash(IN const BYTE * Key, IN DWORD KeyLength);

DWORD CRCHashNoCase(IN const BYTE * Key, IN DWORD KeyLength);

DWORD CRCHashWithPrecompute(IN DWORD	PreComputedHash,	IN const BYTE * Key, IN DWORD KeyLength);

DWORD
CRCChainingHash(	DWORD	sum,
					const	BYTE*	(&Key), 
					BYTE	bTerm
					) ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\codepageconvert.h ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: CodePageConvert.h
//
// Functions:
//   HrCodePageConvert
//   HrCodePageConvert
//   HrCodePageConvertFree
//   HrCodePageConvertInternal
//
// History:
// aszafer  2000/03/29  created
//-------------------------------------------------------------

#ifndef _CODEPAGECONVERT_H_
#define _CODEPAGECONVERT_H_

#include "windows.h"

#define TEMPBUFFER_WCHARS 316

HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source String 
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR pszTargetString,          // p to prealloc buffer where target string is returned
    IN int cbTargetStringBuffer);      // cbytes in prealloc buffer for target string

HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source string
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR * ppszTargetString);      // p to where target string is returned

VOID HrCodePageConvertFree (LPSTR pszTargetString); //p to memory allocated by HrCodePageConvert   

HRESULT HrCodePageConvertInternal (
    IN UINT uiSourceCodePage,               // source code page
    IN LPSTR pszSourceString,               // source string
    IN UINT uiTargetCodePage,               // target code page
    OUT LPSTR pszTargetString,              // target string or NULL
    IN int cbTargetStringBuffer,           // cb in target string or 0 
    OUT LPSTR* ppszTargetString );          // NULL or p to where target string is returned


HRESULT HrConvertToUnicodeWithAlloc(
    IN  UINT  uiSourceCodePage,
    IN  LPSTR pszSourceString,
    OUT LPWSTR* ppwszTargetString);

HRESULT HrConvertToUnicodeWithAlloc(
    IN  UINT  uiSourceCodePage,
    IN  DWORD dwcbSourceString,
    IN  LPSTR pszSourceString,
    OUT LPWSTR* ppwszTargetString);

VOID CodePageConvertFree (
    IN  LPWSTR pwszTargetString); //p to memory allocated by ConvertToUnicodeWithAlloc

HRESULT wcsutf8cmpi(
    IN  LPWSTR pwszStr1,    // two strings to compare
    IN  LPCSTR pszStr2);

#endif //_CODEPAGECONVERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\cstream.h ===
#pragma once

class CImpIStream : public IStream
{
	private:
        LONG	m_cRef;

	protected:
		ULONG	m_cbSeek;
		STATSTG m_statstg;

	public:
		CImpIStream(void);
		CImpIStream(PVOID pvData,ULONG cbSize);
		virtual ~CImpIStream(void);

		//IUnknown
        STDMETHODIMP QueryInterface( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppvObject);
        
        STDMETHODIMP_(ULONG) AddRef(void);
        
        STDMETHODIMP_(ULONG) Release(void);

		// IStream
        STDMETHODIMP Read(
        	void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);

        STDMETHODIMP CopyTo( 
            IStream __RPC_FAR *pstm,
            ULARGE_INTEGER cb,
            ULARGE_INTEGER __RPC_FAR *pcbRead,
            ULARGE_INTEGER __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Commit( 
            DWORD grfCommitFlags);
        
        STDMETHODIMP Revert( void);
        
        STDMETHODIMP LockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP UnlockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP Stat( 
            STATSTG __RPC_FAR *pstatstg,
            DWORD grfStatFlag);
        
        STDMETHODIMP Clone( 
            IStream __RPC_FAR *__RPC_FAR *ppstm);
};

class CStreamMem : public CImpIStream
{
	private:
		PVOID	m_pvData;
		BOOL	m_fExternalData;
	public:
		CStreamMem(void);
		CStreamMem(PVOID pvData,ULONG cbSize);
		~CStreamMem(void);

		// IStream
        STDMETHODIMP Read(
        	void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);
        
        STDMETHODIMP CopyTo( 
            IStream __RPC_FAR *pstm,
            ULARGE_INTEGER cb,
            ULARGE_INTEGER __RPC_FAR *pcbRead,
            ULARGE_INTEGER __RPC_FAR *pcbWritten);

		STDMETHODIMP GetPointerFromStream(PVOID *ppv,DWORD *pdwSize);
};

class CStreamFile : public CImpIStream
{
	private:
		HANDLE m_hFile;
		BOOL m_fCloseHandle;
		BOOL m_fReadOnly;

	public:
		CStreamFile(HANDLE hFile,BOOL fCloseHandle = FALSE, BOOL fReadOnly = FALSE);
		~CStreamFile(void);

		// IStream
        STDMETHODIMP Read(
        	void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);

        STDMETHODIMP Commit( 
            DWORD grfCommitFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\dbgdumpx.h ===
/*++

Copyright (c) 1990, 1998 Microsoft Corporation

Module Name:

    ptdbgext.h
    *WAS* kdextlib.h

Abstract:

    Kernel Debugger extensions to allow the quick creation of CDB/Windbg
    debugger extensions.  Used in conjunction with the following:
        transdbg.h  - Minimal debugging extension helper macros
        ptdbgext.h  - Auto dump of classes and structures
        _dbgdump.h  - Used to define struct/class descriptors in 1 pass

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created
    21-Aug-1995 Milans  Copied for use in Mup Kernel Extensions
    19-April-1998 Mikeswa Modified for Exchange Platinum Transport

--*/

#ifndef _PTDBGEXT_H_
#define _PTDBGEXT_H_

#include <windef.h>
#include <transdbg.h>

#ifndef PTDBGEXT_USE_FRIEND_CLASSES
#include <_dbgdump.h>
#endif //PTDBGEXT_USE_FRIEND_CLASSES

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

//If you not include ntdefs.h, you will need this, otherwise set _ANSI_UNICODE_STRINGS_DEFINED_
#ifndef _ANSI_UNICODE_STRINGS_DEFINED_
//Define string types needed
typedef struct _ANSI_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} ANSI_STRING;
typedef ANSI_STRING *PANSI_STRING;
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt
#endif //_ANSI_UNICODE_STRINGS_DEFINED_


#define PT_DEBUG_EXTENSION(x) TRANS_DEBUG_EXTENSION(x)

//Define potentially exported functions... include those you want to expose in your def file
extern PT_DEBUG_EXTENSION(_help);    //display help based on ExtensionNames & Extensions
extern PT_DEBUG_EXTENSION(_dump);    //Dumps structs/classes as defined by macros in _dbgdump.h
extern PT_DEBUG_EXTENSION(_dumpoffsets);    //Dumps offsets of structs/classes as defined by macros in _dbgdump.h

#define DEFINE_EXPORTED_FUNCTIONS \
    PT_DEBUG_EXTENSION(help) { _help(DebugArgs);};   \
    PT_DEBUG_EXTENSION(dump) { _dump(DebugArgs);};

//
// The help strings printed out
//

extern LPSTR ExtensionNames[];

extern LPSTR Extensions[];

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.  A "bit mask" type falls in the same
// category.  For the puposes of this extension lib, a "enum" and "bit mask" may be
// interchanged.  The key difference is that an "enum" will tested for a single value, while
// a "bit mask" will be testes using a bitwise OR against all values.  The ENUM_VALUE_DESCRIPTOR
// and BIT_MASK_DESCRIPTOR are interchangable.
//
// The macros to define the necessary structures can be found in _dbgdump.h.
//
typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef struct _BIT_MASK_DESCRIPTOR {
    ULONG   BitmaskValue;
    LPSTR   BitmaskName;
} BIT_MASK_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeLong,
    FieldTypeUShort,
    FieldTypeShort,
    FieldTypeGuid,
    FieldTypePointer,
    FieldTypePWStr, //used for LPWSTR fields
    FieldTypePStr,  //used for LPSTR fields
    FieldTypeWStrBuffer, //used for WCHAR[] fields
    FieldTypeStrBuffer, //used for CHAR[] fields
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeClassSignature,
    FieldTypeDword,
    FieldTypeListEntry,
    FieldTypeFiletime,            //Displays file time in human-readable format
    FieldTypeLocalizedFiletime,   //As above, but adjusts for TZ first
    FieldTypeEmbeddedStruct,      //dumps an embedded structure (4th param is struct array)
    FieldTypeNULL
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    ULONG            Offset;      // The offset of the field in the structure
    union {
        VOID                   *pDescriptor;     // Generic Auxillary information - used by Field4 macro
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
        BIT_MASK_DESCRIPTOR    *pBitMaskDescriptor; // Auxillary information for bitmasks.
        VOID                   *pStructDescriptor;
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define NULL_FIELD {FieldTypeNULL, NULL, 0, NULL}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRITOR_ {
    LPSTR             StructName;
    ULONG             StructSize;
    FIELD_DESCRIPTOR  *FieldDescriptors;
} STRUCT_DESCRIPTOR;

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

extern PWINDBG_OUTPUT_ROUTINE               g_lpOutputRoutine;
extern PWINDBG_GET_EXPRESSION               g_lpGetExpressionRoutine;
extern PWINDBG_GET_SYMBOL                   g_lpGetSymbolRoutine;
extern PWINDBG_READ_PROCESS_MEMORY_ROUTINE  g_lpReadMemoryRoutine;
extern HANDLE                               g_hCurrentProcess;

typedef PWINDBG_OLD_EXTENSION_ROUTINE PEXTLIB_INIT_ROUTINE;
extern PEXTLIB_INIT_ROUTINE               g_pExtensionInitRoutine;

#define    SETCALLBACKS() \
    g_lpOutputRoutine = pExtensionApis->lpOutputRoutine; \
    g_lpGetExpressionRoutine = pExtensionApis->lpGetExpressionRoutine; \
    g_lpGetSymbolRoutine = pExtensionApis->lpGetSymbolRoutine; \
    g_hCurrentProcess = hCurrentProcess; \
    g_lpReadMemoryRoutine = \
        ((pExtensionApis->nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
            NULL : pExtensionApis->lpReadProcessMemoryRoutine); \
    g_pExtensionInitRoutine ? (g_pExtensionInitRoutine)(dwCurrentPc, pExtensionApis, szArg) : 0;

#define KdExtReadMemory(a,b,c,d) \
    ((g_lpReadMemoryRoutine) ? \
    g_lpReadMemoryRoutine( (DWORD_PTR)(a), (b), (c), ((DWORD *)d) ) \
 :  ReadProcessMemory( g_hCurrentProcess, (LPCVOID)(a), (b), (c), (d) )) \

#define    PRINTF    g_lpOutputRoutine

VOID
PrintStructFields(
    DWORD_PTR dwAddress,
    VOID *ptr,
    FIELD_DESCRIPTOR *pFieldDescriptors,
    DWORD cIndentLevel
);

BOOL
PrintStringW(
    LPSTR msg,
    PUNICODE_STRING puStr,
    BOOL nl
);

BOOLEAN
GetData(
    DWORD_PTR dwAddress,
    PVOID ptr,
    ULONG size
);

#ifdef __cplusplus
}
#endif //__cplusplus

#endif // _PTDBGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\dns.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dns.h

Abstract:

    Domain Name System (DNS)

    General DNS definitions.

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNS_INCLUDED_
#define _DNS_INCLUDED_


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus



//
//  Basic DNS API definitions
//
//  These are basic definitions used by both DnsAPI and DNS server RPC interface.
//  Since dnsapi.h is not setup for a midl compile, dns.h servers as a common
//  header point with simple definitions used by both.

//
//  Use stdcall for our API conventions
//
//  Explicitly state this as C++ compiler will otherwise
//      assume cdecl.
//

#define DNS_API_FUNCTION    __stdcall

//
//  DNS public types
//

typedef LONG    DNS_STATUS, *PDNS_STATUS;
typedef DWORD   DNS_HANDLE, *PDNS_HANDLE;
typedef DWORD   DNS_APIOP;


//
//  IP Address
//

typedef DWORD   IP_ADDRESS, *PIP_ADDRESS;

#define SIZEOF_IP_ADDRESS            (4)
#define IP_ADDRESS_STRING_LENGTH    (15)

#define IP_STRING( ipAddress )  inet_ntoa( *(struct in_addr *)&(ipAddress) )


//
//  IP Address Array type
//

#if defined(MIDL_PASS)
typedef struct  _IP_ARRAY
{
    DWORD   cAddrCount;
    [size_is( cAddrCount )]  IP_ADDRESS  aipAddrs[];
}
IP_ARRAY, *PIP_ARRAY;

#else

typedef struct  _IP_ARRAY
{
    DWORD       cAddrCount;
    IP_ADDRESS  aipAddrs[1];
}
IP_ARRAY, *PIP_ARRAY;

#endif


//
//  IPv6 Address
//

typedef struct
{
    WORD    IPv6Word[8];
}
IPV6_ADDRESS, *PIPV6_ADDRESS;

#define IPV6_ADDRESS_STRING_LENGTH  (39)


//
//  DNS dotted name
//      - define type simply to clarify arguments
//

#ifdef UNICODE
typedef LPWSTR  DNS_NAME;
#else
typedef LPSTR   DNS_NAME;
#endif

//
//  DNS Text strings
//

#ifdef UNICODE
typedef LPWSTR  DNS_TEXT;
#else
typedef LPSTR   DNS_TEXT;
#endif


//
//  Byte flipping macros
//

#define FlipUnalignedDword( pDword ) \
            (DWORD)ntohl( *(UNALIGNED DWORD *)(pDword) )

#define FlipUnalignedWord( pWord )  \
            (WORD)ntohs( *(UNALIGNED WORD *)(pWord) )

//  Inline is faster, but NO side effects allowed in marco argument

#define InlineFlipUnaligned48Bits( pch )            \
            ( ( *(PUCHAR)(pch)        << 40 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 32 ) |     \
              ( *((PUCHAR)(pch) + 2)  << 24 ) |     \
              ( *((PUCHAR)(pch) + 3)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 4)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 5)  )     )

#define InlineFlipUnalignedDword( pch )             \
            ( ( *(PUCHAR)(pch)        << 24 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 2)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 3)  )     )

#define InlineFlipUnalignedWord( pch )  \
            ( ((WORD)*((PUCHAR)(pch)) << 8) + (WORD)*((PUCHAR)(pch) + 1) )


//
//  Inline byte flipping -- can be done in registers
//

#define INLINE_WORD_FLIP(out, in)   \
        {                           \
            WORD _in = (in);        \
            (out) = (_in << 8) | (_in >> 8);  \
        }
#define INLINE_HTONS(out, in)   INLINE_WORD_FLIP(out, in)
#define INLINE_NTOHS(out, in)   INLINE_WORD_FLIP(out, in)

#define INLINE_DWORD_FLIP(out, in)  \
        {                           \
            DWORD _in = (in);       \
            (out) = ((_in << 8) & 0x00ff0000) | \
                    (_in << 24)               | \
                    ((_in >> 8) & 0x0000ff00) | \
                    (_in >> 24);                \
        }
#define INLINE_NTOHL(out, in) INLINE_DWORD_FLIP(out, in)
#define INLINE_HTONL(out, in) INLINE_DWORD_FLIP(out, in)


//
//  Inline byte flip and write to packet (unaligned)
//

#define INLINE_WRITE_FLIPPED_WORD( pout, in ) \
            INLINE_WORD_FLIP( *((UNALIGNED WORD *)(pout)), in )

#define INLINE_WRITE_FLIPPED_DWORD( pout, in ) \
            INLINE_DWORD_FLIP( *((UNALIGNED DWORD *)(pout)), in )

//
//  Unaligned write without flipping
//

#define WRITE_UNALIGNED_WORD( pout, word ) \
            ( *(UNALIGNED WORD *)(pout) = word )

#define WRITE_UNALIGNED_DWORD( pout, dword ) \
            ( *(UNALIGNED DWORD *)(pout) = dword )




//
//  Basic DNS definitions
//

//
//  DNS port for both UDP and TCP is 53.
//

#define DNS_PORT_HOST_ORDER (0x0035)    // port 53
#define DNS_PORT_NET_ORDER  (0x3500)

#define HOST_ORDER_DNS_PORT DNS_PORT_HOST_ORDER
#define NET_ORDER_DNS_PORT  DNS_PORT_NET_ORDER

//
//  DNS UDP packets no more than 512 bytes
//

#define DNS_RFC_MAX_UDP_PACKET_LENGTH (512)

//  these are going away DO NOT USE!!!
//  1472 is the maximum ethernet IP\UDP payload size
//  without causing fragmentation

#define DNS_UDP_MAX_PACKET_LENGTH               (512)
#define DNS_CLASSICAL_UDP_MAX_PACKET_LENGTH     (512)


//
//  DNS Names limited to 255, 63 in any one label
//

#define DNS_MAX_NAME_LENGTH         (255)
#define DNS_MAX_LABEL_LENGTH        (63)
#define DNS_LABEL_CASE_BYTE_COUNT   (8)

#define DNS_MAX_NAME_BUFFER_LENGTH  (256)
#define DNS_NAME_BUFFER_LENGTH      (256)
#define DNS_LABEL_BUFFER_LENGTH     (64)

//
//  Reverse lookup domain names
//

#define DNS_REVERSE_DOMAIN_STRING ("in-addr.arpa.")

#define DNS_MAX_REVERSE_NAME_LENGTH \
            (IP_ADDRESS_STRING_LENGTH+1+sizeof(DNS_REVERSE_DOMAIN_STRING))

#define DNS_MAX_REVERSE_NAME_BUFFER_LENGTH \
            (DNS_MAX_REVERSE_NAME_LENGTH + 1)


//
//  DNS Text string limited by size representable
//      in a single byte length field

#define DNS_MAX_TEXT_STRING_LENGTH  (255)




//
//  DNS On-The-Wire Structures
//

#include <packon.h>

//
//  DNS Message Header
//

typedef struct _DNS_HEADER
{
    WORD    Xid;

    BYTE    RecursionDesired : 1;
    BYTE    Truncation : 1;
    BYTE    Authoritative : 1;
    BYTE    Opcode : 4;
    BYTE    IsResponse : 1;

    BYTE    ResponseCode : 4;
    BYTE    Broadcast : 1;              // part of DNS reserved, use in WINS
    BYTE    Reserved : 2;
    BYTE    RecursionAvailable : 1;

    WORD    QuestionCount;
    WORD    AnswerCount;
    WORD    NameServerCount;
    WORD    AdditionalCount;
}
DNS_HEADER, *PDNS_HEADER;

//  Question immediately follows header so compressed question name
//      0xC000 | sizeof(DNS_HEADER)

#define DNS_COMPRESSED_QUESTION_NAME  (0xC00C)


//
//  Flags as WORD
//

#define DNS_HEADER_FLAGS(pHead)     ( *((PWORD)(pHead)+1) )


//
//  Swap count bytes
//  Include XID since our XID partitioning will be in host order.
//

#define SWAP_COUNT_BYTES(header)    \
        {                           \
            PDNS_HEADER _head = (header); \
            INLINE_HTONS(_head->Xid,            _head->Xid             ); \
            INLINE_HTONS(_head->QuestionCount,  _head->QuestionCount   ); \
            INLINE_HTONS(_head->AnswerCount,    _head->AnswerCount     ); \
            INLINE_HTONS(_head->NameServerCount,_head->NameServerCount ); \
            INLINE_HTONS(_head->AdditionalCount,_head->AdditionalCount ); \
        }

//
//  Question name follows header
//

#define DNS_OFFSET_TO_QUESTION_NAME     sizeof(DNS_HEADER)


//
//  Packet extraction macros
//

#define QUESTION_NAME_FROM_HEADER( _header_ ) \
            ( (PCHAR)( (PDNS_HEADER)(_header_) + 1 ) )

#define ANSWER_FROM_QUESTION( _question_ ) \
            ( (PCHAR)( (PDNS_QUESTION)(_question_) + 1 ) )


//
//  DNS Question
//

typedef struct _DNS_QUESTION
{
    //  Always preceeded by question name.

    WORD    QuestionType;
    WORD    QuestionClass;

} DNS_QUESTION, *PDNS_QUESTION;


//
//  DNS Resource Record
//

typedef struct _DNS_WIRE_RECORD
{
    //  Always preceded by an owner name.

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    ResourceDataLength;

    //  Followed by resource data.

} DNS_WIRE_RECORD, *PDNS_WIRE_RECORD;

#include <packoff.h>


//
//  DNS Query Types
//

#define DNS_OPCODE_QUERY            0  // Query
#define DNS_OPCODE_IQUERY           1  // Obsolete: IP to name
#define DNS_OPCODE_SERVER_STATUS    2  // Obsolete: DNS ping
#define DNS_OPCODE_UNKNOWN          3  // Unknown
#define DNS_OPCODE_NOTIFY           4  // Notify
#define DNS_OPCODE_UPDATE           5  // Update

//
//  DNS response codes.
//
//  Sent in the "ResponseCode" field of a DNS_HEADER.
//

#define DNS_RCODE_NOERROR       0
#define DNS_RCODE_FORMERR       1
#define DNS_RCODE_SERVFAIL      2
#define DNS_RCODE_NXDOMAIN      3
#define DNS_RCODE_NOTIMPL       4
#define DNS_RCODE_REFUSED       5
#define DNS_RCODE_YXDOMAIN      6
#define DNS_RCODE_YXRRSET       7
#define DNS_RCODE_NXRRSET       8
#define DNS_RCODE_NOTAUTH       9
#define DNS_RCODE_NOTZONE       10
#define DNS_RCODE_MAX           15

#define DNS_RCODE_BADSIG        16
#define DNS_RCODE_BADKEY        17
#define DNS_RCODE_BADTIME       18

#define DNS_EXTRCODE_BADSIG         DNS_RCODE_BADSIG
#define DNS_EXTRCODE_BADKEY         DNS_RCODE_BADKEY
#define DNS_EXTRCODE_BADTIME        DNS_RCODE_BADTIME

#define DNS_RCODE_NO_ERROR          DNS_RCODE_NOERROR
#define DNS_RCODE_FORMAT_ERROR      DNS_RCODE_FORMERR
#define DNS_RCODE_SERVER_FAILURE    DNS_RCODE_SERVFAIL
#define DNS_RCODE_NAME_ERROR        DNS_RCODE_NXDOMAIN
#define DNS_RCODE_NOT_IMPLEMENTED   DNS_RCODE_NOTIMPL


//
//  DNS Classes
//
//  Classes are on the wire as WORDs.
//
//  _CLASS_ defines in host order.
//  _RCLASS_ defines in net byte order.
//
//  Generally we'll avoid byte flip and test class in net byte order.
//

#define DNS_CLASS_INTERNET  0x0001      //  1
#define DNS_CLASS_CSNET     0x0002      //  2
#define DNS_CLASS_CHAOS     0x0003      //  3
#define DNS_CLASS_HESIOD    0x0004      //  4
#define DNS_CLASS_NONE      0x00fe      //  254
#define DNS_CLASS_ALL       0x00ff      //  255
#define DNS_CLASS_ANY       0x00ff      //  255

#define DNS_RCLASS_INTERNET 0x0100      //  1
#define DNS_RCLASS_CSNET    0x0200      //  2
#define DNS_RCLASS_CHAOS    0x0300      //  3
#define DNS_RCLASS_HESIOD   0x0400      //  4
#define DNS_RCLASS_NONE     0xfe00      //  254
#define DNS_RCLASS_ALL      0xff00      //  255
#define DNS_RCLASS_ANY      0xff00      //  255



//
//  DNS Record Types
//
//  _TYPE_ defines are in host byte order.
//  _RTYPE_ defines are in net byte order.
//
//  Generally always deal with types in host byte order as we index
//  resource record functions by type.
//

#define DNS_TYPE_ZERO       0x0000

//  RFC 1034/1035
#define DNS_TYPE_A          0x0001      //  1
#define DNS_TYPE_NS         0x0002      //  2
#define DNS_TYPE_MD         0x0003      //  3
#define DNS_TYPE_MF         0x0004      //  4
#define DNS_TYPE_CNAME      0x0005      //  5
#define DNS_TYPE_SOA        0x0006      //  6
#define DNS_TYPE_MB         0x0007      //  7
#define DNS_TYPE_MG         0x0008      //  8
#define DNS_TYPE_MR         0x0009      //  9
#define DNS_TYPE_NULL       0x000a      //  10
#define DNS_TYPE_WKS        0x000b      //  11
#define DNS_TYPE_PTR        0x000c      //  12
#define DNS_TYPE_HINFO      0x000d      //  13
#define DNS_TYPE_MINFO      0x000e      //  14
#define DNS_TYPE_MX         0x000f      //  15
#define DNS_TYPE_TEXT       0x0010      //  16

//  RFC 1183
#define DNS_TYPE_RP         0x0011      //  17
#define DNS_TYPE_AFSDB      0x0012      //  18
#define DNS_TYPE_X25        0x0013      //  19
#define DNS_TYPE_ISDN       0x0014      //  20
#define DNS_TYPE_RT         0x0015      //  21

//  RFC 1348
#define DNS_TYPE_NSAP       0x0016      //  22
#define DNS_TYPE_NSAPPTR    0x0017      //  23

//  RFC 2065    (DNS security)
#define DNS_TYPE_SIG        0x0018      //  24
#define DNS_TYPE_KEY        0x0019      //  25

//  RFC 1664    (X.400 mail)
#define DNS_TYPE_PX         0x001a      //  26

//  RFC 1712    (Geographic position)
#define DNS_TYPE_GPOS       0x001b      //  27

//  RFC 1886    (IPv6 Address)
#define DNS_TYPE_AAAA       0x001c      //  28

//  RFC 1876    (Geographic location)
#define DNS_TYPE_LOC        0x001d      //  29

//  RFC 2065    (Secure negative response)
#define DNS_TYPE_NXT        0x001e      //  30

//  RFC 2052    (Service location)
#define DNS_TYPE_SRV        0x0021      //  33

//  ATM Standard something-or-another
#define DNS_TYPE_ATMA       0x0022      //  34

//
//  Query only types (1035, 1995)
//
#define DNS_TYPE_TKEY       0x00f9      //  249
#define DNS_TYPE_TSIG       0x00fa      //  250
#define DNS_TYPE_IXFR       0x00fb      //  251
#define DNS_TYPE_AXFR       0x00fc      //  252
#define DNS_TYPE_MAILB      0x00fd      //  253
#define DNS_TYPE_MAILA      0x00fe      //  254
#define DNS_TYPE_ALL        0x00ff      //  255
#define DNS_TYPE_ANY        0x00ff      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//
#define DNS_TYPE_WINS       0xff01      //  64K - 255
#define DNS_TYPE_WINSR      0xff02      //  64K - 254
#define DNS_TYPE_NBSTAT     (DNS_TYPE_WINSR)


//
//  DNS Record Types -- Net Byte Order
//

#define DNS_RTYPE_A             0x0100      //  1
#define DNS_RTYPE_NS            0x0200      //  2
#define DNS_RTYPE_MD            0x0300      //  3
#define DNS_RTYPE_MF            0x0400      //  4
#define DNS_RTYPE_CNAME         0x0500      //  5
#define DNS_RTYPE_SOA           0x0600      //  6
#define DNS_RTYPE_MB            0x0700      //  7
#define DNS_RTYPE_MG            0x0800      //  8
#define DNS_RTYPE_MR            0x0900      //  9
#define DNS_RTYPE_NULL          0x0a00      //  10
#define DNS_RTYPE_WKS           0x0b00      //  11
#define DNS_RTYPE_PTR           0x0c00      //  12
#define DNS_RTYPE_HINFO         0x0d00      //  13
#define DNS_RTYPE_MINFO         0x0e00      //  14
#define DNS_RTYPE_MX            0x0f00      //  15
#define DNS_RTYPE_TEXT          0x1000      //  16

//  RFC 1183
#define DNS_RTYPE_RP            0x1100      //  17
#define DNS_RTYPE_AFSDB         0x1200      //  18
#define DNS_RTYPE_X25           0x1300      //  19
#define DNS_RTYPE_ISDN          0x1400      //  20
#define DNS_RTYPE_RT            0x1500      //  21

//  RFC 1348
#define DNS_RTYPE_NSAP          0x1600      //  22
#define DNS_RTYPE_NSAPPTR       0x1700      //  23

//  RFC 2065    (DNS security)
#define DNS_RTYPE_SIG           0x1800      //  24
#define DNS_RTYPE_KEY           0x1900      //  25

//  RFC 1664    (X.400 mail)
#define DNS_RTYPE_PX            0x1a00      //  26

//  RFC 1712    (Geographic position)
#define DNS_RTYPE_GPOS          0x1b00      //  27

//  RFC 1886    (IPv6 Address)
#define DNS_RTYPE_AAAA          0x1c00      //  28

//  RFC 1876    (Geographic location)
#define DNS_RTYPE_LOC           0x1d00      //  29

//  RFC 2065    (Secure negative response)
#define DNS_RTYPE_NXT           0x1e00      //  30

//  RFC 2052    (Service location)
#define DNS_RTYPE_SRV           0x2100      //  33

//  ATM Standard something-or-another
#define DNS_RTYPE_ATMA          0x2200      //  34

//
//  Query only types (1035, 1995)
//
#define DNS_RTYPE_TKEY          0xf900      //  249
#define DNS_RTYPE_TSIG          0xfa00      //  250
#define DNS_RTYPE_IXFR          0xfb00      //  251
#define DNS_RTYPE_AXFR          0xfc00      //  252
#define DNS_RTYPE_MAILB         0xfd00      //  253
#define DNS_RTYPE_MAILA         0xfe00      //  254
#define DNS_RTYPE_ALL           0xff00      //  255
#define DNS_RTYPE_ANY           0xff00      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//
#define DNS_RTYPE_WINS          0x01ff      //  64K - 255
#define DNS_RTYPE_WINSR         0x02ff      //  64K - 254




//
//  Record type specific definitions
//

//
//  ATMA (ATM address type) formats
//
//  Define these directly for any environment (ex NT4)
//  without winsock2 ATM support (ws2atm.h)
//

#ifndef  ATMA_E164
#define DNS_ATMA_FORMAT_E164            1
#define DNS_ATMA_FORMAT_AESA            2
#define DNS_ATMA_MAX_ADDR_LENGTH        (20)
#else
#define DNS_ATMA_FORMAT_E164            ATM_E164
#define DNS_ATMA_FORMAT_AESA            ATM_AESA
#define DNS_ATMA_MAX_ADDR_LENGTH        ATM_ADDR_SIZE
#endif

#define DNS_ATMA_AESA_ADDR_LENGTH       (20)
#define DNS_ATMA_MAX_RECORD_LENGTH      (DNS_ATMA_MAX_ADDR_LENGTH+1)


//
//  DNSSEC defs
//

//  DNSSEC algorithms

#define DNSSEC_ALGORITHM_RSAMD5     1
#define DNSSEC_ALGORITHM_NULL       253
#define DNSSEC_ALGORITHM_PRIVATE    254

//  DNSSEC KEY protocol table

#define DNSSEC_PROTOCOL_NONE        0
#define DNSSEC_PROTOCOL_TLS         1
#define DNSSEC_PROTOCOL_EMAIL       2
#define DNSSEC_PROTOCOL_DNSSEC      3
#define DNSSEC_PROTOCOL_IPSEC       4

//  DNSSEC KEY flag field

#define DNSSEC_KEY_FLAG_NOAUTH          0x0001
#define DNSSEC_KEY_FLAG_NOCONF          0x0002
#define DNSSEC_KEY_FLAG_FLAG2           0x0004
#define DNSSEC_KEY_FLAG_EXTEND          0x0008
#define DNSSEC_KEY_FLAG_
#define DNSSEC_KEY_FLAG_FLAG4           0x0010
#define DNSSEC_KEY_FLAG_FLAG5           0x0020

// bits 6,7 are name type

#define DNSSEC_KEY_FLAG_USER            0x0000
#define DNSSEC_KEY_FLAG_ZONE            0x0040
#define DNSSEC_KEY_FLAG_HOST            0x0080
#define DNSSEC_KEY_FLAG_NTPE3           0x00c0

// bits 8-11 are reserved for future use

#define DNSSEC_KEY_FLAG_FLAG8           0x0100
#define DNSSEC_KEY_FLAG_FLAG9           0x0200
#define DNSSEC_KEY_FLAG_FLAG10          0x0400
#define DNSSEC_KEY_FLAG_FLAG11          0x0800

// bits 12-15 are sig field

#define DNSSEC_KEY_FLAG_SIG0            0x0000
#define DNSSEC_KEY_FLAG_SIG1            0x1000
#define DNSSEC_KEY_FLAG_SIG2            0x2000
#define DNSSEC_KEY_FLAG_SIG3            0x3000
#define DNSSEC_KEY_FLAG_SIG4            0x4000
#define DNSSEC_KEY_FLAG_SIG5            0x5000
#define DNSSEC_KEY_FLAG_SIG6            0x6000
#define DNSSEC_KEY_FLAG_SIG7            0x7000
#define DNSSEC_KEY_FLAG_SIG8            0x8000
#define DNSSEC_KEY_FLAG_SIG9            0x9000
#define DNSSEC_KEY_FLAG_SIG10           0xa000
#define DNSSEC_KEY_FLAG_SIG11           0xb000
#define DNSSEC_KEY_FLAG_SIG12           0xc000
#define DNSSEC_KEY_FLAG_SIG13           0xd000
#define DNSSEC_KEY_FLAG_SIG14           0xe000
#define DNSSEC_KEY_FLAG_SIG15           0xf000


//
//  TKEY modes
//

#define DNS_TKEY_MODE_SERVER_ASSIGN         1
#define DNS_TKEY_MODE_DIFFIE_HELLMAN        2
#define DNS_TKEY_MODE_GSS                   3
#define DNS_TKEY_MODE_RESOLVER_ASSIGN       4

//
//  WINS + NBSTAT flag field
//

#define DNS_WINS_FLAG_SCOPE     (0x80000000)
#define DNS_WINS_FLAG_LOCAL     (0x00010000)


//
//  NT4
//

#ifdef DNSNT4

//  Sundown types

#define UINT_PTR    DWORD
#define ULONG_PTR   DWORD
#define DWORD_PTR   DWORD
#define LONG_PTR    LONG
#define INT_PTR     LONG


//
//  DNS API Errors / Status Codes
//
//  For NT5 DNS error\status codes shared by DNS API or RPC interface are in
//      winerror.h
//

#define DNS_ERROR_MASK              0xcc000000

//
//  Response codes mapped to non-colliding errors
//
//  Leave the first 4K of space for this in the assumption that DNS
//  RCODEs may be greatly expanded in some future E-DNS.
//

#define DNS_ERROR_RCODE_NO_ERROR        ERROR_SUCCESS
#define DNS_ERROR_RCODE_FORMAT_ERROR    ( DNS_ERROR_MASK | DNS_RCODE_FORMAT_ERROR    )
#define DNS_ERROR_RCODE_SERVER_FAILURE  ( DNS_ERROR_MASK | DNS_RCODE_SERVER_FAILURE  )
#define DNS_ERROR_RCODE_NAME_ERROR      ( DNS_ERROR_MASK | DNS_RCODE_NAME_ERROR      )
#define DNS_ERROR_RCODE_NOT_IMPLEMENTED ( DNS_ERROR_MASK | DNS_RCODE_NOT_IMPLEMENTED )
#define DNS_ERROR_RCODE_REFUSED         ( DNS_ERROR_MASK | DNS_RCODE_REFUSED         )
#define DNS_ERROR_RCODE_YXDOMAIN        ( DNS_ERROR_MASK | DNS_RCODE_YXDOMAIN        )
#define DNS_ERROR_RCODE_YXRRSET         ( DNS_ERROR_MASK | DNS_RCODE_YXRRSET         )
#define DNS_ERROR_RCODE_NXRRSET         ( DNS_ERROR_MASK | DNS_RCODE_NXRRSET         )
#define DNS_ERROR_RCODE_NOTAUTH         ( DNS_ERROR_MASK | DNS_RCODE_NOTAUTH         )
#define DNS_ERROR_RCODE_NOTZONE         ( DNS_ERROR_MASK | DNS_RCODE_NOTZONE         )

//  Extended TSIG\TKEY RCODEs

#define DNS_ERROR_RCODE_BADSIG          ( DNS_ERROR_MASK | DNS_EXTRCODE_BADSIG       )
#define DNS_ERROR_RCODE_BADKEY          ( DNS_ERROR_MASK | DNS_EXTRCODE_BADKEY       )
#define DNS_ERROR_RCODE_BADTIME         ( DNS_ERROR_MASK | DNS_EXTRCODE_BADTIME      )

#define DNS_ERROR_RCODE_LAST            DNS_ERROR_RCODE_BADTIME


//
//  Packet format
//

#define DNS_INFO_NO_RECORDS                         0x4c000030
#define DNS_ERROR_BAD_PACKET                        0xcc000031
#define DNS_ERROR_NO_PACKET                         0xcc000032
#define DNS_ERROR_RCODE                             0xcc000033
#define DNS_STATUS_PACKET_UNSECURE                  0xcc000034
#define DNS_ERROR_UNSECURE_PACKET                   0xcc000034

//
//  General API errors
//

#define DNS_ERROR_NO_MEMORY                         ERROR_OUTOFMEMORY
#define DNS_ERROR_INVALID_NAME                      ERROR_INVALID_NAME
#define DNS_ERROR_INVALID_DATA                      ERROR_INVALID_DATA
#define DNS_ERROR_INVALID_TYPE                      0xcc000051
#define DNS_ERROR_INVALID_IP_ADDRESS                0xcc000052
#define DNS_ERROR_INVALID_PROPERTY                  0xcc000053
#define DNS_ERROR_TRY_AGAIN_LATER                   0xcc000054
#define DNS_ERROR_NOT_UNIQUE                        0xcc000055
#define DNS_ERROR_NON_RFC_NAME                      0xcc000056

#define DNS_STATUS_FQDN                             0x4c000101
#define DNS_STATUS_DOTTED_NAME                      0x4c000102
#define DNS_STATUS_SINGLE_PART_NAME                 0x4c000103

//
//  Zone errors
//

#define DNS_ERROR_ZONE_DOES_NOT_EXIST               0xcc000101
#define DNS_ERROR_NO_ZONE_INFO                      0xcc000102
#define DNS_ERROR_INVALID_ZONE_OPERATION            0xcc000103
#define DNS_ERROR_ZONE_CONFIGURATION_ERROR          0xcc000104
#define DNS_ERROR_ZONE_HAS_NO_SOA_RECORD            0xcc000105
#define DNS_ERROR_ZONE_HAS_NO_NS_RECORDS            0xcc000106
#define DNS_ERROR_ZONE_LOCKED                       0xcc000107

#define DNS_ERROR_ZONE_CREATION_FAILED              0xcc000110
#define DNS_ERROR_ZONE_ALREADY_EXISTS               0xcc000111
#define DNS_ERROR_AUTOZONE_ALREADY_EXISTS           0xcc000112
#define DNS_ERROR_INVALID_ZONE_TYPE                 0xcc000113
#define DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP      0xcc000114

#define DNS_ERROR_ZONE_NOT_SECONDARY                0xcc000120
#define DNS_ERROR_NEED_SECONDARY_ADDRESSES          0xcc000121
#define DNS_ERROR_WINS_INIT_FAILED                  0xcc000122
#define DNS_ERROR_NEED_WINS_SERVERS                 0xcc000123
#define DNS_ERROR_NBSTAT_INIT_FAILED                0xcc000124
#define DNS_ERROR_SOA_DELETE_INVALID                0xcc000125

//
//  Datafile errors
//

#define DNS_ERROR_PRIMARY_REQUIRES_DATAFILE         0xcc000201
#define DNS_ERROR_INVALID_DATAFILE_NAME             0xcc000202
#define DNS_ERROR_DATAFILE_OPEN_FAILURE             0xcc000203
#define DNS_ERROR_FILE_WRITEBACK_FAILED             0xcc000204
#define DNS_ERROR_DATAFILE_PARSING                  0xcc000205

//
//  Database errors
//

#define DNS_ERROR_RECORD_DOES_NOT_EXIST             0xcc000300
#define DNS_ERROR_RECORD_FORMAT                     0xcc000301
#define DNS_ERROR_NODE_CREATION_FAILED              0xcc000302
#define DNS_ERROR_UNKNOWN_RECORD_TYPE               0xcc000303
#define DNS_ERROR_RECORD_TIMED_OUT                  0xcc000304

#define DNS_ERROR_NAME_NOT_IN_ZONE                  0xcc000305
#define DNS_ERROR_CNAME_LOOP                        0xcc000306
#define DNS_ERROR_NODE_IS_CNAME                     0xcc000307
#define DNS_ERROR_CNAME_COLLISION                   0xcc000308
#define DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT          0xcc000309
#define DNS_ERROR_RECORD_ALREADY_EXISTS             0xcc000310
#define DNS_ERROR_SECONDARY_DATA                    0xcc000311
#define DNS_ERROR_NO_CREATE_CACHE_DATA              0xcc000312
#define DNS_ERROR_NAME_DOES_NOT_EXIST               0xcc000313

#define DNS_WARNING_PTR_CREATE_FAILED               0x8c000332
#define DNS_WARNING_DOMAIN_UNDELETED                0x8c000333

#define DNS_ERROR_DS_UNAVAILABLE                    0xcc000340
#define DNS_ERROR_DS_ZONE_ALREADY_EXISTS            0xcc000341
#define DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE            0xcc000342


//
//  Operation errors
//

#define DNS_INFO_AXFR_COMPLETE                      0x4c000403
#define DNS_ERROR_AXFR                              0xcc000404
#define DNS_INFO_ADDED_LOCAL_WINS                   0x4c000405

//  Secure update

#define DNS_STATUS_CONTINUE_NEEDED                  0x4c000406

//
//  Setup errors
//

#define DNS_ERROR_NO_TCPIP                          0xcc000501
#define DNS_ERROR_NO_DNS_SERVERS                    0xcc000502

#endif  // NT4


//
//  Helpful checks
//

#define VALID_USER_MEMORY(p)    ( (DWORD)(p) < 0x80000000 )

#define IS_DWORD_ALIGNED(p)     ( !((DWORD_PTR)(p) & (DWORD_PTR)3) )


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\exver.h ===
#include <ntverp.h>
#include "iisver.h"

//
// Undo IIS's definitions and use our own
//
#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif
#define VER_PRODUCTNAME_STR			"Microsoft(R) Internet Services"

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#ifndef rmj
#define rmj VER_IISMAJORVERSION
#endif // !rmj 
#ifndef rmn
#define rmn VER_IISMINORVERSION
#endif // !rmn 
#define rmm VER_IISPRODUCTBUILD
#define rup 0
#define szVerName ""
#define szVerUser "_mpubld"


#ifdef MAC
#ifndef _rmacmaj
#define _rmacmaj 0x6
#endif
#ifndef _rmacmin
#define _rmacmin 0x
#endif
#ifndef _rmacint
#define _rmacint 0x
#endif
#ifndef _rmactype
#define _rmactype 
#endif
#ifndef _rmacstr
#define _rmacstr "6.0"
#endif
#endif //MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\exchmem.h ===
/*
 -	E X C H M E M . H
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 *	Copyright (C) 1995-96, Microsoft Corporation.
 */

#ifndef _EXCHMEM_
#define _EXCHMEM_


#ifdef __cplusplus
extern "C"
{
#endif

//	Additional Heap Flags

#define HEAP_NO_FREE			0x00001000


//	API Function Prototypes

HANDLE
WINAPI
ExchHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);
	
	
BOOL
WINAPI
ExchHeapDestroy(
	HANDLE	hHeap);
	
	
LPVOID
WINAPI
ExchHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize);
	
	
LPVOID
WINAPI
ExchHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize);
	
	
BOOL
WINAPI
ExchHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree);


BOOL
WINAPI
ExchHeapLock(
	HANDLE hHeap);


BOOL
WINAPI
ExchHeapUnlock(
	HANDLE hHeap);


BOOL
WINAPI
ExchHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry);


BOOL
WINAPI
ExchHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
WINAPI
ExchHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
WINAPI
ExchHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags);


HANDLE
WINAPI
ExchMHeapCreate(
	ULONG	cHeaps,
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);
	
	
BOOL
WINAPI
ExchMHeapDestroy(void);
	
	
LPVOID
WINAPI
ExchMHeapAlloc(
	DWORD	dwSize);
	
LPVOID
WINAPI
ExchMHeapAllocDebug(DWORD dwSize, char *szFileName, DWORD dwLineNumber);

LPVOID
WINAPI
ExchMHeapReAlloc(LPVOID	pvOld, DWORD dwSize);

LPVOID
WINAPI
ExchMHeapReAllocDebug(LPVOID pvOld, DWORD dwSize, char *szFileName, DWORD dwLineNumber);

BOOL
WINAPI
ExchMHeapFree(
	LPVOID	pvFree);


SIZE_T
WINAPI
ExchMHeapSize(
	LPVOID	pvSize);
	
LPVOID
WINAPI
ExchAlloc(
	DWORD	dwSize);
	
	
LPVOID
WINAPI
ExchReAlloc(
	LPVOID	pvOld,
	DWORD	dwSize);
	
	
BOOL
WINAPI
ExchFree(
	LPVOID	pvFree);


SIZE_T
WINAPI
ExchSize(
	LPVOID	pv);


//
//	Misc. Debug functions.  Available in retail and debug exchmem, but retail version is simply a stub..
//
   
VOID
WINAPI
ExchmemGetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind);

VOID
WINAPI
ExchmemFormatSymbol(HANDLE hProcess, DWORD_PTR dwCaller, char rgchSymbol[], DWORD cbSymbol);

DWORD
WINAPI
ExchmemReloadSymbols(void);

#ifdef __cplusplus
}
#endif

#endif	// _EXCHMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\dbgfile.h ===
/*----------------------------------------------------------------------
	dbgfile.h
		Definitions for async tracing file ATF files

	Copyright (C) 1994 Microsoft Corporation
	All rights reserved.

	Authors:
		gordm          Gord Mangione

	History:
		01/30/95 gordm		Created.
----------------------------------------------------------------------*/


//
// Trace file types and definitions
//
// The binary trace file contains the trace statement of the
// following structure. All dwLengths include the entire structure
//


typedef struct tagFIXEDTRACE
{
	WORD		wSignature;
	WORD		wLength;
	WORD		wVariableLength;
	WORD		wBinaryType;
	DWORD		dwTraceMask;
	DWORD		dwProcessId;
	DWORD		dwThreadId;
	SYSTEMTIME	TraceTime;
	DWORD		dwParam;
	WORD		wLine;
	WORD		wFileNameOffset;
	WORD		wFunctNameOffset;
	WORD		wBinaryOffset;
} FIXEDTRACE, *PFIXEDTRACE, FIXEDTR, *PFIXEDTR;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\dnsapi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnsapi.h

Abstract:

    Domain Name System (DNS)

    DNS Client API Library

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

    Glenn Curtis (glennc)   January 22, 1997
        Added Dynamic Update Client API for DNSAPI.DLL

--*/


#ifndef _DNSAPI_INCLUDED_
#define _DNSAPI_INCLUDED_

#ifndef _WINSOCK2API_
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif
#endif

#ifndef _DNS_INCLUDED_
#include <dns.h>
#endif


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Non-wrapping seconds timer (timer.c)
//

DWORD
GetCurrentTimeInSeconds(
    VOID
    );


//
//  General DNS utilities (dnsutil.c)
//

LPSTR
_fastcall
DnsGetDomainName(
    IN  LPSTR   pszName
    );

LPSTR
_fastcall
DnsStatusString(
    IN  DNS_STATUS  Status
    );

#define DnsStatusToErrorString_A(status)    DnsStatusString(status)

DNS_STATUS
_fastcall
DnsMapRcodeToStatus(
    IN  BYTE    ResponseCode
    );

BYTE
_fastcall
DnsIsStatusRcode(
    IN  DNS_STATUS  Status
    );

//
//  Machines IP address list (iplist.c)
//
//  Routine to get the current IP addresses from all adapters
//  configured for the machine.
//

DWORD
DnsGetIpAddressList(
    OUT PIP_ARRAY * ppIpAddresses
    );

//
//  Routine to get the current IP addresses and subnet masks
//  from all adapters configured for the machine.
//

typedef struct _DNS_ADDRESS_INFO_
{
    IP_ADDRESS ipAddress;
    IP_ADDRESS subnetMask;
}
DNS_ADDRESS_INFO, *PDNS_ADDRESS_INFO;

DWORD
DnsGetIpAddressInfoList(
    OUT PDNS_ADDRESS_INFO * ppAddrInfo
    );

DWORD
DnsGetDnsServerList(
    OUT PIP_ARRAY * ppDnsAddresses
    );


//
// Routines and structures for getting network configuration information
// for TCPIP interfaces
//

#define NETINFO_FLAG_IS_WAN_ADAPTER             (0x00000002)
#define NETINFO_FLAG_IS_AUTONET_ADAPTER         (0x00000004)
#define NETINFO_FLAG_IS_DHCP_CFG_ADAPTER        (0x00000008)


typedef struct _NAME_SERVER_INFORMATION_
{
    IP_ADDRESS      ipAddress;
    DWORD           Priority;
}
NAME_SERVER_INFORMATION, *PNAME_SERVER_INFORMATION;

typedef struct _ADAPTER_INFORMATION_
{
    LPSTR                   pszAdapterGuidName;
    LPSTR                   pszDomain;
    PIP_ARRAY               pIPAddresses;
    PIP_ARRAY               pIPSubnetMasks;
    DWORD                   InfoFlags;
    DWORD                   cServerCount;
    NAME_SERVER_INFORMATION aipServers[1];
}
ADAPTER_INFORMATION, *PADAPTER_INFORMATION;

typedef struct _SEARCH_INFORMATION_
{
    LPSTR           pszPrimaryDomainName;
    DWORD           cNameCount;
    LPSTR           aSearchListNames[1];
}
SEARCH_INFORMATION, *PSEARCH_INFORMATION;

typedef struct _NETWORK_INFORMATION_
{
    PSEARCH_INFORMATION  pSearchInformation;
    DWORD                cAdapterCount;
    PADAPTER_INFORMATION aAdapterInfoList[1];
}
NETWORK_INFORMATION, *PNETWORK_INFORMATION;


PNETWORK_INFORMATION
WINAPI
DnsGetNetworkInformation(
    void
    );

PSEARCH_INFORMATION
WINAPI
DnsGetSearchInformation(
    void
    );

VOID
WINAPI
DnsFreeAdapterInformation(
    IN  PADAPTER_INFORMATION pAdapterInformation
    );

VOID
WINAPI
DnsFreeSearchInformation(
    IN  PSEARCH_INFORMATION pSearchInformation
    );

VOID
WINAPI
DnsFreeNetworkInformation(
    IN  PNETWORK_INFORMATION pNetworkInformation
    );



//
//  Resource record type utilities (record.c)
//

BOOL
_fastcall
DnsIsAMailboxType(
    IN  WORD    wType
    );

WORD
DnsRecordTypeForName(
    IN  PCHAR   pszName,
    IN  INT     cchNameLength
    );

PCHAR
DnsRecordStringForType(
    IN  WORD    wType
    );

PCHAR
DnsRecordStringForWritableType(
    IN  WORD    wType
    );

BOOL
DnsIsStringCountValidForTextType(
    IN  WORD    wType,
    IN  WORD    StringCount
    );

BOOL
DnsIpv6StringToAddress(
    OUT PIPV6_ADDRESS   pAddress,
    IN  PCHAR           pchString,
    IN  DWORD           dwStringLength
    );

VOID
DnsIpv6AddressToString(
    OUT PCHAR           pchString,
    IN  PIPV6_ADDRESS   pAddress
    );



//
//  Resource record structure for send\recv records.
//

//
//  Record data for specific types
//

#ifdef SDK_DNS_RECORD

typedef struct
{
    IP_ADDRESS  ipAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    LPTSTR      pNameHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    LPTSTR      pNamePrimaryServer;
    LPTSTR      pNameAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    LPTSTR      pNameMailbox;
    LPTSTR      pNameErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    LPTSTR      pNameExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
#ifdef MIDL_PASS
    [size_is(dwStringCount)] LPTSTR * pStringArray;
#else  // MIDL_PASS
    LPTSTR     pStringArray[1];
#endif // MIDL_PASS
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    DWORD       dwByteCount;
#ifdef MIDL_PASS
    [size_is(dwByteCount)] PBYTE bData;
#else  // MIDL_PASS
    BYTE       bData[1];
#endif // MIDL_PASS
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP_ADDRESS  ipAddress;
    UCHAR       chProtocol;
    BYTE        bBitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    IPV6_ADDRESS    ipv6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    LPTSTR      pNameSigner;
    WORD        wTypeCovered;
    BYTE        chAlgorithm;
    BYTE        chLabelCount;
    DWORD       dwOriginalTtl;
    DWORD       dwExpiration;
    DWORD       dwTimeSigned;
    WORD        wKeyTag;
    WORD        Pad;        // keep byte field aligned
    BYTE        Signature[1];
}
DNS_SIG_DATA, *PDNS_SIG_DATA;

typedef struct
{
    WORD        wFlags;
    BYTE        chProtocol;
    BYTE        chAlgorithm;
    BYTE        Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA;

typedef struct
{
    WORD        wVersion;
    WORD        wSize;
    WORD        wHorPrec;
    WORD        wVerPrec;
    DWORD       dwLatitude;
    DWORD       dwLongitude;
    DWORD       dwAltitude;
}
DNS_LOC_DATA, *PDNS_LOC_DATA;

typedef struct
{
    LPTSTR      pNameNext;
    BYTE        bTypeBitMap[1];
}
DNS_NXT_DATA, *PDNS_NXT_DATA;

typedef struct
{
    LPTSTR      pNameTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    LPTSTR      pNameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pKey;
    PBYTE       pOtherData;
    DWORD       dwCreateTime;
    DWORD       dwExpireTime;
    WORD        wMode;
    WORD        wError;
    WORD        wKeyLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOL        fPacketPointers;
}
DNS_TKEY_DATA, *PDNS_TKEY_DATA;

typedef struct
{
    LPTSTR      pNameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pSignature;
    PBYTE       pOtherData;
    LONGLONG    i64CreateTime;
    WORD        wFudgeTime;
    WORD        wOriginalID;
    WORD        wError;
    WORD        wSigLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOL        fPacketPointers;
}
DNS_TSIG_DATA, *PDNS_TSIG_DATA;


#define DNS_ATM_TYPE_E164    0x01 // E.164 addressing scheme
#define DNS_ATM_TYPE_NSAP    0x02 // NSAP-style addressing scheme
#define DNS_ATM_TYPE_AESA    DNS_ATM_TYPE_NSAP

#define DNS_ATM_MAX_ADDR_SIZE    20

typedef struct
{
    BYTE        AddressType;
    BYTE        Address[ DNS_ATM_MAX_ADDR_SIZE ];

    // Endsystem Address IA5 digits
    // for E164, BCD encoding for NSAP
    // Array size is DNS_ATM_MAX_ADDR_SIZE for NSAP
    // address type, and a null terminated string
    // less than DNS_ATM_MAX_ADDR_SIZE characters
    // for E164 address type.
}
DNS_ATMA_DATA, *PDNS_ATMA_DATA;


//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DWORD       cWinsServerCount;
    IP_ADDRESS  aipWinsServers[1];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    LPTSTR      pNameResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;


//
//  Length of non-fixed-length data types
//

#define DNS_TEXT_RECORD_LENGTH(StringCount) \
            (sizeof(DWORD) + ((StringCount) * sizeof(PCHAR)))

#define DNS_NULL_RECORD_LENGTH(ByteCount) \
            (sizeof(DWORD) + (ByteCount))

#define DNS_WKS_RECORD_LENGTH(ByteCount) \
            (sizeof(DNS_WKS_DATA) + (ByteCount-1))

#define DNS_WINS_RECORD_LENGTH(IpCount) \
            (sizeof(DNS_WINS_DATA) + ((IpCount-1) * sizeof(IP_ADDRESS)))


//
//  Record flags
//

#if 0
typedef struct _DnsRecordFlags
{
    BYTE    Section     : 2;
    BYTE    Delete      : 1;
    BYTE    Unused      : 5;

    BYTE    Unused2     : 4;
    BYTE    FreeData    : 1;
    BYTE    FreeOwner   : 1;
    BYTE    Unicode     : 1;
    BYTE    Multiple    : 1;

    WORD    Reserved;
}
DNSREC_FLAGS;
#endif



typedef struct _DnsRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;
    DWORD   Unused      : 3;

    DWORD   Reserved    : 24;
}
DNSREC_FLAGS;


//
//  Record flags as bit flags
//  These may be or'd together to set the fields
//

//  RR Section in packet

#define     DNSREC_SECTION      (0x00000003)

#define     DNSREC_QUESTION     (0x00000000)
#define     DNSREC_ANSWER       (0x00000001)
#define     DNSREC_AUTHORITY    (0x00000002)
#define     DNSREC_ADDITIONAL   (0x00000003)

//  RR Section in packet (update)

#define     DNSREC_ZONE         (0x00000000)
#define     DNSREC_PREREQ       (0x00000001)
#define     DNSREC_UPDATE       (0x00000002)

//  Delete RR (update) or No-exist (prerequisite)

#define     DNSREC_DELETE       (0x00000004)
#define     DNSREC_NOEXIST      (0x00000004)


#ifdef MIDL_PASS
typedef [switch_type(WORD)] union _DNS_RECORD_DATA_TYPES
{
    [case(DNS_TYPE_A)]      DNS_A_DATA     A;

    [case(DNS_TYPE_SOA)]    DNS_SOA_DATA   SOA;

    [case(DNS_TYPE_PTR,
          DNS_TYPE_NS,
          DNS_TYPE_CNAME,
          DNS_TYPE_MB,
          DNS_TYPE_MD,
          DNS_TYPE_MF,
          DNS_TYPE_MG,
          DNS_TYPE_MR)]     DNS_PTR_DATA   PTR;

    [case(DNS_TYPE_MINFO,
          DNS_TYPE_RP)]     DNS_MINFO_DATA MINFO;

    [case(DNS_TYPE_MX,
          DNS_TYPE_AFSDB,
          DNS_TYPE_RT)]     DNS_MX_DATA    MX;

#if 0
    //  RPC is not able to handle a proper TXT record definition
    //  note:  that if other types are needed they are fixed
    //      (or semi-fixed) size and may be accomodated easily
    [case(DNS_TYPE_HINFO,
          DNS_TYPE_ISDN,
          DNS_TYPE_TEXT,
          DNS_TYPE_X25)]    DNS_TXT_DATA   TXT;

    [case(DNS_TYPE_NULL)]   DNS_NULL_DATA  Null;
    [case(DNS_TYPE_WKS)]    DNS_WKS_DATA   WKS;
    [case(DNS_TYPE_TKEY)]   DNS_TKEY_DATA  TKEY;
    [case(DNS_TYPE_TSIG)]   DNS_TSIG_DATA  TSIG;
    [case(DNS_TYPE_WINS)]   DNS_WINS_DATA  WINS;
    [case(DNS_TYPE_NBSTAT)] DNS_WINSR_DATA WINSR;
#endif

    [case(DNS_TYPE_AAAA)]   DNS_AAAA_DATA  AAAA;
    [case(DNS_TYPE_SRV)]    DNS_SRV_DATA   SRV;
    [case(DNS_TYPE_ATMA)]   DNS_ATMA_DATA  ATMA;
    //
    // BUGBUG - Commented out since this may not be needed - Check with MarioG
    //
    //[default] ;
}
DNS_RECORD_DATA_TYPES;
#endif // MIDL_PASS


//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    LPTSTR              pName;
    WORD                wType;
    WORD                wDataLength; // Not referenced for DNS record types
                                     // defined above.
#ifdef MIDL_PASS
    DWORD               Flags;
#else // MIDL_PASS
    union
    {
        DWORD           DW; // flags as dword
        DNSREC_FLAGS    S;  // flags as structure

    } Flags;
#endif // MIDL_PASS

    DWORD               dwTtl;
    DWORD               dwReserved;
#ifdef MIDL_PASS
    [switch_is(wType)] DNS_RECORD_DATA_TYPES Data;
#else  // MIDL_PASS
    union
    {
        DNS_A_DATA      A;
        DNS_SOA_DATA    SOA, Soa;
        DNS_PTR_DATA    PTR, Ptr,
                        NS, Ns,
                        CNAME, Cname,
                        MB, Mb,
                        MD, Md,
                        MF, Mf,
                        MG, Mg,
                        MR, Mr;
        DNS_MINFO_DATA  MINFO, Minfo,
                        RP, Rp;
        DNS_MX_DATA     MX, Mx,
                        AFSDB, Afsdb,
                        RT, Rt;
        DNS_TXT_DATA    HINFO, Hinfo,
                        ISDN, Isdn,
                        TXT, Txt,
                        X25;
        DNS_NULL_DATA   Null;
        DNS_WKS_DATA    WKS, Wks;
        DNS_AAAA_DATA   AAAA;
        DNS_SRV_DATA    SRV, Srv;
        DNS_TKEY_DATA   TKEY, Tkey;
        DNS_TSIG_DATA   TSIG, Tsig;
        DNS_ATMA_DATA   ATMA, Atma;
        DNS_WINS_DATA   WINS, Wins;
        DNS_WINSR_DATA  WINSR, WinsR, NBSTAT, Nbstat;

    } Data;
#endif // MIDL_PASS
}
DNS_RECORD, *PDNS_RECORD;



#else   // not SDK_DNS_RECORD

//
//  Old DNS_RECORD definitions
//  JBUGBUG:  save only until Cliff (and any other NT file)
//      can be converted, then dump
//

//
//  Record data for specific types
//

typedef struct
{
    IP_ADDRESS  ipAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    DNS_NAME    nameHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    DNS_NAME    namePrimaryServer;
    DNS_NAME    nameAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    DNS_NAME    nameMailbox;
    DNS_NAME    nameErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    DNS_NAME    nameExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
    DNS_TEXT    pStringArray[1];
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    // DWORD       dwByteCount;
    BYTE        bData[1];
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP_ADDRESS  ipAddress;
    UCHAR       chProtocol;
    BYTE        bBitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    IPV6_ADDRESS    ipv6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    DNS_NAME    nameSigner;
    WORD        wTypeCovered;
    BYTE        chAlgorithm;
    BYTE        chLabelCount;
    DWORD       dwOriginalTtl;
    DWORD       dwExpiration;
    DWORD       dwTimeSigned;
    WORD        wKeyTag;
    WORD        Pad;        // keep byte field aligned
    BYTE        Signature[1];
}
DNS_SIG_DATA, *PDNS_SIG_DATA;

typedef struct
{
    WORD        wFlags;
    BYTE        chProtocol;
    BYTE        chAlgorithm;
    BYTE        Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA;

typedef struct
{
    WORD        wVersion;
    WORD        wSize;
    WORD        wHorPrec;
    WORD        wVerPrec;
    DWORD       dwLatitude;
    DWORD       dwLongitude;
    DWORD       dwAltitude;
}
DNS_LOC_DATA, *PDNS_LOC_DATA;

typedef struct
{
    DNS_NAME    nameNext;
    BYTE        bTypeBitMap[1];
}
DNS_NXT_DATA, *PDNS_NXT_DATA;

typedef struct
{
    DNS_NAME    nameTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    DNS_NAME    nameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pKey;
    PBYTE       pOtherData;
    DWORD       dwCreateTime;
    DWORD       dwExpireTime;
    WORD        wMode;
    WORD        wError;
    WORD        wKeyLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TKEY_DATA, *PDNS_TKEY_DATA;

typedef struct
{
    DNS_NAME    nameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pSignature;
    PBYTE       pOtherData;
    LONGLONG    i64CreateTime;
    WORD        wFudgeTime;
    WORD        wOriginalID;
    WORD        wError;
    WORD        wSigLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TSIG_DATA, *PDNS_TSIG_DATA;

#define DNS_ATM_TYPE_E164    0x01 // E.164 addressing scheme
#define DNS_ATM_TYPE_NSAP    0x02 // NSAP-style addressing scheme
#define DNS_ATM_TYPE_AESA    DNS_ATM_TYPE_NSAP

#define DNS_ATM_MAX_ADDR_SIZE    20

typedef struct
{
    BYTE    AddressType;    // E.164 or NSAP-style ATM Endsystem Address
    BYTE    Address[1];     // IA5 digits for E164, BCD encoding for NSAP
                            // Array size is DNS_ATM_MAX_ADDR_SIZE for NSAP
                            // address type, and a null terminated string
                            // less than DNS_ATM_MAX_ADDR_SIZE characters
                            // for E164 address type.
}
DNS_ATMA_DATA, *PDNS_ATMA_DATA;


//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DWORD       cWinsServerCount;
    IP_ADDRESS  aipWinsServers[1];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DNS_NAME    nameResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;


//
//  Length of non-fixed-length data types
//

#define DNS_TEXT_RECORD_LENGTH(StringCount) \
            (sizeof(DWORD) + ((StringCount) * sizeof(PCHAR)))

#define DNS_NULL_RECORD_LENGTH(ByteCount) \
            (sizeof(DWORD) + (ByteCount))

#define DNS_WKS_RECORD_LENGTH(ByteCount) \
            (sizeof(DNS_WKS_DATA) + (ByteCount-1))

#define DNS_WINS_RECORD_LENGTH(IpCount) \
            (sizeof(DNS_WINS_DATA) + ((IpCount-1) * sizeof(IP_ADDRESS)))


//
//  Record flags
//

typedef struct _DnsRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   Unused      : 5;

    DWORD   Unused2     : 4;
    DWORD   FreeData    : 1;
    DWORD   FreeOwner   : 1;
    DWORD   Unicode     : 1;
    DWORD   Multiple    : 1;

    DWORD   Reserved    : 16;
}
DNSREC_FLAGS;


//
//  Record flags as bit flags
//  These may be or'd together to set the fields
//

//  RR Section in packet

#define     DNSREC_SECTION      (0x00000003)

#define     DNSREC_QUESTION     (0x00000000)
#define     DNSREC_ANSWER       (0x00000001)
#define     DNSREC_AUTHORITY    (0x00000002)
#define     DNSREC_ADDITIONAL   (0x00000003)

//  RR Section in packet (update)

#define     DNSREC_ZONE         (0x00000000)
#define     DNSREC_PREREQ       (0x00000001)
#define     DNSREC_UPDATE       (0x00000002)

//  Delete RR (update) or No-exist (prerequisite)

#define     DNSREC_DELETE       (0x00000004)
#define     DNSREC_NOEXIST      (0x00000004)

//  Owner name is allocated and can be freed with record cleanup

#define     DNSREC_FREEOWNER    (0x00002000)

//  UNICODE names in record

#define     DNSREC_UNICODE      (0x00004000)

//  Multiple RR in this record buffer
//  This optimization may be used with fixed types only

#define     DNSREC_MULTIPLE     (0x00008000)


//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    DNS_NAME            nameOwner;
    WORD                wType;
    WORD                wDataLength;
    union
    {
        DWORD           W;  // flags as dword
        DNSREC_FLAGS    S;  // flags as structure

    } Flags;

    DWORD               dwTtl;
    DWORD               dwReserved;
    union
    {
        DNS_A_DATA      A;
        DNS_SOA_DATA    SOA, Soa;
        DNS_PTR_DATA    PTR, Ptr,
                        NS, Ns,
                        CNAME, Cname,
                        MB, Mb,
                        MD, Md,
                        MF, Mf,
                        MG, Mg,
                        MR, Mr;
        DNS_MINFO_DATA  MINFO, Minfo,
                        RP, Rp;
        DNS_MX_DATA     MX, Mx,
                        AFSDB, Afsdb,
                        RT, Rt;
        DNS_TXT_DATA    HINFO, Hinfo,
                        ISDN, Isdn,
                        TXT, Txt,
                        X25;
        DNS_NULL_DATA   Null;
        DNS_WKS_DATA    WKS, Wks;
        DNS_AAAA_DATA   AAAA;
        DNS_SRV_DATA    SRV, Srv;
        DNS_TKEY_DATA   TKEY, Tkey;
        DNS_TSIG_DATA   TSIG, Tsig;
        DNS_ATMA_DATA   ATMA, Atma;
        DNS_WINS_DATA   WINS, Wins;
        DNS_WINSR_DATA  WINSR, WinsR, NBSTAT, Nbstat;

    } Data;
}
DNS_RECORD, *PDNS_RECORD;

#endif // End of old DNS_RECORD definitions


#define DNS_RECORD_FIXED_SIZE       FIELD_OFFSET( DNS_RECORD, Data )
#define SIZEOF_DNS_RECORD_HEADER    DNS_RECORD_FIXED_SIZE



//
//  Resource record set building
//
//  pFirst points to first record in list.
//  pLast points to last record in list.
//

typedef struct _DnsRRSet
{
    PDNS_RECORD pFirstRR;
    PDNS_RECORD pLastRR;
}
DNS_RRSET, *PDNS_RRSET;


//
//  To init pFirst is NULL.
//  But pLast points at the location of the pFirst pointer -- essentially
//  treating the pFirst ptr as a DNS_RECORD.  (It is a DNS_RECORD with
//  only a pNext field, but that's the only part we use.)
//
//  Then when the first record is added to the list, the pNext field of
//  this dummy record (which corresponds to pFirst's value) is set to
//  point at the first record.  So pFirst then properly points at the
//  first record.
//
//  (This works only because pNext is the first field in a
//  DNS_RECORD structure and hence casting a PDNS_RECORD ptr to
//  PDNS_RECORD* and dereferencing yields its pNext field)
//

#define DNS_RRSET_INIT( rrset )                 \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            _prrset->pFirstRR = NULL;           \
            _prrset->pLastRR = (PDNS_RECORD) &_prrset->pFirstRR; \
        }

#define DNS_RRSET_ADD( rrset, pnewRR )          \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            PDNS_RECORD _prrnew = (pnewRR);     \
            _prrset->pLastRR->pNext = _prrnew;  \
            _prrset->pLastRR = _prrnew;         \
        }


//
//  Record building (rralloc.c)
//

PDNS_RECORD
WINAPI
DnsAllocateRecord(
    IN      WORD        wBufferLength
    );

VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD pRecord,
    IN      BOOL        fFreeOwner
    );

#define DnsFreeRRSet( pRRSet, fFreeOwner )  \
        DnsRecordListFree( (pRRSet), (fFreeOwner) )


PDNS_RECORD
DnsRecordSetDetach(
    IN OUT  PDNS_RECORD pRR
    );

PDNS_RECORD
DnsCreatePtrRecord(
    IN      IP_ADDRESS  ipAddress,
    IN      DNS_NAME    pszHostName,
    IN      BOOL        fUnicodeName
    );


//
//  Record build from data strings (rrbuild.c)
//

PDNS_RECORD
DnsRecordBuild(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
DnsRecordBuild_UTF8(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
DnsRecordBuild_W(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPWSTR      pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PWCHAR *    Argv
    );


//
//  Record set manipulation
//

//
//  Record Compare
//
//  Note:  these routines will NOT do proper unicode compare, unless
//         records have the fUnicode flag set. Both input record lists
//         must be either ANSI or UNICODE, but not one of each.
//

BOOL
WINAPI
DnsRecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    );

BOOL
WINAPI
DnsRecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    );


//
//  DNS Name compare
//

BOOL
WINAPI
DnsNameCompare_A(
    IN      LPSTR       pName1,
    IN      LPSTR       pName2
    );

BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR      pName1,
    IN      LPWSTR      pName2
    );

//
//  Record Copy
//  Record copy functions also do conversion between character sets.
//
//  Note, it might be advisable to directly expose non-Ex copy
//  functions _W, _A for record and set, to avoid exposing the
//  conversion enum.
//

typedef enum _DNS_CHARSET
{
    DnsCharSetUnknown,
    DnsCharSetUnicode,
    DnsCharSetUtf8,
    DnsCharSetAnsi,
}
DNS_CHARSET;


PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    IN      PDNS_RECORD     pRecordSet,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

#ifdef UNICODE
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#else
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#endif


#if 0
PDNS_RECORD
WINAPI
DnsRecordCopy(
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUnicodeIn
    );

PDNS_RECORD
DnsRecordSetCopy(
    IN  PDNS_RECORD pRR,
    IN  BOOL        fUnicodeIn
    );

PDNS_RECORD
WINAPI
DnsRecordCopy_W(
    IN      PDNS_RECORD     pRecord
    );

PDNS_RECORD
WINAPI
DnsRecordSetCopy_W(
    IN      PDNS_RECORD     pRRSet
    );

#endif


//
// Routines to copy and convert UNICODE records to other string type records
//

PDNS_RECORD
WINAPI
DnsCopyUnicodeRecordToUnicodeRecord(
    IN  PDNS_RECORD pRecord
    );

PDNS_RECORD
WINAPI
DnsCopyUnicodeRecordToUtf8Record(
    IN  PDNS_RECORD pRecord
    );

PDNS_RECORD
WINAPI
DnsCopyUnicodeRecordToAnsiRecord(
    IN  PDNS_RECORD pRecord
    );

PDNS_RECORD
DnsCopyUnicodeRRSetToUnicodeRRSet(
    IN  PDNS_RECORD pRR
    );

PDNS_RECORD
DnsCopyUnicodeRRSetToUtf8RRSet(
    IN  PDNS_RECORD pRR
    );

PDNS_RECORD
DnsCopyUnicodeRRSetToAnsiRRSet(
    IN  PDNS_RECORD pRR
    );


//
//  DNS Update API
//
//  NOTE:
//
//  The DNS update API functions have new names to clearify their use.
//  The new functions for various DNS update operations are:
//
//      DnsAcquireContextHandle
//      DnsReleaseContextHandle
//      DnsAddRecords
//      DnsAddRecordSet
//      DnsModifyRecords
//      DnsModifyRecordSet
//      DnsRemoveRecords
//      DnsReplaceRecordSet
//      DnsUpdateTest
//      DnsGetLastServerUpdateIP
//
//  The old functions have been changed to macros so
//  as not to break the build.
//

//
//  Old DNS update function definitions
//
//  Options for DnsModifyRRSet & DnsRegisterRRSet
//

//
// Update flags
//

//
// Old flags used for DnsModifyRRSet & DnsRegisterRRSet
//
#define DNS_UPDATE_UNIQUE                   0x00000000
#define DNS_UPDATE_SHARED                   0x00000001

//
// New flags used for:
//   DnsModifyRecords
//   DnsModifyRecordSet
//   DnsAddRecords
//   DnsAddRecordSet
//   DnsRemoveRecords
//   DnsReplaceRecordSet
//

#define DNS_UPDATE_SECURITY_USE_DEFAULT     0x00000000
#define DNS_UPDATE_SECURITY_OFF             0x00000010
#define DNS_UPDATE_SECURITY_ON              0x00000020
#define DNS_UPDATE_SECURITY_ONLY            0x00000100
#define DNS_UPDATE_CACHE_SECURITY_CONTEXT   0x00000200
#define DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT  0x00000400
#define DNS_UPDATE_FORCE_SECURITY_NEGO      0x00000800
#define DNS_UPDATE_RESERVED                 0xfffff000

DNS_STATUS
WINAPI
DnsAcquireContextHandle_W(
    IN  DWORD    CredentialFlags,
    IN  PVOID    Credentials OPTIONAL, // Actually this will be a
                                       // PSEC_WINNT_AUTH_IDENTITY_W,
                                       // calling this a PVOID to avoid
                                       // having to include rpcdce.h
    OUT HANDLE * ContextHandle
    );

DNS_STATUS
WINAPI
DnsAcquireContextHandle_A(
    IN  DWORD    CredentialFlags,
    IN  PVOID    Credentials OPTIONAL, // Actually this will be a
                                       // PSEC_WINNT_AUTH_IDENTITY_A,
                                       // calling this a PVOID to avoid
                                       // having to include rpcdce.h
    OUT HANDLE * ContextHandle
    );

#ifdef UNICODE
#define DnsAcquireContextHandle DnsAcquireContextHandle_W
#else
#define DnsAcquireContextHandle DnsAcquireContextHandle_A
#endif


VOID
WINAPI
DnsReleaseContextHandle(
    IN  HANDLE ContextHandle
    );


DNS_STATUS
WINAPI
DnsModifyRecords_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecords_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecords_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsModifyRecords DnsModifyRecords_W
#else
#define DnsModifyRecords DnsModifyRecords_A
#endif


DNS_STATUS
WINAPI
DnsModifyRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsModifyRecordSet DnsModifyRecordSet_W
#else
#define DnsModifyRecordSet DnsModifyRecordSet_A
#endif


#define DnsModifyRRSet_A( _pCSet,                                    \
                          _pNSet,                                    \
                          _Options,                                  \
                          _Servers )                                 \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_A( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_A( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )

#define DnsModifyRRSet_W( _pCSet,                                    \
                          _pNSet,                                    \
                          _Options,                                  \
                          _Servers )                                 \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_W( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_W( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )

#ifdef UNICODE
#define DnsModifyRRSet( _pCSet,                                      \
                        _pNSet,                                      \
                        _Options,                                    \
                        _Servers )                                   \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_W( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_W( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )
#else
#define DnsModifyRRSet( _pCSet,                                      \
                        _pNSet,                                      \
                        _Options,                                    \
                        _Servers )                                   \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_A( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_A( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsAddRecords_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecords_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecords_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsAddRecords DnsAddRecords_W
#else
#define DnsAddRecords DnsAddRecords_A
#endif


DNS_STATUS
WINAPI
DnsAddRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsAddRecordSet DnsAddRecordSet_W
#else
#define DnsAddRecordSet DnsAddRecordSet_A
#endif


#define DnsRegisterRRSet_A( _pRSet,                                 \
                            _Options,                               \
                            _Servers )                              \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_A( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#define DnsRegisterRRSet_W( _pRSet,                                 \
                            _Options,                               \
                            _Servers )                              \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_W( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#ifdef UNICODE
#define DnsRegisterRRSet( _pRSet,                                   \
                          _Options,                                 \
                          _Servers )                                \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_W( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#else
#define DnsRegisterRRSet( _pRSet,                                   \
                          _Options,                                 \
                          _Servers )                                \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_A( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsRemoveRecords_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsRemoveRecords_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsRemoveRecords_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

#ifdef UNICODE
#define DnsRemoveRecords DnsRemoveRecords_W
#else
#define DnsRemoveRecords DnsRemoveRecords_A
#endif


#define DnsRemoveRRSet_A( _pRSet,                                \
                          _Servers )                             \
            DnsRemoveRecords_A( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )

#define DnsRemoveRRSet_W( _pRSet,                                \
                          _Servers )                             \
            DnsRemoveRecords_W( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )

#ifdef UNICODE
#define DnsRemoveRRSet( _pRSet,                                  \
                        _Servers )                               \
            DnsRemoveRecords_W( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )
#else
#define DnsRemoveRRSet( _pRSet,                                  \
                        _Servers )                               \
            DnsRemoveRecords_A( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsReplaceRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsReplaceRecordSet DnsReplaceRecordSet_W
#else
#define DnsReplaceRecordSet DnsReplaceRecordSet_A
#endif


#define DnsReplaceRRSet_A( _pRSet,                                  \
                           _Servers )                               \
            DnsReplaceRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#define DnsReplaceRRSet_W( _pRSet,                                  \
                           _Servers )                               \
            DnsReplaceRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#ifdef UNICODE
#define DnsReplaceRRSet( _pRSet,                                    \
                         _Servers )                                 \
            DnsReplaceRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#else
#define DnsReplaceRRSet( _pRSet,                                    \
                         _Servers )                                 \
            DnsReplaceRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsUpdateTest_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPSTR       pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPSTR       pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPWSTR      pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsUpdateTest DnsUpdateTest_W
#else
#define DnsUpdateTest DnsUpdateTest_A
#endif


IP_ADDRESS
WINAPI
DnsGetLastServerUpdateIP (
    VOID
    );



//
//  DNS Query API
//

//
//  Options for DnsQuery
//

#define DNS_QUERY_STANDARD                  0x00000000
#define DNS_QUERY_ACCEPT_PARTIAL_UDP        0x00000001
#define DNS_QUERY_USE_TCP_ONLY              0x00000002
#define DNS_QUERY_NO_RECURSION              0x00000004
#define DNS_QUERY_BYPASS_CACHE              0x00000008
#define DNS_QUERY_CACHE_ONLY                0x00000010
#define DNS_QUERY_SOCKET_KEEPALIVE          0x00000100
#define DNS_QUERY_TREAT_AS_FQDN             0x00001000
#define DNS_QUERY_ALLOW_EMPTY_AUTH_RESP     0x00010000
#define DNS_QUERY_RESERVED                  0xfff00000

#define DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE DNS_QUERY_ACCEPT_PARTIAL_UDP


DNS_STATUS WINAPI
DnsQuery_A(
    IN     LPSTR          lpstrName,
    IN     WORD           wType,
    IN     DWORD          fOptions,
    IN     PIP_ARRAY      aipServers            OPTIONAL,
    IN OUT PDNS_RECORD *  ppQueryResultsSet     OPTIONAL,
    IN OUT PVOID *        pReserved             OPTIONAL
    );

DNS_STATUS WINAPI
DnsQuery_UTF8(
    IN     LPSTR          lpstrName,
    IN     WORD           wType,
    IN     DWORD          fOptions,
    IN     PIP_ARRAY      aipServers            OPTIONAL,
    IN OUT PDNS_RECORD *  ppQueryResultsSet     OPTIONAL,
    IN OUT PVOID *        pReserved             OPTIONAL
    );

DNS_STATUS WINAPI
DnsQuery_W(
    IN     LPWSTR         lpstrName,
    IN     WORD           wType,
    IN     DWORD          fOptions,
    IN     PIP_ARRAY      aipServers            OPTIONAL,
    IN OUT PDNS_RECORD *  ppQueryResultsSet     OPTIONAL,
    IN OUT PVOID *        pReserved             OPTIONAL
    );

#ifdef UNICODE
#define DnsQuery DnsQuery_W
#else
#define DnsQuery DnsQuery_A
#endif


//
// Options for DnsCheckNameCollision
//

#define DNS_CHECK_AGAINST_HOST_ANY              0x00000000
#define DNS_CHECK_AGAINST_HOST_ADDRESS          0x00000001
#define DNS_CHECK_AGAINST_HOST_DOMAIN_NAME      0x00000002


DNS_STATUS WINAPI
DnsCheckNameCollision_A (
    IN  LPSTR pszName,
    IN  DWORD fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_UTF8 (
    IN  LPSTR pszName,
    IN  DWORD fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_W (
    IN  LPWSTR pszName,
    IN  DWORD  fOptions
    );

#ifdef UNICODE
#define DnsDnsCheckNameCollision DnsCheckNameCollision_W
#else
#define DnsDnsCheckNameCollision DnsCheckNameCollision_A
#endif


LPSTR WINAPI
DnsGetHostName_A(
    VOID
    );

LPSTR WINAPI
DnsGetHostName_UTF8(
    VOID
    );

LPWSTR WINAPI
DnsGetHostName_W(
    VOID
    );

#ifdef UNICODE
#define DnsGetHostName DnsGetHostName_W
#else
#define DnsGetHostName DnsGetHostName_A
#endif


LPSTR WINAPI
DnsGetPrimaryDomainName_A(
    VOID
    );

LPSTR WINAPI
DnsGetPrimaryDomainName_UTF8(
    VOID
    );

LPWSTR WINAPI
DnsGetPrimaryDomainName_W(
    VOID
    );

#ifdef UNICODE
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_W
#else
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_A
#endif



//
//  DNS Update API for DHCP client
//

typedef struct  _REGISTER_HOST_ENTRY
{
     union
     {
         IP_ADDRESS    ipAddr;
         IPV6_ADDRESS  ipV6Addr;
     } Addr;
     DWORD       dwOptions;
}
REGISTER_HOST_ENTRY, *PREGISTER_HOST_ENTRY;

//
//  Options for above
//

#define REGISTER_HOST_A             0x00000001
#define REGISTER_HOST_PTR           0x00000002  // Used by DHCP server
#define REGISTER_HOST_TRANSIENT     0x00000004  // Don't use, use DYNDNS_REG_RAS
#define REGISTER_HOST_AAAA          0x00000008
#define REGISTER_HOST_RESERVED      0x80000000  // Not used

#define DYNDNS_REG_FWD      0x0
#define DYNDNS_REG_PTR      0x8
#define DYNDNS_REG_RAS      0x10
#define DYNDNS_DEL_ENTRY    0x20


typedef struct  _REGISTER_HOST_STATUS
{
     HANDLE      hDoneEvent;
     DWORD       dwStatus;
}
REGISTER_HOST_STATUS, *PREGISTER_HOST_STATUS;

DNS_STATUS
WINAPI
DnsAsyncRegisterInit(
   LPSTR lpstrRootRegKey
   );

DNS_STATUS
WINAPI
DnsAsyncRegisterTerm(
   VOID
   );

DNS_STATUS WINAPI
DnsRemoveRegistrations(
   VOID
   );

DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs_W(
    IN  LPWSTR                lpstrAdapterName,
    IN  LPWSTR                lpstrHostName,
    IN  PREGISTER_HOST_ENTRY  pHostAddrs,
    IN  DWORD                 dwHostAddrCount,
    IN  PIP_ADDRESS           pipDnsServerList,
    IN  DWORD                 dwDnsServerCount,
    IN  LPWSTR                lpstrDomainName,
    IN  PREGISTER_HOST_STATUS pRegisterStatus,
    IN  DWORD                 dwTTL,
    IN  DWORD                 dwFlags
    );

DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs_UTF8(
    IN  LPSTR                 lpstrAdapterName,
    IN  LPSTR                 lpstrHostName,
    IN  PREGISTER_HOST_ENTRY  pHostAddrs,
    IN  DWORD                 dwHostAddrCount,
    IN  PIP_ADDRESS           pipDnsServerList,
    IN  DWORD                 dwDnsServerCount,
    IN  LPSTR                 lpstrDomainName,
    IN  PREGISTER_HOST_STATUS pRegisterStatus,
    IN  DWORD                 dwTTL,
    IN  DWORD                 dwFlags
    );

DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs_A(
    IN  LPSTR                 lpstrAdapterName,
    IN  LPSTR                 lpstrHostName,
    IN  PREGISTER_HOST_ENTRY  pHostAddrs,
    IN  DWORD                 dwHostAddrCount,
    IN  PIP_ADDRESS           pipDnsServerList,
    IN  DWORD                 dwDnsServerCount,
    IN  LPSTR                 lpstrDomainName,
    IN  PREGISTER_HOST_STATUS pRegisterStatus,
    IN  DWORD                 dwTTL,
    IN  DWORD                 dwFlags
    );

#ifdef UNICODE
#define DnsAsyncRegisterHostAddrs DnsAsyncRegisterHostAddrs_W
#else
#define DnsAsyncRegisterHostAddrs DnsAsyncRegisterHostAddrs_A
#endif


//
//  DNS Update API for DHCP server.
//

//
//  Call back function. DHCP Server will pass a function to
//  DnsDhcpRegisterHostName and this will be called on successful
//  or unsuccessful completion of the task
//  If we have a condition like server down/try again later etc we
//  won't respond until we have an authoritative answer.
//

typedef VOID(*DHCP_CALLBACK_FN)(DWORD dwStatus, LPVOID pvData);

//
//  Callback return codes
//

#define     DNSDHCP_SUCCESS         0x0
#define     DNSDHCP_FWD_FAILED      0x1
#define     DNSDHCP_SUPERCEDED      0x2

#define     DNSDHCP_FAILURE         (DWORD)-1 //reverse failed

#define     DYNDNS_DELETE_ENTRY     0x1
#define     DYNDNS_ADD_ENTRY        0x2
#define     DYNDNS_REG_FORWARD      0x4

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInit(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterTerm(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName_A(
    IN REGISTER_HOST_ENTRY HostAddr,
    IN LPSTR               pszName,
    IN DWORD               dwTTL,
    IN DWORD               dwFlags,
    IN DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN PVOID               pvData,
    IN PIP_ADDRESS         pipDnsServerList OPTIONAL,
    IN DWORD               dwDnsServerCount
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName_UTF8(
    IN REGISTER_HOST_ENTRY HostAddr,
    IN LPSTR               pszName,
    IN DWORD               dwTTL,
    IN DWORD               dwFlags,
    IN DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN PVOID               pvData,
    IN PIP_ADDRESS         pipDnsServerList OPTIONAL,
    IN DWORD               dwDnsServerCount
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName_W(
    IN REGISTER_HOST_ENTRY HostAddr,
    IN LPWSTR              pszName,
    IN DWORD               dwTTL,
    IN DWORD               dwFlags,
    IN DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN PVOID               pvData,
    IN PIP_ADDRESS         pipDnsServerList OPTIONAL,
    IN DWORD               dwDnsServerCount
    );

#define DnsDhcpSrvRegisterHostName  DnsDhcpSrvRegisterHostName_A

#define RETRY_TIME_SERVER_FAILURE        5*60  // 5 minutes
#define RETRY_TIME_TRY_AGAIN_LATER       5*60  // 5 minutes
#define RETRY_TIME_TIMEOUT               5*60  // 5 minutes

#define RETRY_TIME_MAX                   10*60 // back off to 10 mins if
                                               // repeated failures occur




//
//  Memory allocation
//
//  Many dnsapi.dll routines allocate memory.
//  This memory allocation defaults to routines that use:
//      - LocalAlloc,
//      - LocalReAlloc,
//      - LocalFree.
//  If you desire alternative memory allocation mechanisms, use this
//  function to override the DNS API defaults.  All memory returned by dnsapi.dll
//  can then be freed with the specified free function.
//

typedef PVOID (* DNS_ALLOC_FUNCTION)();
typedef PVOID (* DNS_REALLOC_FUNCTION)();
typedef VOID (* DNS_FREE_FUNCTION)();

VOID
DnsApiHeapReset(
    IN  DNS_ALLOC_FUNCTION      pAlloc,
    IN  DNS_REALLOC_FUNCTION    pRealloc,
    IN  DNS_FREE_FUNCTION       pFree
    );

//
//  Modules using DNSAPI memory should use these routines if
//  they are capable of being called by a process that resets
//  the dnsapi.dll heap.  (Example:  the DNS server.)
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    );

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    );


//
//  String utilities (string.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//

#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
#define DNS_ALLOW_NONRFC_NAMES      (0x00000001)
#define DNS_ALLOW_MULTIBYTE_NAMES   (0x00000002)
#define DNS_ALLOW_ALL_NAMES         (0x00000003)


LPSTR
DnsCreateStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString
    );

DWORD
DnsGetBufferLengthForStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsCopyStringEx(
    OUT     PBYTE       pBuffer,
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsStringCopyAllocateEx(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PCHAR
DnsWriteReverseNameStringForIpAddress(
    OUT     PCHAR       pBuffer,
    IN      IP_ADDRESS  ipAddress
    );

PCHAR
DnsCreateReverseNameStringForIpAddress(
    IN      IP_ADDRESS  ipAddress
    );



//
//  Name validation
//

typedef enum _DNS_NAME_FORMAT
{
    DnsNameDomain,
    DnsNameDomainLabel,
    DnsNameHostnameFull,
    DnsNameHostnameLabel,
    DnsNameWildcard,
    DnsNameSrvRecord
}
DNS_NAME_FORMAT;


DNS_STATUS
DnsValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

#ifdef UNICODE
#define DnsValidateName(p,f)    DnsValidateName_W( (p), (f) )
#else
#define DnsValidateName(p,f)    DnsValidateName_A( (p), (f) )
#endif


//
//  Macro away old routines
//

#define DnsValidateDnsName_UTF8(pname)  \
        DnsValidateName_UTF8( (pname), DnsNameDomain )

#define DnsValidateDnsName_W(pname) \
        DnsValidateName_W( (pname), DnsNameDomain )


//
//  Relational name compare result
//
typedef enum
{
   DNS_RELATE_NEQ,         // NOT EQUAL: name's in different name space.
   DNS_RELATE_EQL,         // EQUAL: name's are identical DNS names
   DNS_RELATE_LGT,         // LEFT GREATER THAN: left name is parent (contains) to right name
   DNS_RELATE_RGT,         // RIGHT GREATER THAN: right name is parent (contains) to left name
   DNS_RELATE_INVALID      // INVALID STATE: accompanied with DNS_STATUS return code
} DNS_RELATE_STATUS, *PDNS_RELATE_STATUS;

DNS_STATUS
DnsRelationalCompare_UTF8(
    IN      LPCSTR      pszLeftName,
    IN      LPCSTR      pszRightName,
    IN      DWORD       dwReserved,
    IN OUT DNS_RELATE_STATUS  *pRelation
    );

DNS_STATUS
DnsRelationalCompare_W(
    IN      LPCWSTR      pszLeftName,
    IN      LPCWSTR      pszRightName,
    IN      DWORD       dwReserved,
    IN OUT  DNS_RELATE_STATUS  *pRelation
    );

DNS_STATUS
DnsValidateDnsString_UTF8(
    IN      LPCSTR      pszName
    );

DNS_STATUS
DnsValidateDnsString_W(
    IN      LPCWSTR     pszName
    );

LPSTR
DnsCreateStandardDnsNameCopy(
    IN      PCHAR       pchName,
    IN      DWORD       cchName,
    IN      DWORD       dwFlag
    );

DWORD
DnsDowncaseDnsNameLabel(
    OUT     PCHAR       pchResult,
    IN      PCHAR       pchLabel,
    IN      DWORD       cchLabel,
    IN      DWORD       dwFlags
    );

DWORD
_fastcall
DnsUnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    );

DWORD
_fastcall
DnsUtf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    );

DNS_STATUS
DnsValidateUtf8Byte(
    IN      BYTE        chUtf8,
    IN OUT  PDWORD      pdwTrailCount
    );


//
// Routines for NT services to call to get a Service Control Manager
// control message, (i.e. SERVICE_CONTROL_PARAMCHANGE - 0x00000006, etc.), in
// the event of a PnP change that affects DNS related data.
//

BOOL WINAPI
DnsServiceNotificationRegister_W (
    IN  LPWSTR pszServiceName,
    IN  DWORD  dwControl
    );

BOOL WINAPI
DnsServiceNotificationRegister_UTF8 (
    IN  LPSTR pszServiceName,
    IN  DWORD  dwControl
    );

BOOL WINAPI
DnsServiceNotificationRegister_A (
    IN  LPSTR pszServiceName,
    IN  DWORD  dwControl
    );

#ifdef UNICODE
#define DnsServiceNotificationRegister DnsServiceNotificationRegister_W
#else
#define DnsServiceNotificationRegister DnsServiceNotificationRegister_A
#endif

BOOL WINAPI
DnsServiceNotificationDeregister_W (
    IN  LPWSTR pszServiceName
    );

BOOL WINAPI
DnsServiceNotificationDeregister_UTF8 (
    IN  LPSTR pszServiceName
    );

BOOL WINAPI
DnsServiceNotificationDeregister_A (
    IN  LPSTR pszServiceName
    );

#ifdef UNICODE
#define DnsServiceNotificationDeregister DnsServiceNotificationDeregister_W
#else
#define DnsServiceNotificationDeregister DnsServiceNotificationDeregister_A
#endif


//
// Routines to clear all cached entries in the DNS Resolver Cache, this is
// called by ipconfig /flushdns, and add record sets to the cache.
//

BOOL WINAPI
DnsFlushResolverCache (
    VOID
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_W (
    IN  LPWSTR pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_UTF8 (
    IN  LPSTR pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_A (
    IN  LPSTR pszName
    );

#ifdef UNICODE
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_W
#else
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_A
#endif


DNS_STATUS WINAPI
DnsCacheRecordSet_W(
    IN     LPWSTR      lpstrName,
    IN     WORD        wType,
    IN     DWORD       fOptions,
    IN OUT PDNS_RECORD pRRSet
    );


//
// Routines to enable or disable B-Node resolver service listening thread
//

VOID WINAPI
DnsEnableBNodeResolverThread (
    VOID
    );

VOID WINAPI
DnsDisableBNodeResolverThread (
    VOID
    );


//
// Routines to enable or disable dynamic DNS registrations on local machine
//

VOID WINAPI
DnsEnableDynamicRegistration (
    LPWSTR szAdapterName OPTIONAL   // If NULL, enables DDNS in general
    );

VOID WINAPI
DnsDisableDynamicRegistration (
    LPWSTR szAdapterName OPTIONAL   // If NULL, disables DDNS in general
    );

BOOL
DnsIsDynamicRegistrationEnabled (
    LPWSTR szAdapterName OPTIONAL   // If NULL, tells whether system has
    );                              // DDNS enabled.


//
// Routines to enable or disable dynamic DNS registration of a given
// adapter's domain name on the local machine
//

VOID WINAPI
DnsEnableAdapterDomainNameRegistration (
    LPWSTR szAdapterName
    );

VOID WINAPI
DnsDisableAdapterDomainNameRegistration (
    LPWSTR szAdapterName
    );

BOOL
DnsIsAdapterDomainNameRegistrationEnabled (
    LPWSTR szAdapterName
    );


//
// Routines to write a DNS Query packet request question in a buffer and
// convert response packet buffer to DNS_RECORD structure list.
//

typedef struct _DNS_MESSAGE_BUFFER
{
    DNS_HEADER MessageHead;
    CHAR       MessageBody[1];
}
DNS_MESSAGE_BUFFER, *PDNS_MESSAGE_BUFFER;

BOOL WINAPI
DnsWriteQuestionToBuffer_W (
    IN OUT PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT LPDWORD             pdwBufferSize,
    IN     LPWSTR              pszName,
    IN     WORD                wType,
    IN     WORD                Xid,
    IN     BOOL                fRecursionDesired
    );

BOOL WINAPI
DnsWriteQuestionToBuffer_UTF8 (
    IN OUT PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT LPDWORD             pdwBufferSize,
    IN     LPSTR               pszName,
    IN     WORD                wType,
    IN     WORD                Xid,
    IN     BOOL                fRecursionDesired
    );


DNS_STATUS WINAPI
DnsExtractRecordsFromMessage_W (
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    );

DNS_STATUS WINAPI
DnsExtractRecordsFromMessage_UTF8 (
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    );


//
// Routine to read the contents of the DNS Resolver Cache. The resulting
// table contains a list of record names and types stored in the cache.
// Each of these name/type records can be queried with DnsQuery with the
// option DNS_QUERY_CACHE_ONLY.
//

typedef struct _DNS_CACHE_TABLE_
{
    struct _DNS_CACHE_TABLE_ * pNext;
    LPWSTR                     Name;
    WORD                       Type1;
    WORD                       Type2;
    WORD                       Type3;
}
DNS_CACHE_TABLE, *PDNS_CACHE_TABLE;

BOOL WINAPI
DnsGetCacheDataTable (
    OUT PDNS_CACHE_TABLE * pTable
    );


//
//  Backward compatibility
//
//  Previously exposed functions now macroed to new functions.
//  Eventually need to clean this stuff out of build or
//  separate these defs from public headers
//

#define DNSBACKCOMPAT 1

#ifdef DNSBACKCOMPAT
#ifdef UNICODE
#define DnsCompareName(p1,p2)   DnsNameCompare_W( (p1), (p2) )
#else
#define DnsCompareName(p1,p2)   DnsNameCompare( (p1), (p2) )
#endif

#define DnsCompareName_W(p1,p2)   DnsNameCompare_W( (p1), (p2) )
#define DnsCompareName_A(p1,p2)   DnsNameCompare( (p1), (p2) )

#ifdef UNICODE
#define DnsCopyRR(pRR)  DnsRecordCopy( pRR, TRUE )
#else
#define DnsCopyRR(pRR)  DnsRecordCopy( pRR, FALSE )
#endif

#ifdef UNICODE
#define DnsCopyRRSet(pRRSet)    DnsRecordSetCopy( pRRSet, TRUE )
#else
#define DnsCopyRRSet(pRRSet)    DnsRecordSetCopy( pRRSet, FALSE )
#endif


//  Async registration only from DHCP client.
//  Once it is cleanedup, these can be deleted.

#define DnsMHAsyncRegisterInit(a)   DnsAsyncRegisterInit(a)
#define DnsMHAsyncRegisterTerm()    DnsAsyncRegisterTerm()
#define DnsMHRemoveRegistrations()  DnsRemoveRegistrations()

#define DnsMHAsyncRegisterHostAddrs_A(a,b,c,d,e,f,g,h,i,j) \
        DnsAsyncRegisterHostAddrs_A(a,b,c,d,e,f,g,h,i,j)

#define DnsMHAsyncRegisterHostAddrs_W(a,b,c,d,e,f,g,h,i,j) \
        DnsAsyncRegisterHostAddrs_W(a,b,c,d,e,f,g,h,i,j)

#define DnsMHAsyncRegisterHostAddrs_UTF8(a,b,c,d,e,f,g,h,i,j) \
        DnsAsyncRegisterHostAddrs_UTF8(a,b,c,d,e,f,g,h,i,j)

//  cleanup after clean build

#define DnsNameCompare(a,b) \
        DnsNameCompare_A((a),(b))

#endif DNSBACKCOMPAT



#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSAPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\dnsreci.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       dnsrec.h

   Abstract:

       This file contains type definitions for async DNS

   Author:

        Rohan Phillips (Rohanp)     June-19-1998

   Revision History:

--*/

# ifndef _ADNS_STRUCT_HXX_
# define _ADNS_STRUCT_HXX_


#define TCP_REG_LIST_SIGNATURE    'TgeR'
#define DNS_FLAGS_NONE              0x0
#define DNS_FLAGS_TCP_ONLY          0x1
#define DNS_FLAGS_UDP_ONLY          0x2

#define SMTP_MAX_DNS_ENTRIES	100

typedef void (WINAPI * USERDELETEFUNC) (PVOID);

//-----------------------------------------------------------------------------
//
//  Description:
//      Encapsulates a list of IP addresses (for DNS servers) and maintains
//      state information on them... whether the servers are up or down, and
//      provides retry logic for down servers.
//
//      Some member functions to control the state-tracking logic and error-
//      logging are listed as pure virtual functions (see the bottom of this
//      class declaration). To use this class, derive from it and implement
//      those functions.
//-----------------------------------------------------------------------------
class CDnsServerList
{

protected:
    typedef enum _SERVER_STATE
    {
        DNS_STATE_DOWN = 0,
        DNS_STATE_UP,
        DNS_STATE_PROBATION
    }
    SERVER_STATE;

    DWORD           m_dwSig;
    int             m_cUpServers;
    PIP_ARRAY	    m_IpListPtr;
    DWORD           *m_prgdwFailureTick;
    SERVER_STATE    *m_prgServerState;
    DWORD           *m_prgdwFailureCount;
    DWORD           *m_prgdwConnections;
    CShareLockNH    m_sl;

public:
    CDnsServerList();
    ~CDnsServerList();
    BOOL Update(PIP_ARRAY IpPtr);
    BOOL UpdateIfChanged(PIP_ARRAY IpPtr);
    DWORD GetWorkingServerIp(DWORD *dwIp, BOOL fThrottle);
    void MarkDown(DWORD dwIp, DWORD dwErr, BOOL fUdp);
    void ResetTimeoutServersIfNeeded();
    void ResetServerOnConnect(DWORD dwIp);
    BOOL CopyList(PIP_ARRAY *ppipArray);
    
    DWORD GetCount()
    {
        DWORD dwCount;

        m_sl.ShareLock();
        dwCount = m_IpListPtr ? m_IpListPtr->cAddrCount : 0;
        m_sl.ShareUnlock();

        return dwCount;
    }

    DWORD GetUpServerCount()
    {
        DWORD dwCount;

        m_sl.ShareLock();
        dwCount = m_cUpServers;
        m_sl.ShareUnlock();

        return dwCount;
    }

    DWORD GetAnyServerIp(PDWORD pdwIp)
    {
        m_sl.ShareLock();
        if(!m_IpListPtr || 0 == m_IpListPtr->cAddrCount) {
            m_sl.ShareUnlock();
            return DNS_ERROR_NO_DNS_SERVERS;
        }

        *pdwIp = m_IpListPtr->aipAddrs[0];
        m_sl.ShareUnlock();
        return ERROR_SUCCESS;
    }

    BOOL AllowConnection(DWORD iServer)
    {
        // Note: Sharelock must have been acquired by caller

        if(m_prgServerState[iServer] == DNS_STATE_UP)
            return TRUE;

        if(m_prgServerState[iServer] == DNS_STATE_PROBATION &&
            m_prgdwConnections[iServer] < ConnectsAllowedInProbation())
        {
            m_prgdwConnections[iServer]++;
            return TRUE;
        }
        return FALSE;
    }

    //
    // Pure virtual methods to be overridden by a class to implement processing
    // specific to the application/component.
    //

    virtual DWORD ConnectsAllowedInProbation() = 0;
    
    virtual DWORD ErrorsBeforeFailover() = 0;

    virtual void LogServerDown(
                    DWORD dwServerIp,
                    BOOL fUdp,
                    DWORD dwErr,
                    DWORD cUpServers) = 0;
};

//-----------------------------------------------------------------------------
//  Description:
//      This class adds SMTP DNS specific error-controls and error-logging to
//      the generic DNS server state tracking class.
//-----------------------------------------------------------------------------
class CTcpRegIpList : public CDnsServerList
{
public:
    DWORD ConnectsAllowedInProbation();

    DWORD ErrorsBeforeFailover();

    void LogServerDown(
        DWORD dwServerIp,
        BOOL fUdp,
        DWORD dwErr,
        DWORD cUpServers);
};

typedef struct _MXIPLISTENTRY_
{
	DWORD	IpAddress;
	LIST_ENTRY	ListEntry;
}MXIPLIST_ENTRY, *PMXIPLIST_ENTRY;

typedef struct _MX_NAMES_
{
	char DnsName[MAX_INTERNET_NAME];
	DWORD NumEntries;
	LIST_ENTRY IpListHead;
}MX_NAMES, *PMX_NAMES;

typedef struct _SMTPDNS_REC_
{
	DWORD	NumRecords;		//number of record in DnsArray
	DWORD	StartRecord;	//the starting index 
	PVOID	pMailMsgObj;	//pointer to a mailmsg obj
	PVOID	pAdvQContext;
	PVOID	pRcptIdxList;
	DWORD	dwNumRcpts;
	MX_NAMES *DnsArray[SMTP_MAX_DNS_ENTRIES];
} SMTPDNS_RECS, *PSMTPDNS_RECS;

class CDnsLogger
{
public:
    virtual void DnsPrintfMsg(char *szFormat, ...) = 0;
    
    virtual void DnsPrintfErr(char *szFormat, ...) = 0;

    virtual void DnsPrintfDbg(char *szFormat, ...) = 0;
    
    virtual void DnsLogAsyncQuery(
        char *pszQuestionName,
        WORD wQuestionType,
        DWORD dwSmtpFlags,
        BOOL fUdp,
        CDnsServerList *pDnsServerList) = 0;

    virtual void DnsLogApiQuery(
        char *pszQuestionName,
        WORD wQuestionType,
        DWORD dwDnsApiFlags,
        BOOL fGlobal,
        PIP_ARRAY pipServers) = 0;

    virtual void DnsLogResponse(
        DWORD dwStatus,
        PDNS_RECORD pDnsRecordList,
        PBYTE pbMsg,
        DWORD dwMessageLength) = 0;

    virtual void DnsPrintRecord(PDNS_RECORD pDnsRecord) = 0;
};

extern CDnsLogger *g_pDnsLogger;

// The following are defined as macros since they wrap functions that
// take a variable number of arguments
#define DNS_PRINTF_MSG              \
    if(g_pDnsLogger)                \
        g_pDnsLogger->DnsPrintfMsg

#define DNS_PRINTF_ERR              \
    if(g_pDnsLogger)                \
        g_pDnsLogger->DnsPrintfErr

#define DNS_PRINTF_DBG              \
    if(g_pDnsLogger)                \
        g_pDnsLogger->DnsPrintfDbg

inline void DNS_LOG_ASYNC_QUERY(
    IN DNS_NAME pszQuestionName,
    IN WORD wQuestionType,
    IN DWORD dwSmtpFlags,
    IN BOOL fUdp,
    IN CDnsServerList *pDnsServerList)
{
    if(g_pDnsLogger)
    {
        g_pDnsLogger->DnsLogAsyncQuery(pszQuestionName,
            wQuestionType, dwSmtpFlags, fUdp, pDnsServerList);
    }
}

inline void DNS_LOG_API_QUERY(
    IN DNS_NAME pszQuestionName,
    IN WORD wQuestionType,
    IN DWORD dwDnsApiFlags,
    IN BOOL fGlobal,
    IN PIP_ARRAY pipServers)
{
    if(g_pDnsLogger)
    {
        g_pDnsLogger->DnsLogApiQuery(pszQuestionName,
            wQuestionType, dwDnsApiFlags, fGlobal, pipServers);
    }
}

inline void DNS_LOG_RESPONSE(
    IN DWORD dwStatus,
    IN PDNS_RECORD pDnsRecordList,
    PBYTE pbMsg,
    DWORD dwMessageLength)
{
    if(g_pDnsLogger)
    {
        g_pDnsLogger->DnsLogResponse(dwStatus,
            pDnsRecordList, pbMsg, dwMessageLength);
    }
}

inline void DNS_PRINT_RECORD(
    IN PDNS_RECORD pDnsRecord)
{
    if(g_pDnsLogger)
        g_pDnsLogger->DnsPrintRecord(pDnsRecord);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\fcache.h ===
/*++

	FCACHE.H

	This file defines the interface for the file handle cache !

--*/


#ifndef	_FCACHE_H_
#define	_FCACHE_H_

#include	"smartptr.h"

#ifdef	_USE_RWNH_
#include	"rwnew.h"
#else
#include	"rw.h"
#endif


class	CFileCacheKey	{
public: 
	DWORD		m_cbPathLength ;
	LPCSTR		m_lpstrPath ;
	CFileCacheKey( LPCSTR	lpstr, DWORD	cb ) : 
		m_lpstrPath( lpstr ), m_cbPathLength( cb ) {}
} ;

#define	FILECACHE_MAX_PATH	768

class	CFileCacheObject : public	CRefCount	{
private : 

	char							m_szPath[FILECACHE_MAX_PATH] ;

	CFileCacheKey					m_key ;

	HANDLE							m_hTokenOpeningUser ;
	HANDLE							m_hFile ;
	BY_HANDLE_FILE_INFORMATION		m_FileInfo ;

	PSECURITY_DESCRIPTOR			m_pSecDesc ;
	DWORD							m_cbDesc ;

#ifndef	_USE_RWNH_
	class	CShareLock&  			m_Lock ;
#else
	class	CShareLockNH			m_Lock ;
#endif

	//
	//	These constructors are private as we only want
	//	to have one possible construction method in the public space !
	//
	CFileCacheObject() ;
	CFileCacheObject( CFileCacheObject& ) ;

public : 

	//
	//	Create a CFileCacheObject object - we only save the path for
	//	future reference !
	//
	CFileCacheObject(
			CFileCacheKey&	key,
			class	CFileCacheObjectConstructor&	constructor
			) ;	

	//	
	//	Close our file handle and everything !
	//
	~CFileCacheObject() ;

	//
	//	This file actually attempt to open the file
	//
	BOOL
	Init(	
			CFileCacheObjectConstructor&	constructor
			) ;

	CFileCacheKey&	
	GetKey()	{
		return	m_key ;
	}

	int
	MatchKey( 
			CFileCacheKey&	key
			)	{
		return	key.m_cbPathLength == m_key.m_cbPathLength &&
				memcmp( key.m_lpstrPath, m_key.m_lpstrPath, m_key.m_cbPathLength ) == 0 ;
	}

	void	
	ExclusiveLock()	{
		m_Lock.ExclusiveLock() ;
	}

	void
	ExclusiveUnlock()	{
		m_Lock.ExclusiveUnlock() ;
	}

	void
	ShareLock()	{
		m_Lock.ShareLock() ;
	}

	void
	ShareUnlock()	{
		m_Lock.ShareUnlock() ;
	}

	BOOL
	AccessCheck(
			HANDLE	hToken,
			BOOL	fHoldTokens
			) ;

	//
	//	The following are the publicly available functions 
	//	for using the cached file handle data - 
	//

	HANDLE
	GetFileHandle() {
		return	m_hFile ;
	}

	//
	//
	//
	BOOL
	QuerySize(	LPDWORD	lpcbFileSizeLow, 
				LPDWORD	lpcbFileSizeHigh 
				)	{
		*lpcbFileSizeLow = m_FileInfo.nFileSizeLow ;
		*lpcbFileSizeHigh = m_FileInfo.nFileSizeHigh ;
		return	TRUE ;

	}
} ;	

typedef	CRefPtr< CFileCacheObject >	PCACHEFILE ;

class	CFileCache	{
public : 

	//
	//	Destructor must be virtual as the actual File Cache will be
	//	derived from this but accessed through the CFIleCache interface
	//	only !
	//
	virtual	~CFileCache()	{}

	//
	// If this returns true than we should have a valid file ready to go !
	//
	virtual	BOOL
	CreateFile(
		LPCSTR	lpstrName,
		DWORD	cbTotalPath,
		HANDLE	hOpeningUser, 
		HANDLE&	hFile, 
		PCACHEFILE&	pcacheFile,
		BOOL	fCachingDesired 
		) = 0 ;

	//
	//	This function is used by users who can use PreComputePathHash - 
	//	This allows some optimization as it reduces the cost of computing
	//	hash values for file names significantly if the caller can 
	//	provide a portion of the hash value !!!
	//
	virtual	BOOL
	CreateFileWithPrecomputedHash(
		LPCSTR	lpstrName,
		DWORD	cbTotalPath,
		DWORD	cbPreComputePathLength,
		DWORD	dwHashPrecompute,
		HANDLE	hOpeningUser, 
		HANDLE&	hFile, 
		PCACHEFILE&	pcacheFile,
		BOOL	fCachingDesired 
		) = 0 ;

	//
	//	Close a file handle retrieved from the cache !
	//
	virtual	BOOL
	CloseHandle(
		PCACHEFILE&	pcacheFile
		) = 0 ;

	//
	//	Create an instance of a file cache !
	//
	static	CFileCache*
	CreateFileCache(	
		DWORD	MaxHandles = 5000,
		BOOL	fHoldTokens = TRUE
		) ;

	//
	//	This function is used to Compute a portion of the hash value for 
	//	a path that will be reused several times. This allows the caller 
	//	to speed up cache searches significantly, if they can compute this
	//	value frequently !
	//
	virtual	DWORD	
	PreComputePathHash(
		LPCSTR	lpstrPath, 
		DWORD	cbPath
		) = 0 ;
	
} ;


BOOL
FileCacheInit() ;

BOOL
FileCacheTerm() ;


#endif // _FCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\exchmole.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Mon May 12 23:53:20 1997
 */
/* Compiler settings for mimeole.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __mimeole_h__
#define __mimeole_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IMimeInternational_FWD_DEFINED__
#define __IMimeInternational_FWD_DEFINED__
typedef interface IMimeInternational IMimeInternational;
#endif 	/* __IMimeInternational_FWD_DEFINED__ */


#ifndef __IMimeSecurity_FWD_DEFINED__
#define __IMimeSecurity_FWD_DEFINED__
typedef interface IMimeSecurity IMimeSecurity;
#endif 	/* __IMimeSecurity_FWD_DEFINED__ */


#ifndef __IMimeSecurityOptions_FWD_DEFINED__
#define __IMimeSecurityOptions_FWD_DEFINED__
typedef interface IMimeSecurityOptions IMimeSecurityOptions;
#endif 	/* __IMimeSecurityOptions_FWD_DEFINED__ */


#ifndef __IMimeSecurityInfo_FWD_DEFINED__
#define __IMimeSecurityInfo_FWD_DEFINED__
typedef interface IMimeSecurityInfo IMimeSecurityInfo;
#endif 	/* __IMimeSecurityInfo_FWD_DEFINED__ */


#ifndef __IMimeHeaderTable_FWD_DEFINED__
#define __IMimeHeaderTable_FWD_DEFINED__
typedef interface IMimeHeaderTable IMimeHeaderTable;
#endif 	/* __IMimeHeaderTable_FWD_DEFINED__ */


#ifndef __IMimePropertySchema_FWD_DEFINED__
#define __IMimePropertySchema_FWD_DEFINED__
typedef interface IMimePropertySchema IMimePropertySchema;
#endif 	/* __IMimePropertySchema_FWD_DEFINED__ */


#ifndef __IMimePropertySet_FWD_DEFINED__
#define __IMimePropertySet_FWD_DEFINED__
typedef interface IMimePropertySet IMimePropertySet;
#endif 	/* __IMimePropertySet_FWD_DEFINED__ */


#ifndef __IMimeAddressInfo_FWD_DEFINED__
#define __IMimeAddressInfo_FWD_DEFINED__
typedef interface IMimeAddressInfo IMimeAddressInfo;
#endif 	/* __IMimeAddressInfo_FWD_DEFINED__ */


#ifndef __IMimeAddressTable_FWD_DEFINED__
#define __IMimeAddressTable_FWD_DEFINED__
typedef interface IMimeAddressTable IMimeAddressTable;
#endif 	/* __IMimeAddressTable_FWD_DEFINED__ */


#ifndef __IMimeWebDocument_FWD_DEFINED__
#define __IMimeWebDocument_FWD_DEFINED__
typedef interface IMimeWebDocument IMimeWebDocument;
#endif 	/* __IMimeWebDocument_FWD_DEFINED__ */


#ifndef __IMimeBody_FWD_DEFINED__
#define __IMimeBody_FWD_DEFINED__
typedef interface IMimeBody IMimeBody;
#endif 	/* __IMimeBody_FWD_DEFINED__ */


#ifndef __IMimeMessageTree_FWD_DEFINED__
#define __IMimeMessageTree_FWD_DEFINED__
typedef interface IMimeMessageTree IMimeMessageTree;
#endif 	/* __IMimeMessageTree_FWD_DEFINED__ */


#ifndef __IMimeMessage_FWD_DEFINED__
#define __IMimeMessage_FWD_DEFINED__
typedef interface IMimeMessage IMimeMessage;
#endif 	/* __IMimeMessage_FWD_DEFINED__ */


#ifndef __IMimeMessageParts_FWD_DEFINED__
#define __IMimeMessageParts_FWD_DEFINED__
typedef interface IMimeMessageParts IMimeMessageParts;
#endif 	/* __IMimeMessageParts_FWD_DEFINED__ */


#ifndef __IMimeEnumHeaderRows_FWD_DEFINED__
#define __IMimeEnumHeaderRows_FWD_DEFINED__
typedef interface IMimeEnumHeaderRows IMimeEnumHeaderRows;
#endif 	/* __IMimeEnumHeaderRows_FWD_DEFINED__ */


#ifndef __IMimeEnumProperties_FWD_DEFINED__
#define __IMimeEnumProperties_FWD_DEFINED__
typedef interface IMimeEnumProperties IMimeEnumProperties;
#endif 	/* __IMimeEnumProperties_FWD_DEFINED__ */


#ifndef __IMimeEnumAddressTypes_FWD_DEFINED__
#define __IMimeEnumAddressTypes_FWD_DEFINED__
typedef interface IMimeEnumAddressTypes IMimeEnumAddressTypes;
#endif 	/* __IMimeEnumAddressTypes_FWD_DEFINED__ */


#ifndef __IMimeEnumMessageParts_FWD_DEFINED__
#define __IMimeEnumMessageParts_FWD_DEFINED__
typedef interface IMimeEnumMessageParts IMimeEnumMessageParts;
#endif 	/* __IMimeEnumMessageParts_FWD_DEFINED__ */


#ifndef __IMimeAllocator_FWD_DEFINED__
#define __IMimeAllocator_FWD_DEFINED__
typedef interface IMimeAllocator IMimeAllocator;
#endif 	/* __IMimeAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL_itf_mimeole_0000
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */














//--------------------------------------------------------------------------------
// MIMEOLE.H
//--------------------------------------------------------------------------------
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//--------------------------------------------------------------------------------

#pragma comment(lib,"uuid.lib")

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {6AD6A1EA-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(LIBID_MIMEOLE, 0x6ad6a1ea, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EB-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumAddressTypes, 0x6ad6a1eb, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EC-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeWebDocument, 0x6ad6a1ec, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1ED-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IUnicodeStream, 0x6ad6a1ed, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EE-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeAddressTable, 0x6ad6a1ee, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EF-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeAddressInfo, 0x6ad6a1ef, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F0-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumHeaderRows, 0x6ad6a1f0, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F1-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeInlineSupport, 0x6ad6a1f1, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F2-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumMessageParts, 0x6ad6a1f2, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F3-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeSecurityInfo, 0x6ad6a1f3, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F4-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeSecurityOptions, 0x6ad6a1f4, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F5-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeInternational, 0x6ad6a1f5, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F6-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeInternational, 0x6ad6a1f6, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F7-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeBody, 0x6ad6a1f7, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F8-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeBody, 0x6ad6a1f8, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F9-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeMessageParts, 0x6ad6a1f9, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FA-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeMessageParts, 0x6ad6a1fa, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FB-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeAllocator, 0x6ad6a1fb, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FC-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeAllocator, 0x6ad6a1fc, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FD-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeSecurity, 0x6ad6a1fd, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FE-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeSecurity, 0x6ad6a1fe, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FF-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IVirtualStream, 0x6ad6a1ff, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A200-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IVirtualStream, 0x6ad6a200, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A201-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeHeaderTable, 0x6ad6a201, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A202-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeHeaderTable, 0x6ad6a202, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A203-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimePropertySet, 0x6ad6a203, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A204-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimePropertySet, 0x6ad6a204, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A205-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeMessageTree, 0x6ad6a205, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A206-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeMessageTree, 0x6ad6a206, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A207-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeMessage, 0x6ad6a207, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A208-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeMessage, 0x6ad6a208, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A209-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimePropertySchema, 0x6ad6a209, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A20A-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimePropertySchema, 0x6ad6a20a, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A20B-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumProperties, 0x6ad6a20b, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A20C-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeBindHost,0x6ad6a20c, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// MIMEOLE Failure Return Values
// --------------------------------------------------------------------------------
#define MIME_E_REG_CREATE_KEY                HR_E(0xCE01)
#define MIME_E_REG_QUERY_INFO                HR_E(0xCE02)
#define MIME_E_INVALID_ENCTYPE               HR_E(0xCE03)
#define MIME_E_BOUNDARY_MISMATCH             HR_E(0xCE04)
#define MIME_E_NOT_FOUND                     HR_E(0xCE05)
#define MIME_E_NO_DATA                       HR_E(0xCE05)
#define MIME_E_BUFFER_TOO_SMALL              HR_E(0xCE06)
#define MIME_E_INVALID_ITEM_FLAGS            HR_E(0xCE07)
#define MIME_E_ONE_LINE_ITEM                 HR_E(0xCE08)
#define MIME_E_INVALID_HANDLE                HR_E(0xCE09)
#define MIME_E_CHARSET_TRANSLATE             HR_E(0xCE0A)
#define MIME_E_NOT_INITIALIZED               HR_E(0xCE0B)
#define MIME_E_NO_MORE_ROWS                  HR_E(0xCE0C)
#define MIME_E_ALREADY_BOUND                 HR_E(0xCE0D)
#define MIME_E_CANT_RESET_ROOT               HR_E(0xCE0E)
#define MIME_E_INSERT_NOT_ALLOWED            HR_E(0xCE0F)
#define MIME_E_BAD_BODY_LOCATION             HR_E(0xCE10)
#define MIME_E_NOT_MULTIPART                 HR_E(0xCE11)
#define MIME_E_NO_MULTIPART_BOUNDARY         HR_E(0xCE12)
#define MIME_E_CONVERT_NOT_NEEDED            HR_E(0xCE13)
#define MIME_E_CANT_MOVE_BODY                HR_E(0xCE14)
#define MIME_E_UNKNOWN_BODYTREE_VERSION      HR_E(0xCE15)
#define MIME_E_NOTHING_TO_SAVE               HR_E(0xCE16)
#define MIME_E_NEED_SAVE_MESSAGE             HR_E(0xCE17)
#define MIME_E_NOTHING_TO_REVERT             HR_E(0xCE18)
#define MIME_E_MSG_SIZE_DIFF                 HR_E(0xCE19)
#define MIME_E_CANT_RESET_PARENT             HR_E(0xCE1A)
#define MIME_E_CORRUPT_CACHE_TREE            HR_E(0xCE1B)
#define MIME_E_BODYTREE_OUT_OF_SYNC          HR_E(0xCE1C)
#define MIME_E_INVALID_ENCODINGTYPE          HR_E(0xCE1D)
#define MIME_E_MULTIPART_NO_DATA             HR_E(0xCE1E)
#define MIME_E_INVALID_OPTION_VALUE          HR_E(0xCE1F)
#define MIME_E_INVALID_OPTION_ID             HR_E(0xCE20)
#define MIME_E_INVALID_HEADER_NAME           HR_E(0xCE21)
#define MIME_E_NOT_BOUND                     HR_E(0xCE22)
#define MIME_E_MAX_SIZE_TOO_SMALL            HR_E(0xCE23)
#define MIME_E_MULTIPART_HAS_CHILDREN        HR_E(0xCE25)
#define MIME_E_INVALID_PROP_FLAGS            HR_E(0xCE26)
#define MIME_E_INVALID_ADDRESS_TYPE          HR_E(0xCE27)
#define MIME_E_INVALID_OBJECT_IID            HR_E(0xCE28)
#define MIME_E_MLANG_DLL_NOT_FOUND           HR_E(0xCE29)
#define MIME_E_ROOT_NOT_EMPTY                HR_E(0xCE2A)
#define MIME_E_MLANG_BAD_DLL                 HR_E(0xCE2B)
#define MIME_E_REG_OPEN_KEY                  HR_E(0xCE2C)
#define MIME_E_INVALID_INET_DATE             HR_E(0xCE2D)
#define MIME_E_INVALID_BODYTYPE              HR_E(0xCE2E)
#define MIME_E_INVALID_DELETE_TYPE           HR_E(0xCE2F)
#define MIME_E_OPTION_HAS_NO_VALUE           HR_E(0xCE30)
#define MIME_E_INVALID_CHARSET_TYPE          HR_E(0xCE31)
#define MIME_E_VARTYPE_NO_CONVERT            HR_E(0xCE32)
#define MIME_E_INVALID_VARTYPE               HR_E(0xCE33)
#define MIME_E_NO_MORE_ADDRESS_TYPES         HR_E(0xCE34)
#define MIME_E_INVALID_ENCODING_TYPE         HR_E(0xCE35)
#define MIME_S_ILLEGAL_LINES_FOUND           HR_S(0xCE36)
#define MIME_S_MIME_VERSION                  HR_S(0xCE37)
#define MIME_E_INVALID_TEXT_TYPE             HR_E(0xCE38)
#define MIME_E_READ_ONLY                     HR_E(0xCE39)
#define MIME_S_INVALID_MESSAGE               HR_S(0xCE3A)

// ---------------------------------------------------------------------------
// MIMEOLE Security Error Return Values
// ---------------------------------------------------------------------------
#define MIME_E_SECURITY_NOTINIT              HR_E(0xCEA0)
#define MIME_E_SECURITY_LOADCRYPT32          HR_E(0xCEA1)
#define MIME_E_SECURITY_BADPROCADDR          HR_E(0xCEA2)
#define MIME_E_SECURITY_NODEFAULT            HR_E(0xCEB0)
#define MIME_E_SECURITY_NOOP                 HR_E(0xCEB1)
#define MIME_S_SECURITY_NOOP                 HR_S(0xCEB1)
#define MIME_S_SECURITY_NONE                 HR_S(0xCEB2)
#define MIME_S_SECURITY_ERROROCCURED         HR_S(0xCEB3)
#define MIME_E_SECURITY_USERCHOICE           HR_E(0xCEB4)
#define MIME_E_SECURITY_UNKMSGTYPE           HR_E(0xCEB5)
#define MIME_E_SECURITY_BADMESSAGE           HR_E(0xCEB6)
#define MIME_E_SECURITY_BADCONTENT           HR_E(0xCEB7)
#define MIME_E_SECURITY_BADSECURETYPE        HR_E(0xCEB8)
#define MIME_E_SECURITY_BADSTORE             HR_E(0xCED0)
#define MIME_E_SECURITY_NOCERT               HR_E(0xCED1)
#define MIME_E_SECURITY_CERTERROR            HR_E(0xCED2)
#define MIME_S_SECURITY_NODEFCERT            HR_S(0xCED3)
#define MIME_E_SECURITY_BADSIGNATURE         HR_E(0xCEE0)
#define MIME_E_SECURITY_MULTSIGNERS          HR_E(0xCEE1)
#define MIME_E_SECURITY_NOSIGNINGCERT        HR_E(0xCEE2)
#define MIME_E_SECURITY_CANTDECRYPT          HR_E(0xCEF0)
#define MIME_E_SECURITY_ENCRYPTNOSENDERCERT  HR_E(0xCEF1)

// ---------------------------------------------------------------------------
// MIMEOLE Security Ignore Masks
//  Pass these to the enocode/decode functions to admit "acceptible"
//  errors.  Acceptible defined to be the bits set on this mask.
// ---------------------------------------------------------------------------
#define MIME_SECURITY_IGNORE_ENCRYPTNOSENDERCERT     0x0001
#define MIME_SECURITY_IGNORE_BADSIGNATURE            0x0002
#define MIME_SECURITY_IGNORE_NOCERT                  0x0004
#define MIME_SECURITY_IGNORE_ALL                     0xffff

// --------------------------------------------------------------------------------
// String Definition Macros
// --------------------------------------------------------------------------------
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C extern
#endif

#ifdef DEFINE_STRCONST
#define STRCONSTA(x,y)    EXTERN_C const char x[] = y
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[] = L##y
#else
#define STRCONSTA(x,y)    EXTERN_C const char x[]
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[]
#endif

// --------------------------------------------------------------------------------
// rfc822 Headers
// --------------------------------------------------------------------------------
STRCONSTA(STR_HDR_FROM,              "From");
STRCONSTA(STR_HDR_TO,                "To");
STRCONSTA(STR_HDR_CC,                "Cc");
STRCONSTA(STR_HDR_BCC,               "Bcc");
STRCONSTA(STR_HDR_SENDER,            "Sender");
STRCONSTA(STR_HDR_REPLYTO,           "Reply-To");
STRCONSTA(STR_HDR_RETURNPATH,        "Return-Path");
STRCONSTA(STR_HDR_RR,                "Rr");
STRCONSTA(STR_HDR_RETRCPTTO,         "Return-Receipt-To");
STRCONSTA(STR_HDR_APPARTO,           "Apparently-To");
STRCONSTA(STR_HDR_DATE,              "Date");
STRCONSTA(STR_HDR_RECEIVED,          "Received");
STRCONSTA(STR_HDR_MESSAGEID,         "Message-ID");
STRCONSTA(STR_HDR_XMAILER,           "X-Mailer");
STRCONSTA(STR_HDR_ENCODING,          "Encoding");
STRCONSTA(STR_HDR_ENCRYPTED,         "Encrypted");
STRCONSTA(STR_HDR_COMMENT,           "Comment");
STRCONSTA(STR_HDR_SUBJECT,           "Subject");
STRCONSTA(STR_HDR_MIMEVER,           "MIME-Version");
STRCONSTA(STR_HDR_CNTTYPE,           "Content-Type");
STRCONSTA(STR_HDR_CNTXFER,           "Content-Transfer-Encoding");
STRCONSTA(STR_HDR_CNTID,             "Content-ID");
STRCONSTA(STR_HDR_CNTDESC,           "Content-Description");
STRCONSTA(STR_HDR_CNTDISP,           "Content-Disposition");
STRCONSTA(STR_HDR_CNTBASE,           "Content-Base");
STRCONSTA(STR_HDR_CNTLOC,            "Content-Location");
STRCONSTA(STR_HDR_NEWSGROUPS,        "Newsgroups");
STRCONSTA(STR_HDR_PATH,              "Path");
STRCONSTA(STR_HDR_FOLLOWUPTO,        "Followup-To");
STRCONSTA(STR_HDR_EXPIRES,           "Expires");
STRCONSTA(STR_HDR_REFS,              "References");
STRCONSTA(STR_HDR_CONTROL,           "Control");
STRCONSTA(STR_HDR_DISTRIB,           "Distribution");
STRCONSTA(STR_HDR_KEYWORDS,          "Keywords");
STRCONSTA(STR_HDR_SUMMARY,           "Summary");
STRCONSTA(STR_HDR_APPROVED,          "Approved");
STRCONSTA(STR_HDR_LINES,             "Lines");
STRCONSTA(STR_HDR_XREF,              "Xref");
STRCONSTA(STR_HDR_ORG,               "Organization");
STRCONSTA(STR_HDR_XNEWSRDR,          "X-Newsreader");
STRCONSTA(STR_HDR_XPRI,              "X-Priority");
STRCONSTA(STR_HDR_XMSPRI,            "X-MSMail-Priority");
STRCONSTA(STR_HDR_OFFSETS,           "X-Offsets");
STRCONSTA(STR_HDR_XUNSENT,           "X-Unsent");
STRCONSTA(STR_HDR_ARTICLEID,         "X-ArticleId");
STRCONSTA(STR_HDR_NEWSGROUP,         "X-Newsgroup");

// --------------------------------------------------------------------------------
// Parameters Available through IMimePropertySet/IMimeBody
// --------------------------------------------------------------------------------
STRCONSTA(STR_PAR_CHARSET,           "par:content-type:charset");
STRCONSTA(STR_PAR_NUMBER,            "par:content-type:number");
STRCONSTA(STR_PAR_TOTAL,             "par:content-type:total");
STRCONSTA(STR_PAR_ID,                "par:content-type:id");
STRCONSTA(STR_PAR_BOUNDARY,          "par:content-type:boundary");
STRCONSTA(STR_PAR_NAME,              "par:content-type:name");
STRCONSTA(STR_PAR_PROTOCOL,          "par:content-type:protocol");
STRCONSTA(STR_PAR_MICALG,            "par:content-type:micalg");
STRCONSTA(STR_PAR_FILENAME,          "par:content-disposition:filename");
STRCONSTA(STR_PAR_TYPE,              "par:content-type:type");
STRCONSTA(STR_PAR_START,             "par:content-type:start");

// --------------------------------------------------------------------------------
// Attributes Available through IMimePropertySet/IMimeBody
// --------------------------------------------------------------------------------
STRCONSTA(STR_ATT_FILENAME,          "att:filename");
STRCONSTA(STR_ATT_GENFNAME,          "att:generated-filename");
STRCONSTA(STR_ATT_PRITYPE,           "att:pri-content-type");
STRCONSTA(STR_ATT_SUBTYPE,           "att:sub-content-type");
STRCONSTA(STR_ATT_NORMSUBJ,          "att:normalized-subject");
STRCONSTA(STR_ATT_ILLEGAL,           "att:illegal-lines");
STRCONSTA(STR_ATT_RESOURL,           "att:resolved-url");
STRCONSTA(STR_ATT_SENTTIME,          "att:sent-time");
STRCONSTA(STR_ATT_RECVTIME,          "att:received-time");
STRCONSTA(STR_ATT_PRIORITY,          "att:priority");

// --------------------------------------------------------------------------------
// MIME Content Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_MIME_TEXT_PLAIN,       "text/plain");
STRCONSTA(STR_MIME_TEXT_HTML,        "text/html");
STRCONSTA(STR_MIME_APPL_STREAM,      "application/octet-stream");
STRCONSTA(STR_MIME_MPART_MIXED,      "multipart/mixed");
STRCONSTA(STR_MIME_MPART_ALT,        "multipart/alternative");
STRCONSTA(STR_MIME_MPART_RELATED,    "multipart/related");
STRCONSTA(STR_MIME_MSG_PART,         "message/partial");
STRCONSTA(STR_MIME_MSG_RFC822,       "message/rfc822");
STRCONSTA(STR_MIME_APPLY_MSTNEF,     "application/ms-tnef");

// --------------------------------------------------------------------------------
// MIME Primary Content Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_CNT_TEXT,		    	"text");
STRCONSTA(STR_CNT_MULTIPART,			"multipart");
STRCONSTA(STR_CNT_MESSAGE,			"message");
STRCONSTA(STR_CNT_IMAGE,				"image");
STRCONSTA(STR_CNT_AUDIO,				"audio");
STRCONSTA(STR_CNT_VIDEO,				"video");
STRCONSTA(STR_CNT_APPLICATION,		"application");

// --------------------------------------------------------------------------------
// MIME Secondary Content Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_SUB_PLAIN,             "plain");
STRCONSTA(STR_SUB_HTML,              "html");
STRCONSTA(STR_SUB_RTF,               "ms-rtf");
STRCONSTA(STR_SUB_MIXED,             "mixed");
STRCONSTA(STR_SUB_PARALLEL,          "parallel");
STRCONSTA(STR_SUB_DIGEST,            "digest");
STRCONSTA(STR_SUB_RELATED,           "related");
STRCONSTA(STR_SUB_ALTERNATIVE,       "alternative");
STRCONSTA(STR_SUB_RFC822,            "rfc822");
STRCONSTA(STR_SUB_PARTIAL,           "partial");
STRCONSTA(STR_SUB_EXTERNAL,          "external-body");
STRCONSTA(STR_SUB_OCTETSTREAM,       "octet-stream");
STRCONSTA(STR_SUB_POSTSCRIPT,        "postscript");
STRCONSTA(STR_SUB_GIF,               "gif");
STRCONSTA(STR_SUB_JPEG,              "jpeg");
STRCONSTA(STR_SUB_BASIC,             "basic");
STRCONSTA(STR_SUB_MPEG,              "mpeg");
STRCONSTA(STR_SUB_MSTNEF,            "ms-tnef");
STRCONSTA(STR_SUB_MSWORD,            "msword");
STRCONSTA(STR_SUB_WAV,               "wav");
STRCONSTA(STR_SUB_PKCS7MIME,         "x-pkcs7-mime");
STRCONSTA(STR_SUB_PKCS7SIG,          "x-pkcs7-signature");
STRCONSTA(STR_SUB_SIGNED,            "signed");

// --------------------------------------------------------------------------------
// MIME Content-Transfer-Encoding Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_ENC_7BIT,              "7bit");
STRCONSTA(STR_ENC_QP,                "quoted-printable");
STRCONSTA(STR_ENC_BASE64,            "base64");
STRCONSTA(STR_ENC_8BIT,              "8bit");
STRCONSTA(STR_ENC_BINARY,            "binary");
STRCONSTA(STR_ENC_UUENCODE,          "uuencode");
STRCONSTA(STR_ENC_XUUENCODE,         "x-uuencode");
STRCONSTA(STR_ENC_XUUE,              "x-uue");

// --------------------------------------------------------------------------------
// MIME Content-Disposition Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_DIS_INLINE,            "inline");
STRCONSTA(STR_DIS_ATTACHMENT,        "attachment");

// --------------------------------------------------------------------------------
// MIME Protocol Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_PRO_SHA1,              "sha1");
STRCONSTA(STR_PRO_MD5,               "rsa-md5");

// --------------------------------------------------------------------------------
// Known Priority Strings
// --------------------------------------------------------------------------------
STRCONSTA(STR_PRI_MS_HIGH,           "High");
STRCONSTA(STR_PRI_MS_NORMAL,         "Normal");
STRCONSTA(STR_PRI_MS_LOW,            "Low");
STRCONSTA(STR_PRI_HIGH,              "1");
STRCONSTA(STR_PRI_NORMAL,            "3");
STRCONSTA(STR_PRI_LOW,               "5");

// --------------------------------------------------------------------------------
// IMimeMessage IDataObject clipboard formats (also include CF_TEXT)
// --------------------------------------------------------------------------------
STRCONSTA(STR_CF_HTML,               "HTML Format");
STRCONSTA(STR_CF_INETMSG,            "Internet Message (rfc822/rfc1522)");
STRCONSTA(STR_CF_RFC822,             "message/rfc822");

// --------------------------------------------------------------------------------
// PIDSTRING - Use in GetProp, SetProp, QueryProp, DeleteProp
// --------------------------------------------------------------------------------
#define PID_BASE                     2
#define PIDTOSTR(_dwPropId)          ((LPCSTR)((DWORD_PTR)(_dwPropId)))
#define STRTOPID(_pszName)           ((DWORD)((DWORD_PTR)((LPCSTR)(_pszName))))
#define ISPIDSTR(_pszName)           ((HIWORD((DWORD_PTR)(_pszName)) == 0))
#define ISKNOWNPID(_dwPropId)        (_dwPropId >= PID_BASE && _dwPropId < PID_LAST)

// --------------------------------------------------------------------------------
// Mime Property Ids
// --------------------------------------------------------------------------------
typedef enum tagMIMEPROPID {
    PID_HDR_NEWSGROUP       = 2,
    PID_HDR_NEWSGROUPS      = 3,
    PID_HDR_REFS            = 4,
    PID_HDR_SUBJECT         = 5,
    PID_HDR_FROM            = 6,
    PID_HDR_MESSAGEID       = 7,
    PID_HDR_RETURNPATH      = 8,
    PID_HDR_RR              = 9,
    PID_HDR_RETRCPTTO       = 10,
    PID_HDR_APPARTO         = 11,
    PID_HDR_DATE            = 12,
    PID_HDR_RECEIVED        = 13,
    PID_HDR_REPLYTO         = 14,
    PID_HDR_XMAILER         = 15,
    PID_HDR_BCC             = 16,
    PID_HDR_MIMEVER         = 17,
    PID_HDR_CNTTYPE         = 18,
    PID_HDR_CNTXFER         = 19,
    PID_HDR_CNTID           = 20,
    PID_HDR_CNTDESC         = 21,
    PID_HDR_CNTDISP         = 22,
    PID_HDR_CNTBASE         = 23,
    PID_HDR_CNTLOC          = 24,
    PID_HDR_TO              = 25,
    PID_HDR_PATH            = 26,
    PID_HDR_FOLLOWUPTO      = 27,
    PID_HDR_EXPIRES         = 28,
    PID_HDR_CC              = 29,
    PID_HDR_CONTROL         = 30,
    PID_HDR_DISTRIB         = 31,
    PID_HDR_KEYWORDS        = 32,
    PID_HDR_SUMMARY         = 33,
    PID_HDR_APPROVED        = 34,
    PID_HDR_LINES           = 35,
    PID_HDR_XREF            = 36,
    PID_HDR_ORG             = 37,
    PID_HDR_XNEWSRDR        = 38,
    PID_HDR_XPRI            = 39,
    PID_HDR_XMSPRI          = 40,
    PID_PAR_FILENAME        = 41,
    PID_PAR_BOUNDARY        = 42,
    PID_PAR_CHARSET         = 43,
    PID_PAR_NAME            = 44,
    PID_ATT_FILENAME        = 45,
    PID_ATT_GENFNAME        = 46,
    PID_ATT_PRITYPE         = 47,
    PID_ATT_SUBTYPE         = 48,
    PID_ATT_NORMSUBJ        = 49,
    PID_ATT_ILLEGAL         = 50,
    PID_ATT_RESOURL         = 51,
    PID_ATT_SENTTIME        = 52,
    PID_ATT_RECVTIME        = 53,
    PID_ATT_PRIORITY        = 54,
    PID_HDR_COMMENT         = 55,
    PID_HDR_ENCODING        = 56,
    PID_HDR_ENCRYPTED       = 57,
    PID_HDR_OFFSETS         = 58,
    PID_HDR_XUNSENT         = 59,
    PID_HDR_ARTICLEID       = 60,
    PID_HDR_SENDER          = 61,
    PID_LAST                = 62
};

// --------------------------------------------------------------------------------
// Variant Typed Identifiers
// --------------------------------------------------------------------------------
#define TYPEDID_MASK                     ((ULONG)0x0000FFFF)
#define TYPEDID_TYPE(_typedid)	        (VARTYPE)(((ULONG)(_typedid)) & TYPEDID_MASK)
#define TYPEDID_ID(_typedid)		        (((ULONG)(_typedid))>>16)
#define TYPEDID(_vartype,_id)	        ((((TYPEDID)(_id))<<16)|((ULONG)(_vartype)))

// --------------------------------------------------------------------------------
// Options Ids
// --------------------------------------------------------------------------------
#define OID_ALLOW_8BIT_HEADER            TYPEDID(VT_BOOL,    0x0001) // TRUE or FALSE
#define OID_CBMAX_HEADER_LINE            TYPEDID(VT_UI4,     0x0002) // Bytes
#define OID_SAVE_FORMAT                  TYPEDID(VT_UI4,     0x0003) // SAVE_RFC822 or SAVE_RFC1521 (mime)
#define OID_WRAP_BODY_TEXT               TYPEDID(VT_BOOL,    0x0004) // TRUE or FALSE
#define OID_CBMAX_BODY_LINE              TYPEDID(VT_UI4,     0x0005) // Bytes
#define OID_TRANSMIT_BODY_ENCODING       TYPEDID(VT_UI4,     0x0006) // ENCODINGTYPE
#define OID_TRANSMIT_TEXT_ENCODING       TYPEDID(VT_UI4,     0x0007) // ENCODINGTYPE
#define OID_GENERATE_MESSAGE_ID          TYPEDID(VT_BOOL,    0x0008) // TRUE or FALSE
#define OID_HASH_ALG_ID                  TYPEDID(VT_UI4,     0x0009)
#define OID_ENCRYPTION_ALG_ID            TYPEDID(VT_UI4,     0x000A)
#define OID_MESSAGE_SECURE_TYPE          TYPEDID(VT_UI2,     0x000B)
#define OID_SENDER_SIGNATURE_THUMBPRINT  TYPEDID(VT_BLOB,    0X000C)
#define OID_INCLUDE_SENDER_CERT          TYPEDID(VT_BOOL,    0X000D) // TRUE or FALSE
#define OID_HIDE_TNEF_ATTACHMENTS        TYPEDID(VT_BOOL,    0X000E) // TRUE or FALSE
#define OID_CLEANUP_TREE_ON_SAVE         TYPEDID(VT_BOOL,    0X000F) // TRUE or FALSE
#define OID_SENDER_ENCRYPTION_THUMBPRINT TYPEDID(VT_BLOB,    0X0010)
#define OID_ENCODE_SIDE_OPTIONSET        TYPEDID(VT_BOOL,    0X0011) // TRUE or FALSE
#define OID_SENDER_CERTIFICATE           TYPEDID(VT_BOOL,    0x0012) // TRUE or FALSE
#define OID_SECURITY_IGNOREMASK          TYPEDID(VT_UI4,     0x0013) // MIME_SECURITY_IGNORE_*
#define OID_BODY_REMOVE_NBSP             TYPEDID(VT_BOOL,    0x0014) // TRUE or FALSE
#define OID_DEFAULT_BODY_CHARSET         TYPEDID(VT_UI4,     0x0015) // HCHARSET
#define OID_DEFAULT_HEADER_CHARSET       TYPEDID(VT_UI4,     0x0016) // HCHARSET
#define OID_TRUST_SENDERS_CERTIFICATE    TYPEDID(VT_BOOL,    0x0017) // TRUE or FALSE
#define OID_DBCS_ESCAPE_IS_8BIT          TYPEDID(VT_BOOL,    0x0018) // TRUE or FALSE

// --------------------------------------------------------------------------------
// Default Option Values
// --------------------------------------------------------------------------------
#define DEF_ALLOW_8BIT_HEADER            FALSE
#define DEF_CBMAX_HEADER_LINE            1000
#define DEF_SAVE_FORMAT                  SAVE_RFC1521
#define DEF_WRAP_BODY_TEXT               TRUE
#define DEF_CBMAX_BODY_LINE              74
#define DEF_GENERATE_MESSAGE_ID          FALSE
#define DEF_HASH_ALG_ID                  0x8004  //SHA //N needed?
#define DEF_ENCRYPTION_ALG_ID            0x6602  //RC2 //N needed?
#define DEF_INCLUDE_SENDER_CERT          FALSE
#define DEF_HIDE_TNEF_ATTACHMENTS        TRUE
#define DEF_CLEANUP_TREE_ON_SAVE         TRUE
#define DEF_BODY_REMOVE_NBSP             TRUE
#define DEF_SECURITY_IGNOREMASK          0
#define DEF_DBCS_ESCAPE_IS_8BIT          FALSE
#define DEF_TRANSMIT_BODY_ENCODING       IET_UNKNOWN
#define DEF_TRANSMIT_TEXT_ENCODING       IET_7BIT

// --------------------------------------------------------------------------------
// Min-Max Option Values
// --------------------------------------------------------------------------------
#define MAX_CBMAX_HEADER_LINE            0xffffffff
#define MIN_CBMAX_HEADER_LINE            76
#define MAX_CBMAX_BODY_LINE              0xffffffff
#define MIN_CBMAX_BODY_LINE              30

// --------------------------------------------------------------------------------
// LIBID_MIMEOLE
// --------------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_mimeole_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mimeole_0000_v0_0_s_ifspec;


#ifndef __MIMEOLE_LIBRARY_DEFINED__
#define __MIMEOLE_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MIMEOLE
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [version][helpstring][uuid] */


typedef DWORD TYPEDID;

typedef
enum tagMIMESAVETYPE
    {	SAVE_RFC822	= 0,
	SAVE_RFC1521	= SAVE_RFC822 + 1
    }	MIMESAVETYPE;

typedef
enum tagCSETAPPLYTYPE
    {	CSET_APPLY_UNTAGGED	= 0,
	CSET_APPLY_ALL	= CSET_APPLY_UNTAGGED + 1
    }	CSETAPPLYTYPE;

typedef
enum tagENCODINGTYPE
    {	IET_BINARY	= 0,
	IET_BASE64	= IET_BINARY + 1,
	IET_UUENCODE	= IET_BASE64 + 1,
	IET_QP	= IET_UUENCODE + 1,
	IET_7BIT	= IET_QP + 1,
	IET_8BIT	= IET_7BIT + 1,
	IET_INETCSET	= IET_8BIT + 1,
	IET_UNICODE	= IET_INETCSET + 1,
	IET_RFC1522	= IET_UNICODE + 1,
	IET_ENCODED	= IET_RFC1522 + 1,
	IET_CURRENT	= IET_ENCODED + 1,
	IET_UNKNOWN	= IET_CURRENT + 1
    }	ENCODINGTYPE;

#define	IET_DECODED	( IET_BINARY )

struct  HCHARSET__
    {
    DWORD unused;
    };
typedef struct HCHARSET__ *HCHARSET;

typedef HCHARSET __RPC_FAR *LPHCHARSET;

struct  HBODY__
    {
    DWORD unused;
    };
typedef struct HBODY__ *HBODY;

typedef HBODY __RPC_FAR *LPHBODY;

struct  HHEADERROW__
    {
    DWORD unused;
    };
typedef struct HHEADERROW__ *HHEADERROW;

typedef HHEADERROW __RPC_FAR *LPHHEADERROW;

#define	CCHMAX_HEADER_LINE	( 1000 )


EXTERN_C const IID LIBID_MIMEOLE;

#ifndef __IMimeInternational_INTERFACE_DEFINED__
#define __IMimeInternational_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeInternational
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeInternational __RPC_FAR *LPMIMEINTERNATIONAL;

typedef DWORD CODEPAGEID;

#define	CP_USASCII	( 1252 )

#define	CP_UNICODE	( 1200 )

#define	CP_JAUTODETECT	( 50932 )

#define	CCHMAX_CSET_NAME	( 128 )

#define	CCHMAX_LANG_NAME	( 128 )

#define	CCHMAX_FACE_NAME	( 128 )

typedef struct  tagINETCSETINFO
    {
    CHAR szName[ 128 ];
    HCHARSET hCharset;
    CODEPAGEID cpiWindows;
    CODEPAGEID cpiInternet;
    DWORD dwReserved1;
    }	INETCSETINFO;

typedef struct tagINETCSETINFO __RPC_FAR *LPINETCSETINFO;

typedef
enum tagINETLANGMASK
    {	ILM_FAMILY	= 0x1,
	ILM_NAME	= 0x2,
	ILM_BODYCSET	= 0x4,
	ILM_HEADERCSET	= 0x8,
	ILM_WEBCSET	= 0x10,
	ILM_FIXEDFONT	= 0x20,
	ILM_VARIABLEFONT	= 0x40
    }	INETLANGMASK;

typedef struct  tagCODEPAGEINFO
    {
    DWORD dwMask;
    CODEPAGEID cpiCodePage;
    BOOL fIsValidCodePage;
    ULONG ulMaxCharSize;
    BOOL fInternetCP;
    CODEPAGEID cpiFamily;
    CHAR szName[ 128 ];
    CHAR szBodyCset[ 128 ];
    CHAR szHeaderCset[ 128 ];
    CHAR szWebCset[ 128 ];
    CHAR szFixedFont[ 128 ];
    CHAR szVariableFont[ 128 ];
    ENCODINGTYPE ietNewsDefault;
    ENCODINGTYPE ietMailDefault;
    DWORD dwReserved1;
    }	CODEPAGEINFO;

typedef struct tagCODEPAGEINFO __RPC_FAR *LPCODEPAGEINFO;

typedef struct  tagRFC1522INFO
    {
    BOOL fRfc1522Allowed;
    BOOL fRfc1522Used;
    BOOL fAllow8bit;
    HCHARSET hRfc1522Cset;
    }	RFC1522INFO;

typedef struct tagRFC1522INFO __RPC_FAR *LPRFC1522INFO;

typedef
enum tagCHARSETTYPE
    {	CHARSET_BODY	= 0,
	CHARSET_HEADER	= CHARSET_BODY + 1,
	CHARSET_WEB	= CHARSET_HEADER + 1
    }	CHARSETTYPE;


EXTERN_C const IID IID_IMimeInternational;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F6-C19B-11d0-85EB-00C04FD85AB4")
    IMimeInternational : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDefaultCharset(
            /* [in] */ HCHARSET hCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDefaultCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCodePageCharset(
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [in] */ CHARSETTYPE ctCsetType,
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindCharset(
            /* [in] */ LPCSTR pszCharset,
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharsetInfo(
            /* [in] */ HCHARSET hCharset,
            /* [out][in] */ LPINETCSETINFO pCsetInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCodePageInfo(
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [out][in] */ LPCODEPAGEINFO pCodePageInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE CanConvertCodePages(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeHeader(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPCSTR pszData,
            /* [out][in] */ LPPROPVARIANT pDecoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info) = 0;

        virtual HRESULT STDMETHODCALLTYPE EncodeHeader(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPPROPVARIANT pData,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info) = 0;

        virtual HRESULT STDMETHODCALLTYPE ConvertBuffer(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPBLOB pIn,
            /* [out][in] */ LPBLOB pOut,
            /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;

        virtual HRESULT STDMETHODCALLTYPE ConvertString(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPPROPVARIANT pIn,
            /* [out][in] */ LPPROPVARIANT pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE MLANG_ConvertInetReset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE MLANG_ConvertInetString(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPCSTR pSource,
            /* [in] */ int __RPC_FAR *pnSizeOfSource,
            /* [out] */ LPSTR pDestination,
            /* [in] */ int __RPC_FAR *pnDstSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE Rfc1522Decode(
            /* [in] */ LPCSTR pszValue,
            /* [ref][in] */ LPSTR pszCharset,
            /* [in] */ ULONG cchmax,
            /* [out] */ LPSTR __RPC_FAR *ppszDecoded) = 0;

        virtual HRESULT STDMETHODCALLTYPE Rfc1522Encode(
            /* [in] */ LPCSTR pszValue,
            /* [in] */ HCHARSET hCharset,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeInternationalVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeInternational __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeInternational __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [in] */ CHARSETTYPE ctCsetType,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ LPCSTR pszCharset,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharsetInfo )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [out][in] */ LPINETCSETINFO pCsetInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageInfo )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [out][in] */ LPCODEPAGEINFO pCodePageInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanConvertCodePages )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeHeader )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPCSTR pszData,
            /* [out][in] */ LPPROPVARIANT pDecoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeHeader )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPPROPVARIANT pData,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertBuffer )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPBLOB pIn,
            /* [out][in] */ LPBLOB pOut,
            /* [out] */ ULONG __RPC_FAR *pcbRead);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertString )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPPROPVARIANT pIn,
            /* [out][in] */ LPPROPVARIANT pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MLANG_ConvertInetReset )(
            IMimeInternational __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MLANG_ConvertInetString )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPCSTR pSource,
            /* [in] */ int __RPC_FAR *pnSizeOfSource,
            /* [out] */ LPSTR pDestination,
            /* [in] */ int __RPC_FAR *pnDstSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rfc1522Decode )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ LPCSTR pszValue,
            /* [ref][in] */ LPSTR pszCharset,
            /* [in] */ ULONG cchmax,
            /* [out] */ LPSTR __RPC_FAR *ppszDecoded);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rfc1522Encode )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ LPCSTR pszValue,
            /* [in] */ HCHARSET hCharset,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded);

        END_INTERFACE
    } IMimeInternationalVtbl;

    interface IMimeInternational
    {
        CONST_VTBL struct IMimeInternationalVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeInternational_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeInternational_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeInternational_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeInternational_SetDefaultCharset(This,hCharset)	\
    (This)->lpVtbl -> SetDefaultCharset(This,hCharset)

#define IMimeInternational_GetDefaultCharset(This,phCharset)	\
    (This)->lpVtbl -> GetDefaultCharset(This,phCharset)

#define IMimeInternational_GetCodePageCharset(This,cpiCodePage,ctCsetType,phCharset)	\
    (This)->lpVtbl -> GetCodePageCharset(This,cpiCodePage,ctCsetType,phCharset)

#define IMimeInternational_FindCharset(This,pszCharset,phCharset)	\
    (This)->lpVtbl -> FindCharset(This,pszCharset,phCharset)

#define IMimeInternational_GetCharsetInfo(This,hCharset,pCsetInfo)	\
    (This)->lpVtbl -> GetCharsetInfo(This,hCharset,pCsetInfo)

#define IMimeInternational_GetCodePageInfo(This,cpiCodePage,pCodePageInfo)	\
    (This)->lpVtbl -> GetCodePageInfo(This,cpiCodePage,pCodePageInfo)

#define IMimeInternational_CanConvertCodePages(This,cpiSource,cpiDest)	\
    (This)->lpVtbl -> CanConvertCodePages(This,cpiSource,cpiDest)

#define IMimeInternational_DecodeHeader(This,hCharset,pszData,pDecoded,pRfc1522Info)	\
    (This)->lpVtbl -> DecodeHeader(This,hCharset,pszData,pDecoded,pRfc1522Info)

#define IMimeInternational_EncodeHeader(This,hCharset,pData,ppszEncoded,pRfc1522Info)	\
    (This)->lpVtbl -> EncodeHeader(This,hCharset,pData,ppszEncoded,pRfc1522Info)

#define IMimeInternational_ConvertBuffer(This,cpiSource,cpiDest,pIn,pOut,pcbRead)	\
    (This)->lpVtbl -> ConvertBuffer(This,cpiSource,cpiDest,pIn,pOut,pcbRead)

#define IMimeInternational_ConvertString(This,cpiSource,cpiDest,pIn,pOut)	\
    (This)->lpVtbl -> ConvertString(This,cpiSource,cpiDest,pIn,pOut)

#define IMimeInternational_MLANG_ConvertInetReset(This)	\
    (This)->lpVtbl -> MLANG_ConvertInetReset(This)

#define IMimeInternational_MLANG_ConvertInetString(This,cpiSource,cpiDest,pSource,pnSizeOfSource,pDestination,pnDstSize)	\
    (This)->lpVtbl -> MLANG_ConvertInetString(This,cpiSource,cpiDest,pSource,pnSizeOfSource,pDestination,pnDstSize)

#define IMimeInternational_Rfc1522Decode(This,pszValue,pszCharset,cchmax,ppszDecoded)	\
    (This)->lpVtbl -> Rfc1522Decode(This,pszValue,pszCharset,cchmax,ppszDecoded)

#define IMimeInternational_Rfc1522Encode(This,pszValue,hCharset,ppszEncoded)	\
    (This)->lpVtbl -> Rfc1522Encode(This,pszValue,hCharset,ppszEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeInternational_SetDefaultCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset);


void __RPC_STUB IMimeInternational_SetDefaultCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetDefaultCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeInternational_GetDefaultCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetCodePageCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiCodePage,
    /* [in] */ CHARSETTYPE ctCsetType,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeInternational_GetCodePageCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_FindCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ LPCSTR pszCharset,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeInternational_FindCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetCharsetInfo_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [out][in] */ LPINETCSETINFO pCsetInfo);


void __RPC_STUB IMimeInternational_GetCharsetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetCodePageInfo_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiCodePage,
    /* [out][in] */ LPCODEPAGEINFO pCodePageInfo);


void __RPC_STUB IMimeInternational_GetCodePageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_CanConvertCodePages_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest);


void __RPC_STUB IMimeInternational_CanConvertCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_DecodeHeader_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ LPCSTR pszData,
    /* [out][in] */ LPPROPVARIANT pDecoded,
    /* [out][in] */ LPRFC1522INFO pRfc1522Info);


void __RPC_STUB IMimeInternational_DecodeHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_EncodeHeader_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ LPPROPVARIANT pData,
    /* [out] */ LPSTR __RPC_FAR *ppszEncoded,
    /* [out][in] */ LPRFC1522INFO pRfc1522Info);


void __RPC_STUB IMimeInternational_EncodeHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_ConvertBuffer_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest,
    /* [in] */ LPBLOB pIn,
    /* [out][in] */ LPBLOB pOut,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


void __RPC_STUB IMimeInternational_ConvertBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_ConvertString_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest,
    /* [in] */ LPPROPVARIANT pIn,
    /* [out][in] */ LPPROPVARIANT pOut);


void __RPC_STUB IMimeInternational_ConvertString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_MLANG_ConvertInetReset_Proxy(
    IMimeInternational __RPC_FAR * This);


void __RPC_STUB IMimeInternational_MLANG_ConvertInetReset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_MLANG_ConvertInetString_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest,
    /* [in] */ LPCSTR pSource,
    /* [in] */ int __RPC_FAR *pnSizeOfSource,
    /* [out] */ LPSTR pDestination,
    /* [in] */ int __RPC_FAR *pnDstSize);


void __RPC_STUB IMimeInternational_MLANG_ConvertInetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_Rfc1522Decode_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ LPCSTR pszValue,
    /* [ref][in] */ LPSTR pszCharset,
    /* [in] */ ULONG cchmax,
    /* [out] */ LPSTR __RPC_FAR *ppszDecoded);


void __RPC_STUB IMimeInternational_Rfc1522Decode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_Rfc1522Encode_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ LPCSTR pszValue,
    /* [in] */ HCHARSET hCharset,
    /* [out] */ LPSTR __RPC_FAR *ppszEncoded);


void __RPC_STUB IMimeInternational_Rfc1522Encode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeInternational_INTERFACE_DEFINED__ */


#ifndef __IMimeSecurity_INTERFACE_DEFINED__
#define __IMimeSecurity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeSecurity
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeSecurity __RPC_FAR *LPMIMESECURITY;

typedef /* [unique] */ const IMimeSecurity __RPC_FAR *LPCMIMESECURITY;

typedef BLOB THUMBBLOB;

typedef const void __RPC_FAR *PCX509CERT;

typedef void __RPC_FAR *HCAPICERTSTORE;

#ifndef IMS_ALGIDDEF
#define IMS_ALGIDDEF
typedef unsigned int ALG_ID;

#endif
typedef
enum tagCERTSTATE
    {	CERTIFICATE_OK	= 0,
	CERTIFICATE_NOT_PRESENT	= CERTIFICATE_OK + 1,
	CERTIFICATE_EXPIRED	= CERTIFICATE_NOT_PRESENT + 1,
	CERTIFICATE_CHAIN_TOO_LONG	= CERTIFICATE_EXPIRED + 1,
	CERTIFICATE_TIMES_DONT_NEST	= CERTIFICATE_CHAIN_TOO_LONG + 1,
	CERTIFICATE_MISSING_ISSUER	= CERTIFICATE_TIMES_DONT_NEST + 1,
	CERTIFICATE_CRL_LISTED	= CERTIFICATE_MISSING_ISSUER + 1,
	CERTIFICATE_NOT_TRUSTED	= CERTIFICATE_CRL_LISTED + 1,
	CERTIFICATE_INVALID	= CERTIFICATE_NOT_TRUSTED + 1,
	CERTIFICATE_ERROR	= CERTIFICATE_INVALID + 1,
	CERTIFICATE_NOPRINT	= CERTIFICATE_ERROR + 1,
	CERTIFICATE_UNKNOWN	= CERTIFICATE_NOPRINT + 1
    }	CERTSTATE;

typedef
enum tagCERTNAMETYPE
    {	SIMPLE	= 0,
	OID	= SIMPLE + 1,
	X500	= OID + 1
    }	CERTNAMETYPE;

typedef
enum tagSECURESTATE
    {	SECURITY_TOGGLE	= -1,
	SECURITY_DISABLED	= SECURITY_TOGGLE + 1,
	SECURITY_ENABLED	= SECURITY_DISABLED + 1,
	SECURITY_BAD	= SECURITY_ENABLED + 1,
	SECURITY_UNTRUSTED	= SECURITY_BAD + 1,
	SECURITY_UNKNOWN	= SECURITY_UNTRUSTED + 1,
	SECURITY_STATE_MAX	= SECURITY_UNKNOWN + 1
    }	SECURESTATE;

typedef
enum tagCERTDATAID
    {	CDID_EMAIL	= 0,
	CDID_MAX	= CDID_EMAIL + 1
    }	CERTDATAID;

typedef
enum tagSECURETYPE
    {	SECURITY_NONE	= 0,
	SMIME_ENCRYPT	= 0x1,
	SMIME_SIGN	= 0x2,
	SMIME_CLEARSIGN	= 0x4,
	SMIME_SIGNANDENCRYPT	= SMIME_ENCRYPT | SMIME_SIGN
    }	SECURETYPE;

typedef
enum tagSECURECLASS
    {	ISC_NULL	= 0,
	ISC_SIGNED	= SMIME_SIGN | SMIME_CLEARSIGN,
	ISC_ENCRYPTED	= SMIME_ENCRYPT,
	ISC_ALL	= 0xffff
    }	SECURECLASS;

typedef struct  tagSMIMESECURITY
    {
    SECURESTATE stState;
    LPSTR oidAlg;
    ULONG cCert;
    PCX509CERT __RPC_FAR *rgpCert;
    }	SMIMESECURITY;

typedef struct tagSMIMESECURITY __RPC_FAR *PSMIMESECURITY;

typedef const SMIMESECURITY __RPC_FAR *PCSMIMESECURITY;

typedef struct  tagSMIMEINFO
    {
    SECURETYPE stMsgEnhancement;
    SMIMESECURITY ssSign;
    SMIMESECURITY ssEncrypt;
    PCX509CERT pSendersCert;
    BOOL fTrustedCert;
    BOOL fCertWithMsg;
    DWORD dwIgnoreFlags;
    HCAPICERTSTORE hMsgCertStore;
    }	SMIMEINFO;

typedef struct tagSMIMEINFO __RPC_FAR *PSMIMEINFO;

typedef const SMIMEINFO __RPC_FAR *PCSMIMEINFO;

typedef struct  tagX509CERTRESULT
    {
    DWORD cEntries;
    CERTSTATE __RPC_FAR *rgcs;
    PCX509CERT __RPC_FAR *rgpCert;
    }	X509CERTRESULT;

typedef struct tagX509CERTRESULT __RPC_FAR *PX509CERTRESULT;

typedef const X509CERTRESULT __RPC_FAR *PCX509CERTRESULT;


EXTERN_C const IID IID_IMimeSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1FE-C19B-11d0-85EB-00C04FD85AB4")
    IMimeSecurity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeMessage(
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeMessage(
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EncodeStream(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeStream(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE EncodeBlob(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeBlob(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeDetachedStream(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ const LPSTREAM lpstmSig,
            /* [in] */ LPSTREAM lpstmOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeDetachedBlob(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pData,
            /* [in] */ const LPBLOB pSig,
            /* [out] */ LPBLOB pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE CheckInit( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE AddCertificateToStore(
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ PCX509CERT pCert,
            /* [in] */ const BOOL fReplace,
            /* [in] */ const BOOL fAllowDups) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenSystemStore(
            /* [in] */ LPCTSTR szProtocol,
            /* [ref][out] */ HCAPICERTSTORE __RPC_FAR *pc) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseCertificateStore(
            /* [in] */ HCAPICERTSTORE hc) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertsFromThumbprints(
            /* [in] */ THUMBBLOB __RPC_FAR *const rgThumbprint,
            /* [out][in] */ X509CERTRESULT __RPC_FAR *const pResults) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumCertificates(
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ DWORD dwUsage,
            /* [in] */ PCX509CERT pPrev,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppCert) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertificateName(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTNAMETYPE cn,
            /* [retval][out] */ LPSTR __RPC_FAR *ppszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertificateThumbprint(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ THUMBBLOB __RPC_FAR *const pPrint) = 0;

        virtual HRESULT STDMETHODCALLTYPE DuplicateCertificate(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppDupCert) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeCertificate(
            /* [unique][in] */ const PCX509CERT pc) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetMessageType(
            /* [unique][in] */ const LPSTREAM lpstmIn,
            /* [retval][out] */ SECURETYPE __RPC_FAR *pst) = 0;

        virtual HRESULT STDMETHODCALLTYPE VerifyTimeValidity(
            /* [in] */ const PCX509CERT pX509Cert) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertData(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTDATAID dataid,
            /* [ref][out] */ LPPROPVARIANT pValue) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeSecurityVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeSecurity __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeSecurity __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeMessage )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeMessage )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeStream )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeStream )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeBlob )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeBlob )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeDetachedStream )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ const LPSTREAM lpstmSig,
            /* [in] */ LPSTREAM lpstmOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeDetachedBlob )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pData,
            /* [in] */ const LPBLOB pSig,
            /* [out] */ LPBLOB pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeSecurity __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckInit )(
            IMimeSecurity __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddCertificateToStore )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ PCX509CERT pCert,
            /* [in] */ const BOOL fReplace,
            /* [in] */ const BOOL fAllowDups);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenSystemStore )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ LPCTSTR szProtocol,
            /* [ref][out] */ HCAPICERTSTORE __RPC_FAR *pc);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseCertificateStore )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ HCAPICERTSTORE hc);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertsFromThumbprints )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ THUMBBLOB __RPC_FAR *const rgThumbprint,
            /* [out][in] */ X509CERTRESULT __RPC_FAR *const pResults);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCertificates )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ DWORD dwUsage,
            /* [in] */ PCX509CERT pPrev,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppCert);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertificateName )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTNAMETYPE cn,
            /* [retval][out] */ LPSTR __RPC_FAR *ppszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertificateThumbprint )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ THUMBBLOB __RPC_FAR *const pPrint);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DuplicateCertificate )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppDupCert);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeCertificate )(
            IMimeSecurity __RPC_FAR * This,
            /* [unique][in] */ const PCX509CERT pc);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageType )(
            IMimeSecurity __RPC_FAR * This,
            /* [unique][in] */ const LPSTREAM lpstmIn,
            /* [retval][out] */ SECURETYPE __RPC_FAR *pst);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *VerifyTimeValidity )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertData )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTDATAID dataid,
            /* [ref][out] */ LPPROPVARIANT pValue);

        END_INTERFACE
    } IMimeSecurityVtbl;

    interface IMimeSecurity
    {
        CONST_VTBL struct IMimeSecurityVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeSecurity_EncodeMessage(This,pTree,dwFlags)	\
    (This)->lpVtbl -> EncodeMessage(This,pTree,dwFlags)

#define IMimeSecurity_DecodeMessage(This,pTree,dwFlags)	\
    (This)->lpVtbl -> DecodeMessage(This,pTree,dwFlags)

#define IMimeSecurity_EncodeStream(This,psi,lpstmIn,lpstmOut)	\
    (This)->lpVtbl -> EncodeStream(This,psi,lpstmIn,lpstmOut)

#define IMimeSecurity_DecodeStream(This,psi,lpstmIn,lpstmOut)	\
    (This)->lpVtbl -> DecodeStream(This,psi,lpstmIn,lpstmOut)

#define IMimeSecurity_EncodeBlob(This,psi,pIn,pOut)	\
    (This)->lpVtbl -> EncodeBlob(This,psi,pIn,pOut)

#define IMimeSecurity_DecodeBlob(This,psi,pIn,pOut)	\
    (This)->lpVtbl -> DecodeBlob(This,psi,pIn,pOut)

#define IMimeSecurity_DecodeDetachedStream(This,psi,lpstmIn,lpstmSig,lpstmOut)	\
    (This)->lpVtbl -> DecodeDetachedStream(This,psi,lpstmIn,lpstmSig,lpstmOut)

#define IMimeSecurity_DecodeDetachedBlob(This,psi,pData,pSig,pOut)	\
    (This)->lpVtbl -> DecodeDetachedBlob(This,psi,pData,pSig,pOut)

#define IMimeSecurity_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IMimeSecurity_CheckInit(This)	\
    (This)->lpVtbl -> CheckInit(This)

#define IMimeSecurity_AddCertificateToStore(This,hc,pCert,fReplace,fAllowDups)	\
    (This)->lpVtbl -> AddCertificateToStore(This,hc,pCert,fReplace,fAllowDups)

#define IMimeSecurity_OpenSystemStore(This,szProtocol,pc)	\
    (This)->lpVtbl -> OpenSystemStore(This,szProtocol,pc)

#define IMimeSecurity_CloseCertificateStore(This,hc)	\
    (This)->lpVtbl -> CloseCertificateStore(This,hc)

#define IMimeSecurity_GetCertsFromThumbprints(This,rgThumbprint,pResults)	\
    (This)->lpVtbl -> GetCertsFromThumbprints(This,rgThumbprint,pResults)

#define IMimeSecurity_EnumCertificates(This,hc,dwUsage,pPrev,ppCert)	\
    (This)->lpVtbl -> EnumCertificates(This,hc,dwUsage,pPrev,ppCert)

#define IMimeSecurity_GetCertificateName(This,pX509Cert,cn,ppszName)	\
    (This)->lpVtbl -> GetCertificateName(This,pX509Cert,cn,ppszName)

#define IMimeSecurity_GetCertificateThumbprint(This,pX509Cert,pPrint)	\
    (This)->lpVtbl -> GetCertificateThumbprint(This,pX509Cert,pPrint)

#define IMimeSecurity_DuplicateCertificate(This,pX509Cert,ppDupCert)	\
    (This)->lpVtbl -> DuplicateCertificate(This,pX509Cert,ppDupCert)

#define IMimeSecurity_FreeCertificate(This,pc)	\
    (This)->lpVtbl -> FreeCertificate(This,pc)

#define IMimeSecurity_GetMessageType(This,lpstmIn,pst)	\
    (This)->lpVtbl -> GetMessageType(This,lpstmIn,pst)

#define IMimeSecurity_VerifyTimeValidity(This,pX509Cert)	\
    (This)->lpVtbl -> VerifyTimeValidity(This,pX509Cert)

#define IMimeSecurity_GetCertData(This,pX509Cert,dataid,pValue)	\
    (This)->lpVtbl -> GetCertData(This,pX509Cert,dataid,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeSecurity_EncodeMessage_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMimeSecurity_EncodeMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeMessage_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMimeSecurity_DecodeMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_EncodeStream_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPSTREAM lpstmIn,
    /* [in] */ LPSTREAM lpstmOut);


void __RPC_STUB IMimeSecurity_EncodeStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeStream_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPSTREAM lpstmIn,
    /* [in] */ LPSTREAM lpstmOut);


void __RPC_STUB IMimeSecurity_DecodeStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_EncodeBlob_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPBLOB pIn,
    /* [out] */ LPBLOB pOut);


void __RPC_STUB IMimeSecurity_EncodeBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeBlob_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPBLOB pIn,
    /* [out] */ LPBLOB pOut);


void __RPC_STUB IMimeSecurity_DecodeBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeDetachedStream_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPSTREAM lpstmIn,
    /* [in] */ const LPSTREAM lpstmSig,
    /* [in] */ LPSTREAM lpstmOut);


void __RPC_STUB IMimeSecurity_DecodeDetachedStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeDetachedBlob_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPBLOB pData,
    /* [in] */ const LPBLOB pSig,
    /* [out] */ LPBLOB pOut);


void __RPC_STUB IMimeSecurity_DecodeDetachedBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_InitNew_Proxy(
    IMimeSecurity __RPC_FAR * This);


void __RPC_STUB IMimeSecurity_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_CheckInit_Proxy(
    IMimeSecurity __RPC_FAR * This);


void __RPC_STUB IMimeSecurity_CheckInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_AddCertificateToStore_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ HCAPICERTSTORE hc,
    /* [in] */ PCX509CERT pCert,
    /* [in] */ const BOOL fReplace,
    /* [in] */ const BOOL fAllowDups);


void __RPC_STUB IMimeSecurity_AddCertificateToStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_OpenSystemStore_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ LPCTSTR szProtocol,
    /* [ref][out] */ HCAPICERTSTORE __RPC_FAR *pc);


void __RPC_STUB IMimeSecurity_OpenSystemStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_CloseCertificateStore_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ HCAPICERTSTORE hc);


void __RPC_STUB IMimeSecurity_CloseCertificateStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertsFromThumbprints_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ THUMBBLOB __RPC_FAR *const rgThumbprint,
    /* [out][in] */ X509CERTRESULT __RPC_FAR *const pResults);


void __RPC_STUB IMimeSecurity_GetCertsFromThumbprints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_EnumCertificates_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ HCAPICERTSTORE hc,
    /* [in] */ DWORD dwUsage,
    /* [in] */ PCX509CERT pPrev,
    /* [retval][out] */ PCX509CERT __RPC_FAR *ppCert);


void __RPC_STUB IMimeSecurity_EnumCertificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertificateName_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [in] */ const CERTNAMETYPE cn,
    /* [retval][out] */ LPSTR __RPC_FAR *ppszName);


void __RPC_STUB IMimeSecurity_GetCertificateName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertificateThumbprint_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [retval][out] */ THUMBBLOB __RPC_FAR *const pPrint);


void __RPC_STUB IMimeSecurity_GetCertificateThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DuplicateCertificate_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [retval][out] */ PCX509CERT __RPC_FAR *ppDupCert);


void __RPC_STUB IMimeSecurity_DuplicateCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_FreeCertificate_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [unique][in] */ const PCX509CERT pc);


void __RPC_STUB IMimeSecurity_FreeCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetMessageType_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [unique][in] */ const LPSTREAM lpstmIn,
    /* [retval][out] */ SECURETYPE __RPC_FAR *pst);


void __RPC_STUB IMimeSecurity_GetMessageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_VerifyTimeValidity_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert);


void __RPC_STUB IMimeSecurity_VerifyTimeValidity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertData_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [in] */ const CERTDATAID dataid,
    /* [ref][out] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeSecurity_GetCertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeSecurity_INTERFACE_DEFINED__ */


#ifndef __IMimeSecurityOptions_INTERFACE_DEFINED__
#define __IMimeSecurityOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeSecurityOptions
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][ref][helpstring][uuid] */


typedef /* [unique] */ IMimeSecurityOptions __RPC_FAR *LPMIMESECURITYOPTIONS;

typedef /* [unique] */ const IMimeSecurityOptions __RPC_FAR *LPCMIMESECURITYOPTIONS;


EXTERN_C const IID IID_IMimeSecurityOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F4-C19B-11d0-85EB-00C04FD85AB4")
    IMimeSecurityOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddChainForSenderOnCertificateInclusion( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE IncludeRecipientCertificates( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE AddChainForRecipientsOnCertificateInclusion( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsDecodedMessage( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE IncludeSendersCertificate( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSecurity(
            /* [out] */ SECURETYPE __RPC_FAR *__RPC_FAR *rgtype,
            /* [out] */ SECURESTATE __RPC_FAR *__RPC_FAR *rgstate,
            /* [out] */ ULONG __RPC_FAR *pcTypes) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetHashAlgId(
            /* [retval][out] */ ALG_ID __RPC_FAR *aid) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetEncryptionAlgId(
            /* [retval][out] */ ALG_ID __RPC_FAR *aid) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSendersThumbprints(
            /* [out] */ THUMBBLOB __RPC_FAR *__RPC_FAR *prgPrints,
            /* [out] */ DWORD __RPC_FAR *pCount) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeSecurityOptionsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeSecurityOptions __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddChainForSenderOnCertificateInclusion )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncludeRecipientCertificates )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddChainForRecipientsOnCertificateInclusion )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDecodedMessage )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncludeSendersCertificate )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecurity )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [out] */ SECURETYPE __RPC_FAR *__RPC_FAR *rgtype,
            /* [out] */ SECURESTATE __RPC_FAR *__RPC_FAR *rgstate,
            /* [out] */ ULONG __RPC_FAR *pcTypes);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHashAlgId )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [retval][out] */ ALG_ID __RPC_FAR *aid);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEncryptionAlgId )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [retval][out] */ ALG_ID __RPC_FAR *aid);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSendersThumbprints )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [out] */ THUMBBLOB __RPC_FAR *__RPC_FAR *prgPrints,
            /* [out] */ DWORD __RPC_FAR *pCount);

        END_INTERFACE
    } IMimeSecurityOptionsVtbl;

    interface IMimeSecurityOptions
    {
        CONST_VTBL struct IMimeSecurityOptionsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeSecurityOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeSecurityOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeSecurityOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeSecurityOptions_AddChainForSenderOnCertificateInclusion(This)	\
    (This)->lpVtbl -> AddChainForSenderOnCertificateInclusion(This)

#define IMimeSecurityOptions_IncludeRecipientCertificates(This)	\
    (This)->lpVtbl -> IncludeRecipientCertificates(This)

#define IMimeSecurityOptions_AddChainForRecipientsOnCertificateInclusion(This)	\
    (This)->lpVtbl -> AddChainForRecipientsOnCertificateInclusion(This)

#define IMimeSecurityOptions_IsDecodedMessage(This)	\
    (This)->lpVtbl -> IsDecodedMessage(This)

#define IMimeSecurityOptions_IncludeSendersCertificate(This)	\
    (This)->lpVtbl -> IncludeSendersCertificate(This)

#define IMimeSecurityOptions_GetSecurity(This,rgtype,rgstate,pcTypes)	\
    (This)->lpVtbl -> GetSecurity(This,rgtype,rgstate,pcTypes)

#define IMimeSecurityOptions_GetHashAlgId(This,aid)	\
    (This)->lpVtbl -> GetHashAlgId(This,aid)

#define IMimeSecurityOptions_GetEncryptionAlgId(This,aid)	\
    (This)->lpVtbl -> GetEncryptionAlgId(This,aid)

#define IMimeSecurityOptions_GetSendersThumbprints(This,prgPrints,pCount)	\
    (This)->lpVtbl -> GetSendersThumbprints(This,prgPrints,pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_AddChainForSenderOnCertificateInclusion_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_AddChainForSenderOnCertificateInclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_IncludeRecipientCertificates_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_IncludeRecipientCertificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_AddChainForRecipientsOnCertificateInclusion_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_AddChainForRecipientsOnCertificateInclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_IsDecodedMessage_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_IsDecodedMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_IncludeSendersCertificate_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_IncludeSendersCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetSecurity_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [out] */ SECURETYPE __RPC_FAR *__RPC_FAR *rgtype,
    /* [out] */ SECURESTATE __RPC_FAR *__RPC_FAR *rgstate,
    /* [out] */ ULONG __RPC_FAR *pcTypes);


void __RPC_STUB IMimeSecurityOptions_GetSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetHashAlgId_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [retval][out] */ ALG_ID __RPC_FAR *aid);


void __RPC_STUB IMimeSecurityOptions_GetHashAlgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetEncryptionAlgId_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [retval][out] */ ALG_ID __RPC_FAR *aid);


void __RPC_STUB IMimeSecurityOptions_GetEncryptionAlgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetSendersThumbprints_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [out] */ THUMBBLOB __RPC_FAR *__RPC_FAR *prgPrints,
    /* [out] */ DWORD __RPC_FAR *pCount);


void __RPC_STUB IMimeSecurityOptions_GetSendersThumbprints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeSecurityOptions_INTERFACE_DEFINED__ */


#ifndef __IMimeSecurityInfo_INTERFACE_DEFINED__
#define __IMimeSecurityInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeSecurityInfo
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][unique][helpstring][uuid] */


typedef /* [unique] */ IMimeSecurityInfo __RPC_FAR *LPMIMESECURITYINFO;

typedef /* [unique] */ const IMimeSecurityInfo __RPC_FAR *LPCMIMESECURITYINFO;

typedef struct  tagSECUREINFO
    {
    SECURETYPE stMsgEnhancement;
    SECURESTATE ssSign;
    SECURESTATE ssEncrypt;
    ALG_ID aidHash;
    ALG_ID aidEncryption;
    PCX509CERT pSendersCert;
    BOOL fTrustedCert;
    BOOL fCertWithMsg;
    }	SECUREINFO;

typedef struct tagSECUREINFO __RPC_FAR *PSECUREINFO;

typedef const SECUREINFO __RPC_FAR *PCSECUREINFO;


EXTERN_C const IID IID_IMimeSecurityInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F3-C19B-11d0-85EB-00C04FD85AB4")
    IMimeSecurityInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetDefaults(
            /* [in] */ IMimeSecurityOptions __RPC_FAR *pOptSet) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetDefaultsFromSI(
            /* [in] */ const SMIMEINFO __RPC_FAR *const psi) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsNew( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE DefaultsBeenSet( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetOption(
            /* [in] */ const ULONG ulOptionId,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOption(
            /* [in] */ const ULONG ulOptionId,
            /* [ref][out] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetSecurityType(
            /* [in] */ const SECURETYPE flag,
            /* [in] */ const SECURESTATE state) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSecurityState(
            /* [in] */ const SECURECLASS type,
            /* [out] */ SECURESTATE __RPC_FAR *pState) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDecodedInfo(
            /* [ref][out] */ SECUREINFO __RPC_FAR *const pInfo) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeSecurityInfoVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeSecurityInfo __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaults )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ IMimeSecurityOptions __RPC_FAR *pOptSet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultsFromSI )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const SMIMEINFO __RPC_FAR *const psi);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsNew )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefaultsBeenSet )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const ULONG ulOptionId,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const ULONG ulOptionId,
            /* [ref][out] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecurityType )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const SECURETYPE flag,
            /* [in] */ const SECURESTATE state);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecurityState )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const SECURECLASS type,
            /* [out] */ SECURESTATE __RPC_FAR *pState);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDecodedInfo )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [ref][out] */ SECUREINFO __RPC_FAR *const pInfo);

        END_INTERFACE
    } IMimeSecurityInfoVtbl;

    interface IMimeSecurityInfo
    {
        CONST_VTBL struct IMimeSecurityInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeSecurityInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeSecurityInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeSecurityInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeSecurityInfo_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IMimeSecurityInfo_SetDefaults(This,pOptSet)	\
    (This)->lpVtbl -> SetDefaults(This,pOptSet)

#define IMimeSecurityInfo_SetDefaultsFromSI(This,psi)	\
    (This)->lpVtbl -> SetDefaultsFromSI(This,psi)

#define IMimeSecurityInfo_IsNew(This)	\
    (This)->lpVtbl -> IsNew(This)

#define IMimeSecurityInfo_DefaultsBeenSet(This)	\
    (This)->lpVtbl -> DefaultsBeenSet(This)

#define IMimeSecurityInfo_SetOption(This,ulOptionId,pValue)	\
    (This)->lpVtbl -> SetOption(This,ulOptionId,pValue)

#define IMimeSecurityInfo_GetOption(This,ulOptionId,pValue)	\
    (This)->lpVtbl -> GetOption(This,ulOptionId,pValue)

#define IMimeSecurityInfo_SetSecurityType(This,flag,state)	\
    (This)->lpVtbl -> SetSecurityType(This,flag,state)

#define IMimeSecurityInfo_GetSecurityState(This,type,pState)	\
    (This)->lpVtbl -> GetSecurityState(This,type,pState)

#define IMimeSecurityInfo_GetDecodedInfo(This,pInfo)	\
    (This)->lpVtbl -> GetDecodedInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_InitNew_Proxy(
    IMimeSecurityInfo __RPC_FAR * This);


void __RPC_STUB IMimeSecurityInfo_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetDefaults_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ IMimeSecurityOptions __RPC_FAR *pOptSet);


void __RPC_STUB IMimeSecurityInfo_SetDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetDefaultsFromSI_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const SMIMEINFO __RPC_FAR *const psi);


void __RPC_STUB IMimeSecurityInfo_SetDefaultsFromSI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_IsNew_Proxy(
    IMimeSecurityInfo __RPC_FAR * This);


void __RPC_STUB IMimeSecurityInfo_IsNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_DefaultsBeenSet_Proxy(
    IMimeSecurityInfo __RPC_FAR * This);


void __RPC_STUB IMimeSecurityInfo_DefaultsBeenSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetOption_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const ULONG ulOptionId,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeSecurityInfo_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_GetOption_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const ULONG ulOptionId,
    /* [ref][out] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeSecurityInfo_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetSecurityType_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const SECURETYPE flag,
    /* [in] */ const SECURESTATE state);


void __RPC_STUB IMimeSecurityInfo_SetSecurityType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_GetSecurityState_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const SECURECLASS type,
    /* [out] */ SECURESTATE __RPC_FAR *pState);


void __RPC_STUB IMimeSecurityInfo_GetSecurityState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_GetDecodedInfo_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [ref][out] */ SECUREINFO __RPC_FAR *const pInfo);


void __RPC_STUB IMimeSecurityInfo_GetDecodedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeSecurityInfo_INTERFACE_DEFINED__ */


#ifndef __IMimeHeaderTable_INTERFACE_DEFINED__
#define __IMimeHeaderTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeHeaderTable
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef struct  tagFINDHEADER
    {
    LPCSTR pszHeader;
    DWORD dwReserved;
    }	FINDHEADER;

typedef struct tagFINDHEADER __RPC_FAR *LPFINDHEADER;

typedef struct  tagHEADERROWINFO
    {
    DWORD dwRowNumber;
    ULONG cboffStart;
    ULONG cboffColon;
    ULONG cboffEnd;
    }	HEADERROWINFO;

typedef struct tagHEADERROWINFO __RPC_FAR *LPHEADERROWINFO;

typedef
enum tagHEADERTABLEFLAGS
    {	HTF_NAMEINDATA	= 0x1,
	HTF_ENUMHANDLESONLY	= 0x2
    }	HEADERTABLEFLAGS;


EXTERN_C const IID IID_IMimeHeaderTable;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A202-C19B-11d0-85EB-00C04FD85AB4")
    IMimeHeaderTable : public IPersistStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindFirstRow(
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindNextRow(
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountRows(
            /* [in] */ LPCSTR pszHeader,
            /* [out] */ ULONG __RPC_FAR *pcRows) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendRow(
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData,
            /* [out] */ LPHHEADERROW phRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteRow(
            /* [in] */ HHEADERROW hRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetRowData(
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPSTR __RPC_FAR *ppszData,
            /* [out] */ ULONG __RPC_FAR *pcchData) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetRowData(
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetRowInfo(
            /* [in] */ HHEADERROW hRow,
            /* [out][in] */ LPHEADERROWINFO pInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetRowNumber(
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwRowNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumRows(
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeHeaderTable __RPC_FAR *__RPC_FAR *ppTable) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeHeaderTableVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeHeaderTable __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeHeaderTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeHeaderTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountRows )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPCSTR pszHeader,
            /* [out] */ ULONG __RPC_FAR *pcRows);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData,
            /* [out] */ LPHHEADERROW phRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowData )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPSTR __RPC_FAR *ppszData,
            /* [out] */ ULONG __RPC_FAR *pcchData);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowData )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowInfo )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [out][in] */ LPHEADERROWINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowNumber )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwRowNumber);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRows )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [out] */ IMimeHeaderTable __RPC_FAR *__RPC_FAR *ppTable);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        END_INTERFACE
    } IMimeHeaderTableVtbl;

    interface IMimeHeaderTable
    {
        CONST_VTBL struct IMimeHeaderTableVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeHeaderTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeHeaderTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeHeaderTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeHeaderTable_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeHeaderTable_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeHeaderTable_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeHeaderTable_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeHeaderTable_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)


#define IMimeHeaderTable_FindFirstRow(This,pFindHeader,phRow)	\
    (This)->lpVtbl -> FindFirstRow(This,pFindHeader,phRow)

#define IMimeHeaderTable_FindNextRow(This,pFindHeader,phRow)	\
    (This)->lpVtbl -> FindNextRow(This,pFindHeader,phRow)

#define IMimeHeaderTable_CountRows(This,pszHeader,pcRows)	\
    (This)->lpVtbl -> CountRows(This,pszHeader,pcRows)

#define IMimeHeaderTable_AppendRow(This,pszHeader,dwFlags,pszData,cchData,phRow)	\
    (This)->lpVtbl -> AppendRow(This,pszHeader,dwFlags,pszData,cchData,phRow)

#define IMimeHeaderTable_DeleteRow(This,hRow)	\
    (This)->lpVtbl -> DeleteRow(This,hRow)

#define IMimeHeaderTable_GetRowData(This,hRow,dwFlags,ppszData,pcchData)	\
    (This)->lpVtbl -> GetRowData(This,hRow,dwFlags,ppszData,pcchData)

#define IMimeHeaderTable_SetRowData(This,hRow,dwFlags,pszData,cchData)	\
    (This)->lpVtbl -> SetRowData(This,hRow,dwFlags,pszData,cchData)

#define IMimeHeaderTable_GetRowInfo(This,hRow,pInfo)	\
    (This)->lpVtbl -> GetRowInfo(This,hRow,pInfo)

#define IMimeHeaderTable_SetRowNumber(This,hRow,dwRowNumber)	\
    (This)->lpVtbl -> SetRowNumber(This,hRow,dwRowNumber)

#define IMimeHeaderTable_EnumRows(This,pszHeader,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumRows(This,pszHeader,dwFlags,ppEnum)

#define IMimeHeaderTable_Clone(This,ppTable)	\
    (This)->lpVtbl -> Clone(This,ppTable)

#define IMimeHeaderTable_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeHeaderTable_FindFirstRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPFINDHEADER pFindHeader,
    /* [out] */ LPHHEADERROW phRow);


void __RPC_STUB IMimeHeaderTable_FindFirstRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_FindNextRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPFINDHEADER pFindHeader,
    /* [out] */ LPHHEADERROW phRow);


void __RPC_STUB IMimeHeaderTable_FindNextRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_CountRows_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPCSTR pszHeader,
    /* [out] */ ULONG __RPC_FAR *pcRows);


void __RPC_STUB IMimeHeaderTable_CountRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_AppendRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPCSTR pszHeader,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCSTR pszData,
    /* [in] */ ULONG cchData,
    /* [out] */ LPHHEADERROW phRow);


void __RPC_STUB IMimeHeaderTable_AppendRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_DeleteRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow);


void __RPC_STUB IMimeHeaderTable_DeleteRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_GetRowData_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LPSTR __RPC_FAR *ppszData,
    /* [out] */ ULONG __RPC_FAR *pcchData);


void __RPC_STUB IMimeHeaderTable_GetRowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_SetRowData_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCSTR pszData,
    /* [in] */ ULONG cchData);


void __RPC_STUB IMimeHeaderTable_SetRowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_GetRowInfo_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [out][in] */ LPHEADERROWINFO pInfo);


void __RPC_STUB IMimeHeaderTable_GetRowInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_SetRowNumber_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [in] */ DWORD dwRowNumber);


void __RPC_STUB IMimeHeaderTable_SetRowNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_EnumRows_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPCSTR pszHeader,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeHeaderTable_EnumRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_Clone_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [out] */ IMimeHeaderTable __RPC_FAR *__RPC_FAR *ppTable);


void __RPC_STUB IMimeHeaderTable_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_BindToObject_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimeHeaderTable_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeHeaderTable_INTERFACE_DEFINED__ */


#ifndef __IMimePropertySchema_INTERFACE_DEFINED__
#define __IMimePropertySchema_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimePropertySchema
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimePropertySchema __RPC_FAR *LPMIMEPROPERTYSCHEMA;

typedef
enum tagMIMEPROPFLAGS
    {	MPF_INETCSET	= 0x1,
	MPF_RFC1522	= 0x2,
	MPF_ADDRESS	= 0x4,
	MPF_HASPARAMS	= 0x8,
	MPF_MIME	= 0x10,
	MPF_READONLY	= 0x20
    }	MIMEPROPFLAGS;


EXTERN_C const IID IID_IMimePropertySchema;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A20A-C19B-11d0-85EB-00C04FD85AB4")
    IMimePropertySchema : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterProperty(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber,
            /* [out] */ LPDWORD pdwPropId) = 0;

        virtual HRESULT STDMETHODCALLTYPE ModifyProperty(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetPropertyId(
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwPropId) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetPropertyName(
            /* [in] */ DWORD dwPropId,
            /* [out] */ LPSTR __RPC_FAR *ppszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE RegisterAddressType(
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwAdrType) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimePropertySchemaVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimePropertySchema __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimePropertySchema __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterProperty )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber,
            /* [out] */ LPDWORD pdwPropId);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyProperty )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyId )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwPropId);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyName )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ DWORD dwPropId,
            /* [out] */ LPSTR __RPC_FAR *ppszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterAddressType )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwAdrType);

        END_INTERFACE
    } IMimePropertySchemaVtbl;

    interface IMimePropertySchema
    {
        CONST_VTBL struct IMimePropertySchemaVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimePropertySchema_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimePropertySchema_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimePropertySchema_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimePropertySchema_RegisterProperty(This,pszName,dwFlags,dwRowNumber,pdwPropId)	\
    (This)->lpVtbl -> RegisterProperty(This,pszName,dwFlags,dwRowNumber,pdwPropId)

#define IMimePropertySchema_ModifyProperty(This,pszName,dwFlags,dwRowNumber)	\
    (This)->lpVtbl -> ModifyProperty(This,pszName,dwFlags,dwRowNumber)

#define IMimePropertySchema_GetPropertyId(This,pszName,pdwPropId)	\
    (This)->lpVtbl -> GetPropertyId(This,pszName,pdwPropId)

#define IMimePropertySchema_GetPropertyName(This,dwPropId,ppszName)	\
    (This)->lpVtbl -> GetPropertyName(This,dwPropId,ppszName)

#define IMimePropertySchema_RegisterAddressType(This,pszName,pdwAdrType)	\
    (This)->lpVtbl -> RegisterAddressType(This,pszName,pdwAdrType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimePropertySchema_RegisterProperty_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRowNumber,
    /* [out] */ LPDWORD pdwPropId);


void __RPC_STUB IMimePropertySchema_RegisterProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_ModifyProperty_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRowNumber);


void __RPC_STUB IMimePropertySchema_ModifyProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_GetPropertyId_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ LPDWORD pdwPropId);


void __RPC_STUB IMimePropertySchema_GetPropertyId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_GetPropertyName_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ DWORD dwPropId,
    /* [out] */ LPSTR __RPC_FAR *ppszName);


void __RPC_STUB IMimePropertySchema_GetPropertyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_RegisterAddressType_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ LPDWORD pdwAdrType);


void __RPC_STUB IMimePropertySchema_RegisterAddressType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimePropertySchema_INTERFACE_DEFINED__ */


#ifndef __IMimePropertySet_INTERFACE_DEFINED__
#define __IMimePropertySet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimePropertySet
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimePropertySet __RPC_FAR *LPMIMEPROPERTYSET;

typedef
enum tagPROPDATAFLAGS
    {	PDF_ENCODED	= 0x1,
	PDF_NAMEINDATA	= 0x2,
	PDF_HEADERFORMAT	= 0x4 | PDF_ENCODED,
	PDF_NOCOMMENTS	= 0x8
    }	PROPDATAFLAGS;

typedef
enum tagENUMPROPFLAGS
    {	EPF_NONAME	= 0x1
    }	ENUMPROPFLAGS;

typedef struct  tagMIMEPARAMINFO
    {
    LPSTR pszName;
    LPSTR pszData;
    }	MIMEPARAMINFO;

typedef struct tagMIMEPARAMINFO __RPC_FAR *LPMIMEPARAMINFO;

typedef
enum tagPROPINFOMASK
    {	PIM_CHARSET	= 0x1,
	PIM_ENCODINGTYPE	= 0x2,
	PIM_ROWNUMBER	= 0x4,
	PIM_FLAGS	= 0x8,
	PIM_PROPID	= 0x10,
	PIM_VALUES	= 0x20
    }	PROPINFOMASK;

typedef struct  tagMIMEPROPINFO
    {
    DWORD dwMask;
    HCHARSET hCharset;
    ENCODINGTYPE ietEncoding;
    DWORD dwRowNumber;
    DWORD dwFlags;
    DWORD dwPropId;
    DWORD cValues;
    }	MIMEPROPINFO;

typedef struct tagMIMEPROPINFO __RPC_FAR *LPMIMEPROPINFO;


EXTERN_C const IID IID_IMimePropertySet;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A204-C19B-11d0-85EB-00C04FD85AB4")
    IMimePropertySet : public IPersistStreamInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropInfo(
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ LPMIMEPROPINFO pInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetPropInfo(
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPMIMEPROPINFO pInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteProp(
            /* [in] */ LPCSTR pszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE CopyProps(
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet) = 0;

        virtual HRESULT STDMETHODCALLTYPE MoveProps(
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteExcept(
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE QueryProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCharset(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetParameters(
            /* [in] */ LPCSTR pszName,
            /* [out] */ ULONG __RPC_FAR *pcParams,
            /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsContentType(
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetOption(
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOption(
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumProps(
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimePropertySetVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimePropertySet __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimePropertySet __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimePropertySet __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimePropertySet __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropInfo )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropInfo )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyProps )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveProps )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteExcept )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParameters )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ ULONG __RPC_FAR *pcParams,
            /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumProps )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);

        END_INTERFACE
    } IMimePropertySetVtbl;

    interface IMimePropertySet
    {
        CONST_VTBL struct IMimePropertySetVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimePropertySet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimePropertySet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimePropertySet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimePropertySet_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimePropertySet_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimePropertySet_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimePropertySet_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimePropertySet_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimePropertySet_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimePropertySet_GetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> GetPropInfo(This,pszName,pInfo)

#define IMimePropertySet_SetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> SetPropInfo(This,pszName,pInfo)

#define IMimePropertySet_GetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetProp(This,pszName,dwFlags,pValue)

#define IMimePropertySet_SetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetProp(This,pszName,dwFlags,pValue)

#define IMimePropertySet_AppendProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> AppendProp(This,pszName,dwFlags,pValue)

#define IMimePropertySet_DeleteProp(This,pszName)	\
    (This)->lpVtbl -> DeleteProp(This,pszName)

#define IMimePropertySet_CopyProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> CopyProps(This,cNames,prgszName,pPropertySet)

#define IMimePropertySet_MoveProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> MoveProps(This,cNames,prgszName,pPropertySet)

#define IMimePropertySet_DeleteExcept(This,cNames,prgszName)	\
    (This)->lpVtbl -> DeleteExcept(This,cNames,prgszName)

#define IMimePropertySet_QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimePropertySet_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimePropertySet_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimePropertySet_GetParameters(This,pszName,pcParams,pprgParam)	\
    (This)->lpVtbl -> GetParameters(This,pszName,pcParams,pprgParam)

#define IMimePropertySet_IsContentType(This,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,pszPriType,pszSubType)

#define IMimePropertySet_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#define IMimePropertySet_Clone(This,ppPropertySet)	\
    (This)->lpVtbl -> Clone(This,ppPropertySet)

#define IMimePropertySet_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimePropertySet_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)

#define IMimePropertySet_EnumProps(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumProps(This,dwFlags,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimePropertySet_GetPropInfo_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ LPMIMEPROPINFO pInfo);


void __RPC_STUB IMimePropertySet_GetPropInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetPropInfo_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPMIMEPROPINFO pInfo);


void __RPC_STUB IMimePropertySet_SetPropInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_AppendProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_AppendProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_DeleteProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName);


void __RPC_STUB IMimePropertySet_DeleteProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_CopyProps_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ ULONG cNames,
    /* [in] */ LPCSTR __RPC_FAR *prgszName,
    /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);


void __RPC_STUB IMimePropertySet_CopyProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_MoveProps_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ ULONG cNames,
    /* [in] */ LPCSTR __RPC_FAR *prgszName,
    /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);


void __RPC_STUB IMimePropertySet_MoveProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_DeleteExcept_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ ULONG cNames,
    /* [in] */ LPCSTR __RPC_FAR *prgszName);


void __RPC_STUB IMimePropertySet_DeleteExcept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_QueryProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszCriteria,
    /* [in] */ boolean fSubString,
    /* [in] */ boolean fCaseSensitive);


void __RPC_STUB IMimePropertySet_QueryProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetCharset_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimePropertySet_GetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetCharset_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ CSETAPPLYTYPE applytype);


void __RPC_STUB IMimePropertySet_SetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetParameters_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ ULONG __RPC_FAR *pcParams,
    /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam);


void __RPC_STUB IMimePropertySet_GetParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_IsContentType_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszPriType,
    /* [in] */ LPCSTR pszSubType);


void __RPC_STUB IMimePropertySet_IsContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_BindToObject_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimePropertySet_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_Clone_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet);


void __RPC_STUB IMimePropertySet_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetOption_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetOption_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_EnumProps_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimePropertySet_EnumProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimePropertySet_INTERFACE_DEFINED__ */


#ifndef __IMimeAddressInfo_INTERFACE_DEFINED__
#define __IMimeAddressInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeAddressInfo
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeAddressInfo __RPC_FAR *LPMIMEADDRESSINFO;

typedef DWORD IADDRESSTYPE;

#define	IAT_UNKNOWN	( 0 )

#define	IAT_FROM	( 0x1 )

#define	IAT_SENDER	( 0x2 )

#define	IAT_TO	( 0x4 )

#define	IAT_CC	( 0x8 )

#define	IAT_BCC	( 0x10 )

#define	IAT_REPLYTO	( 0x20 )

#define	IAT_RETURNPATH	( 0x40 )

#define	IAT_RETRCPTTO	( 0x80 )

#define	IAT_RR	( 0x100 )

#define	IAT_APPARTO	( 0x200 )


EXTERN_C const IID IID_IMimeAddressInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EF-C19B-11d0-85EB-00C04FD85AB4")
    IMimeAddressInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetId(
            /* [out] */ LPDWORD pdwId) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetType(
            /* [out] */ LPDWORD pdwAdrType) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetType(
            /* [in] */ DWORD dwAdrType) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetAddress(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddress(
            /* [out] */ LPSTR __RPC_FAR *pszFriendly,
            /* [out] */ LPSTR __RPC_FAR *ppszEmail) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertState(
            /* [out] */ CERTSTATE __RPC_FAR *pcertstate) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCertState(
            /* [in] */ CERTSTATE certstate) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetThumbprint(
            /* [in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetThumbprint(
            /* [unique][out][in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType) = 0;

        virtual HRESULT STDMETHODCALLTYPE CopyTo(
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress,
            /* [in] */ boolean fIncludeType) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCharset(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeAddressInfoVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeAddressInfo __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeAddressInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPDWORD pdwId);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPDWORD pdwAdrType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAddress )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddress )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *pszFriendly,
            /* [out] */ LPSTR __RPC_FAR *ppszEmail);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertState )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ CERTSTATE __RPC_FAR *pcertstate);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCertState )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ CERTSTATE certstate);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThumbprint )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThumbprint )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [unique][out][in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress,
            /* [in] */ boolean fIncludeType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )(
            IMimeAddressInfo __RPC_FAR * This);

        END_INTERFACE
    } IMimeAddressInfoVtbl;

    interface IMimeAddressInfo
    {
        CONST_VTBL struct IMimeAddressInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeAddressInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeAddressInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeAddressInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeAddressInfo_GetId(This,pdwId)	\
    (This)->lpVtbl -> GetId(This,pdwId)

#define IMimeAddressInfo_GetType(This,pdwAdrType)	\
    (This)->lpVtbl -> GetType(This,pdwAdrType)

#define IMimeAddressInfo_SetType(This,dwAdrType)	\
    (This)->lpVtbl -> SetType(This,dwAdrType)

#define IMimeAddressInfo_SetAddress(This,ietEncoding,pszFriendly,pszEmail)	\
    (This)->lpVtbl -> SetAddress(This,ietEncoding,pszFriendly,pszEmail)

#define IMimeAddressInfo_GetAddress(This,pszFriendly,ppszEmail)	\
    (This)->lpVtbl -> GetAddress(This,pszFriendly,ppszEmail)

#define IMimeAddressInfo_GetCertState(This,pcertstate)	\
    (This)->lpVtbl -> GetCertState(This,pcertstate)

#define IMimeAddressInfo_SetCertState(This,certstate)	\
    (This)->lpVtbl -> SetCertState(This,certstate)

#define IMimeAddressInfo_SetThumbprint(This,pThumbPrint,dwType)	\
    (This)->lpVtbl -> SetThumbprint(This,pThumbPrint,dwType)

#define IMimeAddressInfo_GetThumbprint(This,pThumbPrint,dwType)	\
    (This)->lpVtbl -> GetThumbprint(This,pThumbPrint,dwType)

#define IMimeAddressInfo_CopyTo(This,pAddress,fIncludeType)	\
    (This)->lpVtbl -> CopyTo(This,pAddress,fIncludeType)

#define IMimeAddressInfo_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeAddressInfo_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeAddressInfo_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetId_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPDWORD pdwId);


void __RPC_STUB IMimeAddressInfo_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetType_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPDWORD pdwAdrType);


void __RPC_STUB IMimeAddressInfo_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetType_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType);


void __RPC_STUB IMimeAddressInfo_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetAddress_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszFriendly,
    /* [in] */ LPCSTR pszEmail);


void __RPC_STUB IMimeAddressInfo_SetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetAddress_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *pszFriendly,
    /* [out] */ LPSTR __RPC_FAR *ppszEmail);


void __RPC_STUB IMimeAddressInfo_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetCertState_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ CERTSTATE __RPC_FAR *pcertstate);


void __RPC_STUB IMimeAddressInfo_GetCertState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetCertState_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ CERTSTATE certstate);


void __RPC_STUB IMimeAddressInfo_SetCertState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetThumbprint_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ LPBLOB pThumbPrint,
    /* [in] */ DWORD dwType);


void __RPC_STUB IMimeAddressInfo_SetThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetThumbprint_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [unique][out][in] */ LPBLOB pThumbPrint,
    /* [in] */ DWORD dwType);


void __RPC_STUB IMimeAddressInfo_GetThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_CopyTo_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress,
    /* [in] */ boolean fIncludeType);


void __RPC_STUB IMimeAddressInfo_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetCharset_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ CSETAPPLYTYPE applytype);


void __RPC_STUB IMimeAddressInfo_SetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetCharset_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeAddressInfo_GetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_Delete_Proxy(
    IMimeAddressInfo __RPC_FAR * This);


void __RPC_STUB IMimeAddressInfo_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeAddressInfo_INTERFACE_DEFINED__ */


#ifndef __IMimeAddressTable_INTERFACE_DEFINED__
#define __IMimeAddressTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeAddressTable
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeAddressTable __RPC_FAR *LPMIMEADDRESSTABLE;

#define	IAT_ALL	( ( DWORD  )0xffffffff )

#define	IAT_KNOWN	( ( DWORD  )(IAT_FROM | IAT_TO | IAT_CC | IAT_BCC | IAT_REPLYTO | IAT_SENDER) )

#define	IAT_RECIPS	( ( DWORD  )(IAT_TO | IAT_CC | IAT_BCC) )

typedef
enum tagADDRESSFORMAT
    {	AFT_DISPLAY_FRIENDLY	= 0,
	AFT_DISPLAY_EMAIL	= AFT_DISPLAY_FRIENDLY + 1,
	AFT_DISPLAY_BOTH	= AFT_DISPLAY_EMAIL + 1,
	AFT_RFC822_DECODED	= AFT_DISPLAY_BOTH + 1,
	AFT_RFC822_ENCODED	= AFT_RFC822_DECODED + 1,
	AFT_RFC822_TRANSMIT	= AFT_RFC822_ENCODED + 1
    }	ADDRESSFORMAT;

typedef struct  tagADDRESSLIST
    {
    ULONG cAddresses;
    IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress;
    }	ADDRESSLIST;

typedef struct tagADDRESSLIST __RPC_FAR *LPADDRESSLIST;


EXTERN_C const IID IID_IMimeAddressTable;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EE-C19B-11d0-85EB-00C04FD85AB4")
    IMimeAddressTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSender(
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ ULONG __RPC_FAR *pcAddresses) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteTypes(
            /* [in] */ DWORD dwAdrTypes) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendBasic(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendNew(
            /* [in] */ DWORD dwAdrType,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendAs(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendList(
            /* [in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendRfc822(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetFormat(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE ParseRfc822(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr,
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeAddressTableVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeAddressTable __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeAddressTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSender )(
            IMimeAddressTable __RPC_FAR * This,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ ULONG __RPC_FAR *pcAddresses);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )(
            IMimeAddressTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendBasic )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendNew )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendAs )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendList )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendRfc822 )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseRfc822 )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeAddressTable __RPC_FAR * This,
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        END_INTERFACE
    } IMimeAddressTableVtbl;

    interface IMimeAddressTable
    {
        CONST_VTBL struct IMimeAddressTableVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeAddressTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeAddressTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeAddressTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeAddressTable_GetSender(This,ppAddress)	\
    (This)->lpVtbl -> GetSender(This,ppAddress)

#define IMimeAddressTable_CountTypes(This,dwAdrTypes,pcAddresses)	\
    (This)->lpVtbl -> CountTypes(This,dwAdrTypes,pcAddresses)

#define IMimeAddressTable_EnumTypes(This,dwAdrTypes,ppEnum)	\
    (This)->lpVtbl -> EnumTypes(This,dwAdrTypes,ppEnum)

#define IMimeAddressTable_GetTypes(This,dwAdrTypes,pList)	\
    (This)->lpVtbl -> GetTypes(This,dwAdrTypes,pList)

#define IMimeAddressTable_DeleteTypes(This,dwAdrTypes)	\
    (This)->lpVtbl -> DeleteTypes(This,dwAdrTypes)

#define IMimeAddressTable_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#define IMimeAddressTable_AppendBasic(This,dwAdrType,ietEncoding,pszFriendly,pszEmail)	\
    (This)->lpVtbl -> AppendBasic(This,dwAdrType,ietEncoding,pszFriendly,pszEmail)

#define IMimeAddressTable_AppendNew(This,dwAdrType,ppAddress)	\
    (This)->lpVtbl -> AppendNew(This,dwAdrType,ppAddress)

#define IMimeAddressTable_AppendAs(This,dwAdrType,pAddress)	\
    (This)->lpVtbl -> AppendAs(This,dwAdrType,pAddress)

#define IMimeAddressTable_AppendList(This,pList)	\
    (This)->lpVtbl -> AppendList(This,pList)

#define IMimeAddressTable_AppendRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr)	\
    (This)->lpVtbl -> AppendRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr)

#define IMimeAddressTable_GetFormat(This,dwAdrType,format,ppszAddress)	\
    (This)->lpVtbl -> GetFormat(This,dwAdrType,format,ppszAddress)

#define IMimeAddressTable_ParseRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr,pList)	\
    (This)->lpVtbl -> ParseRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr,pList)

#define IMimeAddressTable_Clone(This,ppTable)	\
    (This)->lpVtbl -> Clone(This,ppTable)

#define IMimeAddressTable_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeAddressTable_GetSender_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB IMimeAddressTable_GetSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_CountTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out] */ ULONG __RPC_FAR *pcAddresses);


void __RPC_STUB IMimeAddressTable_CountTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_EnumTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeAddressTable_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_GetTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAddressTable_GetTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_DeleteTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes);


void __RPC_STUB IMimeAddressTable_DeleteTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_DeleteAll_Proxy(
    IMimeAddressTable __RPC_FAR * This);


void __RPC_STUB IMimeAddressTable_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendBasic_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszFriendly,
    /* [in] */ LPCSTR pszEmail);


void __RPC_STUB IMimeAddressTable_AppendBasic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendNew_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB IMimeAddressTable_AppendNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendAs_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress);


void __RPC_STUB IMimeAddressTable_AppendAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendList_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAddressTable_AppendList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendRfc822_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszRfc822Adr);


void __RPC_STUB IMimeAddressTable_AppendRfc822_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_GetFormat_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ADDRESSFORMAT format,
    /* [out] */ LPSTR __RPC_FAR *ppszAddress);


void __RPC_STUB IMimeAddressTable_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_ParseRfc822_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszRfc822Adr,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAddressTable_ParseRfc822_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_Clone_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);


void __RPC_STUB IMimeAddressTable_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_BindToObject_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimeAddressTable_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeAddressTable_INTERFACE_DEFINED__ */


#ifndef __IMimeWebDocument_INTERFACE_DEFINED__
#define __IMimeWebDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeWebDocument
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */



EXTERN_C const IID IID_IMimeWebDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EC-C19B-11d0-85EB-00C04FD85AB4")
    IMimeWebDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetURL(
            /* [out] */ LPSTR __RPC_FAR *ppszURL) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToStorage(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *ppvObject) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeWebDocumentVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeWebDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeWebDocument __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeWebDocument __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )(
            IMimeWebDocument __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *ppszURL);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToStorage )(
            IMimeWebDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *ppvObject);

        END_INTERFACE
    } IMimeWebDocumentVtbl;

    interface IMimeWebDocument
    {
        CONST_VTBL struct IMimeWebDocumentVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeWebDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeWebDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeWebDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeWebDocument_GetURL(This,ppszURL)	\
    (This)->lpVtbl -> GetURL(This,ppszURL)

#define IMimeWebDocument_BindToStorage(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToStorage(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeWebDocument_GetURL_Proxy(
    IMimeWebDocument __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *ppszURL);


void __RPC_STUB IMimeWebDocument_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeWebDocument_BindToStorage_Proxy(
    IMimeWebDocument __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *ppvObject);


void __RPC_STUB IMimeWebDocument_BindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeWebDocument_INTERFACE_DEFINED__ */


#ifndef __IMimeBody_INTERFACE_DEFINED__
#define __IMimeBody_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeBody
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeBody __RPC_FAR *LPMIMEBODY;

typedef struct  tagBODYOFFSETS
    {
    DWORD cbBoundaryStart;
    DWORD cbHeaderStart;
    DWORD cbBodyStart;
    DWORD cbBodyEnd;
    }	BODYOFFSETS;

typedef struct tagBODYOFFSETS __RPC_FAR *LPBODYOFFSETS;

typedef
enum tagIMSGBODYTYPE
    {	IBT_SECURE	= 0,
	IBT_ATTACHMENT	= IBT_SECURE + 1,
	IBT_EMPTY	= IBT_ATTACHMENT + 1
    }	IMSGBODYTYPE;

typedef struct  tagTRANSMITINFO
    {
    ENCODINGTYPE ietCurrent;
    ENCODINGTYPE ietOption;
    ENCODINGTYPE ietXmitMime;
    ENCODINGTYPE ietXmit822;
    ULONG cbLongestLine;
    ULONG cExtended;
    ULONG ulPercentExt;
    ULONG cbSize;
    ULONG cLines;
    }	TRANSMITINFO;

typedef struct tagTRANSMITINFO __RPC_FAR *LPTRANSMITINFO;


EXTERN_C const IID IID_IMimeBody;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F8-C19B-11d0-85EB-00C04FD85AB4")
    IMimeBody : public IMimePropertySet
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsType(
            /* [in] */ IMSGBODYTYPE bodytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetDisplayName(
            /* [in] */ LPCSTR pszDisplay) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDisplayName(
            /* [out] */ LPSTR __RPC_FAR *ppszDisplay) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOffsets(
            /* [out] */ LPBODYOFFSETS pOffsets) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCurrentEncoding(
            /* [out] */ ENCODINGTYPE __RPC_FAR *pietEncoding) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCurrentEncoding(
            /* [in] */ ENCODINGTYPE ietEncoding) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetEstimatedSize(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ ULONG __RPC_FAR *pcbSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDataHere(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ IStream __RPC_FAR *pStream) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetData(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetData(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pvObject) = 0;

        virtual HRESULT STDMETHODCALLTYPE EmptyData( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE CopyTo(
            /* [in] */ IMimeBody __RPC_FAR *pBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTransmitInfo(
            /* [out][in] */ LPTRANSMITINFO pTransmitInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE SaveToFile(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFilePath) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetHandle(
            /* [out] */ LPHBODY phBody) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeBodyVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeBody __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropInfo )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropInfo )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyProps )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveProps )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteExcept )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParameters )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ ULONG __RPC_FAR *pcParams,
            /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumProps )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsType )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ IMSGBODYTYPE bodytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDisplayName )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszDisplay);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *ppszDisplay);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOffsets )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPBODYOFFSETS pOffsets);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentEncoding )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ ENCODINGTYPE __RPC_FAR *pietEncoding);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrentEncoding )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEstimatedSize )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ ULONG __RPC_FAR *pcbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataHere )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ IStream __RPC_FAR *pStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetData )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyData )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ IMimeBody __RPC_FAR *pBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransmitInfo )(
            IMimeBody __RPC_FAR * This,
            /* [out][in] */ LPTRANSMITINFO pTransmitInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToFile )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFilePath);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHandle )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPHBODY phBody);

        END_INTERFACE
    } IMimeBodyVtbl;

    interface IMimeBody
    {
        CONST_VTBL struct IMimeBodyVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeBody_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeBody_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeBody_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeBody_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeBody_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeBody_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeBody_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeBody_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimeBody_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimeBody_GetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> GetPropInfo(This,pszName,pInfo)

#define IMimeBody_SetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> SetPropInfo(This,pszName,pInfo)

#define IMimeBody_GetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetProp(This,pszName,dwFlags,pValue)

#define IMimeBody_SetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetProp(This,pszName,dwFlags,pValue)

#define IMimeBody_AppendProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> AppendProp(This,pszName,dwFlags,pValue)

#define IMimeBody_DeleteProp(This,pszName)	\
    (This)->lpVtbl -> DeleteProp(This,pszName)

#define IMimeBody_CopyProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> CopyProps(This,cNames,prgszName,pPropertySet)

#define IMimeBody_MoveProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> MoveProps(This,cNames,prgszName,pPropertySet)

#define IMimeBody_DeleteExcept(This,cNames,prgszName)	\
    (This)->lpVtbl -> DeleteExcept(This,cNames,prgszName)

#define IMimeBody_QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeBody_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeBody_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeBody_GetParameters(This,pszName,pcParams,pprgParam)	\
    (This)->lpVtbl -> GetParameters(This,pszName,pcParams,pprgParam)

#define IMimeBody_IsContentType(This,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,pszPriType,pszSubType)

#define IMimeBody_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#define IMimeBody_Clone(This,ppPropertySet)	\
    (This)->lpVtbl -> Clone(This,ppPropertySet)

#define IMimeBody_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimeBody_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)

#define IMimeBody_EnumProps(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumProps(This,dwFlags,ppEnum)


#define IMimeBody_IsType(This,bodytype)	\
    (This)->lpVtbl -> IsType(This,bodytype)

#define IMimeBody_SetDisplayName(This,pszDisplay)	\
    (This)->lpVtbl -> SetDisplayName(This,pszDisplay)

#define IMimeBody_GetDisplayName(This,ppszDisplay)	\
    (This)->lpVtbl -> GetDisplayName(This,ppszDisplay)

#define IMimeBody_GetOffsets(This,pOffsets)	\
    (This)->lpVtbl -> GetOffsets(This,pOffsets)

#define IMimeBody_GetCurrentEncoding(This,pietEncoding)	\
    (This)->lpVtbl -> GetCurrentEncoding(This,pietEncoding)

#define IMimeBody_SetCurrentEncoding(This,ietEncoding)	\
    (This)->lpVtbl -> SetCurrentEncoding(This,ietEncoding)

#define IMimeBody_GetEstimatedSize(This,ietEncoding,pcbSize)	\
    (This)->lpVtbl -> GetEstimatedSize(This,ietEncoding,pcbSize)

#define IMimeBody_GetDataHere(This,ietEncoding,pStream)	\
    (This)->lpVtbl -> GetDataHere(This,ietEncoding,pStream)

#define IMimeBody_GetData(This,ietEncoding,ppStream)	\
    (This)->lpVtbl -> GetData(This,ietEncoding,ppStream)

#define IMimeBody_SetData(This,ietEncoding,pszPriType,pszSubType,riid,pvObject)	\
    (This)->lpVtbl -> SetData(This,ietEncoding,pszPriType,pszSubType,riid,pvObject)

#define IMimeBody_EmptyData(This)	\
    (This)->lpVtbl -> EmptyData(This)

#define IMimeBody_CopyTo(This,pBody)	\
    (This)->lpVtbl -> CopyTo(This,pBody)

#define IMimeBody_GetTransmitInfo(This,pTransmitInfo)	\
    (This)->lpVtbl -> GetTransmitInfo(This,pTransmitInfo)

#define IMimeBody_SaveToFile(This,ietEncoding,pszFilePath)	\
    (This)->lpVtbl -> SaveToFile(This,ietEncoding,pszFilePath)

#define IMimeBody_GetHandle(This,phBody)	\
    (This)->lpVtbl -> GetHandle(This,phBody)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeBody_IsType_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ IMSGBODYTYPE bodytype);


void __RPC_STUB IMimeBody_IsType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SetDisplayName_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ LPCSTR pszDisplay);


void __RPC_STUB IMimeBody_SetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetDisplayName_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *ppszDisplay);


void __RPC_STUB IMimeBody_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetOffsets_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ LPBODYOFFSETS pOffsets);


void __RPC_STUB IMimeBody_GetOffsets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetCurrentEncoding_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ ENCODINGTYPE __RPC_FAR *pietEncoding);


void __RPC_STUB IMimeBody_GetCurrentEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SetCurrentEncoding_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding);


void __RPC_STUB IMimeBody_SetCurrentEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetEstimatedSize_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [out] */ ULONG __RPC_FAR *pcbSize);


void __RPC_STUB IMimeBody_GetEstimatedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetDataHere_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IMimeBody_GetDataHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetData_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IMimeBody_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SetData_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszPriType,
    /* [in] */ LPCSTR pszSubType,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pvObject);


void __RPC_STUB IMimeBody_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_EmptyData_Proxy(
    IMimeBody __RPC_FAR * This);


void __RPC_STUB IMimeBody_EmptyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_CopyTo_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ IMimeBody __RPC_FAR *pBody);


void __RPC_STUB IMimeBody_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetTransmitInfo_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out][in] */ LPTRANSMITINFO pTransmitInfo);


void __RPC_STUB IMimeBody_GetTransmitInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SaveToFile_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszFilePath);


void __RPC_STUB IMimeBody_SaveToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetHandle_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeBody_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeBody_INTERFACE_DEFINED__ */


#ifndef __IMimeMessageTree_INTERFACE_DEFINED__
#define __IMimeMessageTree_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeMessageTree
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeMessageTree __RPC_FAR *LPMIMEMESSAGETREE;

#define	HBODY_ROOT	( ( HBODY  )0xffffffff )

typedef
enum tagBODYLOCATION
    {	IBL_ROOT	= 0,
	IBL_PARENT	= IBL_ROOT + 1,
	IBL_FIRST	= IBL_PARENT + 1,
	IBL_LAST	= IBL_FIRST + 1,
	IBL_NEXT	= IBL_LAST + 1,
	IBL_PREVIOUS	= IBL_NEXT + 1
    }	BODYLOCATION;

typedef
enum tagBODYDELETEFLAGS
    {	DELETE_PROMOTE_CHILDREN	= 0x1
    }	BODYDELETEFLAGS;

typedef struct  tagFINDBODY
    {
    LPSTR pszPriType;
    LPSTR pszSubType;
    DWORD dwReserved;
    }	FINDBODY;

typedef struct tagFINDBODY __RPC_FAR *LPFINDBODY;


EXTERN_C const IID IID_IMimeMessageTree;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A206-C19B-11d0-85EB-00C04FD85AB4")
    IMimeMessageTree : public IPersistStreamInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateRootMoniker(
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetMessageSource(
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [in] */ boolean fCommitIfDirty) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetMessageSize(
            /* [out] */ ULONG __RPC_FAR *pcbSize,
            /* [in] */ boolean fCommitIfDirty) = 0;

        virtual HRESULT STDMETHODCALLTYPE LoadOffsetTable(
            /* [in] */ IStream __RPC_FAR *pStream) = 0;

        virtual HRESULT STDMETHODCALLTYPE SaveOffsetTable(
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ boolean fCommitIfDirty) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetFlags(
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE HandsOffStorage( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ HBODY hBody,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

        virtual HRESULT STDMETHODCALLTYPE InsertBody(
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetBody(
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteBody(
            /* [in] */ HBODY hBody,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE MoveBody(
            /* [in] */ HBODY hBody,
            /* [in] */ BODYLOCATION location) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountBodies(
            /* [in] */ HBODY hParent,
            /* [in] */ boolean fRecurse,
            /* [out] */ ULONG __RPC_FAR *pcBodies) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindFirst(
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindNext(
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE ResolveURL(
            /* [in] */ HBODY hRelated,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE ToMultipart(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszSubType,
            /* [out] */ LPHBODY phMultipart) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetBodyOffsets(
            /* [in] */ HBODY hBody,
            /* [out][in] */ LPBODYOFFSETS pOffsets) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCharset(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsBodyType(
            /* [in] */ HBODY hBody,
            /* [in] */ IMSGBODYTYPE bodytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsContentType(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType) = 0;

        virtual HRESULT STDMETHODCALLTYPE QueryBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetOption(
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOption(
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeMessageTreeVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeMessageTree __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRootMoniker )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSource )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSize )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadOffsetTable )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveOffsetTable )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffStorage )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ BODYLOCATION location);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountBodies )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hParent,
            /* [in] */ boolean fRecurse,
            /* [out] */ ULONG __RPC_FAR *pcBodies);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirst )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNext )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResolveURL )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hRelated,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToMultipart )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszSubType,
            /* [out] */ LPHBODY phMultipart);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyOffsets )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [out][in] */ LPBODYOFFSETS pOffsets);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsBodyType )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ IMSGBODYTYPE bodytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        END_INTERFACE
    } IMimeMessageTreeVtbl;

    interface IMimeMessageTree
    {
        CONST_VTBL struct IMimeMessageTreeVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeMessageTree_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeMessageTree_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeMessageTree_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeMessageTree_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeMessageTree_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeMessageTree_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeMessageTree_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeMessageTree_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimeMessageTree_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimeMessageTree_CreateRootMoniker(This,pStream,ppMoniker)	\
    (This)->lpVtbl -> CreateRootMoniker(This,pStream,ppMoniker)

#define IMimeMessageTree_GetMessageSource(This,ppStream,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSource(This,ppStream,fCommitIfDirty)

#define IMimeMessageTree_GetMessageSize(This,pcbSize,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSize(This,pcbSize,fCommitIfDirty)

#define IMimeMessageTree_LoadOffsetTable(This,pStream)	\
    (This)->lpVtbl -> LoadOffsetTable(This,pStream)

#define IMimeMessageTree_SaveOffsetTable(This,pStream,fCommitIfDirty)	\
    (This)->lpVtbl -> SaveOffsetTable(This,pStream,fCommitIfDirty)

#define IMimeMessageTree_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IMimeMessageTree_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IMimeMessageTree_HandsOffStorage(This)	\
    (This)->lpVtbl -> HandsOffStorage(This)

#define IMimeMessageTree_BindToObject(This,hBody,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,hBody,riid,ppvObject)

#define IMimeMessageTree_InsertBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> InsertBody(This,location,hPivot,phBody)

#define IMimeMessageTree_GetBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> GetBody(This,location,hPivot,phBody)

#define IMimeMessageTree_DeleteBody(This,hBody,dwFlags)	\
    (This)->lpVtbl -> DeleteBody(This,hBody,dwFlags)

#define IMimeMessageTree_MoveBody(This,hBody,location)	\
    (This)->lpVtbl -> MoveBody(This,hBody,location)

#define IMimeMessageTree_CountBodies(This,hParent,fRecurse,pcBodies)	\
    (This)->lpVtbl -> CountBodies(This,hParent,fRecurse,pcBodies)

#define IMimeMessageTree_FindFirst(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindFirst(This,pFindBody,phBody)

#define IMimeMessageTree_FindNext(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindNext(This,pFindBody,phBody)

#define IMimeMessageTree_ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)	\
    (This)->lpVtbl -> ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)

#define IMimeMessageTree_ToMultipart(This,hBody,pszSubType,phMultipart)	\
    (This)->lpVtbl -> ToMultipart(This,hBody,pszSubType,phMultipart)

#define IMimeMessageTree_GetBodyOffsets(This,hBody,pOffsets)	\
    (This)->lpVtbl -> GetBodyOffsets(This,hBody,pOffsets)

#define IMimeMessageTree_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeMessageTree_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeMessageTree_IsBodyType(This,hBody,bodytype)	\
    (This)->lpVtbl -> IsBodyType(This,hBody,bodytype)

#define IMimeMessageTree_IsContentType(This,hBody,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,hBody,pszPriType,pszSubType)

#define IMimeMessageTree_QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeMessageTree_GetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessageTree_SetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessageTree_DeleteBodyProp(This,hBody,pszName)	\
    (This)->lpVtbl -> DeleteBodyProp(This,hBody,pszName)

#define IMimeMessageTree_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimeMessageTree_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeMessageTree_CreateRootMoniker_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker);


void __RPC_STUB IMimeMessageTree_CreateRootMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetMessageSource_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
    /* [in] */ boolean fCommitIfDirty);


void __RPC_STUB IMimeMessageTree_GetMessageSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetMessageSize_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcbSize,
    /* [in] */ boolean fCommitIfDirty);


void __RPC_STUB IMimeMessageTree_GetMessageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_LoadOffsetTable_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IMimeMessageTree_LoadOffsetTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SaveOffsetTable_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ boolean fCommitIfDirty);


void __RPC_STUB IMimeMessageTree_SaveOffsetTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetFlags_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IMimeMessageTree_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_Commit_Proxy(
    IMimeMessageTree __RPC_FAR * This);


void __RPC_STUB IMimeMessageTree_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_HandsOffStorage_Proxy(
    IMimeMessageTree __RPC_FAR * This);


void __RPC_STUB IMimeMessageTree_HandsOffStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_BindToObject_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimeMessageTree_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_InsertBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ BODYLOCATION location,
    /* [in] */ HBODY hPivot,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_InsertBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ BODYLOCATION location,
    /* [in] */ HBODY hPivot,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_GetBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_DeleteBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMimeMessageTree_DeleteBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_MoveBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ BODYLOCATION location);


void __RPC_STUB IMimeMessageTree_MoveBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_CountBodies_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hParent,
    /* [in] */ boolean fRecurse,
    /* [out] */ ULONG __RPC_FAR *pcBodies);


void __RPC_STUB IMimeMessageTree_CountBodies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_FindFirst_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out][in] */ LPFINDBODY pFindBody,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_FindFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_FindNext_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out][in] */ LPFINDBODY pFindBody,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_FindNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_ResolveURL_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hRelated,
    /* [in] */ LPCSTR pszBase,
    /* [in] */ LPCSTR pszURL,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_ResolveURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_ToMultipart_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszSubType,
    /* [out] */ LPHBODY phMultipart);


void __RPC_STUB IMimeMessageTree_ToMultipart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetBodyOffsets_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [out][in] */ LPBODYOFFSETS pOffsets);


void __RPC_STUB IMimeMessageTree_GetBodyOffsets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetCharset_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeMessageTree_GetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SetCharset_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ CSETAPPLYTYPE applytype);


void __RPC_STUB IMimeMessageTree_SetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_IsBodyType_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ IMSGBODYTYPE bodytype);


void __RPC_STUB IMimeMessageTree_IsBodyType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_IsContentType_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszPriType,
    /* [in] */ LPCSTR pszSubType);


void __RPC_STUB IMimeMessageTree_IsContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_QueryBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszCriteria,
    /* [in] */ boolean fSubString,
    /* [in] */ boolean fCaseSensitive);


void __RPC_STUB IMimeMessageTree_QueryBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_GetBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SetBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_SetBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_DeleteBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName);


void __RPC_STUB IMimeMessageTree_DeleteBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SetOption_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetOption_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeMessageTree_INTERFACE_DEFINED__ */


#ifndef __IMimeMessage_INTERFACE_DEFINED__
#define __IMimeMessage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeMessage
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeMessage __RPC_FAR *LPMIMEMESSAGE;

typedef
enum tagIMSGFLAGS
    {	IMF_ATTACHMENTS	= 0x1,
	IMF_MULTIPART	= 0x2,
	IMF_SUBMULTIPART	= 0x4,
	IMF_MIME	= 0x8,
	IMF_HTML	= 0x10,
	IMF_PLAIN	= 0x20,
	IMF_PARTIAL	= 0x40,
	IMF_SIGNED	= 0x80,
	IMF_ENCRYPTED	= 0x100,
	IMF_TNEF	= 0x200,
	IMF_MHTML	= 0x400,
	IMF_SECURE	= 0x800,
	IMF_TEXT	= 0x1000
    }	IMSGFLAGS;

typedef
enum tagIMSGPRIORITY
    {	IMSG_PRI_LOW	= 5,
	IMSG_PRI_NORMAL	= 3,
	IMSG_PRI_HIGH	= 1
    }	IMSGPRIORITY;

typedef DWORD TEXTTYPE;

typedef LPDWORD LPTEXTTYPE;

#define	TXT_PLAIN	( 0x1 )

#define	TXT_HTML	( 0x2 )

#define	URL_ATTACH_INTO_MIXED	( 0x1 )

#define	URL_ATTACH_GENERATE_CID	( 0x2 )

#define	URL_RESOLVE_MARK	( 0x1 )

#define	SET_TEXT_RELATED	( 0x1 )


EXTERN_C const IID IID_IMimeMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A208-C19B-11d0-85EB-00C04FD85AB4")
    IMimeMessage : public IMimeMessageTree
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteProp(
            /* [in] */ LPCSTR pszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE QueryProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTextBody(
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetTextBody(
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ HBODY hAlternative,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE AttachObject(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pvObject,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE AttachFile(
            /* [in] */ LPCSTR pszFilePath,
            /* [in] */ IStream __RPC_FAR *pstmFile,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE AttachURL(
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IStream __RPC_FAR *pstmURL,
            /* [out] */ LPSTR __RPC_FAR *ppszCID,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAttachments(
            /* [out] */ ULONG __RPC_FAR *pcAttach,
            /* [out] */ LPHBODY __RPC_FAR *pprghAttach) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSender(
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddressTable(
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddressTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddressFormat(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE SplitMessage(
            /* [in] */ ULONG cbMaxPart,
            /* [out] */ IMimeMessageParts __RPC_FAR *__RPC_FAR *ppParts) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetRootMoniker(
            /* [out] */ LPMONIKER __RPC_FAR *ppmk) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeMessageVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeMessage __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRootMoniker )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSource )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSize )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadOffsetTable )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveOffsetTable )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffStorage )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ BODYLOCATION location);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountBodies )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hParent,
            /* [in] */ boolean fRecurse,
            /* [out] */ ULONG __RPC_FAR *pcBodies);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirst )(
            IMimeMessage __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNext )(
            IMimeMessage __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResolveURL )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hRelated,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToMultipart )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszSubType,
            /* [out] */ LPHBODY phMultipart);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyOffsets )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [out][in] */ LPBODYOFFSETS pOffsets);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsBodyType )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ IMSGBODYTYPE bodytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTextBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ HBODY hAlternative,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachObject )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pvObject,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachFile )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszFilePath,
            /* [in] */ IStream __RPC_FAR *pstmFile,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachURL )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IStream __RPC_FAR *pstmURL,
            /* [out] */ LPSTR __RPC_FAR *ppszCID,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttachments )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcAttach,
            /* [out] */ LPHBODY __RPC_FAR *pprghAttach);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSender )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddressTable )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddressTypes )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddressFormat )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SplitMessage )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ ULONG cbMaxPart,
            /* [out] */ IMimeMessageParts __RPC_FAR *__RPC_FAR *ppParts);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootMoniker )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ LPMONIKER __RPC_FAR *ppmk);

        END_INTERFACE
    } IMimeMessageVtbl;

    interface IMimeMessage
    {
        CONST_VTBL struct IMimeMessageVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeMessage_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeMessage_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeMessage_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeMessage_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeMessage_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimeMessage_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimeMessage_CreateRootMoniker(This,pStream,ppMoniker)	\
    (This)->lpVtbl -> CreateRootMoniker(This,pStream,ppMoniker)

#define IMimeMessage_GetMessageSource(This,ppStream,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSource(This,ppStream,fCommitIfDirty)

#define IMimeMessage_GetMessageSize(This,pcbSize,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSize(This,pcbSize,fCommitIfDirty)

#define IMimeMessage_LoadOffsetTable(This,pStream)	\
    (This)->lpVtbl -> LoadOffsetTable(This,pStream)

#define IMimeMessage_SaveOffsetTable(This,pStream,fCommitIfDirty)	\
    (This)->lpVtbl -> SaveOffsetTable(This,pStream,fCommitIfDirty)

#define IMimeMessage_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IMimeMessage_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IMimeMessage_HandsOffStorage(This)	\
    (This)->lpVtbl -> HandsOffStorage(This)

#define IMimeMessage_BindToObject(This,hBody,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,hBody,riid,ppvObject)

#define IMimeMessage_InsertBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> InsertBody(This,location,hPivot,phBody)

#define IMimeMessage_GetBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> GetBody(This,location,hPivot,phBody)

#define IMimeMessage_DeleteBody(This,hBody,dwFlags)	\
    (This)->lpVtbl -> DeleteBody(This,hBody,dwFlags)

#define IMimeMessage_MoveBody(This,hBody,location)	\
    (This)->lpVtbl -> MoveBody(This,hBody,location)

#define IMimeMessage_CountBodies(This,hParent,fRecurse,pcBodies)	\
    (This)->lpVtbl -> CountBodies(This,hParent,fRecurse,pcBodies)

#define IMimeMessage_FindFirst(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindFirst(This,pFindBody,phBody)

#define IMimeMessage_FindNext(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindNext(This,pFindBody,phBody)

#define IMimeMessage_ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)	\
    (This)->lpVtbl -> ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)

#define IMimeMessage_ToMultipart(This,hBody,pszSubType,phMultipart)	\
    (This)->lpVtbl -> ToMultipart(This,hBody,pszSubType,phMultipart)

#define IMimeMessage_GetBodyOffsets(This,hBody,pOffsets)	\
    (This)->lpVtbl -> GetBodyOffsets(This,hBody,pOffsets)

#define IMimeMessage_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeMessage_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeMessage_IsBodyType(This,hBody,bodytype)	\
    (This)->lpVtbl -> IsBodyType(This,hBody,bodytype)

#define IMimeMessage_IsContentType(This,hBody,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,hBody,pszPriType,pszSubType)

#define IMimeMessage_QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeMessage_GetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessage_SetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessage_DeleteBodyProp(This,hBody,pszName)	\
    (This)->lpVtbl -> DeleteBodyProp(This,hBody,pszName)

#define IMimeMessage_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimeMessage_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)


#define IMimeMessage_GetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetProp(This,pszName,dwFlags,pValue)

#define IMimeMessage_SetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetProp(This,pszName,dwFlags,pValue)

#define IMimeMessage_DeleteProp(This,pszName)	\
    (This)->lpVtbl -> DeleteProp(This,pszName)

#define IMimeMessage_QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeMessage_GetTextBody(This,dwTxtType,ietEncoding,ppStream,phBody)	\
    (This)->lpVtbl -> GetTextBody(This,dwTxtType,ietEncoding,ppStream,phBody)

#define IMimeMessage_SetTextBody(This,dwTxtType,ietEncoding,hAlternative,pStream,phBody)	\
    (This)->lpVtbl -> SetTextBody(This,dwTxtType,ietEncoding,hAlternative,pStream,phBody)

#define IMimeMessage_AttachObject(This,riid,pvObject,phBody)	\
    (This)->lpVtbl -> AttachObject(This,riid,pvObject,phBody)

#define IMimeMessage_AttachFile(This,pszFilePath,pstmFile,phBody)	\
    (This)->lpVtbl -> AttachFile(This,pszFilePath,pstmFile,phBody)

#define IMimeMessage_AttachURL(This,pszBase,pszURL,dwFlags,pstmURL,ppszCID,phBody)	\
    (This)->lpVtbl -> AttachURL(This,pszBase,pszURL,dwFlags,pstmURL,ppszCID,phBody)

#define IMimeMessage_GetAttachments(This,pcAttach,pprghAttach)	\
    (This)->lpVtbl -> GetAttachments(This,pcAttach,pprghAttach)

#define IMimeMessage_GetSender(This,ppAddress)	\
    (This)->lpVtbl -> GetSender(This,ppAddress)

#define IMimeMessage_GetAddressTable(This,ppTable)	\
    (This)->lpVtbl -> GetAddressTable(This,ppTable)

#define IMimeMessage_GetAddressTypes(This,dwAdrTypes,pList)	\
    (This)->lpVtbl -> GetAddressTypes(This,dwAdrTypes,pList)

#define IMimeMessage_GetAddressFormat(This,dwAdrType,format,ppszAddress)	\
    (This)->lpVtbl -> GetAddressFormat(This,dwAdrType,format,ppszAddress)

#define IMimeMessage_SplitMessage(This,cbMaxPart,ppParts)	\
    (This)->lpVtbl -> SplitMessage(This,cbMaxPart,ppParts)

#define IMimeMessage_GetRootMoniker(This,ppmk)	\
    (This)->lpVtbl -> GetRootMoniker(This,ppmk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeMessage_GetProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessage_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_SetProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessage_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_DeleteProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName);


void __RPC_STUB IMimeMessage_DeleteProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_QueryProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszCriteria,
    /* [in] */ boolean fSubString,
    /* [in] */ boolean fCaseSensitive);


void __RPC_STUB IMimeMessage_QueryProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetTextBody_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ TEXTTYPE dwTxtType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_GetTextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_SetTextBody_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ TEXTTYPE dwTxtType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ HBODY hAlternative,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_SetTextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_AttachObject_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ void __RPC_FAR *pvObject,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_AttachObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_AttachFile_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszFilePath,
    /* [in] */ IStream __RPC_FAR *pstmFile,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_AttachFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_AttachURL_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszBase,
    /* [in] */ LPCSTR pszURL,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IStream __RPC_FAR *pstmURL,
    /* [out] */ LPSTR __RPC_FAR *ppszCID,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_AttachURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAttachments_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcAttach,
    /* [out] */ LPHBODY __RPC_FAR *pprghAttach);


void __RPC_STUB IMimeMessage_GetAttachments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetSender_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB IMimeMessage_GetSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAddressTable_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);


void __RPC_STUB IMimeMessage_GetAddressTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAddressTypes_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeMessage_GetAddressTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAddressFormat_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ADDRESSFORMAT format,
    /* [out] */ LPSTR __RPC_FAR *ppszAddress);


void __RPC_STUB IMimeMessage_GetAddressFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_SplitMessage_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ ULONG cbMaxPart,
    /* [out] */ IMimeMessageParts __RPC_FAR *__RPC_FAR *ppParts);


void __RPC_STUB IMimeMessage_SplitMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetRootMoniker_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ LPMONIKER __RPC_FAR *ppmk);


void __RPC_STUB IMimeMessage_GetRootMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeMessage_INTERFACE_DEFINED__ */


#ifndef __IMimeMessageParts_INTERFACE_DEFINED__
#define __IMimeMessageParts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeMessageParts
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeMessageParts __RPC_FAR *LPMIMEMESSAGEPARTS;


EXTERN_C const IID IID_IMimeMessageParts;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1FA-C19B-11d0-85EB-00C04FD85AB4")
    IMimeMessageParts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CombineParts(
            /* [out] */ IMimeMessage __RPC_FAR *__RPC_FAR *ppMessage) = 0;

        virtual HRESULT STDMETHODCALLTYPE AddPart(
            /* [in] */ IMimeMessage __RPC_FAR *pMessage) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetMaxParts(
            /* [in] */ ULONG cParts) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountParts(
            /* [out] */ ULONG __RPC_FAR *pcParts) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumParts(
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeMessagePartsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeMessageParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeMessageParts __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeMessageParts __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CombineParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [out] */ IMimeMessage __RPC_FAR *__RPC_FAR *ppMessage);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPart )(
            IMimeMessageParts __RPC_FAR * This,
            /* [in] */ IMimeMessage __RPC_FAR *pMessage);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [in] */ ULONG cParts);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcParts);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);

        END_INTERFACE
    } IMimeMessagePartsVtbl;

    interface IMimeMessageParts
    {
        CONST_VTBL struct IMimeMessagePartsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeMessageParts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeMessageParts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeMessageParts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeMessageParts_CombineParts(This,ppMessage)	\
    (This)->lpVtbl -> CombineParts(This,ppMessage)

#define IMimeMessageParts_AddPart(This,pMessage)	\
    (This)->lpVtbl -> AddPart(This,pMessage)

#define IMimeMessageParts_SetMaxParts(This,cParts)	\
    (This)->lpVtbl -> SetMaxParts(This,cParts)

#define IMimeMessageParts_CountParts(This,pcParts)	\
    (This)->lpVtbl -> CountParts(This,pcParts)

#define IMimeMessageParts_EnumParts(This,ppEnum)	\
    (This)->lpVtbl -> EnumParts(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeMessageParts_CombineParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [out] */ IMimeMessage __RPC_FAR *__RPC_FAR *ppMessage);


void __RPC_STUB IMimeMessageParts_CombineParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_AddPart_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [in] */ IMimeMessage __RPC_FAR *pMessage);


void __RPC_STUB IMimeMessageParts_AddPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_SetMaxParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [in] */ ULONG cParts);


void __RPC_STUB IMimeMessageParts_SetMaxParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_CountParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcParts);


void __RPC_STUB IMimeMessageParts_CountParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_EnumParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeMessageParts_EnumParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeMessageParts_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumHeaderRows_INTERFACE_DEFINED__
#define __IMimeEnumHeaderRows_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumHeaderRows
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumHeaderRows __RPC_FAR *LPMIMEENUMHEADERROWS;

typedef struct  tagENUMHEADERROW
    {
    HHEADERROW hRow;
    LPSTR pszHeader;
    LPSTR pszData;
    ULONG cchData;
    DWORD dwReserved;
    }	ENUMHEADERROW;

typedef struct tagENUMHEADERROW __RPC_FAR *LPENUMHEADERROW;


EXTERN_C const IID IID_IMimeEnumHeaderRows;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F0-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumHeaderRows : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMHEADERROW prgRow,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumHeaderRowsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumHeaderRows __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumHeaderRows __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMHEADERROW prgRow,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumHeaderRows __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumHeaderRowsVtbl;

    interface IMimeEnumHeaderRows
    {
        CONST_VTBL struct IMimeEnumHeaderRowsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumHeaderRows_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumHeaderRows_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumHeaderRows_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumHeaderRows_Next(This,cFetch,prgRow,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgRow,pcFetched)

#define IMimeEnumHeaderRows_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumHeaderRows_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumHeaderRows_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumHeaderRows_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Next_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ LPENUMHEADERROW prgRow,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumHeaderRows_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Skip_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumHeaderRows_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Reset_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This);


void __RPC_STUB IMimeEnumHeaderRows_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Clone_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumHeaderRows_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Count_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumHeaderRows_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumHeaderRows_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumProperties_INTERFACE_DEFINED__
#define __IMimeEnumProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumProperties
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumProperties __RPC_FAR *LPMIMEENUMPROPERTIES;

typedef struct  tagENUMPROPERTY
    {
    LPSTR pszName;
    HHEADERROW hRow;
    DWORD dwPropId;
    }	ENUMPROPERTY;

typedef struct tagENUMPROPERTY __RPC_FAR *LPENUMPROPERTY;


EXTERN_C const IID IID_IMimeEnumProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A20B-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMPROPERTY prgProp,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumPropertiesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumProperties __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumProperties __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMPROPERTY prgProp,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumProperties __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumPropertiesVtbl;

    interface IMimeEnumProperties
    {
        CONST_VTBL struct IMimeEnumPropertiesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumProperties_Next(This,cFetch,prgProp,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgProp,pcFetched)

#define IMimeEnumProperties_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumProperties_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumProperties_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumProperties_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Next_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ LPENUMPROPERTY prgProp,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumProperties_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Skip_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumProperties_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Reset_Proxy(
    IMimeEnumProperties __RPC_FAR * This);


void __RPC_STUB IMimeEnumProperties_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Clone_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumProperties_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Count_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumProperties_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumProperties_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumAddressTypes_INTERFACE_DEFINED__
#define __IMimeEnumAddressTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumAddressTypes
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumAddressTypes __RPC_FAR *LPMIMEENUMADDRESSTYPES;


EXTERN_C const IID IID_IMimeEnumAddressTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EB-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumAddressTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumAddressTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumAddressTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumAddressTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumAddressTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumAddressTypesVtbl;

    interface IMimeEnumAddressTypes
    {
        CONST_VTBL struct IMimeEnumAddressTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumAddressTypes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumAddressTypes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumAddressTypes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumAddressTypes_Next(This,cFetch,prgpAddress,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgpAddress,pcFetched)

#define IMimeEnumAddressTypes_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumAddressTypes_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumAddressTypes_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumAddressTypes_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Next_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumAddressTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Skip_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumAddressTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Reset_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This);


void __RPC_STUB IMimeEnumAddressTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Clone_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumAddressTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Count_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumAddressTypes_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumAddressTypes_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumMessageParts_INTERFACE_DEFINED__
#define __IMimeEnumMessageParts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumMessageParts
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumMessageParts __RPC_FAR *LPMIMEENUMMESSAGEPARTS;


EXTERN_C const IID IID_IMimeEnumMessageParts;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F2-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumMessageParts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeMessage __RPC_FAR *__RPC_FAR *prgpMessage,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumMessagePartsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumMessageParts __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumMessageParts __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeMessage __RPC_FAR *__RPC_FAR *prgpMessage,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumMessageParts __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumMessagePartsVtbl;

    interface IMimeEnumMessageParts
    {
        CONST_VTBL struct IMimeEnumMessagePartsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumMessageParts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumMessageParts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumMessageParts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumMessageParts_Next(This,cFetch,prgpMessage,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgpMessage,pcFetched)

#define IMimeEnumMessageParts_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumMessageParts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumMessageParts_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumMessageParts_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Next_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ IMimeMessage __RPC_FAR *__RPC_FAR *prgpMessage,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumMessageParts_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Skip_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumMessageParts_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Reset_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This);


void __RPC_STUB IMimeEnumMessageParts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Clone_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumMessageParts_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Count_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumMessageParts_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumMessageParts_INTERFACE_DEFINED__ */


#ifndef __IMimeAllocator_INTERFACE_DEFINED__
#define __IMimeAllocator_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeAllocator
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeAllocator __RPC_FAR *LPMIMEALLOCATOR;


EXTERN_C const IID IID_IMimeAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1FC-C19B-11d0-85EB-00C04FD85AB4")
    IMimeAllocator : public IMalloc
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FreeParamInfoArray(
            /* [in] */ ULONG cParams,
            /* [in] */ LPMIMEPARAMINFO prgParam,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeAddressList(
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReleaseObjects(
            /* [in] */ ULONG cObjects,
            /* [in] */ IUnknown __RPC_FAR *__RPC_FAR *prgpUnknown,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeEnumHeaderRowArray(
            /* [in] */ ULONG cRows,
            /* [in] */ LPENUMHEADERROW prgRow,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeEnumPropertyArray(
            /* [in] */ ULONG cProps,
            /* [in] */ LPENUMPROPERTY prgProp,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeThumbprint(
            /* [in] */ THUMBBLOB __RPC_FAR *pthumbprint) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeSMIMEINFO(
            /* [in] */ SMIMEINFO __RPC_FAR *psi) = 0;

        virtual HRESULT STDMETHODCALLTYPE PropVariantClear(
            /* [in] */ LPPROPVARIANT pProp) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeAllocatorVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeAllocator __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeAllocator __RPC_FAR * This);

        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Alloc )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cb);

        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Realloc )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb);

        void ( STDMETHODCALLTYPE __RPC_FAR *Free )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetSize )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);

        int ( STDMETHODCALLTYPE __RPC_FAR *DidAlloc )(
            IMimeAllocator __RPC_FAR * This,
            void __RPC_FAR *pv);

        void ( STDMETHODCALLTYPE __RPC_FAR *HeapMinimize )(
            IMimeAllocator __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeParamInfoArray )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cParams,
            /* [in] */ LPMIMEPARAMINFO prgParam,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeAddressList )(
            IMimeAllocator __RPC_FAR * This,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseObjects )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cObjects,
            /* [in] */ IUnknown __RPC_FAR *__RPC_FAR *prgpUnknown,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeEnumHeaderRowArray )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cRows,
            /* [in] */ LPENUMHEADERROW prgRow,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeEnumPropertyArray )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cProps,
            /* [in] */ LPENUMPROPERTY prgProp,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeThumbprint )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ THUMBBLOB __RPC_FAR *pthumbprint);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeSMIMEINFO )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ SMIMEINFO __RPC_FAR *psi);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PropVariantClear )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ LPPROPVARIANT pProp);

        END_INTERFACE
    } IMimeAllocatorVtbl;

    interface IMimeAllocator
    {
        CONST_VTBL struct IMimeAllocatorVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeAllocator_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#define IMimeAllocator_Realloc(This,pv,cb)	\
    (This)->lpVtbl -> Realloc(This,pv,cb)

#define IMimeAllocator_Free(This,pv)	\
    (This)->lpVtbl -> Free(This,pv)

#define IMimeAllocator_GetSize(This,pv)	\
    (This)->lpVtbl -> GetSize(This,pv)

#define IMimeAllocator_DidAlloc(This,pv)	\
    (This)->lpVtbl -> DidAlloc(This,pv)

#define IMimeAllocator_HeapMinimize(This)	\
    (This)->lpVtbl -> HeapMinimize(This)


#define IMimeAllocator_FreeParamInfoArray(This,cParams,prgParam,fFreeArray)	\
    (This)->lpVtbl -> FreeParamInfoArray(This,cParams,prgParam,fFreeArray)

#define IMimeAllocator_FreeAddressList(This,pList)	\
    (This)->lpVtbl -> FreeAddressList(This,pList)

#define IMimeAllocator_ReleaseObjects(This,cObjects,prgpUnknown,fFreeArray)	\
    (This)->lpVtbl -> ReleaseObjects(This,cObjects,prgpUnknown,fFreeArray)

#define IMimeAllocator_FreeEnumHeaderRowArray(This,cRows,prgRow,fFreeArray)	\
    (This)->lpVtbl -> FreeEnumHeaderRowArray(This,cRows,prgRow,fFreeArray)

#define IMimeAllocator_FreeEnumPropertyArray(This,cProps,prgProp,fFreeArray)	\
    (This)->lpVtbl -> FreeEnumPropertyArray(This,cProps,prgProp,fFreeArray)

#define IMimeAllocator_FreeThumbprint(This,pthumbprint)	\
    (This)->lpVtbl -> FreeThumbprint(This,pthumbprint)

#define IMimeAllocator_FreeSMIMEINFO(This,psi)	\
    (This)->lpVtbl -> FreeSMIMEINFO(This,psi)

#define IMimeAllocator_PropVariantClear(This,pProp)	\
    (This)->lpVtbl -> PropVariantClear(This,pProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeParamInfoArray_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cParams,
    /* [in] */ LPMIMEPARAMINFO prgParam,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_FreeParamInfoArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeAddressList_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAllocator_FreeAddressList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_ReleaseObjects_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cObjects,
    /* [in] */ IUnknown __RPC_FAR *__RPC_FAR *prgpUnknown,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_ReleaseObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeEnumHeaderRowArray_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cRows,
    /* [in] */ LPENUMHEADERROW prgRow,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_FreeEnumHeaderRowArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeEnumPropertyArray_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cProps,
    /* [in] */ LPENUMPROPERTY prgProp,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_FreeEnumPropertyArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeThumbprint_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ THUMBBLOB __RPC_FAR *pthumbprint);


void __RPC_STUB IMimeAllocator_FreeThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeSMIMEINFO_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ SMIMEINFO __RPC_FAR *psi);


void __RPC_STUB IMimeAllocator_FreeSMIMEINFO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_PropVariantClear_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ LPPROPVARIANT pProp);


void __RPC_STUB IMimeAllocator_PropVariantClear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeAllocator_INTERFACE_DEFINED__ */

#endif /* __MIMEOLE_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\fdlhash.h ===
/*++
	FDLHash.h

	This file contains a template class for a hash table.

	The templates used in here build off the templates in tfdlist.h for
	doubly linked lists.  The bucket chains implemented in this version
	of the hash table are doubly linked lists.

	The Data type must support the following :

	class Data {
		DLSIT_ENTRY	m_list;

		KEYREF	GetKey(	) ;

	} ;

	int		MatchKey(	KEYREF	otherkey, KEYREF	otherkey) ;	/* NOTE : MatchKey returns non-zero on equality
	DWORD	(* m_pfnReHash)(Data* p ) ;
	DWORD	(* m_pfnHash)( KEYREF k ) ;	
	
--*/

#ifndef	_FDLHASH_H_
#define	_FDLHASH_H_

#include	"tfdlist.h"


class	CHashStats	{
public :
	enum	COUNTER	{
		HASHITEMS = 0,		// Number of items in the hash table
		INSERTS,			// Number of times Insert has been called
		SPLITINSERTS,		// Number of inserts until the next split !
		DELETES,			// Number of times Delete has been called
		SEARCHES,			// Number of times Search has been called
		SEARCHHITS,			// Number of times we Search and find something !
		SPLITS,				// Number of times we've split the table on an insert !
		REALLOCS,			// Number of times we've reallocated memory for a split
		DEEPBUCKET,			// The deepest bucket we have !
		AVERAGEBUCKET,		// The average depth of the buckets
		EMPTYBUCKET,		// The number of Empty buckets !
		ALLOCBUCKETS,		// Number of buckets we've allocated
		ACTIVEBUCKETS,		// Number of Active buckets
		AVERAGESEARCH,		// Average number of buckets we examine each search
		DEEPSEARCH,			// Longest walk we do on a search
		SEARCHCOST,			// Sum of the number of items we've visited for all search hits !
		SEARCHCOSTMISS,		// Sum of the number of items we've visited for search misses !
		MAX_HASH_STATS		// Number of statistics we report !
	} ;

	long	m_cHashCounters[MAX_HASH_STATS] ;

	CHashStats()	{
		ZeroMemory( m_cHashCounters, sizeof( m_cHashCounters ) ) ;
		//m_cHashCounters[SMALLSEARCH] = 0x7FFF ;
	}

	static	inline	void
	IncrementStat(	CHashStats*	p, CHashStats::COUNTER	c ) {
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			InterlockedIncrement( &p->m_cHashCounters[c] ) ;
		}
	}

	static	inline	void
	AddStat(	CHashStats*p, CHashStats::COUNTER	c, long	l ) {
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			InterlockedExchangeAdd( &p->m_cHashCounters[c], l ) ;
		}
	}

	static	inline	void
	DecrementStat(	CHashStats* p, CHashStats::COUNTER	c )		{
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			InterlockedDecrement( &p->m_cHashCounters[c] ) ;
		}
	}

	static	inline	void
	SetStat(	CHashStats*	p, CHashStats::COUNTER c, long l ) {
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			p->m_cHashCounters[c] = l ;
		}
	}

} ;

#ifdef	METER
#define	INCREMENTSTAT( s )	CHashStats::IncrementStat( m_pStat, CHashStats::##s )
#define	DECREMENTSTAT( s )	CHashStats::DecrementStat( m_pStat, CHashStats::##s )
#define	ADDSTAT( s, a )		CHashStats::AddStat( m_pStat, CHashStats::##s, a )
#define	SETSTAT( s, a )		CHashStats::SetStat( m_pStat, CHashStats::##s, a )
//#if 0
#define	MAXBUCKET( i )		MaxBucket( i )
#define	AVERAGEBUCKET()		AverageBucket()
//#else
//#define	MAXBUCKET( i )
//#define	AVERAGEBUCKET()
//#endif
#else	// METER
#define	INCREMENTSTAT( s )
#define	DECREMENTSTAT( s )
#define	ADDSTAT( s, a )
#define	SETSTAT( s, a )
#define	MAXBUCKET( i )
#define	AVERAGEBUCKET()
#endif	// METER

template<	class	HASHTABLE	>	
class	TFDLHashIterator	{
private :

	//
	//	The hash table that the item is in !
	//
	HASHTABLE*			m_pTable ;

	//
	//	The bucket we are walking on !
	//
	int					m_iBucket ;

	//
	//	Keep track of our position in a list !
	//
	typename HASHTABLE::ITER		m_Iter ;

	//
	//	Move between hash table buckets as necessary !
	//
	void
	PrevBucket()	{
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
		_ASSERT( m_Iter.AtEnd() ) ;
		if( m_iBucket > 0 ) {
			do	{
				m_Iter.ReBind( &m_pTable->m_pBucket[--m_iBucket] ) ; 			
			}	while( m_Iter.AtEnd() && m_iBucket > 0 ) ;
		}
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
	}

	//
	//	Move between hash table buckets as necessary !
	//
	void
	NextBucket()	{
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
		_ASSERT( m_Iter.AtEnd() ) ;

		if( m_iBucket < m_pTable->m_cActiveBuckets-1 ) {
			do	{
				m_Iter.ReBind( &m_pTable->m_pBucket[++m_iBucket] ) ;
			}	while( m_Iter.AtEnd() && m_iBucket < m_pTable->m_cActiveBuckets-1 ) ;
		}
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
	}

public :

	typedef	typename HASHTABLE::DATA	DATA ;

	TFDLHashIterator( HASHTABLE&	ref, BOOL fForward = TRUE ) :
		m_pTable( &ref ),
		m_iBucket( fForward ? 0 : ref.m_cActiveBuckets-1 ),
		m_Iter( ref.m_pBucket[m_iBucket] )	{

		if( m_Iter.AtEnd() ) {
			if( fForward ) {
				NextBucket() ;
			}	else	{
				PrevBucket() ;
			}
		}
	}

	void
	Prev()	{
	/*++

	Routine Description :

		This function moves the iterator back one slot.

	Arguments :

		None.

	Return	Value :

		None.

	--*/
	
		m_Iter.Prev() ;
		if( m_Iter.AtEnd() ) {
			PrevBucket() ;
		}				
	}

	void
	Next()	{
	/*++

	Routine Description :

		This function moves the iterator forward one slot.

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		m_Iter.Next() ;
		if( m_Iter.AtEnd() )	{
			NextBucket() ;
		}

	}
	void
	Front()	{
	/*++

	Routine Description :

		Reset the iterator to reference the first item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/

		m_Iter.ReBind( &m_pTable->m_pBucket[0], TRUE ) ;
		m_iBucket = 0 ;
		if( m_Iter.AtEnd() ) {
			NextBucket() ;
		}
	}
	void
	Back()	{
	/*++

	Routine Description :

		Reset the iterator to reference the last item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
	
		m_Iter.ReBind( &m_pTable->m_pBucket[m_pTable->m_cActiveBuckets-1], FALSE ) ;
		m_iBucket = m_pTable->m_cActiveBuckets-1 ;
		if( m_Iter.AtEnd() ) {
			PrevBucket() ;
		}
	}

	BOOL
	AtEnd()	{
	/*++

	Routine Description :

		Return TRUE if we are at the end of the list !
		This is a little more complicated to compute -
		depends on which way we are going !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		return	m_Iter.AtEnd() ;
	}

	DATA*	
	CurrentEntry()	{
		return	m_Iter.Current() ;
	}

	DATA*
	RemoveItem()	{
	/*++

	Routine Description :

		Remove the item that the iterator currently
		references from the list.
		If we are going forward then the iterator
		will be setting on the previous element,
		otherwise the iterator is left on the next element.
		We have to take care that we don't leave the iterator
		sitting on an invalid element.

	Arguments :

		None.

	Return	Value :

		Pointer to the removed item.

	--*/

		DATA*	pData = m_Iter.RemoveItem() ;
		if( pData ) {
			m_pTable->NotifyOfRemoval() ;
		}
		if( m_Iter.AtEnd() ) {
			if( m_Iter.m_fForward ) {
				NextBucket() ;
			}	else	{
				PrevBucket() ;
			}
		}
		return	pData ;
	}



	inline DATA*
	Current( ) {
		return	m_Iter.Current() ;
	}

	inline void
	InsertBefore(	DATA*	p )		{
		m_Iter.InsertBefore( p ) ;
	}
	
	inline void
	InsertAfter(	DATA*	p )		{
		m_Iter.InsertAfter( p ) ;
	}
} ;


//------------------------------------------------------------
template<	class	Data,		/* This is the item that resides in the hashtable */
			class	KEYREF,		/* This is the type used to point or reference items in the cache*/
			typename Data::PFNDLIST	pfnDlist,
			BOOL	fOrdered = TRUE
			>
class	TFDLHash	{
//
//	This class defines a Hash table which can grow dynamically to
//	accomodate insertions into the table.  The table only grows, and
//	does not shrink.
//
public :

	//
	//	This is the iterator object that can walk the hash table !
	//
	friend	class	TFDLHashIterator<	TFDLHash< Data, KEYREF, pfnDlist > > ;

	//
	//	This is the type of the Data item !
	//
	//typedef	DATAHELPER		Data ;
	typedef	KEYREF	(Data::*GETKEY)() ;

	//
	//	This is the type that we use to maintain doubly linked lists of
	//	hash table items !
	//
	typedef	TDListHead< Data, pfnDlist >	DLIST ;	
	
	//
	//	This is the type we use to make iterators over the bucket chains !
	//
	typedef	TDListIterator< DLIST >		ITER ;

	//
	//	Define this type for our iterators !
	//
	typedef	Data	DATA ;

	//
	//	This is a member function pointer to a function which
	//	will retrieve the key we are to use !
	//
	//typedef	KEYREF	(Data::*GETKEY)( ) ;
	//typedef	Data::GETKEY	GETKEY ;

	//
	//	This is the type of function that computes the hash value !
	//
	typedef	DWORD	(*PFNHASH)( KEYREF ) ;

	//
	//	This is the type of function that can recompute the hash value when
	//	we are splitting up the hash table !
	//
	typedef	DWORD	(*PFNREHASH)( Data* ) ;

	//
	//	This is a member function pointer of the type that will
	//	compare keys for us !
	//
	typedef	int		(*MATCHKEY)( KEYREF key1, KEYREF	key2 ) ;


private :

	//
	// An array of buckets !
	//
	DLIST*	m_pBucket ;	

	//
	//	Member Pointer - will get the key out of the object for us !
	//
	GETKEY	m_pGetKey ;

	//
	//	Member Pointer - will compare the key in the item for us !
	//
	MATCHKEY	m_pMatchKey ;
	
	//
	// A counter that we use to determine when to grow the
	// hash table.  Each time we grow the table we set this
	// to a large positive value, and decrement as we insert
	// elements.  When this hits 0 its time to grow the table !
	//
	long	m_cInserts ;		

	//
	// The function we use to compute hash values.
	// (Provided by the Caller of Init())
	//
	PFNHASH	m_pfnHash ;	

	//
	//	The function we call when we are growing the hash table
	//	and splitting bucket chains and we need to rehash an element !
	//
	PFNREHASH	m_pfnReHash ;

	//
	// Number of Buckets used in index computation
	//
	int		m_cBuckets ;		

	//
	// Number of Buckets we are actually using
	// Assert( m_cBuckets >= m_cActiveBuckets ) always true.
	//
	int		m_cActiveBuckets ;	

	//
	// Number of Buckets we have allocated
	// Assert( m_cNumAlloced >= m_cActiveBuckets ) must
	// always be true.
	//
	int		m_cNumAlloced ;		

	//
	// The amount we should grow the hash table when we
	// decide to grow it.
	//
	int		m_cIncrement ;		

	//
	// The number of CBuckets we should allow in each
	// collision chain (on average).
	//
	int		m_load ;

#ifdef	METER
	//
	//	The structure for collecting our performance data !
	//
	CHashStats*	m_pStat ;

	//
	//	Compute the depth of a bucket !
	//
	long
	BucketDepth(	DWORD index ) ;

	//
	//	set the statistics for the deepest bucket !
	//
	void
	MaxBucket(	DWORD index ) ;

	//
	//	Compute the average Search depth !
	//
	void
	AverageSearch( BOOL	fHit, long lDepth ) ;

	//
	//	Compute the average Bucket depth !
	//
	void
	AverageBucket( ) ;
#endif

	//
	// The function we use to compute the
	// position of an element in the hash table given its
	// Hash Value.
	//
	DWORD	
	ComputeIndex( DWORD dw ) ;	

	DWORD	
	ReHash( Data*	p )		{
		if( m_pfnReHash )
			return	m_pfnReHash( p ) ;
		return	m_pfnHash( (p->*m_pGetKey)() ) ;
	}

public :
	TFDLHash( ) ;
	~TFDLHash( ) ;

	BOOL	
	Init(	int		cInitial,
			int		cIncrement,
			int		load,
			PFNHASH	pfnHash,
			GETKEY	pGetKey,
			MATCHKEY	pMatchKey,
			PFNREHASH	pfnReHash = 0,
			CHashStats*	pStats = 0
			) ;

	//
	//	Check that the hash table is in a valid state
	//	if fCheckHash == TRUE we will walk all the buckets and check that
	//	the data hashes to the correct value !
	//
	BOOL	
	IsValid( BOOL fCheckHash = FALSE ) ;

	//
	//	Check that the Bucket is valid - everything contains
	//	proper hash value and is in order !
	//
	BOOL	
	IsValidBucket( int	i ) ;

	//
	//	This function grows the number of hash buckets as the
	//	total number of items in the table grows !
	//
	BOOL
	Split() ;
	

	//
	//	Insert a piece of Data into the Hash Table
    //  We take a pointer to the Data object.
	//
	BOOL
	InsertDataHash(	DWORD	dw,
					KEYREF	k,
					Data*	pd
					) ;

	//
	//	Insert a piece of Data into the Hash Table
	//	
	//	We take an iterator that is already position in the
	//	correct location for inserting the item !
	//
	BOOL
	InsertDataHashIter(	ITER&	iter,
						DWORD	dw,
						KEYREF	k,
						Data*	pd
						) ;


	//
	//	Insert a piece of Data into the Hash Table
	//
	BOOL
	InsertData(	Data*	pd )	{
		KEYREF	keyref = (pd->*m_pGetKey)() ;
		return	InsertDataHash( m_pfnHash(keyref), keyref, pd ) ;
	}

	//
	//	Insert a piece of Data into the Hash table
	//	given an iterator that should be at the right location !
	//
	BOOL
	InsertDataIter(	ITER&	iter,
					Data*	pd	)	{
		KEYREF	keyref = (pd->*m_pGetKey)() ;
		return	InsertDataHashIter( iter, m_pfnHash(keyref), keyref, pd ) ;
	}
					
	//
	//	Search for an item in the cache - if we don't find
	//	it we return an ITERATOR that the user can use to insert
	//	the item by calling ITER.InsertBefore() ;
	//
	//	If the item is found, we'll return the item, as well
	//	as returning an iterator who's current element
	//	points at the data item !
	//
	ITER
	SearchKeyHashIter(
					DWORD	dw,
					KEYREF	k,
					Data*	&pd
					) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	void	
	SearchKeyHash(	DWORD	dw,
					KEYREF	k,
					Data*	&pd
					) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*
	SearchKey(	KEYREF	k )	{
		Data*	p ;
		SearchKeyHash( m_pfnHash( k ), k, p ) ;
		return	 p ;		
	}

	//
	//	Search for the given item and return a good iterator !
	//
	ITER
	SearchKeyIter(	KEYREF	k,
					Data*	&pd ) {
		pd = 0 ;
		return	SearchKeyHashIter( m_pfnHash( k ), k, pd ) ;
	}
		

	Data*
	SearchKey(	DWORD	dw,
				KEYREF	k
				)	{
		Data*	p = 0 ;
		_ASSERT( dw == m_pfnHash( k ) ) ;
		SearchKeyHash( dw, k, p ) ;
		return	p ;
	}

	//
	//	Given an item in the hash table - remove it !
	//
	void
	Delete(	Data*	pd 	) ;

	//
	//	Find an element in the hash table - and remove it !
	//	(Confirm that the found item matches the Key!)
	//
	void
	DeleteData(	KEYREF	k,
				Data*	pd
			 	) ;

	//
	//	Remove an item from the hash table - and return it !
	//
	Data*
	DeleteData(	KEYREF	k )	{
		Data*	p ;
		//
		//	Find the item
		//
		SearchKeyHash( m_pfnHash( k ), k, p ) ;
		//
		//	Remove from Hash Table
		//
		if( p )
			Delete( p ) ;
		return	p ;
	}

	//
	//	Delete the key and associated data from the table.
	//
	BOOL	
	Destroy( KEYREF	k )	{
		Data*	p = DeleteData( k ) ;
		if( p ) {
			delete	p ;
			return	TRUE ;
		}
		return	FALSE ;
	}

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	void	Clear( ) ;

	//
	//	Removes all of the items in the hash table.  Does not call "delete"
	//  on them.
	//
	void	Empty( ) ;

	//
	//	Called by Iterators that want to let us know that items have been
	//	removed from the cache so we can do our splits correctly etc... !
	//
	void	NotifyOfRemoval() ;

	//
	//	Function to compute hash value of a key for callers
	//	who don't keep track of the hash function
	//
	DWORD
	ComputeHash(	KEYREF	k ) ;

} ;

#include	"fdlhash.inl"

#endif // _FDLHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\fdlhash.inl ===
/*++

	fdlhash.inl

	This file contains the template implementation of the class TFDLHash

--*/



#ifdef	METER
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
long
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::BucketDepth(
									DWORD	index
									) {
/*++

Routine Description :

	computes how deep the specified bucket is !
	
Arguments :

	index - the hash bucket thats changed length !

Return Value :

	Depth of the bucket !
	
--*/

	_ASSERT( IsValid( FALSE ) ) ;

	long	l = 0 ;
	ITER	i = m_pBucket[index] ;
	while( !i.AtEnd() ) {
		i.Next() ;
		l ++ ;
	}
	return	l ;
}

template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::MaxBucket(
									DWORD	index
									) {
/*++

Routine Description :

	Sets our statistics for what the deepest bucket is !
	
Arguments :

	index - the hash bucket that was touched !

Return Value :

	None.
	
--*/

	if( m_pStat )	{
		long l = BucketDepth( index ) ;
		m_pStat->m_cHashCounters[CHashStats::DEEPBUCKET] =
				max( m_pStat->m_cHashCounters[CHashStats::DEEPBUCKET], l ) ;
	}
}

template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::AverageBucket() {
/*++

Routine Description :

	Sets out statistics for what the average bucket depth is !
	
Arguments :

	index - the hash bucket that was touched !

Return Value :

	None.
	
--*/

	if( m_pStat )	{
		BOOL	fReMax = (m_pStat->m_cHashCounters[CHashStats::INSERTS] % 1000) == 0 ;
		if( fReMax ) {
			m_pStat->m_cHashCounters[CHashStats::DEEPBUCKET] = 0 ;
		}

		if( (m_pStat->m_cHashCounters[CHashStats::INSERTS] % 200) == 0 ) {

			long	l = m_pStat->m_cHashCounters[CHashStats::HASHITEMS] ;
			long	cNonEmpty = 0 ;
			for( int i=0; i < m_cActiveBuckets ; i++ ) {
				if( !m_pBucket[i].IsEmpty() )	{
					cNonEmpty ++ ;
					if( fReMax )
						MaxBucket( DWORD(i) ) ;
				}
			}
			m_pStat->m_cHashCounters[CHashStats::AVERAGEBUCKET] =
						l / cNonEmpty ;
			m_pStat->m_cHashCounters[CHashStats::EMPTYBUCKET] = m_cActiveBuckets - cNonEmpty ;
		}
	}
}



template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::AverageSearch(
									BOOL	fHit,
									long	depthSearch
									) {
/*++

Routine Description :

	Computes the average Search depth !
	
Arguments :

	depthSearch - how long the search went !

Return Value :

	none

--*/

	if( m_pStat )	{
	
		if( (m_pStat->m_cHashCounters[CHashStats::SEARCHHITS] % 500) == 0 ) {
			m_pStat->m_cHashCounters[CHashStats::DEEPSEARCH] = 0 ;
		}

	
		if( depthSearch != 0 ) {
			long	searches = m_pStat->m_cHashCounters[CHashStats::SEARCHHITS] ;
			searches = min( searches, 100 ) ;	// Average over the last 100 hits !
				__int64	sum = m_pStat->m_cHashCounters[CHashStats::AVERAGESEARCH] *
							(searches) ;
			__int64 average = (sum + ((__int64)depthSearch)) / ((__int64)searches+1) ;

			m_pStat->m_cHashCounters[CHashStats::AVERAGESEARCH] = (long)average ;
		}

		if( fHit )	{
			INCREMENTSTAT( SEARCHHITS ) ;
			ADDSTAT( SEARCHCOST, depthSearch ) ;
		}	else	{
			ADDSTAT( SEARCHCOSTMISS, depthSearch ) ;
		}

		m_pStat->m_cHashCounters[CHashStats::DEEPSEARCH] =
			max( m_pStat->m_cHashCounters[CHashStats::DEEPSEARCH], depthSearch ) ;
	}
}
#endif	// METER




//---------------------------------------------
template<	class Data,
			class KEYREF,		/* This is the type used to point or reference items in the cache*/
			typename Data::PFNDLIST	s_Offset,
			BOOL			fOrdered
			>
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::TFDLHash( ) :
	m_cBuckets( 0 ),
	m_cActiveBuckets( 0 ),
	m_cNumAlloced( 0 ),
	m_cIncrement( 0 ),
	m_pBucket( 0 ),
	m_pfnHash( 0 ),
	m_pGetKey( 0 ),
	m_pMatchKey( 0 ),	
	m_load( 0 )	{
//
//	Very basic constructor
//

}

//---------------------------------------------
template<	class	Data,
			class	KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL	
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::Init(
							int cInitial,
							int cIncrement,
							int load,
							PFNHASH		pfnHash,
							GETKEY		pGetKey,
							MATCHKEY	pMatchKey,
							PFNREHASH	pfnReHash,
							CHashStats*	pStats
							) {
/*++

Routine Description :

	Initialize the hash table

Arguments :

	pNext - A pointer to Member with class Data where we can hold
		our bucket pointers !
	cInitial - Initial size of the hash table
	cIncrement - Amount to grow the hash table by !
	pfnHash - Hash Function -
	load - Average bucket length before growing the table !

Return Value :

	TRUE if successfull FALSE otherwise

--*/

#ifdef	METER
	m_pStat = pStats ;
#endif

	m_pGetKey = pGetKey ;
	m_pMatchKey = pMatchKey ;

    //
    // Compute nearest power of 2
    //

    int	power = cInitial ;
    while( power & (power-1) )
        power = power & (power-1) ;
    power<<= 1 ;

    cInitial = power;
	m_load = load ;
	m_pfnHash = pfnHash ;
	m_pfnReHash = pfnReHash ;

    //
    // Number of ActiveBuckets is initially half that of the number of buckets.
    //

    m_cActiveBuckets = power/2  ;
    m_cBuckets = power ;
    m_cInserts = m_cActiveBuckets * m_load ;
    m_cIncrement = m_cActiveBuckets / 4;
	m_cNumAlloced = cInitial + 5 * m_cIncrement ;

	//
	// Allocate bucket pointers and zero initialize
	//

	m_pBucket = new DLIST[m_cNumAlloced] ;

	SETSTAT( ALLOCBUCKETS, m_cNumAlloced ) ;
	SETSTAT( ACTIVEBUCKETS, m_cActiveBuckets ) ;
	SETSTAT( SPLITINSERTS, m_cInserts ) ;

    if( m_pBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;
	    return  TRUE ;
	}
	return	FALSE ;
}



//------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL	
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::IsValidBucket( int	i )		{
/*++

Routine Description :

	Chech that the hash bucket is valid !

Arguments :

	i - the bucket to check !

Return Value :

	TRUE if successfull FALSE otherwise

--*/

	if( i>=m_cActiveBuckets ) {
		if( !m_pBucket[i].IsEmpty() ) {
			_ASSERT(1==0) ;
			return	FALSE ;
		}
	}	else	{
		ITER	iterNext = m_pBucket[i] ;
		if( !iterNext.AtEnd() )
			iterNext.Next() ;
		for( ITER	iter = m_pBucket[i]; !iter.AtEnd(); iter.Next()) {
			Data	*p = iter.Current() ;
			KEYREF	keyref = (p->*m_pGetKey)();
			DWORD	dwHash = m_pfnHash( keyref ) ;
			DWORD	index = ComputeIndex(dwHash) ;
			if( index != unsigned(i) ) {
				_ASSERT(1==0);
				return	FALSE ;
			}
			if( fOrdered ) {
				if( !iterNext.AtEnd() ) {
					Data	*pNext = iterNext.Current() ;
					KEYREF	keyrefNext = (pNext->*m_pGetKey)() ;
					int	iCompare = (*m_pMatchKey)( keyref, keyrefNext ) ;
					_ASSERT( iCompare < 0 ) ;
					if( iCompare >= 0 )
						return	FALSE ;
					iterNext.Next() ;
				}
			}
		}
	}
	return	TRUE ;
}



//------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL	
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::IsValid( BOOL fCheckHash ) {
/*++

Routine Description :

	Check that the hash table is valid

Arguments :

	fCheckHash - verify that all the buckets contain the correct hash values !

Return Value :

	TRUE if successfull FALSE otherwise

--*/

	//
	//	This function checks that all member variables are consistent and correct.
	//	Do not call this function until AFTER calling the Init() function.
	//

	if( m_cBuckets <= 0 ||
		m_cActiveBuckets <= 0 ||
		m_cNumAlloced <= 0 ||
		m_cIncrement <= 0 ||
		m_load <= 0 )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_cActiveBuckets < (m_cBuckets / 2) || m_cActiveBuckets > m_cBuckets )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_cActiveBuckets > m_cNumAlloced )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_cInserts > (m_load * m_cActiveBuckets) )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_pBucket == 0 )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( fCheckHash ) {
		//
		// Examine every bucket chain to ensure that elements are in correct slots.
		//
		for( int i=0; i<m_cNumAlloced; i++ ) {

			if( i>=m_cActiveBuckets ) {
				if( !m_pBucket[i].IsEmpty() ) {
					_ASSERT(1==0) ;
					return	FALSE ;
				}
			}	else	{
				for( ITER	iter = m_pBucket[i]; !iter.AtEnd(); iter.Next() ) {
					Data	*p = iter.Current() ;
					KEYREF	keyref = (p->*m_pGetKey)();
					DWORD	dwHash = m_pfnHash( keyref ) ;
					DWORD	index = ComputeIndex(dwHash) ;
					if( index != unsigned(i) ) {
						_ASSERT(1==0);
						return	FALSE ;
					}
				}
			}
			_ASSERT( IsValidBucket( i ) ) ;
		}
	}
	return	TRUE ;
}



//-------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::~TFDLHash() {
/*++

Routine Description :

	Destroy the hash table !

Arguments :

	None

Return Value :

	None

--*/
	//
	//	The destructor discards any memory we have allocated.
	//
	Clear();
}


//-------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::Clear() {
/*++

Routine Description :

	Delete all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !

Arguments :
	
	None.

Return Value :

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_pBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		for( int i=0; i<m_cNumAlloced; i++ ) {
			for( ITER iter=m_pBucket[i]; !iter.AtEnd(); ) {
				Data*	p = iter.RemoveItem() ;
				delete	p ;
			}
		}
		delete[] m_pBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_pBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}


//-------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::Empty() {
/*++

Routine Description :

	Remove all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !
	This is just like Clear() but it does do a "delete".

Arguments :
	
	None.

Return Value :

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_pBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		delete[] m_pBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}

//-------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
DWORD
TFDLHash<	Data, KEYREF, s_Offset, fOrdered >::ComputeIndex( DWORD dw ) {
/*++

Routine Description :

	Compute which bucket an element should be in

	This function tells us where we should store elements.  To do this we mod with
	m_cBuckets.  Since we only have m_cActiveBuckets in reality, we check the result
	of the mod and subtract m_cBuckets over 2 if necessary.

Arguments :

	dw - the hash value of the entry we are adding to the table

Return Value :

	Index to the bucket to use !

--*/

	DWORD	dwTemp = dw % m_cBuckets ;
	return	(dwTemp >= (unsigned)m_cActiveBuckets) ? dwTemp - (m_cBuckets/2) : dwTemp ;
}


//-----------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::SearchKeyHash(
									DWORD	dwHash,
									KEYREF	k,
									Data*	&pd
									) {
/*++

Routine Description :

	Search for an element in the Hash Table,
	
Arguments :

	dwHash - the hash value of the entry we are adding to the table
	k - reference to the key we are to compare against

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( dwHash == (m_pfnHash)(k) ) ;

	INCREMENTSTAT( SEARCHES ) ;

#ifdef	METER
	long	lSearchDepth = 0 ;
#endif

	pd = 0 ;
	DWORD	index = ComputeIndex(	dwHash ) ;
	ITER	i = m_pBucket[index] ;
	Data*	p = 0 ;
	while( !i.AtEnd() ) {
#ifdef	METER
		lSearchDepth ++ ;
#endif
		p = i.Current() ;
		int	iSign = (*m_pMatchKey)( (p->*m_pGetKey)(), k ) ;
		if( iSign == 0 ) {
			pd = p ;
			break ;
		}	else	if( fOrdered && iSign > 0 ) {
			break ;
		}
		i.Next() ;
	}
#ifdef	METER
	AverageSearch( pd != 0, lSearchDepth ) ;
#endif	
}

//-----------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
typename TFDLHash< Data, KEYREF, s_Offset, fOrdered >::ITER
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::SearchKeyHashIter(
									DWORD	dwHash,
									KEYREF	k,
									Data*	&pd
									) {
/*++

Routine Description :

	Search for an element in the Hash Table,
	
Arguments :

	dwHash - the hash value of the entry we are adding to the table
	k - reference to the key we are to compare against

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( dwHash == (m_pfnHash)(k) ) ;

	INCREMENTSTAT( SEARCHES ) ;

#ifdef	METER
	long	lSearchDepth = 0 ;
#endif

	pd = 0 ;
	DWORD	index = ComputeIndex(	dwHash ) ;
	ITER	i = m_pBucket[index] ;
	Data*	p = 0 ;
	while( !i.AtEnd() ) {
#ifdef	METER
		lSearchDepth ++ ;
#endif
		p = i.Current() ;
		int	iSign = (*m_pMatchKey)( (p->*m_pGetKey)(), k ) ;
		if( iSign == 0 ) {
			pd = p ;
			break ;
		}	else	if( fOrdered && iSign > 0 ) {
			break ;
		}
		i.Next() ;
	}
#ifdef	METER
	AverageSearch( pd != 0, lSearchDepth ) ;
#endif
	return	i ;
}

//-------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::InsertDataHashIter(
								ITER&	iter,
								DWORD	dwHash,
								KEYREF	k,
								Data*	pd
								) {
/*++

Routine Description :

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments :

	dw - the hash value of the entry we are adding to the table
	pd - Pointer to the item we are adding to the table !

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( INSERTS ) ;

#if	defined(DEBUG) || defined( METER )
	KEYREF	keyref = (pd->*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;
	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;
	_ASSERT( iter.GetHead() == &m_pBucket[index] ) ;
#endif

		//
		//	This is no longer smaller than the current guy - so insert in front
		//
	iter.InsertBefore( pd ) ;

#if	defined(DEBUG) || defined( METER )
	_ASSERT( IsValidBucket( index ) ) ;

	//
	//	Update our statistics !
	//
	//MAXBUCKET( index ) ;
#endif

	INCREMENTSTAT( HASHITEMS ) ;
	//AVERAGEBUCKET() ;
		
	_ASSERT( IsValid( FALSE ) ) ;


	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {
		Split() ;
	}

	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	return	TRUE ;
}




template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::Split( ) {
/*++

Routine Description :

	This function grows the hash table so that our average bucket depth remains constant !

Arguments :

	None.
	
Return Value :

	Index to the bucket to use !

--*/



	_ASSERT( IsValid( TRUE ) ) ;

	INCREMENTSTAT( SPLITS ) ;

	//
	// Check whether we need to reallocate the array of Bucket pointers.
	//
	if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {

		INCREMENTSTAT( REALLOCS ) ;

		DLIST*	pTemp = new DLIST[m_cNumAlloced + 10 * m_cIncrement ] ;

		if( pTemp == 0 ) {
			//
			//	bugbug ... need to handles this error better !?
			//
			return	FALSE ;
		}	else	{

			for( int i=0; i<m_cNumAlloced; i++ ) {
				pTemp[i].Join( m_pBucket[i] ) ;
			}
			delete[]	m_pBucket ;
			m_cNumAlloced += 10 * m_cIncrement ;
			m_pBucket = pTemp ;

			SETSTAT( ALLOCBUCKETS, m_cNumAlloced ) ;
		}
	}

	_ASSERT( IsValid( TRUE ) ) ;

	//
	// Okay grow the array by m_cIncrement.
	//
	m_cActiveBuckets += m_cIncrement ;
	if( m_cActiveBuckets > m_cBuckets )
		m_cBuckets *= 2 ;		
	m_cInserts = m_cIncrement * m_load ;

	SETSTAT( ACTIVEBUCKETS, m_cActiveBuckets ) ;

	//
	// Now do some rehashing of elements.
	//

	for( int	i = -m_cIncrement; i < 0; i++ ) {
		int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
		ITER	iter = m_pBucket[iCurrent] ;
		while( !iter.AtEnd() ) {
			Data*	p = iter.Current() ;
			int	index = ComputeIndex( ReHash( p ) ) ;
			if( index != iCurrent ) {
				Data*	pTemp = iter.RemoveItem() ;
				_ASSERT( pTemp == p ) ;
				m_pBucket[index].PushBack( p ) ;
			}	else	{
				iter.Next() ;
			}
		}
		_ASSERT( IsValidBucket( iCurrent ) ) ;
	}
	_ASSERT( IsValid( TRUE ) ) ;
	return	TRUE ;
}


//-------------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::InsertDataHash(
								DWORD	dwHash,
								KEYREF	k,
								Data*	pd
								) {
/*++

Routine Description :

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments :

	dw - the hash value of the entry we are adding to the table
	pd - Pointer to the item we are adding to the table !

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( INSERTS ) ;

	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {
		if( !Split() )	{
			return	FALSE ;
		}
	}

	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	KEYREF	keyref = (pd->*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;

	if( !fOrdered ) {
		m_pBucket[index].PushFront( pd ) ;
	}	else	{
		//
		//	Build the hash  buckets in order !
		//
		ITER	iter = m_pBucket[index] ;		
		Data*	p = 0 ;
		while( !iter.AtEnd() ) {
			p = iter.Current() ;
			int	i = (*m_pMatchKey)( (p->*m_pGetKey)(), k ) ;
			_ASSERT( i != 0 ) ;
			if( i > 0 )
				break ;
			iter.Next() ;
		}
		//
		//	This is no longer smaller than the current guy - so insert in front
		//
		iter.InsertBefore( pd ) ;
	}
	_ASSERT( IsValidBucket( index ) ) ;

	//
	//	Update our statistics !
	//
	//MAXBUCKET( index ) ;
	INCREMENTSTAT( HASHITEMS ) ;
	//AVERAGEBUCKET() ;
		
	_ASSERT( IsValid( FALSE ) ) ;

	return	TRUE ;
}

//-----------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::Delete(	Data*	pd	) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( DELETES ) ;

	if( pd ) {
		DECREMENTSTAT(HASHITEMS) ;
		m_cInserts ++ ;
		DLIST::Remove( pd ) ;
	}

	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	_ASSERT( IsValid( FALSE ) ) ;
}


template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::NotifyOfRemoval(	) {
//
//	Notify us that an item has been removed from the hash table !
//

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( DELETES ) ;
	DECREMENTSTAT( HASHITEMS ) ;
	m_cInserts ++ ;
	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	_ASSERT( IsValid( FALSE ) ) ;
}




//-----------------------------------------------
template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::DeleteData(	KEYREF	k,
											Data*	pd
											) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	_ASSERT( IsValid( FALSE ) ) ;

	if( !pd ) {
		pd = SearchKey( k ) ;
	}
	if( pd ) {

		INCREMENTSTAT(DELETES) ;
		DECREMENTSTAT(HASHITEMS) ;

		_ASSERT( (*m_pMatchKey)( pd->GetKey(), k ) ) ;
		_ASSERT( SearchKey( k ) == pd ) ;
		m_cInserts ++ ;
		DLIST::Remove( pd ) ;
	}
	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	_ASSERT( IsValid( FALSE ) ) ;
}

template<	class Data,
			class KEYREF,
			typename Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
DWORD
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::ComputeHash(	KEYREF	k	)	{

	return	m_pfnHash( k ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\fhash.h ===
//
//	FHash.h
//
//	This file contains a template class for a hash table.
//	The template has two arguments, the type of the Data Elements and the
//	type of the Key.
//
//	The Data type must support the following :
//
//	class Data {
//		Data() ;
//		Data( Data & ) ;
//		~Data() ;
//		Key&	GetKey() ;
//		int		MatchKey() ;	/* NOTE : MatchKey returns non-zero on equality
//	} ;
//
//	The Key class has no requirements.
//	
//

#ifndef	_FHASH_H_
#define	_FHASH_H_

//#include	"..\assert\assert.h"

#ifndef	Assert
#define	Assert	_ASSERT
#endif


//------------------------------------------------------------
template< class Data, class Key >
class	TFHash	{
//
//	This class defines a Hash table which can grow dynamically to
//	accomodate insertions into the table.  The table only grows, and
//	does not shrink.
//
private :

	struct	CFreeElement	{
		struct	CFreeElement*	m_pNext ;
	} ;

	//
	// The CBucket structure defines the elements within the hash table.
	//	
	struct	CBucket	{
		Data		m_data ;
		CBucket*	m_pNext ;

		CBucket( Data& d ) : m_data( d ), m_pNext( 0 ) {
		}

		CBucket( ) : m_pNext( 0 ) {
		}

		void*	operator	new( size_t size, void*	pv )	{
			if( pv != 0 ) {
				return	pv ;
			}	
			//
			//	Get memory which is DWORDLONG aligned !
			//
			return	(void*) ::new	DWORDLONG[ (size + sizeof( DWORDLONG ) - 1) / sizeof( DWORDLONG ) ] ;
		}

		void	operator	delete( void *	pv )	{}

#if _MSC_VER >= 1200
        void    operator    delete( void * p, void *pv ) {}
#endif

	private :
		CBucket( CBucket& ) {}

	} ;

	//
	//	Linked list of free memory we've cached to avoid always going
	//	through C runtimes for allocations !
	//
	CFreeElement*	m_pFreeStack ;

	//
	//	Number of Free Blocks we've cached on the stack
	//
	int		m_cFreeStack ;

	//	
	//	Maximum number of Free Blocks we should cache !
	//
	int		m_cMaxFreeStack ;

	int		m_cBuckets ;		// Number of Buckets used in index computation
	int		m_cActiveBuckets ;	// Number of Buckets we are actually using
								// Assert( m_cBuckets >= m_cActiveBuckets ) always true.
	int		m_cNumAlloced ;		// Number of Buckets we have allocated
								// Assert( m_cNumAlloced >= m_cActiveBuckets ) must
								// always be true.
	int		m_cIncrement ;		// The amount we should grow the hash table when we
								// decide to grow it.
	int		m_load ;			// The number of CBuckets we should allow in each
								// collision chain (on average).
	long	m_cInserts ;		// A counter that we use to determine when to grow the
								// hash table.

	DWORD	(* m_pfnHash)( const Key& k ) ;	// The function we use to compute hash values.
										// (Provided by the Caller of Init())

	CBucket**	m_ppBucket ;	// An array of pointer to buckets.

	DWORD	ComputeIndex( DWORD dw ) ;	// The function we use to compute the
								// position of an element in the hash table given its
								// Hash Value.
public :
	TFHash( ) ;
	~TFHash( ) ;

	BOOL	Init(	int	cInitial,
					int cIncrement,
					DWORD (* pfnHash)( const Key& ),
					int load = 2,
					int cMaxFreeStack = 128
					) ;

	//
	//	Check that the hash table is in a valid state
	//	if fCheckHash == TRUE we will walk all the buckets and check that
	//	the data hashes to the correct value !
	//
	BOOL	IsValid( BOOL fCheckHash = FALSE ) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	InsertDataHash(	DWORD	dw,
							Data&	d
							) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	InsertData(	Data&	d ) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	SearchKeyHash(	DWORD	dw,
							Key& k
							) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	SearchKey(	Key& k ) ;

	//
	//	Search for a given Key in the Hash Table and delete the
	//	data if present.  if pd != 0 then we will check that the key
	//	we find is actually within the CBucket object which pd lies within.
	//
	BOOL	DeleteData(	Key& k,	
						Data*	pd = 0	
						) ;

	//	
	//	Insert the given block of data into the hash table.
	//	We will make a copy of the Data Object and store it in one
	//	of our bucket objects.
	//
	BOOL	Insert( Data&	d	) ;

	//	
	//	Find the given key in the table and copy the Data object into
	//	the out parameter 'd'
	//
	BOOL	Search( Key& k,
					Data &d
					) ;

	//
	//	Delete the key and associated data from the table.
	//
	BOOL	Delete( Key k ) ;

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	void	Clear( ) ;

} ;

#include	"fhash.inl"

#endif // _FHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\fhash.inl ===
//
//	FHash.inl
//
//	This file contains the template implementation of the class TFHash.
//


//---------------------------------------------
template< class Data, class Key >
TFHash< Data, Key >::TFHash( ) : m_cBuckets( 0 ), m_cActiveBuckets( 0 ),
	m_cNumAlloced( 0 ), m_cIncrement( 0 ), m_ppBucket( 0 ), m_pfnHash( 0 ), m_load( 0 ), 
	m_pFreeStack( 0 ), m_cFreeStack( 0 ) {
//
//	Very basic constructor
//

}


//---------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::Init( 
								int cInitial, 
								int cIncrement, 
								DWORD (*pfnHash)(const Key&), 
								int load, 
								int	cMaxBucketCache 
								) {
//
//	The initialization function will allocate the initial array of Bucket pointers
//	and set the member variables.   The user can specify the following :
//
//	cInitial - the initial size of the hash table (this is rounded to the nearest power of 2.)
//	cIncrement - the amount the hash table should grow on each growth
//	pfnHash() - The function which computes the hash values for the key.
//	load - the number of elements we should have on average in each collision chain.
//

    //
    // Compute nearest power of 2
    //

	m_cMaxFreeStack = cMaxBucketCache ;

    int	power = cInitial ;
    while( power & (power-1) )
        power = power & (power-1) ;
    power<<= 1 ;

    cInitial = power;
	m_load = load ;
	m_pfnHash = pfnHash ;

    //
    // Number of ActiveBuckets is initially half that of the number of buckets.
    //

    m_cActiveBuckets = power/2  ;
    m_cBuckets = power ;
    m_cInserts = m_cActiveBuckets * m_load ;
    m_cIncrement = m_cActiveBuckets / 4;
	m_cNumAlloced = cInitial + 5 * m_cIncrement ;

	//
	// Allocate bucket pointers and zero initialize
	//

	m_ppBucket = new CBucket*[m_cNumAlloced] ;

    if( m_ppBucket ) {
	    ZeroMemory( m_ppBucket, m_cNumAlloced * sizeof( CBucket*) ) ;
	    Assert( IsValid( FALSE ) ) ;
	    return  TRUE ;
	}
	return	FALSE ;
}

//------------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::IsValid( BOOL fCheckHash ) {
//
//	This function checks that all member variables are consistent and correct.
//	Do not call this function until AFTER calling the Init() function.
//

	if( m_cBuckets <= 0 ||
		m_cActiveBuckets <= 0 ||
		m_cNumAlloced <= 0 ||
		m_cIncrement <= 0 ||
		m_load <= 0 )
		return	FALSE ;

	if( m_cActiveBuckets < (m_cBuckets / 2) || m_cActiveBuckets > m_cBuckets )
		return	FALSE ;

	if( m_cActiveBuckets > m_cNumAlloced )
		return	FALSE ;

	if( m_cInserts > (m_load * m_cActiveBuckets) )
		return	FALSE ;

	if( m_ppBucket == 0 )
		return	FALSE ;

	if( fCheckHash ) {
		//
		// Examine every bucket chain to ensure that elements are in correct slots.
		//
		for( int i=0; i<m_cNumAlloced; i++ ) {

			if( i>=m_cActiveBuckets ) {
				if( m_ppBucket[i] != 0 ) {
					return	FALSE ;
				}
			}	else	{
				for( CBucket *p = m_ppBucket[i]; p != 0; p = p->m_pNext ) {
					if( ComputeIndex( m_pfnHash( p->m_data.GetKey() ) ) != unsigned(i) ) {
						return	FALSE ;
					}
				}
			}
		}
	}
	return	TRUE ;
}


//-------------------------------------------------
template< class Data, class Key >
TFHash< Data, Key >::~TFHash() {
//
//	The destructor discards any memory we have allocated.
//
	Clear();
}


//-------------------------------------------------
template< class Data, class Key >
void	TFHash< Data, Key >::Clear() {
//
//	Discards any memory we have allocated - after this, you must
//  call Init() again!
//
	if( m_ppBucket ) {
		Assert( IsValid( TRUE ) ) ;

		for( int i=0; i<m_cNumAlloced; i++ ) {
			CBucket *p, *pNext ;
			for( p = m_ppBucket[i], pNext = p ? p->m_pNext : 0;
					p!=0; p=pNext, pNext= p ? p->m_pNext : 0 ) {
				delete	p ;
				DWORDLONG*	pdwl = (DWORDLONG*)((void*)p) ;
				delete[]	pdwl ;
			}
		}
		delete[] m_ppBucket;
	}
	for( CFreeElement*	p = m_pFreeStack; 
				p != 0; 
				p = m_pFreeStack ) {

		m_pFreeStack = p->m_pNext ;
		
		DWORDLONG*	pdwl = (DWORDLONG*)((void*)p) ;
		delete[]	pdwl ;
		m_cFreeStack -- ;
	}	
	_ASSERT( m_cFreeStack == 0 && m_pFreeStack == 0 ) ;
	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
	m_pFreeStack = 0;
	m_cFreeStack = 0;
}


//-------------------------------------------------
template< class Data, class Key >
DWORD	TFHash<Data, Key>::ComputeIndex( DWORD dw ) {
//
//	This function tells us where we should store elements.  To do this we mod with
//	m_cBuckets.  Since we only have m_cActiveBuckets in reality, we check the result
//	of the mod and subtract m_cBuckets over 2 if necessary.
//
	DWORD	dwTemp = dw % m_cBuckets ;
	return	(dwTemp >= (unsigned)m_cActiveBuckets) ? dwTemp - (m_cBuckets/2) : dwTemp ;
}


#if 0 
//-------------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::Insert( Data& d ) {
//
//	This function will Insert an element into the Hash table.  We will
//	actually make a copy of the element using the Copy COnstructor Data::Data( Data& )
//	when we do so.
//
	Assert( IsValid( FALSE ) ) ;

	//
	//	Do we have some free memory in our cache !?
	//

	CFreeElement*	pTemp = m_pFreeStack ;
	if( m_pFreeStack != 0 ) {
		m_pFreeStack = m_pFreeStack->m_pNext ;
		m_cFreeStack -- ;
	}

	CBucket*	pNew = new( pTemp )	CBucket( d ) ;
	if( pNew == 0 ) {
		return	FALSE ;
	}

	//
	// First check whether it is time to grow the hash table.
	//
	if( InterlockedDecrement( &m_cInserts ) == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			CBucket** pTemp = new CBucket*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				if( pNew ) { delete pNew; pNew = NULL; }
				return	FALSE ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( CBucket*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( CBucket* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			CBucket**	ppNext = &m_ppBucket[ iCurrent ] ;
			CBucket*	p = *ppNext ;
			while( p ) {

				int	index = ComputeIndex( m_pfnHash( p->m_data.GetKey() ) ) ;
				CBucket*	pNext = p->m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &p->m_pNext ;
				}
				p = pNext ;
			}
		}
	}

	//
	//	Finally, insert into the Hash Table.
	//
	DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	Assert( index < unsigned(m_cActiveBuckets) ) ;

#if 0
	CBucket*	pNew = new	CBucket( d ) ;
#endif

	Assert( pNew );
	pNew->m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = pNew ;

	Assert( IsValid( FALSE ) ) ;

	return	TRUE ;
}
#endif

template< class Data, class Key >
BOOL	TFHash< Data, Key >::Insert( Data& d ) {

	if( InsertData( d ) ) 
		return	TRUE ;
	return	FALSE ;
}

//-------------------------------------------------
template< class Data, class Key >
Data*	TFHash< Data, Key >::InsertDataHash( 
								DWORD	dwHash,
								Data&	d 
								) {
//
//	This function will Insert an element into the Hash table.  We will
//	actually make a copy of the element using the Copy COnstructor Data::Data( Data& )
//	when we do so.
//
	Assert( IsValid( FALSE ) ) ;


	//
	//	Do we have some free memory in our cache !?
	//

	CFreeElement*	pTemp = m_pFreeStack ;
	if( m_pFreeStack != 0 ) {
		m_pFreeStack = m_pFreeStack->m_pNext ;
		m_cFreeStack -- ;
	}

	CBucket*	pNew = new( pTemp )	CBucket( d ) ;
	if( pNew == 0 ) {
		return	FALSE ;
	}

	//
	// First check whether it is time to grow the hash table.
	//
	if( InterlockedDecrement( &m_cInserts ) == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			CBucket** pTemp = new CBucket*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				//
				//	bugbug ... need to handles this error better !?
				//
				if( pNew ) { 
					delete pNew; 
					pNew = NULL; 
				}
				return	FALSE ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( CBucket*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( CBucket* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			CBucket**	ppNext = &m_ppBucket[ iCurrent ] ;
			CBucket*	p = *ppNext ;
			while( p ) {

				int	index = ComputeIndex( m_pfnHash( p->m_data.GetKey() ) ) ;
				CBucket*	pNext = p->m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &p->m_pNext ;
				}
				p = pNext ;
			}
		}
	}

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	Assert( dwHash == m_pfnHash( d.GetKey() ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	Assert( index < unsigned(m_cActiveBuckets) ) ;

	Assert( pNew );
	pNew->m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = pNew ;

	Assert( IsValid( FALSE ) ) ;

	return	&pNew->m_data;
}




//-------------------------------------------------
template< class Data, class Key >
inline	Data*	
TFHash< Data, Key >::InsertData( Data& d ) {
//
//	This function will Insert an element into the Hash table.  We will
//	actually make a copy of the element using the Copy COnstructor Data::Data( Data& )
//	when we do so.
//
	Assert( IsValid( FALSE ) ) ;

	return	InsertDataHash(	m_pfnHash( d.GetKey() ), d ) ;
}


//-----------------------------------------------
template< class Data, class Key >
BOOL	
TFHash< Data, Key >::Search( Key& k, Data &dOut ) {
//
//	Search for an element in the hash table.
//	We will return TRUE if found, FALSE otherwise.
//	If we return false the dOut return parameter is untouched.
//

	const	Data*	pData = SearchKey( k ) ;
	if( pData ) {
		dOut = *pData ;
		return	TRUE ;
	}
	return	FALSE ;
}

//-----------------------------------------------
template< class Data, class Key >
Data*	
TFHash< Data, Key >::SearchKeyHash( 
									DWORD	dwHash, 
									Key& k 
									) {
//
//	Search for an element in the hash table.
//	We will return TRUE if found, FALSE otherwise.
//	If we return false the dOut return parameter is untouched.
//

	Assert( IsValid( FALSE ) ) ;
	Assert( dwHash == (m_pfnHash)(k) ) ;

	DWORD	index = ComputeIndex(	dwHash ) ;
	CBucket*	p = m_ppBucket[index] ;
	while( p ) {
		if( p->m_data.MatchKey( k ) )
			break ;
		p = p->m_pNext ;
	}
	if( p ) {
		return	&p->m_data ;
	}
	return	0 ;
}



//-----------------------------------------------
template< class Data, class Key >
inline	Data*	
TFHash< Data, Key >::SearchKey( Key& k ) {
//
//	Search for an element in the hash table.
//	We will return TRUE if found, FALSE otherwise.
//	If we return false the dOut return parameter is untouched.
//

	Assert( IsValid( FALSE ) ) ;

	return	SearchKeyHash( m_pfnHash( k ), k ) ;
}



//-----------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::Delete( Key k ) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	return	DeleteData( k, 0 ) ;
}



//-----------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::DeleteData(	Key& k,
											Data*	pd
											) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	Assert( IsValid( FALSE ) ) ;

	DWORD	dwHash = (m_pfnHash)( k ) ;

	DWORD	index = ComputeIndex( dwHash ) ;
	CBucket**	ppNext = &m_ppBucket[index] ;
	CBucket*	p = *ppNext ;

	while( p ) {
		if( p->m_data.MatchKey( k ) )
			break ;
		ppNext = &p->m_pNext ;
		p = *ppNext ;
	}
	if( p ) {
		//
		//	If we were given a pointer to a data block, than the client
		//	wants us to check to make sure that we are deleting the correct
		//	instance !!
		//
		if( !pd || pd == &p->m_data ) {
			*ppNext = p->m_pNext ;


			//
			//	Call our do-nothing delete operator - we need to do more 
			//	work to manage the free'd memory !
			//
			delete	p ;

			//
			//	Now in debug versions zap that memory to make sure nobody tries
			//	to use it !!
			//
#ifdef	DEBUG
			FillMemory( p, sizeof( *p ), 0xCC ) ;
#endif
			//
			//	Okay, put that piece of free memory on a little queue we 
			//	maintain if we haven't saved up too much already !
			//
			if( m_cFreeStack < m_cMaxFreeStack ) {
				CFreeElement*	pFree = (CFreeElement*)((void*)p) ;

				pFree->m_pNext = m_pFreeStack ;
				m_pFreeStack = pFree ;
				m_cFreeStack ++ ;


			}	else	{
				//
				//	otherwise - release this memory to the system !
				//
				DWORDLONG*	pdwl = (DWORDLONG*)((void*)p) ;

				::delete[]	pdwl ;

			}

			//
			//	Finally - since we removed something from the hash table 
			//	increment the number of inserts so that we don't keep splitting
			//	the table unnecessarily !
			//
			InterlockedIncrement( &m_cInserts ) ;

			Assert( IsValid( FALSE ) ) ;
			return	TRUE ;
		}
	}
	Assert( IsValid( FALSE ) ) ;
	return	FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\makefile.inc ===
copyfiles:
!if "$(_NTTREE)" != ""
	perl -S xcopy2binplace.pl /yvirfd export $(_NTTREE)\staxpt\export\inc
!endif
!if "$(_NTTREE_NO_SPLIT)" != ""
	perl -S xcopy2binplace.pl /yvirfd export $(_NTTREE_NO_SPLIT)\staxpt\export\inc
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\packoff.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack()
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\mapctxt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mapctxt.h

Abstract:

    Declaration of map context struct

Revision History:

--*/

#ifndef	_MAPCTXT_H_
#define	_MAPCTXT_H_

//
//	Each service must initialize and pass a SERVICE_MAPPING_CONTEXT
//	to Initialize() if it wants to do client-cert mapping. This context
//	contains a callback that knows how to return the mapper objects
//	for a given instance.
//

typedef struct _SERVICE_MAPPING_CONTEXT
{
	BOOL (WINAPI * ServerSupportFunction) (
		PVOID pInstance,
		PVOID pData,
		DWORD dwPropId
	);
	
} SERVICE_MAPPING_CONTEXT, *PSERVICE_MAPPING_CONTEXT;

#define	SIMSSL_PROPERTY_MTCERT11				1000
#define SIMSSL_PROPERTY_MTCERTW					1001
#define SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED		1002
#define SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED		1003
#define SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED	1004
#define SIMSSL_NOTIFY_MAPPER_CERT11_TOUCHED		1005

#endif // _MAPCTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\packon.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\isquery.h ===
#include <windows.h>
#define OLEDBVER 0x0250 // enable ICommandTree interface
#include <ole2.h>
#include <oledb.h>
#include <cmdtree.h>
#include <ntquery.h>

// the maximum number of columns that the user can request in their
// comma delimited list
#define MAX_COLUMNS 6
#define MAX_FRIENDLYNAME 128

typedef HRESULT
(STDAPICALLTYPE *PCIMAKEICOMMAND)(ICommand **           ppQuery,
                          ULONG                 cScope,
                          DWORD const *         aDepths,
                          WCHAR const * const * awcsScope,
                          WCHAR const * const * awcsCat,
                          WCHAR const * const * awcsMachine );

typedef HRESULT
(STDAPICALLTYPE *PCITEXTTOFULLTREE)(WCHAR const * pwszRestriction,
                            WCHAR const * pwszColumns,
                            WCHAR const * pwszSortColumns, // may be NULL
                            WCHAR const * pwszGroupings,   // may be NULL
                            DBCOMMANDTREE * * ppTree,
                            ULONG cProperties,
              /*optional*/  CIPROPERTYDEF * pReserved,
                            LCID LocaleID );

class CIndexServerQuery {
    public:
		// This is used to globally initalize the CIndexServerQuery classes
		// by having it load the necessary bits that it needs from Tripoli.
		// It should be called on service startup by any service which
		// expects to use CIndexServerQuery
		static HRESULT GlobalInitialize();
		// This is the global shutdown code... it should be called on service
		// shutdown
		static HRESULT GlobalShutdown();
		// constructor
        CIndexServerQuery();
        //
        // start the query going.
        //
        // arguments:
        // [in] bDeepQuery - TRUE if deep query, FALSE if shallow
        // [in] pwszQueryString - the tripoli query string
        // [in] pwszMachine - the machine to query against (NULL for localhost)
        // [in] pwszCatalog - the tripoli catalog to query against (name or
        //                    path is okay).
        // [in] pwszScope - the tripoli scope to query against.  NULL for the
        //                  default scope (\).
        // [in] pwszColumns - the columns to return.  supported columns are
        //                    filename,newsarticleid,newsgroup,newsmsgid.
        //                    note: this string gets altered internally, so
        //                    it might change from what you pass in.
        // [in] pwszSortOrder - sort priority for the columns.  NULL to return
        //                      unsorted
        //
        HRESULT MakeQuery( BOOL bDeepQuery, WCHAR const *pwszQueryString,
            WCHAR const *pwszMachine, WCHAR const *pwszCatalog,
            WCHAR const *pwszScope, WCHAR *pwszColumns, WCHAR const *pwszSortOrder,
			LCID LocaleID = GetSystemDefaultLCID(), DWORD cMaxRows = 0);
        //
        // get the results from the query
        //
        // arguments:
        // [in] pcResults - pointer to the a size of the ppvResults array
        // [out] pcResults - the number of items put into ppvResults
        // [in/out] ppvResults - an array of pointers to PROPVARIANTS.  this is
        //                       filled in by column for up to *pcResults
        //                       rows.
        // [out] pfMore - set to TRUE if there are more results, FALSE if
        //                this is the last set of results.
        //
        // usage:
        // DWORD cResults;
        // PROPVARIANT *rgpvResults[COLUMNS * ROWS];
        // BOOL fMore;
        // cResults = ROWS;
        // HRESULT hr;
        // hr = GetQueryResults(&cResults, rgpvResults, &fMore);
        // if (FAILED(hr)) /* handle error */
        // else {
        //    for (i = 0; i < ROWS; i++) {
        //       PROPVARIANT **ppvColumn = rgpvResults + (j * ROWS);
        //       /* ppvColumn[0] has column 0 in row j */
        //       /* ppvColumn[1] has column 1 in row j */
        //       /* etc... */
        //    }
        // }
        //
        HRESULT GetQueryResults(DWORD *pcResults, PROPVARIANT **ppvResults,
                                BOOL *pfMore);
        ~CIndexServerQuery();

    private:
		// class globals
		static HMODULE				m_hmQuery;
		static PCIMAKEICOMMAND		m_pfnCIMakeICommand;
		static PCITEXTTOFULLTREE	m_pfnCITextToFullTree;
		
		// class variables
        HACCESSOR       			m_hAccessor;
        IRowset         			*m_pRowset;
        DWORD           			m_cCols;
        BOOL            			m_fNoMoreRows;
        HROW            			*m_phRows;
        DBCOUNTITEM       			m_cRowHandlesAllocated;
        DBCOUNTITEM        			m_cRowHandlesInUse;
		struct tagCIPROPERTYDEF		*m_pPropDef;
		DWORD						m_cPropDef;

        HRESULT CreateAccessor(WCHAR *szColumns);
		HRESULT BuildFriendlyNames(const WCHAR *pwszQueryString);
        void ReleaseAccessor();
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\norminfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetinfo.h

Abstract:

    This file contains the internet info server admin APIs.
	Added Normandy specific stuff.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

    Madana      10-Oct-1995  Made a new copy for product split from inetasrv.h
    MuraliK     12-Oct-1995  Fixes to support product split
    MuraliK     15-Nov-1995  Support Wide Char interface names

--*/

#ifndef _NORMINFO_H_
#define _NORMINFO_H_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  NNTP specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define NNTP_SERVICE_NAME        TEXT("NNTPSVC")
# define NNTP_SERVICE_NAME_A      "NNTPSVC"
# define NNTP_SERVICE_NAME_W      L"NNTPSVC"

//
//   Client Interface Name for RPC connections over named pipes
//

# define  NNTP_INTERFACE_NAME     NNTP_SERVICE_NAME
# define  NNTP_NAMED_PIPE         TEXT("\\PIPE\\") ## NNTP_INTERFACE_NAME
# define  NNTP_NAMED_PIPE_W       L"\\PIPE\\" ## NNTP_SERVICE_NAME_W

//
//	Service location stuff
//
#define INET_NNTP_SVCLOC_ID         (ULONGLONG)(0x0000000000000008)

#if 0
#define METACACHE_NNTP_SERVER_ID                 3
#define METACACHE_SMTP_SERVER_ID                 4
#define METACACHE_POP3_SERVER_ID                 5
#define METACACHE_IMAP_SERVER_ID                 6
#endif

#endif	// _NORMINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\hashimp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

hashimp.h

Abstract : 

	This file contains the inline functions required to implement
	the hash tables defined in hashmap.h


--*/

#ifndef	_HASHIMP_H_
#define	_HASHIMP_H_

inline
IStringKey::IStringKey(	
					LPBYTE	pbKey,	
					DWORD	cbKey ) :	
	m_lpbKey( pbKey ), 
	m_cbKey( cbKey )	{
}


inline	LPBYTE	
IStringKey::Serialize(	
					LPBYTE	pbPtr 
					)	const	{
	PDATA	pData = (PDATA)pbPtr ;
	pData->cb = (WORD)m_cbKey ;
	CopyMemory( pData->Data, m_lpbKey, m_cbKey ) ;
	return	pData->Data + m_cbKey ;
}


inline	LPBYTE	
IStringKey::Restore(	
					LPBYTE	pbPtr,	
					DWORD	&cbOut	
					)	{
	PDATA	pData = (PDATA)pbPtr ;
	if( m_cbKey < pData->cb ) {
		cbOut = pData->cb ;
		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		return	 0 ;
	}
	cbOut = m_cbKey = pData->cb ;
	CopyMemory( m_lpbKey, pData->Data, m_cbKey ) ;
	return	pData->Data + m_cbKey ;
}


inline	DWORD	
IStringKey::Size() const	{
	return	sizeof( SerializedString ) - sizeof( BYTE ) + m_cbKey ;
}


inline	BOOL	
IStringKey::Verify(	
					LPBYTE	pbContainer,
					LPBYTE	pbPtr,	
					DWORD	cb 
					)	const	{
	PDATA	pData = (PDATA)pbPtr ;
	if( pData->cb > cb ) {
		return	FALSE ;
	}
	return	TRUE ;
}


inline	DWORD	
IStringKey::Hash( )	const	{

	return	CHashMap::CRCHash( m_lpbKey, m_cbKey ) ;

}


inline	BOOL	
IStringKey::CompareKeys( 
					LPBYTE	pbPtr 
					)	const	{
	PDATA	pData = PDATA( pbPtr ) ;
	return pData->cb == m_cbKey && !memcmp( pData->Data, m_lpbKey, m_cbKey ) ;
}


inline	LPBYTE	
IStringKey::EntryData(	
					LPBYTE	pbPtr,	
					DWORD	&cbOut 
					)	const	{
	PDATA	pData = PDATA( pbPtr ) ;
	return	pData->Data + pData->cb ;
}


#endif	// _HASHIMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\hashmap.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    hashmap.h

Abstract:

    This module contains class declarations/definitions for

        CHashMap
        CMsgArtMap
        CHistory


    **** Schedule ****

    Hash function                   Free (ripped out from INN code)

    Core Hash Engine:               2 weeks
        Initialization/Setup
        Collision resolution
            Double hashing/
                linear probing


        Insertion
        Page Splitting
        Search
        Deletion
        Directory setup

    Article Mapping                 1 week
        Leaf Page Setup
        Leaf Page Compaction
        Recovery
        Statistics


    History                         1 week
        Leaf Page Setup
        Insertion
        Crawler/Expiration/Deletion
        Statistics

    Unit Testing                    2 weeks
        Get a large set of msg ids
        Write an app to
            try out hash fn and make sure distribution is acceptable
            test page splitting and directory growing operations
            test compaction code
            test multithreaded operations
            get raw speed of table lookup (lookup/sec)
            detect map file corruption
            rebuilding of map file
            test history crawler delete and compaction operations

    Misc design stuff
        At startup, figure out the system page size
        Regkey for size of mapping file
        Add collision info to statistics
        Backup history file


    **** Hash algorithm ****

    Overview:

    The hashing mechanism is made up of 2 structures: the directory,
    and the leaf pages.  The directory is made up of 2**n entries,
    where n is the first n bits of a hash value.  Each directory
    entry points to a leaf page.  (A leaf page can be pointed to by
    more than one entry).

    A leaf page contains up to x entries.  When the page is about to be
    full (determined by number of entries or by space remaining), the
    page is split into two.  After the page is split, the directory pointers
    will also have to be modified to account for the new page.

    This scheme ensures that we take at most 2 page faults for each search.


    Implementation details:

    The leaf page can accomodate up to 128 entries. The last m=7 bits
    of the hash value is used to hash into the list.  We will use
    linear probing with p=1 to resolve collisions.

    The leaf page has fields called HashPrefix and PageDepth.  The HashPrefix
    contains the first PageDepth bits of a hash value which this page
    represents.  PageDepth <= n.  If PageDepth < n, then that means that
    more than one entry points to it.

    If PageDepth == n and we need to split the page, then this would
    necessitate rebuilding the directory structure so the condition
    PageDepth <= n will still be true after the split.

    We are using the first page of the mapping file as a reserved page.
    Here, we will store statistics information etc.


    **** Recovery strategy ****

    Detection:

        The first page of the map file will be reserved.  This will contain
        timestamps and statistics.  There will be an entry to indicate
        whether a clean shutdown took place.  If during startup, this
        flag indicates otherwise, we need to do a possible rebuild.

        ** We can also think of putting something in the registry
        to indicate this.  Maybe we'll do both. **

        There will be a LastWrite timestamp in this page.  After each flush,
        the timestamp will be updated. This will give us an indication on
        when the last complete write took place.

    Rebuilding the mapping file:

        There are three levels of map file rebuilding.  This can be
        specified by the operator.

        Level 1 rebuild

            Using the timestamp, find all the articles file time stamps
            which were created after this and add them to the lookup table.

        Level 2 rebuild

            A cursory rebuild assumes that all the XOver files in each
            newsgroup is valid.  The rebuilding will involve going over
            each XOver file (about 10000 of them), and rebuild the table
            with xover entries.

        Level 3 rebuild

            The more extensive rebuild involves going through each and every
            article in every newsgroup.  This will probably involve at least
            a million files and would substantially take longer to do.

        How do we know if we need to upgrade to a higher level?

            Well, the hash table will know how many article entries it
            has and there should be some way of figuring out how many
            articles are stored in the disk.  If they don't match, then
            it's time to upgrade.


    **** Registry Keys ****

        MappingFileSize     DWORD       Size of mapping files
        HashFileName        REG_SZ      Name of hash files
        InitialPageDepth    DWORD       Initial depth of leaf nodes
        Did they existed ?


Author:

    Johnson Apacible (JohnsonA)     07-Sept-1995

Revision History:

	Alex Wetmore (awetmore)			27-Aug-1996
	    - seperated from nntp server
		- removed dependencies for this include file on others...

--*/

#ifndef _HASHMAP_
#define _HASHMAP_

#include	"smartptr.h"

#ifdef	_USE_RWNH_
#include	"rwnew.h"
typedef	class	CShareLockNH	_RWLOCK ;
#else
#include	"rw.h"
typedef	class	CShareLock		_RWLOCK ;
#endif

//
// type declarations
//
typedef DWORD HASH_VALUE;

//
// manifest constants for hash stuff
//
#define   	KB							1024
#define     HASH_PAGE_SIZE              (4 * KB)
#define     NUM_PAGES_PER_IO            64

#define     MAX_MSGID_LEN               255
#define     MIN_HASH_FILE_SIZE          ((1+(1<<NUM_TOP_DIR_BITS)) *  HASH_PAGE_SIZE)

#define     LEAF_ENTRY_BITS             7
#define     MAX_LEAF_ENTRIES            (1 << LEAF_ENTRY_BITS)
#define     LEAF_ENTRY_MASK             (MAX_LEAF_ENTRIES - 1)
#define     MAX_XPOST_GROUPS            255

//
// Num of entries, bytes, and size of fragments to trigger page split.
//
#define     LEAF_ENTRYCOUNT_THRESHOLD   MAX_LEAF_ENTRIES
//#define     LEAF_ENTRYCOUNT_THRESHOLD   (MAX_LEAF_ENTRIES * 7 / 8)
#define     LEAF_SPACE_THRESHOLD        300
#define     FRAG_THRESHOLD              400

#define     DEF_DEPTH_INCREMENT         2
#define		DEF_PAGE_RESERVE			4
#define     DEF_PAGE_INCREMENT          32
#define     NUM_PAGE_LOCKS              256
#define		NUM_TOP_DIR_BITS			9
#define		MAX_NUM_TOP_DIR_BITS		10

//
// MASK and SIGNATURES
//
#define     DELETE_SIGNATURE            0xCCCC
#define     OFFSET_FLAG_DELETED         0x8000
#define     OFFSET_VALUE_MASK           0x7fff

#define     ART_HEAD_SIGNATURE          0xaaaaaaaa
#define     HIST_HEAD_SIGNATURE         0xbbbbbbbb
#define     XOVER_HEAD_SIGNATURE        0xcccccccc

#define     DEF_HEAD_SIGNATURE          0xdefa1234
#define     CACHE_INFO_SIGNATURE        0xbeef0205
#define     GROUP_LINK_MASK             0x80000000

//
// history map stuff (should be reg settable)
//
#define     DEF_EXPIRE_INTERVAL         (3 * SEC_PER_WEEK) // 1 week
#define     DEF_CRAWLER_WAKEUP_TIME     (30)               // 30 secs
#define     MIN_MAXPAGES_TO_CRAWL       (4)

//
//
// what fraction of total pages to crawl.  1/128 means
// we could cover all the pages in 2 hours.  This is
// expressed in terms of shifts.  7 right shift is 128
//
#define     FRACTION_TO_CRAWL_SHFT      7

//
// Indicates that the space used for this entry has been reclaimed
//
#define     ENTRY_DEL_RECLAIMED         ((WORD)0xffff)

//
// Get pointer given the offset and base
//
#define     GET_ENTRY( _base, _offset ) \
                ((PCHAR)(_base) + (_offset))

//
// See if we need to update the stats in the header page
//
#define     UPDATE_HEADER_STATS( ) { \
            if ( (m_nInsertions + m_nDeletions) >= STAT_FLUSH_THRESHOLD ) { \
                FlushHeaderStats( ); \
            } \
}

//
// Current hash table valid version numbers
//
// Significant Versions:
// 000  - old table
// 300  - Removed duplicates from the xover table
// 310  - Remove xposting from article table
//      - add articleid/groupid coding into xover table
// 320  - Change XOVER table to hold offsets into articles
// 330  - Change hash table to use two tier directory
// 340	- Change Xover Table to remove most data and place in index files !
// 350  - Change the number of top level directories used to 512 !
//
#define     HASH_VERSION_NUMBER_MCIS10	0x340
#define		HASH_VERSION_NUMBER			0x350

//
// Disable auto alignments
//
#pragma pack(1)

//
// doubly linked list
//
typedef struct _HASH_LIST_ENTRY {

    WORD    Flink;
    WORD    Blink;

} HASH_LIST_ENTRY, *PHASH_LIST_ENTRY;

//
// Entry headers - this is the structure of each hash entry header
//
typedef struct _ENTRYHEADER {

    //
    // hash value
    // *** Must be first entry ***
    //

    DWORD   HashValue;

    //
    // Size of this entry
    // *** Must be second entry ***
    //

    WORD    EntrySize;

#ifdef _WIN64
	//
	// Alignment word. This makes data align-8 instead of align-2, without
	// it the compiler would look at the type "BYTE" figure align-1 is good
	// enough and then place it right after EntrySize at an align-2 slot.  With
	// this word we cause the slot to be 8 bytes into the struct and hence align-8.
	// Data will hold larger objects and hence must be aligned better.
	//
	WORD	Reserved;
#endif

	//
	//	Member variable for var length data
	//
	BYTE	Data[1] ;

} ENTRYHEADER, *PENTRYHEADER;

//
// headers for deleted entries
//
typedef struct _DELENTRYHEADER {

    //
    // doubly linked list
    //

    HASH_LIST_ENTRY Link;

    //
    // Size of this entry
    //

    WORD    EntrySize;

    //
    // ???
    //

    WORD    Reserved;

} DELENTRYHEADER, *PDELENTRYHEADER;

//
// Handle for caching entry information
//
typedef struct _HASH_CACHE_INFO {

    //
    // Signature to verify this structure
    //

    DWORD       Signature;

    //
    // Cache of hash and msg id length
    //

    HASH_VALUE  HashValue;
    DWORD       MsgIdLen;

} HASH_CACHE_INFO, *PHASH_CACHE_INFO;

//
// This is the structure for the head page.
//
typedef struct _HASH_RESERVED_PAGE {

    //
    // Signature to identify the hash file
    //

    DWORD   Signature;

    //
    // Version number of the hash table
    //

    DWORD   VersionNumber;

    //
    // Has this file been initialized?
    //

    BOOL    Initialized;

    //
    // Is this file active
    //

    BOOL    TableActive;

    //
    // Number of pages that are being used including the reserved page
    //

    DWORD   NumPages;

    //
    // Max dir depth of the directory
    //

    DWORD   DirDepth;

    //
    // Statistics
    //

    DWORD   InsertionCount;
    DWORD   DeletionCount;
    DWORD   SearchCount;
    DWORD   PageSplits;
    DWORD   DirExpansions;
    DWORD   TableExpansions;
    DWORD   DupInserts;

} HASH_RESERVED_PAGE, *PHASH_RESERVED_PAGE;

//
// This is the structure of each entry in the leaf pages of the hash table.
//
typedef struct _MAP_PAGE {

    //
    // Prefix of hash values currently mapped into this page
    //

    DWORD   HashPrefix;

    //
    // Number of bits of the hash value that is mapped to this page
    //

    BYTE    PageDepth;

    //
    // Number of active indices in the page (includes deletes)
    //

    BYTE    EntryCount;

    //
    // Number of real entries in this page
    //

    BYTE    ActualCount;

    //
    // Flags
    //

    BYTE    Flags;

    //
    // Location to add new entry
    //

    WORD    ReservedWord;
    WORD    NextFree;

    //
    // Location of the page ending
    //

    WORD    LastFree;

    //
    // Number of bytes left by deleted entries
    //

    WORD    FragmentedBytes;

    //
    // Reserved, can be used for anything.  !QWA
    //

    WORD    Reserved1;
    WORD    Reserved2;
    WORD    Reserved3;
    WORD    Reserved4;

    //
    // List of deleted entries
    //

    HASH_LIST_ENTRY  DeleteList;

    //
    // Offset of entry from beginning of page.  Deleted entries
    // will have the high bit set.
    //

    WORD    Offset[MAX_LEAF_ENTRIES];

    //
    // Start of Entries
    //

    DWORD   StartEntries;

} MAP_PAGE, *PMAP_PAGE;

//
// Page header flags
//

#define PAGE_FLAG_SPLIT_IN_PROGRESS     (WORD)0x0001

//
// XOVER FLAGS
//
#define XOVER_MAP_PRIMARY       ((BYTE)0x01)

#pragma pack()

class CDirectory;
class PageEntry;
class	CPageCache ;





typedef	CRefPtr< CPageCache >	CCACHEPTR ;

//
//	Helper class for managing all of the locks that must be manipulated
//	to access something within the Hash Tables.
//
//	There are two principal locks that must almost always be held :
//
//		A Lock on the directory which references a hash table page
//		(this can be either exclusive or shared)
//		A CDirectory object contains and manages this lock.
//
//		A Lock on the page which contains the hash table page -
//		A PageEntry structure contains and manages this lock.
//
//	What we do is co-ordinate the use of these two locks, whenever
//	hash table data is accessed we keep track of both the Directory
//	that refers to the hash page and the hash table page containing the
//	data. (through pointers to these objects).  When we are created
//	we always have NULL pointers, and we accumulate these pointers
//	as CHashMap
//
//
class	CPageLock	{
private:

	friend	class	CPageCache	;
	friend	class	CDirectory ;
	friend	class	CHashMap ;

	//
	//	Copy constructor is private - because we don't want people making copies !!
	//
	CPageLock( CPageLock& ) ;
	CPageLock&	operator=( CPageLock& ) ;

	//
	//	The PageEntry object which has read our page into memory, and which
	//	has the critical section guaranteeing exclusive access to the page
	//
	PageEntry*		m_pPage ;

	//
	//	The directory we used to lookup the page - we have grabbed
	//	the directory either exclusively, or shared - The caller must
	//	keep track of which and use the appropriate API's
	//
	CDirectory*		m_pDirectory ;

	//
	//	Used to figure out whether we got the page shared or exclusive !
	//
	BOOL			m_fPageShared ;

	//
	//	Secondary page - used when we are doing page splits !
	//
	PageEntry*		m_pPageSecondary ;

#ifdef	DEBUG
	//
	//	This is used in debug builds to make sure the caller is using
	//	the correct API's and keeping track of shared/exclusive usage
	//	correctly !
	//
	BOOL			m_fExclusive ;
#endif

	//
	//	Only public members are constructor and destructor -
	//	everything else is used by our friends - CHashMap only !
	//
public :

	//
	//	Initialize to a NULL state
	//
	inline	CPageLock() ;

#ifdef	DEBUG
	//
	//	In debug builds - _ASSERT check that all our members
	//	are set to NULL before we are destroyed - as we release locks
	//	we will set these to NULL !
	//
	inline	~CPageLock() ;
#endif

private :
	//
	//	Lock a specific directory for shared access, and
	//	remember what directory we grabbed so we can release it later !
	//
	inline	void	AcquireDirectoryShared( CDirectory*	pDirectory	) ;

	//
	//	Lock a specific directory for EXCLUSIVE access, and remember what
	//	directory we grabbed so we can release it later !
	//
	inline	void	AcquireDirectoryExclusive(	CDirectory*	pDirectory ) ;

	//
	//	Release the directory !
	//
	inline	void	ReleaseDirectoryExclusive() ;

	//
	//	Release a ShareLock from the directory !
	//
	public:	void	ReleaseDirectoryShared() ;

	//
	//	Lock a page - and remember who we locked for later release !
	//
	private:	inline	PMAP_PAGE	AcquirePageShared(
							PageEntry	*page,
							HANDLE		hFile,
							DWORD		PageNumber,
							BOOL		fDropDirectory
							) ;
	inline	PMAP_PAGE	AcquirePageExclusive(
							PageEntry	*page,
							HANDLE		hFile,
							DWORD		PageNumber,
							BOOL		fDropDirectory
							) ;
	//
	//	Lock the secondary page Exclusive !
	//
	inline	BOOL	AddPageExclusive(
							PageEntry*	page,
							HANDLE		hFile,
							DWORD		PageNumber
							) ;

	//
	//	Release all of our locks - we were holding a shared lock before !
	//
	inline	void	ReleaseAllShared(	PMAP_PAGE	page ) ;

	//
	//	Release all of our locks - we had an exclusive lock on the directory !
	//
	inline	void	ReleaseAllExclusive(	PMAP_PAGE	page	) ;

	//
	//	Check that all of the members are legally setup !
	//
	BOOL		IsValid() ;


} ;

typedef	CPageLock	HPAGELOCK ;

extern DWORD LeafMask[];

//
// Size of our directory view
//

#define DIR_VIEW_SIZE       (64 * KB)

//
// Number of entries per view
//

#define DIR_VIEW_ENTRIES    (16 * KB)
#define DIR_VIEW_SHIFT      14
#define DIR_VIEW_MASK       0x00003fff


//
// Number of inserts and deletes before stats are flushed
//

#define STAT_FLUSH_THRESHOLD    16

DWORD
WINAPI
CrawlerThread(
        LPVOID Context
        );


//
//	This is a protototype for the function pointer the hash tables
//	can call in case of critical errors.
//	This function is called when the hash table gets an error from
//	the O.S. which will seriously affect the usablility of the hash table.
//	For instance, if we fail to allocate more memory when expanding a
//	directory, the hash table will most likely to start to fail the
//	majority of attempts to insert new items.
//	This is probably non recoverable, and the function would be called
//	with fRecoverable set to FALSE.
//	If the hash table fails due to a more temporary condition, ie. out
//	of disk space, then the function will be called with fRecoverable
//	set to TRUE.
//	This function pointer is registered on the call to the hash tables
//	Initialize() function.
//
typedef	void	(* HASH_FAILURE_PFN)(	LPVOID	lpv,
										BOOL	fRecoverable	) ;

//
//	This interface defines the interface used by both Key's and Entry's
//	to save and restore their data into the hash table.
//
class	ISerialize	{
	public :
		//
		//	Save the data into a serialized form, and return a pointer
		//	to where the next block of data can be placed !
		//	This can be called IFF IsDataSet() == TRUE
		//
		virtual	LPBYTE	Serialize(	LPBYTE	pbPtr )	const = 0 ;

		//
		//	Restore data from a serialized block of data !
		//	This can be called IF IsDataSet() == TRUE  || IsDataSet() == FALSE
		//
		//	If the return value is NULL the call failed, and cbOut contains
		//	the number of bytes required to hold the data in unserialized form !
		//
		virtual	LPBYTE	Restore(	LPBYTE	pbPtr,
									DWORD	&cbOut
									) = 0 ;

		//
		//	Return the number of bytes required to serialize the object !
		//	This can be called IFF IsDataSet() == TRUE
		//
		virtual	DWORD	Size( ) const = 0 ;

		//
		//	This function verifies that the serialized block of data is valid !
		//	This can be called IF IsDataSet() == TRUE || IsDataSet() == FALSE
		//
		//	NOTE : pbContainer - will point to the start of the entire block
		//	of data containing both serialized Key and Data blocks !
		//
		virtual	BOOL	Verify(	LPBYTE	pbContainer,
								LPBYTE	pbPtr,
								DWORD	cb
								) const = 0 ;
} ;


//
//	This interface defines the extra interface members a Key must support
//	in order to be used by the hash tables
//
class	IKeyInterface : public ISerialize	{
	protected :
		//
		//	Default parameter for EntryData() when we wish to discard
		//	the size output !
		//
		static	DWORD	cbJunk ;
	public:
		//
		//	Compute the hash value of this key !
		//	this must be called IFF IsDataSet() == TRUE !
		//
		virtual	DWORD	Hash() const	= 0 ;

		//
		//	Compare a Key to a Serialized Key this must
		//	be called IFF IsDataSet() == TRUE
		//
		virtual	BOOL	CompareKeys( LPBYTE	pbPtr ) const = 0 ;

		//
		//	Given some serialized Key Data find the Start of
		//	the serialized Entry Data.  The resulting pointer
		//	must be suitable to be passed to an Entry object's
		//	Restore() method.
		//
		virtual	LPBYTE	EntryData(	LPBYTE pbPtr,
									DWORD&	cbKeyOut = IKeyInterface::cbJunk
									)	const = 0 ;


} ;

class	IStringKey	:	public	IKeyInterface	{
	private :
		//
		//	Pointer to the String We are concerned with !
		//
		LPBYTE	m_lpbKey ;
		//
		//	Number of bytes available !
		//
		DWORD	m_cbKey ;

		//
		//	The structure we serialize to.
		//
		struct	SerializedString	{
			WORD	cb ;
			BYTE	Data[1] ;
		} ;

		typedef	SerializedString*	PDATA ;

	public :
		//
		//	Construct a Key object !
		//
		IStringKey(	LPBYTE	pbKey = 0,
					DWORD	cbKey = 0
					) ;

		//
		//	Required by ISerialize Interface - save key data into memory
		//
		LPBYTE
		Serialize(	LPBYTE	pbPtr )	const ;

		//
		//	Required by ISerialize Interface - restore key data from buffer
		//
		LPBYTE
		Restore(	LPBYTE	pbPtr,	DWORD	&cbOut	)	;

		//
		//	Return the number of bytes required by Serialize()
		//
		DWORD
		Size() const ;

		//
		//	Check that a serialized version of the data looks legal !
		//
		BOOL
		Verify(	LPBYTE	pbContainer,
				LPBYTE	pbPtr,
				DWORD	cb
				)	const ;

		//
		//	Compute the hash value of the key
		//
		DWORD
		Hash( )	const	;

		//
		//	Compare the Key contained in an instance to a serialized one !
		//
		BOOL
		CompareKeys( LPBYTE	pbPtr )	const	;

		//
		//	Get a pointer to where the Entry should have been serialized
		//	following the Key
		//
		LPBYTE
		EntryData( LPBYTE	pbPtr,	DWORD	&cbOut )	const;

} ;

//
//	Interface to be used to access the reserved words within the hash table
//
class	IEnumInterface	{
public :

	//
	//	This interface is passed to the GetFirstMapEntry, GetNextMapEntry routines !
	//	This function is called to determine if there is anything on this
	//	page we wish to deal with !!
	//
	virtual	BOOL
	ExaminePage(	PMAP_PAGE	page ) = 0 ;

	//
	//	This function is called to determine if we wish to examine an
	//	a particular entry within a page !!
	//
	//
	virtual	BOOL
	ExamineEntry(	PMAP_PAGE	page,	LPBYTE	pbPtr ) = 0 ;

} ;


//
// an entry in the hash table
//
// this is an interface used for writing to data in the hashmaps.
// to store data in the hashmap a class must derive from this that
// implements all of the methods
//
//	NOTE : This interface handles the serialization of keys and puts them
//	automagically as the first element of the structure.  This is laid out
//	as specified by _KEY_ENTRY below !
//
typedef struct _KEY_ENTRY {
	// length of key
	WORD KeyLen;
	BYTE Key[1];
} KEY_ENTRY, *PKEY_ENTRY;

//
//	CHashEntry is an old interface used by the hash tables.
//	we define a
//
//
//
class CHashEntry : public ISerialize
{
    public:

		LPBYTE
		Serialize( LPBYTE pbPtr )	const	{

			SerializeToPointer( pbPtr ) ;
			return	pbPtr ;
		}

		LPBYTE
		Restore( LPBYTE pbPtr, DWORD&	cbOut ) {

			cbOut = 0 ;
			RestoreFromPointer( pbPtr ) ;
			return	pbPtr ;
		}

		DWORD
		Size( )	const {

			return	GetEntrySize() ;

		}

		BOOL
		Verify( LPBYTE	pbContainer, LPBYTE	pbPtr, DWORD	cbData )	const	{

			return Verify( pbContainer, (DWORD)(pbPtr-pbContainer), pbPtr) ;
		}

		//
		// take data and store it into a pointer.  no more then
		// CHashEntry::GetEntrySize() bytes should be stored here
		//
	    virtual void SerializeToPointer(LPBYTE pbPtr) const=0;
		//
		// unserialize data at pbPtr into this class
		//
	    virtual void RestoreFromPointer(LPBYTE pbPtr)=0;
		//
		// the number of bytes required to store the data in this
		// hash entry
		//
	    virtual DWORD GetEntrySize() const=0;
		//
		// make sure that data is valid in its marshalled format
		//
		virtual BOOL Verify(LPBYTE pKey, DWORD cKey, LPBYTE pbPtr) const = 0;
};


class CHashWalkContext
{
	private:
		//
		// variables needed for GetFirstMapEntry/GetNextMapEntry
		//
		// buffer containing the data in the current page
		BYTE m_pPageBuf[HASH_PAGE_SIZE];
		// the current page that we are examining
		DWORD m_iCurrentPage;
		// the current entry in the current page
		DWORD m_iPageEntry;

	friend class CHashMap;
};

//
// Flags returned from VerifyHashMapFile in *pdwErrorFlags.  anything that fits
// in the mask 0x0000ffff is a fatal error (so the hashmap is invalid)
//
// invalid directory link
#define HASH_FLAG_BAD_LINK             0x00000001
// invalid hash file signature
#define HASH_FLAG_BAD_SIGNATURE        0x00000002
// invalid hash file size
#define HASH_FLAG_BAD_SIZE             0x00000004
// corrupt page prefix
#define HASH_FLAG_PAGE_PREFIX_CORRUPT  0x00000008
// file init flag not set
#define HASH_FLAG_NOT_INIT             0x00000010
// page entry count doesn't match number of page entries
#define HASH_FLAG_BAD_ENTRY_COUNT      0x00000020
// invalid page count
#define HASH_FLAG_BAD_PAGE_COUNT       0x00000040
// bad directory depth
#define HASH_FLAG_BAD_DIR_DEPTH        0x00000080
// invalid entry size or offset
#define HASH_FLAG_ENTRY_BAD_SIZE       0x00000100
// invalid entry hash value
#define HASH_FLAG_ENTRY_BAD_HASH       0x00000200
// Verify() function on entry data failed
#define HASH_FLAG_ENTRY_BAD_DATA       0x00000400

//
// hash file couldn't be found
//
#define HASH_FLAG_NO_FILE              0x00010000
//
// If this is set, then no rebuilding is to take place
// because of a fatal error.
//
#define HASH_FLAG_ABORT_SCAN           0x00020000

//
// flags that can be passed into the verify functions to specify how
// strict they should be (more flags means longer checks and slower
// runs).
//
//

// build a directory and check it for integrity.  this is also done in
// Initialize, so it is not needed in general
#define HASH_VFLAG_FILE_CHECK_DIRECTORY		0x00000001
// do basic checks for for valid offsets, page lengths, and hash values
// for each entry (this needs to be there for anything to get checked in
// pages)
#define HASH_VFLAG_PAGE_BASIC_CHECKS		0x00010000
// call the CHashEntry::Verify method to check the data of each entry
#define HASH_VFLAG_PAGE_VERIFY_DATA			0x00020000
// check for overlapping entries
#define HASH_VFLAG_PAGE_CHECK_OVERLAP		0x00040000

#define HASH_VFLAG_ALL 						0xffffffff



//
// These flags indicate that the file is corrupt and should
// be rebuilt.
//
#define HASH_FLAGS_CORRUPT             0x0000ffff

//
//
//
// CHashMap - pure virtual base class for NNTP hash table
//
// The algorithm we are using is similar to the Extendible Hashing
// Technique specified in "Extendible Hashing - A Fast Access Method for
// Dynamic Files" ACM Transaction on Database, 1979 by Fagin,
// Nievergelt, et.al.  This algorithm guarantees at most 2 page faults
// to locate a given key.
//
class CHashMap {

public:

    CHashMap();
    virtual ~CHashMap( );

	//
	// verify that a hash file isn't corrupted (fsck/chkdsk for hashmap
	// files).  this should be called before init
	//
	static BOOL VerifyHashFile(
				LPCSTR HashFileName,
				DWORD Signature,
				DWORD dwCheckFlags,
				DWORD *pdwErrorFlags,
				IKeyInterface*	pIKey,
				ISerialize	*pHashEntry);

	//
	//	Initialize the hash table but specify what cache to use !
	//
	BOOL	Initialize(
                IN LPCSTR HashFileName,
                IN DWORD Signature,
                IN DWORD MinimumFileSize,
				IN DWORD Fraction,
				IN CCACHEPTR	pCache,
				IN DWORD dwCheckFlags = HASH_VFLAG_PAGE_BASIC_CHECKS,
				IN HASH_FAILURE_PFN	HashFailurePfn = 0,
				IN LPVOID	lpvFailureCallback = 0,
				IN BOOL	fNoBuffering = FALSE
                );
    //
    // Initialize the hash table
	// this needs to be called before the hash table is used.
    //
    BOOL Initialize(
                IN LPCSTR HashFileName,
                IN DWORD Signature,
                IN DWORD MinimumFileSize,
				IN DWORD cPageEntry = 256,
				IN DWORD cNumLocks = 64,
				IN DWORD dwCheckFlags = HASH_VFLAG_PAGE_BASIC_CHECKS,
				IN HASH_FAILURE_PFN	HashFailurePfn = 0,
				IN LPVOID	lpvFailureCallback = 0,
				IN BOOL	fNoBuffering = FALSE
                );

	//
	// Lookup an entry
	//
	// helper functions for some of the non-obvious uses of this are below
	//
	BOOL LookupMapEntry(	const	IKeyInterface*	pIKey,
							ISerialize*		pHashEntry,
							BOOL			bDelete = FALSE,
							BOOL			fDirtyOnly = FALSE
							);

    //
    // Delete an entry
    //
    BOOL DeleteMapEntry(	const	IKeyInterface*	pIKey,
							BOOL	fDirtyOnly = FALSE ) {
		return LookupMapEntry(pIKey, 0, TRUE, fDirtyOnly);
	}

	//
	// Lookup and Delete and entry in one step
	//
	BOOL LookupAndDelete(	const	IKeyInterface*	pIKey,
							ISerialize	*pHashEntry) {
		return LookupMapEntry(pIKey, pHashEntry, TRUE);
	}

	//
	// See if the entry is here
	//
	BOOL Contains(	const	IKeyInterface*	pIKey ) {
		return LookupMapEntry(pIKey, 0, FALSE);
	}

	//
	// Insert or update a map entry
	//
	BOOL InsertOrUpdateMapEntry(const	IKeyInterface*	pIKey,
								const	ISerialize*		pHashEntry,
								BOOL bUpdate = FALSE,
                                BOOL fDirtyOnly = FALSE);

    //
	// Insert new entry
	//
	BOOL InsertMapEntry(const	IKeyInterface*	pIKey,
						const	ISerialize*		pHashEntry,
                        BOOL    fDirtyOnly = FALSE) {
		return InsertOrUpdateMapEntry(pIKey, pHashEntry, FALSE, fDirtyOnly);
	}

	//
	// Update Map Entry
	//
	BOOL UpdateMapEntry(const	IKeyInterface*	pIKey,
						const	ISerialize*		pHashEntry) {
		return InsertOrUpdateMapEntry(pIKey, pHashEntry, TRUE);
	}

	//
    // returns the current number of entries in the hash table
    //
    DWORD GetEntryCount() const { return(m_nEntries); }

	//
	// see if the hash table is active
	//
	inline BOOL IsActive() { return	m_active; }

	//
	// methods for walking the entries in the hashtable.  order should be
	// considered random.
	//
	BOOL
	GetFirstMapEntry(	IKeyInterface*	pIKey,
						DWORD&			cbKeyRequried,
						ISerialize*		pHashEntry,
						DWORD&			cbEntryRequried,
						CHashWalkContext *pHashWalkContext,
						IEnumInterface*	pEnum
						);

	//
	//	Get the next entry
	//
	BOOL
	GetNextMapEntry(	IKeyInterface*	pIKey,
						DWORD&			cbKeyRequried,
						ISerialize*		pHashEntry,
						DWORD&			cbEntryRequried,
						CHashWalkContext *pHashWalkContext,
						IEnumInterface	*pEnum
						);

	//
	//	Get the next entry in the next page
	//
	BOOL
	GetNextPageEntry(	IKeyInterface*	pIKey,
						DWORD&			cbKeyRequried,
						ISerialize*		pHashEntry,
						DWORD&			cbEntryRequried,
						CHashWalkContext *pHashWalkContext,
						IEnumInterface	*pEnum
						);


	//
	// make a backup copy of the hashmap suitable
	//
	BOOL MakeBackup(LPCSTR pszBackupFilename);

    //
    // CRCHash function (which is the default, but can be overridden by
	// overriding the Hash method below)
    //
    static DWORD CRCHash(IN const BYTE * Key, IN DWORD KeyLength);
	static void CRCInit(void);

protected :

    //
    // Close the hash table
    //
    virtual VOID Shutdown(BOOL	fLocksHeld = FALSE);

private:

	//
	//	Create the initial set of directory objects !!!
	//
	DWORD
	InitializeDirectories(
			WORD	cBitDepth
			) ;


	//
	// verify that the page structure is valid
	//
	static BOOL VerifyPage(	PMAP_PAGE Page,
							DWORD dwCheckFile,
							DWORD *pdwErrorFlags,
							IKeyInterface*	pIKey,
							ISerialize	*pHashEntry
							);

    //
    // Allocates and initialize the directory
    //

    DWORD I_BuildDirectory( BOOL SetupHashFile = TRUE );

    //
    // Cleans up the mapping
    //

    VOID I_DestroyPageMapping( VOID );

    //
    // Additional work that needs to be done by the derived class
    // for an entry during an insertion
    //
    virtual	VOID I_DoAuxInsertEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    )	{}

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //

    virtual VOID I_DoAuxDeleteEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    ) {}

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a page split
    //

    virtual VOID I_DoAuxPageSplit(
                    IN PMAP_PAGE OldPage,
                    IN PMAP_PAGE NewPage,
                    IN PVOID NewEntry
                    ) {}

    //
    // Find next available slot for an entry
    //

    DWORD I_FindNextAvail(
                    IN HASH_VALUE HashValue,
                    IN PMAP_PAGE MapPage
                    );

    //
    // Initializes a brand new hash file
    //

    DWORD I_InitializeHashFile( VOID );

    //
    // Initialize a new leaf
    //

    VOID I_InitializePage(
                IN PMAP_PAGE MapPage,
                IN DWORD HashPrefix,
                IN DWORD PageDepth
                );

    //
    // link the deleted entry to the delete list
    //

    VOID I_LinkDeletedEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD Offset
                    );


	//
	//	When re-loading a hash table, we need to increase our directory
	//	depth on the fly without grabbing any locks etc...
	//
	BOOL I_SetDirectoryDepthAndPointers(
					IN	PMAP_PAGE	MapPage,
					IN	DWORD	PageNum
					) ;

    //
    // Set up links for the given page
    //

    BOOL I_SetDirectoryPointers(
					IN HPAGELOCK&	hLock,
                    IN PMAP_PAGE MapPage,
                    IN DWORD PageNumber,
                    IN DWORD MaxDirEntries
                    );

    //
    // Open the hash file and set up file mappings
    //

    DWORD I_SetupHashFile( IN BOOL &NewTable );

	//
	//	Find a page we can use within the hash table.
	//
	DWORD	I_AllocatePageInFile(WORD Depth) ;

    //
    // loads/unloads the correct page view
    //

	inline
    PDWORD LoadDirectoryPointerShared(
        DWORD HashValue,
		HPAGELOCK&	hLock
        );

	inline
    PDWORD LoadDirectoryPointerExclusive(
        DWORD HashValue,
		HPAGELOCK&	hLock
        );

    //
    // Compare if reserved pages are same
    //
    BOOL CompareReservedPage( HASH_RESERVED_PAGE* page1, HASH_RESERVED_PAGE* page2 );

    //
    // Current depth of directory
    //

    WORD m_dirDepth;

	//
	// Number of bits we use to select a CDirectory object !
	//

	WORD m_TopDirDepth ;

    //
    // Initial depth of leaves
    //

    WORD m_initialPageDepth;

    //
    // Maximum number of entries per leaf page before we split
    //

    WORD m_pageEntryThreshold;

    //
    // Maximum number of bytes used before we split
    //

    WORD m_pageMemThreshold;

    //
    // Name of the hash file
    //

    CHAR m_hashFileName[MAX_PATH];

    //
    // handle to the hash file
    //

    HANDLE m_hFile;

	//
	//	Do we want to let NT do buffering of this file !
	//

	BOOL	m_fNoBuffering ;

    //
    // pages allocated
    //

    DWORD m_maxPages;

	//
	//	Long that we use to synchronize FlushHeaderStats() call -
	//	whoever InterlockExchange's and gets a 0 back should go
	//	ahead and assume they have the lock !
	//

	long	m_UpdateLock ;

	//
	//	Critical section for managing allocation of new pages
	//
	CRITICAL_SECTION	m_PageAllocator ;

	//
	//	Boolean to indicate whether we've had a critical
	//	failure in allocating memory, and will be unable
	//	to recover simply !
	//	ie.  If we fail a VirtualAlloc() call, then we set this to
	//	TRUE, as we will probably not recover.  However, if we have
	//	run out of Disk Space, we leave this as FALSE as we will
	//	probably be able to recover.
	//
	BOOL	m_fCriticalFailure ;

	//
	//	A pointer of a function to call in case of severe failures
	//	which will crimp the hash tables functionality.
	//
	HASH_FAILURE_PFN	m_HashFailurePfn ;

	//
	//	An opaque LPVOID we will pass to the m_HashFailurePfn when
	//	we call it.
	//
	LPVOID	m_lpvHashFailureCallback ;

    //
    // handle to file mapping
    //

    HANDLE m_hFileMapping;

    //
    // pointer to the reserved page
    //

    PHASH_RESERVED_PAGE m_headPage;

#if 0
    //
    // pointer to the hash file
    //

    //PMAP_PAGE m_hashPages;

	LPVOID	m_lpvBuffers ;
#endif


    //
    // Handle to the directory mapping
    //

    HANDLE m_hDirMap;

    //
    // Locks the directory
    //
	_RWLOCK	*m_dirLock;


	//
	//	Top level directory
	//

	// DWORD	*m_pTopDirectory ;

	//
	//	Array of CDirectory objects - used to find out what hash
	//	table pages have the data we want !
	//

	CDirectory	*m_pDirectory[(1<< MAX_NUM_TOP_DIR_BITS)] ;

	//
	//	Pointer to the Cache which holds all of our pages
	//
	CCACHEPTR	m_pPageCache ;

	//
	//	A power of 2 fraction which indicates what
	//	purportion of the cache pages we can occupy !
	//
	DWORD		m_Fraction ;

    //
    // Head page signature
    //

    DWORD m_HeadPageSignature;

    //
    // whether the hash table is active or not
    //

    BOOL m_active;

	//
	// methods for GetFirstMapEntry/GetNextMapEntry
	//
	BOOL LoadWalkPage(CHashWalkContext *pHashWalkContext);

	//
	// the flags to pass into VerifyPage when loading pages (0 disables
	// calling VerifyPage)
	//
	DWORD m_dwPageCheckFlags;

	//
	// Set to TRUE if we successfully returned from Initialize().  If this
	// occurs then on shutdown we should be able to save the Directory
	// structure
	//
	BOOL m_fCleanInitialize;

protected:

    //
    // Hash function
    //
    virtual DWORD Hash(IN LPBYTE Key, IN DWORD KeyLength);

    //
    // acquire directory lock
    //
    VOID AcquireBackupLockShared( );
    VOID AcquireBackupLockExclusive( );

    //
    // acquires the lock for the given directory entry index
    // returns a handle to the actual lock
    //

    PMAP_PAGE	AcquireLockSetShared(
					IN DWORD DirEntry,
					OUT HPAGELOCK&	lock,
					BOOL	fDropDirectory = FALSE
					);

    PMAP_PAGE	AcquireLockSetExclusive(
					IN DWORD DirEntry,
					OUT HPAGELOCK&	lock,
					BOOL	fDropDirectory = FALSE
					);

	//
	//	Add a secondary page to the pagelock !
	//
    BOOL		AddLockSetExclusive(
					IN DWORD DirEntry,
					OUT HPAGELOCK&	lock
					);


	BOOL
	AddPageExclusive(
                IN DWORD	PageNum,
                OUT HPAGELOCK& hLock
                ) ;

	//
	//	Get the page addresss,
	//	Get a shared lock on the directory AND
	//	an exclusive lock on the page !
	//
	PMAP_PAGE GetPageExclusive(
						IN	HASH_VALUE	HashValue,
						OUT	HPAGELOCK&	hLock
						) ;

    //
    // Get the page address and also get a shared lock
	//	on both the directory and page objects !
    //

    PMAP_PAGE GetDirAndPageShared(
                        IN HASH_VALUE HashValue,
                        OUT HPAGELOCK& hLock
                        );

	//
	//	Get the page address, an exclusive lock on the page
	//	and an exclusive lock on the directory !
	//
    PMAP_PAGE GetDirAndPageExclusive(
                        IN HASH_VALUE HashValue,
                        OUT HPAGELOCK& hLock
                        );

    //
    // Get the page address and also lock the directory and page
    // given the page number
    //

    PMAP_PAGE GetAndLockPageByNumber(
                                IN DWORD PageNumber,
                                OUT HPAGELOCK& hLock
                                );

	//
	//	Get the page address, and do not lock the directory, but
	//	do lock the page.  Caller must have directory lock already !
	//

	PMAP_PAGE GetAndLockPageByNumberNoDirLock(
					IN DWORD PageNumber,
					OUT HPAGELOCK& hLock
					) ;


    //
    // See if the next bit is one
    //

    BOOL I_NextBitIsOne( IN HASH_VALUE HashValue, IN DWORD PageDepth ) {
            return (BOOL)(HashValue & LeafMask[PageDepth]);
            }

    //
    // Releases the directory lock
    //
	VOID	ReleaseBackupLockShared( );
	VOID	ReleaseBackupLockExclusive();

    //
    // releases the lock
    //

#if 0
    VOID ReleaseLock( PMAP_PAGE	page, HPAGELOCK&	hLock ) {
                        hLock.ReleasePage( page ) ;
                        }
#endif

    //
    // releases both the page lock and the backup lock
    //

	inline	VOID
	ReleasePageShared(
					PMAP_PAGE	page,
					HPAGELOCK&	hLock
					)	;

	inline	VOID
	ReleasePageExclusive(
					PMAP_PAGE	page,
					HPAGELOCK&	hLock
					) ;

    //
    // Page compaction
    //

    BOOL CompactPage(
					IN	HPAGELOCK&	HLock,
					PMAP_PAGE Page
					);

    //
    // Expand hash file
    //

    BOOL ExpandHashFile(
            DWORD NumPagesToAdd = DEF_PAGE_INCREMENT
            );

    //
    // Expands the directory.  Directory will grow by
    // a multiple of 2**nBitsExpand.
    //

    BOOL ExpandDirectory(
			HPAGELOCK&	hPageLock,
            WORD nBitsExpand = DEF_DEPTH_INCREMENT
            );

    //
    // Find an existing entry
    //

    BOOL FindMapEntry(
                    IN const IKeyInterface*	pIKey,
                    IN HASH_VALUE HashValue,
                    IN PMAP_PAGE MapPage,
					IN const ISerialize* pIEntryInterface,
                    OUT PDWORD AvailIndex OPTIONAL,
                    OUT PDWORD MatchedIndex OPTIONAL
                    );

    //
    // Updates the header statistics
    //

    VOID FlushHeaderStats(
					BOOL	fLockHeld = FALSE
					);


	//
	// flush a page
	//
    BOOL FlushPage(
                    HPAGELOCK&  hLock,
					PVOID Base,
					BOOL	fDirtyOnly = FALSE
					);

	//
    // Get the remaining bytes in the system
    //

    DWORD GetBytesAvailable( PMAP_PAGE MapPage ) {
                return((DWORD)(MapPage->LastFree - MapPage->NextFree));
                }

    //
    // Given the hash value, get the index to the directory
    // NOTE: m_dirDepth must never be == 0 or else this computation
    // will not work.  It is initialized to 2 in the hash table so
    // can never be 0 by design.
    //

    DWORD GetDirIndex( HASH_VALUE HashValue ) {
                            return (HashValue >> (32 - m_dirDepth ));
                            }

    //
    // Get the leaf entry index
    //

    DWORD GetLeafEntryIndex( HASH_VALUE HashValue ) {
                            return (DWORD)(HashValue & LEAF_ENTRY_MASK);
                            }

    //
    // Increment global stats
    //

    VOID IncrementInsertCount( VOID ) {
                    InterlockedIncrement((PLONG)&m_nInsertions);
                    ++m_nEntries;}
    VOID IncrementDeleteCount( VOID ) {
                    InterlockedIncrement((PLONG)&m_nDeletions);
                    --m_nEntries;}

    VOID IncrementSearchCount( VOID ) { m_nSearches++; }
    VOID IncrementSplitCount( VOID ) { m_nPageSplits++; }
    VOID IncrementDirExpandCount( VOID ) { m_nDirExpansions++; }
    VOID IncrementTableExpandCount( VOID ) { m_nTableExpansions++; }
    VOID IncrementDupInsertCount( VOID ) { m_nDupInserts++; }

    //
    // link the deleted entry to the delete list
    //

    VOID LinkDeletedEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD Offset
                    );


    //
    // Allocate a deleted buffer, if possible
    //

    PVOID ReuseDeletedSpace(
                IN PMAP_PAGE MapPage,
				IN HPAGELOCK&	HLock,
                IN DWORD & NeededEntrySize
                );

    //
    // Sets a page flag bit
    //

    VOID SetPageFlag(
				PMAP_PAGE MapPage,
				HPAGELOCK&	HLock,
				WORD Mask
				) {
            MapPage->Flags |= (WORD)(Mask);
			FlushPage( HLock, MapPage ) ;
            }

    //
    // Splits a page
    //

    BOOL SplitPage(
            IN PMAP_PAGE Page,
			HPAGELOCK&	hLock,
            OUT BOOL & Expand
            );

	//
	// get the size of an entry
	//
	DWORD GetEntrySize(	const ISerialize*	pIKey,
						const ISerialize*	pHashEntry
						);

    //
    // **************************************************************
    // **************************************************************

    //
    // number of Map pages
    //

    DWORD m_nPagesUsed;

    //
    // number of insertions
    //

    DWORD m_nInsertions;

    //
    // number of deletions
    //

    DWORD m_nDeletions;

    //
    // number of entries in the hash table
    //

    DWORD m_nEntries;

    //
    // number of searches
    //

    DWORD m_nSearches;

    //
    // number of duplicate insertions
    //

    DWORD m_nDupInserts;

    //
    // number of pages plits
    //

    DWORD m_nPageSplits;

    //
    // number of times we had to expand the directory
    //

    DWORD m_nDirExpansions;

    //
    // number of times we had to remap the file
    //

    DWORD m_nTableExpansions;

}; // CHashMap


//
//	This class defines a hash table which uses LPSTR's as the
//	key !
//
class	CStringHashMap :	private	CHashMap	{
public :
	//
	// verify that a hash file isn't corrupted (fsck/chkdsk for hashmap
	// files).  this should be called before init
	//
	static BOOL VerifyHashFile(
				LPCSTR HashFileName,
				DWORD Signature,
				DWORD dwCheckFlags,
				DWORD *pdwErrorFlags,
				ISerialize	*pHashEntry)	{

		IStringKey	key ;

		return	CHashMap::VerifyHashFile(
					HashFileName,
					Signature,
					dwCheckFlags,
					pdwErrorFlags,
					&key,
					pHashEntry
					) ;
	}

    //
    // Initialize the hash table
	// this needs to be called before the hash table is used.
    //
    BOOL Initialize(
                IN LPCSTR HashFileName,
                IN DWORD Signature,
                IN DWORD MinimumFileSize,
				IN DWORD cPageEntry = 256,
				IN DWORD cNumLocks = 64,
				IN DWORD dwCheckFlags = HASH_VFLAG_PAGE_BASIC_CHECKS,
				IN HASH_FAILURE_PFN	HashFailurePfn = 0,
				IN LPVOID	lpvFailureCallback = 0
                )	{
		return	CHashMap::Initialize(
						HashFileName,
						Signature,
						MinimumFileSize,
						cPageEntry,
						cNumLocks,
						dwCheckFlags,
						HashFailurePfn,
						lpvFailureCallback
						) ;
	}

	//
	// Lookup an entry
	//
	// helper functions for some of the non-obvious uses of this are below
	//
	BOOL LookupMapEntry(LPBYTE Key,
						DWORD KeyLen,
						ISerialize	*pHashEntry,
						BOOL bDelete = FALSE)	{

		IStringKey	key( Key, KeyLen ) ;
		return	CHashMap::LookupMapEntry( &key, pHashEntry, bDelete ) ;
	}

    //
    // Delete an entry
    //
    BOOL DeleteMapEntry(LPBYTE Key, DWORD KeyLen) {
		return LookupMapEntry(Key, KeyLen, NULL, TRUE);
	}

	//
	// Lookup and Delete and entry in one step
	//
	BOOL LookupAndDelete(LPBYTE Key, DWORD KeyLen, ISerialize	*pHashEntry) {
		return LookupMapEntry(Key, KeyLen, pHashEntry, TRUE);
	}

	//
	// See if the entry is here
	//
	BOOL Contains(LPBYTE Key, DWORD KeyLen) {
		return LookupMapEntry(Key, KeyLen, NULL);
	}

	//
	// Insert or update a map entry
	//
	BOOL InsertOrUpdateMapEntry(LPBYTE Key, DWORD KeyLen, const ISerialize	*pHashEntry, BOOL bUpdate = FALSE)	{
		IStringKey	key( Key, KeyLen ) ;
		return	CHashMap::InsertOrUpdateMapEntry( &key, pHashEntry, bUpdate ) ;
	}

    //
	// Insert new entry
	//
	BOOL InsertMapEntry(LPBYTE Key, DWORD KeyLen, const ISerialize	*pHashEntry) {
		return InsertOrUpdateMapEntry(Key, KeyLen, pHashEntry, FALSE);
	}

	//
	// Update Map Entry
	//
	BOOL UpdateMapEntry(LPBYTE Key, DWORD KeyLen, const ISerialize	*pHashEntry) {
		return InsertOrUpdateMapEntry(Key, KeyLen, pHashEntry, TRUE);
	}

	//
    // returns the current number of entries in the hash table
    //
    DWORD GetEntryCount() const { return(m_nEntries); }

	//
	// see if the hash table is active
	//
	inline BOOL IsActive() { return	CHashMap::IsActive(); }

	//
	// methods for walking the entries in the hashtable.  order should be
	// considered random.
	//
	BOOL GetFirstMapEntry(	LPBYTE pKey,
							PDWORD pKeyLen,
							ISerialize	*pHashEntry,
							CHashWalkContext *pHashWalkContext)	{

		DWORD	cbData ;
		IStringKey	key( pKey, *pKeyLen ) ;
		BOOL	fReturn = CHashMap::GetFirstMapEntry(	&key,
														*pKeyLen,
														pHashEntry,
														cbData,
														pHashWalkContext,
														0
														) ;

		return	fReturn ;
	}

	BOOL GetNextMapEntry(	LPBYTE pKey,
							PDWORD pKeyLen,
							ISerialize	*pHashEntry,
							CHashWalkContext *pHashWalkContext)	{

		DWORD	cbData ;
		IStringKey	key( pKey, *pKeyLen ) ;
		BOOL	fReturn = CHashMap::GetNextMapEntry(	&key,
														*pKeyLen,
														pHashEntry,
														cbData,
														pHashWalkContext,
														0
														) ;

		return	fReturn ;


	}

	//
	// make a backup copy of the hashmap suitable
	//
	BOOL MakeBackup(LPCSTR pszBackupFilename)	{
		return	CHashMap::MakeBackup( pszBackupFilename ) ;
	}

} ;


//
//	This class defines a page cache that can be shared amongst hash tables !
//
//
class	CPageCache :	public	CRefCount	{
private :

	LPVOID			m_lpvBuffers ;

	//
	//	Number of PageLock objects we use to keep track of our cache.
	//
	DWORD			m_cPageEntry ;

	//
	//	Pointer to an array of PageEntry objects !
	//
	PageEntry*		m_pPageEntry ;

	//
	//	Track the number of locks we are using to sync access to the pages
	//
	DWORD			m_cpageLock ;

	//
	//	Pointer to the array of locks we are using !
	//
	_RWLOCK*		m_ppageLock ;

	//
	//	No copying of CPageCache objects !
	//
	CPageCache( CPageCache& ) ;
	CPageCache&	operator=( CPageCache& ) ;

public :

	CPageCache() ;
	~CPageCache() ;

	BOOL
	Initialize(		DWORD	cPageEntry = 0,
					DWORD	cLocks = 0
					) ;

	inline	PMAP_PAGE
	AcquireCachePageShared(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock,
					IN	BOOL	fDropDirectory
					) ;

	inline	PMAP_PAGE
	AcquireCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock,
					BOOL	fDropDirectory
					) ;


	inline	BOOL
	AddCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock
					) ;

    //
    // releases both the page lock and the backup lock
    //

	static	inline	VOID
	ReleasePageShared(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						) ;

	static	inline	VOID
	ReleasePageExclusive(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						) ;

	//
	//	Remove this file handle from the cache wherever it appears !
	//
	void
	FlushFileFromCache(
					IN	HANDLE	hFile
					) ;

} ;

DWORD
CalcNumPagesPerIO( DWORD nPages );


#include	"hashimp.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\reg_cbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       cbuffer.h
//
//  Contents:   CHAR buffer definitions
//
//  History:    02-16-93    SethuR -- Implemented
//              07-28-94    AlokS  -- Added more methods
//              12-09-97    MilanS -- Ported to Exchange
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef __CBUFFER_H__
#define __CBUFFER_H__

//+---------------------------------------------------------------------
//
// Class:   CCHARBuffer
//
// Purpose: A CHAR buffer
//
// History:
//
// Notes:   Very often we encounter the case in string manipulation wherein
//          the length of the string is less than some value most of the time
//          (99%). However, in order to reliably with the very rare case we
//          are forced to either allocate the string on the heap or alternatively
//          go through some bizarre code that avoids the heap allocation in the
//          common case. This class is an abstraction of a WCHAR buffer and its
//          implementation is an attempt at hiding the detail from all clients.
//
//          As it is designed it is an ideal candidate for a temporary buffer
//          for string manipulation.
//
//----------------------------------------------------------------------

#define MAX_CHAR_BUFFER_SIZE 260 // long enough to cover all path names

class CCHARBuffer
{
public:

    inline CCHARBuffer(ULONG cwBuffer = 0);
    inline ~CCHARBuffer();

    inline DWORD    Size();
    inline PCHAR   ReAlloc(DWORD cwBuffer = MAX_CHAR_BUFFER_SIZE);
    inline void     Set(PCHAR  pszFrom);

    inline      operator PCHAR ();
    inline      operator PCHAR () const;

    inline void operator  =(PCHAR  pszFrom)
    {
        Set(pszFrom);
    };

private:

    DWORD   _cBuffer;
    PCHAR   pchBuffer;    // buffer ptr;
    CHAR   _achBuffer[MAX_CHAR_BUFFER_SIZE];
};

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::CCHARBuffer, inline public
//
//  Synopsis:   Constructor
//
//  Arguments:  [cBuffer]   -- desired buffer length.
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::CCHARBuffer(ULONG cBuffer) :
                     pchBuffer(NULL),
                     _cBuffer(cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::~CCHARBuffer, inline public
//
//  Synopsis:   Destructor
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::~CCHARBuffer()
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Size, inline public
//
//  Synopsis:   Retrieve the size of the buffer
//
//  Returns:    the size of the buffer as a DWORD
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline DWORD CCHARBuffer::Size()
{
    return _cBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::ReAlloc, inline public
//
//  Synopsis:   Reallocates the buffer to accomdate the newly specified size
//
//  Arguments:  [cBuffer] -- the desired buffer size
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline PCHAR CCHARBuffer::ReAlloc(DWORD cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }

    if ((_cBuffer = cBuffer) > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
    else if (_cBuffer == 0)
    {
        pchBuffer = NULL;
    }

    return pchBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::operator PCHAR (), inline public
//
//  Synopsis:   casting operator to accomdate syntactic sugaring
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::operator PCHAR ()
{
    return (PCHAR)pchBuffer;
}

inline CCHARBuffer::operator PCHAR () const
{
    return (PCHAR)pchBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Set, inline public
//
//  Synopsis:   Copies the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pszFrom] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Set(PCHAR pszFrom)
{
    if (pszFrom==NULL)
    {
        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        _cBuffer=0;
        pchBuffer = NULL;
    }
    else if (*pszFrom)
    {
        DWORD len = strlen(pszFrom)+1;
        if ( len > _cBuffer)
        {
            (void)ReAlloc (len);
        }
        // Now copy
        if (pchBuffer != NULL)		// In case ReAlloc fails
        	memcpy(pchBuffer, pszFrom, len);
    }
    else
    {
        *pchBuffer=L'\0';
    }
    return;
}
#endif // __CBUFFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\refptr2.h ===
//
// This file contains another implementation of smart pointers.  It is 
// different from the implementation found in smartptr.h because the
// object itself deletes itself when its reference count hits 0.  This
// is similar to the way COM objects are written.
//
#ifndef _SMARTP2_H_
#define _SMARTP2_H_

#include <dbgtrace.h>

//
// A reference counting implementation
//
class CRefCount2 {
protected:
    LONG    m_cRefs;

public: 
    CRefCount2() {
		m_cRefs = 1;
	}
	virtual ~CRefCount2() {
	}

	LONG AddRef() {
    	return InterlockedIncrement(&m_cRefs);
	}
    void Release() {
    	LONG r = InterlockedDecrement(&m_cRefs);
		_ASSERT(r >= 0);
		if (r == 0) delete this;
	}
};

template<class Type> class CRefPtr2;

//
// This is a type of pointer which can be returned by functions.  The only
// valid operation on it is to copy it to a CRefPtr2<Type> pointer.  It 
// tells the CRefPtr2 not to do an AddRef.
//
template<class Type>
class CRefPtr2HasRef {
	protected:
		Type	*m_p;

		CRefPtr2HasRef<Type>& operator=(const CRefPtr2HasRef<Type>& rhs) {
			_ASSERT(FALSE);
			return *this;
		}

		BOOL operator==(CRefPtr2<Type>&rhs) {
			_ASSERT(FALSE);
			return m_p == rhs.m_p;
		}
	
		BOOL operator!=(CRefPtr2<Type>&rhs) {
			_ASSERT(FALSE);
			return m_p != rhs.m_p;
		}

	public:

		//
		//	Do nothing protected constructor !
		//
		CRefPtr2HasRef() : m_p( 0 )	{
		}
	
	    CRefPtr2HasRef(const Type *p ) :
			m_p( (Type*)p )		{
			if (m_p) m_p->AddRef();
		}

	    ~CRefPtr2HasRef() {
			// this pointer always needs to be copied to a CRefPtr2, which
			// should set m_p to NULL
			_ASSERT(m_p == NULL);
		}

		friend class CRefPtr2<Type>;
};

template<class	Type, BOOL	fAddRef>
class	CHasRef : public	CRefPtr2HasRef<Type>	{
public : 

	CHasRef(	const	Type*	p = 0 )	{
		m_p = (Type*)p ;
		if( fAddRef ) {
			if( m_p )
				m_p->AddRef() ;
		}
	}
} ;

template< class Type >
class   CRefPtr2 {
private: 
    Type*  m_p ; 

public : 
    CRefPtr2(const CRefPtr2<Type>& ref) {
		m_p = ref.m_p;
		if (m_p) m_p->AddRef();
	}

	// copy from an intermediate pointer -- we don't need to do an addref
	CRefPtr2(CRefPtr2HasRef<Type> &ref) {
		m_p = ref.m_p;
		ref.m_p = NULL;
	}

    CRefPtr2(const Type *p = 0) {
		m_p = (Type *) p;
		if (m_p) m_p->AddRef();
	}
    
    ~CRefPtr2() {
		if (m_p) m_p->Release();
	}

	CRefPtr2<Type>& operator=(const CRefPtr2<Type>& rhs) {
		if (m_p != rhs.m_p) {
			Type *pTemp = m_p;
			m_p = rhs.m_p;
			if (m_p) m_p->AddRef();
			if (pTemp) pTemp->Release();
		}
		return *this;
	}

	// copy from an intermediate pointer -- we don't need to do an addref
	CRefPtr2<Type>& operator=(CRefPtr2HasRef<Type>& rhs) {
		Type *pTemp = m_p;
		m_p = rhs.m_p;
		if (pTemp) pTemp->Release();
		rhs.m_p = NULL;
		return *this;
	}

	CRefPtr2<Type>& operator=(const Type *rhs) {
		if (m_p != rhs) {
			Type *pTemp = m_p;
			m_p = (Type *) rhs;
			if (m_p) m_p->AddRef();
			if (pTemp) pTemp->Release();
		}
		return *this;
	}

	BOOL operator==(CRefPtr2<Type>&rhs) {
		return m_p == rhs.m_p;
	}

	BOOL operator!=(CRefPtr2<Type>&rhs) {
		return m_p != rhs.m_p;
	}

	BOOL operator==(Type *p) {
		return	m_p == p;
	}

	BOOL operator!=(Type *p) {
		return	m_p != p;
	}

    Type *operator->() const {
    	return  m_p ;
	}

	operator Type*() const {
		return	m_p ;
	}

    BOOL operator!() const {
		return	!m_p ;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\phatqcat.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: phatqcat.h
//
// Contents: Categorizer related definitions used outside of phatq code
//
// History:
// jstamerj 1999/08/31 16:34:54: Created.
//
//-------------------------------------------------------------

//
// The guid for creating a CSMTPCategorizer object
//
DEFINE_GUID(CLSID_PhatQCat, 
0xad8a7977, 0xa7b8, 0x41ca, 0xbe, 0x5e, 0xf5, 0xa9, 0x5e, 0x64, 0x15, 0x51);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\refcount.inl ===
//
// refcount.inl
//
// This file implements the member functions of 
// CRefCount as defined in smartptr.h.  
// Refer to smartptr.h for all information.
//


//-------------------------------------------
//
//  Initialize the reference count to -1.  We Use -1 so 
//  that it will be possible to determine when the first reference
//  is made.
//  
inline
CRefCount::CRefCount( ) : m_refs( -1 ) { }

//-------------------------------------------
inline  LONG
CRefCount::AddRef( ) {
//
//  Add a reference to an object.
//
    return  InterlockedIncrement( &m_refs ) ;
}



//-------------------------------------------
inline  LONG
CRefCount::RemoveRef( ) {
//
//  Remove a Reference from an object.
//  When this function returns a negative number the object
//  should be destroyed.
//
    return  InterlockedDecrement( &m_refs ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\simssl2.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simssl.h

Abstract:

    This module contains class declarations/definitions for

        CEncryptCtx (some code stolen from internet server)

Revision History:

--*/

#ifndef _SIMSSL_H_
#define _SIMSSL_H_


class CEncryptCtx
{

private:

    //
    // is this the client side
    //

    BOOL                m_IsClient;

    //
    // indicates whether we are starting a new session
    //

    BOOL                m_IsNewSSLSession;

    //
    // should this session be encypted
    //

    BOOL                m_IsEncrypted;

    //
    // Handle to user's security context for encryption
    //

    CtxtHandle          m_hSealCtxt;

    //
    // Pointers to cached credential blocks
    //

    //
    //  Array of credential handles - Note this comes form the credential cache
    //  and should not be deleted.  m_phCredInUse is the pointer to the
    //  credential handle that is in use
    //

    PVOID               m_phCreds;

    CredHandle*         m_phCredInUse;
    DWORD               m_iCredInUse;

    //
    // ecryption header and trailer lengths
    //

    DWORD               m_cbSealHeaderSize;
    DWORD               m_cbSealTrailerSize;

    //
    // indicates whether we have context handles opened
    //

    BOOL                m_haveSSLCtxtHandle;

    //
    // Have we been authenticated ? we will consider an
    // SSL session to be authenticated, if we have a non-null
    // NT token.
    //

    BOOL                m_IsAuthenticated;

    //
    // SSL access perms - should we map client certs to NT accounts
    //

    DWORD               m_dwSslAccessPerms;

    //
    // NT token - non-NULL if client cert was mapped successfully
    //

    HANDLE              m_hSSPToken;

    //
    // Key size used - 40 bit vs 128 bit etc
    //

    DWORD               m_dwKeySize;
    
    //
    // Have we been authenticated, if so did we use the
    // anonymous token
    //

    static BOOL         m_IsSecureCapable;

    //
    // static variables used by all class instances
    //

    static WCHAR    wszServiceName[16];
#if 0
    static char szLsaPrefix[16];
#endif

    //
    // hSecurity - NULL when security.dll/secur32.dll  is not loaded
    //
    static HINSTANCE    m_hSecurity;

    //
    // hLsa - NULL for Win95, set for NT
    //
    static HINSTANCE    m_hLsa;

    //
    // shared context callback for instance mapper
    //
    static PVOID        m_psmcMapContext;
    
    //
    // internal routine to implement public Converse
    //

    DWORD EncryptConverse(
            IN PVOID        InBuffer,
            IN DWORD        InBufferSize,
            OUT LPBYTE      OutBuffer,
            OUT PDWORD      OutBufferSize,
            OUT PBOOL       MoreBlobsExpected,
            IN CredHandle*  pCredHandle,
            OUT PULONG      pcbExtra
            );

public:

    CEncryptCtx( BOOL IsClient = FALSE, DWORD dwSslAccessPerms = 0 );
    ~CEncryptCtx();

    //
    // routines used to initialize and terminate use of this class
    //

    static BOOL WINAPI Initialize(  LPSTR   pszServiceName,
                                    IMDCOM* pImdcom,
                                    PVOID   psmcMapContext = NULL,
                                    PVOID   pvAdminBase = NULL /*,
                            LPSTR pszLsaPrefix */ );

    static VOID WINAPI Terminate( VOID );

    //
    // routine to set the magic bits required by the IIS Admin tool
    //

    static void WINAPI GetAdminInfoEncryptCaps( PDWORD pdwEncCaps );

    //
    // returns whether sspi packages and credentials have been installed
    //

    static BOOL IsSecureCapable( void ) { return m_IsSecureCapable; }

    //
    // returns whether session is encrypted or not
    //

    BOOL IsEncrypted( void )            { return m_IsEncrypted; }

    //
    // returns whether session has successfully authenticated
    //

    BOOL IsAuthenticated( void )        { return m_IsAuthenticated; }

    //
    // returns key size used in SSL session
    //

    DWORD QueryKeySize()    { return m_dwKeySize; }
    
    //
    // Encryption routines
    //

    BOOL WINAPI SealMessage(
                    IN LPBYTE   Message,
                    IN DWORD    cbMessage,
                    OUT LPBYTE  pbuffOut,
                    OUT DWORD  *pcbBuffOut
                    );

    BOOL WINAPI UnsealMessage(
                    IN LPBYTE Message,
                    IN DWORD cbMessage,
                    OUT LPBYTE *DecryptedMessage,
                    OUT PDWORD DecryptedMessageSize,
                    OUT PDWORD ExpectedMessageSize,
                    OUT LPBYTE *NextSealMessage = NULL
                    );

    //
    // SSL specific routines.  This is used for processing SSL negotiation
    // packets.
    //

    DWORD WINAPI Converse(
            IN PVOID    InBuffer,
            IN DWORD    InBufferSize,
            OUT LPBYTE  OutBuffer,
            OUT PDWORD  OutBufferSize,
            OUT PBOOL   MoreBlobsExpected,
            IN LPSTR    LocalIpAddr,
            IN LPSTR    LocalPort,
            IN LPVOID   lpvInstance,
            IN DWORD    dwInstance,
            OUT PULONG  pcbExtra
            );

    //
    // resets the user name
    //

    void WINAPI Reset( void );

    //
    // returns the size of the encryption header for this session
    //
    DWORD GetSealHeaderSize( void )
        { return    m_haveSSLCtxtHandle ? m_cbSealHeaderSize : 0 ; }

    //
    // returns the size of the encryption trailer for this session
    //
    DWORD GetSealTrailerSize( void )
        { return    m_haveSSLCtxtHandle ? m_cbSealTrailerSize : 0 ; }

    //
    // return the NT token mapped from the client cert
    //

    HANDLE QueryCertificateToken() { return m_hSSPToken; }
    
    //
    // decrypts read buffer, concatenating all decrypted data at the
    // head of the buffer.
    //
    DWORD WINAPI DecryptInputBuffer(
                IN LPBYTE   pBuffer,
                IN DWORD    cbInBuffer,
                OUT DWORD*  pcbOutBuffer,
                OUT DWORD*  pcbParsable,
                OUT DWORD*  pcbExpected
            );

    //
    //  verifies the intended host name matches the name contained in the cert
    //  This function, checks a given hostname against the current certificate
    //  stored in an active SSPI Context Handle. If the certificate containts
    //  a common name, and it matches the passed in hostname, this function
    //  will return TRUE.
    //
    BOOL CheckCertificateCommonName(
                IN LPSTR pszHostName
            );

    BOOL CheckCertificateSubjectName(
                IN LPSTR pszHostName
            );
    //
    //  Check if the certificate is issued by a trusted authority
    //
    BOOL CheckCertificateTrust();

    //
    //  verifies the ccertificate has not expired
    //  returns TRUE if the cert is valid
    //
    BOOL CheckCertificateExpired(
                void
            );

    //
    //  check that a server cert is installed
    //

    BOOL CheckServerCert(
            IN LPSTR    LocalIpAddr,
            IN LPSTR    LocalPort,
            IN LPVOID   lpvInstance,
            IN DWORD    dwInstance);

}; // CSslCtx

//
// blkcred.cpp
//

#endif  // _SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\simauth2.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simauth.h

Abstract:

    This module contains class declarations/definitions for

        CSecurityCtx (some code stolen from internet server)

Revision History:

--*/

#ifndef _SIMAUTH_H_
#define _SIMAUTH_H_


//
// Authentication commands supported
//

typedef enum _AUTH_COMMAND {

    AuthCommandUser,
    AuthCommandPassword,
    AuthCommandReverse,
    AuthCommandTransact,
    AuthCommandInvalid

} AUTH_COMMAND;

//
// struct for each package
//

typedef struct _AUTH_BLOCK
{
    //
    // name of the package
    //
    LPSTR Name;

} AUTH_BLOCK, *PAUTH_BLOCK;


//
// Response IDs for the Converse function.  If the return
// value is anything other than SecNull, the application
// should map these IDs to that appropriate protocol specific
// response string.  If the value is SecNull, the application
// should send the returned data from Converse to the client
// with the appropriate header ( ie +OK ) and trailer ( ie \r\n )
//
typedef enum _REPLY_LIST {
    SecAuthOk,
    SecAuthOkAnon,
    SecProtOk,
    SecNeedPwd,
    SecBadCommand,
    SecSyntaxErr,
    SecPermissionDenied,
    SecNoUsername,
    SecInternalErr,
    SecAuthReq,
    SecProtNS,
    SecNull,
    NUM_SEC_REPLIES
} REPLY_LIST;

enum PKG_REPLY_FMT
{
    PkgFmtSpace,
    PkgFmtCrLf
};


//
// CSecurityContext - user security context class designed to work with any
//  ssp interface. The object have 2 sets of context handles - one for
//  authentication, and one for encrption.  If we are using only one package,
//  then these handles point to the same thing.  This is used to support
//  use of multi-ssp packages like Sicily over SSL.
//

class CSecurityCtx : public TCP_AUTHENT
{

private:

    //
    // Have we been authenticated, if so did we use the
    // anonymous token
    //

    BOOL                m_IsAuthenticated;
    BOOL                m_IsClearText;
    BOOL                m_IsAnonymous;
    BOOL                m_IsGuest;
    BOOL                m_fBase64;      // encoding flag

    static BOOL         m_AllowGuest;
    static BOOL         m_StartAnonymous;

    static HANDLE      m_hTokenAnonymous;

    //
    // storage for login name while waiting for the pswd
    //

    LPSTR               m_LoginName;

    //
    // storage for package name used
    //

    LPSTR               m_PackageName;

    DWORD               m_cProviderPackages;
    LPSTR               m_ProviderNames;
    PAUTH_BLOCK         m_ProviderPackages;

    //
    // Cleartext package name
    //

    char                m_szCleartextPackageName[MAX_PATH];
    char                m_szMembershipBrokerName[MAX_PATH];

    //
    // AUTHENT_INFO needed by k2
    //
    
    TCP_AUTHENT_INFO    m_TCPAuthentInfo;


    DWORD               m_dwInstanceAuthFlags;

    //
    // private member functions used to implement ProcessAuthInfo
    // after some amount of error and parameter checking
    //
    BOOL    ProcessUser(
                IN PIIS_SERVER_INSTANCE pIisInstance,
                IN LPSTR        pszUser,
                OUT REPLY_LIST* pReply
                );

    BOOL    ProcessPass(
                IN PIIS_SERVER_INSTANCE pIisInstance,
                IN LPSTR        pszPass,
                OUT REPLY_LIST* pReply
                );

    BOOL    ProcessTransact(
                IN PIIS_SERVER_INSTANCE pIisInstance,
                IN LPSTR        Blob,
                IN OUT LPBYTE   ReplyString,
                IN OUT PDWORD   ReplySize,
                OUT REPLY_LIST* pReply,
                IN DWORD        BlobLength
                );

    BOOL    MbsBasicLogon(
                IN LPSTR        pszUser,
                IN LPSTR        pszPass,
                OUT BOOL        *pfAsGuest,
                OUT BOOL        *pfAsAnonymous
                );


public:

    CSecurityCtx(
            PIIS_SERVER_INSTANCE pIisInstance,
            DWORD AuthFlags = TCPAUTH_SERVER|TCPAUTH_UUENCODE,
            DWORD InstanceAuthFlags = INET_INFO_AUTH_ANONYMOUS,
            TCP_AUTHENT_INFO *pTcpAuthInfo = NULL
            );

    ~CSecurityCtx();

    //
    // routines used to initialize and terminate use of this class
    //
    static BOOL Initialize(
                        BOOL                    fAllowGuest = TRUE,
                        BOOL                    fStartAnonymous = TRUE
                        );

    static VOID Terminate( VOID );

    BOOL SetInstanceAuthPackageNames(
        DWORD cProviderPackages,
        LPSTR ProviderNames,
        PAUTH_BLOCK ProviderPackages);

    BOOL GetInstanceAuthPackageNames(
        OUT LPBYTE          ReplyString,
        IN OUT PDWORD       ReplySize,
        IN PKG_REPLY_FMT    PkgFmt = PkgFmtSpace);

    //
    // Returns the login name of the user
    //

    LPSTR QueryUserName(void)   { return    m_LoginName; }

    //
    // returns whether session has successfully authenticated
    //

    BOOL IsAuthenticated( void )    { return m_IsAuthenticated; }

    //
    // returns whether session was a clear text logon
    //

    BOOL IsClearText( void )        { return m_IsClearText; }

    //
    // returns whether session logged on as Guest
    //

    BOOL IsGuest( void )            { return m_IsGuest; }

    //
    // returns whether session logged on Anonymously
    //

    BOOL IsAnonymous( void )        { return m_IsAnonymous; }

    //
    // Methods for determining whether MBS should be used
    //

    BOOL ShouldUseMbs( void );

    //
    // Method to set the cleartext package name of the current security context
    //
    VOID    SetCleartextPackageName(
                LPSTR           szCleartextPackageName, 
                LPSTR           szMembershipBrokerName
                );

    //
    // resets the user name
    //

    void Reset( void );

    // override base class. Use m_hTokenAnonymous if it's NNTP Anon. Otherwise call base class.
    HANDLE QueryImpersonationToken( VOID );
    //
    // set the supported SSPI packages
    // Parameter is the same format as returned by RegQueryValueEx for
    // REG_MULTI_SZ values
    //

    static BOOL SetAuthPackageNames(
            IN LPSTR            lpMultiSzProviders,
            IN DWORD            cchMultiSzProviders
            );

    //
    // different than set in that the packages are returned separated
    // by spaces and only a single terminating NULL.  This is done to 
    // make the response to the client easier to format
    //
    static BOOL GetAuthPackageNames(
            OUT LPBYTE          ReplyString,
            IN OUT PDWORD       ReplySize,
            IN PKG_REPLY_FMT    PkgFmt = PkgFmtSpace
            );

    //
    // Service Principal Name routines for Kerberos authentication. 
    //
    // A SPN is a name for a server that a client and server can independantly 
    // compute (ie, compute it without communicating with each other). Only 
    // then is mutual auth possible. 
    //
    // Here, we take the approach of using the stringized IP addrs returned by
    // doing a gethostbyname on the FQDN as the identifying part of SPNs. 
    // Since the clients connecting to this server know which IP they are using,
    // they too can indepedently generate the SPN.
    //
    // So, the usage of the methods below is:
    //
    // 1. On service startup, call ResetServicePrincipalNames.
    //      This cleans up all SPNs for the service registered on the local
    //      computer account.
    //
    // 2. On each virtual server startup, call RegisterServicePrincipalNames
    //      with the FQDN of that virtual server. This causes new SPNs to be
    //      registered on the local computer account.
    //
    // 3. When acting as a client (eg, SMTP outbound), call 
    //    SetTargetPrincipalName, passing in the IP address of the remote server
    //
    // 4. If desired, one may call ResetServicePrincipalNames on service 
    //    (NOT virtual server!) shutdown. This will unregister the SPNs for all
    //    virtual servers of that type.
    //
    // In all cases, szServiceClass is a service specific string, like "SMTP"
    //

    static BOOL ResetServicePrincipalNames(
            IN LPCSTR           szServiceType);

    static BOOL RegisterServicePrincipalNames(
            IN LPCSTR           szServiceType,
            IN LPCSTR           szFQDN);

    BOOL SetTargetPrincipalName(
            IN LPCSTR           szServiceType,
            IN LPCSTR           szTargetIP);

    // 
    // external interface for initiating a client-side AUTH protocol exchange.
    // You should use this instead of TCP_AUTHENT::Converse or 
    // TCP_AUTHENT::ConverseEx because it gives this object a chance to map
    // Internet security protocol names to NT package names (eg, from GSSAPI to
    // Negotiate)
    //
    BOOL ClientConverse( 
            IN VOID *           pBuffIn,
            IN DWORD            cbBuffIn,
            OUT BUFFER *        pbuffOut,
            OUT DWORD *         pcbBuffOut,
            OUT BOOL *          pfNeedMoreData,
            IN PTCP_AUTHENT_INFO pTAI,
            IN CHAR *           pszPackage  = NULL,
            IN CHAR *           pszUser     = NULL,
            IN CHAR *           pszPassword = NULL,
            IN PIIS_SERVER_INSTANCE psi = NULL );

    
    //
    // external interface for passing blobs received as part of AUTHINFO
    // or AUTH processing
    //
    BOOL ProcessAuthInfo(
            IN PIIS_SERVER_INSTANCE pIisInstance,
            IN AUTH_COMMAND     Command,
            IN LPSTR            Blob,
            IN OUT LPBYTE       ReplyString,
            IN OUT PDWORD       ReplySize,
            OUT REPLY_LIST*     pReplyListID,
            IN OPTIONAL DWORD   BlobLength = 0
            );


}; // CSecurityCtx


#endif  // _SIMAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\registry.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.h
//
//  Contents:   Definitions of classes for manipulating registry entries.
//
//  Classes:    CMyRegKey     - class for registry key objects
//              CRegValue   - base class for registry value objects
//              CRegSZ      - derived class for registry string values
//              CRegDWORD   - derived class for registry dword values
//              CRegBINARY  - derived class for registry binary values
//              CRegMSZ     - derived class for registry multi-string values
//
//  History:    09/30/92    Rickhi  Created
//
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it lightweight for normal set/get
//                                  operations. Threw out all exception code
//
//              12/09/97    Milans  Ported it over to Exchange
//
//  Notes:      CMyRegKey can use another CMyRegKey as a parent, so you can
//              build a tree of keys.  To kick things off, you can give one
//              of the default registry keys like HKEY_CURRENT_USER. When
//              you do this, the GetParent method returns NULL.  Currently
//              however, no ptrs are kept to child and sibling keys.
//
//              CRegValue is a base class for dealing with registry values.
//              The other classes (except CMyRegKey) are for dealing with a
//              specific type of registry value in the native data format.
//              For example, CRegDWORD lets you call methods just providing
//              a dword.  The methods take care of figuring out the size and
//              casting the dword to a ptr to bytes, etc for use in the Win32
//              registry APIs.
//
//              For any registry type not defined here, you can always resort
//              to using the CRegValue base class directly, though you then
//              must call GetValue or SetValue methods explicitly.
//
//              Sample Usage:
//
//                  The following reads the username in the ValueID UserName
//                  within the key HKEY_CURRENT_USER\LogonInfo. It then changes
//                  it to Rickhi.  It also sets the password valueid in the
//                  the same key to foobar.
//
//                  #include    <registry.h>
//
//                  //  open the registry key
//                  CMyRegKey rkLogInfo(HKEY_CURRENT_USER, L"LogonInfo");
//
//                  //  read the user name
//                  LPSTR  pszUserName;
//                  CRegSZ rszUserName(&rkLogInfo, "UserName", pszUserName);
//                  rszUserName.SetString("Rickhi");
//
//                  //  set the password
//                  CRegSZ rszPassWord(&rkLogInfo, "PassWord", "foobar");
//
//----------------------------------------------------------------------------

#ifndef __REGISTRY_H__
#define __REGISTRY_H__

#include "reg_cbuffer.h"

//  to simplify error creation
#define Creg_ERROR(x) (x)

//  forward declarations for use in the following structures
class   CRegValue;
class   CMyRegKey;

//  structure for enumerating subkeys of a key
typedef struct _SRegKeySet
{
        ULONG       cKeys;
        CMyRegKey     *aprkKey[1];
} SRegKeySet;

//  structure for enumerating values within a key
typedef struct _SRegValueSet
{
        ULONG       cValues;
        CRegValue   *aprvValue[1];
} SRegValueSet;

//  structure for dealing with multi-string values
typedef struct _SMultiStringSet
{
        ULONG       cStrings;
        LPSTR      apszString[1];
} SMultiStringSet;


//+-------------------------------------------------------------------------
//
//  Class:      CMyRegKey
//
//  Purpose:    class for abstracting Registry Keys
//
//  Interface:  CMyRegKey         - constructor for a registry key object
//              ~CMyRegKey        - destructor for a registry key object
//              GetParentHandle - returns parent key's handle
//              GetHandle       - returns this key's handle
//              GetName         - returns key path
//              Delete          - deletes the key from the registry
//              EnumValues      - enumerate values stored in the key
//              EnumKeys        - enumerates subkeys of the key
//              NotifyChange    - sets up change notification for the key
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CMyRegKey
{
public:
        //  constructor using HKEY for parent
        //  Mode: Create key if not present
        CMyRegKey(HKEY     hkParent,
                LPCSTR   pszPath,

                //  remaining parameters are optional
                      REGSAM      samDesiredAccess = KEY_ALL_ACCESS,
                LPCSTR      pszClass = NULL,
                      DWORD       dwOptions = REG_OPTION_NON_VOLATILE,
                      DWORD       *pdwDisposition = NULL,
                const LPSECURITY_ATTRIBUTES pSecurityAttributes = NULL
                );
        //  constructor using CMyRegKey as parent
        //  Mode: Create key if not present
        CMyRegKey(const CMyRegKey&    crkParent,
                LPCSTR      pszPath,
               //  remaining parameters are optional
                REGSAM      samDesiredAccess = KEY_ALL_ACCESS,
                LPCSTR      pszClass = NULL,
                DWORD       dwOptions = REG_OPTION_NON_VOLATILE,
                DWORD       *pdwDisposition = NULL,
                const LPSECURITY_ATTRIBUTES pSecurityAttributes = NULL
               );

        // Constructor using HKEY for parent
        // Mode: Simply Open the key, if exists
        CMyRegKey (HKEY    hkParent,
                 DWORD   *pdwErr,
                 LPCSTR  pszPath,
                 REGSAM  samDesiredAccess = KEY_ALL_ACCESS
               );

        // Constructor using CMyRegKey as parent
        // Mode: Simply open the key, if exists
        CMyRegKey  (const  CMyRegKey& crkParent,
                  DWORD    *pdwErr,
                  LPCSTR   pszPath,
                  REGSAM   samDesiredAccess = KEY_ALL_ACCESS
                );
        // Destructor - Closes registry key
        ~CMyRegKey(void);

        HKEY        GetHandle(void) const;
        LPCSTR GetName(void) const;
        DWORD     Delete(void);
        DWORD     EnumValues(SRegValueSet **pprvs);
        DWORD     EnumKeys(SRegKeySet **pprks);

        // This method can be called to determine if
        // Object is in sane state or not
        DWORD     QueryErrorStatus () const { return _dwErr ; }

        // Static routine which frees memory allocated during EnumValues/Keys
    static void         MemFree ( void * pv )
    {

        delete [] (BYTE*)pv;
    }

private:
        DWORD        CreateKey(HKEY      hkParent,
                               LPCSTR    pszPath,
                               REGSAM    samDesiredAccess,
                               LPCSTR    pszClass,
                               DWORD     dwOptions,
                               DWORD     *pdwDisposition,
                               const LPSECURITY_ATTRIBUTES pSecurityAttributes
                              );

        DWORD        OpenKey  (HKEY      hkParent,
                               LPCSTR      pszPath,
                               REGSAM    samDesiredAccess
                              );

        HKEY         _hkParent;      //  Handle to parent
        HKEY         _hkThis;        //  handle for this key
        CCHARBuffer _cszName;        // Buffer containing the registry path
                                     //  path from parent key to this key
        DWORD      _dwErr;           // Internal error status
};

inline HKEY CMyRegKey::GetHandle(void) const
{
    return _hkThis;
}

inline LPCSTR CMyRegKey::GetName(void) const
{
    return (LPCSTR) (LPSTR)_cszName;
}


//+-------------------------------------------------------------------------
//
//  Class:      CRegValue
//
//  Purpose:    base class for abstracting Registry Values
//
//  Interface:  CRegValue       - constructor for value
//              ~CRegValue      - destructor for value
//              GetKeyHandle    - returns handle for parent key
//              GetValueID      - returns the ValueID name
//              GetTypeCode     - returns the TypeCode of the data
//              GetValue        - returns the data associated with the value
//              SetValue        - sets the data associated with the value
//              Delete          - deletes the value from the registry
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92    Rickhi      Created
//
//  Notes:      This is a base class from which more specific classes are
//              derived for each of the different registry value types.
//
//--------------------------------------------------------------------------

class CRegValue
{
public:
                    CRegValue(const CMyRegKey& crkParentKey,
                              LPCSTR   pszValueID);
                    ~CRegValue(void){;};

    HKEY            GetParentHandle(void) const;
    LPCSTR    GetValueID(void)   const;

    // Caller supplies buffer
    DWORD         GetValue(LPBYTE pbData,   ULONG *pcbData, DWORD *pdwTypeCode);

    DWORD         SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode);
    virtual DWORD QueryErrorStatus (void) const { return _dwErr ; }

private:
    CCHARBuffer      _cszValueID;
    HKEY             _hkParent;
    DWORD          _dwErr ;
};

//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::CRegValue
//
//  Purpose:    constructor for base registry value
//
//  Arguments:  [prkParent] - ptr to parent CMyRegKey for the key
//              [pszValueID] - the valueID name for the value
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

inline  CRegValue::CRegValue(const CMyRegKey&  crkParent,
                             LPCSTR  pszValueID)
                        :   _hkParent (crkParent.GetHandle()),
                            _dwErr(crkParent.QueryErrorStatus())
{
        _cszValueID.Set((PCHAR) pszValueID);
}

inline HKEY CRegValue::GetParentHandle(void) const
{
        return _hkParent;
}

inline LPCSTR CRegValue::GetValueID(void) const
{
        return (LPCSTR) (LPSTR) _cszValueID;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegSZ
//
//  Purpose:    Derived class for abstracting Registry string Values
//
//  Interface:  CRegSZ      - constructor for registry value using string
//              ~CRegSZ     - destructor for registry string object
//              GetString   - returns the string
//              SetString   - sets a new string value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------
class CRegSZ : public CRegValue
{
public:
        //  create/write value constructor
        CRegSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID,
               LPCSTR  pszData
          );

        //  io-less constructor - used by enumerator
        CRegSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID
          );

        ~CRegSZ(void){;};

        DWORD         SetString(LPCSTR pszData);

        // Caller supplies buffer (supply the buffer size in bytes)
        DWORD         GetString(      LPSTR pszData, ULONG *pcbData);

        DWORD           GetTypeCode(void);

        DWORD         QueryErrorStatus(void) const { return _dwErr ; }

private:
        DWORD     _dwErr;

};

//+-------------------------------------------------------------------------
//
//  Member:     CRegSZ::CRegSZ
//
//  Purpose:    Constructor for registry string value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------
inline CRegSZ::CRegSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID,
                      LPCSTR    pszData)
    : CRegValue(crkParent, pszValueID)
{
    if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
        _dwErr = SetString(pszData);
}

inline CRegSZ::CRegSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID)
    : CRegValue(crkParent, pszValueID)
{
    //  automatic actions in header are sufficient
    _dwErr = CRegValue::QueryErrorStatus();
}

inline DWORD CRegSZ::SetString(LPCSTR pszData)
{
    return SetValue((LPBYTE)pszData, (strlen(pszData)+1), REG_SZ);
}

inline DWORD CRegSZ::GetString(LPSTR pszData, ULONG* pcbData)
{
    DWORD   dwTypeCode;

    return GetValue((LPBYTE)pszData, pcbData, &dwTypeCode);
}

inline DWORD CRegSZ::GetTypeCode(void)
{
    return  REG_SZ;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegMSZ
//
//  Purpose:    Derived class for abstracting Registry multi-string Values
//
//  Interface:  CRegMSZ      - constructor for registry value using string
//              ~CRegMSZ     - destructor for registry string object
//              GetString   -  returns the string
//              SetString   -  sets a new string value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------
class CRegMSZ : public CRegValue
{
public:
        //  create/write value constructor
        CRegMSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID,
               LPCSTR  pszData
          );

        //  io-less constructor - used by enumerator
        CRegMSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID
          );

        ~CRegMSZ(void){;};

        DWORD         SetString(LPCSTR pszData);

        // Caller supplies buffer (supply the buffer size in bytes)
        DWORD         GetString(      LPSTR pszData, ULONG *pcbData);

        DWORD           GetTypeCode(void);

        DWORD         QueryErrorStatus(void) const { return _dwErr ; }

private:
        DWORD     _dwErr;

};

//+-------------------------------------------------------------------------
//
//  Member:     CRegMSZ::CRegMSZ
//
//  Purpose:    Constructor for registry string value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------
inline CRegMSZ::CRegMSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID,
                      LPCSTR    pszData)
    : CRegValue(crkParent, pszValueID)
{
    if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
        _dwErr = SetString(pszData);
}

inline CRegMSZ::CRegMSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID)
    : CRegValue(crkParent, pszValueID)
{
    //  automatic actions in header are sufficient
    _dwErr = CRegValue::QueryErrorStatus();
}

inline DWORD CRegMSZ::SetString(LPCSTR pszData)
{
    DWORD   cLen, cbData;
    LPCSTR  pszNextString;

    for (pszNextString = pszData, cbData = 0;
            *pszNextString != '\0';
                pszNextString += cLen) {
         cLen = strlen(pszNextString) + 1;
         cbData += cLen;
    }
    cbData += sizeof('\0');

    return SetValue((LPBYTE)pszData, cbData, REG_MULTI_SZ);
}

inline DWORD CRegMSZ::GetString(LPSTR pszData, ULONG* pcbData)
{
    DWORD   dwTypeCode;

    return GetValue((LPBYTE)pszData, pcbData, &dwTypeCode);
}

inline DWORD CRegMSZ::GetTypeCode(void)
{
    return  REG_MULTI_SZ;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegDWORD
//
//  Purpose:    Derived class for abstracting Registry dword Values
//
//  Interface:  CRegDWORD   - constructor for registry value using dword
//              ~CRegDWORD  - destructor for registry dword object
//              GetDword    - returns the dword
//              SetDword    - sets a new dword value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------

class CRegDWORD : public CRegValue
{
public:
        //  create/write value constructor
        CRegDWORD(const CMyRegKey &crkParent,
                  LPCSTR  pszValueID,
                        DWORD   dwData);

        //  open/read value constructor
        CRegDWORD(const CMyRegKey &crkParent,
                  LPCSTR  pszValueID,
                        DWORD   *pdwData);

        //  io-less constructor - used by enumerator
        CRegDWORD( const CMyRegKey &crkParent,
                   LPCSTR  pszValueID);

        ~CRegDWORD(void){;};


        DWORD         SetDword(DWORD dwData);
        DWORD         GetDword(DWORD *pdwData);
        DWORD           GetTypeCode(void) ;
        DWORD         QueryErrorStatus(void) const { return _dwErr ; }

private:
        DWORD     _dwErr;
};

//+-------------------------------------------------------------------------
//
//  Member:     CRegDWORD::CRegDWORD
//
//  Purpose:    Constructor for registry dword value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

inline CRegDWORD::CRegDWORD(const CMyRegKey &crkParent,
                            LPCSTR  pszValueID,
                                  DWORD   dwData)
    : CRegValue(crkParent, pszValueID)
{

        if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
                _dwErr = SetDword(dwData);
}


inline CRegDWORD::CRegDWORD(const CMyRegKey &crkParent,
                            LPCSTR  pszValueID,
                                  DWORD   *pdwData)
    : CRegValue(crkParent, pszValueID)
{

        if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
                _dwErr = GetDword(pdwData);
}

inline CRegDWORD::CRegDWORD(const CMyRegKey &crkParent,
                            LPCSTR  pszValueID)
    : CRegValue(crkParent, pszValueID)
{
        //  automatic actions in header are sufficient
        _dwErr = CRegValue::QueryErrorStatus();
}

inline DWORD CRegDWORD::GetDword(DWORD *pdwData)
{
        DWORD   dwTypeCode;
        DWORD   dwErr;
        ULONG   cbData= sizeof(DWORD);
        dwErr = GetValue((LPBYTE)pdwData, &cbData, &dwTypeCode);
        return (dwErr);
}


inline DWORD CRegDWORD::SetDword(DWORD dwData)
{
        return SetValue((LPBYTE)&dwData, sizeof(DWORD), REG_DWORD);
}

inline DWORD CRegDWORD::GetTypeCode(void)
{
        return  REG_DWORD;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegBINARY
//
//  Purpose:    Derived class for abstracting Registry binary Values
//
//  Interface:  CRegBINARY  - constructor for registry value using binary data
//              ~CRegBINARY - destructor for registry binary data object
//              GetBinary   - returns the binary data
//              SetBinary   - sets a new binary data value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------

class CRegBINARY : public CRegValue
{
public:
        //  create/write value constructor
        CRegBINARY(const CMyRegKey &crkParent,
                   LPCSTR  pszValueID,
                   const LPBYTE  pbData,
                         ULONG   cbData);

        //  io-less constructor - used by enumerator
        CRegBINARY(const CMyRegKey &crkParent,
                   LPCSTR  pszValueID);

        ~CRegBINARY(void){;};

        DWORD         SetBinary(const LPBYTE pbData, ULONG cbData);

        // Caller supplies buffer (supply the buffer size in bytes)
        DWORD         GetBinary(LPBYTE pbData, ULONG *pcbData);

        DWORD           GetTypeCode(void);
        DWORD         QueryErrorStatus(void) { return _dwErr ; }

private:
        DWORD     _dwErr;

};

//+-------------------------------------------------------------------------
//
//  Member:     CRegBINARY::CRegBINARY
//
//  Purpose:    Constructor for registry binary value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------


inline CRegBINARY::CRegBINARY(const CMyRegKey   &crkParent,
                              LPCSTR    pszValueID,
                              const LPBYTE    pbData,
                                    ULONG     cbData)
    : CRegValue(crkParent, pszValueID)
{

    if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
        _dwErr = SetBinary(pbData, cbData);
}

inline CRegBINARY::CRegBINARY(const CMyRegKey   &crkParent,
                              LPCSTR    pszValueID)
    : CRegValue(crkParent, pszValueID)
{
        //  automatic actions in header are sufficient
        _dwErr = CRegValue::QueryErrorStatus();
}


inline DWORD CRegBINARY::SetBinary(const LPBYTE pbData, ULONG cbData)
{
        return SetValue(pbData, cbData, REG_BINARY);
}

inline DWORD CRegBINARY::GetBinary(LPBYTE pbData, ULONG* pcbData)
{
        DWORD   dwTypeCode;
        return  GetValue(pbData, pcbData, &dwTypeCode);
}
inline DWORD CRegBINARY::GetTypeCode(void)
{
        return  REG_BINARY;
}

//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    This function can be used to deleting a key and all it's
//              children.
//
//  History:    09/30/93  AlokS        Created
//
//  Notes:      We assume that caller has proper access priviledge
//              and the key is non-volatile.
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPSTR lpszKeyPath);

#endif   // __REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\smartptr.h ===
//
// smartptr.h
//
//  This file contains stuff for implementing reference counting smart 
//  pointers.
//
// Implementation Schedule for all classes defined by this file : 
//
// 0.5 week.
//
// Unit Test Schedule for all classes defined by this file : 
//
// 0.5 week.
//  Unit Testing will consist of the following : 
//  Define a class derived from CRefCount.  On one thread 
//  create this object and place it into a smart pointer.
//  Pass a copy of the smart pointer to several other threads.
//  These threads should wait a random interval - print the contents
//  of the object and then destroy their smart pointer.
//
//  The test should insure that : 
//  All Memory is freed.
//  The objects are not prematurely destroyed by the smart pointers.
//  
// 


#ifndef _SMARTPTR_H_
#define _SMARTPTR_H_

#ifndef	Assert
#define	Assert	_ASSERT
#endif



//------------------------------------------------------------------
class   CRefCount    {
//
// This class contains a long which is used to count references to an 
// object.  This class is designed to work with the CRefPtr template
// that follows within this file.  
//
// Users of this class should publicly derive from the class 
// (ie :  'class CNewsGroup : public CRefCount {'.
// Once this is done, the derived object can be reference counted.
// The functions AddRef() and RemoveRef() are used to add and remove
// reference counts, using InterlockedIncrement and InterlockedDecrement.
// If RemoveRef returns a negative value the object no longer has 
// any references.
//
//  Objects derived from this should have Init() functions.
//  All initialization of the object should be done through these 
//  Init() functions, the constructor should do minimal work.
//
//  This allows the creation of a smart pointer to allocate the 
//  memory for the object.  The object is then initialized by calling
//  through the smart pointer into the Init() function.
//
public : 
    LONG    m_refs ;

    inline  CRefCount( ) ;
    inline  LONG    AddRef( ) ;
    inline  LONG    RemoveRef( ) ;
} ;

//
// refcount.inl contains all of the actual implementation of this class.
//
#include    "refcount.inl" 

//------------------------------------------------------------------
template< class Type >
class   CRefPtr {
//
// This template is used to build reference counting pointers to 
// an object.  The object should be a class derived from CRefCount.
// The cost of using these smart pointers is 1 DWORD for the smart pointer
// itself, and 1 DWORD in the pointed to object to contain the reference 
// count.
//
// These Smart Pointers will do the following : 
// On Creation the smart pointer will add a reference to the pointed to object.
// On Assignment 'operator=' the smart pointer will check for assignment
// to self, if this is not the case it will remove a reference from the 
// pointed to object and destroy it if necessary.  It will then point 
// itself to the assigned object and add a reference to it.
// On Destruction the smart pointer will remove a reference from the 
// pointed to object, and if necessary delete it.
//
private: 
    Type*  m_p ; 

    //CRefPtr( ) ;
public : 

    inline  CRefPtr( const CRefPtr< Type >& ) ;
    inline  CRefPtr( const Type *p = 0 ) ;
    
    inline  ~CRefPtr( ) ;

	inline	CRefPtr<Type>&	operator=( const	CRefPtr<Type>& ) ;
	inline	CRefPtr<Type>&	operator=( const	Type	* ) ;
	inline	BOOL			operator==( CRefPtr<Type>& ) ;
	inline	BOOL			operator!=( CRefPtr<Type>& ) ;
	inline	BOOL			operator==( Type* ) ;
	inline	BOOL			operator!=( Type* ) ;
    inline  Type*   operator->() const ;
	inline	operator Type*  () const ;
    inline  BOOL    operator!() const ;
	inline	Type*			Release() ;
	inline	Type*			Replace( Type * ) ;
} ;

//------------------------------------------------------------------
template< class Type >
class   CSmartPtr {
//
// This template is used to build reference counting pointers to 
// an object.  The object should be a class derived from CRefCount.
// The cost of using these smart pointers is 1 DWORD for the smart pointer
// itself, and 1 DWORD in the pointed to object to contain the reference 
// count.
//
// These Smart Pointers will do the following : 
// On Creation the smart pointer will add a reference to the pointed to object.
// On Assignment 'operator=' the smart pointer will check for assignment
// to self, if this is not the case it will remove a reference from the 
// pointed to object and destroy it if necessary.  It will then point 
// itself to the assigned object and add a reference to it.
// On Destruction the smart pointer will remove a reference from the 
// pointed to object, and if necessary delete it.
//
private: 
    Type*  m_p ; 

public : 

    inline  CSmartPtr( const CSmartPtr< Type >& ) ;
    inline  CSmartPtr( const Type *p = 0 ) ;
    
    inline  ~CSmartPtr( ) ;

    //inline  CSmartPtr<Type>&  operator=( CSmartPtr<Type>& ) ;
	inline	CSmartPtr<Type>&	operator=( const	CSmartPtr<Type>& ) ;
	inline	CSmartPtr<Type>&	operator=( const	Type	* ) ;
	inline	BOOL			operator==( CSmartPtr<Type>& ) ;
	inline	BOOL			operator!=( CSmartPtr<Type>& ) ;
	inline	BOOL			operator==( Type* ) ;
	inline	BOOL			operator!=( Type* ) ;
    inline  Type*   operator->() const ;
	inline	operator Type*  () const ;
    inline  BOOL    operator!() const ;
	inline	Type*			Release() ;
	inline	Type*			Replace( Type * ) ;
} ;





#include    "smartptr.inl"


#endif  // _SORTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\smtpevents.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       smtpevents.h

   Abstract:

       This file contains type definitions seo events

   Author:

        Rohan Phillips (Rohanp)     MAY-06-1998

   Revision History:

--*/

#ifndef _SMTPEVENT_PARAMS_
#define _SMTPEVENT_PARAMS_

#define SMTP_SERVER_EVENT_IO_TIMEOUT 5*60*1000

#include "filehc.h"

typedef struct _SMTP_EVENT_ALLOC_
{
	PFIO_CONTEXT hContent;
	PVOID IMsgPtr;
	PVOID BindInterfacePtr;
	PVOID pAtqClientContext;
//	PATQ_CONTEXT pAtqContext;
	PVOID	* m_EventSmtpServer;
	LPCSTR  m_DropDirectory;

	DWORD   m_InstanceId;
	
	DWORD	m_RecipientCount;

	DWORD	*pdwRecipIndexes;
	HRESULT hr;

	DWORD	m_dwStartupType;
    PVOID m_pNotify;
}SMTP_ALLOC_PARAMS;


typedef struct _SEOEVENT_OVERLAPPED
{
    FH_OVERLAPPED   	Overlapped;
	DWORD				Signature;
	ATQ_COMPLETION  pfnCompletion;
	PVOID				ThisPtr;
}   SERVEREVENT_OVERLAPPED;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\snprflib.h ===
/*==========================================================================*\

    Module:        exprflib.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the header for exprflib.h a perf library. This 
                   is the code that runs in the app exporting the counters.
    
\*==========================================================================*/


#ifndef __PERFLIB_H__
#define __PERFLIB_H__

///////////////////////////////////////////////////////////////////////////////
//
// Includes
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <winperf.h>
#include <stdio.h>
#ifdef STAXMEM
#include <exchmem.h>
#endif


///////////////////////////////////////////////////////////////////////////////
//
// Data Structures / typedefs / misc defines
//
///////////////////////////////////////////////////////////////////////////////
#define MAX_PERF_NAME           16
#define MAX_OBJECT_NAME         16
#define MAX_INSTANCE_NAME       16
#define MAX_PERF_OBJECTS        16
#define MAX_OBJECT_COUNTERS     200
#define SHMEM_MAPPING_SIZE      32768

typedef WCHAR OBJECTNAME[MAX_OBJECT_NAME];
typedef WCHAR INSTANCENAME[MAX_INSTANCE_NAME];
typedef unsigned __int64 QWORD;

struct INSTANCE_DATA
{
    BOOL                        fActive;
    PERF_INSTANCE_DEFINITION    perfInstDef;
    INSTANCENAME                wszInstanceName;
};


///////////////////////////////////////////////////////////////////////////////
//
// Forward class declarations
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectInstance;
class PerfCounterDefinition;
class PerfObjectDefinition;


///////////////////////////////////////////////////////////////////////////////
//
// Local memory management
//
///////////////////////////////////////////////////////////////////////////////
#ifdef STAXMEM
#undef new
#endif

class MemoryModule
{
public:

#ifdef STAXMEM
#ifdef DEBUG
    void* operator new (size_t cb, char * szFile, DWORD dwLine)
        { return ExchMHeapAllocDebug (cb, szFile, dwLine); }
#else //!DEBUG
    void* operator new (size_t cb)
        { return ExchMHeapAlloc (cb); }
#endif
    void  operator delete(void* pv)
        { ExchMHeapFree (pv); };
#endif
};

#ifdef STAXMEM
#ifdef DEBUG
#define new     new(__FILE__, __LINE__)
#endif
#endif


///////////////////////////////////////////////////////////////////////////////
//
// Shared memory management
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _SharedMemorySegment : public MemoryModule
{
    HANDLE  m_hMap;
    PBYTE   m_pbMap;
    struct _SharedMemorySegment * m_pSMSNext;
} SharedMemorySegment;



///////////////////////////////////////////////////////////////////////////////
//
// PerfLibrary class declaration. There is one perf library instance per linkee.
//
///////////////////////////////////////////////////////////////////////////////
class PerfLibrary : public MemoryModule
{
    friend class PerfObjectDefinition;
    friend class PerfCounterDefinition;
    
private:
    // Name of this performance module
    WCHAR                       m_wszPerfName[MAX_PERF_NAME];
        
    // Array of PerfObjectDefinition's and a count of how many there are.
    PerfObjectDefinition*       m_rgpObjDef[MAX_PERF_OBJECTS];
    DWORD                       m_dwObjDef;

    // Shared memory handle and pointer to base of shared memory
    HANDLE                      m_hMap;
    PBYTE                       m_pbMap;
    

    // Pointers to places in the shared memory where we keep stuff
    DWORD*                      m_pdwObjectNames;
    OBJECTNAME*                 m_prgObjectNames;

    // Base values for title text and help text for the library
    DWORD                       m_dwFirstHelp;
    DWORD                       m_dwFirstCounter;

    void AddPerfObjectDefinition (PerfObjectDefinition* pObjDef);
    
public:

    PerfLibrary (LPCWSTR pcwstrPerfName);
    ~PerfLibrary (void);

    PerfObjectDefinition* AddPerfObjectDefinition (LPCWSTR pcwstrObjectName,
                                                   DWORD dwObjectNameIndex,
                                                   BOOL fInstances);
    
    BOOL Init (void);
    void DeInit (void);
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectDefinition class declaration. There is one of these for each
//  perfmon object exported. Generally there is just one, but not neccessarily.
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectDefinition : public MemoryModule
{
    friend class PerfLibrary;
    friend class PerfCounterDefinition;
    friend class PerfObjectInstance;
    
private:
    
    WCHAR                       m_wszObjectName[MAX_OBJECT_NAME];
    
    DWORD                       m_dwObjectNameIndex;
    BOOL                        m_fInstances;

    PerfCounterDefinition*      m_rgpCounterDef[MAX_OBJECT_COUNTERS];
    DWORD                       m_dwCounters;

    DWORD                       m_dwDefinitionLength;
    DWORD                       m_dwCounterData;
    DWORD                       m_dwPerInstanceData;

    PERF_OBJECT_TYPE*           m_pPerfObjectType;
    PERF_COUNTER_DEFINITION*    m_rgPerfCounterDefinition;

    DWORD                       m_dwActiveInstances;

    SharedMemorySegment*        m_pSMS;
    DWORD                       m_dwShmemMappingSize;
    DWORD                       m_dwInstancesPerMapping;
    DWORD                       m_dwInstances1stMapping;

    CRITICAL_SECTION            m_csPerfObjInst;
    BOOL                        m_fCSInit;

    PerfObjectInstance*         m_pPoiTotal;
    
    BOOL Init (PerfLibrary* pPerfLib);
    void DeInit (void);
    void AddPerfCounterDefinition (PerfCounterDefinition* pcd);

    DWORD GetCounterOffset (DWORD dwId);

public:

    PerfObjectDefinition (LPCWSTR pwcstrObjectName,
                          DWORD dwObjectNameIndex,
                          BOOL  fInstances = FALSE);

    ~PerfObjectDefinition (void);

    PerfCounterDefinition* AddPerfCounterDefinition (
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale = 0);

    PerfCounterDefinition* AddPerfCounterDefinition (
                                    PerfCounterDefinition * pCtrRef,
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale = 0);

    PerfObjectInstance*    AddPerfObjectInstance (LPCWSTR pwcstrInstanceName);

    void DeletePerfObjectInstance ();
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfCounterDefinition class declaration. There is one of these per counter.
//
///////////////////////////////////////////////////////////////////////////////
class PerfCounterDefinition : public MemoryModule
{
    friend class PerfObjectDefinition;
    
private:    
    PerfObjectDefinition*       m_pObjDef;
    PerfCounterDefinition*      m_pCtrRef;
    DWORD                       m_dwCounterNameIndex;
    LONG                        m_lDefaultScale;
    DWORD                       m_dwCounterType;
    DWORD                       m_dwCounterSize;

    DWORD                       m_dwOffset;

    void Init (PerfLibrary* pPerfLib,
               PERF_COUNTER_DEFINITION* pdef,
               PDWORD pdwOffset);
    
public:
    PerfCounterDefinition (DWORD dwCounterNameIndex,
                           DWORD dwCounterType = PERF_COUNTER_COUNTER,
                           LONG lDefaultScale = 0);

    PerfCounterDefinition (PerfCounterDefinition* pRefCtr,
                           DWORD dwCounterNameIndex,
                           DWORD dwCounterType = PERF_COUNTER_COUNTER,
                           LONG lDefaultScale = 0);
                           
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectInstance class declaration. There is one of these per instance
//  of an object. There is one if there are no instances (the global instance.)
//
// NOTE: User is responsible for allocating space and Init this object after
//       the PerfLibrary is initialized. When destroying the perf counters,
//       this object must be destroyed before the PerfLibrary is deinitialized.
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectInstance : public MemoryModule
{
    friend class PerfObjectDefinition;

private:
    PerfObjectDefinition*       m_pObjDef;  
    WCHAR                       m_wszInstanceName[MAX_INSTANCE_NAME];
    INSTANCE_DATA*              m_pInstanceData;
    char*                       m_pCounterData;
    BOOL                        m_fInitialized;

    void Init (char* pCounterData,
               INSTANCE_DATA* pInstData,
               LONG lID);
    
public:
    PerfObjectInstance (PerfObjectDefinition* pObjDef,
                        LPCWSTR pwcstrInstanceName);
    ~PerfObjectInstance () { DeInit(); };
    
    VOID                DeInit (void);

    BOOL                FIsInitialized () {return m_fInitialized; };
    DWORD *             GetDwordCounter (DWORD dwId);
    LARGE_INTEGER *     GetLargeIntegerCounter (DWORD dwId);
    QWORD *             GetQwordCounter (DWORD dwId);
    PERF_OBJECT_TYPE *  GetPerfObjectType ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\tfdlist.h ===
/*++

	TFDLIST.H

	This header file defines templates for manipulating doubly linked lists.
	These are intrusive lists - the client must provide a DLIST_ENTRY item
	within each data member for us to maintain the list.

--*/



#ifndef	_TFDLIST_H_
#define	_TFDLIST_H_

class	DLIST_ENTRY	{
/*++

Class Description :

	This class is intended to be incorporated into classes which are held
	within doubly linked lists.   This class will define two pointers used
	to chain the items within the lists.

	IMPORTANT : m_pNext and m_pPrev point to DLIST_ENTRY's and not to the
	top of the containing item - the template classes provided following here
	are to be used to manipulate these items.

--*/
private :

	//
	//	These are private - they don't make sense for clients !
	//
	DLIST_ENTRY( DLIST_ENTRY& ) ;
	DLIST_ENTRY&	operator=(DLIST_ENTRY&) ;
protected :
	//
	//	The items which allows maintain the doubly linked list !
	//
	class	DLIST_ENTRY*	m_pNext ;
	class	DLIST_ENTRY*	m_pPrev ;
	//
	//	The base class for all iterators !
	//
	friend class	DLISTIterator ;

	void
	InsertAfter(	DLIST_ENTRY* p )	{
	/*++

	Routine Description :

		Insert an item into the list after THIS !
	
	Arguments :
	
		p - the item to be inserted !

	Return Value

		None.

	--*/
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		_ASSERT( p->m_pNext == p ) ;
		_ASSERT( p->m_pPrev == p ) ;
		DLIST_ENTRY*	pNext = m_pNext ;
		p->m_pNext = pNext ;
		p->m_pPrev = this ;
		pNext->m_pPrev = p ;
		m_pNext = p ;
	}
	
	void
	InsertBefore(	DLIST_ENTRY* p )	{
	/*++

	Routine Description :

		Insert an item into the list before THIS !
	
	Arguments :
	
		p - the item to be inserted !

	Return Value

		None.

	--*/

		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		_ASSERT( p->m_pNext == p ) ;
		_ASSERT( p->m_pPrev == p ) ;
		DLIST_ENTRY*	pPrev = m_pPrev ;
		p->m_pNext = this ;
		p->m_pPrev = pPrev ;
		pPrev->m_pNext = p ;
		m_pPrev = p ;
	}

public :
	
	//
	//	Initialize a list !
	//	
	DLIST_ENTRY() {
		m_pNext = this ;
		m_pPrev = this ;
	}


	//
	//	It would be nice to comment out this Destructor in Retail builds,
	//	however - VC5 has a compiler bug where if you allocate an array of
	//	DLIST_ENTRY objects it adds a DWORD to hold the number of allocated
	//	objects.  Unless you have a Destructor (even a do nothing like this
	//	one will be in retail), the delete[] operator won't do the math
	//	to account for the DWORD counter - and you get Assert's etc...
	//	in your memory allocators.
	//
//#ifdef	DEBUG
	//
	//	Destroy an item in a list - should be empty when destroyed !
	//
	~DLIST_ENTRY()	{
		_ASSERT( m_pNext == this ) ;
		_ASSERT( m_pPrev == this ) ;
		_ASSERT( m_pNext == m_pPrev ) ;
	}
//#endif	

	BOOL
	IsEmpty()	{
	/*++

	Routine Description :

		This function returns TRUE if there is nothing else in the list but us.

	Arguments :

		None.

	Return Value :

		TRUE if Empty, FALSE otherwise !

	--*/
		_ASSERT( m_pPrev != 0 && m_pNext != 0 ) ;
		return	m_pPrev == this ;
	}

	void
	RemoveEntry( ) {
	/*++

	Routine Description :

		Remote this item from the list !

	Arguments :

		None.

	Return Value :

		None.

	--*/
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		
		DLIST_ENTRY*	pPrev = m_pPrev ;
		DLIST_ENTRY*	pNext = m_pNext ;
		pPrev->m_pNext = pNext ;
		pNext->m_pPrev = pPrev ;
		m_pPrev = this ;
		m_pNext = this ;
	}

	void
	Join( DLIST_ENTRY&	head )	{
	/*++

	Routine Description :

		Take one list and join it with another.
		The referenced head of the list is not to become an element in the list,
		and is left with an empty head !
	
	Arguments ;

		head - the head of the list that is to become empty, and whose elements
		are to be joined into this list !

	Return Value :

		None.

	--*/
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;

		if( !head.IsEmpty() ) {
			//
			//	First - save the guy that is at the head of our list !
			//
			DLIST_ENTRY*	pNext = m_pNext ;
			head.m_pPrev->m_pNext = pNext ;
			pNext->m_pPrev = head.m_pPrev ;
			head.m_pNext->m_pPrev = this ;
			m_pNext = head.m_pNext ;
			head.m_pNext = &head ;
			head.m_pPrev = &head ;
		}
		_ASSERT( head.IsEmpty() ) ;
	}


} ;


class	DLISTIterator	{
/*++

Class Description :

	Implement an iterator which can go both directions over
	doubly linked lists built on the DLIST_ENTRY class !
	This is the base class for a set of templates that will
	provide iteration over generic items which contain DLIST_ENTRY
	objects for their list manipulation !

--*/
protected :
	//
	//	The current position in the list !
	//
	DLIST_ENTRY	*m_pCur ;
	//
	//	the DLIST_ENTRY which is both head & tail of the list
	//	(since it is circular !)
	//
	DLIST_ENTRY	*m_pHead ;
public :

	//
	//	TRUE if we're using the m_pNext pointers to go forward !
	//	This member should not be manipulated by clients - its exposed
	//	for read only purposes only.
	//
	BOOL		m_fForward ;

	DLISTIterator(	
				DLIST_ENTRY*	pHead,
				BOOL			fForward = TRUE
				) :
		m_pHead( pHead ),
		m_fForward( fForward ),
		m_pCur( fForward ? pHead->m_pNext : pHead->m_pPrev ) {
		_ASSERT( m_pHead != 0 ) ;
	}

	void
	ReBind(	DLIST_ENTRY*	pHead,
			BOOL	fForward
			)	{

		m_pHead = pHead ;
		m_fForward = fForward ;
		m_pCur = fForward ? pHead->m_pNext : pHead->m_pPrev ;
	}

	void
	ReBind(	DLIST_ENTRY*	pHead	)	{

		m_pHead = pHead ;
		m_pCur = m_fForward ? pHead->m_pNext : pHead->m_pPrev ;
	}



	void
	Prev()	{
	/*++

	Routine Description :

		This function moves the iterator back one slot.
		Note that m_pHead is the end of the list, and we avoiud
		setting m_pCur equal to m_pHead !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		_ASSERT( m_pCur != m_pHead || m_pHead->IsEmpty() || m_fForward ) ;

		m_pCur = m_pCur->m_pPrev ;
		m_fForward = FALSE ;
	}

	void
	Next()	{
	/*++

	Routine Description :

		This function moves the iterator forward one slot.
		Note that m_pHead is the end of the list, and we avoiud
		setting m_pCur equal to m_pHead !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		_ASSERT( m_pCur != m_pHead || m_pHead->IsEmpty() || !m_fForward ) ;

		m_pCur = m_pCur->m_pNext ;
		m_fForward = TRUE ;
	}
	void
	Front()	{
	/*++

	Routine Description :

		Reset the iterator to reference the first item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/

		m_pCur = m_pHead->m_pNext ;
		m_fForward = TRUE ;
	}
	void
	Back()	{
	/*++

	Routine Description :

		Reset the iterator to reference the last item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
	
		m_pCur = m_pHead->m_pPrev  ;
		m_fForward = FALSE ;
	}

	BOOL
	AtEnd()	{
	/*++

	Routine Description :

		Return TRUE if we are at the end of the list !
		This is a little more complicated to compute -
		depends on which way we are going !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		return	m_pCur == m_pHead ;

	}

	DLIST_ENTRY*	
	CurrentEntry()	{
		return	m_pCur ;
	}

	DLIST_ENTRY*
	RemoveItemEntry()	{
	/*++

	Routine Description :

		Remove the item that the iterator currently
		references from the list.
		If we are going forward then the iterator
		will be setting on the previous element,
		otherwise the iterator is left on the next element.
		We have to take care that we don't leave the iterator
		sitting on an invalid element.

	Arguments :

		None.

	Return	Value :

		Pointer to the removed item.

	--*/

		if( m_pCur == m_pHead )
			return	0 ;
		DLIST_ENTRY*	pTemp = m_pCur ;
		if( m_fForward )	{
			m_pCur = pTemp->m_pNext;
		}	else	{
			m_pCur = pTemp->m_pPrev ;
		}
		pTemp->RemoveEntry() ;
		return	pTemp ;
	}

	void
	InsertBefore(	DLIST_ENTRY*	p )		{
	/*++

	Routine Description :

		Insert an item before our current position in the list !

	Arguments :

		None.

	Return	Value :

		Nothin

	--*/
		
		m_pCur->InsertBefore( p ) ;
	}

	void
	InsertAfter(	DLIST_ENTRY*	p )		{
	/*++

	Routine Description :
	
		Insert an Item after our current position in the list !

	Arguments :

		None.

	Return	Value :

		Nothin

	--*/

		m_pCur->InsertAfter( p ) ;
	}

} ;

template<	class	LISTHEAD	>
class	TDListIterator : public DLISTIterator	{
/*++

Class Description :

	This class provides an iterator which can walk over a specified List !

--*/
public :
	typedef	typename LISTHEAD::EXPORTDATA	Data ;
private :

#if 0
	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	void
	ReBind(	DLIST_ENTRY*	pHead,
			BOOL	fForward
			) ;

	void
	ReBind(	DLIST_ENTRY*	pHead ) ;
#endif

	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	DLIST_ENTRY*
	RemoveItemEntry() ;

	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	DLIST_ENTRY*
	CurrentEntry() ;

	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	void
	InsertBefore( DLIST_ENTRY* ) ;
	
	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	void
	InsertAfter( DLIST_ENTRY* ) ;

public :

	TDListIterator(
		LISTHEAD*		pHead,
		BOOL			fForward = TRUE
		) :
		DLISTIterator( pHead, fForward )	{
	}

	TDListIterator(
		LISTHEAD&		head,
		BOOL			fForward = TRUE
		) : DLISTIterator( &head, fForward ) {
	}

	TDListIterator(
		DLIST_ENTRY*	pHead,
		BOOL			fForward = TRUE
		) :
		DLISTIterator( pHead, fForward ) {
	}

	void
	ReBind(	LISTHEAD*	pHead )	{
		DLISTIterator::ReBind( pHead ) ;
	}

	void
	ReBind(	LISTHEAD*	pHead, BOOL fForward )	{
		DLISTIterator::ReBind( pHead, fForward ) ;
	}

	inline Data*
	Current( ) {
		return	LISTHEAD::Convert( m_pCur ) ;
	}

	inline Data*
	RemoveItem( )	{
		DLIST_ENTRY*	pTemp = DLISTIterator::RemoveItemEntry() ;
		return	LISTHEAD::Convert( pTemp ) ;
	}

	inline void
	InsertBefore(	Data*	p )		{
		DLIST_ENTRY*	pTemp = LISTHEAD::Convert( p ) ;
		DLISTIterator::InsertBefore( pTemp ) ;
	}
	
	inline void
	InsertAfter(	Data*	p )		{
		DLIST_ENTRY*	pTemp = LISTHEAD::Convert( p ) ;
		DLISTIterator::InsertAfter(	pTemp ) ;
	}

	//
	//	For debug purposes - let people know what the head is !
	//
	LISTHEAD*	
	GetHead()	{
		return	(LISTHEAD*)m_pHead ;
	}
} ;

template<	class	Data,
			typename Data::PFNDLIST	pfnConvert 	>
class	TDListHead : private	DLIST_ENTRY	{
/*++

Class	Description :

	This class defines the head of a doubly linked list of items of DATAHELPER::LISTDATA
	We provide all the functions required to manipulate the list, and a mechanism
	for creating iterators.

--*/
public :

	//
	//	Publicly redefine the type that we deal with into a nice short form !
	//
	typedef	Data	EXPORTDATA ;

private :

	//
	//	These kinds of iterators are our friends !
	//
	friend	class	TDListIterator< TDListHead<Data, pfnConvert> > ;

	static inline Data*
	Convert(	DLIST_ENTRY*	p )	{
	/*++

	Routine Description :

		This function takes a pointer to a DLIST_ENTRY and returns a pointer
		to the beginning of the data item !

	Arguments :

		p - pointer to a DLIST_ENTRY found within our list !

	Return Value :

		Pointer to the Data Item containing the referenced DLIST_ENTRY !

	--*/

		if( p )		{
			return	(Data*)(((PCHAR)p) - (PCHAR)(pfnConvert(0))) ;
		}
		return	0 ;
	}

	static inline DLIST_ENTRY*
	Convert( Data* pData ) {
		return	pfnConvert(pData) ;
	}

	//
	//	Copy Constructor and Operator= are private, as they don't make sense !
	//
	

public :

	//
	//	Redefine this to be public !
	//
	inline BOOL
	IsEmpty()	{
		return	DLIST_ENTRY::IsEmpty() ;
	}

	inline void
	PushFront(	Data*	pData ) {	
	/*++

	Routine Description :

		Push the Data item onto the front of the doubly linked list !

	Arguments :

		pData - item to add to the front of the list

	Return Value :

		None.

	--*/
		_ASSERT( pData != 0 ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	p = Convert(pData);
		InsertAfter( p ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
	}

	inline void
	PushBack(	Data*	pData ) {
	/*++

	Routine Description :

		Push the Data item onto the back of the doubly linked list !

	Arguments :

		pData - item to add to the front of the list

	Return Value :

		None.

	--*/

		_ASSERT( pData != 0 ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	p = Convert(pData) ;
		InsertBefore( p ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
	}

	inline Data*
	PopFront()	{
	/*++

	Routine Description :

		Remove the data item from the front of the List !

	Arguments :
		
		None.

	Return Value :

		The front of the list - NULL if empty !

	--*/

		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	pReturn = 0;
		if( m_pNext != this ) {
			pReturn = m_pNext ;
			pReturn->RemoveEntry() ;
		}
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		return	Convert( pReturn ) ;
	}

	inline Data*
	PopBack()	{
	/*++

	Routine Description :

		Remove the data item from the Back of the List !

	Arguments :
		
		None.

	Return Value :

		The Back of the list - NULL if empty !

	--*/


		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	pReturn = 0 ;
		if( m_pPrev != this ) {
			pReturn = m_pPrev ;
			pReturn->RemoveEntry() ;
		}
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		return	Convert( pReturn ) ;
	}

	static inline void
	Remove(	Data*	pData )	{
	/*++

	Routine Description :

		Remove the specified item from the list !
		
	Arguments :
		
		None.

	Return Value :

		The Back of the list - NULL if empty !

	--*/

		DLIST_ENTRY*	p = Convert( pData ) ;
		p->RemoveEntry() ;
	}

	inline Data*
	GetFront()	{
	/*++

	Routine Description :

		Return the data item from the Front of the List !

	Arguments :
		
		None.

	Return Value :

		The Front of the list - NULL if empty !

	--*/


		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		if( m_pNext == this ) {
			return	0 ;
		}
		return	Convert( m_pNext ) ;
	}			
	
	inline Data*
	GetBack()	{
	/*++

	Routine Description :

		Return the data item from the Back of the List !

	Arguments :
		
		None.

	Return Value :

		The Back of the list - NULL if empty !

	--*/


		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		if( m_pPrev == this ) {
			return	0 ;
		}
		return	Convert( m_pPrev ) ;
	}

	inline void
	Join( TDListHead&	head )	{
	/*++

	Routine Description :

		Take one list and join it with another.
		The referenced head of the list is not to become an element in the list,
		and is left with an empty head !
	
	Arguments ;

		head - the head of the list that is to become empty, and whose elements
		are to be joined into this list !

	Return Value :

		None.

	--*/

		DLIST_ENTRY::Join( head ) ;
	}
} ;

#endif	// _TFDLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\tflistex.h ===
#ifndef __TFLISTEX_H__
#define __TFLISTEX_H__

//
// This defines TFListEx, which is just like TFList but it has built in
// locking.  For usage information refer to tflist.h.  For examples of
// TFList usage look at the unit test found in 
// src\core\tflist\utest\tflist.cpp.
//
// -awetmore
//

#include "tflist.h"
#include "rwnew.h"

template <class Data> class TFListEx : public TFList<Data> {
	protected:
		CShareLockNH m_lock;

		// 
		// This is a helper class which automatically does the lock/unlock
		// operation for us.  The compiler will turn a method that looks 
		// like:
		//
		// bool IsEmpty(void) {
		// 		CListShareLock lock(this);
		//		return TFList<Data>::IsEmpty();
		// }
		//
		// become:
		// bool IsEmpty(void) {
		// 		bool f;
		//		m_lock.ShareLock();
		//		f = TFList<Data>::IsEmpty();
		//		m_lock.ShareUnlock();
		//		return f;
		// }
		//
		// I chose to do things this way because its less error prone (I 
		// can't return without releasing the lock, etc) and makes the 
		// inline functions shorter and cleaner.  
		//
		class CListShareLock {
			private:
				TFListEx<Data> *m_pList;
			public:
				CListShareLock(TFListEx<Data> *pList) { 
					m_pList = pList;
					m_pList->m_lock.ShareLock(); 
				}
				~CListShareLock() { 
					m_pList->m_lock.ShareUnlock(); 
				}
		};

		//
		// same as CListShareLock, but it grabs the lock exclusively.
		//
		class CListExclusiveLock {
			private:
				TFListEx<Data> *m_pList;
			public:
				CListExclusiveLock(TFListEx<Data> *pList) { 
					m_pList = pList;
					m_pList->m_lock.ExclusiveLock(); 
				}
				~CListExclusiveLock() { 
					m_pList->m_lock.ExclusiveUnlock(); 
				}
		};	

	public:
		TFListEx(NEXTPTR pPrev, NEXTPTR pNext) : TFList<Data>(pPrev, pNext) {}

		bool IsEmpty() {
			CListShareLock lock(this);
			return TFList<Data>::IsEmpty();
		}

        void PushFront(Data *node) { 
			CListExclusiveLock lock(this);
			TFList<Data>::PushFront(node);
		}

        void PushBack(Data *node) { 
			CListExclusiveLock lock(this);
			TFList<Data>::PushBack(node);
		}

        Data *PopFront() { 
			CListExclusiveLock lock(this);
			return TFList<Data>::PopFront();
		}

        Data *PopBack() { 
			CListExclusiveLock lock(this);
			return TFList<Data>::PopBack();
		}

		Data* GetFront() {
			CListShareLock lock(this);
			return TFList<Data>::GetFront();
		}

		Data* GetBack() {
			CListShareLock lock(this);
			return TFList<Data>::GetBack();
		}

		//
		// The Iterator holds a lock for the objects lifetime.  You can
		// choose a share lock or an exclusive lock with the second parameter.
		// It defaults to a share lock.
		//
		class Iterator : public TFList<Data>::Iterator {
			public:
				Iterator(TFListEx<Data> *pList, BOOL fExclusive = FALSE, BOOL fForward = TRUE) :
					TFList<Data>::Iterator((TFList<Data> *) pList, fForward) 
				{
					m_fExclusive = fExclusive;
					if (m_fExclusive) {
						pList->m_lock.ExclusiveLock();
					} else {
						pList->m_lock.ShareLock();
					}

                    ResetHeader( pList );
				}
	
				~Iterator() {
					TFListEx<Data> *pList = (TFListEx<Data> *) m_pList;
					if (m_fExclusive) {
						pList->m_lock.ExclusiveUnlock();
					} else {
						pList->m_lock.ShareUnlock();
					}
				}

#ifdef DEBUG
				//
				// In debug builds we have _ASSERTs to make sure that no
				// operations which require an exclusive lock are performed
				// while holding a share lock.
				//

				Data *RemoveItem(void) {
					if (!m_fExclusive) _ASSERT(FALSE);
					TFList<Data>::Iterator *pThis = (TFList<Data>::Iterator *) this;
					return pThis->RemoveItem();
				}

				void InsertBefore(Data* pNode) {
					if (!m_fExclusive) _ASSERT(FALSE);
					TFList<Data>::Iterator *pThis = (TFList<Data>::Iterator *) this;
					pThis->InsertBefore(pNode);
				}

				void InsertAfter(Data* pNode) {
					if (!m_fExclusive) _ASSERT(FALSE);
					TFList<Data>::Iterator *pThis = (TFList<Data>::Iterator *) this;
					pThis->InsertAfter(pNode);
				}
#endif

			private:
				// what sort of lock did we grab?
				BOOL	m_fExclusive;
		};

		// our helper classes need to be able to access the lock
		friend class TFListEx<Data>::CListShareLock;
		friend class TFListEx<Data>::CListExclusiveLock;
		friend class TFListEx<Data>::Iterator;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\thrdpool.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.h
//
//  Contents:    definitions needed for clients of the thrdpool lib
//
//	Description: The thrdpool library defines the CWorkerThread base class
//				 Users of this lib should define their own derived class
//				 that inherits from CWorkerThread. Each CWorkerThread object
//				 has a thread that is used to do some work. It is also
//				 associated with a common completion port that is used to
//				 queue work items. All worker threads will normally block on
//				 GetQueuedCompletionStatus(). Clients of the CWorkerThread
//				 objects will call PostWork() to get work done. This will
//				 result in one of the worker threads returning from 
//				 GetQueuedCompletionStatus() and calling the derived class'
//				 WorkCompletion() routine with a pvContext.
//
//				 NOTE: the base class has no knowledge of the type of work
//				 getting done. It just manages the details of getting work
//				 requests and distributing it to threads in its pool. This 
//				 allows the derived class to focus on processing the actual
//				 work item without bothering about queueing etc.
//
//				 Completion ports are used merely to leverage its queueing
//				 semantics and not for I/O. If the work done by each thread
//				 is fairly small, LIFO semantics of completion ports will 
//				 reduce context switches.
//
//  Functions:  
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------

#ifndef THRDPOOL_H
#define THRDPOOL_H

//
//	This is the blob that is passed thro the completion port 
//
typedef struct _WorkContextEnv
{
	OVERLAPPED		Ov;					// needed by Post/GetQueuedCompletionStatus
	PVOID			pvWorkContext;		// actual work context - user defined 
} WorkContextEnv, *LPWorkContextEnv;

//
//	Base worker thread class
//
class CWorkerThread
{
public:
	//
	//	Constructor, destructor
	//
	CWorkerThread();
	virtual ~CWorkerThread();

	//
	//	class initializer - should be called once before this class is used
	//
	static BOOL InitClass( DWORD dwConcurrency );

	//
	//	class terminator - should be called once when done using the class
	//
	static BOOL TermClass();

	//
	//	clients should call this to post work items
	//
	BOOL 						PostWork(PVOID pvWorkContext);

	//
	//	expose shutdown event
	//
	HANDLE QueryShutdownEvent() { return m_hShutdownEvent; }

protected:

	//
	//	derived method called when work items are posted
	//
	virtual VOID 				WorkCompletion(PVOID pvWorkContext) = 0;

private:

	//
	//	check for matching InitClass(), TermClass() calls
	//
	static	LONG				m_lInitCount;

	//
	//	handle to completion port
	//
	static HANDLE				m_hCompletionPort;

	//
	//	handle to worker thread
	//
	HANDLE						m_hThread;

	//
	//	shutdown event
	//
	HANDLE						m_hShutdownEvent;

	//
	//	thread function
	//
	static DWORD __stdcall 		ThreadDispatcher(PVOID pvWorkerThread);

	//
	//	block on GetQueuedCompletionStatus for work items
	//
	VOID 						GetWorkCompletion(VOID);
};

#endif		// #ifndef THRDPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\tflist.h ===
#ifndef __CLIST_H__
#define __CLIST_H__


//
// TFList - a class for handling templated lists.  Lists support adding
// and removing items from the front and back of the list.  The item on
// the front or back can be examined.  Using iterator the list can
// be traversed easily (see the block comment below).
//
// The objects that this list hold should have this form:
//
// CListObject {
// 		public:
//			CListObject *m_pNext;		// for use by TFList<CListObject>
//			CListObject *m_pPrev;		// for use by TFList<CListObject>
//		// other object parameters
// }
//
// The constructor for the object should set m_pNext and m_pPrev to NULL
// in debug builds to avoid hitting _ASSERTs.
//
// To construct the list you need to pass in the offsets for the m_pNext
// and m_pPrev members using C++'s member offset syntax.  Here is an
// example:
//	TFList<CListObject> list(&CListObject::m_pPrev, &CListObject::m_pNext);
//
template <class Data> class TFList {
	public:
		typedef Data *Data::*NEXTPTR;

    protected:
		Data		*m_pHead;				// the head of the list
		Data 		*m_pTail;				// the tail of the list
		NEXTPTR		m_pNext;				// offset to the next pointer
		NEXTPTR		m_pPrev;				// offset to the prev pointer

    public:
		TFList(NEXTPTR pPrev, NEXTPTR pNext) {
			m_pHead = NULL;
			m_pTail = NULL;
			m_pNext = pNext;
			m_pPrev = pPrev;
		}

		~TFList() {
			// the user should empty the list before deleting it
			_ASSERT(m_pHead == NULL);
			_ASSERT(m_pTail == NULL);
		}

		// see if the list is empty
		bool IsEmpty() {
			bool f = (m_pHead == NULL);
			// if the head is null then the tail has to be null
			_ASSERT(!f || m_pTail == NULL);
			return f;
		}

        // push an element onto the front of the list
        void PushFront(Data *node) { 	
			_ASSERT(node != NULL);
			// you can't put an entry into the list that is already in it
			_ASSERT(node->*m_pNext == NULL);
			_ASSERT(node->*m_pPrev == NULL);
			// set the next and prev pointers
			node->*m_pPrev = NULL;
			node->*m_pNext = m_pHead;
			// if the list is empty then this new item is the tail too
			if (IsEmpty()) {
				_ASSERT(m_pTail == NULL);
				m_pTail = node;
			} else {
				_ASSERT(m_pHead->*m_pPrev == NULL);
				m_pHead->*m_pPrev = node;
			}
			m_pHead = node;
		}

        // push an element onto the back of the list
        void PushBack(Data* node) { 
			_ASSERT(node != NULL);
			// you can't put an entry into the list that is already in it
			_ASSERT(node->*m_pNext == NULL);
			_ASSERT(node->*m_pPrev == NULL);
			// set the next and prev pointers
			node->*m_pNext = NULL;
			node->*m_pPrev = m_pTail;
			// if the list is empty then this new item is the head too
			if (IsEmpty()) {
				_ASSERT(m_pHead == NULL);
				m_pHead = node;
			} else {
				_ASSERT(m_pTail->*m_pNext == NULL);
				m_pTail->*m_pNext = node;
			}			
			m_pTail = node;
		}

        // remove the item from the front of the list
        Data *PopFront() { 
			if (m_pHead == NULL) return NULL;
			Data *node = m_pHead;
			m_pHead = node->*m_pNext;
			if (m_pHead == NULL) m_pTail = NULL;
			else m_pHead->*m_pPrev = NULL;
			node->*m_pNext = NULL;
			node->*m_pPrev = NULL;
			return node;
		}

        // remove the item from the back of the list
        Data *PopBack() { 
			if (m_pTail == NULL) return NULL;
			Data *node = m_pTail;
			m_pTail = node->*m_pPrev;
			if (m_pTail == NULL) m_pHead = NULL;
			else (m_pTail)->*m_pNext = NULL;
			node->*m_pNext = NULL;
			node->*m_pPrev = NULL;
			return node;
		}

        // get the item on the front of the list
        Data* GetFront() { return m_pHead; }

        // get the item on the back of the list
        Data* GetBack() { return m_pTail; }


	public:
		//
		// The Iterator object is used to walk the list and modify members
		// that are in the middle of the list.  It is declared using this
		// syntax:
		// 	TFList<CListObject>::Iterator it(&list);
		//
		class Iterator {
		    protected:
				Data *m_pCur;				// our cursor
				int m_fForward; 			// TRUE for forward, FALSE for back
				TFList<Data> *m_pList;		// the list that we are iterating
				NEXTPTR m_pPrev, m_pNext;
		
		    public:
				//
				// create a new iterator object
				// 
				// arguments: 
				//   pList - the list to iterate across
				//   fForward - TRUE to start at the front, and go forward.
				//              FALSE to start at the back, and go backwards.
				//
				Iterator(TFList<Data> *pList, BOOL fForward = TRUE) {
					_ASSERT(pList != NULL);
					m_pList = pList;
					m_fForward = fForward;
					m_pCur = (fForward) ? pList->m_pHead : pList->m_pTail;
					m_pPrev = pList->m_pPrev;
					m_pNext = pList->m_pNext;
				}

				void ResetHeader( TFList<Data> *pList ) {
				    _ASSERT( pList != NULL );
				    m_pList = pList;
				    m_pCur = (m_fForward) ? m_pList->m_pHead : m_pList->m_pTail;
				    m_pPrev = m_pList->m_pPrev;
				    m_pNext = m_pList->m_pNext;
				}
		
				//
				// get a pointer to the current item
				//
				Data *Current() {
					return m_pCur;
				}
		
				//
		        // go to the previous item in the list
				//
		        void Prev() { 
					if (m_pCur != NULL) {
						m_pCur = m_pCur->*m_pPrev;
					} else {
						// if they switch direction and are at the end of
						// the list then they need to get to a legal place
						if (m_fForward) m_pCur = m_pList->m_pTail;
					}

					m_fForward = FALSE;
				}

				//
		        // go to the next item in the list
				//
		        void Next() { 
					if (m_pCur != NULL) {
						m_pCur = m_pCur->*m_pNext;
					} else {
						// if they switch direction and are at the end of
						// the list then they need to get to a legal place
						if (!m_fForward) m_pCur = m_pList->m_pHead;
					}

					m_fForward = TRUE;
				}

				// 
				// Go to the head of the list
				//
				void Front() {
					m_pCur = m_pList->m_pHead;
					m_fForward = TRUE;
				}

				// 
				// Go to the tail of the list
				//
				void Back() {
					m_pCur = m_pList->m_pTail;
					m_fForward = FALSE;
				}

				//
				// unlinks an item from the linked list
				//
				// cursor updates:
				//   if the last movement in this list was forward then the 
				//   iterator will point towards the pPrev item in the list.  
				//   visa-versa if the last movement was backward.  this is 
				//   so that a for loop over an iterator still works as 
				//   expected.
				//
				// returns:
				//   a pointer to the item that was unlinked.  
				//
				Data *RemoveItem(void) {
					Data *pTemp;
		
					if (m_pCur == NULL) return NULL;

					pTemp = m_pCur;

					// update cur
					if (m_fForward) Next(); else Prev();

					// fix head and tail pointers if necessary
					if (m_pList->m_pHead == pTemp) 
						m_pList->m_pHead = pTemp->*m_pNext;
					if (m_pList->m_pTail == pTemp) 
						m_pList->m_pTail = pTemp->*m_pPrev;

					// fix up the links on the adjacent elements
					if (pTemp->*m_pNext != NULL) 
						pTemp->*m_pNext->*m_pPrev = pTemp->*m_pPrev;
					if (pTemp->*m_pPrev != NULL) 
						pTemp->*m_pPrev->*m_pNext = pTemp->*m_pNext;

					// clean up the next and prev pointers
					pTemp->*m_pNext = NULL;
					pTemp->*m_pPrev = NULL;

					// return the item
					return pTemp;
				}
		
				//
				// insert a new item before the current item.
				//
				// Cursor updates:
				// If you use this method to insert an item then it should
				// not be visited if the next cursor movement is a Next().
				// If the next cursor movement is a Prev() then it should
				// be visited.
				//
				void InsertBefore(Data* pNode) {
					// this entry shouldn't be linked into the list
					_ASSERT(pNode->*m_pNext == NULL);
					_ASSERT(pNode->*m_pPrev == NULL);

					if (m_pCur == NULL) {
						// if we are at the head of the list then we'll insert
						// before the head
						if (m_fForward) {
							m_pList->PushFront(pNode);
							// set the current pointer to this item, so that
							// if we iterate forward we dont' see this item
							m_pCur = pNode;
						} else {
							// invalid operation.  do nothing
							_ASSERT(FALSE);
						}
					} else {
						pNode->*m_pNext = m_pCur;
						pNode->*m_pPrev = m_pCur->*m_pPrev;
						m_pCur->*m_pPrev = pNode;
						if (pNode->*m_pPrev != NULL) 
							pNode->*m_pPrev->*m_pNext = pNode;
						if (m_pList->m_pHead == m_pCur) 
							m_pList->m_pHead = pNode;
					}
				}
		
				//
				// insert a new item after the current item.
				//
				// Cursor updates are the opposite of InsertBefore().
				//
				void InsertAfter(Data *pNode) {
					// this entry shouldn't be linked into the list
					_ASSERT(pNode->*m_pNext == NULL);
					_ASSERT(pNode->*m_pPrev == NULL);

					if (m_pCur == NULL) {
						// if we are at the tail of the list then we'll insert
						// before the tail
						if (!m_fForward) {
							m_pList->PushBack(pNode);
							// set the current pointer to this item, so that
							// if we iterate backwards we dont' see this item
							m_pCur = pNode;
						} else {
							// invalid operation.  do nothing
							_ASSERT(FALSE);
						}
					} else {
						pNode->*m_pPrev = m_pCur;
						pNode->*m_pNext = m_pCur->*m_pNext;
						m_pCur->*m_pNext = pNode;
						if (pNode->*m_pNext != NULL) 
							pNode->*m_pNext->*m_pPrev = pNode;
						if (m_pList->m_pTail == m_pCur) 
							m_pList->m_pTail = pNode;
					}				
				}
		
				//
				// see if we are at either the front or back of the list
				//
				bool AtEnd() {
					return (m_pCur == NULL);
				}
		};

		friend class TFList<Data>::Iterator;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\transdbg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: transdbg.h
//
//  Description:  Include file to define some basic debugger extension macros
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __TRANSDBG_H__
#define __TRANSDBG_H__

#define  NOEXTAPI
#include <wdbgexts.h>

//---[ TRANS_DEBUG_EXTENSION ]-------------------------------------------------
//
//
//  Description: Macro used to declare a debug extension.  The variable names
//      used are consistant with the debug function macros defined below
//
//  Parameters:
//      function - Name of the function to declare
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
#define TRANS_DEBUG_EXTENSION(function) \
    void function(HANDLE hCurrentProcess, \
        HANDLE hCurrentThread, \
        DWORD dwCurrentPc, \
        PWINDBG_EXTENSION_APIS pExtensionApis, \
        PCSTR szArg)

//---[ Debug function Macros ]-------------------------------------------------
//
//
//  Description:
//      The following Macros are defined to make writing debugging extensions
//      easier.
//          dprintf - printf to the debugger
//          GetExpression - Resolves symbolic expression to DWORD.  Takes a
//                  LPSTR.
//          GetSymbol -
//          Disassm - Disasemble code at given location
//          CheckControlC -
//          ReadMemory - Readmemory in the debuggee. Takes the follow arg:
//                  a PVOID - Pointer value to read
//                  b PVOID - Buffer to copy memory to
//                  c DWORD - # of bytes to read
//                  d PDWORD - OUT - # of bytes read (can be NULL)
//          WriteMemory - Writememory in the process being debugged.  Takes
//              the same arguments as ReadMemory.
//          DebugArgs - Used to pass all the debug args to another extension
//
//  Notes:
//      It is important to realize that you cannot directly read/write pointers
//      that are obtained from the process being debugged.  You must use the
//      ReadMemory and WriteMemory Macros
//
//-----------------------------------------------------------------------------
#define dprintf                 (pExtensionApis->lpOutputRoutine)
#define GetExpression           (pExtensionApis->lpGetExpressionRoutine)
#define GetSymbol               (pExtensionApis->lpGetSymbolRoutine)
#define Disasm                  (pExtensionApis->lpDisasmRoutine)
#define CheckControlC           (pExtensionApis->lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d) \
    ((pExtensionApis->nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( hCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : pExtensionApis->lpReadProcessMemoryRoutine( (ULONG_PTR)(a), (b), (c), (d) ))
#define WriteMemory(a,b,c,d) \
    ((pExtensionApis->nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( hCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : pExtensionApis->lpWriteProcessMemoryRoutine( (ULONG_PTR)(a), (LPVOID)(b), (c), (d) ))
#define DebugArgs hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szArg

#endif //__TRANSDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\smartptr.inl ===
//
//
//
//

template< class Type > 
inline  CRefPtr< Type >::CRefPtr( const CRefPtr< Type >&    ref ) : 
    m_p( ref.m_p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CRefPtr< Type >::CRefPtr( const	Type *p ) : m_p( (Type*)p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CRefPtr< Type >::~CRefPtr( ) {
    if( m_p && m_p->RemoveRef() < 0 ) {
        delete	m_p ;
    }
}

#if 0 
template< class Type > 
inline  CRefPtr< Type >&    CRefPtr< Type >::operator=( CRefPtr< Type >& rhs ) {
    if( m_p != rhs.m_p ) {
        if( m_p && m_p->RemoveRef() < 0 ) {
            delete m_p ;
        }        
    }   
    m_p = rhs.m_p ;
	if( m_p ) 
		m_p->AddRef() ;
    return  *this ;
} ;
#endif

template< class Type > 
inline  CRefPtr< Type >&    CRefPtr< Type >::operator=( const	CRefPtr< Type >& rhs ) {
    if( m_p != rhs.m_p ) {
		Type*	pTemp = m_p ;
		m_p = rhs.m_p ;
		if( m_p ) 
			m_p->AddRef() ;
        if( pTemp && pTemp->RemoveRef() < 0 ) {
            delete	pTemp ;
        }        
    }   
    return  *this ;
} ;

template< class Type >
inline	CRefPtr< Type >&	CRefPtr< Type >::operator=( const	Type*	rhs )	{
	if( m_p != rhs )	{
		Type*	pTemp = m_p ;
		m_p = (Type*)rhs ;
		if( m_p ) 
			m_p->AddRef() ;
		if( pTemp && pTemp->RemoveRef() < 0 )	{
			delete	pTemp ;
		}
	}
	return	*this ;
}

template< class Type > 
inline  Type*   CRefPtr< Type >::operator->()    const   {
    return  m_p ;
}

template< class Type > 
inline	CRefPtr< Type >::operator Type* () const	{
	return	m_p ;
}

#if 0 
template< class Type >
inline  CRefPtr<Type>::CRefPtr() : m_p( 0 ) {
}
#endif

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator ! ( void ) const {
	return	!m_p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator==( CRefPtr<Type>& rhs ) {
	return	m_p == rhs.m_p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator!=( CRefPtr<Type>& rhs )	{
	return	m_p != rhs.m_p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator==( Type * p )	{
	return	m_p == p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator!=( Type * p )	{
	return	m_p != p ;
}

template< class Type > 
inline	Type*	CRefPtr<Type>::Release()	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = 0 ;
	return	pReturn ;
}						

template< class Type > 
inline	Type*	CRefPtr<Type>::Replace( Type* p )	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = p ;
	if( m_p != 0 ) {
		p->AddRef() ;
		if( pReturn == p )	{
			pReturn = 0 ;
		}
	}
	return	pReturn ;
}						

template< class Type > 
inline  CSmartPtr< Type >::CSmartPtr( const CSmartPtr< Type >&    ref ) : 
    m_p( ref.m_p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CSmartPtr< Type >::CSmartPtr( const	Type *p ) : m_p( (Type*)p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CSmartPtr< Type >::~CSmartPtr( ) {
    if( m_p && m_p->RemoveRef() < 0 ) {
        m_p->DestroySelf() ;
    }
}

#if 0 
template< class Type > 
inline  CSmartPtr< Type >&    CSmartPtr< Type >::operator=( CSmartPtr< Type >& rhs ) {
    if( m_p != rhs.m_p ) {
        if( m_p && m_p->RemoveRef() < 0 ) {
            delete m_p ;
        }        
    }   
    m_p = rhs.m_p ;
	if( m_p ) 
		m_p->AddRef() ;
    return  *this ;
} ;
#endif

template< class Type > 
inline  CSmartPtr< Type >&    CSmartPtr< Type >::operator=( const	CSmartPtr< Type >& rhs ) {

    if( m_p != rhs.m_p ) {
		Type*	pTemp = m_p ;
		m_p = rhs.m_p ;
		if( m_p ) 
			m_p->AddRef() ;
        if( pTemp && pTemp->RemoveRef() < 0 ) {
            pTemp->DestroySelf() ;
        }        
    }   
    return  *this ;
} ;

template< class Type >
inline	CSmartPtr< Type >&	CSmartPtr< Type >::operator=( const	Type*	rhs )	{
	if( m_p != rhs )	{
		Type*	pTemp = m_p ;
		m_p = (Type*)rhs ;
		if( m_p ) 
			m_p->AddRef() ;
		if( pTemp && pTemp->RemoveRef() < 0 )	{
			pTemp->DestroySelf() ;
		}
	}
	return	*this ;
}

template< class Type > 
inline  Type*   CSmartPtr< Type >::operator->()    const   {
    return  m_p ;
}

template< class Type > 
inline	CSmartPtr< Type >::operator Type* () const	{
	return	m_p ;
}

#if 0 
template< class Type >
inline  CSmartPtr<Type>::CSmartPtr() : m_p( 0 ) {
}
#endif

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator ! ( void ) const {
	return	!m_p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator==( CSmartPtr<Type>& rhs ) {
	return	m_p == rhs.m_p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator!=( CSmartPtr<Type>& rhs )	{
	return	m_p != rhs.m_p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator==( Type * p )	{
	return	m_p == p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator!=( Type * p )	{
	return	m_p != p ;
}

template< class Type > 
inline	Type*	CSmartPtr<Type>::Release()	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = 0 ;
	return	pReturn ;
}						

template< class Type > 
inline	Type*	CSmartPtr<Type>::Replace( Type* p )	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = p ;
	if( m_p != 0 ) {
		p->AddRef() ;
		if( pReturn == p )	{
			pReturn = 0 ;
		}
	}
	return	pReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\vroot.h ===
#ifndef __VROOT_H__
#define __VROOT_H__

#include <dbgtrace.h>
#include <iadmw.h>
#include <mddefw.h>
#include <tflist.h>
#include <rwnew.h>
#include <refptr2.h>
#include <listmacr.h>

#define MAX_VROOT_PATH MAX_PATH + 1

class CVRootTable;

#define VROOT_GOOD_SIG  'TOOR'
#define VROOT_BAD_SIG   'ROOT'

//
// There is one of these objects for each of the VRoots defined.  It contains
// the VRoot parameters.  The only parameter used by the VRoot library is the
// vroot name, but users of this library should inherit from this and make
// their own version which stores all of the other parameters of interest.
//
class CVRoot : public CRefCount2 {
        public:
                CVRoot() {
                        m_fInit = FALSE;
                        m_pPrev = NULL;
                        m_pNext = NULL;
                        m_dwSig = VROOT_GOOD_SIG;
                }

                virtual ~CVRoot();

                //
                // initialize this class.
                //
                void Init(LPCSTR pszVRootName, CVRootTable *pVRootTable, LPCWSTR wszConfigPath, BOOL fUpgrade );

                //
                // get the vroot name (and optionally its length) from this entry.
                //
                LPCSTR GetVRootName(DWORD *pcch = NULL) { 
                        _ASSERT(m_fInit);
                        if (pcch != NULL) *pcch = m_cchVRootName;
                        return m_szVRootName; 
                }

                // get the MB configuration path
                LPCWSTR GetConfigPath() { return m_wszConfigPath; }

                //
                // This needs to be defined by a subclass of CVRoot.
                //
                virtual HRESULT ReadParameters(IMSAdminBase *pMB, 
                                                   METADATA_HANDLE hmb) = 0;

                //
                // Virtual function for handling orphan VRoot during VRootRescan/VRootDelete
                //
                virtual void DispatchDropVRoot() {};

                // the next and previous pointers for our list
                CVRoot *m_pPrev;
                CVRoot *m_pNext;

#ifdef DEBUG
    LIST_ENTRY  m_DebugList;
#endif

        protected:

        DWORD   m_dwSig;
                BOOL m_fInit;
                // the name of this vroot (alt.binaries for example) and its length.
                char m_szVRootName[MAX_VROOT_PATH];
                DWORD m_cchVRootName;
                // the table which owns us
                CVRootTable *m_pVRootTable;
                // our config path in the metabase
                WCHAR m_wszConfigPath[MAX_VROOT_PATH];
                // upgrad flag
                BOOL m_fUpgrade;
};

typedef CRefPtr2<CVRoot> VROOTPTR;

//
// an implementation of CVRoot which reads the parameters likely to be used
// by all IIS based client of this VRoot implementation.
//
class CIISVRoot : public CVRoot {
        public:
                virtual ~CIISVRoot() {}

                void Init(void *pContext,                       // ignored
                              LPCSTR pszVRootName,              // passed to CVRoot::Init
                                  CVRootTable *pVRootTable,     // passed to CVRoot::Init
                              LPCWSTR pwszConfigPath,
                              BOOL fUpgrade )   // available via GetConfigPath()
                {
                        CVRoot::Init(pszVRootName, pVRootTable, pwszConfigPath, fUpgrade);
                        m_pContext = pContext;
                }

                // get the context pointer
                void *GetContext() { return m_pContext; }

                // SSL properties
                DWORD GetSSLAccessMask() { return m_dwSSL; }

                // access properties
                DWORD GetAccessMask() { return m_dwAccess; }

                // is the content indexed?
                BOOL IsContentIndexed() { return m_fIsIndexed; }

                // this method reads the parameters below from the metabase
                virtual HRESULT ReadParameters(IMSAdminBase *pMB, 
                                                                           METADATA_HANDLE hmb);

        protected:
                // this method reads a dword from the metabase (wraps GetData())
                virtual HRESULT GetDWord(IMSAdminBase *pMB,
                                                                 METADATA_HANDLE hmb,
                                                                 DWORD dwId,
                                                                 DWORD *pdw);

                // this method reads a string from the metabase (wraps GetData())
                virtual HRESULT GetString(IMSAdminBase *pMB,
                                                                  METADATA_HANDLE hmb,
                                                                  DWORD dwId,
                                                                  LPWSTR szString,
                                                                  DWORD *pcString);

        protected:
                // parameters given to use by the constructor
                void *m_pContext;

                // parameters read from the metabase
                BOOL m_fIsIndexed;                                      // is the content indexed?
                BOOL m_fDontLog;                                        // should logging be disabled here?
                DWORD m_dwAccess;                                       // access permissions bitmask
                DWORD m_dwSSL;                                          // SSL access perm's bitmask

};

//
// a subclass of the above which hides the fact that context is a void *.
//
// template arguments:
//  _context_type - the type for the context.  must be castable to void *.
//
template <class _context_type>
class CIISVRootTmpl : public CIISVRoot {
        public:
                virtual ~CIISVRootTmpl() {}

                void Init(_context_type pContext,
                              LPCSTR pszVRootName, 
                                  CVRootTable *pVRootTable,
                                  LPCWSTR pwszConfigPath,
                                  BOOL fUpgrade )
                {
                        CIISVRoot::Init((void *) pContext, 
                                                        pszVRootName, 
                                                        pVRootTable,
                                                        pwszConfigPath,
                                                        fUpgrade );
                }

                // return the context pointer (mostly likely a pointer to an IIS 
                // instance)
                _context_type GetContext() { 
                        return (_context_type) CIISVRoot::GetContext(); 
                }
};

//
// this is a type that points to a function which can create CVRoot objects.
// use it to create your own version of the CVRoot class.
//
// parameters:
//  pContext - the context pointer passed into CVRootTable
//  pszVRootName - the name of the vroot
//  pwszConfigPath - a Unicode string with the path in the metabase for 
//                   this vroot's configuration information.
//
typedef VROOTPTR (*PFNCREATE_VROOT)(void *pContext, 
                                                                    LPCSTR pszVRootName,
                                                                        CVRootTable *pVRootTable,
                                                                    LPCWSTR pwszConfigPath,
                                                                    BOOL fUpgrade );

//
// a function of this type is called when the vroot table is scanned.  it
// is passed a copy of the context pointer
//
typedef void (*PFN_VRTABLE_SCAN_NOTIFY)(void *pContext);

typedef void (*PFN_VRENUM_CALLBACK)(void *pEnumContext,
                                                                        CVRoot *pVRoot);

//
// The CVRootTable object keeps a list of VRoots and can find a vroot for
// a given folder.
//
class CVRootTable {
        public:
                static HRESULT GlobalInitialize();
                static void GlobalShutdown();
                CVRootTable(void *pContext, 
                                        PFNCREATE_VROOT pfnCreateVRoot,
                                        PFN_VRTABLE_SCAN_NOTIFY pfnScanNotify);
                virtual ~CVRootTable();
                HRESULT Initialize(LPCSTR pszMBPath, BOOL fUpgrade );
                HRESULT Shutdown(void);
                HRESULT FindVRoot(LPCSTR pszPath, VROOTPTR *ppVRoot);
                HRESULT EnumerateVRoots(void *pEnumContext, 
                                                                PFN_VRENUM_CALLBACK pfnCallback);

        private:
                VROOTPTR NewVRoot();
                HRESULT ScanVRoots( BOOL fUpgrade );
                HRESULT InitializeVRoot(CVRoot *pVRoot);
                HRESULT InitializeVRoots();
                HRESULT ScanVRootsRecursive(METADATA_HANDLE hmbParent, 
                                                                        LPCWSTR pwszKey, 
                                                                        LPCSTR pszVRootName,
                                                                        LPCWSTR pwszPath,
                                                                        BOOL    fUpgrade );
                void InsertVRoot(VROOTPTR pVRoot);

                // find a vroot
                HRESULT FindVRootInternal(LPCSTR pszPath, VROOTPTR *ppVRoot);

                // convert a config path to a vroot name
                void ConfigPathToVRootName(LPCWSTR pwszConfigPath, LPSTR szVRootName);

                // used to pass metabase notifications back into this object
                static void MBChangeNotify(void *pThis, 
                                                                   DWORD cChangeList, 
                                                                   MD_CHANGE_OBJECT_W pcoChangeList[]);

                // parameters changed under a vroot
                void VRootChange(LPCWSTR pwszConfigPath, LPCSTR pszVRootName);

                // a vroot was deleted
                void VRootDelete(LPCWSTR pwszConfigPath, LPCSTR pszVRootName);

                // a vroot was added
                void VRootAdd(LPCWSTR pwszConfigPath, LPCSTR pszVRootName);

                // rescan the whole vroot list
                void VRootRescan(void);

#ifdef DEBUG
        LIST_ENTRY      m_DebugListHead;
        CShareLockNH    m_DebugListLock;
        
        void DebugPushVRoot( CVRoot *pVRoot ) {
            _ASSERT( pVRoot );
            m_DebugListLock.ExclusiveLock();
            InsertTailList( &m_DebugListHead, &pVRoot->m_DebugList );
            m_DebugListLock.ExclusiveUnlock();
        }

        void DebugExpungeVRoot( CVRoot *pVRoot ) {
            m_DebugListLock.ExclusiveLock();
            RemoveEntryList( &pVRoot->m_DebugList );
            m_DebugListLock.ExclusiveUnlock();
        }
#endif

                // locking: for walking the list either m_lock.ShareLock must be
                // held or m_cs must be held.  For editting the list both 
                // m_lock.ExclusiveLock must be held and m_cs must be held.  
                // When making large changes (such as rebuilding the entire list)
                // m_cs should be held until all of the changes are complete.

                // lock for the vroot list
                CShareLockNH m_lock;

                // critical section used for making global changes on the vroot
                // list.  this is used to make sure that only one thread can editting
                // the list at a time
                CRITICAL_SECTION m_cs;

                // our context pointer
                void *m_pContext;

                // the path to our metabase area
                WCHAR m_wszRootPath[MAX_VROOT_PATH];
                DWORD m_cchRootPath;

                // have we been initialized?
                BOOL m_fInit;

        // are we shutting down?
        BOOL m_fShuttingDown;

                // function to create a new vroot object
                PFNCREATE_VROOT m_pfnCreateVRoot;

                // function to call when the vroot table is rescanned
                PFN_VRTABLE_SCAN_NOTIFY m_pfnScanNotify;

                // the list of vroots
                TFList<CVRoot> m_listVRoots;

                // this RW lock is used to figure out when all of the VRoot objects
                // have shutdown.  They hold a ShareLock on it for their lifetime,
                // so the CVRootTable can grab an ExclusiveLock to wait for all of
                // the VRoot objects to disappear.
                CShareLockNH m_lockVRootsExist;

                // these guys need access to m_lockVRootsExist
                friend void CVRoot::Init(LPCSTR, CVRootTable *, LPCWSTR, BOOL);
                friend CVRoot::~CVRoot();
};

//
// this is a templated version of CIISVRootTable.  You tell it the version of
// CVRoot that you are using, and the context type that you are using.  
//
// template arguments:
//  _CVRoot - a subclass of CVRoot that you'll be using
//  _context_type - the type that you'll be using for context information.
//                  this must be castable to void *.
//
template <class _CVRoot, class _context_type>
class CIISVRootTable {
        public:
                CIISVRootTable(_context_type pContext,
                               PFN_VRTABLE_SCAN_NOTIFY pfnScanNotify) : 
                        impl((void *) pContext, 
                             CIISVRootTable<_CVRoot, _context_type>::CreateVRoot, pfnScanNotify) 
                {
                }
                HRESULT Initialize(LPCSTR pszMBPath, BOOL fUpgrade ) {
                        return impl.Initialize(pszMBPath, fUpgrade);
                }
                HRESULT Shutdown(void) {
                        return impl.Shutdown();
                }
                HRESULT FindVRoot(LPCSTR pszPath, CRefPtr2<_CVRoot> *ppVRoot) {
                        return impl.FindVRoot(pszPath, (VROOTPTR *) ppVRoot);
                }
                HRESULT EnumerateVRoots(void *pEnumContext, 
                                                                PFN_VRENUM_CALLBACK pfnCallback) 
                {
                        return impl.EnumerateVRoots(pEnumContext, pfnCallback);
                }
        private:
                static VROOTPTR CreateVRoot(void *pContext, 
                                            LPCSTR pszVRootName, 
                                            CVRootTable *pVRootTable, 
                                            LPCWSTR pwszConfigPath,
                                            BOOL fUpgrade) 
                {                                                               
                        // create the vroot object
                        CRefPtr2<_CVRoot> pVRoot = new _CVRoot;
                        // initialize it
                        pVRoot->Init((_context_type) pContext, 
                                                 pszVRootName, 
                                                 pVRootTable,
                                                 pwszConfigPath,
                                                 fUpgrade );
                        return (_CVRoot *)pVRoot;
                }

                CVRootTable impl;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\xmemwrpr.h ===
/*++
Copyright (c) 1998 Microsoft Corporation
All rights reserved.

Module:

    xmemwrpr.h

Abstract:

    Wrapper of exchmem.  

    User of this wrapper: you should create the heap using
    ExchMHeapCreate before allocating any memory from EXCHMEM.
    You should destroy the heap using ExchMHeapDestroy.

    For raw memory allocation from heap, you should use PvAlloc,
    PvRealloc and FreePv functions.

    For object creation, unless you overload new yourself in
    the class defintion, using "new" will go to EXCHMEM, using
    "XNEW" will go to EXCHMEM while at the same time catch the
    file and line information for that allocation ( this is
    for debug version only )
                        
Authors:

    KangYan      Kangrong Yan     Sept. 29, 1998

History:
    09/29/98    KangYan      Created
--*/
#if !defined(_XMEMWRPR_H_)
#define _XMEMWRPR_H_

#include <exchmem.h>
#include <dbgtrace.h>

//
// Define number of exchmem heaps if not already defined
//
#if !defined(NUM_EXCHMEM_HEAPS)
#define NUM_EXCHMEM_HEAPS   0
#endif

//
// Macros for major heap allocation functions. ( We follow
// exchange store's convention here )
//
#if defined( DEBUG )
#define PvAlloc(_cb)                    ExchMHeapAllocDebug(_cb, __FILE__, __LINE__)
#define PvRealloc(_pv, _cb)             ExchMHeapReAllocDebug(_pv, _cb, __FILE__, __LINE__)
#define FreePv(_pv)                     ExchMHeapFree(_pv)
#else
#define PvAlloc(_cb)                    ExchMHeapAlloc(_cb)
#define PvRealloc(_pv, _cb)             ExchMHeapReAlloc(_pv, _cb)
#define FreePv(_pv)                     ExchMHeapFree(_pv)
#endif

//
// Operator XNEW, XDELETE are defined to replace "new" where xchmem wants to 
// be used so that we can pass in file name and line number of each allocation
// to make catching leaks much easier in debug builds.  In rtl builds,
// the file name or line number will not be passed in
//
#if defined( DEBUG )
#define XNEW new(__FILE__,__LINE__)
#else
#define XNEW new
#endif

#define XDELETE  delete

// 
// Overload global new operators 
//
__inline void * __cdecl operator new(size_t size, char *szFile, unsigned int uiLine )
{
    void *p = ExchMHeapAllocDebug( size, szFile, uiLine );
    SetLastError( p? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY );
    return p;
}

__inline void * __cdecl operator new( size_t size )
{
    void *p = ExchMHeapAlloc( size );
    SetLastError( p? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY );
    return p;
}

//
// Overload global delete operator, one version only
//
__inline void __cdecl operator delete( void *pv )
{
    ExchMHeapFree( pv );
    SetLastError( NO_ERROR );
}

//
// Create creation wrappers
//
__inline BOOL  CreateGlobalHeap( DWORD cHeaps, DWORD dwFlag, DWORD dwInit, DWORD dwMax ) {
    if ( ExchMHeapCreate( cHeaps, dwFlag, dwInit, dwMax ) ) {
        SetLastError( NO_ERROR );
        return TRUE;
    } else {
        _ASSERT( 0 );
        return FALSE;
    }
}

__inline BOOL DestroyGlobalHeap() {
    if ( ExchMHeapDestroy() ) {
        return TRUE;
    } else {
        _ASSERT( 0 );
        return FALSE;
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\build\paths.inc ===
#
#  Places all of the internet binaries into the inetsrv tree.
#  Also establishes some standard conventions used across the project.
#

#
# Override IISBASEDIR if you're one of those weirdos that didn't
# enlist the IIS project into the correct directory.
#

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

STAXBASE=$(IISBASEDIR)\svcs
STAXINC=$(IISBASEDIR)\staxinc
STAXCORE=$(STAXBASE)\staxcore
STAXCORETARGET=$(STAXCORE)\$(_OBJ_DIR)
STAXCORELIBPATH=$(STAXCORETARGET)\$(TARGET_DIRECTORY)

!if [mkdir $(STAXCORETARGET)\$(TARGET_DIRECTORY)]
!endif


!if "$(FREEBUILD)"=="1"
### message **** FREE BUILD ***
STAXFLAVOR=rtl
!else
### message **** DEBUG BUILD ***
### DEBUG_CRTS=1
STAXFLAVOR=dbg
!endif
BUFFER_OVERFLOW_CHECKS=1 
USE_MSVCRT=1

!ifdef BUILD_ALT_DIR
ALT_PROJECT_TARGET=$(BUILD_ALT_DIR)
!endif


## Note, .hlp file suggests that this be done in the environment
## and not in the sources file...
## "You usually do this in your environment, not in your sources file.
## You should do this on your build machine rather than on all of your
## developers' machines because they probably want the symbols there.
## It's easier to track. The debugger does not have to do all this hand
## waving to find the debug symbolic files that match the images themselves."
NTDBGFILES=1

NTDEBUGTYPE=both

LINKER_FLAGS=-merge:.VTABLE=.text -merge:RODATA=.text -merge:.rdata=.text -merge:.data1=.data -merge:.SHARED1=.SHARED

##
## Default system libraries
##

#
# We'll use our own COFFBASE.TXT and PLACEFIL.TXT, thank you very much.
#
## xxx: Need to merge coffbase.txt?

!IFNDEF COFFBASE_TXT_FILE
COFFBASE_TXT_FILE=$(IISBASEDIR)\coffbase.txt
!ENDIF

!IFNDEF BINPLACE_PLACEFILE
BINPLACE_PLACEFILE=$(IISBASEDIR)\staxinc\build\placefil.txt
!ENDIF

# This used to have the -y option.  Now, inetsrv binaries are binplaced
# to retail, so the symbols should be binplaced to symbols\retail.
# The -y switch causes the symbols to be binplaced to the wrong directory.

### BINPLACE_FLAGS=$(BINPLACE_FLAGS)

# enable building legoizable binaries
!IFNDEF IIS_NO_BBT
NTBBT=1
!ENDIF

!IFNDEF IIS_NO_PDB
USE_PDB=1
!ENDIF

!IF $(386)
!IFNDEF IIS_NO_SYM
USE_MAPSYM=1
!ENDIF
!ENDIF

!if 0
# (DISABLED)


#
# ENABLE WARNING LEVEL 3, TREAT WARNINGS AS ERRORS
#

!IFNDEF MSC_WARNING_LEVEL
## XXX: only enable /W3
##MSC_WARNING_LEVEL=/W3 /WX
MSC_WARNING_LEVEL=/W3
!ENDIF

#
# DON'T ALLOW ANYONE TO DISABLE WARNINGS AS ERRORS.
#
# IF ANY OF THE {PLATFORM}_WARNING_LEVEL MACROS ARE DEFINED WITHOUT
# THE /WX SWITCH, APPEND /WX TO THE MACRO AND WHINE ABOUT IT.
#

!IFDEF 386_WARNING_LEVEL
! IF ("$(386_WARNING_LEVEL:/WX=X)" == "$(386_WARNING_LEVEL)") && ("$(386_WARNING_LEVEL:-WX=X)" == "$(386_WARNING_LEVEL)")
!  MESSAGE 386_WARNING_LEVEL DEFINED WITHOUT /WX
386_WARNING_LEVEL=$(386_WARNING_LEVEL) /WX
! ENDIF
!endif

!ifdef AMD64_WARNING_LEVEL
! if ("$(AMD64_WARNING_LEVEL:/WX=x)" == "$(AMD64_WARNING_LEVEL)") && ("$(AMD64_WARNING_LEVEL:-WX=x)" == "$(AMD64_WARNING_LEVEL)")
!  message AMD64_WARNING_LEVEL defined without /WX
AMD64_WARNING_LEVEL=$(AMD64_WARNING_LEVEL) /WX
! endif
!endif

!ifdef IA64_WARNING_LEVEL
! if ("$(IA64_WARNING_LEVEL:/WX=x)" == "$(IA64_WARNING_LEVEL)") && ("$(IA64_WARNING_LEVEL:-WX=x)" == "$(IA64_WARNING_LEVEL)")
!  message IA64_WARNING_LEVEL defined without /WX
IA64_WARNING_LEVEL=$(IA64_WARNING_LEVEL) /WX
! endif
!endif

!endif


#
# Win95 Chokes if the subsystem version is 5.00
#

###SUBSYSTEM_VERSION=5.00
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\transmem.h ===
//-----------------------------------------------------------------------------
//
//  File:        TRANSMEM.H
//
//  Copyright Microsoft Corporation 1997, All Rights Reserved.
//
//  Owner: NIKOS
//
//  Description: This file contains memory routines and macros for using 
//               EXCHMEM as a dynamic memory allocator. If your object can
//               be made fixed in size, it may be more appropriate to use
//               CPool especially if your object is allocated/freed often.
//                
//               Note: CPool never releases (frees) objects, so some sort of
//                     free such objects may also be needed.
//
//  Modified 2/98 by mikeswa - Added Multi-heap support
//-----------------------------------------------------------------------------

#ifndef __TRANSMEM_H__
#define __TRANSMEM_H__

#include <exchmem.h>
#include <cpool.h>

#define HEAP_LOW_MEMORY_RESERVE 65536   // to be freed when we're low on memory

//define number of exchmem heaps if not already defined
#ifndef  NUM_EXCHMEM_HEAPS
#define  NUM_EXCHMEM_HEAPS   0
#endif  //NUM_EXCHMEM_HEAPS


//
// These three globals:
//
// HANDLE g_hTransHeap = NULL;
//
// must be declared somewhere in a C file so things will link properly. The macros
// declared use these to store heap handles, etc. to make things work.
//
#ifdef __cplusplus
extern "C" {
#endif
    extern HANDLE g_hTransHeap;
#ifdef __cplusplus
}
#endif

//
// TrHeapCreate needs to be called once at startup time to initialize Exchmem and create
// the heap.
//
#ifdef __cplusplus
__inline BOOL TrHeapCreate(DWORD dwFlags=0, DWORD dwInitialSize=1024000, DWORD dwMaxSize=0)
#else
__inline BOOL TrHeapCreate(DWORD dwFlags, DWORD dwInitialSize, DWORD dwMaxSize)
#endif
{
    if (g_hTransHeap)
        return FALSE;

    g_hTransHeap = ExchMHeapCreate(NUM_EXCHMEM_HEAPS, dwFlags, dwInitialSize, dwMaxSize);

    if (g_hTransHeap)
        return TRUE;
    else
        return FALSE;
}

//
// TrHeapDestroy() needs to be called once at shutdown time to free the heap and it's contents.
//
// Note: Because the heap is destroyed before the module is finished unloading, all objects that
//       allocated memory must be destroyed (with delete) before the module is unloaded. If not
//       done, nasty crashes will result. This is a BAD thing to do:
//
// CObject g_Object;
//
// CObject::~CObject()
// {
//     if (NULL != m_pBuffer)
//     {
//         TrFree(m_pBuffer);
//         m_pBuffer = NULL;
//     }
// }
//
// since ~CObject() will be called AFTER TrHeapDestroy, and TrFree will be called on a (destroyed) heap.
//
__inline BOOL TrHeapDestroy(void)
{
    BOOL b = TRUE;

    if (g_hTransHeap)
    {
        b = ExchMHeapDestroy();
        g_hTransHeap = NULL;
    }

    return b;
}

//
// TrCalloc: replacement for calloc()
//                    
__inline void * TrCalloc(unsigned int x, unsigned int y, char * szFile = __FILE__, unsigned int uiLine = __LINE__)
{
    return g_hTransHeap ? ExchMHeapAllocDebug(x*y, szFile, uiLine) : NULL;
}
        

//
// TrFree: replacement for free() 
__inline void TrFree(void *pv)
{
    if (g_hTransHeap)
    {
        ExchMHeapFree(pv);
    }
    else
    {
        // Our allocs / frees are out of sync.
#ifdef DEBUG
        DebugBreak();
#endif
    }
}

// TrMalloc: replacement for malloc()
__inline void * TrMalloc(unsigned int size, char * szFile = __FILE__, unsigned int uiLine = __LINE__)
{
    return g_hTransHeap ? ExchMHeapAllocDebug(size, szFile, uiLine) : NULL;
}

// TrRealloc: replacement for realloc()
__inline void * TrRealloc(void *pv, unsigned int size, char * szFile = __FILE__, unsigned int uiLine = __LINE__)
{
    return g_hTransHeap ? ExchMHeapReAllocDebug(pv, size, szFile, uiLine) : NULL;
}

#ifdef __cplusplus
#define TransCONST const
#else
#define TransCONST
#endif

// TrStrdupW: replacement for wcsdup()
__inline LPWSTR TrStrdupW(TransCONST LPWSTR pwszString)
{
    LPWSTR pwszTmp = NULL;
    
    if (NULL == g_hTransHeap || NULL == pwszString)
        return NULL;
    
    pwszTmp = (LPWSTR) ExchMHeapAlloc((wcslen(pwszString) + 1) * sizeof(WCHAR));
    if (NULL != pwszTmp)
        wcscpy(pwszTmp,pwszString);

    return pwszTmp;
}

// TrStrdupA: replacement for strdup()
__inline LPSTR TrStrdupA(TransCONST LPSTR pszString)
{
    LPSTR pszTmp = NULL;
    
    if (NULL == g_hTransHeap || NULL == pszString)
        return NULL;
    
    pszTmp = (LPSTR) ExchMHeapAlloc((strlen(pszString) + 1) * sizeof(CHAR));
    if (NULL != pszTmp)
        strcpy(pszTmp,pszString);

    return pszTmp;
}


#ifdef _UNICODE
#define TrStrdup(x) TrStrdupW(x)
#else
#define TrStrdup(x) TrStrdupA(x)
#endif

//
// Please use the pv* macros... defined here allocators may change over time and this will
// make it easy to change when needed.
//
#define pvMalloc(x)        TrMalloc(x, __FILE__, __LINE__)
#define FreePv(x)          TrFree(x)
#define pvCalloc(x,y)      TrCalloc(x,y, __FILE__, __LINE__)
#define pszStrdup(x)       TrStrdup(x)
#define pvRealloc(pv,size) TrRealloc(pv, size, __FILE__, __LINE__)

#ifdef __cplusplus
// Replacement for the default new() operator
__inline void * __cdecl operator new(size_t stAllocateBlock)
{
    return TrMalloc( stAllocateBlock );
}

// Replacement for the default new() operator that allows 
//specification of file and line #
// To use this allocator as your default allocator, simply use the following:
//#define new TRANSMEM_NEW
//NOTE: You must be careful when you redefine this macro... it may cause
//problems with overloaded new operators (a la CPOOL or STL).
#define TRANSMEM_NEW new(__FILE__, __LINE)
__inline void * __cdecl operator new(size_t stAllocateBlock, char * szFile, unsigned int uiLine)
{
    return TrMalloc( stAllocateBlock, szFile, uiLine );
}
// Replacement for the default delete() operator
__inline void __cdecl operator delete( void *pvMem )
{
    FreePv( pvMem );
}

#endif

// Convenient macro to set the pointer you freed to NULL as well
#define TRFREE(x) \
if (NULL != x) \
{ \
    FreePv(x); \
    x = NULL; \
}

// Convenient macro to set the pointer to the object to NULL as well
#define TRDELETE(x) \
if (NULL != x) \
{ \
    delete x; \
    x = NULL; \
}

#endif /* __TRANSMEM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\tran_evntlog.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        
    Copyright (C) 1998 Microsoft Corporation
    All rights reserved.

    File:       evntlog.h

    Abstract:   EventLog DLL interface

    Authors:    Hao Zhang

    History:    Oct 25, 1999
                
----------------------------------------------------------------------*/
#define TRAN_CAT_ROUTING_ENGINE                                      1
#define TRAN_CAT_CATEGORIZER                                         2
#define TRAN_CAT_CONNECTION_MANAGER                                  3
#define TRAN_CAT_QUEUE_ENGINE                                        4
#define TRAN_CAT_EXCHANGE_STORE_DRIVER                               5      
#define TRAN_CAT_SMTP_PROTOCOL                                       6
#define TRAN_CAT_NTFS_STORE_DRIVER                                   7

#define LOGEVENT_LEVEL_FIELD_ENGINEERING       7
#define LOGEVENT_LEVEL_MAXIMUM                 5
#define LOGEVENT_LEVEL_MEDIUM                  3
#define LOGEVENT_LEVEL_MINIMUM                 1
#define LOGEVENT_LEVEL_NONE                    0

#define LOGEVENT_FLAG_ALWAYS		   0x00000001
#define LOGEVENT_FLAG_ONETIME		   0x00000002
#define LOGEVENT_FLAG_PERIODIC	       0x00000003
// we use the lower 8 bits for various logging modes, and reserve the
// other 24 for flags
#define LOGEVENT_FLAG_MODEMASK         0x000000ff

// 100ns units between periodic event logs.  this can't be larger then 
// 0xffffffff
#define LOGEVENT_PERIOD (DWORD) (3600000000) // 60 minutes 

//
// setup DLL Export macros
//
#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif

#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif

/******************************************************************************/
DllExport
HRESULT TransportLogEvent(
    IN DWORD idMessage,
    IN WORD idCategory,
    IN WORD cSubstrings,
    IN LPCSTR *rgszSubstrings,
    IN WORD wType,
    IN DWORD errCode,
    IN WORD iDebugLevel,
    IN LPCSTR szKey,
    IN DWORD dwOptions);

DllExport
HRESULT TransportLogEventEx(
    IN DWORD idMessage,
    IN WORD idCategory,
    IN WORD cSubstrings,
    IN LPCSTR *rgszSubstrings,
    IN WORD wType,
    IN DWORD errCode,
    IN WORD iDebugLevel,
    IN LPCSTR szKey,
    IN DWORD dwOptions,
    DWORD iMessageString,
    HMODULE hModule);

DllExport
HRESULT TransportLogEventFieldEng(
    IN DWORD idMessage,
    IN WORD idCategory,
    IN LPCTSTR format,
    ...
    );
 
DllExport 
HRESULT TransportResetEvent(
    IN DWORD idMessage,
    IN LPCSTR szKey);

DllExport 
DWORD TransportGetLoggingLevel(
    IN WORD idCategory);

DllExport
HRESULT TransportLogEventInit ();

//
// Attention:
// Make sure that no other logging was called
// before calling this Deinit function
//
DllExport
HRESULT TransportLogEventDeinit ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\build\sources.inc ===
!if "$(FREEBUILD)"=="1"
### !message **** FREE BUILD ***
!else
C_DEFINES=$(C_DEFINES) -DDEBUG=1
!if !$(WIN64)
MSC_OPTIMIZATION=/Od
!endif
!endif

!ifdef TRACE_ENABLED
C_DEFINES=$(C_DEFINES) -DTRACE_ENABLED
!endif

INCLUDES=$(INCLUDES);$(STAXINC)\export;$(IISBASEDIR)\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\_dbgdump.h ===
//-----------------------------------------------------------------------------
//
//
//  File: _dbgext.h
//
//  Description: 
//      Defines macros for defining structures to dump in your CDB extension
//
//  Usage:
//      Create a head file that includes this file and defines your field
//      descriptors using only the following macros:
//
//      BIT MASKS:
//          BEGIN_BIT_MASK_DESCRIPTOR(BitMaskName) -
//              start bit mask descriptor
//          BIT_MASK_VALUE(Value) -
//              Give a defined value for a bit mask.  Uses #Value 
//              to describe the value.  If your bitmask values are
//              defined using #defines... then only the numerical
//              values will appear in the dump... use BIT_MASK_VALUE2
//              instead.
//          BIT_MASK_VALUE2(Value, Description) -
//              Give a value and description for a bit mask.
//          END_BIT_MASK_DESCRIPTOR
//              Mark the end of a bit mask descriptor
//
//      ENUMS:
//          BEGIN_ENUM_DESCRIPTOR(BitMaskName) -
//              start enum descriptor
//          ENUM_VALUE(Value) -
//              Give a defined value for a enum.  Uses #Value 
//              to describe the value.
//          ENUM_VALUE2(Value, Description) -
//              Give a value and description for a enum.
//          END__DESCRIPTOR -
//              Mark the end of a enum descriptor
//
//      STRUCTURES & CLASSES:
//          BEGIN_FIELD_DESCRIPTOR(FieldDescriptorName) - 
//              start field decscritor
//          FIELD3(FieldType, StructureName, FieldName) - 
//              define non-enum public field
//          FIELD4(FieldType, StructureName, FieldName, AuxInfo) - 
//              define enum public field
//              For FIELD4, you should pass one of the following to
//              to define the aux info:
//                  GET_ENUM_DESCRIPTOR(x)
//                  GET_BITMASK_DESCRIPTOR(x)
//              Where x is one of the values used to define a bit mask
//              or enum.
//              
//          END_FIELD_DESCRIPTOR -
//              Define end of field descriptors for class/struct
//
//      GLOBALS: - Used to tell ptdbgext what class/structures to dump
//          BEGIN_STRUCT_DESCRIPTOR -
//              Marks the begining of the global stuct descriptor
//          STRUCT(TypeName,FieldDescriptor) -
//              Defines a struct to dump.  TypeName is the name of the 
//              type, and FieldDescriptor is a name given in a 
//              BEGIN_FIELD_DESCRIPTOR.
//
//      NOTE: You must define bit masks & enums before classes and structures.  
//      You must also define the global STRUCT_DESCRIPTOR last.
//
//      **this include file with redefine the key words "protected" and "private"***
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef ___DBGEXT_H__FIRST_PASS_
#define ___DBGEXT_H__FIRST_PASS_

#ifndef PTDBGEXT_USE_FRIEND_CLASSES
//Needed to allow access to private members of classes
#define private public
#define protected public 
#endif //PTDBGEXT_USE_FRIEND_CLASSES

#define DEFINE_VALUE(VAL)  \
        {VAL, #VAL},
#define DEFINE_VALUE2(VAL, DESCRIPTION)  \
        {VAL, DESCRIPTION},

//---[ ENUM MACROS ]-----------------------------------------------------------
//
//
//  Description: Enum macro definitions.... used to define enum values for 
//      the dump command.
//
//  
//-----------------------------------------------------------------------------
#define GET_ENUM_DESCRIPTOR(ENUM_NAME) EnumValueDescrsOf_##ENUM_NAME
#define BEGIN_ENUM_DESCRIPTOR(ENUM_NAME) \
    ENUM_VALUE_DESCRIPTOR GET_ENUM_DESCRIPTOR(ENUM_NAME)[] = {
#define END_ENUM_DESCRIPTOR \
    0                       \
    };
#define ENUM_VALUE(VAL)  DEFINE_VALUE(VAL)
#define ENUM_VALUE2(VAL, DESCRIPTION)  DEFINE_VALUE2(VAL, DESCRIPTION)

//Bit masks
//---[ BIT MASK MACROS ]-------------------------------------------------------
//
//
//  Description: Bit mask macro definitions... used to define bit mask values
//      for the dump command.
//
//  
//-----------------------------------------------------------------------------
#define GET_BIT_MASK_DESCRIPTOR(BITMAP_NAME) BitmapValueDescrsOf_##BITMAP_NAME
#define BEGIN_BIT_MASK_DESCRIPTOR(BITMAP_NAME) \
    BIT_MASK_DESCRIPTOR GET_BIT_MASK_DESCRIPTOR(BITMAP_NAME)[] = {
#define END_BIT_MASK_DESCRIPTOR   \
    0                             \
    };
#define BIT_MASK_VALUE(VAL)  DEFINE_VALUE(VAL)
#define BIT_MASK_VALUE2(VAL, DESCRIPTION)  DEFINE_VALUE2(VAL, DESCRIPTION)

//---[ FIELD MACROS ]----------------------------------------------------------
//
//
//  Description: Field descriptor macros.... used to define fields from structures
//      and classes to dump.
//
//  
//-----------------------------------------------------------------------------
//Field descriptor... used to define structures and classes
#define BEGIN_FIELD_DESCRIPTOR(x) \
    FIELD_DESCRIPTOR x[] = {
#define END_FIELD_DESCRIPTOR \
    NULL_FIELD               \
    };
#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL},
#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,(VOID *) AuxInfo},
#ifdef PTDBGEXT_USE_FRIEND_CLASSES
#define FIELD3_PRIV(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , 0 ,NULL},
#define FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , 0,(VOID *) AuxInfo},
#else //PTDBGEXT_USE_FRIEND_CLASSES not defined
#define FIELD3_PRIV(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL},
#define FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,(VOID *) AuxInfo},
#endif //PTDBGEXT_USE_FRIEND_CLASSES

//Struct descriptor
#define BEGIN_STRUCT_DESCRIPTOR \
    STRUCT_DESCRIPTOR Structs[] = {
#define END_STRUCT_DESCRIPTOR \
    0               \
    };
#define STRUCT(StructTypeName,FieldDescriptors) \
        { #StructTypeName,sizeof(StructTypeName),FieldDescriptors},

#define EMBEDDED_STRUCT(StructTypeName, FieldDescriptors, EmbeddedStructName) \
    STRUCT_DESCRIPTOR EmbeddedStructName[] = \
        { STRUCT(StructTypeName, FieldDescriptors) 0 };

#else //___DBGEXT_H__FIRST_PASS_ already defined...at least 2nd pass
#ifdef PTDBGEXT_USE_FRIEND_CLASSES  //if not set, do not do the multipass stuff
#ifndef ___DBGEXT_H__
#define ___DBGEXT_H__
//
//      As an alternative to using #defining private and protected to public, you
//      may wish to use the friend class method of accessing the structure offsets.
//      (If, for example, the organization of your classes are changed as a result
//      of those #defining private and prctected).
//
//      To do so, #define PTDBGEXT_USE_FRIEND_CLASSES and use the following 
//      additional macros:
//
//          FIELD3_PRIV(FieldType, StructureName, FieldName) - 
//              define non-enum private field
//          FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) - 
//              define enum private field
//
//      If you use FIELD?_PRIV, then you are accessing private members of a
//      class.  In this case, you need to create a void (void) initialization 
//      function and assign it to g_pExtensionInitRoutine.  It should be a 
//      member function of class that is a friend of all the classes you are
//      interested in debugging.  Suppose your field descriptors are defined 
//      in mydump.h, you would need to create an initialization function as 
//      follows:
//
//          #include <mydump.h> //initial definition
//          ...
//          void CMyDebugExt::Init(void) {
//          #include <mydump.h>
//          }

//undefine previously defined macros
#undef BEGIN_FIELD_DESCRIPTOR
#undef END_FIELD_DESCRIPTOR
#undef FIELD3
#undef FIELD4
#undef FIELD3_PRIV
#undef FIELD4_PRIV
#undef GET_ENUM_DESCRIPTOR
#undef BEGIN_ENUM_DESCRIPTOR
#undef END_ENUM_DESCRIPTOR
#undef GET_BIT_MASK_DESCRIPTOR
#undef BEGIN_BIT_MASK_DESCRIPTOR
#undef END_BIT_MASK_DESCRIPTOR
#undef BEGIN_STRUCT_DESCRIPTOR
#undef STRUCT
#undef END_STRUCT_DESCRIPTOR
#undef DEFINE_VALUE
#undef DEFINE_VALUE2
#undef EMBEDDED_STRUCT

#define GET_ENUM_DESCRIPTOR(ENUM_NAME) 
#define BEGIN_ENUM_DESCRIPTOR(ENUM_NAME)
#define END_ENUM_DESCRIPTOR 
#define GET_BIT_MASK_DESCRIPTOR(BITMAP_NAME) 
#define BEGIN_BIT_MASK_DESCRIPTOR(BITMAP_NAME)
#define END_BIT_MASK_DESCRIPTOR 
#define DEFINE_VALUE(VAL) 
#define DEFINE_VALUE2(VAL, DESCRIPTION) 
#define BEGIN_STRUCT_DESCRIPTOR
#define STRUCT(x, y)
#define END_STRUCT_DESCRIPTOR
#define EMBEDDED_STRUCT(x, y, z)

#define BEGIN_FIELD_DESCRIPTOR(x) \
    pfd = x; 
#define END_FIELD_DESCRIPTOR \
    pfd = NULL;

#define FIELD3(FieldType,StructureName, FieldName) \
    pfd++;
#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
    pfd++;

//Use Field?_PRIV when dealing with private memebers.  Requires 2 passes
#define FIELD3_PRIV(FieldType,StructureName, FieldName) \
        pfd->Offset = FIELD_OFFSET(StructureName, FieldName); \
        pfd++;

#define FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) \
        pfd->Offset = FIELD_OFFSET(StructureName, FieldName); \
        pfd++;

    FIELD_DESCRIPTOR *pfd = NULL;  //Variable declaration in INIT function
#else //whoops
#pragma message "WARNING: _dbgext.h included more than twice"
#endif //___DBGEXT_H__
#endif //PTDBGEXT_USE_FRIEND_CLASSES
#endif //___DBGEXT_H__FIRST_PASS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\aqadmtyp.h ===
/*
        @doc ADVANCED QUEUEING DATA TYPES
        @module aqadmtyp.h | Data types used in advanced queueing interfaces
*/

/*++/

Copyright (c) 1999  Microsoft Corporation

Module Name:

    aqadmtyp.h

Abstract:

    This module defines data types used in advanced queueing interfaces


--*/
#ifndef __AQADMTYP_H__
#define __AQADMTYP_H__

#ifdef __midl
#define MIDL(x) x
#else
#define MIDL(x)
#endif

// max *required* size of buffer returned by implementor of QAPI
// If the size of the requested information exceeds this constant,
// then QAPI *may* truncate the buffer.
#define QUEUE_ADMIN_MAX_BUFFER_REQUIRED  200

// @enum QUEUE_ADMIN_VERSIONS | Enum specify current and supported
//  queue admin versions.
// @emem CURRENT_QUEUE_ADMIN_VERSION | The current queue admin version
//  that all structures should have this value in their dwVersion field.
typedef enum tagQUEUE_ADMIN_VERSIONS {
    CURRENT_QUEUE_ADMIN_VERSION = 4,
} QUEUE_ADMIN_VERSIONS;


// 
// @struct MESSAGE_FILTER | Structure describing criteria for selecting 
// messages
// @field DWORD | dwVersion | Version of MESSAGE_FILTER struct - must be CURRENT_QUEUE_ADMIN_VERSION
// @field DWORD | fFlags | <t MESSAGE_FILTER_FLAGS> indicating which 
//  fields of filter are specified
// @field LPCWSTR | szMessageId | Message ID, as returned in a MESSAGE_INFO 
// struct
// @field LPCWSTR | szMessageSender | Messages sent by this sender match
// @field LPCWSTR | szMessageRecipient | Messages sent to this recipient match
// @field DWORD | dwLargerThanSize | Messages larger than this value match
// @field SYSTEMTIME | stOlderThan | Messages older than this value match
//
typedef struct tagMESSAGE_FILTER {
                    DWORD dwVersion; 
                    DWORD fFlags;
    MIDL([string])  LPCWSTR szMessageId;
    MIDL([string])  LPCWSTR szMessageSender;
    MIDL([string])  LPCWSTR szMessageRecipient;
                    DWORD  dwLargerThanSize;
                    SYSTEMTIME stOlderThan;
} MESSAGE_FILTER, *PMESSAGE_FILTER;

// @enum MESSAGE_FILTER_FLAGS | Type specifying the type of filter 
// requested.  These are bitflags and can be OR'd together.
// @emem MF_MESSAGEID | The <e MESSAGE_FILTER.szMessageId> is specified
// @emem MF_SENDER | The <e MESSAGE_FILTER.szMessageSender> is specified
// @emem MF_RECIPIENT | The <e MESSAGE_FILTER.szMessageRecipient> is specified
// @emem MF_SIZE | The <e MESSAGE_FILTER.dwLargerThanSize> is specified
// @emem MF_TIME | The <e MESSAGE_FILTER.stOlderThan> is specified
// @emem MF_FROZEN | The <e MESSAGE_FILTER.fFrozen> is specified
// @emem MF_FAILED | Selects messages that have had a failed delivery attempt
// @emem MF_INVERTSENSE | If set, indicates that the negation of the filter
// @emem MF_ALL | Select all messages
typedef enum tagMESSAGE_FILTER_FLAGS {
                    MF_MESSAGEID                = 0x00000001,
                    MF_SENDER                   = 0x00000002,
                    MF_RECIPIENT                = 0x00000004,
                    MF_SIZE                     = 0x00000008,
                    MF_TIME                     = 0x00000010,
                    MF_FROZEN                   = 0x00000020,
                    MF_FAILED                   = 0x00000100,
                    MF_ALL                      = 0x40000000,
                    MF_INVERTSENSE              = 0x80000000
} MESSAGE_FILTER_FLAGS;

// @enum MESSAGE_ACTION | Type specifying possible administrative actions
//      that may be applied to messages in a virtual server, link, or queue
// @emem MA_DELETE | Remove message from the virtual server, link, or queue
// @emem MA_DELETE_SILENT | Remove message without generating an NDR
// @emem MA_FREEZE | Freeze the message in the virtual server, link, or queue
// @emem MA_THAW | Un-freeze the message in the virtual server, link, or queue
// @emem MA_COUNT | Null operation, does not affect messages, but does return count.
typedef enum tagMESSAGE_ACTION {
                    MA_THAW_GLOBAL              = 0x00000001, 
                    MA_COUNT                    = 0x00000002,
                    MA_FREEZE_GLOBAL            = 0x00000004,
            		MA_DELETE                   = 0x00000008,
                    MA_DELETE_SILENT            = 0x00000010
} MESSAGE_ACTION;

// @enum MESSAGE_ENUM_FILTER_TYPE | Type specifying the type of filter 
// requested.  These are bitflags and can be OR'd together.
// @emem MEF_FIRST_N_MESSAGES | Return the first 
// <e MESSAGE_ENUM_FILTER.cMessages> messages
// @emem MEF_N_LARGEST_MESSAGES | Return the largest 
// <e MESSAGE_ENUM_FILTER.cMessages> messages
// @emem MEF_N_OLDEST_MESSAGES | Return the oldest
// <e MESSAGE_ENUM_FILTER.cMessages> messages
// @emem MF_SENDER | The <e MESSAGE_ENUM_FILTER.szMessageSender> is specified
// @emem MF_RECIPIENT | The <e MESSAGE_ENUM_FILTER.szMessageRecipient> is specified
// @emem MEF_OLDER_THAN | Return messages older than 
// <e MESSAGE_ENUM_FILTER.stDate>
// @emem MEF_LARGER_THAN | Return messages larger than 
// <e MESSAGE_ENUM_FILTER.cbSize> bytes
// @emem MEF_FROZEN | Return messages that are frozen
// @emem MEF_INVERTSENSE  | Invert the meaning of the filter
// @emem MEF_ALL | Select all messages
// @emem MEF_FAILED | Return only messages that have had failed delivery
// attempts.
typedef enum tagMESSAGE_ENUM_FILTER_TYPE {
                    MEF_FIRST_N_MESSAGES        = 0x00000001,
                    MEF_SENDER                  = 0x00000002,
                    MEF_RECIPIENT               = 0x00000004,
                    MEF_LARGER_THAN             = 0x00000008,
                    MEF_OLDER_THAN              = 0x00000010,
                    MEF_FROZEN                  = 0x00000020,
                    MEF_N_LARGEST_MESSAGES      = 0x00000040,
                    MEF_N_OLDEST_MESSAGES       = 0x00000080,
                    MEF_FAILED                  = 0x00000100,
                    MEF_ALL                     = 0x40000000,
                    MEF_INVERTSENSE             = 0x80000000,
} MESSAGE_ENUM_FILTER_TYPE;

// @struct MESSAGE_ENUM_FILTER | Structure describing criteria for enumerating
// messages
// @field DWORD | dwVersion | Version of filter - must be CURRENT_QUEUE_ADMIN_VERSION
// @field MESSAGE_ENUM_FILTER_TYPE | mefType | <t MESSAGE_ENUM_FILTER_TYPE> Flags for filter.
// @field DWORD | cMessages | Number of messages to return
// @field DWORD | cbSize | Size parameter of messages
// @field DWORD | cSkipMessages | Number of messages at front of queue to skip.
//  This is provided to allow "paged" queries to the server.
// @field SYSTEMTIME | stDate | Date/Time parameter of messages
typedef struct tagMESSAGE_ENUM_FILTER {
                    DWORD dwVersion;
                    DWORD mefType;
                    DWORD cMessages;
                    DWORD cbSize;
                    DWORD cSkipMessages;
                    SYSTEMTIME stDate;
    MIDL([string])  LPCWSTR szMessageSender;
    MIDL([string])  LPCWSTR szMessageRecipient;
} MESSAGE_ENUM_FILTER, *PMESSAGE_ENUM_FILTER;


// @enum LINK_INFO_FLAGS | Type specifying the state of the link 
// @emem LI_ACTIVE | Link has an active connection transferring mail
// @emem LI_READY | Link is ready for a connection, but there are no connections
// @emem LI_RETRY | Link is waiting for the retry interval to elapse
// @emem LI_SCHEDULED | Link is waiting for the next scheduled time
// @emem LI_REMOTE | Link is to be activated by remote server. A connection
//  will not be made unless requested by a remote server.
// @emem LI_FROZEN | Link was frozen by administrative action
// @emem LI_TYPE_REMOTE_DELIVERY | Messages on link are being delivered
//  remotely.  This is the default type of link.
// @emem LI_TYPE_LOCAL_DELIVERY | Messages on this link are being delivered
//  locally.
// @emem LI_TYPE_PENDING_CAT | Messages on this link are pending message
//  categorization.
// @emem LI_TYPE_PENDING_ROUTING | Messages on this link have not been routed
//  to their next hop.
// @emem LI_TYPE_CURRENTLY_UNREACHABLE | Messages on this link do not have an 
//  available route to their final destination.  This is due to transient 
//  network or server errors.  These messages will be retried when a route
//  becomes available.
// @emem LI_TYPE_INTERNAL | This link is an internal link not described 
//  by the above.
typedef enum tagLINK_INFO_FLAGS {
                    LI_ACTIVE                       = 0x00000001,
                    LI_READY                        = 0x00000002,
                    LI_RETRY                        = 0x00000004,
                    LI_SCHEDULED                    = 0x00000008,
                    LI_REMOTE                       = 0x00000010,
                    LI_FROZEN                       = 0x00000020,
                    LI_TYPE_REMOTE_DELIVERY         = 0x00000100,
                    LI_TYPE_LOCAL_DELIVERY          = 0x00000200,
                    LI_TYPE_PENDING_ROUTING         = 0x00000400,
                    LI_TYPE_PENDING_CAT             = 0x00000800,
                    LI_TYPE_CURRENTLY_UNREACHABLE   = 0x00001000,
                    LI_TYPE_DEFERRED_DELIVERY       = 0x00002000,
                    LI_TYPE_INTERNAL                = 0x00004000,
                    LI_TYPE_PENDING_SUBMIT          = 0x00008000,
} LINK_INFO_FLAGS;

// @enum LINK_ACTION | Actions that can be applied to a link
// @emem LA_KICK | Force a connection to be made for this link. 
//  This will even work for connections pending retry or a scheduled connection.
// @emem LA_FREEZE | Prevent outbound connections from being made for a link
// @emem LA_THAW | Undo a previous admin freeze action.
typedef enum tagLINK_ACTION {
                    LA_INTERNAL                 = 0x00000000,
                    LA_KICK                     = 0x00000001,
                    LA_FREEZE                   = 0x00000020,
                    LA_THAW                     = 0x00000040,
} LINK_ACTION;

//
// @struct LINK_INFO | Structure describing state of a virtual server AQ link
// @field DWORD | dwVersion | Version of LINK_INFO structure - will be CURRENT_QUEUE_ADMIN_VERSION
// @field LPWSTR | szLinkName | Name of next-hop
// @field DWORD | cMessages | Number of messages queued up for this link
// @field DWORD | fStateFlags | <t LINK_INFO_FLAGS> indicating Link State
// @field SYSTEMTIME | stNextScheduledConnection | The time at which the next
// connection will be attempted.
// @field SYSTEMTIME | stOldestMessage | The oldest message on this link
// @field ULARGE_INTEGER | cbLinkVolume | Total number of bytes on link
// @field LPWSTR | szLinkDN | DN associated with this link by routing.  Can be NULL.
// @field LPWSTR | szExtendedStateInfo | If present, this provides additional state
// information about why a link is in <t LI_RETRY> state.
// @field DWORD | dwSupportedLinkActions | Tells which <t LINK_ACTIONS> are supported
// by this link.
typedef struct tagLINK_INFO {
                    DWORD dwVersion; 
    MIDL([string])  LPWSTR szLinkName;
                    DWORD cMessages;
                    DWORD fStateFlags;
                    SYSTEMTIME stNextScheduledConnection;
                    SYSTEMTIME stOldestMessage;
                    ULARGE_INTEGER cbLinkVolume;
    MIDL([string])  LPWSTR szLinkDN;
    MIDL([string])  LPWSTR szExtendedStateInfo;
                    DWORD  dwSupportedLinkActions;
} LINK_INFO, *PLINK_INFO;

//
// @struct QUEUE_INFO | Structure describing state of a virtual server link 
// queue
// @field DWORD | dwVersion | Version of LINK_INFO structure - will be CURRENT_QUEUE_ADMIN_VERSION
// @field LPWSTR | szQueueName | Name of queue
// @field LPWSTR | szLinkName | Name of link that is servicing this queue
// @field DWORD | cMessages | Number of messages on this queue
// @field ULARGE_INTEGER | cbQueueVolume | Total number of bytes on queue
// @field DWORD | dwMsgEnumFlagsSupported | The types of message enumeration supported
typedef struct tagQUEUE_INFO {
                    DWORD dwVersion; 
    MIDL([string])  LPWSTR szQueueName;
    MIDL([string])  LPWSTR szLinkName;
                    DWORD cMessages;
                    ULARGE_INTEGER cbQueueVolume;
                    DWORD dwMsgEnumFlagsSupported;
} QUEUE_INFO, *PQUEUE_INFO;

//
// @enum AQ_MESSAGE_FLAGS | Flags describing message properties
// @flag MP_HIGH | High Priority Message
// @flag MP_NORMAL | Normal Priority Message
// @flag MP_LOW | Low Priority Message
// @flag MP_MSG_FROZEN | Message has been frozen by admin.
// @flag MP_MSG_RETRY | Delivery has been attempted and failed at least once
//  for this message.
// @flag MP_MSG_CONTENT_AVAILABLE | The content for this message can be 
//  accessed through the QAPI.
typedef enum tagAQ_MESSAGE_FLAGS {
                    MP_HIGH                     = 0x00000001,
                    MP_NORMAL                   = 0x00000002,
                    MP_LOW                      = 0x00000004,
                    MP_MSG_FROZEN               = 0x00000008,
                    MP_MSG_RETRY                = 0x00000010,
                    MP_MSG_CONTENT_AVAILABLE    = 0x00000020,
} AQ_MESSAGE_FLAGS;

// @struct MESSAGE_INFO | Structure describing a single mail message
// @field DWORD | dwVersion | Version of LINK_INFO structure - will be CURRENT_QUEUE_ADMIN_VERSION
// @field LPWSTR | szMessageId | Message ID
// @field LPWSTR | szSender | Sender Address, from "From:" header
// @field LPWSTR | szSubject | Message Subject
// @field DWORD | cRecipients | Number of recipients
// @field LPWSTR | szRecipients | Recipient Addresses, from "To:" header
// @field DWORD | cCCRecipients | Number of CC recipients
// @field LPWSTR | szCCRecipients | CC Recipient Addresses, from "CC:" header
// @field DWORD | cBCCRecipients | Number of BCC recipients
// @field LPWSTR | szBCCRecipients | BCC Recipient Addresses, from "BCC:" header
// @field DWORD | cbMessageSize | size of message in bytes
// @field DWORD | fMsgFlags | <t AQ_MESSAGE_FLAGS> describing message properties.
// @field SYSTEMTIME | stSubmission | Time of message submission
// @field SYSTEMTIME | stReceived | Time message was received by this server
// @field SYSTEMTIME | stExpiry | Time message will expire by if not delivered
// to all recipients, thus generating an NDR
// @field DWORD | cFailures | The number of failured delivery attempts for 
// this message
// @field DWORD | cEnvRecipients | The number of envelope recipeints
// @field DWORD | cbEnvRecipients | The size in bytes of the envelope recipients
// @field WCHAR * | mszEnvRecipients | A multi-string UNICODE buffer containing
// a NULL-terminated string for each recipient.  The buffer itself is terminated
// by an additional NULL.  Each recipient string will be formatted in the proxy
// address format of 'addr-type ":" address'.  The addr-type should match
// the address type found in the DS (ie SMTP).  The address should be returned 
// in it's native format.
typedef struct tagMESSAGE_INFO {
                                    DWORD dwVersion; 
    MIDL([string])                  LPWSTR szMessageId;
    MIDL([string])                  LPWSTR szSender;
    MIDL([string])                  LPWSTR szSubject;
                                    DWORD cRecipients;
    MIDL([string])                  LPWSTR szRecipients;
                                    DWORD cCCRecipients;
    MIDL([string])                  LPWSTR szCCRecipients;
                                    DWORD cBCCRecipients;
    MIDL([string])                  LPWSTR szBCCRecipients;
                                    DWORD fMsgFlags;
                                    DWORD cbMessageSize;
                                    SYSTEMTIME stSubmission;
                                    SYSTEMTIME stReceived;
                                    SYSTEMTIME stExpiry;
                                    DWORD cFailures;
                                    DWORD cEnvRecipients;
                                    DWORD cbEnvRecipients;
    MIDL([size_is(cbEnvRecipients/sizeof(WCHAR))]) WCHAR *mszEnvRecipients;
} MESSAGE_INFO, *PMESSAGE_INFO;

typedef enum tagQUEUELINK_TYPE {
                    QLT_QUEUE,
                    QLT_LINK,
                    QLT_NONE
} QUEUELINK_TYPE;

typedef struct tagQUEUELINK_ID {
                    GUID            uuid;
    MIDL([string])  LPWSTR          szName;
                    DWORD           dwId;
                    QUEUELINK_TYPE  qltType;
} QUEUELINK_ID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\aqdll.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdll.h
//
//  Description:    Declarations for non-COM functionality exported in
//      aqueue.dll. This file is included by aqueue.h, so no one should
//      need to include this file directly.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQDLL_H__
#define __AQDLL_H__

#define AQ_DLL_NAME "aqueue.dll"
#define AQ_INITIALIZE_FUNCTION_NAME "HrAdvQueueInitialize"
#define AQ_DEINITIALIZE_FUNCTION_NAME "HrAdvQueueDeinitialize"
#define AQ_INITIALIZE_FUNCTION_NAME_EX "HrAdvQueueInitializeEx"
#define AQ_DEINITIALIZE_FUNCTION_NAME_EX "HrAdvQueueDeinitializeEx"
typedef void (*PSRVUPDATEFN)(PVOID);
typedef HRESULT (*AQ_INITIALIZE_FUNCTION)(ISMTPServer *pISMTPServer, DWORD dwServerInstance, IAdvQueue **ppIAdvQueue, IConnectionManager **ppIConnectionManager, IAdvQueueConfig **ppIAdvQueueConfig, PVOID *ppvContext);
typedef HRESULT (*AQ_INITIALIZE_EX_FUNCTION)(ISMTPServer *pISMTPServer, DWORD dwServerInstance, LPSTR szUser, LPSTR szDomain, LPSTR szPassword, PSRVUPDATEFN pFn, PVOID pvSrvContext, IAdvQueue **ppIAdvQueue, IConnectionManager **ppIConnectionManager, IAdvQueueConfig **ppIAdvQueueConfig, PVOID *ppvContext);
typedef HRESULT (*AQ_DEINITIALIZE_FUNCTION)(PVOID pvContext);
typedef HRESULT (*AQ_DEINITIALIZE_EX_FUNCTION)(PVOID pvContext, PSRVUPDATEFN pFn, PVOID pvSrvContext);

HRESULT HrAdvQueueInitialize(
                    IN  ISMTPServer *pISMTPServer,
					IN	DWORD	dwServerInstance,
                    OUT IAdvQueue **ppIAdvQueue,
                    OUT IConnectionManager **ppIConnectionManager,
                    OUT IAdvQueueConfig **ppIAdvQueueConfig,
					OUT PVOID *ppvContext);

HRESULT HrAdvQueueDeinitialize(PVOID pvContext);

#endif //__AQDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\abook.h ===
//+---------------------------------------------------------------
//
//  File:   Abook.h
//
//  Synopsis:   Prove Server level api for MSN Servers to access addres book
//
//  Copyright (C) 1995 Microsoft Corporation
//          All rights reserved.
//
//  History:    SunShaw     Created         30 Jan 1996
//
//----------------------------------------------------------------

#ifndef _ABOOK_H_
#define _ABOOK_H_

#include <abtype.h>

#if defined(__cplusplus)
extern "C" {

#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif
#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif

#if !defined(_ABOOK_DLL_DEFINED)
    #define _ABOOK_DLL_DEFINED
    #if defined(WIN32)
        #if defined(_ABOOK_DLL)
            #define AbookDll DllExport
        #else
            #define AbookDll DllImport
        #endif
    #else
        #define _ABOOK_DLL
    #endif
#endif

#define ABCALLCONV  __stdcall

#define ABEXPDLLCPP extern "C" AbookDll

//+---------------------------------------------------------------
//
// All Function Prototype used by SMTP, POP3 or AbSysAdmin
//
//----------------------------------------------------------------

typedef ABRETC (ABCALLCONV *LPFNAB_INIT)(LPSTR, LPFNLOGTRANX, PLIST_ENTRY, HANDLE*);
typedef ABRETC (ABCALLCONV *LPFNAB_TERM)(HANDLE);
typedef ABRETC (ABCALLCONV *LPFNAB_CANCEL)(HANDLE);

typedef ABRETC (ABCALLCONV *LPFNAB_GET_ERROR_STRING)(ABRETC, LPSTR, DWORD);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_ROUTING_DIRECTORY)(PLIST_ENTRY pleSources, LPSTR szDirectory);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_SOURCES)(HANDLE, PLIST_ENTRY);
typedef ABRETC (ABCALLCONV *LPFNAB_VALIDATE_SOURCE)(HANDLE hAbook, LPSTR szSource);
typedef ABRETC (ABCALLCONV *LPFNAB_VALIDATE_NUM_SOURCES)(HANDLE hAbook, DWORD dwNumSources);

typedef ABRETC (ABCALLCONV *LPFNAB_RES_ADDR)(HANDLE, PLIST_ENTRY, PABADDRSTAT pabAddrStat, PABROUTING pabroutingCheckPoint, ABRESOLVE *pabresolve);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_RES_ADDR)(HANDLE, PABRESOLVE pabresolve, PABROUTING pabrouting);
typedef ABRETC (ABCALLCONV *LPFNAB_END_RES_ADDR)(HANDLE, PABRESOLVE pabresolve);
typedef ABRETC (ABCALLCONV *LPFNAB_RES_ADDR_ASYNC)(HANDLE, PLIST_ENTRY, PABADDRSTAT pabAddrStat, PABROUTING pabroutingCheckPoint, ABRESOLVE *pabresolve, LPVOID pContext);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_MAILROOT)(HANDLE, PCHAR, LPSTR, LPDWORD);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_PERFMON_BLK)(HANDLE, PABOOKDB_STATISTICS_0);

typedef ABRETC (ABCALLCONV *LPFNAB_END_ENUM_RESULT)(HANDLE, PABENUM);

typedef ABRETC (ABCALLCONV *LPFNAB_ENUM_NAME_LIST)(HANDLE, LPSTR, BOOL, DWORD, PABENUM);
typedef ABRETC (ABCALLCONV *LPFNAB_ENUM_NAME_LIST_FROM_DL)(HANDLE, LPSTR, LPSTR, BOOL, DWORD, PABENUM);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_NEXT_EMAIL)(HANDLE, PABENUM, DWORD*, LPSTR);

typedef ABRETC (ABCALLCONV *LPFNAB_ADD_LOCAL_DOMAIN)(HANDLE, LPSTR);
typedef ABRETC (ABCALLCONV *LPFNAB_ADD_ALIAS_DOMAIN)(HANDLE, LPSTR, LPSTR);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_LOCAL_DOMAIN)(HANDLE, LPSTR);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_ALL_LOCAL_DOMAINS)(HANDLE);

typedef ABRETC (ABCALLCONV *LPFNAB_CREATE_USER)(HANDLE hAbook, LPSTR szEmail, LPSTR szForward, BOOL fLocalUser, LPSTR szVRoot, DWORD cbMailboxMax, DWORD cbMailboxMessageMax);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_USER)(HANDLE hAbook, LPSTR szEmail);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_FORWARD)(HANDLE hAbook, LPSTR szEmail, LPSTR szForward);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_MAILROOT)(HANDLE hAbook, LPSTR szEmail, LPSTR szVRoot);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_MAILBOX_SIZE)(HANDLE hAbook, LPSTR szEmail, DWORD cbMailboxMax);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_MAILBOX_MESSAGE_SIZE)(HANDLE hAbook, LPSTR szEmail, DWORD cbMailboxMessageMax);

typedef ABRETC (ABCALLCONV *LPFNAB_CREATE_DL)(HANDLE hAbook, LPSTR szEmail, DWORD dwType);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_DL)(HANDLE hAbook, LPSTR szEmail);
typedef ABRETC (ABCALLCONV *LPFNAB_CREATE_DL_MEMBER)(HANDLE hAbook, LPSTR szEmail, LPSTR szMember);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_DL_MEMBER)(HANDLE hAbook, LPSTR szEmail, LPSTR szMember);

typedef ABRETC (ABCALLCONV *LPFNAB_GET_USER_PROPS)(HANDLE hAbook, LPSTR lpszEmail, ABUSER *pABUSER);

typedef ABRETC (ABCALLCONV *LPFNAB_MAKE_BACKUP)(HANDLE hAbook, LPSTR szConfig);

typedef DWORD (ABCALLCONV *LPFNAB_GET_TYPE)(void);


// Get user or DL's properties
ABEXPDLLCPP ABRETC ABCALLCONV AbGetUserProps(HANDLE hAbook, LPSTR lpszEmail, ABUSER *pABUSER);
ABEXPDLLCPP ABRETC ABCALLCONV AbGetDLProps(HANDLE hAbook, LPSTR lpszEmail, ABDL *pABDL);

// Given beginning chars, match user names
ABEXPDLLCPP ABRETC ABCALLCONV AbEnumNameList(HANDLE hAbook, LPSTR lpszEmail, BOOL f ,
                                             DWORD dwType, PABENUM pabenum);
// Match user names only in the given DL
ABEXPDLLCPP ABRETC ABCALLCONV AbEnumNameListFromDL(HANDLE hAbook, LPSTR lpszDLName, LPSTR lpszEmail,
                                                   BOOL f , DWORD dwType, PABENUM pabenum);
// Get back all the matching names
ABEXPDLLCPP ABRETC ABCALLCONV AbGetNextEmail(HANDLE hAbook, PABENUM pabenum, DWORD *pdwType, LPSTR lpszEmail);


//+---------------------------------------------------------------
//
//  Function:   AbGetType
//
//  Synopsis:   returns the routing type number
//
//  Arguments:
//
//  Returns:    DWORD       Routing type number defined above
//
//----------------------------------------------------------------

#define ROUTING_TYPE_SQL    1
#define ROUTING_TYPE_FF     2
#define ROUTING_TYPE_LDAP   3

ABEXPDLLCPP DWORD ABCALLCONV AbGetType
        ();


//+---------------------------------------------------------------
//
//  Function:   AbInitialize
//
//  Synopsis:   Must be the first call to abookdb.dll (except AbGetType)
//
//  Arguments:
//              LPSTR        [in] Display name for abookdb users/context,
//                              i.e. SMTP, POP3 or NULL if don't care.
//              LPFNLOGTRANX [in] Transaction Logging callback.
//                              NULL if don't care about transaction logging.
//              PHANDLE      [out] Return buffer for context handle,
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbInitialize
        (LPSTR pszDisplayName, LPFNLOGTRANX pfnTranx, PLIST_ENTRY pHead, HANDLE* phAbook);


//+---------------------------------------------------------------
//
//  Function:   AbSetSources
//
//  Synopsis:   Called to update available data sources at any time
//
//  Arguments:  LPSTR       it's the command line and should have the following form:
//                      [server=ayin][,][MaxCnx=100]
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbSetSources(HANDLE hAbook, PLIST_ENTRY pHead);

//+---------------------------------------------------------------
//
//  Function:   AbGetErrorString
//
//  Synopsis:   To translate ABRETC to an error string
//
//  Arguments:  ABRETC  [in]    The return code from abook API
//              LPSTR   [out]   Buffer for the error string to copy into
//              DWORD   [in]    The size of the buffer supplized
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbGetErrorString(ABRETC abrc, LPSTR lpBuf, DWORD cbBufSize);


//+---------------------------------------------------------------
//
//  Function:   AbTerminate
//
//  Synopsis:   User must call this when done with abook.dll
//
//  Arguments:
//              HANDLE   [in] Context Handle returned from AbInitialize.
//
//  Returns:    NONE
//
//----------------------------------------------------------------

ABEXPDLLCPP VOID ABCALLCONV AbTerminate(HANDLE hAbook);


//+---------------------------------------------------------------
//
//  Function:   AbCancel
//
//  Synopsis:   This function will cancel all resolve address calls
//              to DB so that SMTP can shut down cleanly without waiting
//              too long.
//
//  Arguments:
//              HANDLE   [in] Context Handle returned from AbInitialize.
//
//  Returns:    ABRETC
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbCancel(HANDLE hAbook);


//+---------------------------------------------------------------
//
//  Function:   AbResolveAddress
//
//  Synopsis:   Resolves email address to minimum routing info.
//
//  Arguments:
//              HANDLE       [in]     Context Handle returned from AbInitialize.
//              HACCT        [in]     HACCT for sender, 0 for non-MSN account
//              PQUEUE_ENTRY [in|out] List of CAddr/Recipients
//              LPFNCREATEADDR   [in] Callback constructor of CAddr
//              BOOL*        [out]    Pointer to buffer to indicate at least 1
//                                      recipient is encrypted and needs verification
//                                      could be NULL in 2.0
//
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------
ABEXPDLLCPP ABRETC ABCALLCONV AbResolveAddress
    (
    HANDLE hAbook,
    PLIST_ENTRY pltInput,
    PABADDRSTAT pabAddrStat,
    PABROUTING pabroutingCheckPoint,
    ABRESOLVE *pabresolve
    );

ABEXPDLLCPP ABRETC ABCALLCONV AbAsyncResolveAddress
    (
    HANDLE hAbook,
    PLIST_ENTRY pltInput,
    PABADDRSTAT pabAddrStat,
    PABROUTING pabroutingCheckPoint,
    ABRESOLVE *pabresolve,
    LPFNRESOLVECOMPLETE pfnCompletion,
    LPVOID pContext
    );



ABEXPDLLCPP ABRETC ABCALLCONV AbGetResolveAddress
    (
    HANDLE hAbook,
    ABRESOLVE *pabresolve,
    ABROUTING *pabrouting
    );



ABEXPDLLCPP ABRETC ABCALLCONV AbEndResolveAddress
    (
    HANDLE hAbook,
    ABRESOLVE *pabresolve
    );


ABEXPDLLCPP ABRETC ABCALLCONV AbEndEnumResult
        (HANDLE hAbook, PABENUM pabEnum);


//+---------------------------------------------------------------
//
//  Function:   AbAddLocalDomain  AbDeleteLocalDomain
//
//  Synopsis:   add and delete Local domain to the database
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              HACCT   [in] Currently ignored
//              PABPDI  [in] Pointer to the Local domain structure
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbAddLocalDomain(HANDLE hAbook, LPSTR szDomainName);
ABEXPDLLCPP ABRETC ABCALLCONV AbAddAliasDomain(HANDLE hAbook, LPSTR szDomainName, LPSTR szAliasName);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeleteLocalDomain(HANDLE hAbook, LPSTR szDomainName);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeleteAllLocalDomains(HANDLE hAbook);


//+---------------------------------------------------------------
//
//  Function:   AbGetUserMailRoot
//
//  Synopsis:   Gets the Virtual Mail Root for the specified users
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              PCHAR   [in] ASCII user name
//              LPCHAR  [in] ASCII Virtual Mail Root
//              LPDWORD [in|out] (in) size of buffer, (out) string length
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbGetUserMailRoot
        (HANDLE hAbook, PCHAR pszUser, LPSTR pszVRoot, LPDWORD pcbVRootSize);

//+---------------------------------------------------------------
//
//  Function:   AbGetPerfmonBlock
//
//  Synopsis:   Gets the Pointer to the Perfmon Statistic block
//              associated with hAbook.  The pointer is guaranteed
//              to be valid before the AbTerminate call.
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              PABOOKDB_STATISTICS_0*
//                      [out] Buffer is receive the pointer to stat
//                               block.
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbGetPerfmonBlock
        (HANDLE hAbook, PABOOKDB_STATISTICS_0* ppabStat);

//+---------------------------------------------------------------
//
//  Function:   AbMakeBackup
//
//  Synopsis:   Triggers the routing table to make a backup of the
//              data associated with hAbook.
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              LPSTR   [in] configuration string
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbMakeBackup
    (HANDLE hAbook, LPSTR szConfig);

//+---------------------------------------------------------------
//
//  Function:   AbValidateSource
//
//  Synopsis:   Validates a single source for accuracy before
//              saving into the registry
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              LPSTR   [in] source string
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbValidateSource
    (HANDLE hAbook, LPSTR szSource);
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\blockmgr.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

        blockmgr.h

Abstract:

        This module contains the definition of the block memory manager

Author:

        Keith Lau       (keithlau@microsoft.com)

Revision History:

        keithlau        02/27/98        created

--*/

#ifndef __BLOCKMGR_H__
#define __BLOCKMGR_H__

#include "rwnew.h"

#include "cpoolmac.h"
#include "mailmsg.h"

//
// Nasty forwards for these interfaces ...
//
struct IMailMsgPropertyStream;
struct IMailMsgNotify;

/***************************************************************************/
// Define this to remove contention control
//
// #define BLOCKMGR_DISABLE_ATOMIC_FUNCS
// #define BLOCKMGR_DISABLE_CONTENTION_CONTROL
//
#ifdef BLOCKMGR_DISABLE_CONTENTION_CONTROL
#define BLOCKMGR_DISABLE_ATOMIC_FUNCS
#endif

/***************************************************************************/
// Debug stuff ...
//

#ifdef DEBUG

#define DEBUG_TRACK_ALLOCATION_BOUNDARIES

#endif

/***************************************************************************/
// CBlockManager - Implementation of pseudo flat memory space using a
//    heap that works like an I-Node. The underlying memory utilizes
//    disjoint, fixed-size memory blocks.
//
// Each node is as follows:
//
// +---------------------------------------------------------+
// | Pointers to other nodes | Space for arbitrary data      |
// +---------------------------------------------------------+
//
// Analysis:
// We assume in some way or another memory allocation is based on
// 4K pages or some multiple thereof. The first thing we want to
// determine is how many pointers to other nodes we want to have in
// the node (order of the heap). We know that each node would probably
// be some size between 1K to 2K so that we won't waste space in the
// average case of small email messages, yet provide scalability for
// huge email messages that potentially may have millions of email
// addresses. 2 intuitive candidates are 32 and 64 pointers.
//
// We consider the worst case scenario of MSN, which has about 2.5
// million users. Assuming the averace recipient record is about
// 45 bytes (name & attributes, etc.), then we need 112.5M of
// storage, which is about 2 ^ 27. Assume the average data payload
// is 1K per node (2 ^ 10), then we need 2 ^ 17 nodes. Thus, for
// 23 pointers (2 ^ 5) per node, we need 4 layers to cover the
// required address space of 112M. However, this turns out to be
// an overkill since 4 layers covers 1G (2 ^ 20) where we only need
// about 10% of that. As for the 64 pointers case, we only need 3
// layers to cover 256M (2 ^ (18 + 10)), which roughly covers 5
// million users. We will choose 64 pointer per node (256 bytes).
//
// As for the size of the payload, I considered using 1K allocations
// and using the remaining 768 bytes as data payload. But since this
// is not a round power of two, it would be expensive to do a
// div and mod operation. As an alternative, I suggest allocating
// 1024 + 256 byte blocks. This makes both numbers round powers of
// two, which makes div and mod operations simple AND and SHR
// operations, which typically take 2-4 cycles to complete. Also,
// when the wasted space is considered, turns out that a 4K page
// fits 3 such blocks, and only 256 bytes is wasted per page. This
// comes to 93.3% utilization of space.
//
// So each node would look like this:
// +---------------------------------------------------------+
// | 64 pointers = 256 bytes | 1K block for arbitrary data   |
// +---------------------------------------------------------+
//
// It is an explicit objective that a typical mail message header
// fits in a single block. Each block fans out to 64 other blocks
// and each block's payload maps to 1K of the flat data address
// space. The root node maps to the first 1K of the data space
// (i.e. absolute address 0 to 1023 in data space), then each
// of the next 64 nodes in the next layer represents the next 64K,
// respectively, and so on for each subsequent layer. Nodes for
// the next layer is not created until the current layer is
// depleted. Collpasing of nodes is not required due to the fact
// that the heap can only grow.
//
// During commit of the whole heap, the scatter-gather list is
// built by traversing the entire heap. The average number of
// dereferences is n*(log64(n))/2).
//
// All items in a message object is allocated off this heap.
//
// An slight modification can be used to track dirty or unused
// bits. We can actually add a block of flags and attributes to
// each node to track dirty regions and other flags. This will
// probably not be implemented in the initial implementation,
// but such capability will be factored in. In terms of allocation
// optimization, we can have a block of up to 64 bytes without
// disrupting the 4K page allocation scheme. In fact, adding a
// 64-byte block to each node boosts memory utilization to up
// to 98.4% without any real extra cost while still keeping each
// node 64-byte aligned.
//
// Synchronization:
// Allocation of memory in the data space is done through a
// reservation model where multiple threads can concurrently
// reserve memory and be guaranteed to get a unique block.
// A lightweight critical section is used to synchronize block
// creation should the reservation span into blocks that are
// not yet allocated. Allocation of new blocks is serialized.
//
// Synchronization for concurrent access to the same data space
// must be enforced at a higher level, if desired.
//

// Define the constants chosen for this implementation

#ifdef _WIN64
// The order will be 5 bits in 64-bit (8 * 32 = 256 bytes)
#define BLOCK_HEAP_ORDER_BITS		(5)
#else
// The order will be 6 bits in 32-bit (4 * 64 = 256 bytes)
#define BLOCK_HEAP_ORDER_BITS		(6)
#endif

#define BLOCK_HEAP_ORDER			(1 << BLOCK_HEAP_ORDER_BITS)
#define BLOCK_HEAP_ORDER_MASK		(BLOCK_HEAP_ORDER - 1)
#define BLOCK_HEAP_PAYLOAD_BITS		(10)
#define BLOCK_HEAP_PAYLOAD			(1 << BLOCK_HEAP_PAYLOAD_BITS)
#define BLOCK_HEAP_PAYLOAD_MASK		(BLOCK_HEAP_PAYLOAD - 1)
#define BLOCK_DWORD_ALIGN_MASK		(sizeof(DWORD) - 1)

#define BLOCK_DEFAULT_FLAGS			(BLOCK_IS_DIRTY)

#define BLOCK_MAX_ALLOWED_LINEAR_HOPS 3

// Define the underlying data type for a flat address in the
// linear address space, and the type that we use to count nodes.
// This is for scalability so when we want to use 64-bit
// quantities, we can simply replace this section of data-size
// specific values
//
// Note: you need to make sure that the data size is AT LEAST:
// 1 + (BLOCK_HEAP_ORDER_BITS * MAX_HEAP_DEPTH) + BLOCK_HEAP_PAYLOAD_BITS
//
// Note: In order for this type to be used as the base address
// type, the following operations must be supported:
// - Assignment
// - Comparison
// - Arithmetic operators
// - Bitwise operators
// - Interlocked operations
//
// Start data-size-specific values

	typedef SIZE_T					HEAP_BASE_ADDRESS_TYPE;
	typedef HEAP_BASE_ADDRESS_TYPE		HEAP_NODE_ID;
	typedef HEAP_NODE_ID				*LPHEAP_NODE_ID;
	typedef HEAP_BASE_ADDRESS_TYPE		FLAT_ADDRESS;
	typedef FLAT_ADDRESS				*LPFLAT_ADDRESS;

	// These must be changed if HEAP_BASE_ADDRESS_TYPE is not DWORD
	#define NODE_ID_MAPPING_FACTOR		\
			(HEAP_BASE_ADDRESS_TYPE)(	\
				 1 |					\
				(1 << BLOCK_HEAP_ORDER_BITS) |		\
				(1 << (BLOCK_HEAP_ORDER_BITS * 2))	\
				)
	//	And so on, etc ...
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 3))
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 4))

	#define NODE_ID_ABSOLUTE_MAX		\
			(HEAP_BASE_ADDRESS_TYPE)(	\
				(1 << BLOCK_HEAP_ORDER_BITS) |		\
				(1 << (BLOCK_HEAP_ORDER_BITS * 2)) |\
				(1 << (BLOCK_HEAP_ORDER_BITS * 3))	\
				)
	//	And so on, etc ...
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 4))
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 5))

	#define NODE_ID_BORROW_BIT			\
			(HEAP_BASE_ADDRESS_TYPE)(1 << (BLOCK_HEAP_ORDER_BITS * 3))

	// Depth of heap allowed by base data type
	#define MAX_HEAP_DEPTH				4

	// Node Id space mask
	#define MAX_FLAT_ADDRESS			\
				(FLAT_ADDRESS)((1 << (MAX_HEAP_DEPTH * BLOCK_HEAP_ORDER_BITS)) - 1)

	// Same as a NULL pointer
	#define INVALID_FLAT_ADDRESS		((FLAT_ADDRESS)-1)

	// Number of bits to rotate the mapped result
	#define NODE_ID_ROR_FACTOR			((MAX_HEAP_DEPTH - 1) * BLOCK_HEAP_ORDER_BITS)

	// Define the rotate functions
	#define ROTATE_LEFT(v, n)			_lrotl((v), (n))
	#define ROTATE_RIGHT(v, n)			_lrotr((v), (n))

	// Define the interlocked functions
	#define AtomicAdd(pv, a)			\
				(HEAP_BASE_ADDRESS_TYPE)InterlockedExchangeAdd((long *)(pv), (a))

// End data-size-specific values

// Forward declaration of the _BLOCK_HEAP_NODE structure
struct _BLOCK_HEAP_NODE;

// Define the attribute block for each node
typedef struct _BLOCK_HEAP_NODE_ATTRIBUTES
{
	struct _BLOCK_HEAP_NODE	*pParentNode;	// Pointer to parent node
	HEAP_NODE_ID			idChildNode;	// Which child am I?
	HEAP_NODE_ID			idNode;			// Id of node in block heap
	FLAT_ADDRESS			faOffset;		// Starting offset the node
	DWORD					fFlags;			// Attributes of the block

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES
	// This tracks the allocation boundaries between memory
	// allocations so that we can check whether a read or write
	// crosses an allocation boundary. We use a bit to represent
	// the start of a block. Since the allocations are DWORD-aligned,
	// we need BLOCK_HEAP_PAYLOAD >> 2 >> 3 bits to track
	// all allocation boundaries per block.
	BYTE					rgbBoundaries[BLOCK_HEAP_PAYLOAD >> 5];
#endif

} BLOCK_HEAP_NODE_ATTRIBUTES, *LPBLOCK_HEAP_NODE_ATTRIBUTES;

// Define each node in the heap
typedef struct _BLOCK_HEAP_NODE
{
	struct _BLOCK_HEAP_NODE		*rgpChildren[BLOCK_HEAP_ORDER];
	BLOCK_HEAP_NODE_ATTRIBUTES	stAttributes;
	BYTE						rgbData[BLOCK_HEAP_PAYLOAD];

} BLOCK_HEAP_NODE, *LPBLOCK_HEAP_NODE;

#define BLOCK_HEAP_NODE_SIZE	(sizeof(BLOCK_HEAP_NODE))

#define BOP_LOCK_ACQUIRED			0x80000000
#define BOP_NO_BOUNDARY_CHECK		0x40000000
#define BOP_OPERATION_MASK			0x0000ffff

typedef enum _BLOCK_OPERATION_CODES
{
	BOP_READ = 0,
	BOP_WRITE

} BLOCK_OPERATION_CODES;

// Define the block attribute flags
#define BLOCK_IS_DIRTY				0x00000001
#define BLOCK_PENDING_COMMIT		0x00000002

// block allocation flags
// the block was allocated with CMemoryAccess instead of cpool
#define BLOCK_NOT_CPOOLED           0x00010000

#define BLOCK_CLEAN_MASK			(~(BLOCK_IS_DIRTY))
#define RESET_BLOCK_FLAGS(_flags_) _flags_ &= 0xffff0000
#define DEFAULT_BLOCK_FLAGS(_flags_) _flags_ &= (0xffff0000 | BLOCK_IS_DIRTY)

//
// Define a method signature for acquiring a stream pointer
//
typedef IMailMsgPropertyStream	*(*PFN_STREAM_ACCESSOR)(LPVOID);

/***************************************************************************/
// Context class for memory access
//

class CBlockContext
{
  private:

	DWORD				m_dwSignature;

  public:

	CBlockContext() { Invalidate(); }
	~CBlockContext() { Invalidate(); }

	BOOL IsValid();

	void Set(
				LPBLOCK_HEAP_NODE	pLastAccessedNode,
				FLAT_ADDRESS		faLastAccessedNodeOffset
				);

	void Invalidate();

	LPBLOCK_HEAP_NODE	m_pLastAccessedNode;
	FLAT_ADDRESS		m_faLastAccessedNodeOffset;
};


/***************************************************************************/
// Memory allocator classes
//

class CBlockMemoryAccess
{
  public:

	CBlockMemoryAccess() {}
	~CBlockMemoryAccess() {}

	HRESULT AllocBlock(
				LPVOID	*ppvBlock,
				DWORD	dwBlockSize
				);

	HRESULT FreeBlock(
				LPVOID	pvBlock
				);

	//
	// CPool
	//
	static CPool m_Pool;
};


class CMemoryAccess
{
  public:

	CMemoryAccess() {}
	~CMemoryAccess() {}

	static HRESULT AllocBlock(
				LPVOID	*ppvBlock,
				DWORD	dwBlockSize
				);

	static HRESULT FreeBlock(
				LPVOID	pvBlock
				);
};

/***************************************************************************/
// Class for accessing stream
//

class CBlockManagerGetStream
{
  public:
	virtual HRESULT GetStream(
				IMailMsgPropertyStream	**ppStream,
				BOOL					fLockAcquired
				) = 0;
};


/***************************************************************************/
// Block heap manager
//

class CBlockManager
{
  public:
	CBlockManager(
				IMailMsgProperties *pMsg,
				CBlockManagerGetStream	*pParent = NULL
				);
	~CBlockManager();

	// Sanity check
	BOOL IsValid();

	// This initializes an empty MailMsg to a certain size.
	// CAUTION: This should only be used to initialize an empty MailMsg
	// when binding to a non-empty stream. Any other uses will cause
	// unpredictable results and/or corruption or even crashes.
	HRESULT SetStreamSize(
				DWORD	dwStreamSize
				);

	//
	// Synopsis:
	// Allocate the desired amount of memory.
	// Thread safe.
	//
	// Arguments:
	// dwSizeDesired - the size of the block desired
	// pfaOffsetToReservedMemory - returns the offset to the
	//      reserved block of memory, if successful, in the
	//      flat memory space managed by the block manager.
	// pdwSizeAllocated - returns the actual size allocated, which
	//		is greater than or equal to the desired size, if successful.
	// pContext (Optional) - fills in a context that describes
	//      the reserved block. This context can be used in
	//      subsequent reads and writes to the block. Accesses
	//      using this context are faster than using the
	//      offset alone. Ignored if NULL. The caller must allocate
	//      the context structure prior to calling ReserveMemory.
	//
	// Return values:
	// S_OK - Success, the memory of requested size is
	//      successfully reserved.
	// STG_E_INSUFFICIENTMEMORY - Error, the required amount of memory
	//      is not available to honor the request.
	// STG_E_INVALIDPARAMETER - Internal error, mostly used
	//      for debug considerations.
	//
	HRESULT AllocateMemory(
				DWORD				dwSizeDesired,
				FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
				DWORD				*pdwSizeAllocated,
				CBlockContext		*pContext	// Optional
				);

	//
	// Synopsis:
	// Returns the total size allocated by this block manager.
	// Thread safe.
	//
	// Arguments:
	// pfaSizeAllocated - returns the total size allocated.
	//
	// Return values:
	// S_OK - Success, the memory of requested size is
	//      successfully reserved.
	// STG_E_INVALIDPARAMETER - Internal error, mostly used
	//      for debug considerations.
	//
	HRESULT GetAllocatedSize(
				FLAT_ADDRESS	*pfaSizeAllocated
				);

	//
	// Synopsis:
	// Reads a chunk of contiguous memory in flat address space into a
	// user-supplied buffer. Synchronization not supported at this level.
	//
	// Arguments:
	// pbBuffer - buffer to return contents read, must be large enough
	//      to store the data read.
	// faTargetOffset - offset measured in flat address space to start
	//      reading from.
	// dwBytesToRead - number of contiguous bytes to read
	// pdwBytesRead - returns number of bytes actually read
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the read is successful.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_READFAULT - Error, The read failed to complete, pdwBytesRead
	//      reflects the actual number of bytes read into pbBuffer.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a read is issued to read past
	//      the current allocated block.
	//
	HRESULT ReadMemory(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faTargetOffset,
				DWORD			dwBytesToRead,
				DWORD			*pdwBytesRead,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Writes a chunk of contiguous memory from a specified buffer into
	// a specified offset in the flat address space. Synchronization not
	// supported at this level.
	//
	// Arguments:
	// pbBuffer - source buffer of bytes to be written
	// faTargetOffset - offset measured in flat address space to start
	//      writing to.
	// dwBytesToWrite - number of contiguous bytes to write
	// pdwBytesWritten - returns number of bytes actually written
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the read is successful.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_WRITEFAULT - Error, The read failed to complete, pdwBytesRead
	//      reflects the actual number of bytes read into pbBuffer.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//      the current allocated block.
	//
	HRESULT WriteMemory(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faTargetOffset,
				DWORD			dwBytesToWrite,
				DWORD			*pdwBytesWritten,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Atomically reads the length and size of a data block, and loads the
	// data block from the offset of the size specified.
	//
	// Arguments:
	// pbBuffer - target buffer of bytes to write the read data
	// pdwBufferSize - Contains the length of the supplied buffer going in,
	//      and returns the length of data actually read.
	// pbInfoStruct - Structure containing the information structure
	// faOffsetToInfoStruct - Offset to the info structure
	// dwSizeOfInfoStruct - Size of the info struct to load
	// dwOffsetInInfoStructToOffset - Offset to the address of the data block.
	//      this is measured w.r.t. the info structure
	// dwOffsetInInfoStructToOffset - Offset to the size of the data block.
	//      this is measured w.r.t. the info structure
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the read is successful.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) - Error/Informational,
	//      the supplied buffer is not large enough to hold all the data.
	//      *pdwBufferSize returns the actual number of bytes read.
	// STG_E_READFAULT - Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a read is issued to read past
	//      the current allocated block.
	//
	HRESULT AtomicDereferenceAndRead(
				LPBYTE			pbBuffer,
				DWORD			*pdwBufferSize,
				LPBYTE			pbInfoStruct,
				FLAT_ADDRESS	faOffsetToInfoStruct,
				DWORD			dwSizeOfInfoStruct,
				DWORD			dwOffsetInInfoStructToOffset,
				DWORD			dwOffsetInInfoStructToSize,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Atomically writes the contents of a buffer to memory in flat space and
	// increments a DWORD value by a specified amount. The write is attempted
	// first, and if it succeeds, the value is incremented. If the write fails
	// for some reason, the value will not be incremented. This is to ensure that
	// all the data is written before the increment so the data "exists" by the
	// time the counter is updated.
	//
	// Arguments:
	// pbBuffer - source buffer of bytes to be written
	// faOffset - offset measured in flat address space to start
	//      writing to.
	// dwBytesToWrite - number of contiguous bytes to write
	// pdwValueToIncrement - Pointer to the value to be atomically incremented
	//      after the write successfully written. If this value is NULL, the
	//      increment is ignored and only a protected write is performed.
	// dwReferenceValue - If the value in pdwValueToIncrement differs from this
	//      value, the call will be aborted.
	// dwIncrementValue - Amount to increment pdwValueToIncrement.
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the write is successful.
	// HRESULT_FROM_WIN32(ERROR_RETRY) - Informational, The reference value
	//      changed during processing and the call cannot complete. A retry
	//      should be performed immediately.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_WRITEFAULT - Error, The write failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//      the current allocated block.
	//
	HRESULT AtomicWriteAndIncrement(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faOffset,
				DWORD			dwBytesToWrite,
				DWORD			*pdwValueToIncrement,
				DWORD			dwReferenceValue,
				DWORD			dwIncrementValue,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Atomically allocates memory, writes the contents of a buffer to memory
	// in flat space and increments a DWORD value by a specified amount. The
	// allocation is preceeded by a synchronization object and the allocation
	// takes place only if the value of the value to increment is identical before
	// and after the synchronization object is acquired. This allows multiple threads
	// to call this function for the same base object and only one such allocation
	// will succeed. The user can specify a buffer containing content data that will
	// be copied to the allocated buffer should the allocation succeed.
	// There can be 3 outcomes from the allocation:
	// 1) Allocation succeeded
	// 2) Allocation failed due to memory system problems
	// 3) Allocation was not done because the increment value changed during the
	//    acquisition of the synchronization object.
	//
	// If the allocation failed due to memory problems, this function will fail without
	// performing the rest of the duties. For scenario 1, the function will
	// continue. For scenario 3, the function will return a specific error code
	// indicating that it had been beaten and the caller will have to do something else
	//
	// After the allocation phase, the write is attempted first, and if it succeeds,
	// the value is incremented. If the write fails for some reason, the value will
	// not be incremented. This is to ensure that all the data is written before the
	// increment so the data "exists" by the time the counter is updated. On the
	// event of a write failure, the memory cannot be salvaged.
	//
	// Arguments:
	// dwDesiredSize - Size of memory block to allocate
	// pfaOffsetToAllocatedMemory - returns the starting offset to the
	//      allocated block, in flat address space
	// faOffsetToWriteOffsetToAllocatedMemory - Specifies a location in
	//      which to store the offset of the allocated block
	// faOffsetToWriteSizeOfAllocatedMemory - Specifies a location in
	//      which to store the actual size of the allocated block
	// pbInitialValueForAllocatedMemory - Specifies a buffer that contains
	//      the initial value for the allocated block. This will be copied
	//      to the allocated block if the allocation succeeds.
	// pbBufferToWriteFrom - source buffer of bytes to be written
	// dwOffsetInAllocatedMemoryToWriteTo - offset from the start of the
	// allocated block to start writing to.
	// dwSizeofBuffer - number of contiguous bytes to write
	// pdwValueToIncrement - Pointer to the value to be atomically incremented
	//      after the write successfully written. This value MUST NOT be NULL.
	// dwReferenceValue - If the value in pdwValueToIncrement differs from this
	//      value, the call will be aborted.
	// dwIncrementValue - Amount to increment pdwValueToIncrement.
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the write is successful.
	// HRESULT_FROM_WIN32(ERROR_RETRY) - Informational, The reference value
	//      changed during processing and the call cannot complete. A retry
	//      should be performed immediately.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_WRITEFAULT - Error, The write failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//      the current allocated block.
	//
	HRESULT AtomicAllocWriteAndIncrement(
				DWORD			dwDesiredSize,
				FLAT_ADDRESS	*pfaOffsetToAllocatedMemory,
				FLAT_ADDRESS	faOffsetToWriteOffsetToAllocatedMemory,
				FLAT_ADDRESS	faOffsetToWriteSizeOfAllocatedMemory,
				LPBYTE			pbInitialValueForAllocatedMemory,
				DWORD			dwSizeOfInitialValue,
				LPBYTE			pbBufferToWriteFrom,
				DWORD			dwOffsetInAllocatedMemoryToWriteTo,
				DWORD			dwSizeofBuffer,
				DWORD			*pdwValueToIncrement,
				DWORD			dwReferenceValue,
				DWORD			dwIncrementValue,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Sets the state of a specified block to the specified state.
	//
	// In the debug version, any block that is both "DIRTY" and "PENDING COMMIT"
	// is invalid and results in an ASSERT.
	//
	// Arguments:
	// pbData - block as specified by its data pointer
	// fClean	- TRUE to mark the blocks as "CLEAN", FALSE for "DIRTY"
	//
	// Return values:
	// S_OK - Success.
	//
	HRESULT MarkBlockAs(
				LPBYTE			pbData,
				BOOL			fClean
				);

	//
	// Synopsis:
	// Traverses the list of allocated blocks, from the specified address, and
	// finds dirty blocks. For each dirty block encountered, the block will be
	// changed from "DIRTY" to "PENDING COMMIT" and the block will marked for
	// commit. When enough of these blocks are encountered, they will be
	// committed in a batch and the committed blocks will be marked as "CLEAN".
	// The process will iterate until no more dirty blocks. An optional faLengthToScan
	// specifies the number of bytes from the starting offset to scan for
	// dirty blocks, if this is INVALID_FLAT_ADDRESS, then this function scans
	// to the end of all allocated blocks. It is not an error if there are
	// less allocated bytes than the length specified, only the allocated blocks
	// are scanned.
	//
	// Arguments:
	// faStartingOffset - Starting offset to start scanning for dirty blocks
	// dwLengthToScan - Length of memory from start to scan for dirty blocks
	// pStream - specifies the IMailMsgPropertyStore to use to commit the blocks.
	// fComputeBlockCountsOnly - don't make calls to WriteBlocks, just
	//    compute counters for what would be sent to WriteBlocks.
	// pcBlocksToWrite - incremented by how many blocks we would write
	// pcTotalBytesToWrite - incremented by the total byte count of what we
	//    would write
	//
	// Return values:
	// S_OK - Success, one or more dirty blocks are returned.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// Plus the error codomain of IMailMsgPropertyStream
	//
	HRESULT CommitDirtyBlocks(
				FLAT_ADDRESS			faStartingOffset,
				FLAT_ADDRESS			faLengthToScan,
				DWORD					dwFlags,
				IMailMsgPropertyStream	*pStream,
				BOOL					fDontMarkAsCommit,
				BOOL					fComputeBlockCountsOnly,
				DWORD					*pcBlocksToWrite,
				DWORD					*pcTotalBytesToWrite,
				IMailMsgNotify			*pNotify
				);

	//
	// Synopsis:
	// Releases the entire list of nodes managed by this object.
	//
	// Arguments:
	// None.
	//
	// Return values:
	// S_OK - Success.
	//
	HRESULT Release();

	//
	// Synopsis:
	// Exposes the lock in the block manager, attempts to access the internal lock
	//
	// Arguments:
	// None.
	//
	// Remarks:
	// These locks will cause deadlocks if a thread tries to acquire it twice.
	// In debug builds, there will be some sort of deadlock detection, in
	// retail, you will deadlock.
	//
	// Return values:
	// S_OK - Success, the lock operation succeeded.
	// !(SUCCESS(HRESULT)) - An error occurred and the lock operaiton failed.
	//
	HRESULT WriteLock() { m_CSLock.Enter(); return(S_OK); }
	HRESULT WriteUnlock() { m_CSLock.Leave(); return(S_OK); }

	// return the state of the dirty flag
	BOOL IsDirty() { return m_fDirty; }

	// change the value of the dirty flag.  this is used by MailMsg to
	// set it to FALSE when a successful Commit has occured.
	void SetDirty(BOOL fDirty) {
        m_fDirty = fDirty;
#ifdef DEBUG
//        _ASSERT(!(m_fCommitting && m_fDirty));
#endif
    }
    void SetCommitMode(BOOL fCommitting) {
#ifdef DEBUG
        m_fCommitting = fCommitting;
#endif
    }

  private:

	// GetNodeIdFromOffset() defined as a macro in the source

	// Method to load a block from the stream if required
	/*
	HRESULT ConnectLeftSibling(
				LPBLOCK_HEAP_NODE	pNode,
				LPBLOCK_HEAP_NODE	pParent,
				DWORD				dwChildId
				);

	HRESULT ConnectRightSibling(
				LPBLOCK_HEAP_NODE	pNode,
				LPBLOCK_HEAP_NODE	pParent,
				DWORD				dwChildId
				);
	*/

	HRESULT GetStream(
				IMailMsgPropertyStream	**ppStream,
				BOOL					fLockAcquired
				);

	HRESULT MoveToNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				HEAP_NODE_ID		idTargetNode,
				BOOL				fLockAcquired
				);

	HRESULT GetNextNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				);

	HRESULT LoadBlockIfUnavailable(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	pParent,
				HEAP_NODE_ID		idChildNode,
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				);

	HRESULT GetEdgeListFromNodeId(
				HEAP_NODE_ID		idNode,
				HEAP_NODE_ID		*rgEdgeList,
				DWORD				*pdwEdgeCount
				);

	HRESULT GetNodeFromNodeId(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired = FALSE
				);

	HRESULT GetParentNodeFromNodeId(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	*ppNode
				);

	HRESULT InsertNodeGivenPreviousNode(
				LPBLOCK_HEAP_NODE	pNodeToInsert,
				LPBLOCK_HEAP_NODE	pPreviousNode
				);

	BOOL IsMemoryAllocated(
				FLAT_ADDRESS		faOffset,
				DWORD				dwLength
				);

	HRESULT AllocateMemoryEx(
				BOOL				fAcquireLock,
				DWORD				dwSizeDesired,
				FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
				DWORD				*pdwSizeAllocated,
				CBlockContext		*pContext	// Optional
				);

	HRESULT WriteAndIncrement(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faOffset,
				DWORD			dwBytesToWrite,
				DWORD			*pdwValueToIncrement,
				DWORD			dwIncrementValue,
				CBlockContext	*pContext	// Optional
				);

	HRESULT OperateOnMemory(
				DWORD			dwOperation,
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faTargetOffset,
				DWORD			dwBytesToDo,
				DWORD			*pdwBytesDone,
				CBlockContext	*pContext	// Optional
				);

	HRESULT ReleaseNode(
				LPBLOCK_HEAP_NODE	pNode
				);

	DWORD					m_dwSignature;

	// This value indicates the current end of data. This is
	// always changed with interlocked operations such that
	// multiple threads can increment this variable and the
	// increments are properly serialized
	FLAT_ADDRESS			m_faEndOfData;

	HEAP_NODE_ID			m_idNodeCount;
	LPBLOCK_HEAP_NODE		m_pRootNode;

	CBlockManagerGetStream	*m_pParent;

	CBlockMemoryAccess		m_bma;

#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	CCritSection            m_CSLock;
#endif

	IMailMsgProperties		*m_pMsg;

	BOOL					m_fDirty;
#ifdef DEBUG
    BOOL                    m_fCommitting;
#endif

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\artcore.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    article.h

Abstract:

    This module contains class declarations/definitions for

		CArticle
        CField
			CDateField
			CFromField
			CMessageIDField
			CSubjectField
			CNewsgroupsField
			CPathField
			CXrefField
			CFollowupToField
			CReplyToField
			CApprovedField
			CSenderField
			CExpiresField
			COrganizationField
			CSummaryField
			CReferencesField
            CControlField
			CLinesField
			CDistributionField
			CKeywordsField
			CNNTPPostingHostField
			CXAuthLoginNameField
		CNAMEREFLIST


    **** Overview ****

    An CArticle object provides an software interface for viewing
	and editing a netnews article.
	
	An object is initialized by
	giving it a handle or filename for a file containing a Netnews
	article. During initialization the article is "preparsed".
	Preparsing consists of memory mapping the file and then
	finding the location of
	    1. The gap that may preceed the article in the file.
		2. The article in the file.
		3. The article's header
		4. The article's body.

	Also for every header line in the header, the preparsing creates an
	entry in an array that records the location of:
		1. The header line
		2. The keyword
		4. The value

	All these locations are represented with Pointer/Counter Strings (See
	CPCString in pcstring.h.) This representation has just to parts
		1. A char pointer to the start of the item in the memory mapped file..
		2. A dword containing the length of the item.


  **** Fields ****

	Each CArticle object can also have several CField subobjects. These
	subobjects specialize in parsing and editing specific types of fields.
	For example, the CNewsgroupsField object knows how to validate, get,
	and set the "Newsgroups: " field.

  **** Derivied Objects ****

	Every type of feed (e.g. FromClient, FromPeer, etc) defines its own CArticle
	object with the CField subobjects that it needs. For example, for FromClient
	feeds there is a CFromClientArticle (defined in fromclnt.h) with a
	CFromClientFromField (also defined in fromclnt.h) that does very strict
	parsing of the article's "From: " field.

  **** Editing an Article ****

	The header of an article can be edited by deleting old headers and adding
	new ones. Headers are deleted just may marking an field in the array of
	header values. Headers are added by adding a new entry to the array. This
	entry can't just point to the memory-mapped file, so it instead points
	to dynamically allocated memory.

	When an article is "saved" (or "flushed"), the actual image on disk is
	changed to reflected the changes made.



Author:

    Carl Kadie (CarlK)     10-Oct-1995

Revision History:

--*/

#ifndef	_ARTCORE_H_
#define	_ARTCORE_H_

#include	"tigtypes.h"
#include	"grouplst.h"
#include    "artglbs.h"
#include 	"pcstring.h"
#include 	"nntpret.h"
#include 	"mapfile.h"
#include 	"artutil.h"
#include 	"nntpmacr.h"
#include 	"pcparse.h"
#include 	"nntpcons.h"
#include 	"timeconv.h"

// forward declaration
class	CInFeed ;

//
// CPool Signature
//

#define ARTCORE_SIGNATURE (DWORD)'artc'

//
//	Utility functions
//
BOOL	AgeCheck(	CPCString	pcDate	) ;

//
// NAME_AND_ARTREF - structure for storing a newsgroups name, groupid, and article id.
//

typedef struct _NAME_AND_ARTREF {
	CPCString pcName;
	CArticleRef artref;
} NAME_AND_ARTREF;


//
// CNAMEREFLIST - object implementing a list of newsgroups. For each newsgroup,
// its name, group id and article id is recorded.
//

#ifndef	_NO_TEMPLATES_

#ifndef _NAMEREF_GROUPLIST_TEMPLATE_
#define _NAMEREF_GROUPLIST_TEMPLATE_
typedef CGroupList< NAME_AND_ARTREF > CNAMEREFLIST;
#endif

#else

DECLARE_GROUPLST(	NAME_AND_ARTREF )

typedef	INVOKE_GROUPLST( NAME_AND_ARTREF )	CNAMEREFLIST ;

#endif




//
// An interger setting an upper limit on the number of
// fields in a header can be processed.
//

const unsigned int uMaxFields = 60;

//
// Used to note that the size of the gap before the article starts is
// not known.
//

const DWORD cchUnknownGapSize = (DWORD) -1;


//
// The maximum size of a component (e.g. "alt", "ms-windows") of a
// newsgroup name. (Value is from the Son of 1036 spec.)
//

const DWORD cchMaxNewsgroups = 14;

//
// Define some header field keywords
//

const char szKwFrom[] =			"From:";
const char szKwDate[] =			"Date:";
const char szKwSubject[] =		"Subject:";
const char szKwNewsgroups[] =	"Newsgroups:";
const char szKwMessageID[] =	"Message-ID:";
const char szKwPath[] =			"Path:";
const char szKwReplyTo[] =		"ReplyTo:";
const char szKwSender[] =		"Sender:";
const char szKwFollupTo[] =		"FollowupTo:";
const char szKwExpires[] =		"Expires:";
const char szKwReferences[] =	"References:";
const char szKwControl[] =		"Control:";
const char szKwDistribution[] =	"Distribution:";
const char szKwOrganization[] =	"Organization:";
const char szKwKeywords[] =		"Keywords:";
const char szKwSummary[] =		"Summary:";
const char szKwApproved[] =		"Approved:";
const char szKwLines[] =		"Lines:";
const char szKwXref[] =			"Xref:";
const char szKwNNTPPostingHost[] = "NNTP-Posting-Host:";
const char szKwFollowupTo[] =	"Followup-To:";
const char szKwXAuthLoginName[] =	"X-Auth-Login-Name:";

//
// Used to create an array that points to header values.
// The memory may be allocated in a mapped file or
// dynamically.
//

typedef struct
{
	CPCString	pcKeyword;		//  The keyword upto the ":"
	CPCString	pcValue;		//  The value (starting after any whitespace,

								//
								//		not including newline characters
								//

	CPCString	pcLine;			//  The whole line include any newline characters
	BOOL		fInFile;	//  True if pointer to a file (rather than other memory
	BOOL		fRemoved;
} HEADERS_STRINGS;


//
// Forward class declarations (the full classes are declared later)
//

class	CArticle;
class	CXrefField;
class	CPathField;
class   CArticleCore;

//
// Represents the states of a field.
//

typedef enum _FIELD_STATE {
	fsInitialized,
	fsFound,
	fsParsed,
	fsNotFound,
} FIELD_STATE;

//
// Represents the types of control messages
// The order should EXACTLY match the keyword array that follows
//

typedef enum _CONTROL_MESSAGE_TYPE {
	cmCancel,
	cmNewgroup,
	cmRmgroup,
	cmIhave,
    cmSendme,
    cmSendsys,
    cmVersion,
    cmWhogets,
    cmCheckgroups,
} CONTROL_MESSAGE_TYPE;

//
// Control message strings
//
#define MAX_CONTROL_MESSAGES 9

static  char  *rgchControlMessageTbl[ MAX_CONTROL_MESSAGES ] =
{
	"cancel", "newgroup", "rmgroup", "ihave", "sendme", "sendsys",
	"version", "whogets", "checkgroups",
};

//
//	Switch to decide what From: header to use in the envelope of mail messages
//
typedef enum _MAIL_FROM_SWITCH {
	mfNone,
	mfAdmin,
	mfArticle,
} MAIL_FROM_SWITCH;

static const char* lpNewgroupDescriptorTag = "For your newsgroups file:";
static const char lpModeratorTag[] = "Group submission address:";

//
//
//
// CField - pure virtual base class for manipulating a field in an
//			article.
//
//	Each CArticle object can also have several CField subobjects. These
//	subobjects specialize in parsing and editing specific types of fields.
//	For example, the CNewsgroupsField object knows how to validate, get,
//	and set the "Newsgroups: " field.
//

class	CField {

public :

	//
	// Constructor
	//

	CField():
		   m_pHeaderString(NULL),
		   m_fieldState(fsInitialized)
		   { numField++; };

	//
	// Deconstructor
	//

    virtual ~CField(void){ numField--;};

	//
	// Returns the keyword of the field on which this CField works.
	//

	virtual const char * szKeyword(void) = 0;

	//
	// Finds the field of interest in the article (if it is there)
	// and parses it.
	//

	BOOL fFindAndParse(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);


	//
	// Makes sure the keyword for this file has the correct
	// capitalization.
	//

	BOOL fConfirmCaps(
			CNntpReturn & nntpReturn
			);


	//
	// The derived objects will define Get(s) that return the type of interest, but
	// here are some virtual functions for the most common types.
	//

	//
	// Get the value in multisz form
	//

	virtual const char * multiSzGet(void)	{
			return (char *) NULL;
			};

	//
	// Get the value in DWORD form
	//

	virtual DWORD cGet(void) {
			return (DWORD) -1;
			};

	//
	// Get the value as a CPCString
	//

	virtual CPCString pcGet(void) {
			return m_pc;
			}

	//
	// Specify friends
	//

	friend CArticle;
	friend CPathField;

protected:


	// Finds this field in the article
	virtual BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Parses this field. By default just find the begining
	// and end of the value.

	virtual BOOL fParse(
				CArticleCore & article,
				CNntpReturn & nntpReturn)
			{
				return fParseSimple(FALSE, m_pc, nntpReturn);
			};

	// One type of "find" -- Find one or zero occurances of this field.
	// Any other number is a error.
	BOOL fFindOneOrNone(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "find" -- Find zero occurances of this field.
	// Any other number is a error.
	BOOL fFindNone(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Just finds the beginning and end of the value.
	BOOL fParseSimple(
			BOOL fEmptyOK,
			CPCString & pc,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Splits the value into a list of items.
	BOOL fParseSplit(
			BOOL fEmptyOK,
			char * & multisz,
			DWORD & c,
			char const * szDelimSet,
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the strict Newsgroups parse rules.
	BOOL fStrictNewsgroupsParse(
			BOOL fEmptyOK,
			char * & multiSzNewsgroups,
			DWORD & cNewsgroups,
		    CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the strict Date parse rules.
	// Useful for Date and Expires.
	BOOL fStrictDateParse(
			CPCString & pcDate,
			BOOL fEmptyOK,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the relative Date parse rules.
	// Useful for Date and Expires.
	BOOL fRelativeDateParse(
			CPCString & pcDate,
			BOOL fEmptyOK,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the strict From parse rules.
	// Useful for From, Sender, and ReplyTo
	BOOL fStrictFromParse(
			CPCString & pcFrom,
			BOOL fEmptyOK,
			CNntpReturn & nntpReturn
			);


	// Test a message id value for legal values.
	BOOL fTestAMessageID(
			const char * szMessageID,
			CNntpReturn & nntpReturn
			);
	
	// Points to the item in the article's array for this field.
	HEADERS_STRINGS * m_pHeaderString;

	// The state of this field
	FIELD_STATE m_fieldState;

	// The result of SimpleParse (this may not be used)
	CPCString m_pc;

};


//
//
// Pure virtual base class for manipulating an article's Date field.

class CDateField : public CField {

public:

    CDateField(){ numDateField++;};
    ~CDateField(void){ numDateField--;};

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwDate;
			};
};


//
//
// Pure virtual base class for manipulating an article's From field.

class CFromField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwFrom;
			};

};



//
//
// Pure virtual base class for manipulating an article's MessageID field.

class CMessageIDField : public CField {

public:
	//
	// Initalize the member variable
	//
	CMessageIDField (void)
			{
			m_szMessageID[0] = '\0';
			}

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwMessageID;
			};

	// Parse a message id field
	BOOL fParse(
			 CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Get the message id
	char * szGet(void) {
			return m_szMessageID;
			};

protected:
	// a place to store the message id that parsing findds
	char m_szMessageID[MAX_MSGID_LEN];
};



//
//
// Pure virtual base class for manipulating an article's Subject field.

class CSubjectField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwSubject;
			};

	// The subject field is parsed with ParseSimple
	BOOL fParse(
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
			{
				return fParseSimple(TRUE, m_pc, nntpReturn);
			};

	friend CArticle;

};


//
//
// Pure virtual base class for manipulating an article's Newsgroups field.
//

class CNewsgroupsField : public CField {

public:

	// Constructor
	CNewsgroupsField():
			m_multiSzNewsgroups(NULL),
			m_cNewsgroups((DWORD) -1),
			m_pAllocator(NULL)
			{};

	// Destructor
	virtual ~CNewsgroupsField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzNewsgroups);
				}
			};


	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwNewsgroups;
			};

	// Parse the Newsgroups field
	BOOL fParse(
			 CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Return the newsgroups as a multisz
	const char * multiSzGet(void);

	// Return the number of newsgroups found
	DWORD cGet(void);

	friend CXrefField;

protected:

	// A pointer to the dynamic memory used to hold the list of newsgroups
	char * m_multiSzNewsgroups;

	// The number of newsgroups
	DWORD m_cNewsgroups;

	// Where to allocate from
	CAllocator * m_pAllocator;

};



class CDistributionField : public CField {

public:

	// Constructor
	CDistributionField():
			m_multiSzDistribution(NULL),
			m_cDistribution((DWORD) -1),
			m_pAllocator(NULL)
			{};

	// Destructor
	virtual ~CDistributionField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzDistribution);
				}
			};


	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwDistribution;
			};

	BOOL fFind(
		CArticleCore & article,
		CNntpReturn & nntpReturn)
	{
		return fFindOneOrNone(article, nntpReturn);
	};

// Parse the Distribution field
	BOOL fParse(
			 CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Return the Distribution as a multisz
	const char * multiSzGet(void);

	// Return the number of Distribution found
	DWORD cGet(void);

protected:

	// A pointer to the dynamic memory used to hold the list of Distribution
	char * m_multiSzDistribution;

	// The number of Distribution
	DWORD m_cDistribution;

	// Where to allocate from
	CAllocator * m_pAllocator;

};

//
//  base class for manipulating an article's Control field.
//
class CControlField : public CField {

public:
    //
    // Constructor
    //
    CControlField(){ m_cmCommand = (CONTROL_MESSAGE_TYPE)MAX_CONTROL_MESSAGES;}

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwControl;
			};

	//
	// There should only be one such field in articles from clients.
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse to get the type of control message
	//
	BOOL fParse(
		    CArticleCore & article,
			CNntpReturn & nntpReturn
            );

    //
    // Return the type of control message
    //
    CONTROL_MESSAGE_TYPE    cmGetControlMessage(){return m_cmCommand;}

protected:
    //
    // Control message type
    //
    CONTROL_MESSAGE_TYPE    m_cmCommand;
};

//
//
// Pure virtual base class for manipulating an article's Xref field.

class CXrefField : public CField {

public:
		
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwXref;
			};

	// This is a way of saying that, by default, the Xref line should
	// never be parsed.
	virtual BOOL fParse(
				 CArticle & article,
				 CNntpReturn & nntpReturn
				 )
			{
				_ASSERT(FALSE);
				return FALSE;
			};

	// Create a new Xref line.
	BOOL fSet(
			CPCString & pcHub,
			CNAMEREFLIST & namereflist,
			CArticleCore & article,
			CNewsgroupsField & fieldNewsgroups,
			CNntpReturn & nntpReturn
			);

	// Just delete any Xref lines
	BOOL fSet(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);


	// Return the list of newsgroup name's, groupid, and article id's
	CNAMEREFLIST * pNamereflistGet(void)	{
			_ASSERT(m_namereflist.fAsBeenInited());
			return &m_namereflist;
			};

	// Return the number of newsgroups that we are posting to locally.
	DWORD cGet(void) {
			_ASSERT(m_namereflist.fAsBeenInited());
			return m_namereflist.GetCount();
			};

	friend CArticle;

protected:

	// Store a list of the local newsgroups we are posting to.
	CNAMEREFLIST m_namereflist;

};


//
//
// Pure virtual base class for manipulating an article's FollowupTo field.

class CFollowupToField : public CField {

public:

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwFollowupTo;
			};

};


//
//
// Pure virtual base class for manipulating an article's ReplyTo field.

class CReplyToField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwReplyTo;
			};
};

//
//
// Pure virtual base class for manipulating an article's Approved field.

class CApprovedField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwApproved;
			};

};

//
//
// Pure virtual base class for manipulating an article's Sender field.

class CSenderField	: public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwSender;
			};
};

//
//
// Pure virtual base class for manipulating an article's Expires field.

class CExpiresField	: public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwExpires;
			};
};

//
//
// Pure virtual base class for manipulating an article's Organization field.

class COrganizationField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwOrganization;
			};
};

//
//
// Pure virtual base class for manipulating an article's Summary field.

class CSummaryField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwSummary;
			};
};

//
//
// Pure virtual base class for manipulating an article's References field.

class CReferencesField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwReferences;
			};
};

//
//
// Pure virtual base class for manipulating an article's Lines field.
//

class CLinesField : public CField {

public:
		
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwLines;
			};

	//
	// There should be one or none
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};


	//
	// How to set the field.
	//

	virtual BOOL fSet(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	//
	// Do we need to back fill ?
	//
	BOOL fNeedBackFill() { return fsParsed != m_fieldState; }

	//
	// Get lines back fill offset
	//
	DWORD   GetLinesOffset() { return m_dwLinesOffset; }

private:

    //
    // back fill offset
    //
    DWORD   m_dwLinesOffset;

};

//
//
// Pure virtual base class for manipulating an article's Keywords field.

class CKeywordsField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwKeywords;
			};
};

//
//
// Pure virtual base class for manipulating an article's NNTPPostingHost field.

class CNNTPPostingHostField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwNNTPPostingHost;
			};
};

//
//
// Pure virtual base class for manipulating an article's XAuthLoginName field.

class CXAuthLoginNameField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwXAuthLoginName;
			};
};

//
// Represents the states of an article
//
typedef enum _ARTICLE_STATE {
	asUninitialized,
	asInitialized,
	asPreParsed,
	asModified,
	asSaved
} ARTICLE_STATE;

//
// CCreateFileImpl implements the way we create the file for mapfile,
// in this case we do CacheCreateFile.
//
class CCacheCreateFile : public CCreateFile {

public:
    CCacheCreateFile( BOOL fOpenForRead ) :
        m_fOpenForRead( fOpenForRead ),
        m_pFIOContext( NULL )
    {}
    ~CCacheCreateFile();
    virtual HANDLE CreateFileHandle( LPCSTR szFileName );

    PFIO_CONTEXT    m_pFIOContext;

private:

    CCacheCreateFile();
    static HANDLE CacheCreateCallback(  LPSTR   szFileName,
                                        LPVOID  pv,
                                        PDWORD  pdwSize,
                                        PDWORD  pdwSizeHigh );

    BOOL            m_fOpenForRead;
};

//
//
//
// CArticleCore - pure virtual base class for manipulating an article.
// Article are derived from CRefCount. Thus, when nothing points
// to an article it is freed up.


class	CArticleCore  : public CRefCount{
private :

	// Used for memory allocation
	static	CPool*	g_pArticlePool;

	// Uesd for special create file with CMapFile
	CCacheCreateFile m_CacheCreateFile;

//
// Public Members
//

public :

	// Used for memory allocation
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	inline	void*	operator	new(	size_t	size ) ;
	inline	void	operator	delete( void *pv ) ;

	//
	//   Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
    CArticleCore();

   	//
   	//   Destructor
   	//

    virtual ~CArticleCore() ;

	//
	//   Initialize from a filename or handle
	//

	BOOL fInit(
			const char * szFilename,
			CNntpReturn & nntpReturn,
			CAllocator * pAllocator,
			HANDLE hFile = INVALID_HANDLE_VALUE,
			DWORD	cBytesGapSize = cchUnknownGapSize,
			BOOL    fCacheCreate = FALSE
			);

	//
	//	If an incoming article was small enough to fit entirely into
	//	a memory buffer - call this function !
	//
	
	BOOL	fInit(
				char*		pchHead,
				DWORD		cbHead,
				DWORD		cbArticle,
				DWORD		cbBufferTotal,
				CAllocator*	pAllocator,
				CNntpReturn&	nntpReturn
				) ;

	//
	//	If an incoming article was so large that it did not fit into
	//	a memory buffer call this initialization function !
	//
	
	BOOL	fInit(
				char*		pchHead,
				DWORD		cbHead,
				DWORD		cbArticle,
				DWORD		cbBufferTotal,
				HANDLE		hFile,
				LPSTR		lpstrFileName,
				DWORD		ibHeadOffset,
				CAllocator*	pAllocator,
				CNntpReturn&	nntpReturn
				) ;

	//
	// create's an IStream pointer to the article contents and returns
	// it
	//
	BOOL fGetStream(IStream **ppStream);

	//
	//  Get body - map file if needed
	//

	BOOL fGetBody(
			CMapFile * & pMapFile,
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//	return TRUE if the article is in memory only and there is no file !
	//
	inline	BOOL	fIsArticleCached()	{
				return	m_szFilename == 0 ;
				}

	//
	//	Find out where the head and body of the article are within the file !
	//
	inline	void	GetOffsets(
						WORD	&wHeadStart,
						WORD	&wHeadSize,
						DWORD	&dwTotalSize
						)	{
		wHeadStart = (WORD)m_pcGap.m_cch ;
		wHeadSize  = (WORD)m_pcHeader.m_cch ;
		dwTotalSize = m_pcArticle.m_cch ;
	}

	//
	// These functions get (parts of) an article for transmission.
	// The second in each par of functions is useful when the article
	// is to be encrypted.
	//


	//
	//  Get header for file transmission
	//

	BOOL fHead(
			HANDLE & hFile,
			DWORD & dwOffset,
			DWORD & dwLength
			);

	//
	//  Get header for encryption
	//

	BOOL fHead(
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//  Get body for file transmission
	//

	BOOL fBody(
			HANDLE & hFile,
			DWORD & dwOffset,
			DWORD & dwLength
			);

	//
	//  Get body for encryption
	//

	BOOL fBody(
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//  Get body for encryption
	//

	DWORD dwBodySize(void)
		{
			return m_pcBody.m_cch;			
		}

	//
	//  Get whole article for file transmission
	//

	BOOL fWholeArticle(
			HANDLE & hFile,
			DWORD & dwOffset,
			DWORD & dwLength
			);

	//
	//  Get whole article for encryption
	//

	BOOL fWholeArticle(
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//   Sets the value of a header field including any newlines.
	// New values are always stored in dynamic memory allocated
	// with heap_alloc from the local thread. This function also sets
	// m_HeadersDirty and dwCurrentHeaderSize;
	//

	BOOL fSetHeaderValue(
			char const * szKeyword,
			const char * pchValue,
			DWORD cchValue
			);

	//
	// a header line of exactly the same length. It returns an error
	// if the lines aren't the same length.
	// Its expected use it to add the value of the XRef line to an
	// article without having to moving anything else around.
	//

	BOOL fOverwriteHeaderValue(
			char const * szKeyword,
			const char * pchValue,
			DWORD cchValue
			);

	//
	// Should we really changed the order the header lines just because we want
	// to touch "path" and "xref"?
	//
	//   Writes out the header. This means: Writing out the known fields in the
	// order they appear in the HEADER_FIELDS enumeration. If the gap is not big enough,
	// this will require coping the file. Unknown headers are written after the known ones.
	// This clears dwHeadersDirty, sets dwOriginalHeaderSize to be the current header size.
	// If another pass of changes is required, then m_fParse must be called again.
	// The parameter tell if the headers should be output in the original order or if they
	// should be output in the prefered order.
	//

	BOOL fSaveHeader(
			CNntpReturn     &nntpReturn,
			PDWORD          pdwLinesOffset = NULL
			);

	BOOL fSaveCachedHeaderInternal(
			CNntpReturn&	nntpReturn,
			PDWORD          pdwLinesOffset = NULL
			) ;

	BOOL fBuildNewHeader(	
			CPCString&	pcHeaderBuf	,
			CNntpReturn&	nntpReturn,
			PDWORD          pdwLinesOffset = NULL
			) ;

	//
	// calling this function makes it safe to use fGetHeader after a
	// call to vClose.
	//
	BOOL fMakeGetHeaderSafeAfterClose(CNntpReturn &nntpReturn);

	BOOL fSaveHeaderInternal(
			CPCString & pcHeaderBuf,
			CPCString & pcNewBody,
			CNntpReturn & nntpReturn,
			PDWORD      pdwLinesOffset = NULL
			);

	BOOL fGetHeader(
			LPSTR	lpstrHeader,
			BYTE*	lpbOutput,
			DWORD	cbOutput,
			DWORD&	cbReturn
			) ;
			

	// Removes any occurance of a field

	BOOL fRemoveAny(
			const char * szKeyword,
			CNntpReturn & nntpReturn
			);

	// Adds a line of text to the header

	BOOL fAdd(
			char * pchCurrent,
			const char * pchMax,
			CNntpReturn & nntpReturn
			);

	// Returns the article's filename
	char *	szFilename(void) {
			return m_szFilename;
			};


	//
	// For dynamic memory allocation
	//

	CAllocator * pAllocator(void)
		{ return m_pAllocator;}

	// Returns the article's main artref
	CArticleRef	articleRef(void) {
			return m_articleRef;
			};

	// Sets the article's main artref
	void vSetArticleRef(CArticleRef	& articleRef) {
			m_articleRef = articleRef;
			};

	// Returns XOver information for the article.
	BOOL fXOver(
			CPCString & pcBuffer,
			CNntpReturn & nntpReturn
			);

	// Closes the article's filemapping.
	void vClose(void);
	void vCloseIfOpen(void);

	//	Flush the article to disk !
	void	vFlush(void);

	// Finds the one and only occurance of the a field in the headers.
	// If there are no occurances or multiple occurances, then an error
	// is returned.

	BOOL fFindOneAndOnly(
			const char * szKeyword,
			HEADERS_STRINGS * & pHeaderString,
			CNntpReturn & nntpReturn
			);

	friend CField;

	//
	//	Public interface which should be used if fSaveHeader() is not called
	//	to fill in any initial gap within the file !
	//
	BOOL	
	fCommitHeader(	
			CNntpReturn &	nntpReturn
			) ;
			

	//
	//	Did the headers remain in the IO buffer - if so where ?
	//
	BOOL
	FHeadersInIOBuff(	char*	pchStartIOBuffer, DWORD	cbIOBuffer )	{
		if( m_pcHeader.m_pch > pchStartIOBuffer &&
			m_pcHeader.m_pch < &pchStartIOBuffer[cbIOBuffer] ) 	{
			_ASSERT( (m_pcHeader.m_pch + m_pcHeader.m_cch) < (m_pcHeader.m_pch + cbIOBuffer) ) ;
			return	TRUE ;
		}
		return	FALSE ;
	}

	DWORD	
	GetHeaderPosition(	char*	pchStartIOBuffer,
						DWORD	cbIOBuffer,	
						DWORD&	ibOffset
						) 	{
		//
		//	Only use this function if FHeadersInIOBuff() returns TRUE !
		//
		_ASSERT( FHeadersInIOBuff( pchStartIOBuffer, cbIOBuffer ) ) ;
		ibOffset = (DWORD)(m_pcHeader.m_pch - pchStartIOBuffer) ;
		return	m_pcHeader.m_cch + 2 ;
	}
	
	// get the length of the headers.  we add space for the \r\n
	DWORD GetHeaderLength(	) {
		return m_pcHeader.m_cch + 2;
	}

	// copy the headers into another buffer.  the buffer must be at least
	// GetHeaderLength characters long
	void CopyHeaders(char *pszDestination) {
		memmove(pszDestination, m_pcHeader.m_pch, m_pcHeader.m_cch);
		memmove(pszDestination + m_pcHeader.m_cch, "\r\n", 2);
	}

	// get the length of the headers.  no space for \r\n
	DWORD GetShortHeaderLength() { return m_pcHeader.m_cch; }

	char *GetHeaderPointer() {
		return m_pcHeader.m_pch;
	}

	//
	// protected Members
	//

protected :

	// The function that is actually used to add lines to
	// the article's header.
	BOOL fAddInternal(
			char * & pchCurrent,
			const char * pchMax,
			BOOL fInFile,
			CNntpReturn & nntpReturn
			);

	//
	//  the name of the article's file
	//

	LPSTR	m_szFilename ;

	//
	//  A handle to the article's file
	//

	HANDLE  m_hFile;

	//
	//	Offset to the body of the article within the file !
	//

	DWORD	m_ibBodyOffset ;

	//
	//  A pointer to a file mapping of the article
	//

	CMapFile * m_pMapFile;

	//
	//	If we have to allocate a buffer to hold a header which grows at some
	//	point we will set this pointer.
	//
	char*	m_pHeaderBuffer ;

	//
	//  a pointer-and-count string that points to the
	// whole article
	//

	CPCString m_pcFile;

	//
	//  a pointer-and-count string that points to the
	//	gap
	//

	CPCString m_pcGap;

	//
	//  a pointer-and-count string that points to the
	//	whole article
	//

	CPCString m_pcArticle;

	//
	// Fill the gap in the file with blanks (and other info).
	//

	void vGapFill(void);

	//
	//  build an array pointing to known header types
	//

	BOOL fPreParse(
			CNntpReturn & nntpReturn
			);

	//
	//  a pointer-and-count string that points to the
	//	header of the article
	//

	CPCString m_pcHeader;

	//
	//  a pointer-and-count string that points to the
	//	body of the article.
	//

	CPCString m_pcBody;

	//
	//  An array that points to the header fields
	//

	HEADERS_STRINGS m_rgHeaders[(unsigned int) uMaxFields];

	//
	//  The article reference for this article
	//

	CArticleRef m_articleRef;

	//
	// For dynamic memory allocation
	//

	CAllocator * m_pAllocator;

	//
	// the number of fields in the header.
	//

	DWORD m_cHeaders;

	
	//
	// Removed deleted entries from the array of headers.
	//

	void vCompressArray(void);

	//
	// Find the size of the gap by looking at the file.
	//

	void vGapRead(void);

	//
	// Remove a header line.
	//

	void vRemoveLine(
			HEADERS_STRINGS * phs
			);

	//
	// Remove all header lines that have no values.
	//

	BOOL fDeleteEmptyHeader(
			CNntpReturn & nntpReturn
			);

	//
	// Record the state of the article.
	//

	ARTICLE_STATE m_articleState;

	//
	// Add more information to the XOver data.
	//

	BOOL fXOverAppend(
			CPCString & pc,
			DWORD cchLast,
			const char * szKeyword,
			BOOL fRequired,
			BOOL fIncludeKeyword,
			CNntpReturn & nntpReturn
			);

	//
	// Add References information to the XOver data. Shorten the
	// data if necessary.
	//

	BOOL fXOverAppendReferences(
			CPCString & pc,
			DWORD cchLast,
			CNntpReturn & nntpReturn
			);
	//
	// Append a string to the XOver data.
	//

	BOOL fXOverAppendStr(
			CPCString & pc,
			DWORD cchLast,
			char * const sz,
			 CNntpReturn & nntpReturn
			 );

	//
	// Tells if the article should open the file with read/write mode.
	//

	virtual BOOL fReadWrite(void) { return FALSE ;}

	//
	// Check if the length of the article's body is not too long.
	//


	virtual BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn) { return TRUE; };

	//
	// Check the character following the ":" in a header.
	//

	virtual BOOL fCheckFieldFollowCharacter(
			char chCurrent) { return TRUE; }

	//
	// Run "FindAndParse" on a list of fields.
	//

	BOOL fFindAndParseList(
			CField * * rgPFields,
			DWORD cFields,
			CNntpReturn & nntpReturn
			);

	//
	// Run "ConfirmCaps" on a list of fields.
	//

	BOOL fConfirmCapsList(
			CField * * rgPFields,
			DWORD cFields,
			CNntpReturn & nntpReturn
			);

	BOOL ArtCloseHandle( HANDLE& );

	friend CField;
	friend CMessageIDField;
	friend CNewsgroupsField;

} ;

extern const unsigned cbMAX_ARTCORE_SIZE;

inline  void*
CArticleCore::operator  new(    size_t  size )
{
    _ASSERT( size <= cbMAX_ARTCORE_SIZE ) ;
    return  g_pArticlePool->Alloc() ;
}

inline  void
CArticleCore::operator  delete( void*   pv )
{
    g_pArticlePool->Free( pv ) ;
}

//
//
// Pure virtual base class for manipulating an article's Path field.

class CPathField : public CField {

public:
	// Constructor
	CPathField():
			m_multiSzPath(NULL),
			m_cPath((DWORD) -1),
			m_pAllocator(NULL),
			m_fChecked(FALSE)
			{};

	//
	//   Deconstructor
	//

	virtual ~CPathField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzPath);
				}
			};


	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwPath;
			};

	//
	//!!!constize
	//!!! is a null path OK?
	//!!!CLIENT NEXT
	//

	// Parse the Path value into its components.
	BOOL fParse(
				CArticleCore & article,
				CNntpReturn & nntpReturn
				)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fParseSplit(FALSE, m_multiSzPath, m_cPath, " \t\r\n!",
				article, nntpReturn);
			};

	// Return the path as a multsz list.
	const char * multiSzGet(void);

	// Set a new path by appending our hub to the old value.
	BOOL fSet(
			CPCString & pcHub,
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);


	// Check for a loop by looking for our hub in the path (by not in the last location)
	BOOL fCheck(
			CPCString & pcHub,
			CNntpReturn & nntpReturn
			);

protected:

	// A pointer to the dynamic memory that contains the path as a multisz
	char * m_multiSzPath;

	// The number of components in the path.
	DWORD m_cPath;

	// Where to allocate from
	CAllocator * m_pAllocator;

	// True, if and only if, the path has been checked for a loop.
	BOOL m_fChecked;
};

//
// Some other functions
//

// Test a newsgroup name for legal values.
BOOL fTestComponents(
		const char * szNewsgroups
		);


// Tests the components of a newsgroup name (e.g. "alt", "ms-windows") for
// legal values.
BOOL fTestAComponent(
		const char * szComponent
		);

//
//  Largest possible CArticle derived object
//
#define MAX_ARTCORE_SIZE    sizeof( CArticleCore )
#define MAX_SESSIONS        15000
#define	MAX_ARTICLES	(2 * MAX_SESSIONS)

#define MAX_REFERENCES_FIELD 512
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cache2.h ===
/*++

	Cache2.h

	This header file defines an LRU0 cache template that
	can be used to hold arbitrary objects !

	Items in the Cache must have the following format :

	class	DataItem	{
		ICacheRefInterface*		m_pCacheRefInterface ;
	} ;

    class   Constructor {
        DATA*
        Create( KEY&, PERCACHEDATA& )
        void
        Release( DATA*, PERCACHEDATA* )
        void
        StaticRelease( DATA*, PERCACHEDATA* )
    }

--*/


#ifndef	_CACHE2_H_
#define	_CACHE2_H_

#include	"randfail.h"

#include	"fdlhash.h"
#include	"lockq.h"
#include	"tfdlist.h"
#include	"rwnew.h"
#include	"refptr2.h"

typedef	CShareLockNH	CACHELOCK ;


class	CAllocatorCache	{
/*++

Class Description :

	This class provides a Memory Allocation cache - we work with
	an operator new provide below.   We exist to provide some
	optimizations for allocations of the elements of the caches
	specified in this module.

NOTE :

	We assume the caller provides all locking !

--*/
private :
	//
	//	The structurure we use to keep our free list !
	//
	struct	FreeSpace	{
		struct	FreeSpace*	m_pNext ;
	} ;

	//
	//	Size of each element - clients must not ask for something bigger !
	//
	DWORD	m_cbSize ;
	//
	//	Number of elements in our list at this moment !
	//
	DWORD	m_cElements ;
	//
	//	The maximum number of elements we should hold !
	//
	DWORD	m_cMaxElements ;
	//
	//	Top of the stack !
	//
	struct	FreeSpace*	m_pHead ;

	//	
	//	Make the following private - nobody is allowed to use these !
	//
	CAllocatorCache( CAllocatorCache& ) ;
	CAllocatorCache&	operator=( CAllocatorCache& ) ;

public :

	//
	//	Initialize the Allocation Cache !
	//
	CAllocatorCache(	DWORD	cbSize,
						DWORD	cMaxElements = 512
						) ;

	//
	//	Destroy the Allocation Cache - release extra memory back to system !
	//
	~CAllocatorCache() ;

	//
	//	Allocate a block of memory
	//	returns NULL if Out of Memory !
	//
	void*
	Allocate(	size_t	cb ) ;

	//
	//	Return some memory back to the system heap !
	//
	void
	Free(	void*	pv ) ;
} ;





class	ICacheRefInterface : public CQElement	{
/*++

Class	Description :

	This class defines the interface for Cache References -
	the mechanism that allows multiple caches to reference
	a single data item.

--*/
protected :

	//
	//	Add an item to the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	AddCacheReference( class	ICacheRefInterface*,	void*	pv, BOOL	) = 0 ;

	//
	//	Remove an item from the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	RemoveCacheReference(	BOOL	fQueue ) = 0 ;

	//
	//	Remove all references to the cache item !
	//
	virtual BOOL
	RemoveAllReferences( ) = 0 ;
} ;

#include	"cintrnl.h"


// This callback function is used to issue a stop hint during a
// long spin while shutting down so that the shutdown won't time
// out.
typedef void (*PSTOPHINT_FN)();

extern	CRITICAL_SECTION	g_CacheShutdown ;

//
//	Call these functions to initialize the Cache Library
//
extern	BOOL	__stdcall CacheLibraryInit() ;
extern	BOOL	__stdcall CacheLibraryTerm() ;

template	<	class	Data, 
				class	Key
				>
class	CacheExpungeObject	{
public : 

	//
	//	This function is called to determine whether we should remove 
	//	the item from the cache.
	//
	//	pKey - Pointer to the Key of the item in the cache
	//	pData - Pointer to the data for the item in the cache 
	//	cOutstandingReferences - The number of times of outstanding check-outs on the item !
	//	fMultipleReferenced - TRUE if there is more than one cache that contains
	//		this item !
	//
	virtual
	BOOL
	fRemoveCacheItem(	Key*	pKey, 
						Data*	pData
						) = 0 ;

} ;

template	<	class	Data >
class	CacheCallback	{
public :
	virtual	BOOL	fRemoveCacheItem(	Data&	d )	{
		return	FALSE ;
	}
} ;


class	CacheStats : public	CHashStats	{
public :

	enum	COUNTER	{
		ITEMS,				//	Number of items in the cache
		CLRU,				//	Number of items in the LRU List
		EXPIRED,			//	Number of items that have been expired !
		INSERTS,			//	Number of items inserted over time
		READHITS,			//	Number of times we've had a cache hit needing only readlocks during FindOrCreate()!
		SUCCESSSEARCH,		//	Number of times we've successfully searched for an item !
		FAILSEARCH,			//	Number of times we've failed to find an item !
		RESEARCH,			//	Number of times we've had to search a second time for an item
		WRITEHITS,			//	Number of times we've had a cache hit requiring a PartialLock()
		PARTIALCREATES,		//	Number of times we've created an item with only a PartialLock
		EXCLUSIVECREATES,	//	Number of times we've created an item with an Exclusive Lock !
		CEFAILS,			//	Number of times we've failed to allocate a CACHEENTRY structure
		CLIENTALLOCFAILS,	//	Number of times we've failed to allocate a Data object
		CLIENTINITFAILS,	//	Number of times a client object has failed to initialize !
		MAXCOUNTER			//	A Invalid Counter - all values smaller than this !
	} ;
	//
	//	Array of longs to hold different values !
	//
	long	m_cCounters[MAXCOUNTER] ;

	CacheStats()	{
		ZeroMemory( m_cCounters, sizeof(m_cCounters) ) ;
	}
} ;


typedef	CacheStats	CACHESTATS ;


inline	void
IncrementStat(	CacheStats*	p, CACHESTATS::COUNTER	c ) {
	_ASSERT( c < CACHESTATS::MAXCOUNTER ) ;
	if( p != 0 ) {
		InterlockedIncrement( &p->m_cCounters[c] ) ;
	}
}

inline	void
AddStat(	CacheStats*p, CACHESTATS::COUNTER	c, long	l ) {
	_ASSERT( c < CACHESTATS::MAXCOUNTER ) ;
	if( p != 0 ) {
		InterlockedExchangeAdd( &p->m_cCounters[c], l ) ;
	}
}

inline	void
DecrementStat(	CacheStats* p, CACHESTATS::COUNTER	c )		{
	_ASSERT( c < CACHESTATS::MAXCOUNTER ) ;
	if( p != 0 ) {
		InterlockedDecrement( &p->m_cCounters[c] ) ;
	}
}

template	<	class	Data,
				class	Key,
				class	Constructor,
				class	PerCacheData = LPVOID
				>
class	CacheEx :	public	CacheTable	{
public :

	//
	//	For compare, hash functions etc.... we will use this type !
	//
	typedef	Data	DATA ;
	typedef	Key		KEY ;
	typedef	Key*	PKEY ;

	//
	//	Hash Computation function
	//
	typedef	DWORD	(*PFNHASH)( PKEY ) ;

	//
	//	Key Comparison function - to be provided by caller !
	//
	typedef	int	(*PKEYCOMPARE)(PKEY, PKEY) ;

	//
	//	Callback objects for Expunge Operations !
	//
	typedef	CacheCallback< DATA >	CALLBACKOBJ ;

	//
	//	Objects that the user can give to the cache to manage the removal of items !
	//
	typedef	CacheExpungeObject<	DATA, KEY >	EXPUNGEOBJECT ;

private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CCacheItemKey< DATA, KEY, Constructor, PerCacheData >	CACHEENTRY ;

	//
	//	Define the helper class for Hash Tables
	//
	typedef	TFDLHash< CACHEENTRY, PKEY, &CacheState::HashDLIST >	HASHTABLE ;

	//
	//	An iterator that lets us walk everything in the hash table !
	//
	typedef	TFDLHashIterator< HASHTABLE >	HASHITER ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	An object to collect statistics about cache operations !
	//	This may be NULL !
	//
	class	CacheStats*				m_pStats ;

	//
	//	A list of everything in the Cache, used for TTL processing
	//
	CLRUList						m_ExpireList ;

	//
	//	A hash table we use to find things within the Cache
	//
	HASHTABLE						m_Lookup ;

	//
	//	Pointer to a runtime-user provided function which is used
	//	to determine what things should be removed from the Cache
	//
//	BOOL							(* m_pfnExpungeSpecific )( Data & ) ;

	//	
	//	Pointer to a runtime-user provided object derived from CacheCallback< Data >
	//	which lets the user invoke some function for each item in the Cache !
	//
	CALLBACKOBJ*					m_pCallbackObject ;

	//
	//	Reader writer lock which protects all these data structures !
	//
	CACHELOCK						m_Lock ;

	//
	//	The initial TTL we should assign to all newly cached objects !
	//
	DWORD							m_TTL ;

	//
	//	The cache used for creation/deletion of our CACHEENTRY objects !
	//
	CAllocatorCache					m_Cache ;


protected :

	//
	//	Virtual function called by CScheduleThread's thread which
	//	we use to bump TTL counters
	//
	void
	Schedule();

	//
	//	Function which removes an Entry from the Cache !
	//
	BOOL	
	RemoveEntry(	
			CacheState*	pEntry
			) ;

	//
	//	Virtual Function called by CacheList when we pass call
	//	CacheList::ExpungeSpecific
	//
	BOOL	
	QueryRemoveEntry(	
			CacheState*	pEntry
			) ;

	//
	//	Virtual Function part of CacheTable interface - used
	//	by LRUList to do appropriate locking !
	//
	CACHELOCK&
	GetLock()	{
		return	m_Lock ;
	}

public :

	//
	//	This is the users extra data - we will provide it on calls
	//	to constructor objects so that they can track some state sync'd
	//	with the cache locks !
	//
	PerCacheData	m_PerCacheData ;

	//
	//	This function is used to return an item to the cache -
	//	it will bump down a ref count for the number of clients
	//	currently using the item !
	//
	static	void
	CheckIn( DATA* ) ;

	//
	//	This function is provided for cases when the client needs
	//	to check-in an item from a Cache Callback function (i.e. Expunge)
	//
	//
	static	void
	CheckInNoLocks(	DATA*	) ;

	//
	//	This function is used to add a client reference to an item in the cache !
	//
	static	void
	CheckOut(	DATA*,
				long	cClientRefs = 1
				) ;

	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	CacheEx( ) ;

	//
	//	Destructor - remove ourselves from schedule list before continuing !
	//
	~CacheEx() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			PFNHASH	pfnHash,
			PKEYCOMPARE	pKeyCompare,
			DWORD	dwLifetimeSeconds,
			DWORD	cMaxInstances,
			CACHESTATS*	pStats,
			PSTOPHINT_FN pfnStopHint = NULL
			) {
	/*++

	Routine Description :

		This function initializes the cache so that it is ready
		to take entries.

	Arguments :

		pfnHash - function to be used to compute hash values on keys
		dwLifetimeSeconds - The number of seconds objects should live in the Cache
		pfnStopHint - function to be used to send stop hints during
		  long spins so shutdown's don't time out.

	Return Value :

		TRUE if successfull

	--*/

		m_pStats = pStats ;

		m_ExpireList.Init(	cMaxInstances,
							dwLifetimeSeconds
							) ;
		
		return	m_fValid = m_Lookup.Init(
										256,
										128,
										4,
										pfnHash,
										&CACHEENTRY::GetKey,
										pKeyCompare,
										0,
										pStats
										) ;
	}

	void
	Expire() {

		EnterCriticalSection( &g_CacheShutdown ) ;

		DWORD	c = 0 ;
		m_ExpireList.Expire( this, &m_Cache, c, &m_PerCacheData ) ;

		LeaveCriticalSection( &g_CacheShutdown ) ;

	}

	//
	//	Called to remove all items from the cache !
	//
	BOOL
	EmptyCache() ;

	BOOL
	ExpungeItems(
				EXPUNGEOBJECT*	pExpunge
				) ; 

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	ExpungeKey(	
			DWORD	dwHash,
			PKEY	key
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//

	//
	//	INTERNAL API's - These are public for convenience - not intended
	//	for Use outside of cachelib !!
	//
	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result !
	//
	//	
	//
	BOOL
	FindOrCreateInternal(	
			DWORD	dwHash,
			KEY&	key,
			Constructor&	constructor,
			DATA*	&pData,
			BOOL	fEarlyCreate = FALSE  /* Best Perf if this is FALSE - but required by some users !*/
			) ;

	//
	//	Find the item if it is in the cache !
	//
	DATA*	
	FindInternal(
			DWORD	dwHash,
			KEY&	key
			) ;

	//
	//	Insert a new item into the cache -
	//	We get to specify whether and what kind of reference
	//	we will hold outside of the cache !
	//
	BOOL
	InsertInternal(
			DWORD	dwHash,
			KEY&	key,
			DATA*	pData,
			long	cClientRefs = 0
			) ;

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData = LPVOID
				>
class	MultiCacheEx {
public:

	typedef	Data	DATA ;
	typedef	Key		KEY ;
	typedef	Key*	PKEY ;

	//
	//	Hash Computation function
	//
	typedef	DWORD	(*PFNHASH)( PKEY ) ;

	//
	//	Key Comparison function - to be provided by caller !
	//
	typedef	int	(*PKEYCOMPARE)(PKEY, PKEY) ;

	//
	//	Callback objects for Expunge Operations !
	//
	typedef	CacheCallback< DATA >	CALLBACKOBJ ;

	//
	//	Objects that the user can give to the cache to manage the removal of items !
	//
	typedef	CacheExpungeObject<	DATA, KEY >	EXPUNGEOBJECT ;


private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CCacheItemKey< DATA, KEY, Constructor, PerCacheData >	CACHEENTRY ;
	//
	//	Define the type for a single instance !
	//
	typedef	CacheEx< Data, Key, Constructor, PerCacheData >	CACHEINSTANCE ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	Pointer to the various Cache's we subdivide our work into
	//
	CACHEINSTANCE					*m_pCaches ;

	//
	//	Number of sub cache's we use to split up the work !
	//
	DWORD							m_cSubCaches ;

	//
	//	We use the hash function to choose which of our subcaches to work with !
	//
	typename CACHEINSTANCE::PFNHASH			m_pfnHash ;

	//
	//	Return the correct cache instance to hold the selected piece of data !
	//
	DWORD							ChooseInstance( DWORD	dwHash ) ;

public :

	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	MultiCacheEx(  ) ;

	//
	//	Destructor - destroys are various sub cache's
	//
	~MultiCacheEx() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			PFNHASH	pfnHash,
			PKEYCOMPARE	pfnCompare,
			DWORD	dwLifetimeSeconds,
			DWORD	cMaxElements,
			DWORD	cSubCaches,
			CACHESTATS*	pStats,
			PSTOPHINT_FN pfnStopHint = NULL
			) ;

	//
	//	Expire items in the cache !
	//
	void
	Expire() ;

	//
	//	Called to remove all items from the cache !
	//
	BOOL
	EmptyCache() ;

	//
	//	The user wants to remove a large set of items from the cache !
	//
	BOOL
	ExpungeItems(
				EXPUNGEOBJECT*	pExpunge
				) ; 

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	ExpungeKey(	
			PKEY	key
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	Data*
	FindOrCreate(	
			Key&	key,
			Constructor&	constructor,
			BOOL	fEarlyCreate = FALSE
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//	NOTE : This is for use when the caller has a cheaper
	//	way to compute the hash value then us - in debug we
	//	need to assure that the caller correctly computes this !
	//
	Data*
	FindOrCreate(	
			DWORD	dwHash,
			Key&	key,
			Constructor&	constructor,
			BOOL	fEarlyCreate = FALSE
			) ;

	//
	//	Find an item in the cache - hash of key is precomputed !
	//
	Data*
	Find(	DWORD	dwHash,
			KEY&	key
			) ;

	//
	//	Find an item in the cache
	//
	Data*
	Find(	KEY&	key ) ;

	//
	//	Insert a new item into the cache -
	//	We get to specify whether and what kind of reference
	//	we will hold outside of the cache !
	//
	BOOL
	Insert( DWORD	dwHash,
			KEY&	key,
			Data*	pData,
			long	cClientRefs = 0
			) ;

	//
	//	Insert a new item into the cache -
	//	We get to specify whether and what kind of reference
	//	we will hold outside of the cache !
	//
	BOOL
	Insert( KEY&	key,
			Data*	pData,
			long	cClientRefs = 0
			) ;





	//
	//	This function is used to return an item to the cache -
	//	it will bump down a ref count for the number of clients
	//	currently using the item !
	//
	static	void
	CheckIn( DATA* ) ;

	//
	//	This function is provided for cases when the client needs
	//	to check-in an item from a Cache Callback function (i.e. Expunge)
	//
	//
	static	void
	CheckInNoLocks(	DATA*	) ;

	//
	//	This function is used to add a client reference to an item in the cache !
	//
	static	void
	CheckOut(	DATA*,
				long	cClientRefs = 1	
				) ;

} ;



#include	"cache2i.h"


#endif	// _CACHE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\abtype.h ===
//+---------------------------------------------------------------
//
//  File:   Abtype.h
//
//  Synopsis:   Includes all defs and datatype used in MSN Address Book 2.x
//
//  Copyright (C) 1995 Microsoft Corporation
//          All rights reserved.
//
//  History:    SunShaw     Created                 30 Jan 1996
//              FeiSu       modified error code     21 May 1996
//
//----------------------------------------------------------------



#ifndef  _AB_TYPE_H_
#define  _AB_TYPE_H_


#include <wtypes.h>
#include <dbsqltyp.h>


#define AB_API_SIGNATURE    (DWORD) 'PABA'
#define AB_DOMAIN_LIST_SIG  (DWORD) 'ldbA'

//+---------------------------------------------------------------
//
// Definitions used in MSN Address Book 2.x
//
//----------------------------------------------------------------

#define AB_MAX_MONIKER  (250)
#define AB_MAX_LOGIN    (64)

#define AB_MAX_EMAIL    (AB_MAX_LOGIN)
#define AB_MAX_DOMAIN   (250)
#define AB_MAX_FULL_EMAIL_WO_NULL   (AB_MAX_LOGIN + AB_MAX_DOMAIN + 1)
#define AB_MAX_INTERNAL_FULL_EMAIL  (AB_MAX_LOGIN + AB_MAX_DOMAIN + 1 + 1)
#define AB_MAX_CONTEXT_NAME (16)
#define AB_MAX_CONFIG   (512)
#define AB_MAX_VROOT    (250)
#define AB_MAX_LDAP_DN  (AB_MAX_INTERNAL_FULL_EMAIL)
#define AB_MAX_AUTOREPLY_SUBJECT (250)

#define AB_SUCCESS                  0x00000000  //  Success
#define AB_SUCCESS_NOTLOCAL         0x00000001  //  AB Internal Use only

#define MAX_SERVERNAME          31  // same value, different name as defined in sqlfront.h
#define MAX_NAME                30  // same value, different name as defined in sqlfront.h

/////////////////////////////////////////////////////////////////////
//
//  Abook error codes are moved to abmsg.h, which is generated by abmsg.mc
//  To add a new error code, check both abmsg.mc and abget.cpp
//
/////////////////////////////////////////////////////////////////////
#define WIN32_ERROR_FROM_AB

//+---------------------------------------------------------------
//
// Types used in MSN Address Book 2.x
//
//----------------------------------------------------------------

typedef DWORD ABRETC;   // Address Book Return Code


typedef struct tagDOMAIN_LIST {
    DWORD       dwSignature;
    CHAR        szDomainName[AB_MAX_DOMAIN+1];
    LIST_ENTRY  list;
} DOMAIN_LIST;


// added june 5th 1996
typedef struct tagABUSER {
    CHAR    szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    CHAR    szForward[AB_MAX_INTERNAL_FULL_EMAIL];
    BOOL    fLocal;
    DWORD   cbMailBoxSize;
    DWORD   cbMailBoxMessageSize;
    CHAR    szVRoot[AB_MAX_VROOT];
} ABUSER;

typedef struct tagABDL {
    CHAR    szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    DWORD   dwToken;
} ABDL;


//  The ABROUTING structure contains the information necessary for
//  the mail servers to route mail to a user.
typedef enum tagABSTATUS {
    absUnknown      = 0,    // CAddr should be initialize with this value
    absLocal        = 1,
    absUnresolved   = 3,
    absNotLocal     = 4,
    absNotUsed      = 6,    // Just discard the CAddr
    absNotDelivered = 7,    // Local mail delivery failed
    absAccessDenied = 8,    // Access Denied to usage the DL
    absDelivered    = 9,    // Need for DL to file
    //
    // Values from 60 to 200 are reserved for Abook Internal Use Only
    //
    absInPartial    = 60,
    absInDistList   = 64,   // Is Small DL with no public token, needs to call GetAccountRight
    absInDistListEx = 128   // Is Large DL with no public token, needs to call
                            //      GetAccountRight then AbResolveAddressEx

} ABSTATUS;

#define ABROUTING_SIGNATURE 'gtRA'

typedef struct tagABROUTING {
    DWORD       dwSignature;
    ABSTATUS    abstatus;
    CHAR        szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];
    CHAR        szVRoot[AB_MAX_MONIKER];
    CHAR        szDN[AB_MAX_LDAP_DN];
    CHAR        szAutoReplySubject[AB_MAX_AUTOREPLY_SUBJECT];
    DWORD       cbMaxInbox;
    DWORD       cbMaxInboxMessages;
    BOOL        fAutoReply;
} ABROUTING, *PABROUTING;

#define ABRESOLVE_SIGNATURE 'vsRA'
typedef struct tagABRESOLVE
{
    DWORD       dwSignature;
    HANDLE      hConnection;
    PVOID       dbproc;
} ABRESOLVE, *PABRESOLVE;

typedef struct tagABPARTIALINFO {
    DWORD   dwAbMagicId;
    DWORD   dwAbInfoId;
    DWORD   dwAbToken;
    DWORD   dwAbType;
} ABPARTIALINFO, *PABPARTIALINFO;




typedef struct tagABROUTINGEX {
    ABSTATUS    abs;
    CHAR        szFullEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    ABROUTING   abrouting;
} ABROUTINGEX, *PABROUTINGEX;


typedef ULONG ABIID;        // AbInfoId

// Address Book Type Search Flag
typedef ULONG ABTSF;
#define ABTSF_ACCOUNT       0x00000001      // 1
#define ABTSF_NORMAL_DL     0x00000040      // 64
#define ABTSF_EXTENED_DL    0x00000080      // 128
#define ABTSF_DOMAIN_DL     0x00000100      // 256
#define ABTSF_SITE_DL       0x00000200      // 512
#define ABTSF_DISTLIST      (ABTSF_NORMAL_DL | ABTSF_EXTENDED_DL | ABTSF_DOMAIN_DL | ABTSF_SITE_DL)
#define ABTSF_ALLTYPE       0xffffffff

typedef enum {
    abtUnknown      = 0,
    abtAccount      = ABTSF_ACCOUNT,
    abtNormalDL     = ABTSF_NORMAL_DL,
    abtExtendedDL   = ABTSF_EXTENED_DL,
    abtDomainDL     = ABTSF_DOMAIN_DL,
    abtSiteDL       = ABTSF_SITE_DL
} ABTYPE;

typedef enum {
    abasValid   = 0,
    abasExpired = 1
} ABACCTSTATUS;


typedef struct tagABINFO_COM {
    ABIID   abiid;
    ABTYPE  abt;
    CHAR    szEmail[AB_MAX_EMAIL];
    CHAR    szDomain[AB_MAX_DOMAIN];
    INT     nDomainId;
} ABINFO_COM, *PABINFO_COM;


typedef struct tagABINFO_ACCOUNT {
    ABIID       abiid;
    ABTYPE      abt;
    CHAR        szEmail[AB_MAX_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];    //
    INT         nDomainId;                  // Reserved for Internal use, must set to -1.
    HACCT       hAcct;                      //
    DWORD       dwGroupId;
    DWORD       dwFlags;
} ABINFO_ACCOUNT, *PABINFO_ACCOUNT;


typedef struct tagABINFO_DISTLIST {
    ABIID       abiid;
    ABTYPE      abt;
    CHAR        szEmail[AB_MAX_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];
    INT         nDomainId;
    HACCT       hAcctOwner;
    TOKEN       token;
    DWORD       dwSecureLevel;
} ABINFO_DISTLIST, *PABINFO_DISTLIST;




typedef struct tagABSERVER_INFO {
    DWORD   dwServerId;
    DWORD   dwTypeFlags;
    CHAR    szServerName[MAX_PATH];
} ABSRVR_INFO, *PABSRVR_INFO;


union ABINFO_SUPERSET {
    ABINFO_ACCOUNT      abiacc;
    ABINFO_DISTLIST     abidl;
    ABSRVR_INFO         absrvr;
};


typedef struct tagAbPersistDomainInfo {
    CHAR        szDomainName[AB_MAX_DOMAIN];    // ie uk.eu.msn.com
    BOOL        fLocal;                         // Local to current site
    BOOL        fReplicate;                     // Not local but just want to subscribe to the info
    CHAR        szParentDomain[AB_MAX_DOMAIN];  // ie eu.msn.com
    LIST_ENTRY  list;                           // list pointers
} ABPDI, *PABPDI;

typedef struct tagAbSource {
    CHAR        szConfig[AB_MAX_CONFIG];
    LIST_ENTRY  list;
} ABSOURCE, *PABSOURCE;

typedef struct tagAbSourceEntry {
    LONG            lType;
    LONG            lMaxCnx;
    LONG            lQueryTimeOut;
    DWORD           dwRecoverTime;

    CHAR            szServerName[MAX_SERVERNAME + 1];
    CHAR            szDBName[MAX_NAME + 1];
    CHAR            szLoginName[MAX_NAME + 1];
    CHAR            szPassWord[MAX_NAME +1];

    DWORD           dwAction;

    LIST_ENTRY      list;

    void* operator new(size_t size);
    void  operator delete(void* pvMem, size_t size);
} ABSOURCE_ENTRY, *PABSOURCE_ENTRY;

typedef struct tagAbAddrStatistic {
    BOOL    cRemote;            // Number of remote recips to return
    BOOL    cLocal;             // Number of local recips to return
    DWORD   cUnresolved;        // Number of unresolved recips to return
} ABADDRSTAT,*PABADDRSTAT;


typedef enum {
    abatResolveDL = 1,
    abatMatchName = 2,
    abatServerList= 3,
    abatDomainList= 4,
    abatEnumResolveEx=5,
    abatEnumUserGroup=6
} ABACTIONTYPE;

typedef struct tagABENUM {
    ABRETC          abrcLastError;
    BOOL            fCheckRights;
    HACCT           hAcct;
    DWORD           dwRights;
    DWORD           cRowSoFar;
    DWORD           cRowRejected;
    DWORD           cRowMatched;
    DWORD           cRowReturned;
    PVOID           dbproc;
    HANDLE          hconn;  // HANDLE returned from DbGetConnection() in dbcon.dll
    ABACTIONTYPE    abat;
    BOOL            fUseLastRow;
    ABINFO_SUPERSET rgbLastRow;
} ABENUM, *PABENUM;

typedef struct _ABOOKDB_STATISTICS_0
{
    DWORD               NumResolvedAddresses;
    DWORD               NumUnresolvedAddresses;

    // Distribution List specific
    DWORD               NumDLsExpanded;
    DWORD               NumSmallDLsExpanded;
    DWORD               NumLargeDLsExpanded;
    DWORD               TimeResolvingSmallDLs;
    DWORD               TimeResolvingLargeDLs;

    // Api call frequency
    DWORD               NumAbResolveAddressCalls;
    DWORD               NumAbResolveAddressExCalls;
    DWORD               NumAbGetUserMailRootCalls;
    DWORD               NumAbGetUserMailRootFromHacctCalls;

    DWORD               NumAbCreateDL;
    DWORD               NumAbUpdateDL;
    DWORD               NumAbDeleteDL;
    DWORD               NumAbAddDLMember;
    DWORD               NumAbDeleteDLMember;

    DWORD               NumAbCreateInternetAcct;
    DWORD               NumAbDeleteInternetAcct;

    DWORD               NumAbCreateLocalUser;
    DWORD               NumAbCreateRemoteUser;
    DWORD               NumAbDeleteUser;

    DWORD               NumAbGetAbinfoFromEmail;
    DWORD               NumAbGetAbinfoFromAbiid;

    DWORD               NumAbResolveDLMembers;
    DWORD               NumAbMatchSimilarName;
    DWORD               NumAbGetServerList;
    DWORD               NumAbGetDomainList;
    DWORD               NumAbGetSiteList;

    // Data Base specific
    DWORD               NumDBFailures;
    DWORD               NumAuthenticationRequested;

} ABOOKDB_STATISTICS_0, *PABOOKDB_STATISTICS_0;

//
//  Completion callback from ABResolveAddress
//
typedef VOID (__stdcall *LPFNRESOLVECOMPLETE)(
    DWORD dwErr,
    PVOID pContext,
    PABADDRSTAT pAddrStat,
    PABRESOLVE pAbresolve);
//
//  Callback from TransactionLogging
//
typedef VOID  (__stdcall *LPFNLOGTRANX)(LPCSTR,LPCSTR,LPCSTR,DWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cache2i.h ===
/*++

cache2i.h -

	This file contains all the template function definitions required
	to make the cache manager work.


--*/

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx< Data, Key, Constructor, PerCacheData >::Schedule()	{
/*++

Routine Description :

	This function runs through all the items in the Cache
	bumping TTL's.  If there are any items ready to go
	then we dump them from the Cache.

Arguments :

	None.

Return Value :

	Nothing

--*/

	//TraceFunctEnter( "CacheEx::Schedule" ) ;

	if( !m_fValid )
		return ;

	DWORD	cExpired = 0 ;
	Expire( ) ;

}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL	
CacheEx<Data, Key, Constructor, PerCacheData>::RemoveEntry(	
					CacheState*	pEntry
					)	{
/*++

Routine Description :

	This function removes an entry from the Cache.
	We call our hash table to delete the item.
	the CacheState destructor automagically removes
	the item from our linked lists.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item to be removed from cache

Return Value :

	TRUE if successfully removed !

--*/

	TraceFunctEnter( "CacheEx::RemoveEntry" ) ;
	DebugTrace( (DWORD_PTR)this, "pEntry %x", pEntry ) ;

	CACHEENTRY	*pCacheEntry = (CACHEENTRY*)pEntry ;
	m_Lookup.Delete( pCacheEntry ) ;

	m_ExpireList.DecrementItems() ;
	//
	//	Update our counters !
	//
	DecrementStat( m_pStats, CACHESTATS::ITEMS ) ;

	return	TRUE ;
}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL	
CacheEx<Data, Key, Constructor, PerCacheData>::QueryRemoveEntry(	
					CacheState*	pEntry )	{
/*++

Routine Description :

	This function is called from CacheList object to
	determine whether we want to remove an item from the Cache.
	This function is used to implement the ExpungeSpecific
	function available to clients.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item we want to determine whether it should remain !

Return Value :

	TRUE if successfully removed !

--*/

	TraceFunctEnter( "CacheEx::QueryRemoveEntry" ) ;

	CACHEENTRY	*pCacheEntry = (CACHEENTRY*) pEntry ;

	if( m_pCallbackObject ) {
//		return	m_pCallbackObject->fRemoveCacheItem( *pCacheEntry->m_pData ) ;
	}
	return	FALSE ;
}


#ifdef	DEBUG

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
long	CacheEx<Data, Key, Constructor, PerCacheData>::s_cCreated = 0 ;

#endif

	
template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
CacheEx<Data, Key, Constructor, PerCacheData>::CacheEx( ) :
	m_fValid( FALSE ),
	m_Cache( sizeof( CACHEENTRY ) )	 {
/*++

Routine Description :

	This function initializes our member variables.

Arguments :

	cMax - maximum number of elements the cache should hold

Return Value :

	Nothing

--*/

#ifdef	DEBUG

	InterlockedIncrement( &s_cCreated ) ;

#endif

	AddToSchedule() ;

}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
CacheEx<Data, Key, Constructor, PerCacheData>::~CacheEx( ) {
/*++

Routine Description :

	This function destroys a Cache object !

Arguments :

	None

Return Value :

	Nothing

--*/

	RemoveFromSchedule() ;

	EnterCriticalSection( &g_CacheShutdown ) ;

	//
	//	Member and Base class destruction follows !!
	//

	BOOL	f = EmptyCache() ;

	LeaveCriticalSection( &g_CacheShutdown ) ;

	_ASSERT( f ) ;

#ifdef	DEBUG

	InterlockedDecrement( &s_cCreated ) ;

#endif

}


#if 0
template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::Init(	
				PFNHASH	pfnHash,
				PKEYCOMPARE	pKeyCompare,
				DWORD	dwLifetimeSeconds,
				DWORD	cMaxInstances,
				PSTOPHINT_FN pfnStopHint
		) {
/*++

Routine Description :

	This function initializes the cache so that it is ready
	to take entries.

Arguments :

	pfnHash - function to be used to compute hash values on keys
	dwLifetimeSeconds - The number of seconds objects should live in the Cache
	pfnStopHint - function to be used to send stop hints during
	  long spins so shutdown's don't time out.

Return Value :

	TRUE if successfull

--*/


	m_ExpireList.Init(	cMaxInstances,
						dwLifeTimeSeconds
						) ;
	
	return	m_fValid = m_Lookup.Init(
									256,
									128,
									4,
									pfnHash,
									&CACHEENTRY::GetKey,
									pKeyCompare
									) ;
}
#endif



template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::EmptyCache(	) {
/*++

Routine Description :

	This function removes everything from the cache.
	We are used during shutdown and destruction of the cache.

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/

	if (!m_fValid) {
		return TRUE;
	}

	BOOL	fReturn = TRUE ;

	FILETIME	filetimeNow ;

	ZeroMemory( &filetimeNow, sizeof( filetimeNow ) ) ;

	BOOL	fTerm = FALSE ;

	m_Lock.ExclusiveLock() ;

	m_ExpireList.ProcessWorkQueue(0,0) ;

	//BOOL	fReturn = m_ExpireList.Empty( this, &m_Cache, &m_PerCacheData ) ;

	HASHITER	Iter( m_Lookup ) ;
	
	while( !Iter.AtEnd() ) {

		CACHEENTRY*	pEntry = Iter.Current() ;
		//BOOL	fLock = pEntry->FLockCandidate( FALSE, filetimeNow, fTerm ) ;

		//_ASSERT( fLock ) ;

		pEntry->IsolateCandidate() ;

		CACHEENTRY*	pTemp = Iter.RemoveItem() ;
		m_ExpireList.DecrementItems() ;
		_ASSERT( pTemp == pEntry ) ;

		long l = pTemp->Release( &m_Cache, &m_PerCacheData ) ;
		_ASSERT( l== 0 || l == 1) ;
	}

	m_ExpireList.DrainWorkQueue() ;

	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}

template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::ExpungeItems(
			EXPUNGEOBJECT*	pExpunge
			) {
/*++

Routine Description :

	This function removes everything from the cache.
	We are used during shutdown and destruction of the cache.

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/

	BOOL	fReturn = TRUE ;

	m_Lock.ExclusiveLock() ;

	//
	//	Build an iterator that can walk our hash tables !
	//
	HASHITER	Iter( m_Lookup ) ;
	
	//
	//	Examine everything in the hash tables !
	//
	while( !Iter.AtEnd() ) {

		CACHEENTRY*	pEntry = Iter.Current() ;

		//
		//	We only let you Expunge Master Entries !
		//
		CacheState*	pMaster = 0 ;
		BOOL	fLocked = pEntry->FLockExpungeCandidate(pMaster) ;
		if( fLocked )	{

			//
			//	Ask the user if they want to delete this item !
			//
			if( pExpunge->fRemoveCacheItem(	pEntry->GetKey(),
											pEntry->m_pData
											) )	{

				CACHEENTRY*	pTemp = Iter.RemoveItem() ;
				m_ExpireList.DecrementItems() ;
				_ASSERT( pTemp == pEntry ) ;

				//
				//	This removes the cache item from any association
				//	it may have with other cache items ! In addition
				//	it drops the locks we were holding !
				//
				pTemp->FinishCandidate(pMaster) ;

				//
				//	Drop the cache's reference - this will leave the
				//	item orphaned - to be destroyed when the final
				//	client reference is released !
				//
				long l = pTemp->Release( &m_Cache, &m_PerCacheData ) ;
				continue ;
			}	else	{
				
				//
				//	We're not deleting this guy - release any locks we're holding !
				//
				pEntry->ReleaseLocks(pMaster) ;

			}
		}
		Iter.Next() ;
	}

	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}


template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::ExpungeKey(
			DWORD	dwHash,
			PKEY	pKeyExpunge
			) {
/*++

Routine Description :

	This function removes everything from the cache.
	We are used during shutdown and destruction of the cache.

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/

	TraceFunctEnter( "CacheEx::ExpungeKey" ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( pKeyExpunge ) ) ;

	BOOL	fReturn = FALSE ;
	m_Lock.PartialLock() ;

	Data*	pDataOut = 0 ;

	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
	}	else	{
		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = m_Lookup.SearchKey( dwHash, pKeyExpunge ) ;
		if( pEntry ) {
			//
			//	We've found the entry we want to remove - now go to an Exclusive Lock
			//	so we can ensure people don't blow up walking hash bucket chains 
			//
			m_Lock.FirstPartialToExclusive() ;
			CacheState*	pMaster ;
			BOOL	fLocked = pEntry->FLockExpungeCandidate(pMaster) ;
			//
			//	If we successfully locked the item, we're ready to go ahead an remove the item !
			//
			if( fLocked )	{
				//
				//	get rid of the guy !
				//
				m_Lookup.Delete( pEntry ) ;
				m_ExpireList.DecrementItems() ;
				pEntry->FinishCandidate(pMaster) ;
				//
				//	This could be the final reference, (but maybe not if clients are still holding it etc...)
				//
				long l = pEntry->Release( &m_Cache, &m_PerCacheData ) ;
				fReturn = TRUE ;
			}	
			m_Lock.ExclusiveUnlock() ;
			return	fReturn ;
		}
	}
	m_Lock.PartialUnlock() ;
	return	FALSE ;
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::FindOrCreateInternal(
						DWORD	dwHash,
						Key&	key,
						Constructor&	constructor,
						Data*	&pDataOut,
						BOOL	fEarlyCreate
						) {
/*++

Routine Description :

	This function is called when we want something out
	of the Cache.  We will either find the object or create it.

	WE WILL GRAB THE NECESSARY LOCKS !
	WE ARE NOT REENTRANT -
	
	At several points we call user provided code - it must
	not re-enter this cache !

Arguments :

	dwHash - The hash of the key we've been passed
	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pDataOut - Pointer which gets the result !
	fEarlyCreate - If this is TRUE we should call the constructor.Create()
		function early in the Cache Insertion process - this allows us to
		correctly deal with the condition where the Create() call may return
		a reference to another cache.	
	

Return Value :

	TRUE if successfull

--*/

	TraceFunctEnter( "CacheEx::FindOrCreateInternal" ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( &key ) ) ;

	Data*	pRelease = 0 ;
	pDataOut = 0 ;
	long	cClientRefs = 1 ;

	DebugTrace( (DWORD_PTR)this, "Args - dwHash %x fEarlyCreate %x", dwHash, fEarlyCreate ) ;

	//
	//	Check that the cache is initialized !
	//
	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
		return	FALSE ;
	}	else	{

		m_Lock.ShareLock() ;
		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = 0 ;
		HASHTABLE::ITER	iter = m_Lookup.SearchKeyHashIter( dwHash, &key, pEntry ) ;
		if( pEntry ) {
			pDataOut = pEntry->PublicData( &m_ExpireList ) ;
		}

		DebugTrace( (DWORD_PTR)this, "Initial Search - pDataOut %x", pDataOut ) ;

		if( pDataOut != 0 ) {

			//
			//	We're all done - release the lock !
			//
			m_Lock.ShareUnlock() ;
			//
			//	Increment our statistics !
			//
			IncrementStat( m_pStats, CACHESTATS::READHITS ) ;

		}	else	{

			//
			//	Try to convert our shared lock to a partial lock -
			//	if we can do so then we don't need to search the hash table again !
			//
			if( !m_Lock.SharedToPartial() ) {
				
				m_Lock.ShareUnlock() ;
				m_Lock.PartialLock() ;

				//
				//	Search the table again - something could happen while we briefly
				//	dropped the lock !
				//
				iter = m_Lookup.SearchKeyHashIter( dwHash, &key, pEntry ) ;

				IncrementStat( m_pStats, CACHESTATS::RESEARCH ) ;
				if( pEntry )
					IncrementStat( m_pStats, CACHESTATS::WRITEHITS ) ;

			}

			DebugTrace( (DWORD_PTR)this, "After possible Second Search - pEntry %x", pEntry ) ;
		
			//
			//	Time to re-evaluate, is there an entry in the cache !
			//
			if( pEntry != 0 )	{
				//
				//	Ok - we found an entry in the hash table, but it contained no data -
				//	so we need to do our FindOrCreate protocol on this element !
				//
				pDataOut = pEntry->FindOrCreate(
										m_Lock,
										constructor,
										m_PerCacheData,
										&m_ExpireList,
										m_pStats
										) ;

				//
				//	NOTE : pEntry->FindOrCreate() manipulates the global lock !
				//	it MUST unlock for us before it returns !
				//
				//m_Lock.PartialUnlock() ;
			}	else	{

				//
				//	Ok - first try to create the item we will be placing into the cache !
				//
				if( fEarlyCreate )
					pRelease = pDataOut = constructor.Create( key, m_PerCacheData ) ;

				DebugTrace( (DWORD_PTR)this, "fEarlyCreate %x pDataOut %x", fEarlyCreate, pDataOut ) ;

				if( !fEarlyCreate || pDataOut ) {

					//
					//	This must be the case !
					//
					_ASSERT( (pDataOut && fEarlyCreate) || (!pDataOut && !fEarlyCreate) ) ;

					CCacheItemBase<Data>*	pRef = 0 ;
					if( pDataOut )	{
						pRef = (CCacheItemBase<Data>*)pDataOut->m_pCacheRefInterface ;
						//
						//	Add a client reference IF this item is NOT contained in another cache !
						//
						cClientRefs = !pRef ? 1 : 0 ;
					}
					//
					//	Now - we will see if we can make the container to hold this data item !
					//	NOTE : we use pRef to figure out if we should add a client reference
					//	to this object - only do so if pRef is NULL meaning that this CACHEENTRY object
					//	OWNS the item in the cache !
					//
					//	This all means that pEntry is constructed with 1 or 2 references altogether
					//	which we need to handle in the error paths !
					//
					//	NOTE : if failure occurs pEntry should only be destroyed with FailedCheckOut() !
					//
#ifdef	DEBUG
					if( fTimeToFail() ) {
						pEntry = 0 ;
					}	else
#endif
					pEntry = new( m_Cache )	CACHEENTRY( &m_ExpireList, key, 0, cClientRefs ) ;

					DebugTrace( (DWORD_PTR)this, "pEntry %x pRef %x pDataOut %x pEntry->m_pData %x", pEntry, pRef,
						pDataOut, pEntry ? pEntry->m_pData : 0 ) ;

					if( pEntry != 0 ) {
						//
						//	Just check some basic things here !
						//
						_ASSERT( !pEntry->IsInLRUList() ) ;
						_ASSERT( pEntry->IsCheckedOut() || pRef ) ;

						//
						//	Grab the lock on the entry !
						//
						if( pRef )	{
							pRef->ExclusiveLock() ;
							//
							//	This must be checked out of its native cache,
							//	otherwise it could be destroyed from under us !
							//
							_ASSERT( pRef->IsCheckedOut() ) ;
							_ASSERT( pRef->IsMatch( pDataOut ) ) ;
						}
						pEntry->ExclusiveLock() ;
						//
						//	Convert to an Exclusive Lock for inserting into
						//	the hash table !
						//
						m_Lock.FirstPartialToExclusive() ;

						BOOL	fInsert ;
#ifdef	DEBUG
						//
						//	Periodically fail to insert into the hash table !
						//
						if( fTimeToFail() ) {
							fInsert = FALSE ;
						}	else
#endif
						fInsert = m_Lookup.InsertDataHashIter( iter, dwHash, &key, pEntry ) ;

						DebugTrace( (DWORD_PTR)this, "Insert Results - %x pDataOut %x pEntry %x", fInsert, pDataOut, pEntry ) ;
						_ASSERT( pRelease == pDataOut ) ;

						//
						//	Both the global Cache Lock - m_Lock and
						//	the locks for pEntry must be released within the branches of
						//	this if !
						//

						if( fInsert ) {
							m_ExpireList.IncrementItems() ;
							//
							//	Don't need to hold the whole cache anymore
							//
							m_Lock.ExclusiveUnlock() ;	

							//
							//	Number of times we've created an item while holding hash lock exclusively !
							//
							IncrementStat(	m_pStats, CACHESTATS::EXCLUSIVECREATES ) ;

							//
							//	This must be the case !
							//
							_ASSERT( (pDataOut && fEarlyCreate) || (!pDataOut && !fEarlyCreate) ) ;

							//
							//	Now do whatever is necessary to finish initialization ! -
							//	must always call Init() unless we're going to give up on this thing !
							//
							//	NOTE : Errors at this point can leave a dud CACHEENTRY in the
							//	cache, which should be cleaned up by expiration !
							//

							_ASSERT( pRelease == pDataOut ) ;

							if( !pDataOut ) {
								//
								//	This should only occur if we were not asked to do early creation !
								//
								_ASSERT( !fEarlyCreate ) ;

								pRelease = pDataOut = constructor.Create( key, m_PerCacheData ) ;
								pEntry->m_pData = pDataOut ;
								if( !pDataOut )	{
									//
									//	Keep Track of our statistics !
									//
									IncrementStat( m_pStats, CACHESTATS::CLIENTALLOCFAILS ) ;
								}
							}	

							_ASSERT( pRelease == pDataOut ) ;

							if( pDataOut && pDataOut->Init( key, constructor, m_PerCacheData ) ) {
								if( !pRef ) {
									pDataOut->m_pCacheRefInterface = pEntry ;
									pEntry->m_pData = pDataOut ;
								}	else {
#ifdef	DEBUG
									//
									//	Periodically fail these operations !
									//
									if( fTimeToFail() ) {
										pDataOut = 0 ;
									}	else	{
#endif
										//
										//	The item resides in another cache, and there must
										//	already be a user reference on the item, the user
										//	always gets a client ref through FindOrCreate - but
										//	they will get the client ref taken out by the
										//	constructor.Create call to provide us with the item !
										//
										if( !pRef->InsertRef( pEntry, pDataOut, 0 ) )	{
											pDataOut = 0 ;
										}
#ifdef	DEBUG
									}	//	Part of making the operation fail periodically !
#endif
								}	
							}	else	{
								//
								//	Should check the item in so that expire catches it !
								//
								pEntry->m_pData = pDataOut = 0 ;
								IncrementStat( m_pStats, CACHESTATS::CLIENTINITFAILS ) ;

							}

							DebugTrace( (DWORD_PTR)this, "pDataOut is Now %x pEntry %x pEntry->m_pData %x",
								pDataOut, pEntry, pEntry->m_pData ) ;

							_ASSERT( pDataOut == pEntry->m_pData ) ;

							//
							//	If things have gone bad - remove the client
							//	ref and put in the expiration list !
							//
							if( pDataOut ) {
								IncrementStat(	m_pStats, CACHESTATS::ITEMS ) ;
								pRelease = 0 ;
							}	else	{
								pEntry->FailedCheckOut( &m_ExpireList,
														cClientRefs,
														0,			// Can't give them the Allocation Cache - no lock held
														0			// Can't give them per cache stuff - no lock held !
														) ;
								_ASSERT( !pDataOut || pDataOut->m_pCacheRefInterface == pRef ) ;
							}	

							//
							//	Release the lock on the pEntry !
							//
							pEntry->ExclusiveUnlock() ;

						}	else	{

							DebugTrace( (DWORD_PTR)this, "Failed to Insert - pDataOut %x pRelease %x pRef %x pEntry %x",
								pDataOut, pRelease, pRef, pEntry ) ;

							_ASSERT( !pDataOut || pDataOut->m_pCacheRefInterface == pRef ) ;

							_ASSERT( pRelease == pDataOut ) ;
							pDataOut = 0 ;
							_ASSERT( pEntry->m_pData == pDataOut ) ;

							//
							//	This item should have been checked out !
							//
							_ASSERT( pEntry->IsCheckedOut() || pRef ) ;

							//
							//	Release the lock on the pEntry object before we destroy it !
							//
							pEntry->ExclusiveUnlock() ;

							//
							//	Release back to the cache -did we have a client ref -
							//	have to get rid of that if necessary !
							//	NOTE : This should totally destroy pEntry - we will also
							//	remove his last reference and return to the allocator cache !
							//
							pEntry->FailedCheckOut( &m_ExpireList,
													cClientRefs,
													&m_Cache,
													&m_PerCacheData
													) ;

							//
							//	To prevent a deadlock we have to release this lock !
							//	This is because the locks used within CACHEENTRY's are not re-entrant
							//	but if we call constructor.Release() below, we may try to re-enter
							//	pRef's lock (our client may try to Re-Enter !)
							//
							if( pRef )	{
								_ASSERT( pRef->IsCheckedOut() ) ;
								pRef->ExclusiveUnlock() ;
								pRef = 0 ;	// set to 0
							}
			
							if( pRelease != 0 ) {
								_ASSERT( pDataOut == 0 ) ;
								//
								//	Well we called the constructors create call - need to
								//	release the object back to the constructor !
								//
								constructor.Release( pRelease, &m_PerCacheData ) ;
							}
							pRelease = 0 ;


							//
							//	Release the hash table lock
							//
							m_Lock.ExclusiveUnlock() ;
						}

						if( pRef )	{
							//
							//	This must be checked out of its native cache,
							//	otherwise it could be destroyed from under us !
							//
							_ASSERT( pRef->IsCheckedOut() ) ;
							pRef->ExclusiveUnlock() ;
							pRef = 0 ;
						}
						//
						//	pRef should be unlocked by this point -
						//
						_ASSERT( pRef == 0 ) ;
					}	else	{
						//
						//	Number of times we've failed to alloc a CACHEENTRY object !
						//
						IncrementStat( m_pStats, CACHESTATS::CEFAILS ) ;

						_ASSERT( pRelease == pDataOut ) ;
						pDataOut = 0 ;

						//
						//	We were unable to allocate the necessary object to
						//	hold in the cache !
						//
						m_Lock.PartialUnlock() ;
						SetLastError( ERROR_OUTOFMEMORY ) ;
					}
				}	else	{
					m_Lock.PartialUnlock() ;
	
					//
					//	Keep Track of our statistics !
					//
					IncrementStat( m_pStats, CACHESTATS::CLIENTALLOCFAILS ) ;
	
				}
			}
		}
	}

	//
	//	One of these had better be NULL !
	//
	_ASSERT( pRelease == 0 || pDataOut == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "pRelease %x", pRelease ) ;

	if( pRelease != 0 ) {
		_ASSERT( pDataOut == 0 ) ;
		//
		//	Well we called the constructors create call - need to
		//	release the object back to the constructor !
		//
		constructor.Release( pRelease, 0 ) ;
	}

	//
	//	Well return TRUE if we got something to return after all !
	//
	return	pDataOut != 0 ;
}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
Data*
CacheEx<Data, Key, Constructor, PerCacheData>::FindInternal(
						DWORD	dwHash,
						Key&	key
						) {
/*++

Routine Description :

	This function will try to find something within the cache !

Arguments :

	dwHash - the hash value of the item we're looking for !
	key - The unique key used to find the item in the Cache.
	fClient - the kind of reference to stick on the item we find !	

Return Value :

	TRUE if successfull

--*/

	TraceFunctEnter( "CacheEx::FindInternal" ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( &key ) ) ;

	Data*	pDataOut = 0 ;

	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
		return	FALSE ;
	}	else	{

		m_Lock.ShareLock() ;
		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = m_Lookup.SearchKey( dwHash, &key ) ;
		if( pEntry ) {
			pDataOut = pEntry->PublicData( &m_ExpireList ) ;
		}
		m_Lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "After Search pEntry %x pDataOut %x", pEntry, pDataOut ) ;

		//
		//	Set up the error codes for why we may have failed !
		//
		if( !pEntry ) {
			SetLastError( ERROR_FILE_NOT_FOUND ) ;
		}	else if( !pDataOut )	{
			SetLastError( ERROR_INVALID_DATA ) ;
		}
	}
	if( pDataOut )
		IncrementStat( m_pStats, CACHESTATS::SUCCESSSEARCH ) ;
	else
		IncrementStat( m_pStats, CACHESTATS::FAILSEARCH ) ;

	return	pDataOut ;
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::InsertInternal(
						DWORD	dwHash,
						Key&	key,
						Data*	pDataIn,
						long	cClientRefs
						) {
/*++

Routine Description :

	This function is called when we have a data item,
	and we wish to insert it into the cache !

Arguments :

	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pData - Pointer which gets the result !
	

Return Value :

	TRUE if successfull

--*/

	TraceFunctEnter( "CacheEx::InsertInternal" ) ;
	DebugTrace( (DWORD_PTR)this, "Args dwHash %x pDataIn %x cClientRefs %x",
		dwHash, pDataIn, cClientRefs ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( &key ) ) ;

	BOOL	fReturn = FALSE ;

	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
		return	FALSE ;
	}	else	{

		//
		//	Grab the cache lock with a Partial Lock - this
		//	guarantees that nobody else can insert or delete
		//	from the hash table untill we finish.
		//
		//	Note : every branch in the following if's must
		//	ensure that the lock is properly released/manipulated !
		//
		m_Lock.PartialLock() ;

		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = 0 ;
		HASHTABLE::ITER	iter = m_Lookup.SearchKeyHashIter( dwHash, &key, pEntry ) ;
		//CACHEENTRY	*pEntry = m_Lookup.SearchKey( dwHash, &key ) ;

		DebugTrace( (DWORD_PTR)this, "After Search pEntry %x pEntry->m_pData %x",
			pEntry, pEntry ? pEntry->m_pData : 0 ) ;

		if( pEntry != 0 )	{
			fReturn = pEntry->SetData( pDataIn, &m_ExpireList, cClientRefs ) ;
			m_Lock.PartialUnlock() ;
		}	else	{
			CCacheItemBase<Data>*	pRef = (CCacheItemBase<Data>*)pDataIn->m_pCacheRefInterface ;

#ifdef	DEBUG
			//
			//	Periodically fail to allocate memory !
			//
			if( fTimeToFail() ) {
				pEntry = 0 ;
			}	else
#endif
			pEntry = new( m_Cache )	CACHEENTRY( &m_ExpireList, key, 0, cClientRefs ) ;

			DebugTrace( (DWORD_PTR)this, "pEntry %x pRef %x", pEntry, pRef ) ;

			if( pEntry != 0 ) {
				//
				//	Just check some basic things here !
				//
				_ASSERT( !pEntry->IsCheckedOut() || cClientRefs != 0 ) ;
				_ASSERT( !pEntry->IsInLRUList() ) ;

				//
				//	Grab the lock on the entry !
				//
				if( pRef )	{
					pRef->ExclusiveLock() ;
					//
					//	This must be checked out of its native cache,
					//	otherwise it could be destroyed from under us !
					//
					_ASSERT( pRef->IsCheckedOut() ) ;
					_ASSERT( pRef->IsMatch( pDataIn ) ) ;
				}
				pEntry->ExclusiveLock() ;

				//
				//	Convert to an Exclusive Lock for inserting into
				//	the hash table !
				//
				m_Lock.FirstPartialToExclusive() ;

#ifdef	DEBUG
				//
				//	Periodically fail to insert into the hash table !
				//
				if( fTimeToFail() ) {
					fReturn = FALSE ;
				}	else
#endif
				fReturn = m_Lookup.InsertDataHashIter( iter, dwHash, &key, pEntry ) ;

				DebugTrace( (DWORD_PTR)this, "Insert results %x", fReturn ) ;

				//
				//	Both the global Cache Lock - m_Lock and
				//	the locks for pEntry must be released within the branches of
				//	this if !
				//
				if( fReturn ) {

					m_Lock.ExclusiveUnlock() ;

					m_ExpireList.IncrementItems() ;
		
					if( !pRef ) {
						//
						//	Ok, lets set up our Entry
						//
						pEntry->m_pData = pDataIn ;
						_ASSERT( pDataIn->m_pCacheRefInterface == 0 ) ;
						pDataIn->m_pCacheRefInterface = pEntry ;
					}	else	{
						//
						//	If the user checked this out of one cache, to make
						//	a reference in ours - he/she shouldn't ask us to add
						//	another check-out reference !
						//
						_ASSERT( cClientRefs == 0 ) ;
#ifdef	DEBUG
						//
						//	Periodically fail these operations !
						//
						if( fTimeToFail() ) {
							fReturn = FALSE ;
						}	else
#endif
						fReturn = pRef->InsertRef( pEntry, pDataIn, cClientRefs ) ;

						DebugTrace( (DWORD_PTR)this, "InsertRef Resutls - fReturn %x", fReturn ) ;

						//
						//	Failure at this point leaves a dangling dummy entry in
						//	the cache - we need to insure that expiration gets it !
						//
						if( !fReturn ) {
							pEntry->FailedCheckOut( &m_ExpireList,
													cClientRefs,
													0,
													0
													) ;
							_ASSERT( pEntry->m_pData == 0 ) ;
						}						
					}
					_ASSERT( (!fReturn && pEntry->m_pData==0) || (fReturn && pEntry->m_pData) ) ;
					_ASSERT( pDataIn->m_pCacheRefInterface != pEntry ||
							pEntry->m_pData == pDataIn ) ;
					pEntry->ExclusiveUnlock() ;
				}	else	{

					_ASSERT( pEntry->m_pData == 0 ) ;

					//
					//	Since the client provided this item, we set this to 0 as
					//	we have not been able to add a reference to the item !
					//	This prevents us from calling Release when our pEntry is destroyed !
					//
					pEntry->m_pData = 0 ;

					_ASSERT( pDataIn->m_pCacheRefInterface != pEntry ||
							pEntry->m_pData == pDataIn ) ;

					pEntry->ExclusiveUnlock() ;
					//
					//	Release back to the cache -did we have a client ref -
					//	have to get rid of that if necessary !
					//
					pEntry->FailedCheckOut( &m_ExpireList,
											cClientRefs,
											&m_Cache,
											&m_PerCacheData
											) ;
					//
					//	Let this go after we've accessed the allocation cache !
					//
					m_Lock.ExclusiveUnlock() ;
				}
				//
				//	Release any remaining locks !
				//
				if( pRef )	{
					//
					//	This must be checked out of its native cache,
					//	otherwise it could be destroyed from under us !
					//
					_ASSERT( pRef->IsCheckedOut() ) ;
					pRef->ExclusiveUnlock() ;
				}
			}	else	{
				//
				//	Either we found the item after all,
				//	or we were unable to allocate memory
				//	to make the container !
				//
				m_Lock.PartialUnlock() ;
			}
		}
	}
	return	fReturn ;
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx<Data, Key, Constructor, PerCacheData>::CheckIn(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	if( pData )	{
		CacheState*	p	 = (CacheState*)pData->m_pCacheRefInterface ;
		_ASSERT( p ) ;
		p->ExternalCheckIn( ) ;
	}
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx<Data, Key, Constructor, PerCacheData>::CheckInNoLocks(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	if( pData )	{
		CacheState*	p	 = (CacheState*)pData->m_pCacheRefInterface ;
		_ASSERT( p ) ;
		p->ExternalCheckInNoLocks( ) ;
	}
}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx<Data, Key, Constructor, PerCacheData>::CheckOut(
						Data*	pData,
						long	cClientRefs
						) {
/*++

Routine Description :

	This function is called when we want to add a client
	reference to something that is already in the cache !

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;
	_ASSERT( cClientRefs > 0 ) ;

	if( pData )	{
		CacheState*	p	 = (CacheState*)pData->m_pCacheRefInterface ;
		_ASSERT( p ) ;
		p->CheckOut( 0, cClientRefs ) ;
	}
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
MultiCacheEx< Data, Key, Constructor, PerCacheData >::MultiCacheEx() :
	m_fValid( FALSE ),
	m_pCaches( 0 ) ,
	m_cSubCaches( 0 ),
	m_pfnHash( 0 ) {
/*++

Routine Description :

	This function initializes the MultiCache's data structures

Arguments :

	None.

Return Value :

	Nothing

--*/
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
MultiCacheEx< Data, Key, Constructor, PerCacheData >::~MultiCacheEx()	{
/*++

Routine Description :

	This function destroys all of our data structures - release
	all of our subcaches !

Arguments :

	None.

Return Value :

	Nothing

--*/


	if( m_pCaches ) {

		delete[]	m_pCaches ;

	}

}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Init(
				PFNHASH	pfnHash,
				PKEYCOMPARE	pfnCompare,
				DWORD	dwLifetimeSeconds,
				DWORD	cMaxElements,
				DWORD	cSubCaches,
				CACHESTATS*	pStats,
				PSTOPHINT_FN pfnStopHint
				) {

/*++

Routine Description :

	This function initializes the MultiCache - we use
	multiple independent Caches to split the work
	of caching all the data.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( !m_fValid ) ;
	_ASSERT( m_pCaches == 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	pfnHash != 0 ) ;
	_ASSERT(	pfnCompare != 0 ) ;
	_ASSERT(	dwLifetimeSeconds != 0 ) ;
	_ASSERT(	cSubCaches != 0 ) ;
	_ASSERT(	cMaxElements != 0 ) ;

	m_pfnHash = pfnHash ;
	m_cSubCaches = cSubCaches ;

	//
	//	Allocate the necessary subcaches !
	//

	m_pCaches = new	CACHEINSTANCE[m_cSubCaches] ;

	if( !m_pCaches ) {
		return	FALSE ;
	}	else	{

		for( DWORD	i=0; i<cSubCaches; i++ ) {
			
			if( !m_pCaches[i].Init( m_pfnHash,
									pfnCompare,
									dwLifetimeSeconds,
									(cMaxElements / cSubCaches) + 1,
									pStats,
									pfnStopHint
									) ) {
				delete[]	m_pCaches ;
				m_pCaches = NULL;
				return	FALSE ;
			}
		}
	}
	m_fValid = TRUE ;
	return	TRUE ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
DWORD
MultiCacheEx< Data, Key, Constructor, PerCacheData >::ChooseInstance(
				DWORD	dwHash
				) {
/*++

Routine Description :

	Given a Key figure out which of our subinstances we wish to use.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( m_fValid ) ;
	_ASSERT( m_pCaches != 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	m_pfnHash != 0 ) ;
	_ASSERT(	m_cSubCaches != 0 ) ;

	
	//DWORD	dwHash = m_pfnHash( k ) ;
	
	//
	//	Constants below stolen from C-runtime rand() function !
	//

	dwHash = (((dwHash * 214013) +2531011) >> 8) % m_cSubCaches ;

	return	dwHash ;

}



template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx<Data, Key, Constructor, PerCacheData>::ExpungeItems(
			EXPUNGEOBJECT*	pExpunge
			) {
/*++

Routine Description :

	This function allows the user to remove a specific set of objects
	from the cache - a callback object is provided to visit each element !

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/


	TraceFunctEnter( "MultiCacheEx::ExpungeItems" ) ;

	BOOL	fReturn = TRUE ;

	for( DWORD i=0; i<m_cSubCaches; i++ ) {
		fReturn &= m_pCaches[i].ExpungeItems( pExpunge ) ;
	}

	return	fReturn ;
}


template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx<Data, Key, Constructor, PerCacheData>::ExpungeKey(
			PKEY	pKeyExpunge
			) {
/*++

Routine Description :

	This function allows us to remove a particular key from the cache !

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/


	TraceFunctEnter( "MultiCacheEx::ExpungeKey" ) ;
	DWORD	dw = m_pfnHash( pKeyExpunge ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	return	pInstance->ExpungeKey(	dw, pKeyExpunge ) ;
}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::FindOrCreate(
				Key&	key,
				Constructor&	constructor,
				BOOL	fEarlyCreate
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	DWORD	dw = m_pfnHash( &key ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	Data*	pDataOut = 0 ;

	BOOL	fSuccess = pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut, fEarlyCreate ) ;
	_ASSERT( fSuccess || pDataOut == 0 ) ;
	
	return	pDataOut ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::FindOrCreate(
				DWORD	dw,
				Key&	key,
				Constructor&	constructor,
				BOOL	fEarlyCreate
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	_ASSERT( dw == m_pfnHash( &key ) ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	Data*	pDataOut = 0 ;
	BOOL	fSuccess = pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut ) ;
	_ASSERT( fSuccess || pDataOut == 0 ) ;
	
	return	pDataOut ;
}




template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Find(
				Key&	key
				) {
/*++

Routine Description :

	Given the key of an element - find it in the cache !

Arguments :

	None.

Return Value :

	Nothing

--*/

	DWORD	dw = m_pfnHash( &key ) ;
	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->FindInternal( dw, key ) ;
}




template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Find(
				DWORD	dw,
				Key&	key
				) {
/*++

Routine Description :

	Given the key of an element - find it in the cache !

Arguments :

	None.

Return Value :

	Nothing

--*/

	_ASSERT( dw == m_pfnHash( &key ) ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->FindInternal( dw, key ) ;
}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx<Data, Key, Constructor, PerCacheData>::CheckIn(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	CACHEINSTANCE::CheckIn( pData ) ;

}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx<Data, Key, Constructor, PerCacheData>::CheckInNoLocks(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	CACHEINSTANCE::CheckInNoLocks( pData ) ;

}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx<Data, Key, Constructor, PerCacheData>::CheckOut(
						Data*	pData,
						long	cClientRefs
						) {
/*++

Routine Description :

	This function is called when we want to add a client
	reference to something in the cache !

Arguments :

	p - the item checked out of the cache !

Return Value :

	none

--*/

	_ASSERT( pData ) ;
	_ASSERT( cClientRefs > 0 ) ;

	CACHEINSTANCE::CheckOut( pData, cClientRefs ) ;

}



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Expire() {
/*++

Routine Description :

	Remove old items from the cache !

Arguments :

	None.

Return Value :

	Nothing

--*/

	for( DWORD i=0; i<m_cSubCaches; i++ ) {
		m_pCaches[i].Expire( ) ;
	
	}
}



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Insert(
				Key&	key,
				Data*	pData,
				long	cClientRefs
				) {
/*++

Routine Description :

	Given the key of an element and a piece of data - insert it
	into the cache !

Arguments :

	key - key of the item being inserted into the cache
	pData - The data item to go into the cache
	cClientRefs - the number of client references we want to stick on the item !

Return Value :

	TRUE if successfull

--*/

	DWORD	dw = m_pfnHash( &key ) ;
	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->InsertInternal( dw, key, pData, cClientRefs ) ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Insert(
				DWORD	dw,
				Key&	key,
				Data*	pData,
				long	cClientRefs
				) {
/*++

Routine Description :

	Given the key of an element - find it in the cache !

Arguments :

	dw - hash of the key !
	key - key of the item being inserted into the cache
	pData - The data item to go into the cache
	fReference - do we want the item checked out !

Return Value :

	TRUE if successfull

--*/

	_ASSERT( dw == m_pfnHash( &key ) ) ;
	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->InsertInternal( dw, key, pData, cClientRefs ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\commsg.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    commsg.h

Abstract:

    HRESULT <-> Win32 error mapping macros.

Author:

    Michael W. Thomas (michth)   24-Sep-1996

Revision History:

    Keith Moore (keithmo)        07-Feb-1997
        Cleanup, comment, made Metadata errors "real" HRESULTs.

--*/


#ifndef _COMMSG_H_
#define _COMMSG_H_


//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))


//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#endif  // _COMMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cmmprops.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmprops.h

Abstract:

	This module contains the definition of the property search class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/02/98	created

--*/

#ifndef _PROPS_H_
#define _PROPS_H_

#include "blockmgr.h"
#include "propid.h"
#include "mailmsgprops.h"

/*

	This file defines a generice class for property tables. The following is
	the terminology used in relation to property tables:

	Search key - A value used to uniquely identify a property
	Property - A tuple consisting of a { Property Identifier, Value } pair.
	Property Identifier - the search key for the property table. The property
		table class does not restrict the data type or length of the property
		identifier, but rather, the caller must specify the length of the
		property identifier and provide a compare function when an instance
		of the property table is created.
	Value - A tuple consisting of a { Offset, Length } pair. The offset points
		to the physical location of the value and its length is specified by
		the Length element.
	Property Table - A collection of properties keyed off the designated
		property identifier. 

	A property table contains an instance info record (PROPERTY_TABLE_INSTANCE), 
	which describes the	parameters of the table, such as the length of each 
	property item record (PROPERTY_ITEM), how many items fit in a fragment
	(PROPERTY_TABLE_FRAGMENT), and a link to the first fragment.

	Fragments are linked together and thus a property table can hold an 
	arbitrarily larger number of properties, until the identifier space is
	exhausted. Fragments contain property item records, each item record
	contains an ordered tuple: { Offset, Length, Max Length, Property Identifier }
	In the definition of PROPERTY_ITEM, the Property Identifier element is not
	explicitly defined, but it is implied that whatever follows Max Length 
	is the property identifier. This allows maximum flexibility for different
	search key types. Similarly, although PROPERTY_TABLE_FRAGMENT does not
	include an array of PROPERTY_ITEMs, it is implied that an array of item
	records follow after faNextFragment. The size of the property identifier field 
	is specified during instance creation so the size of each property item 
	is fixed and known at run time.

	Since the property identifiers can be of different sizes, the creator must
	provide a function that knows how to compare a search key against a 
	property item.

	A memory manager must be specified when the property table is created.
	This provides a mechanism for memory to be allocated and released in 
	a linear, flat address space.
 */

// Define the well-known property item structure. We will have a sorted
// array of these items that make up the list of well-known properties.
// 
// Arrays of this type MUST be sorted for correct search results.
typedef struct _INTERNAL_PROPERTY_ITEM
{
	PROP_ID				idProp;			// Prop ID 
	DWORD				dwIndex;		// Reserved index of this prop ID

} INTERNAL_PROPERTY_ITEM, *LPINTERNAL_PROPERTY_ITEM;

// Define a generic structure to represent a property in the property
// table
// Each property table that uses this class as the accessor must have 
// an item structure that includes this structure as its first member
typedef struct _PROPERTY_ITEM
{
	FLAT_ADDRESS		faOffset;		// Offset in flat space to value
	DWORD				dwSize;			// Size of value data in bytes
	DWORD				dwMaxSize;		// Max size allocated for value

} PROPERTY_ITEM, *LPPROPERTY_ITEM;

// Define a generic structure to describe a fragment in the property table
typedef struct _PROPERTY_TABLE_FRAGMENT
{
	DWORD				dwSignature;	// Signature of fragment
	FLAT_ADDRESS		faNextFragment;	// Link to next fragment

} PROPERTY_TABLE_FRAGMENT, *LPPROPERTY_TABLE_FRAGMENT;

// Define a function type specifying the generic compare function passed
// into the search routine
//
// Arguments:
// LPVOID - pointer to search key value, the compare function must have
//          intimate knowledge of how to retrieve the property key from
//          the pointer and its size.
// LPPROPERTY_ITEM - pointer to item to compare against. The compare
//          function must have intimate knowledge of how to retrieve the
//          property key from the item pointer. The actual size of this
//          structure is in PROPERTY_TABLE_INSTANCE.dwItemSize.
//
// Return values:
// SUCCESS(HRESULT) - The item matches the search key
// !SUCCESS(HRESULT) - The item does not match the search key
//
typedef HRESULT (*LPPROPERTY_COMPARE_FUNCTION)(LPVOID, LPPROPERTY_ITEM);

// Define a generic structure to describe the property table instance
// Each property table that uses this class as the accessor must have 
// an instance structure that includes this structure as its first member
typedef struct _PROPERTY_TABLE_INSTANCE
{
	DWORD				dwSignature;	// Signature of instance
	FLAT_ADDRESS		faFirstFragment;// Link to first fragment
	DWORD				dwFragmentSize;	// Size of each fragment
	DWORD				dwItemBits;		// # lower bits that represent the item
	DWORD				dwItemSize;		// Size of a specific PROPERTY_ITEM
	DWORD				dwProperties;	// # properties in this instance
	FLAT_ADDRESS		faExtendedInfo;	// Link to any specific extended into

} PROPERTY_TABLE_INSTANCE, *LPPROPERTY_TABLE_INSTANCE;

// Enumerate the different applications of the property table
// This is used to track what kind of table we are looking at for debugging
typedef enum _PROPERTY_TABLE_TYPES
{
	PTT_INVALID_TYPE = 0,				// Default value
	PTT_PROPERTY_TABLE,					// Standard property table
	PTT_RECIPIENT_TABLE,				// Recipient table
	PTT_PROP_ID_TABLE					// Prop ID management table

} PROPERTY_TABLE_TYPES;

// Enumerate the different types of operations GetOrSetNextExistingItem
// supports
typedef enum _PROPERTY_ITEM_OPERATIONS
{
	PIO_INVALID_TYPE = 0,				// Default value
	PIO_READ_ITEM,						// Normal read
	PIO_WRITE_ITEM,						// Normal write
	PIO_ATOMIC_WRITE_ITEM				// Protected write

} PROPERTY_ITEM_OPERATIONS;

#include "cmmtypes.h"

// =================================================================
// class for accessing items from the property table. This class
// hides the details of fragmentation.
//
// This class is single-threaded
//
class CPropertyTableItem
{
  public:

    CPropertyTableItem(
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
				);
	~CPropertyTableItem();

	HRESULT AddItem(
				LPPROPERTY_ITEM pItem,
				DWORD			*pdwIndex,
                FLAT_ADDRESS    *pfaOffsetToItem = NULL
				);

	HRESULT UpdateItem(
				DWORD			dwIndex,
				LPPROPERTY_ITEM pItem,
                FLAT_ADDRESS    *pfaOffsetToItem = NULL
				);

	HRESULT GetItemAtIndex(
				DWORD			dwIndex,
				LPPROPERTY_ITEM pItem,
				LPFLAT_ADDRESS	pfaOffset = NULL
				);

	HRESULT GetNextItem(
				LPPROPERTY_ITEM pItem
				);

	HRESULT GetOffsetToCurrentItem(
				FLAT_ADDRESS	*pfaOffset
				)
	{ if (pfaOffset) *pfaOffset = m_faOffsetToCurrentItem; return(S_OK); }

  private:

	HRESULT GetOrSetNextExistingItem(
				// This looks at m_dwCurrentItem for index
				LPPROPERTY_ITEM pItem,
				DWORD			dwOperation,
				LPFLAT_ADDRESS	pfaOffset = NULL
				);
  
	HRESULT ReadFragmentFromFragmentNumber(
				DWORD			dwFragmentNumber
				);

	HRESULT ReadFragment(
				FLAT_ADDRESS	faOffset
				);

public:
	HRESULT ReadItem(
				FLAT_ADDRESS	faOffset,
				LPPROPERTY_ITEM	pItem
				);

private:
	HRESULT WriteItem(
				FLAT_ADDRESS	faOffset,
				LPPROPERTY_ITEM	pItem,
				BOOL			fAtomic
				);

    // Info of parent instance
	LPPROPERTY_TABLE_INSTANCE	m_pInstanceInfo;

	// Current fragment being processed
	BOOL						m_fLoaded;
	PROPERTY_TABLE_FRAGMENT		m_Fragment;
	DWORD						m_dwCurrentFragment;
	FLAT_ADDRESS				m_faOffsetToFragment;
	DWORD						m_dwCurrentItem;
	DWORD						m_dwCurrentItemInFragment;
	FLAT_ADDRESS				m_faOffsetToCurrentItem;
	
	// Memory manager pointer and context for fast access
	CBlockManager				*m_pBlockManager;
	CBlockContext				m_bcContext;
};

// =================================================================
// class for accessing an instance of a property table
//
class CPropertyTable
{
  public:

	CPropertyTable(
				PROPERTY_TABLE_TYPES		pttTableType,
				DWORD						dwValidSignature,
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo,
				LPPROPERTY_COMPARE_FUNCTION	pfnCompare,
				const LPINTERNAL_PROPERTY_ITEM	pInternalProperties	= NULL,
				DWORD						dwInternalProperties	= 0
				);
	~CPropertyTable();

	BOOL IsValid();
	BOOL IsInstanceInfoValid();

	//
	// Method to return the property count
	//
	// GetCount - Returns the current property count
	//
	// Arguments
	// pdwCount		- Pointer to DWORD to return count
	//
	// Return values
	//
	// S_OK						- Succeeded
	//
	HRESULT GetCount(
				DWORD		*pdwCount
				);

	//
	// Method to create or update a property item and value given a search key
	//
	// PutProperty - Creates the specified property if the property does not
	//				 exist, or updates the value of the property otherwise.
	//
	// Arguments
	// pvPropKey	- Pointer to the search key
	// pItem		- Pointer to the property item to write
	// dwSize		- Size of property value data
	// pbValue		- Pointer to property value data. If this value is NULL,
	//				  then no data is written, only the item record is created
	//				  or updated. dwSize must also be zero.
	//
	// Return values
	//
	// S_OK						- Succeeded, property already exists, but the
	//								value is updated as specified.
	// S_FALSE					- Succeeded, new property is created
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_WRITEFAULT			- Error, The write failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//								the current allocated block.
	//
	HRESULT PutProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem,
				DWORD			dwSize,
				LPBYTE			pbValue
				);

	//
	// Method to retrieve a property item given a search key
	//
	// GetPropertyItem - Attempts to find the property item specified by the
	//				 Search key. If found, the property item record will
	//				 be returned.
	//
	// Arguments
	// pvPropKey	- Pointer to the search key
	// pItem		- Pointer to the property item to return, sufficient space
	//				  must be allocated by the caller to hold the property item
	//
	// Return values
	//
	// S_OK						- Succeeded
	// STG_E_UNKNOWN			- Error, specified property not found.
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_READFAULT			- Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a read is issued to write past
	//								the current allocated block.
	//
	HRESULT GetPropertyItem(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	//
	// Method to retrieve a property item and its associated value
	//
	// GetPropertyItemAndValue - Attempts to find the property item specified 
	//				 by the Search key. If found, the property item record, as
	//				 well as the value data will be returned.
	//
	// Arguments
	// pvPropKey	- Pointer to the search key
	// pItem		- Pointer to the property item to return, sufficient space
	//				  must be allocated by the caller to hold the property item
	// dwLength		- Size of buffer allocated for value data
	// pdwLengthRead- Size of value data actually read, if the provided buffer is
	//				  insufficient, then the full length of the property data is
	//				  returned.
	// pbValue		- Pointer to return property value data.
	//
	// Return values
	//
	// S_OK						- Succeeded
	// STG_E_UNKNOWN			- Error, specified property not found.
	// HRESULT_FROM_WIN32(ERROR_MORE_DATA) - Error, the buffer provided is not
	//							large enough to hold all the value data.
	//							*pdwLengthRead returns the full length. *pItem
	//							would still return the item record in this case.
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_READFAULT			- Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS		- Debug Error, a read is issued to write past
	//								the current allocated block.
	//
	HRESULT GetPropertyItemAndValue(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem,
				DWORD			dwLength,
				DWORD			*pdwLengthRead,
				LPBYTE			pbValue
				);

	//
	// Method to retrieve a property item and its associated value, using an
	// internal index instead of a search key.
	//
	// GetPropertyItemAndValueUsingIndex - Attempts to find the property item 
	//				 specified by the Search key. If found, the property item 
	//				 record, as well as the value data will be returned.
	//
	// Arguments
	// dwIndex		- Index of item to retrieve, this is actually the dwIndex'th
	//				  item in the property table. One can walk the entire table
	//				  using this method.
	// pItem		- Pointer to the property item to return, sufficient space
	//				  must be allocated by the caller to hold the property item
	// dwLength		- Size of buffer allocated for value data
	// pdwLengthRead- Size of value data actually read, if the provided buffer is
	//				  insufficient, then the full length of the property data is
	//				  returned.
	// pbValue		- Pointer to return property value data.
	//
	// Return values
	//
	// S_OK						- Succeeded
	// STG_E_UNKNOWN			- Error, specified property not found.
	// HRESULT_FROM_WIN32(ERROR_MORE_DATA) - Error, the buffer provided is not
	//							large enough to hold all the value data.
	//							*pdwLengthRead returns the full length. *pItem
	//							would still return the item record in this case.
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_READFAULT			- Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS		- Debug Error, a read is issued to write past
	//								the current allocated block.
	//
	HRESULT GetPropertyItemAndValueUsingIndex(
				DWORD			dwIndex,
				LPPROPERTY_ITEM	pItem,
				DWORD			dwLength,
				DWORD			*pdwLengthRead,
				LPBYTE			pbValue
				);

  private:
  
	// Method to search the property table and return the associated
	// property item, if found
	HRESULT SearchForProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem,
				DWORD			*pdwIndexToItem,
				FLAT_ADDRESS	*pfaOffsetToItem
				);

    //
    // map a propid into an array index into m_rgWellKnownProps.  returns
    // -1 if the prop isn't well known
    //
    int MapCachedProp(DWORD iPropId) {
        if (m_cCachedProps &&
            iPropId >= m_iCachedPropsBase && 
            iPropId < m_iCachedPropsBase + m_cCachedProps)
        {
            int i = iPropId - m_iCachedPropsBase;
            _ASSERT(i < (int) m_cCachedProps);
            return i;
        } else {
            return -1;
        }
    }

    //
    // Initialize the property cache
    //
    void InitializePropCache();

    //
    // set an item in the property cache.  to invalidate an item pass in
    // INVALID_FLAT_ADDRESS for fa.
    //
    void UpdatePropCache(LPPROPERTY_ITEM pItem,
                         FLAT_ADDRESS fa,
                         DWORD dwIndex);

	DWORD						m_dwSignature;
	DWORD						m_dwTableType;
	DWORD						m_dwValidInstanceSignature;

	// Keep a local instance structure, and track the offset to the
	// copy in flat space
	PROPERTY_TABLE_INSTANCE		*m_pInstanceInfo;

	// List of well-known properties, we will use the count to determine
	// whether there are any well-known properties
	//
	// Note that well-known 
	LPINTERNAL_PROPERTY_ITEM	m_pInternalProperties;
	DWORD						m_dwInternalProperties;

	// Function pointer to do property comparisons
	LPPROPERTY_COMPARE_FUNCTION	m_pfnCompare;

	// Memory manager to use
	CBlockManager				*m_pBlockManager;

    // this structure is used for each item in the cache.  
    typedef struct {
        // the flat address for this item, or INVALID_FLAT_ADDRESS if its not in the cache
        FLAT_ADDRESS    fa;
        // its index
        DWORD           dwIndex;
    } PROPCACHEITEM;

    // array of cached property offsets for the predefined properties.
    // if its GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID
    // then this has the prop ids from IMMPID_MP_BEFORE+1 to IMMPID_MP_AFTER
    // otherwise this will be NULL
    //
    // There is no reason to cache recipient property offsets at this
    // time since the recipient property table is instantiated, used
    // once, then thrown away.  we'd spend more time making the cache
    // then the linear search in SearchForProperty costs
    PROPCACHEITEM              *m_rgCachedProps;
    DWORD                       m_iCachedPropsBase;
    DWORD                       m_cCachedProps;
};

// Utility function to crash when error conditions are detected in mailmsg
extern DWORD g_fForceCrashOnError;
inline void ForceCrashIfNeeded()
{
    INT *pnull = NULL;
    if(g_fForceCrashOnError)
        *pnull = 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cpoolmac.h ===
//-----------------------------------------------------------------------------
//
//
//  File: CPoolMac.h
//
//  Description: Definitions of CPool Helper Macros.  Moved from transmem.h to
//      make it easier to use CPool without Exchmem (for COM dlls).
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _CPOOLMAC_H_
#define _CPOOLMAC_H_

#include <cpool.h>
#include <dbgtrace.h>

//If you would rather use Exchmem (or the default new & delete), 
//then define OVERRIDE_CPOOL
#ifndef OVERRIDE_CPOOL
    //Use after "public:" in class definition
    #define DEFINE_CPOOL_MEMBERS    \
                static CPool m_MyClassPool; \
                inline void *operator new(size_t size) {return m_MyClassPool.Alloc();}; \
                inline void operator delete(void *p, size_t size) {m_MyClassPool.Free(p);};
    //Use at top of classes CPP file
    #define DECLARE_CPOOL_STATIC(CMyClass) \
                CPool CMyClass::m_MyClassPool;
    //Use in "main" before any classes are allocated
    #define F_INIT_CPOOL(CMyClass, NumPreAlloc)  \
                CMyClass::m_MyClassPool.ReserveMemory(NumPreAlloc, sizeof(CMyClass))
    #define RELEASE_CPOOL(CMyClass) \
                {_ASSERT(CMyClass::m_MyClassPool.GetAllocCount() == 0);CMyClass::m_MyClassPool.ReleaseMemory();}
#else //use exchmem to track allocations 
    #define DEFINE_CPOOL_MEMBERS    
    #define F_INIT_CPOOL(CMyClass, NumPreAlloc) true
    #define RELEASE_CPOOL(CMyClass) 
#endif //OVERRIDE_CPOOL

#endif //_CPOOLMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cmmtypes.h ===
/*++

Copyright (c) 1998, 2001  Microsoft Corporation

Module Name:

	cmmtypes.h

Abstract:

	This module contains the definition of the item and fragment types

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/09/98	created
	mikeswa	    10/12/2001	updated with MAX_PROPERTY_ITEM

--*/

#ifndef _CMMTYPES_H_
#define _CMMTYPES_H_

#include "cmmprops.h"


// =================================================================
// Private Definitions
//

// == GLOBAL PROPERTIES ==================================================

#define GLOBAL_PROPERTY_ITEM_BITS		5
#define GLOBAL_PROPERTY_ITEMS			(1 << (GLOBAL_PROPERTY_ITEM_BITS))

//
// Specific data structure for a global property item, note the default
// structures defined in props.h are used as preludes.
//
typedef struct _GLOBAL_PROPERTY_ITEM
{
	PROPERTY_ITEM		piItem;			// Default property item prelude
	PROP_ID				idProp;			// Property Id of item

} GLOBAL_PROPERTY_ITEM, *LPGLOBAL_PROPERTY_ITEM;

#define GLOBAL_PROPERTY_ITEM_SIZE			sizeof(GLOBAL_PROPERTY_ITEM)

//
// Specific data structure for a global property table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _GLOBAL_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT	ptfFragment;// Default fragment prelude
	GLOBAL_PROPERTY_ITEM	rgpiItems[GLOBAL_PROPERTY_ITEMS];	
										// Array of items

} GLOBAL_PROPERTY_TABLE_FRAGMENT, *LPGLOBAL_PROPERTY_TABLE_FRAGMENT;

#define GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(GLOBAL_PROPERTY_TABLE_FRAGMENT)


// == RECIPIENT LIST =====================================================

#define RECIPIENTS_PROPERTY_ITEM_BITS		5
#define RECIPIENTS_PROPERTY_ITEMS			(1 << (RECIPIENTS_PROPERTY_ITEM_BITS))

//
// Define the maximum number of hash keys supported
//
#define MAX_COLLISION_HASH_KEYS		5

//
// Define which address is of which type
//
typedef enum _ADDRESS_TYPE_INDICES
{
	AT_SMTP = 0,
	AT_X400,
	AT_X500,
	AT_LEGACY_EX_DN,
    AT_OTHER,
	AT_MAXAT
} ADDRESS_TYPE_INDICES;


//
// Specific data structure for a recipient item. This essentially contains
// an instance to the per-recipient property table
//
typedef struct _RECIPIENTS_PROPERTY_ITEM
{
	DWORD					dwFlags;		// Flags for this recipient
	FLAT_ADDRESS			faNameOffset[MAX_COLLISION_HASH_KEYS];	
											// Offset to each name
	DWORD					dwNameLength[MAX_COLLISION_HASH_KEYS];
											// Length of each name
	PROP_ID					idName[MAX_COLLISION_HASH_KEYS];
											// Prop ID of each name
	PROPERTY_TABLE_INSTANCE	ptiInstanceInfo;// Rcpt property table instance

} RECIPIENTS_PROPERTY_ITEM, *LPRECIPIENTS_PROPERTY_ITEM;

#define RECIPIENTS_PROPERTY_ITEM_SIZE			sizeof(RECIPIENTS_PROPERTY_ITEM)



class CMemoryAccess;

typedef struct _RECIPIENTS_PROPERTY_ITEM_HASHKEY {
    BYTE                                *pbKey;
    DWORD                               cKey;
} RECIPIENTS_PROPERTY_ITEM_HASHKEY;

#define RECIPIENTS_PROPERTY_ITEM_EX_SIG	'eipR'
//
// Specific data structure for a recipient item. This extends it to contain 
// in-memory structures for hashing and domain grouping
//
typedef struct _RECIPIENTS_PROPERTY_ITEM_EX
{
	DWORD								dwSignature;
    // reference counting on this object
    // there is always one reference for the list of recipients
    // there is an additional reference for each recipient hash table that
    // the item is in
    long                                m_cRefs;
    // hashkey for the domain
    RECIPIENTS_PROPERTY_ITEM_HASHKEY    rgHashKeys[MAX_COLLISION_HASH_KEYS];
	struct _RECIPIENTS_PROPERTY_ITEM_EX	*pNextHashEntry[MAX_COLLISION_HASH_KEYS];
														// Next entry in same hash bucket
	struct _RECIPIENTS_PROPERTY_ITEM_EX	*pNextInDomain;	// Next entry in same domain
	struct _RECIPIENTS_PROPERTY_ITEM_EX	*pNextInList;	// List used for deallocating
	RECIPIENTS_PROPERTY_ITEM			rpiRecipient;	// Recipient structure
} RECIPIENTS_PROPERTY_ITEM_EX, *LPRECIPIENTS_PROPERTY_ITEM_EX;

#define RECIPIENTS_PROPERTY_ITEM_SIZE_EX	sizeof(RECIPIENTS_PROPERTY_ITEM_EX)

//
// Specific data structure for a recipient table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _RECIPIENTS_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT		ptfFragment;// Default fragment prelude
	RECIPIENTS_PROPERTY_ITEM	rgpiItems[RECIPIENTS_PROPERTY_ITEMS];	
											// Array of items

} RECIPIENTS_PROPERTY_TABLE_FRAGMENT, *LPRECIPIENTS_PROPERTY_TABLE_FRAGMENT;

#define RECIPIENTS_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(RECIPIENTS_PROPERTY_TABLE_FRAGMENT)


// == PROPERTY MANAGEMENT ================================================

#define PROPID_MGMT_PROPERTY_ITEM_BITS		3
#define PROPID_MGMT_PROPERTY_ITEMS			(1 << (PROPID_MGMT_PROPERTY_ITEM_BITS))

//
// Specific data structure for a recipient item, note the default
// structures defined in props.h are used as preludes.
//
typedef struct _PROPID_MGMT_PROPERTY_ITEM
{
	PROPERTY_ITEM		piItem;			// Default property item prelude
	GUID				Guid;			// GUID identifying each reservation

} PROPID_MGMT_PROPERTY_ITEM, *LPPROPID_MGMT_PROPERTY_ITEM;

#define PROPID_MGMT_PROPERTY_ITEM_SIZE			sizeof(PROPID_MGMT_PROPERTY_ITEM)

//
// Specific data structure for a recipient table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _PROPID_MGMT_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT		ptfFragment;// Default fragment prelude
	PROPID_MGMT_PROPERTY_ITEM	rgpiItems[PROPID_MGMT_PROPERTY_ITEMS];	
											// Array of items

} PROPID_MGMT_PROPERTY_TABLE_FRAGMENT, *LPPROPID_MGMT_PROPERTY_TABLE_FRAGMENT;

#define PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(PROPID_MGMT_PROPERTY_TABLE_FRAGMENT)


// == RECIPIENT PROPERTIES ===============================================

#define RECIPIENT_PROPERTY_ITEM_BITS		3
#define RECIPIENT_PROPERTY_ITEMS			(1 << (RECIPIENT_PROPERTY_ITEM_BITS))

//
// Specific data structure for a recipient item, note the default
// structures defined in props.h are used as preludes.
//
typedef struct _RECIPIENT_PROPERTY_ITEM
{
	PROPERTY_ITEM		piItem;			// Default property item prelude
	PROP_ID				idProp;			// Property Id of item

} RECIPIENT_PROPERTY_ITEM, *LPRECIPIENT_PROPERTY_ITEM;

#define RECIPIENT_PROPERTY_ITEM_SIZE			sizeof(RECIPIENT_PROPERTY_ITEM)

//
// Specific data structure for a recipient table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _RECIPIENT_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT	ptfFragment;// Default fragment prelude
	RECIPIENT_PROPERTY_ITEM	rgpiItems[RECIPIENT_PROPERTY_ITEMS];	
										// Array of items

} RECIPIENT_PROPERTY_TABLE_FRAGMENT, *LPRECIPIENT_PROPERTY_TABLE_FRAGMENT;

#define RECIPIENT_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(RECIPIENT_PROPERTY_TABLE_FRAGMENT)


//
//  Define our max item size
//
#define MAX_PROPERTY_ITEM_SIZE  RECIPIENTS_PROPERTY_ITEM_SIZE_EX

//
//  Max property item size.  This is used to define a static item 
//  that can support all of the items in this header file
//
typedef struct _MAX_PROPERTY_ITEM
{
    BYTE rgbPayload[MAX_PROPERTY_ITEM_SIZE];
} MAX_PROPERTY_ITEM, *LPMAX_PROPERTY_ITEM;


//
//  This should be asserted in the property code
//
inline BOOL fMaxPropertyItemSizeValid()
{
    if (MAX_PROPERTY_ITEM_SIZE < RECIPIENTS_PROPERTY_ITEM_SIZE_EX)
        return FALSE;
    if (MAX_PROPERTY_ITEM_SIZE < RECIPIENTS_PROPERTY_ITEM_SIZE)
        return FALSE;
    if (MAX_PROPERTY_ITEM_SIZE < GLOBAL_PROPERTY_ITEM_SIZE)
        return FALSE;
    if (MAX_PROPERTY_ITEM_SIZE < PROPID_MGMT_PROPERTY_ITEM_SIZE)
        return FALSE;
    if (MAX_PROPERTY_ITEM_SIZE < RECIPIENT_PROPERTY_ITEM_SIZE)
        return FALSE;

    return TRUE;
}

//
//  Validates that an item size is "valid" (not unreasonably large)
//
inline BOOL fPropertyItemSizeValid(DWORD dwItemSize)
{
    return (sizeof(MAX_PROPERTY_ITEM) >= dwItemSize);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cintrnl.h ===
/*++

	cintrnl.h

	This file contains internal definitions for the cache library -
	this stuff should not be of interest for most users.

--*/

#ifndef	_CINTRNL_H_
#define	_CINTRNL_H_

class	CScheduleThread {
/*++

Class Description :

	This is a base class for those objects which wish to be
	called on a regularily scheduled basis.

	The constructors for this class will automatically
	put the object in a doubly linked list walked by a
	background thread which periodically executes a virtual function.


--*/
private :

	//
	//	Special constructor for the 'Head' element of the
	//	doubly linked list this class maintains.
	//
	CScheduleThread( BOOL	fSpecial ) ;
	
protected :

	//
	//	Has the scheduler been initialized ?
	//
	static	BOOL			s_fInitialized ;

	//
	//	Crit sect protecting doubly linked list.
	//
	static	CRITICAL_SECTION	s_critScheduleList ;

	//
	//	Handle to event used to terminate background thread.
	//
	static	HANDLE			s_hShutdown ;

	//
	//	Handle to background thread.
	//
	static	HANDLE			s_hThread ;

	//
	//	The head element of the doubly linked list.
	//
	static	CScheduleThread		s_Head ;

	//
	//	The thread which calls our virtual functions
	//
	static	DWORD	WINAPI	ScheduleThread(	LPVOID	lpv ) ;

	//
	//	Previous and Next pointers which maintain doubly linked
	//	list of scheduled itesm.
	//
	class	CScheduleThread*	m_pPrev ;
	class	CScheduleThread*	m_pNext ;

protected :

	//
	//	Derived classes should override this function -
	//	it will be called on a regular basis by the scheduler thread.
	//
	virtual	void	Schedule( void ) {}

	//
	//	Constructor and Destructor automagically manage
	//	insertion into doubly linked list of other scheduled items.
	//	These are protected as we want people to buid only
	//	derived objects which use this.
	//
	CScheduleThread() ;

	//
	//	Member functions which put us into the regular schedule !
	//
	void	AddToSchedule() ;
	void	RemoveFromSchedule() ;
		
public :

	//
	//	Initialize the class - don't construct
	//	any derived objects before this is called.
	//
	static	BOOL	Init() ;

	//
	//	Terminate class and background thread !
	//
	static	void	Term() ;

	//
	//	Global which tells clients how frequently they
	//	will be called !	
	//
	static	DWORD	dwNotificationSeconds ;

	//
	//	Destructor is protected - we should only be invoked
	//	by derived class constructors
	//
	virtual	~CScheduleThread() ;

} ;




class	CacheState : public	ICacheRefInterface	{
/*++

Class Description :

	This class will provide the base support for LRU
	removal of items in the cache !

Base Class :

	CQElement - we put these objects into
		a TLockQueue to amortize LRU operations !

--*/
private :

	//
	//	The following operations are not allowed !
	//
	CacheState() ;
	CacheState( CacheState& ) ;
	CacheState&	operator=( CacheState& ) ;

	//
	//	Tell us if this entry is older than the specified time !
	//
	BOOL
	OlderThan( FILETIME&	filetime )	{
		return	CompareFileTime( &m_LastAccess, &filetime ) <= 0 ;
	}

protected :

	//
	//	The LRU List which holds all of these items gets to
	//	know are innards !
	//
	friend	class	CLRUList ;

	//
	//	For debug purposes - make the memory recognizable !
	//
	DWORD	m_dwSignature ;

	//
	//	The lock used to protect operations within the derived
	//	classes of this object - most operations within this class
	//	don't require locking, however all derived classes need
	//	various locking services, so we provide one lock for all users !
	//
	CACHELOCK		m_lock ;

	//
	//	Our signaure, and constants for supporting us implementing two
	//	kinds of reference counts !
	//
	enum	CACHESTATE_CONSTANTS	{
		CACHESTATE_SIGNATURE = 'hcaC',
		CLIENT_REF	= 0x10000,
		CLIENT_BITS = 0xFFFF0000
	} ;

	//
	//	Keep a reference count - number of references holding
	//	this in memory !
	//	NOTE : we hold two types of references in here -
	//	regular references added by AddRef() and Release()
	//	which are references from other caches
	//	As well as client references.  To Add a client reference
	//	add CLIENT_REF atomically to this !
	//
	volatile	long	m_cRefs ;

	//
	//	a long that we use as a lock for calls to LRUReference
	//
	volatile	long	m_lLRULock ;

	//
	//	The last time this was touched - helps LRU algorithm !
	//
	FILETIME	m_LastAccess ;

	//
	//	The LRU List that owns this object !
	//
	public:	class	CLRUList*	m_pOwner ;

	//
	//	Pointers to maintain doubly linked list of
	//	items in the LRU chain !
	//
	protected:	DLIST_ENTRY	m_LRUList ;

	//
	//	structure to keep track of all the References to a
	//	particular item ! - note m_lock is used to protect
	//	access to this list
	//
	DLIST_ENTRY		m_ReferencesList ;

	//
	//	The field used to chain in Hash Table buckets
	//
	DLIST_ENTRY	m_HashList ;


	//
	//	This Constructor is protected as we only ever want to see
	//	classes derived from this thing created !
	//
	CacheState(	class	CLRUList*,
				long	cClientRefs = 1
				) ;

	//
	//	Destructor must be virtual - lots of derived classes !
	//
	virtual	~CacheState() ;

	//
	//	Touch the structure in a fashion so that the LRU state
	//	is updated !
	//
	void
	LRUReference(	class	CLRUList*	pLRU ) ;

	//
	//	calling this function insures that the correct Destructor is called !
	//
	void	virtual
	Destroy(	void*	pv	) = 0 ;

	//
	//	Reference counting support - Add a reference
	//
	long
	AddRef() ;

	//
	//	Keeping track of clients - remove a client ref !
	//
	long	
	CheckIn(	class	CAllocatorCache* pAlloc = 0
				) ;

	//
	//	Keeping track of clients - remove a client ref !
	//
	long	
	CheckInNoLocks(	class	CAllocatorCache* pAlloc = 0
				) ;

	virtual
	BOOL
	IsMasterReference()	{
		return	TRUE ;
	}

	virtual
	CacheState*
	GetMasterReference()	{
		return	this ;
	}

	CacheState*
	AddRefMaster( )	{
		TraceFunctEnter( "CacheState::AddRefMaster()" ) ;
		m_lock.ShareLock() ;		
		CacheState*	pReturn = GetMasterReference() ;
		if( pReturn ) {
			long l = pReturn->AddRef() ;
			DebugTrace( DWORD_PTR(pReturn), "Added a reference to %x this %x", pReturn, this ) ;
		}
		m_lock.ShareUnlock() ;
		return	pReturn ;
	}


public :

#ifdef	DEBUG
	//
	//	The number of these things that have been allocated !
	//
	static	long	g_cCacheState ;
#endif


	//
	//	Remove a reference - when we return 0 we're destroyed !
	//
	long
	Release(	class	CAllocatorCache	*pAlloc,
				void*	pv
				) ;

	//
	//	Provided to deal with failures during initialization of items
	//	being insert into the cache - this function ensures that the
	//	cache item ends up on the list for destruction !
	//
	void
	FailedCheckOut(	class	CLRUList*	p,
					long	cClientRefs,
					CAllocatorCache*	pAllocator,
					void*	pv
					) ;

	//
	//	For allocating these we use this special operator new
	//	which goes through our allocation cache !
	//
	//	NOTE : We take a reference because the cache MUST be provided !
	//
	void*
	operator	new(	size_t size,
						class CAllocatorCache&	cache
						) {
		return	cache.Allocate( size ) ;
	}

	//
	//	Exclusive Lock ourselves !
	//
	void
	ExclusiveLock()	{
		m_lock.ExclusiveLock() ;
	}

	//	
	//	Unlock ourselves
	//
	void
	ExclusiveUnlock()	{
		m_lock.ExclusiveUnlock() ;
	}

	//
	//	Keeping track of clients - Add a client ref !
	//
	long
	CheckOut(	class	CLRUList*	p,
				long	cClientRefs = 1
				)	;

	long
	ExternalCheckIn( ) ;

	long
	ExternalCheckInNoLocks( ) ;

	//
	//	Check to see whether this element is still referenced
	//	by the hash table containing the cache !
	//
	BOOL
	InCache()	{
		return	!m_HashList.IsEmpty() ;
	}

	//
	//	Check to see whether any Cache clients have a
	//	reference to this item !
	//	Return TRUE if any clients have added a reference !
	//
	BOOL	
	IsCheckedOut()	{
		_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
		return	(m_cRefs & CLIENT_BITS) != 0 ;
	}

	//
	//	Return TRUE if this item is in our LRU list !
	//
	BOOL
	IsInLRUList()	{
		_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
		//	return whether we are in the LRU List !
		return	!m_LRUList.IsEmpty() ;

	}

#ifdef	DEBUG
	//
	//	This is used in _ASSERT's and stuff to check that the cache is correctly ordered
	//	by time !
	//
	BOOL
	IsOlder(	FILETIME	filetimeIn,
				FILETIME&	filetimeOut
				) ;
#endif

	//
	//	The following support functions are used to support manipulating
	//	these objects in the various kinds of doubly linked lists we may reside in
	//
	//
	BOOL
	FLockCandidate(	BOOL	fExpireChecks,
					FILETIME&	filetime,
					BOOL&	fToYoung
					) ;

	//
	//	The following function locks an element of the cache.
	//	If this is the master cache entry, we will also look all associated items and return TRUE.
	//	If this is not the master, we lock only the one entry !
	//
	BOOL
	FLockExpungeCandidate(	CacheState*&	pMaster	) ;

	//
	//	This function pairs with FLockExpungeCandidate()
	//
	void
	ReleaseLocks(	CacheState*	pMaster ) ;

	//
	//	This is the other half of FLockExpungeCandidate -
	//	we ensure the destruction of the selected item !
	//
	void
	FinishCandidate(	CacheState*	pMaster ) ;

	//
	//	The following is not thread safe and is only for use during
	//	shutdown, where there should be no thread issues !
	//
	void
	IsolateCandidate() ;

	//
	//	This removes the item from the LRU List - Cache lock must be held exclusive or partially !
	//
	void
	RemoveFromLRU() ;

	//
	//	Define the Pointer to Function type that is so usefull
	//	for using the DLIST templates !
	//
	typedef		DLIST_ENTRY*	(*PFNDLIST)( class	CacheState* pState ) ;

	//
	//	Helper function for Doubly linked lists of these items in the
	//	Cache's hash tables !
	//
	inline	static
	DLIST_ENTRY*
	HashDLIST(	CacheState*	p ) {
		return	&p->m_HashList ;
	}

	//
	//	Helper function for Doubly linked lists of these items in the
	//	LRU lists
	//
	inline	static
	DLIST_ENTRY*
	LRUDLIST(	CacheState* p ) {
		return	&p->m_LRUList ;
	}

	//
	//	Helper function for Doubly linked lists of these items in
	//	the reference lists - the list of items referencing the same
	//	cache item !
	//
	inline	static
	DLIST_ENTRY*
	REFSDLIST(	CacheState*	p )	{
		return	&p->m_ReferencesList ;
	}
} ;




//
//	Now Define some Doubly Linked Lists that we can use to manipulate the
//	items in the cache in various ways !
//
typedef	TDListHead< CacheState, &CacheState::LRUDLIST	>	LRULIST ;
typedef	TDListHead< CacheState,	&CacheState::REFSDLIST	>	REFSLIST ;
typedef	TDListIterator<	REFSLIST >	REFSITER ;


class	CacheTable :	public	CScheduleThread	{
/*++

Class	Description :

	This class defines a call back interface which we hand to
	the LRU List to manipulate the items in the cache !

--*/
public :
	//
	//	Get the lock we use for manipulating the lock state of the table !
	//
	virtual	CACHELOCK&	
	GetLock() = 0 ;

	//
	//	Remove an item from the Cache's hash table !
	//
	virtual	BOOL
	RemoveEntry(
			CacheState*	pEntry
			) = 0 ;

	//
	//	Ask if we want to remove this particular item !
	//
	virtual	BOOL	
	QueryRemoveEntry(	
			CacheState*	pEntry
			) = 0 ;

} ;


class	CLRUList	{
/*++

Class Description :

	This class implements our LRU algorithms and selects
	the elements that are to be deleted from the cache !

--*/
private :

	//
	//	The head of the LRU List !
	//
	LRULIST		m_LRUList ;

	//	
	//	A list of items that have been touched in the LRU List !
	//
	TLockQueue<	CacheState >	m_lqModify ;	

	//
	//	Maximum number of elements we should hold in this cache !
	//
	DWORD		m_cMaxElements ;

	//
	//	Number of items we inserted !
	//
	DWORD		m_dwAverageInserts ;

	//
	//	Number of items NOT in the LRU List !
	//
	DWORD		m_cCheckedOut ;

	//
	//	The number of subtract from the current time to
	//	determine our expire date !
	//
	ULARGE_INTEGER	m_qwExpire ;

	//
	//	This function actually selects the items that will be expired
	//
	void
	SelectExpirations(	DLIST_ENTRY&	expireList ) ;

	//
	//	Do the expires !
	//
	DWORD
	DoExpirations(	DLIST_ENTRY&	expireList ) ;
	
	//
	//	Don't allow copies!
	//
	CLRUList( CLRUList& ) ;
	CLRUList&	operator=( CLRUList& ) ;
	

public :

	//
	//	Number of items in the cache !
	//
	long		m_cItems ;

	//CLRUList(	ULARGE_INTEGER	qwExpire ) ;
	CLRUList() ;

	//
	//	Initialize the LRU List with the parameters
	//	controlling the maximum number of elements and the time to live !
	//
	void
	Init(	DWORD	cMaxInstances,
			DWORD	cLifeTimeSeconds
			) ;

	//
	//	Something has changed - put it in the list of items needing
	//	to be examined !
	//	
	//	This function should only be called when the containing cache has
	//	a lock on the cache !
	//
	void
	AddWorkQueue( 	CacheState*	pbase ) ;

	//
	//	This function examines each item in the Work Queue and does
	//	appropriate processing !
	//
	void
	ProcessWorkQueue(	CAllocatorCache*	pAllocCache,
						LPVOID				lpv
						) ;

	//
	//	This function drains each item out of the Work Queue and releases
	//	them - called during shutdown/destruction of a cache !
	//
	void
	DrainWorkQueue() ;

	//
	//	Bump the number of items in the cache !
	//
	long
	IncrementItems()	{
		return	InterlockedIncrement( &m_cItems ) ;
	}

	//
	//	Decrease the number of items in the cache !
	//
	long
	DecrementItems()	{
		return	InterlockedDecrement( &m_cItems ) ;
	}

	//
	//	Do the work required to expire an item !
	//
	void
	Expire(	CacheTable*	pTable,
			CAllocatorCache*	pCache,
			DWORD&	countExpired,
			void*	pv	//per cache data !
			) ;

	BOOL
	Empty(	CacheTable*	pTable,
			CAllocatorCache*	pCache,
			void*	pv
			) ;


	//
	//	Remove a random set of elements in the table !
	//
	void
	ExpungeItems(	
				CacheTable*	pTable,
				DWORD&	countExpunged
				) ;

} ;



template<	class	Data
			>
class	CCacheItemBase :	public	CacheState 	{
/*++

Class Desceription :

	This class provides the interface defination for
	items in the cache which may or may not hold the
	key as well within the cache !

Arguments :

	Data - the item we will hold within the Cache

--*/
protected:

	//
	//	Constructor - initialize stuff to zero !
	//
	CCacheItemBase(	class	CLRUList*	p,
					Data*	pData,
					BOOL	fClientRef
					) :
		CacheState( p, fClientRef ),
		m_pData( pData ) {
	}

	~CCacheItemBase()	{
		//
		//	Somebody else must free our data elements !
		//
		_ASSERT(m_pData == 0 ) ;
	}

	BOOL
	IsMasterReference()	{

		return
			m_pData == 0 ||
			m_pData->m_pCacheRefInterface == this ;
	}

	CacheState*
	GetMasterReference( )	{
		if( m_pData == 0 ) {
			return	this ;
		}	
		return	(CacheState*)m_pData->m_pCacheRefInterface ;
	}

public :

	//
	//	The actual item we are holding within the Cache !
	//
	Data*	m_pData ;

	//
	//	Check that our data items match !
	//	used for _ASSERT's
	//
	BOOL
	IsMatch(	Data*	p ) {
		return	p == m_pData ;
	}

	//
	//	Must be able extract the Data Item !
	//
	Data*
	PublicData(	class	CLRUList*	p	)	{
	/*++
	
	Routine Description :

		This function adds a client reference to an item in the cache,
		and sets up the necessary LRU Manipulations!
		We also return the data pointer to the client, and add a reference
		to ourselves to keep track of !

	Arguments :

		p - the LRUList that owns us !

	Return Value :

		Pointer to the Data item we contain - can be NULL !

	--*/
		TraceFunctEnter( "CCacheItemBase::PublicData" ) ;

		_ASSERT( p != 0 ) ;
		_ASSERT( p == m_pOwner ) ;

		Data*	pReturn = 0 ;
		m_lock.ShareLock() ;

		DebugTrace( (DWORD_PTR)this, "m_pData %x m_pCacheRef %x",
			m_pData, m_pData ? m_pData->m_pCacheRefInterface : 0 ) ;

		if( m_pData ) {
			CacheState*	pState = (CacheState*)m_pData->m_pCacheRefInterface ;
			pState->CheckOut( p ) ;
			pReturn = m_pData ;
		}

		//
		//	If there's no data in this item - it must not be checked out !
		//
		_ASSERT( pReturn || !IsCheckedOut() ) ;
	
		m_lock.ShareUnlock() ;
		return	pReturn ;
	}

	//
	//	This is called when the locks are NOT held -
	//	do all the correct logic for setting this item up !
	//
	BOOL
	SetData(	Data*	pData,
				CLRUList*	pList,
				long	cClientRefs
				)	{
	/*++

	Routine Description :

		Make this Cache Element point to some piece of data that was provided
		by the end user.

		NOTE :
		The piece of data may be referenced by another cache - in which case
		we must work well with it !!!!

	Arguments :

		pData - the Item the client wants us to refer to with our key
		pList - the LRU List containing us !

		fReference - Is the client putting the item in the cache and not keeping
			his reference, this is TRUE if


	--*/

		TraceFunctEnter( "CCacheItemBase::SetData" ) ;

		BOOL	fReturn = FALSE ;

		_ASSERT( pData != 0 ) ;
		_ASSERT( pList != 0 ) ;
		_ASSERT( pList == m_pOwner ) ;

		DebugTrace( (DWORD_PTR)this, "pData %x pList %x cClientRefs %x", pData, pList, cClientRefs ) ;

		//
		//	Is this an item referenced by another cache -
		//	NOTE : IF it is an item from another Cache it MUST be checked out with a
		//	client reference !  The m_pCacheRefInterface of an item MUST NEVER CHANGED
		//	as long as an item is checked out by clients, so the following dereference
		//	is safe !
		//
		CCacheItemBase*	p = (CCacheItemBase*)pData->m_pCacheRefInterface ;

		DebugTrace( (DWORD_PTR)this, "Examined Item - m_pCacheRefInterface %x", p ) ;

		if( p != 0 ) {
			//
			//	In this scenario it is meaningless to access for a client reference -
			//	the client MUST have gotten one from the other cache !
			//
			_ASSERT( cClientRefs == 0 ) ;
			_ASSERT( p->IsCheckedOut() ) ;

			//
			//	Ok make our cache reference the same item !
			//
			fReturn = p->AddCacheReference( this, pData ) ;
			//	
			//	This can fail if the user tries to insert the same name twice !
			//
			//_ASSERT( fReturn ) ;
		}	else	{
			m_lock.ExclusiveLock() ;
			if( !m_pData ) {
				//
				//	The Cache should never have refences outstanding with
				//	the data pointer equal to NULL - so _ASSERT that we're
				//	not checked out by a client !
				//
				_ASSERT( !IsCheckedOut() ) ;
				//
				//	Now point to the data the client wants us to point at !
				//
				m_pData = pData ;
				pData->m_pCacheRefInterface = this ;
				//
				//	It worked - return TRUE !
				//
				fReturn = TRUE ;
				//
				//	Now we are checked out by a client !
				//
				if( cClientRefs )
					CheckOut( pList, cClientRefs ) ;
			}
			m_lock.ExclusiveUnlock() ;
		}
		return	fReturn ;
	}


	//
	//	Add an item to the list of caches referencing
	//	this cache item !
	//
	BOOL
	InsertRef(	CCacheItemBase<Data>*	p,
				Data*	pData,
				long	cClientRefs = 0
				)	{
	/*++

	Routine Description :

				


	--*/

		TraceFunctEnter( "CCacheItemBase::InsertRef" ) ;

		_ASSERT( p != 0 ) ;
		_ASSERT( pData != 0 ) ;
		_ASSERT( IsCheckedOut() ) ;
		_ASSERT( pData->m_pCacheRefInterface == this ) ;


		BOOL	fReturn = FALSE ;

		REFSITER	refsiter( &m_ReferencesList ) ;

		DebugTrace( (DWORD_PTR)this, "m_pData %x p %x p->m_pData %x cClientRefs %x",
			m_pData, p, p->m_pData, cClientRefs ) ;

		if( m_pData != 0 ) {
			//
			//	Now grab the second lock !
			//
			//	This _ASSERT isn't valid, the user can insert names that are already in use !
			//
			//_ASSERT( p->m_pData == 0 || p->m_pData == m_pData ) ;
			if( p->m_pData == 0 ) {
				//
				//	Insert p into the list of item in the list !
				//
				refsiter.InsertBefore( p ) ;

				//
				//	We've added another reference to ourself !
				//	This comes from another Cache item, so count it specially !
				//	
				long l = AddRef() ;

				DebugTrace( (DWORD_PTR)this, "AddRef result %x this %x p %x", l, this, p ) ;

				//
				//	Give a reference to the data we are holding !
				//
				p->m_pData = m_pData ;
				fReturn = TRUE ;
			}	else	if( p->m_pData == m_pData ) {
				fReturn = TRUE ;
			}
			//	This _ASSERT isn't valid, the user can insert names that are already in use !
			//
			//_ASSERT( p->m_pData == m_pData ) ;
		}

		if( fReturn && cClientRefs ) {
			CheckOut( m_pOwner, cClientRefs ) ;
		}
		return	fReturn ;
	}



	//
	//	Add an item to the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	AddCacheReference(	class	ICacheRefInterface*	pInterface,
						void*	pv,
						BOOL	fReference = FALSE
						)	{
	/*++

	Routine Description :

				


	--*/

		TraceFunctEnter( "CCacheItemBase::AddCacheReference" ) ;

		Data*	pData = (Data*)pv ;
		CCacheItemBase<Data>*	p = (CCacheItemBase<Data>*)pInterface ;
		BOOL	fReturn = TRUE  ;

		_ASSERT( pData != 0 ) ;
		_ASSERT( p != 0 ) ;

		REFSITER	refsiter( &m_ReferencesList ) ;

		DebugTrace( (DWORD_PTR)this, "pInterface %x pv %x fReference %x", pInterface, pv, fReference ) ;

		m_lock.ExclusiveLock() ;
		p->m_lock.ExclusiveLock() ;

		fReturn = InsertRef(	p,
								pData,
								fReference
								) ;

		p->m_lock.ExclusiveUnlock() ;
		_ASSERT( m_pData == pData ) ;
		m_lock.ExclusiveUnlock() ;

		return	fReturn ;
	}

	//
	//	Remove an item from the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	RemoveCacheReference(	BOOL	fQueue	)	{

		TraceFunctEnter( "CCacheItemBase::RemoveCacheReference" ) ;

		DebugTrace( (DWORD_PTR)this, "m_pData %x m_pData->m_pCacheRefInterface %x",
			m_pData, m_pData ? m_pData->m_pCacheRefInterface: 0 ) ;

		m_pData = 0 ;

		//
		//	Well now - we're on our own - we should be expired !
		//
		if( fQueue )
			LRUReference( m_pOwner ) ;

		//
		//	p no longer has a reference - you can remove it !
		//
		return	FALSE ;
	}

	//
	//	Remove all references to the cache item !
	//
	virtual BOOL
	RemoveAllReferences( )	{

		return	FALSE ;
	}

} ;


template<	class	Data,
			class	Key,
			class	Constructor,
			class	PerCacheData
			>
class	CCacheItemKey : public	CCacheItemBase< Data > {
/*++

Class Description :

	This class item holds the key of the item we are
	referencing within the cache !
	We don't assume that the data objects hold the
	keys for us - we do this ourselves.

--*/
private :

	//
	//	This is the type of the key we are going to be holding !
	//
	Key		m_key ;

	//
	//	Make all these constructors and copiers private !
	//
	CCacheItemKey() ;
	CCacheItemKey&	operator=( CCacheItemKey& ) ;

protected :
	//
	//	Destroy ourselves
	//
	void
	Destroy(	void*	pv )	{
		TraceFunctEnter( "CCacheItemKey::Destroy" ) ;
		DebugTrace( (DWORD_PTR)this, "m_pData %x pv %x", m_pData, pv ) ;
		PerCacheData*	p = (PerCacheData*)pv ;
		if( m_pData )
			Constructor::StaticRelease( m_pData, pv ) ;
		m_pData = 0 ;			
		CCacheItemKey::~CCacheItemKey() ;
	}

public :

	~CCacheItemKey()	{
		if( m_pData ) {
			Constructor::StaticRelease( m_pData, 0 ) ;
			m_pData = 0 ;
		}
	}

	//
	//	Can only create by initializing the key !
	//
	CCacheItemKey(	class	CLRUList*	p,
					Key& k,
					Data*	pData,
					long	cClientRefs
					) :
		CCacheItemBase<Data>( p, pData, cClientRefs ),
		m_key( k ) {
	}

	Key*	GetKey()	{
		return	&m_key ;
	}


	//
	//	This is called when no locks are held - assumes
	//	that we may find that data is in the item, or that
	//	we need to build it !
	//
	Data*
	FindOrCreate(
				CACHELOCK&		cachelock,
				Constructor&	constructor,
				PerCacheData&	cachedata,
				CLRUList*		plrulist,
				class	CacheStats*		pStats
				)	{
	/*++

	Routine Description :

		This function executes our creation protocol with the client.

		The constructor.Create() function is called to create a partially
		constructed Item for the cache.  We will check if the returned item
		is referenced in another cache - if it is we will build the list
		of CacheState objects referencing the same cache item.		

		The caller assumes that cachelock is released by the time we return !
		
	Arguments :

		cachelock - The lock for the containing cache, we get this so that
			we can minimize the time it is held !
		constructor -
			The object that can build an item for the cache !
		cachedata -
			Some client data that they get for free !
		plrulist -
			The LRU list that we should use !

	Return Value :

		Pointer to a Data item if successfull !

	--*/

		TraceFunctEnter( "CCacheItemKey::FindOrCreate" ) ;

		_ASSERT( plrulist == m_pOwner || plrulist == 0 ) ;

		DebugTrace( (DWORD_PTR)this, "plrulist %x", plrulist ) ;

		Data*	pReturn = 0 ;
		//
		//	First look to see if there happens to be something here already !
		//
		m_lock.ShareLock() ;
		if( m_pData ) {

			DebugTrace( (DWORD_PTR)this, "m_pData %x m_pData->m_pCacheRefInterface %x",
				m_pData, m_pData->m_pCacheRefInterface ) ;
			//
			//	We've found this item constructed in the cache -	
			//	so check it out, AND put on the LRU work list !
			//
			CacheState*	pState = (CacheState*)m_pData->m_pCacheRefInterface ;
			pState->CheckOut( plrulist ) ;
			pReturn = m_pData ;
		}	
		m_lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "pReturn %x", pReturn ) ;
		
		//
		//	Did we find something !
		//
		if( pReturn  ) {
			//
			//	Because caller assumes this is unlocked - do so now !
			//
			cachelock.PartialUnlock() ;
		}	else	{
			//
			//	An item with no data - Must not be checked out !
			//
			_ASSERT( !IsCheckedOut() ) ;
			_ASSERT( m_pData == 0 ) ;

			//
			//	Partially build the data object we want to hold !
			//
			Data*	pData = constructor.Create( m_key, cachedata ) ;
	
			DebugTrace( (DWORD_PTR)this, "Created pData %x", pData ) ;

			if( !pData ) {
				//
				//	We failed - release our locks and go away !
				//
				cachelock.PartialUnlock() ;

			}	else	{
				
				//
				//	Figure out if we got a reference to an item already in the cache !
				//
				CCacheItemBase<Data>*	p = (CCacheItemBase<Data>*)pData->m_pCacheRefInterface ;

				//
				//	Grab the locks in the correct order for what we might need !
				//
				if( p )	{
					p->ExclusiveLock() ;
					//
					//	If he gave us an item, it must be checked out of whatever cache
					//	it came from - this ensures that it will not be destroyed while we
					//	access it, because we are not at the point of adding our own reference
					//	yet !
					//
					_ASSERT( p->IsCheckedOut() ) ;
					_ASSERT( p->IsMatch( pData ) ) ;
				}
				m_lock.ExclusiveLock() ;

				//
				//	Don't need to hold onto the cache anymore !
				//
				cachelock.PartialUnlock() ;

				DebugTrace( (DWORD_PTR)this, "Create path - pData %x p %x m_pData %x", pData, p, m_pData ) ;

				//
				//	Now do whatever is necessary to finish initialization ! -
				//	must always call Init() unless we're going to give up on this thing !
				//

				//
				//	We should not change state as long as we've been holding either
				//	the cachelock or our item lock up until this point - which is the case !
				//
				_ASSERT( m_pData == 0 ) ;


				if( pData->Init(	m_key,
									constructor,
									cachedata ) ) {
					if( !p ) {
						m_pData = pData ;
						pData->m_pCacheRefInterface = this ;
						pReturn = m_pData ;
						CheckOut( m_pOwner ) ;
					}	else	{
						//
						//	NOTE : If the client's constructor gave us an object from another
						//	cache they MUST add the client's reference for us - so we pass 0 to
						//	InsertRef(), so that we don't add yet another reference.
						//
						if( p->InsertRef( this, pData, 0 ) ) {
							//
							//	Insert Ref should setup our m_pData pointer !
							//
							_ASSERT( m_pData == pData ) ;
							pReturn = m_pData ;
						}
					}
				}

				DebugTrace( (DWORD_PTR)this, "Create path - pReturn %x", pReturn ) ;

				//
				//	NOTE :
				//	If pReturn==0 indicating some kind of error, than there should
				//	have been no client refs added at this point !
				//
				_ASSERT( pReturn || !IsCheckedOut() ) ;
				_ASSERT( pReturn == m_pData ) ;

				if( p ) {
					//
					//	If he gave us an item, it must be checked out of whatever cache
					//	it came from - this ensures that it will not be destroyed while we
					//	access it, because we are not at the point of adding our own reference
					//	yet !
					//
					_ASSERT( p->IsCheckedOut() ) ;
					p->ExclusiveUnlock() ;
				}

				if( pReturn ) {
					IncrementStat(	pStats, CACHESTATS::ITEMS ) ;
				}	else	{
					//
					//	Release the data item back to the user
					//	NOTE - Don't have the cachelock so can't give them
					//	the cachedata at this point !
					//
					constructor.Release( pData, 0 ) ;

					//
					//	Insure that we get onto the expiration list - this CACHEENTRY
					//	should be removed at some point !
					//
					FailedCheckOut( plrulist, FALSE, 0, 0 ) ;
				}
				//
				//	Release the locks - this can be done before we go down the 
				//	error path because we know that we won't get destroyed !
				//
				m_lock.ExclusiveUnlock() ;
			}
		}
		return	pReturn ;
	}
} ;








#endif	// _CINTRNL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cmmsprop.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmsprop.h

Abstract:

	This module contains the definition of the special property class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	04/19/98	created

--*/

#ifndef _CMMVPROP_H_
#define _CMMVPROP_H_

#include "propid.h"

// Define a generic accessor function to access special properties
typedef HRESULT (*GET_ACCESSOR_FUNCTION)(
			PROP_ID	idProp, 
			LPVOID	pContext,
			LPVOID	pParam,
			DWORD	cbLength, 
			LPDWORD	pcbLength,
			LPBYTE	pbBuffer 
			);

typedef HRESULT (*PUT_ACCESSOR_FUNCTION)(	
			PROP_ID	idProp,
			LPVOID	pContext,
			LPVOID	pParam,
			DWORD	cbLength, 
			LPBYTE	pbBuffer
			);

// Define the property item structure
//
// Note: In this implementation, all special properties are volatile
// We can do Serialize() and Restore() operations in the future if we want.
//
typedef struct _SPECIAL_PROPERTY_ITEM
{
	PROP_ID							idProp;			// Property ID of property
	DWORD							ptBaseType:16;	// Lowest 16 bits: property type
	DWORD							fAccess:15;		// Upper 15 bits: access rights
	DWORD							fVolatile:1;	// MSB: TRUE if property is volatile
	GET_ACCESSOR_FUNCTION			pfnGetAccessor;	// Accessor to get property value
	PUT_ACCESSOR_FUNCTION			pfnPutAccessor;	// Accessor to set property value

} SPECIAL_PROPERTY_ITEM, *LPSPECIAL_PROPERTY_ITEM;

// Define a generic structure to define a set of properties
typedef struct _PTABLE
{
	LPSPECIAL_PROPERTY_ITEM		pProperties;	// Actual property table
	DWORD						dwProperties;	// Count
	BOOL						fIsSorted;		// Prop table sorted by PROP_ID?

} PTABLE, *LPPTABLE;

// Enumerated types representing type of access on property
typedef enum _PROPERTY_ACCESS
{
	PA_NONE = 0,
	PA_READ = 1,
	PA_WRITE = 2,
	PA_READ_WRITE = PA_READ | PA_WRITE,
	PA_MAXPA

} _PROPERTY_ACCESS;

// Enumerated types representing property types
typedef enum _PROPERTY_DATA_TYPES
{
	PT_NONE = 0,
	PT_STRING,
	PT_DWORD,
	PT_BOOL,
	PT_INTERFACE,
	PT_MAXPT

} PROPERTY_DATA_TYPES;


// =================================================================
// class for searching special properties
//
class CSpecialPropertyTable
{
  public:

	CSpecialPropertyTable(
				LPPTABLE	pPropertyTable
				);

	~CSpecialPropertyTable();

	//
	// Synopsis:
	// Method to retrieve a special property item, if exists in the 
	// special property table.
	//
	// Arguments:
	// idProp - Property ID
	// pContext - context for accessor function
	// ptBaseType - one of the values in PROPERTY_DATA_TYPES. If specified,
	//			this type will be checked against the base type of the special
	//			property. A perfect type match would then be required. If this
	//			is PT_NONE, then a type check is not performed.
	// cbLength - length of buffer provided
	// pcbLength - returns length of property value
	// pbBuffer - buffer to receive property value
	// fCheckAccess - [optional] TRUE if the caller wants an access check on
	//			the property, FALSE (default) skips the check
	//
	// Return values:
	// S_OK - success, the specified property if found and its value returned
	// S_FALSE - success, the specified property is not found in the table
	// E_INVALIDARG - error, one or more arguments are invalid
	// E_ACCESSDENIED - error, desired access to the specified property is
	//			denied
	// TYPE_E_TYPEMISMATCH - error, a specific data type is given, but the
	//			specified and actual types don't match
	// HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) - error, the specified
	//			buffer is not large enough to hold the property value. 
	//			*pcbLength should contain the required length in bytes.
	// Or any other HRESULT from the get accessor
	//
	HRESULT GetProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				DWORD		*pcbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess = FALSE
				);

	//
	// Synopsis:
	// Method to set a special property item, if exists in the 
	// special property table.
	//
	// Arguments:
	// idProp - Property ID
	// pContext - context for accessor function
	// ptBaseType - one of the values in PROPERTY_DATA_TYPES. If specified,
	//			this type will be checked against the base type of the special
	//			property. A perfect type match would then be required. If this
	//			is PT_NONE, then a type check is not performed.
	// cbLength - length of buffer provided
	// pcbLength - returns length of property value
	// pbBuffer - buffer to receive property value
	// fCheckAccess - [optional] TRUE if the caller wants an access check on
	//			the property, FALSE (default) skips the check
	//
	// Return values:
	// S_OK - success, the specified property if found and its value is set
	// S_FALSE - success, the specified property is not found in the table
	// E_INVALIDARG - error, one or more arguments are invalid
	// E_ACCESSDENIED - error, desired access to the specified property is
	//			denied
	// TYPE_E_TYPEMISMATCH - error, a specific data type is given, but the
	//			specified and actual types don't match
	// Or any other HRESULT from the put accessor
	//
	HRESULT PutProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess = FALSE
				);

  private:
  
	// Method to search the property table and return the associated
	// property item, if found
	LPSPECIAL_PROPERTY_ITEM SearchForProperty(
				PROP_ID	idProp
				);

	// Pointer to property table and count of items
	LPSPECIAL_PROPERTY_ITEM		m_pProperties;
	DWORD						m_dwProperties;

	// TRUE if the table of properties is sorted, will use
	// binary search if so. Otherwise, a linear scan is performed
	BOOL						m_fIsSorted;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\cpool.h ===
//#---------------------------------------------------------------
//  File:		CPool.h
//        
//	Synopsis:	Header for the CPool class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------

#ifndef	_CPOOL_H_
#define _CPOOL_H_

#include "dbgtrace.h"

#define POOL_SIGNATURE	 			(DWORD)'looP' 
#define UPSTREAM_SIGNATURE 			(DWORD)'tspU' 
#define DOWNSTREAM_SIGNATURE 		(DWORD)'tsnD' 
#define AUTHENTICATION_SIGNATURE 	(DWORD)'htuA' 
#define USER_SIGNATURE 				(DWORD)'resU' 
#define PROXY_SIGNATURE 		    (DWORD)'xorP' 

#define	DEFAULT_ALLOC_INCREMENT		0xFFFFFFFF

//
// maximum number of VirtualAlloc chunks to allow
//

#define	MAX_CPOOL_FRAGMENTS			16


class CPool
{
		//
		// struct def'n for linking free instances
		// see page 473 of Stroustrup
		//
		struct	Link	{ Link*	pNext; };

	public:
		CPool( DWORD dwSignature=1 );
		~CPool( void );

	    void *operator new( size_t cSize )
						{ return HeapAlloc( GetProcessHeap(), 0, cSize ); }

	    void operator delete (void *pInstance)
						{ HeapFree( GetProcessHeap(), 0, pInstance ); }

#ifdef DEBUG
		void	IsValid( void );
#else
		inline void IsValid( void ) { return; }
#endif
		//
		// to be called after the constructor to VirtualAlloc the necessary
		// memory address
		//
		BOOL	ReserveMemory(	DWORD MaxInstances,
								DWORD InstanceSize,
								DWORD IncrementSize = DEFAULT_ALLOC_INCREMENT ); 

		BOOL	ReleaseMemory( void );

		void*	Alloc( void );
		void	Free( void* pInstance );

		DWORD	GetContentionCount( void );

		DWORD	GetEntryCount( void );

		DWORD	GetTotalAllocCount()
				{ return	m_cTotalAllocs; }

		DWORD	GetTotalFreeCount()
				{ return	m_cTotalFrees; }

		DWORD	GetTotalExtraAllocCount()
				{ return	m_cTotalExtraAllocs; }

		DWORD	GetCommitCount()
				{ return	m_cNumberCommitted; }

		DWORD	GetAllocCount()
				{ return	m_cNumberInUse; }

		DWORD	GetInstanceSize(void);

	private:
		//
		// internal function to alloc more mem from the OS
		//
		void 	GrowPool( void );
		//
		// Structure signature for a pool object
		// 
		const DWORD			m_dwSignature;
		//
		// total number of descriptors ( maximum )
		//
		DWORD				m_cMaxInstances;
		//
		// size of the descriptor
		//
		DWORD				m_cInstanceSize;
		//
		// virtual array number of committed instances
		//
		DWORD				m_cNumberCommitted;
		//
		// number of In_use instances ( debug/admin only )
		//
		DWORD				m_cNumberInUse;
		//
		// number of Free instances ( debug/admin only )
		//
		DWORD				m_cNumberAvail;
		//
		// the handle of the pool critical section
		//
		CRITICAL_SECTION	m_PoolCriticalSection;
		//
		// the pointer to the first descriptor on the free list
		//
		Link				*m_pFreeList;
		//
		// the pointer to a free descriptor not on the free list
		//
		Link				*m_pExtraFreeLink;
		//
		// number to increment the pool when expanding
		//
		DWORD				m_cIncrementInstances;

		//
		// Debug counters for perf testing ( debug/admin only )
		//
		DWORD				m_cTotalAllocs;
		DWORD				m_cTotalFrees;
		DWORD				m_cTotalExtraAllocs;

		//
		// Debug variables to help catch heap bugs
		//
		Link				*m_pLastAlloc;
		Link				*m_pLastExtraAlloc;

		//
		// size of each fragment in instances
		//
		DWORD				m_cFragmentInstances;

		//
		// maximum number of fragments
		//
		DWORD				m_cFragments;

		//
		// maximum number of fragments
		//
		LPVOID				m_pFragments[ MAX_CPOOL_FRAGMENTS ];
};



#endif //!_CPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\dbgtrace.h ===
/*----------------------------------------------------------------------
    dbgtrace.h
        Definitions for async tracing routines

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_DBGTRACE_H_)
#define _DBGTRACE_H_

//
// setup DLL Export macros
//
#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif
#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif
#if !defined(_DBGTRACE_DLL_DEFINED)
    #define _DBGTRACE_DLL_DEFINED
    #if defined(WIN32)
        #if defined(_DBGTRACE_DLL_IMPLEMENTATION)
            #define DbgTraceDLL DllExport
        #else
            #define DbgTraceDLL DllImport
        #endif
    #else
        #define DbgTraceDLL
    #endif
#endif

#ifndef THIS_FILE
#define THIS_FILE   __FILE__
#endif

#ifndef THIS_MODULE
#define THIS_MODULE "ALL"
#endif

#if defined( NOTRACE )

#define FLUSHASYNCTRACE                         // for _ASSERT below

#define FatalTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
#define DebugTrace  1 ? (void)0 : PreAsyncTrace
#define StateTrace  1 ? (void)0 : PreAsyncTrace
#define FunctTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTraceX 1 ? (void)0 : PreAsyncTrace
#define DebugTraceX 1 ? (void)0 : PreAsyncTrace

#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )

#define TraceQuietEnter( sz )
#define TraceFunctEnter( sz )
#define TraceFunctEnterEx( lparam, sz )
#define TraceFunctLeave()
#define TraceFunctLeaveEx(lparam)

//
// import functions from DBGTRACE.DLL
//
#define InitAsyncTrace()
#define TermAsyncTrace()
#define FlushAsyncTrace()

__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
        return( 1);
}


#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )



#else // NOTRACE

#define FLUSHASYNCTRACE     FlushAsyncTrace(),  // for _ASSERT below

#define FatalTrace  !(__dwEnabledTraces & FATAL_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, FATAL_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define ErrorTrace  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTrace  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define StateTrace  !(__dwEnabledTraces & STATE_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, STATE_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define FunctTrace  !(__dwEnabledTraces & FUNCT_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, FUNCT_TRACE_MASK ) &&     \
                    PreAsyncTrace

//
// Support for unspecified function names
//

#define ErrorTraceX  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, "Fn", ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTraceX  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, "Fn", DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace


//
// use to explicitly remove function tracing even for debug builds
//
#define TraceQuietEnter( sz )                   \
        char    *___pszFunctionName = sz

//
// disable function tracing for retail builds
// reduces code size increase and only should
// only be used sparingly
//
#ifdef  DEBUG

#define TraceFunctEnter( sz )                   \
        TraceQuietEnter( sz );                  \
        FunctTrace( 0, "Entering %s", sz )

#define TraceFunctLeave()                       \
        FunctTrace( 0, "Leaving %s", ___pszFunctionName )

#define TraceFunctEnterEx( lParam, sz )         \
        TraceQuietEnter( sz );                  \
        FunctTrace( lParam, "Entering %s", sz )

#define TraceFunctLeaveEx( lParam )             \
        FunctTrace( lParam, "Leaving %s", ___pszFunctionName )

#else

#define TraceFunctEnter( sz )           TraceQuietEnter( sz )
#define TraceFunctEnterEx( lParam, sz ) TraceQuietEnter( sz )

#define TraceFunctLeave()
#define TraceFunctLeaveEx( lParam )

#endif

//
// import functions from DBGTRACE.DLL
//
extern DbgTraceDLL BOOL WINAPI InitAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI TermAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI FlushAsyncTrace( void );




//
// fixed number of parameters for Binary trace macros
//
#define MessageTrace( lParam, pbData, cbData )                  \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_MESSAGE, pbData, cbData )

#define BinaryTrace( lParam, pbData, cbData )                   \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_BINARY, pbData, cbData )

#define UserTrace( lParam, dwUserType, pbData, cbData )         \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, dwUserType, pbData, cbData )

//
// imported trace flag used by trace macros to determine if the trace
// statement should be executed
//
extern DWORD DbgTraceDLL    __dwEnabledTraces;



extern DbgTraceDLL int WINAPI AsyncStringTrace( LPARAM  lParam,
                                                LPCSTR  szFormat,
                                                va_list marker );

extern DbgTraceDLL int WINAPI AsyncBinaryTrace( LPARAM  lParam,
                                                DWORD   dwBinaryType,
                                                LPBYTE  pbData,
                                                DWORD   cbData );

extern DbgTraceDLL int WINAPI SetAsyncTraceParams(  LPSTR   pszFile,
                                                    int     iLine,
                                                    LPSTR   szFunction,
                                                    DWORD   dwTraceMask );

extern DbgTraceDLL int WINAPI SetAsyncTraceParamsEx(LPSTR   pszModule,
                                                    LPSTR   pszFile,
                                                    int     iLine,
                                                    LPSTR   szFunction,
                                                    DWORD   dwTraceMask );

//
// Trace flag constants
//
#define FATAL_TRACE_MASK    0x00000001
#define ERROR_TRACE_MASK    0x00000002
#define DEBUG_TRACE_MASK    0x00000004
#define STATE_TRACE_MASK    0x00000008
#define FUNCT_TRACE_MASK    0x00000010
#define MESSAGE_TRACE_MASK  0x00000020
#define ALL_TRACE_MASK      0xFFFFFFFF

#define NUM_TRACE_TYPES     6

//
// Output trace types. used by tools to modify the
// registry to change the output target
//
enum tagTraceOutputTypes {
    TRACE_OUTPUT_DISABLED = 0,
    TRACE_OUTPUT_FILE = 1,
    TRACE_OUTPUT_DEBUG = 2,
    TRACE_OUTPUT_DISCARD = 4        // used to find race windows
};

#define TRACE_OUTPUT_INVALID    \
        ~(TRACE_OUTPUT_FILE|TRACE_OUTPUT_DEBUG|TRACE_OUTPUT_DISCARD)


#define IsTraceFile(x)      ((x) & TRACE_OUTPUT_FILE)
#define IsTraceDebug(x)     ((x) & TRACE_OUTPUT_DEBUG)
#define IsTraceDiscard(x)   ((x) & TRACE_OUTPUT_DISCARD)


//
// predefined types of binary trace types.  User defined
// types must be greater than 0x8000
//
enum tagBinaryTypes {
    TRACE_STRING = 0,
    TRACE_BINARY,
    TRACE_MESSAGE,
    TRACE_USER = 0x8000
};

#include <stdarg.h>

//
// use __inline to ensure grab __LINE__ and __FILE__
//
__inline int WINAPIV PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
    va_list marker;
    int     iLength;

    va_start( marker, szFormat );
    iLength = AsyncStringTrace( lParam, szFormat, marker );
    va_end( marker );

    return  iLength;
}

// !defined(NOTRACE) from way at the top of this include file
#endif // !defined(NOTRACE)

// Asserts are independent of tracing
// (with the exception of flushing the trace buffer).

//
// For now enable ASSERT defines only if debugging is enabled
//
#ifdef  DEBUG
#define _ENABLE_ASSERTS

#ifndef NOTRACE
#define _ENABLE_VERBOSE_ASSERTS
#endif  // NO_TRACE

#endif  // DEBUG

//
// Macros added for doing asserts and verifies.  basic clones
// of the MFC macros with a prepended _ symbol
//
#ifdef  _ENABLE_ASSERTS

extern DllExport void WINAPI DebugAssert(   DWORD dwLine,
                                            LPSTR lpszFunction,
                                            LPSTR lpszExpression );

#ifndef _ASSERT
#ifdef  _ENABLE_VERBOSE_ASSERTS
#define _ASSERT(f)  !(f) ? DebugAssert( __LINE__,  THIS_FILE, #f ) : ((void)0)
#else
#define _ASSERT(f)  !(f) ? DebugBreak() : ((void)0)
#endif  //_ENABLE_VERBOSE_ASSERTS
#endif

#define _VERIFY(f)  _ASSERT(f)

#else

#undef _ASSERT
#undef _VERIFY
#define _ASSERT(f)  ((void)0)
#define _VERIFY(f)  ((void)(f))

#endif  // _ENABLE_ASSERTS

#endif // !defined(_DBGTRACE_H_)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\dbsqltyp.h ===
/****************************************************************************************
 * NAME:        DBSQLTYP.H
 * MODULE:      DBSQL
 * AUTHOR:      Ross M. Brown
 *
 * HISTORY
 *      08/29/94  ROSSB      Created
 *		05/08/96  DanielLi	 Added Pxxxx defs
 *
 * OVERVIEW
 *
 * Includes basic Account database types for use by other services.
 * (See "acctapi.h" for api definitions.)
 *
 ****************************************************************************************/

#ifndef DBSQLTYP_H
#define DBSQLTYP_H

#include <windows.h>

typedef ULONG 	HACCT;
typedef HACCT 	*PHACCT;
typedef ULONG 	HOWNER;
typedef ULONG 	HPAYMENTMETHOD;
typedef int	  	TOKEN;
typedef TOKEN	*PTOKEN;
typedef WORD  	AR;
typedef AR		*PAR;
typedef ULONG	HGROUP;
typedef HGROUP	*PHGROUP;

//typedef ULONG TOKEN;

#endif // DBSQLTYP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\fhashex.inl ===
/*++

	FHashEx.inl

	This file contains the template implementation of the class TFHashEx.

--*/


//---------------------------------------------
template<	class Data, 
			class Key,
			class KEYREF		/* This is the type used to point or reference items in the cache*/
			>
TFHashEx< Data, Key, KEYREF	>::TFHashEx( ) : 
	m_cBuckets( 0 ), 
	m_cActiveBuckets( 0 ),
	m_cNumAlloced( 0 ), 
	m_cIncrement( 0 ), 
	m_ppBucket( 0 ), 
	m_pfnHash( 0 ), 
	m_pGetKey( 0 ),
	m_pMatchKey( 0 ),	
	m_load( 0 )	{
//
//	Very basic constructor
//

}

//---------------------------------------------
template<	class	Data, 
			class	Key, 
			class	KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Init( 
							NEXTPTR	pNext,
							int cInitial, 
							int cIncrement, 
							DWORD (*pfnHash)(KEYREF), 
							int load,
							GETKEY		pGetKey, 
							MATCHKEY	pMatchKey
							) {
/*++

Routine Description : 

	Initialize the hash table 

Arguments : 

	pNext - A pointer to Member with class Data where we can hold
		our bucket pointers !
	cInitial - Initial size of the hash table
	cIncrement - Amount to grow the hash table by !
	pfnHash - Hash Function - 
	load - Average bucket length before growing the table !

Return Value : 

	TRUE if successfull FALSE otherwise

--*/

	m_pGetKey = pGetKey ;
	m_pMatchKey = pMatchKey ;

    //
    // Compute nearest power of 2
    //

	m_pNext = pNext ;

    int	power = cInitial ;
    while( power & (power-1) )
        power = power & (power-1) ;
    power<<= 1 ;

    cInitial = power;
	m_load = load ;
	m_pfnHash = pfnHash ;

    //
    // Number of ActiveBuckets is initially half that of the number of buckets.
    //

    m_cActiveBuckets = power/2  ;
    m_cBuckets = power ;
    m_cInserts = m_cActiveBuckets * m_load ;
    m_cIncrement = m_cActiveBuckets / 4;
	m_cNumAlloced = cInitial + 5 * m_cIncrement ;

	//
	// Allocate bucket pointers and zero initialize
	//

	m_ppBucket = new Data*[m_cNumAlloced] ;

    if( m_ppBucket ) {
	    ZeroMemory( m_ppBucket, m_cNumAlloced * sizeof( Data*) ) ;
	    _ASSERT( IsValid( FALSE ) ) ;
	    return  TRUE ;
	}
	return	FALSE ;
}

//------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::IsValid( BOOL fCheckHash ) {
/*++

Routine Description : 

	Check that the hash table is valid 

Arguments : 

	fCheckHash - verify that all the buckets contain the correct hash values !

Return Value : 

	TRUE if successfull FALSE otherwise

--*/

	//
	//	This function checks that all member variables are consistent and correct.
	//	Do not call this function until AFTER calling the Init() function.
	//

	if( m_cBuckets <= 0 ||
		m_cActiveBuckets <= 0 ||
		m_cNumAlloced <= 0 ||
		m_cIncrement <= 0 ||
		m_load <= 0 )
		return	FALSE ;

	if( m_cActiveBuckets < (m_cBuckets / 2) || m_cActiveBuckets > m_cBuckets )
		return	FALSE ;

	if( m_cActiveBuckets > m_cNumAlloced )
		return	FALSE ;

	if( m_cInserts > (m_load * m_cActiveBuckets) )
		return	FALSE ;

	if( m_ppBucket == 0 )
		return	FALSE ;

	if( fCheckHash ) {
		//
		// Examine every bucket chain to ensure that elements are in correct slots.
		//
		for( int i=0; i<m_cNumAlloced; i++ ) {

			if( i>=m_cActiveBuckets ) {
				if( m_ppBucket[i] != 0 ) {
					return	FALSE ;
				}
			}	else	{
				for( Data	*p = m_ppBucket[i]; p != 0; p = p->*m_pNext ) {
					KEYREF	keyref = (p->*m_pGetKey)();
					if( ComputeIndex( m_pfnHash( keyref ) ) != unsigned(i) ) {
						return	FALSE ;
					}
				}
			}
		}
	}
	return	TRUE ;
}



//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
TFHashEx< Data, Key, KEYREF >::~TFHashEx() {
/*++

Routine Description : 

	Destroy the hash table !

Arguments : 

	None

Return Value : 

	None

--*/
	//
	//	The destructor discards any memory we have allocated.
	//
	Clear();
}


//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
void
TFHashEx< Data, Key, KEYREF >::Clear() {
/*++

Routine Description : 

	Delete all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !

Arguments : 
	
	None.

Return Value : 

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_ppBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		for( int i=0; i<m_cNumAlloced; i++ ) {
			Data	*p, *pNext ;
			for( p = m_ppBucket[i], pNext = p ? p->*m_pNext : 0;
					p!=0; p=pNext, pNext= p ? p->*m_pNext : 0 ) {
				delete	p ;
			}
		}
		delete[] m_ppBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}


//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
void
TFHashEx< Data, Key, KEYREF >::Empty() {
/*++

Routine Description : 

	Remove all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !
	This is just like Clear() but it does do a "delete".

Arguments : 
	
	None.

Return Value : 

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_ppBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		delete[] m_ppBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}

//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
DWORD
TFHashEx< Data, Key, KEYREF >::ComputeIndex( DWORD dw ) {
/*++

Routine Description : 

	Compute which bucket an element should be in

	This function tells us where we should store elements.  To do this we mod with
	m_cBuckets.  Since we only have m_cActiveBuckets in reality, we check the result
	of the mod and subtract m_cBuckets over 2 if necessary.

Arguments : 

	dw - the hash value of the entry we are adding to the table

Return Value : 

	Index to the bucket to use !

--*/

	DWORD	dwTemp = dw % m_cBuckets ;
	return	(dwTemp >= (unsigned)m_cActiveBuckets) ? dwTemp - (m_cBuckets/2) : dwTemp ;
}



template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Insert( Data& d ) {
/*++

Routine Description : 

	Insert a Data element into the hash table

Arguments : 

	d - reference to the item to be inserted into the table 

Return Value : 

	TRUE if successfull - FALSE otherwise !

--*/

	_ASSERT( d.*m_pNext == 0 ) ;
	_ASSERT( IsValid( FALSE ) ) ;

	if( InsertData( d ) ) 
		return	TRUE ;
	return	FALSE ;
}

template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Insert( Data* pd ) {
/*++

Routine Description : 

	Insert a Data element into the hash table

Arguments : 

	pd - pointer to the item to be inserted into the table 

Return Value : 

	TRUE if successfull - FALSE otherwise !

--*/

	_ASSERT( pd->*m_pNext == 0 ) ;
	_ASSERT( IsValid( FALSE ) ) ;

	KEYREF	keyref = (pd->*m_pGetKey)() ;
	if( InsertDataHash( m_pfnHash( keyref ), pd ) ) 
		return	TRUE ;
	return	FALSE ;
}

//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::InsertDataHash( 
								DWORD	dwHash,
								Data&	d 
								) {
/*++

Routine Description : 

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments : 

	dw - the hash value of the entry we are adding to the table
	d -  The item we are adding to the table !

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( d.*m_pNext == 0 ) ;

	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			Data** pTemp = new Data*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				//
				//	bugbug ... need to handles this error better !?
				//
				return	0 ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( Data*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( Data* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) 
			m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			Data**	ppNext = &m_ppBucket[ iCurrent ] ;
			Data*	p = *ppNext ;
			while( p ) {

				KEYREF	keyref = (p->*m_pGetKey)();
				int	index = ComputeIndex( m_pfnHash( keyref ) ) ;
				Data*	pNext = p->*m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->*m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &(p->*m_pNext) ;
				}
				p = pNext ;
			}
		}
		_ASSERT( IsValid( TRUE ) ) ;
	}

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	KEYREF	keyref = (d.*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;

	d.*m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = &d ;

	_ASSERT( IsValid( FALSE ) ) ;

	return	&d ;
}

//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::InsertDataHash( 
								DWORD	dwHash,
								Data*	pd 
								) {
/*++

Routine Description : 

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments : 

	dw - the hash value of the entry we are adding to the table
	pd - Pointer to the item we are adding to the table !

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( pd->*m_pNext == 0 ) ;

	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			Data** pTemp = new Data*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				//
				//	bugbug ... need to handles this error better !?
				//
				return	0 ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( Data*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( Data* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) 
			m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			Data**	ppNext = &m_ppBucket[ iCurrent ] ;
			Data*	p = *ppNext ;
			while( p ) {

				KEYREF	keyref = (p->*m_pGetKey)();
				int	index = ComputeIndex( m_pfnHash( keyref ) ) ;
				Data*	pNext = p->*m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->*m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &(p->*m_pNext) ;
				}
				p = pNext ;
			}
		}
		_ASSERT( IsValid( TRUE ) ) ;
	}

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	KEYREF	keyref = (pd->*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;

	pd->*m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = pd ;

	_ASSERT( IsValid( FALSE ) ) ;

	return	pd ;
}


//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
inline	Data*
TFHashEx< Data, Key, KEYREF >::InsertData( Data& d ) {
/*++

Routine Description : 

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain,
	and we will also compute the hash of the key !

Arguments : 

	d -  The item we are adding to the table !

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/
	_ASSERT( IsValid( FALSE ) ) ;

	KEYREF	keyref = (d.*m_pGetKey)() ;
	return	InsertDataHash(	m_pfnHash( keyref ), d ) ;
}


//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Search(	KEYREF	k, 
										Data &dOut 
										) {
/*++

Routine Description : 

	Search for an element in the hashtable.

Arguments : 


	k - key of the item to find
	dOut - A reference that we will set to the
		located data item

Return Value : 

	TRUE if found, FALSE otherwise 

--*/

	const	Data*	pData = SearchKey( k ) ;
	if( pData ) {
		dOut = *pData ;
		return	TRUE ;
	}
	return	FALSE ;
}

//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::SearchKeyHash( 
									DWORD	dwHash, 
									KEYREF	k 
									) {
/*++

Routine Description : 

	Search for an element in the Hash Table, 
	
Arguments : 

	dwHash - the hash value of the entry we are adding to the table
	k - reference to the key we are to compare against 

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( dwHash == (m_pfnHash)(k) ) ;

	DWORD	index = ComputeIndex(	dwHash ) ;
	Data*	p = m_ppBucket[index] ;
	while( p ) {
		if( (p->*m_pMatchKey)( k ) )
			break ;
		p = p->*m_pNext ;
	}
	return	p ;
}



//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
inline	Data*
TFHashEx< Data, Key, KEYREF >::SearchKey( KEYREF	k ) {
/*++

Routine Description : 

	Search for an element in the Hash Table, 
	We will compute the hash of the key.
	
Arguments : 

	k - reference to the key we are to compare against 

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	return	SearchKeyHash( m_pfnHash( k ), k ) ;
}



//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Delete( KEYREF	k ) {
/*++

Routine Description : 

	Find an element in the hash table, remove it from
	the table and then destroy it !
	
Arguments : 

	k - reference to the key we are to compare against 

Return Value : 

	TRUE if an item is found and destroyed, FALSE otherwise !

--*/


	Data*	p = DeleteData( k, 0 ) ;
	if( p ) {
		delete	p ;
		return	TRUE ;
	}
	return	FALSE ;
}



//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::DeleteData(	KEYREF	k,
											Data*	pd
											) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	_ASSERT( IsValid( FALSE ) ) ;

	DWORD	dwHash = (m_pfnHash)( k ) ;

	DWORD	index = ComputeIndex( dwHash ) ;
	Data**	ppNext = &m_ppBucket[index] ;
	Data*	p = *ppNext ;

	while( p ) {
		if( (p->*m_pMatchKey)( k ) )
			break ;
		ppNext = &(p->*m_pNext) ;
		p = *ppNext ;
	}
	if( p ) {
		//
		//	If we were given a pointer to a data block, than the client
		//	wants us to check to make sure that we are deleting the correct
		//	instance !!
		//
		if( !pd || pd == p ) {
			*ppNext = p->*m_pNext ;
			p->*m_pNext = 0 ;


			//
			//	Finally - since we removed something from the hash table 
			//	increment the number of inserts so that we don't keep splitting
			//	the table unnecessarily !
			//
			m_cInserts++ ;

			_ASSERT( IsValid( FALSE ) ) ;
		}	else	{
			p = 0 ;
		}
	}
	_ASSERT( IsValid( FALSE ) ) ;
	return	p ;
}

template<	class Data, 
			class Key, 
			class KEYREF 
			>
DWORD
TFHashEx< Data, Key, KEYREF >::ComputeHash(	KEYREF	k	)	{

	return	m_pfnHash( k ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\fhashex.h ===
/*++
	FHash.h

	This file contains a template class for a hash table.
	The template has two arguments, the type of the Data Elements and the 
	type of the Key.  

	The Data type must support the following : 

	class Data {
		Data*	m_pNext ;

		KEYREF	GetKey(	) ;

		int		MatchKey(	KEYREF	otherkey) ;	/* NOTE : MatchKey returns non-zero on equality
	} ;

	DWORD	(* m_pfnHash)( KEYREF k ) ;	
	
--*/

#ifndef	_FHASHEX_H_
#define	_FHASHEX_H_

//------------------------------------------------------------
template<	class	Data,		/* This is the item that resides in the hashtable */
			class	Key,		/* This is the type of the Key */
			class	KEYREF		/* This is the type used to point or reference items in the cache*/
			>
class	TFHashEx	{
//
//	This class defines a Hash table which can grow dynamically to 
//	accomodate insertions into the table.  The table only grows, and 
//	does not shrink.
//
public : 
	//
	//	Define the subtypes we need !
	//

	//
	//	This is a member pointer to a pointer to Data - 
	//	i.e. this is the offset in the class Data where we 
	//	will hold the next pointers for our hash buckets !
	//
	typedef	Data*	Data::*NEXTPTR ;

	//
	//	This is a member function pointer to a function which
	//	will retrieve the key we are to use !
	//
	typedef	KEYREF	(Data::*GETKEY)( ) ;

	//
	//	This is a member function pointer of the type that will
	//	compare keys for us !
	//
	typedef	int		(Data::*MATCHKEY)( KEYREF key ) ;


private : 


	//
	// An array of pointer to buckets.
	//
	Data**	m_ppBucket ;	

	//
	//	Member Pointer - points to where the pointer is that
	//	we should use for chaining buckets together !
	//
	NEXTPTR	m_pNext ;	

	//
	//	Member Pointer - will get the key out of the object for us !
	//
	GETKEY	m_pGetKey ;

	//
	//	Member Pointer - will compare the key in the item for us !
	//
	MATCHKEY	m_pMatchKey ;
	
	//
	// A counter that we use to determine when to grow the
	// hash table.  Each time we grow the table we set this
	// to a large positive value, and decrement as we insert
	// elements.  When this hits 0 its time to grow the table !
	//
	long	m_cInserts ;		

	//
	// The function we use to compute hash values.
	// (Provided by the Caller of Init())
	//
	DWORD	(* m_pfnHash)( KEYREF k ) ;	

	//
	// Number of Buckets used in index computation
	//
	int		m_cBuckets ;		

	//
	// Number of Buckets we are actually using
	// Assert( m_cBuckets >= m_cActiveBuckets ) always true.
	//
	int		m_cActiveBuckets ;	

	//
	// Number of Buckets we have allocated 
	// Assert( m_cNumAlloced >= m_cActiveBuckets ) must
	// always be true.
	//
	int		m_cNumAlloced ;		

	//
	// The amount we should grow the hash table when we 
	// decide to grow it.
	//
	int		m_cIncrement ;		

	//
	// The number of CBuckets we should allow in each 
	// collision chain (on average).
	//
	int		m_load ;			

	//
	// The function we use to compute the 
	// position of an element in the hash table given its
	// Hash Value.
	//
	DWORD	
	ComputeIndex( DWORD dw ) ;	

public : 
	TFHashEx( ) ;
	~TFHashEx( ) ;

	BOOL	
	Init(	NEXTPTR	pNext,
			int		cInitial, 
			int		cIncrement, 
			DWORD	(* pfnHash)( KEYREF	), 
			int,
			GETKEY,
			MATCHKEY
			) ;

	//
	//	Check that the hash table is in a valid state
	//	if fCheckHash == TRUE we will walk all the buckets and check that
	//	the data hashes to the correct value !
	//
	BOOL	
	IsValid( BOOL fCheckHash = FALSE ) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	
	InsertDataHash(	DWORD	dw,
					Data&	d 
					) ;

	//
	//	Insert a piece of Data into the Hash Table
    //  We take a pointer to the Data object.
	//
	Data*	
	InsertDataHash(	DWORD	dw,
					Data*	pd 
					) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	
	InsertData(	Data&	d ) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	
	SearchKeyHash(	DWORD	dw,
					KEYREF	k 
					) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	
	SearchKey(	KEYREF	k ) ;

	//
	//	Search for a given Key in the Hash Table and remove
	//	the item if found.  We will return a pointer to the item.
	//
	Data*
	DeleteData(	KEYREF	k,	
				Data*	pd = 0	
				) ;

	//	
	//	Insert the given block of data into the hash table.
	//	We will make a copy of the Data Object and store it in one 
	//	of our bucket objects.
	//
	BOOL	
	Insert( Data&	d	) ;

	//	
	//	Insert the given block of data into the hash table.
	//	We take a pointer to the Data Object and store it in one 
	//	of our bucket objects.
	//
	BOOL	
	Insert( Data*	pd	) ;

	//	
	//	Find the given key in the table and copy the Data object into 
	//	the out parameter 'd'
	//
	BOOL	
	Search( KEYREF	k, 
			Data &d 
			) ;

	//
	//	Delete the key and associated data from the table.
	//
	BOOL	
	Delete( KEYREF	k ) ;

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	void	Clear( ) ;

	//
	//	Removes all of the items in the hash table.  Does not call "delete"
	//  on them.
	//
	void	Empty( ) ;

	//
	//	Function to compute hash value of a key for callers
	//	who don't keep track of the hash function 
	//
	DWORD
	ComputeHash(	KEYREF	k ) ;

} ;

#include	"fhashex.inl"

#endif // _FHASHEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\filehc.h ===
/*++

    Copyright (c) 2002  Microsoft Corporation

    Module Name:

	    FILEHC.H

    Abstract:

	    This file defines the public interfaces for issuing async
        Reads/Writes to a file using the fcache wrapper library.

--*/

#ifndef	_FILEHC_H_
#define	_FILEHC_H_

#ifdef	__cplusplus	
extern	"C"	{
#endif

typedef	VOID
(*PFN_IO_COMPLETION)(
		IN	struct	FIO_CONTEXT*	pContext,
		IN	struct	FH_OVERLAPPED*	lpo, 
		IN	DWORD		cb, 
		IN	DWORD		dwCompletionStatus
		);



struct	FH_OVERLAPPED	{
/*++

	This structure defines the extended OVERLAPPED structure
	used by the File IO layer implemented in this module.

	The first 5 elements of this structure are identical to 
	NT's OVERLAPPED structure and have the exact same semantics.
	
	The final additional parameter is a pointer to a 
	function that will be called to complete the IO.

--*/
	UINT_PTR	Internal ;
	UINT_PTR	InternalHigh ;
	DWORD		Offset ;
	DWORD		OffsetHigh ;
	HANDLE		hEvent ;
	PFN_IO_COMPLETION	pfnCompletion ;	
	UINT_PTR	Reserved1 ;
	UINT_PTR	Reserved2 ;
	UINT_PTR	Reserved3 ;
	UINT_PTR	Reserved4 ;
} ;

typedef	struct	FH_OVERLAPPED*	PFH_OVERLAPPED ;

struct	FIO_CONTEXT	{
/*++

	This structure defines the context object
	that is used to represent file handles.

--*/
    //
    //  Temporary hack - mailmsg object assumes it can put a NULL in us !
    //
    DWORD       m_dwTempHack ;

	//
	//	The context signature !
	//
	DWORD		m_dwSignature ;

	//
	//	The users file handle !
	//
	HANDLE		m_hFile ;

	//
	//  The offset to back fill Lines header - nntp aware only
	//
	DWORD       m_dwLinesOffset;

	//
	//  Header length - nntp aware only
	//
	DWORD       m_dwHeaderLength;
} ;

typedef	FIO_CONTEXT*	PFIO_CONTEXT ;


#ifdef	_FILEHC_IMPLEMENTATION_
#define	FILEHC_EXPORT	__declspec( dllexport )	
#else
#define	FILEHC_EXPORT	__declspec( dllimport )	
#endif


//
//	Initialize the DLL for Async IO - 
//	This is a counting initialize - for each call to FIOInitialize()
//	there should be a matching call to FIOTerminate
//
FILEHC_EXPORT
BOOL	__stdcall
FIOInitialize(
    IN DWORD dwFlags
    );

//
//	Terminate the DLL's support for Async IO !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOTerminate(
    VOID
    );

//
//	Do an async read against the File !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOReadFile(
    IN  PFIO_CONTEXT	pContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
    IN  FH_OVERLAPPED *	lpo
    );

//
//	Do an async read against the file - pass extra args
//	so that if the FIO_CONTEXT is doing dot stuffing for the user
//	it can do so efficiently !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOReadFileEx(
    IN  PFIO_CONTEXT	pContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
	IN	DWORD			BytesAvailable, // must be >= BytesToWrite - number of bytes I can mess with.
    IN  FH_OVERLAPPED *	lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ? 
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
    );


//
//	Do an async write against the file !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOWriteFile(
    IN  PFIO_CONTEXT	pContext,
    IN  LPCVOID			lpBuffer,
    IN  DWORD			BytesToWrite,
    IN  FH_OVERLAPPED * lpo
    );

//
//	Do an async write against the file - pass extra args
//	so that if the FIO_CONTEXT is doing dot stuffing for the user
//	it can do so efficiently !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOWriteFileEx(
	IN	PFIO_CONTEXT	pContext,
	IN	LPVOID			lpBuffer,
	IN	DWORD			BytesToWrite,
	IN	DWORD			BytesAvailable, // must be >= BytesToWrite - number of bytes I can mess with.
	IN	FH_OVERLAPPED*	lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ? 
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
	) ;

//
//	Callback functions which create things in the cache !
//
//	NOTE: this is equivalent to FCACHE_RICHCREATE_CALLBACK where
//
//	pfDidWeScanIt - returns FALSE
//	pfIsStuffed - return FALSE
//	pfStoredWithDots - return FALSE
//
typedef	
HANDLE	
(__stdcall	*FCACHE_CREATE_CALLBACK) (
		IN	LPSTR	lpstrName, 
		IN	LPVOID	lpvData, 
		OUT	DWORD*	cbFileSize,
		OUT	DWORD*	cbFileSizeHigh
		) ;


//
//	Callback functions which create things in the cache !
//
//	This function will be called by CacheRichCreateFile().
//
//	lpstrName - the name of the file 
//	lpvData - User provided data, provided to CacheRichCreateFile
//	cbFileSize - The function should return the size of the file through this
//	cbFileSizeHigh - place to return the High DWORD of the file size
//	pfDidWeScanIt - if THIS is true then at some point the created file has been
//		scanned for DOTs appearing at the beginning of lines
//	pfIsStuffed - This is only meaningfull if pfDidWeScanIt==TRUE, in which case
//		if this is TRUE this indicates that there are DOTs at the beginning of lines
//	pfStoredWithDots - If this is TRUE then it indicates that any DOTs that appear
//		at the beginning of lines are stored with an extra dot as required in NNTP, 
//		SMTP and POP3 protocols.  if this is FALSE then the message is stored without
//		DOT stuffing.
//
typedef	
HANDLE	
(__stdcall	*FCACHE_RICHCREATE_CALLBACK) (
		IN	LPSTR	lpstrName, 
		IN	LPVOID	lpvData, 
		OUT	DWORD*	cbFileSize, 
		OUT	DWORD*	cbFileSizeHigh,
        OUT BOOL*   pfDidWeScanIt,
        OUT BOOL*   pfIsStuffed,
		OUT	BOOL*	pfStoredWithDots, 
		OUT	BOOL*	pfStoredWithTerminatingDot
		) ;

//
//	Initialize the File Handle Cache - 
//
//	NOTE : this will automatically initialize the DLL for async
//	IO as well !
//
FILEHC_EXPORT
BOOL	__stdcall
InitializeCache() ;

//
//	Terminate the cache !
//	
//	NOTE : this will terminate the DLL for async IO as well !
//
FILEHC_EXPORT
BOOL	__stdcall
TerminateCache() ;

//
//	Associate a file with an async context !
//
FILEHC_EXPORT
PFIO_CONTEXT	__stdcall	
AssociateFile(	HANDLE	hFile	) ;

//
//	This allows the user to specify whether file stores content with extra DOTS
//	added for RFC 822 protocols (i.e. NNTP and SMTP DATA commands).
//
//	NOTE: AssociateFile() is the same as AssociateFileEx( hFile, FALSE ) ;
//
//	hFile - The file that contains message content, or in which we will write message content
//	fStoreWithDots - if TRUE then each period or DOT in the file which starts a line
//		but is NOT part of the terminating CRLF.CRLF will be stored with an extra dot
//		adjacent to it.  This is the on the wire format for NNTP for instance.
//
FILEHC_EXPORT
PFIO_CONTEXT	__stdcall
AssociateFileEx(	HANDLE	hFile,
					BOOL	fStoreWithDots, 
					BOOL	fStoredWithTerminatingDot 
					) ;

//
//	Add a reference to a context - 
//	
//	Each call to AddRefContext() must be matched by a corresponding
//	call to ReleaseContext().   Both AssociateFile and CacheCreateFile()
//	also add a single reference which must be matched by a call to ReleaseContext().
//
FILEHC_EXPORT
void	__stdcall	
AddRefContext(	PFIO_CONTEXT ) ;

//
//	Release a Context !
//
//	FIO_CONTEXT's are reference counted - the user must call
//	this for each successfull call to CacheCreateFile(), and 
//	each call to InsertFile() where fKeepReference is TRUE
//
FILEHC_EXPORT
void	__stdcall
ReleaseContext(	PFIO_CONTEXT ) ;

//
//	Close a handle associated with a non-cached FIO_CONTEXT
//
//	This is used to Close the file handle within a context.
//	This only succeeds if the FIO_CONTEXT is not cached !
//
FILEHC_EXPORT
BOOL	__stdcall
CloseNonCachedFile(	PFIO_CONTEXT	) ;

//
//	Create a file in the cache, or find an existing one !
//
//	If the file is not in the cache, the cache will call 
//	pfnCallBack with lpv to do the actual work of calling
//	CreateFile().
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
CacheCreateFile(	IN	LPSTR	lpstrName, 
					IN	FCACHE_CREATE_CALLBACK	pfnCallBack, 
					IN	LPVOID	lpv, 
					IN	BOOL	fAsyncContext
					) ;
					
//
//	Create a file in the cache or find an existing one, 
//	if we create the file we can add properties onto it in 
//	the cache !
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
CacheRichCreateFile(	IN	LPSTR	lpstrName, 
						IN	FCACHE_RICHCREATE_CALLBACK	pfnCallBack, 
						IN	LPVOID	lpv, 
						IN	BOOL	fAsyncContext
						) ;

//
//	This function allows a user to remove all files with the specified 
//	Name from the cache.  if fAllPrefixes is TRUE, we will remove all files
//	where the Name matches the beginning of the path !
//	If fAllPrefixes is FALSE then we will remove only the one file which 
//	exactly matches lpstrName !
//
FILEHC_EXPORT
void	__stdcall
CacheRemoveFiles(	IN	LPSTR	lpstrName,
					IN	BOOL	fAllPrefixes
					) ;
//
//	Insert the file into the cache !
//
//	This function will add the file handle in the FIO_CONTEXT
//	to the cache.  All searches by lpstrName will find this
//	item untill it expires from the cache.
//
//	If fKeepReference is TRUE then the user must make a call to 
//	ReleaseContext() for the inserted FIO_CONTEXT !
//
FILEHC_EXPORT
BOOL	__stdcall	
InsertFile(		IN	LPSTR	lpstrName, 
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL	fKeepReference 
				) ;

//
//	Report the file size that we've cached with the handle
//
FILEHC_EXPORT
DWORD	__stdcall
GetFileSizeFromContext(	IN	FIO_CONTEXT*	pContext, 
						OUT	DWORD*			pcbFileSizeHigh
						) ;

//----------------------------------------------------------------------
// NAME CACHE NAME CACHE NAME CACHE - 
//
//	Name Cache API's
//
//

//
//	This is the function pointer provided by clients to compare 
//	keys.  This must be provided on all calls.
//
//	The function has memcmp() semantics, i.e. it must order the keys
//	consistently, and return <0 if key1 is smaller then key2, ==0 if the
//	keys match and >0 if key1 is greater then key2.
//
typedef	
int
(__stdcall	*CACHE_KEY_COMPARE)(	IN	DWORD	cbKey1, 
									IN	LPBYTE	lpbKey1,
									IN	DWORD	cbKey2, 
									IN	LPBYTE	lpbKey2
									) ;

//
//	This is the function provided by clients to compute a hash 
//	value on Keys - NOTE: The Cache will provide a hash function 
//	IF the user does not, however the internally provided hash
//	function is best only for things that appear to be regular strings.
//
typedef
DWORD
(__stdcall	*CACHE_KEY_HASH)(	IN	LPBYTE	lpbKey, 
								IN	DWORD	cbKey
								) ;

//
//	This is the generic callback function that is provided to the 
//	cache to help examine items within the cache.
//	The BOOL return value is meaningfull to the Cache API's only
//	on the following calls : 
//
//
typedef	
BOOL
(__stdcall	*CACHE_READ_CALLBACK)(	IN	DWORD	cb, 
									IN	LPBYTE	lpb, 
									IN	LPVOID	lpvContext
									) ;

//	
//	This is a callback that is called whenever we destroy an entry in 
//	the name cache - this is called once for both key and data components, 
//	and gives the client a chance to track any relationships 
//
//	NOTE : if the client does not associate 
//	data with the name, the function will only be called for the Key data.
//
typedef
void
(__stdcall	*CACHE_DESTROY_CALLBACK)(	IN	DWORD	cb, 
										IN	LPBYTE	lpb
										) ;

//
//	This is a callback this is called whenever we evaluate a security descriptor.
//	If it is not provided we will call the standard NT AccessCheck() call !
//
//	The function has the same signature as AccessCheck, however there are arguments
//	we don't use - PrivilegeSet will always be NULL and PrivilegeSetLength will always be 0 !
//
typedef
BOOL
(WINAPI	*CACHE_ACCESS_CHECK)(	IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
								IN	HANDLE					hClientToken,
								IN	DWORD					dwDesiredAccess, 
								IN	PGENERIC_MAPPING		GenericMapping, 
								IN	PRIVILEGE_SET*			PrivilegeSet, 
								IN	LPDWORD					PrivilegeSetLength,
								IN	LPDWORD					GrantedAccess, 
								IN	LPBOOL					AccessStatus
								) ;


//
//	This is the externally exposed structure representing a Name Cache - 
//	it doesn't contain any fields usefull for a client, but must be passed
//	back into all of the name cache API's
//
struct	NAME_CACHE_CONTEXT	{
	//
	//	Signature DWORD ! - user must not touch this !
	//
	DWORD		m_dwSignature ;
} ;

typedef	struct	NAME_CACHE_CONTEXT*	PNAME_CACHE_CONTEXT ;

//
//	API's for creating/manging NAME CACHE's
//	NOTE : Name Cache's are reference counted, and if this
//	function is called twice with the same name we will 
//	Add a reference to an existing Name Cache.
//
FILEHC_EXPORT
PNAME_CACHE_CONTEXT	__stdcall
FindOrCreateNameCache(
		//
		//	Must not be NULL ! - this is CASE SENSITVE !
		//
		LPSTR	lpstrName, 
		//
		//	Must not be NULL !
		//
		CACHE_KEY_COMPARE		pfnKeyCompare, 
		//
		//	This may be NULL, in which case the cache will provide one !
		//
		CACHE_KEY_HASH			pfnKeyHash, 
		//
		//	The following two function pointers may be NULL !
		//
		CACHE_DESTROY_CALLBACK	pfnKeyDestroy, 
		CACHE_DESTROY_CALLBACK	pfnDataDestroy
		) ;

//
//	API's for releasing the NAME CACHE !
//
//	The caller must guarantee the thread safety of this call - This function must not 
//	be called if any other thread is simultanesouly executing within 
//	CacheFindContectFromName(), AssociateContextWithName(), AssociateDataWithName(), or InvalidateName() 
//
FILEHC_EXPORT
long	__stdcall
ReleaseNameCache(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache
		) ;


//
//	API's for setting options on the name cache - this can be used to change
//	how Security is evaluated !
//
FILEHC_EXPORT
BOOL	__stdcall
SetNameCacheSecurityFunction(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache, 
		//
		//	This is the function pointer that will be used to evaluate security - 
		//	this may be NULL - if it is we will use the Win32 Access Check !
		//
		CACHE_ACCESS_CHECK		pfnAccessCheck
		) ;

//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer, 
//	if the user passed a NULL FIO_CONTEXT to AssociateContextWithName() !
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					) ;


//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer, 
//	if the user passed a NULL FIO_CONTEXT to AssociateContextWithName() !
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindSyncContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					) ;


//
//	Cache Associate context with name !
//	This insert a Name into the Name cache, that will find the specified FIO_CONTEXT !
//
//	If the name is already present in the cache, this will fail with GetLastError()==ERROR_DUP_NAME !
//
FILEHC_EXPORT
BOOL	__stdcall
AssociateContextWithName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User may provide some arbitrary data to assoicate with the name !
					//	
					IN	LPBYTE	lpbData, 
					IN	DWORD	cbData, 
					//
					//	User may provide a self relative security descriptor to 
					//	be associated with the name !
					//
					IN	PGENERIC_MAPPING		pGenericMapping,
					IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
					//
					//	User provides the FIO_CONTEXT that the name should reference
					//
					FIO_CONTEXT*		pContext,
					//
					//	User specifies whether they wish to keep their reference on the FIO_CONTEXT
					//
					BOOL				fKeepReference
					) ;

//
//	This function allows the user to remove a single name and all associated data
//	from the name cache.
//
FILEHC_EXPORT
BOOL
InvalidateName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName
					) ;
	

//
//	End of Name Cache API's
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
//	DOT STUFFING API's
//

//
//  This function gets an FIO_CONTEXT with the requested state.
//  We may or may not create a new FIO_CONTEXT, if we do create one we'll stick 
//  it into the cache so it can be used again !
//  NOTE: if we have to do work, the user has the only reference to the resulting
//  FIO_CONTEXT which will go away when they call ReleaseContext() !
//
//	pContext - the original FIO_CONTEXT
//	lpstrName - the file name associated with pContext
//	fWantItDotStuffed - if TRUE the resulting FIO_CONTEXT should be dot stuffed !
//	fTerminatorIncluded - if this is TRUE the source FIO_CONTEXT contains a terminating
//	dot that we should be carefull not to stuff !
//
//	NOTE: We may return the same FIO_CONTEXT as the caller provided - in which case
//	an extra reference has been added that needs to be dropped with ReleaseContext() !
//
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
ProduceDotStuffedContext(	IN	FIO_CONTEXT*	pContext,
                            IN  LPSTR           lpstrName,
							IN  BOOL			fWantItDotStuffed // if TRUE add dots, if FALSE remove dots
							) ;

//
//	This function takes a source FIO_CONTEXT (pContextSource) and copies
//	the content into pContextDestination.
//
//	The user specifies whether the Destination FIO_CONTEXT should be dot stuffed
//	with fWantItDotStuffed, and whether the source FIO_CONTEXT includes the 
//	terminating CRLF.CRLF
//
//	The out parameter pfModified is TRUE if there were modifications when
//	Source was copied to Destination !
//
//	The function returns TRUE if successfull, FALSE otherwise !
//
FILEHC_EXPORT
BOOL	__stdcall
ProduceDotStuffedContextInContext(
							IN	FIO_CONTEXT*	pContextSource,
							IN	FIO_CONTEXT*	pContextDestination,
							IN	BOOL			fWantItDotStuffed, 
							OUT	BOOL*			pfModified
							) ;
							



//
//	Find out whether the file has a terminating 'CRLF.CRLF' sequence !
//
FILEHC_EXPORT
BOOL	__stdcall
GetIsFileDotTerminated(	IN	FIO_CONTEXT*	pContext ) ;

//
//	Set whether the file has a terminating 'CRLF.CRLF' sequence !
//
FILEHC_EXPORT
void	__stdcall
SetIsFileDotTerminated(	IN	FIO_CONTEXT*	pContext,
						IN	BOOL			fIsDotTerminated 
						) ;

//
//	Enable dot stuffing properties on the write path of the file
//	handle cache of this message !
//
//	if fEnable is FALSE then all dot stuffing behaviour is turned
//	off.
//
//	if fStripDots is TRUE the File Handle Cache will convert 
//	occurrences of "\r\n." to "\r\n" within your message.
//
//	if fStripDots is FALSE the FileHandle Cache will convert occurrences
//	of "\r\n.." to "\r\n" within your message.
//	
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotStuffingOnWrites(	IN	FIO_CONTEXT*	pContext, 
						//
						//	fEnable == FALSE means ignore fStripDots, and writes are unmodified
						//
						IN	BOOL			fEnable,
						//
						//	fStripDots == TRUE means we remove dots that are dot stuffed, 
						//	fStripDots == FALSE means that we add dots to make the message dot stuffed
						//
						IN	BOOL			fStripDots
						) ;

#if 0 
//
//	This function temporarily disabled !
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotStuffingOnReads(	IN	FIO_CONTEXT*	pContext,
						IN	BOOL			fEnable,
						IN	BOOL			fStripDots
						) ;
#endif

//
//	Enable dot scanning properties on the write path 
//	of the file handle cache for this file !
//
//	if fEnable is TRUE the we will examine each write
//	that goes through us to determine whether the
//	message has any occurrences of "\r\n.".
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotScanningOnWrites(	IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fEnable
						) ;

//
//	
//	This function should be called when we have finished doing all writes to an FIO_CONTEXT
//	This function should be paired with SetDotStuffingOnWrites() and the fStripDots
//	parameter should be the same as when SetDotStuffingOnWrites() was called.
//
//	We will update the Dot Stuffing State of the FIO_CONTEXT and discard 
//	all dot stuffing memory and stuff that may have been required !
//
//	If this function call is paired with a call to SetDotScanningOnWrites() fStripDots should be TRUE !
//
FILEHC_EXPORT
void	__stdcall
CompleteDotStuffingOnWrites(	IN	FIO_CONTEXT*	pContext, 
								IN	BOOL			fStripDots
								) ;

//
//	This will cause us to examine each read for occurrences of 
//	"\r\n."
//
//	NOTE : the user must use ASYNC Reads for this to work - we will assert
//	if the user tries to pend any synchronous reads while we are in this state !
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotScanningOnReads(	IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fEnable
						) ;
							

//
//	If any of the dot stuffing mechanism our turned on, 
//	this will get a count of the number of occurrences/modifications
//	have occurred.
//
//	if fReads is TRUE we get the count for occurrences on Read's
//	if fReads is FALSE we get the count for occurrences on Write's
//
//	if dot stuffing was turned off or not enabled somehow then
//	GetDotStuffState() will return FALSE.
//
//	NOTE: A NULL pfStuffed is not allowed !
//
FILEHC_EXPORT
BOOL	__stdcall
GetDotStuffState(		IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fReads,
						OUT	BOOL*			pfStuffed,
						OUT	BOOL*			pfStoredWithDots
						) ;

//
//	In this case we always assume that the FIO_CONTEXT is not going to be dot stuffed.
//	fRequiresStuffing == TRUE indicates that it SHOULD BE stuffed.
//	fRequiresStuffing == FALSE indicates that the message does not need dot stuffing.
//
FILEHC_EXPORT
void	__stdcall
SetDotStuffState(		IN	FIO_CONTEXT*	pContext, 
						//
						//	fIsStuffed is only relevant when fKnown == TRUE
						//
						IN	BOOL			fKnown,		// We do know the dot stuff state
						//
						//	if fKnown is TRUE then fIsStuffed is meaningfull, when thats the case
						//	if fIsStuffed is TRUE then the message 
						//
						IN	BOOL			fRequiresStuffing// if fKnown is TRUE this arg is meaningfull
						) ;


#ifdef	__cplusplus	
}
#endif



#endif	// _FILEHC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\evntwrap.h ===
/*
 * An event log wrapper to simplify event logging for DLLs and to add
 * a few extra features.
 */

#ifndef __EVENTWRAP_H__
#define __EVENTWRAP_H__

#include <dbgtrace.h>
#include <fhashex.h>

#define LOGEVENT_DEBUGLEVEL_HIGH       1
#define LOGEVENT_DEBUGLEVEL_MEDIUM     2^15
#define LOGEVENT_DEBUGLEVEL_LOW        2^16

#define LOGEVENT_FLAG_ALWAYS		   0x00000001
#define LOGEVENT_FLAG_ONETIME		   0x00000002
#define LOGEVENT_FLAG_PERIODIC	       0x00000003
// we use the lower 8 bits for various logging modes, and reserve the
// other 24 for flags
#define LOGEVENT_FLAG_MODEMASK         0x000000ff

//
// This object is the key for the eventlog hash table
//
class CEventLogHashKey {
    public:
        char *m_szKey;
        DWORD m_idMessage;
        BOOL m_fAllocKey;

        CEventLogHashKey() {
            m_fAllocKey = FALSE;
            m_szKey = NULL;
            m_idMessage = 0;
        }

        HRESULT Init(const char *szKey, DWORD idMessage) {
            m_idMessage = idMessage;
            m_szKey = new char[strlen(szKey) + 1];
            if (m_szKey) {
                m_fAllocKey = TRUE;
                strcpy(m_szKey, szKey);
            } else {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }

        ~CEventLogHashKey() {
            if (m_fAllocKey && m_szKey) {
                delete[] m_szKey;
                m_szKey = NULL;
                m_fAllocKey = FALSE;
            }
            m_idMessage = 0;
        }
};

// Time to wait between periodic event logs in 100ns units. Note that this
// is larger than 32 bits (it is 8'61c46800).
const __int64 LOGEVENT_PERIOD = 36000000000; // 60 minutes

//
// For each unique idMessage/szKey event that is logged we insert one
// of these objects into a hash table.  This allows us to support the
// LOGEVENT_FLAG_ONETIME and LOGEVENT_FLAG_PERIODIC flags
//
class CEventLogHashItem {
    public:
        CEventLogHashItem *m_pNext;

        CEventLogHashItem() {
            m_pNext = NULL;
            ZeroMemory(&m_timeLastLog, sizeof(FILETIME));
            UpdateLogTime();
        }

        CEventLogHashKey *GetKey() {
            return &(m_key);
        }

        int MatchKey(CEventLogHashKey *pOtherKey) {
            return (m_key.m_idMessage == pOtherKey->m_idMessage &&
                    strcmp(m_key.m_szKey, pOtherKey->m_szKey) == 0);
        }

        HRESULT InitializeKey(const char *szKey, DWORD idMessage) {
            return m_key.Init(szKey, idMessage);
        }

        BOOL PeriodicLogOkay() {
            FILETIME timeCurrent;

            GetSystemTimeAsFileTime(&timeCurrent);

            LARGE_INTEGER liCurrent = 
                { timeCurrent.dwLowDateTime, timeCurrent.dwHighDateTime };
            LARGE_INTEGER liLastLog = 
                { m_timeLastLog.dwLowDateTime, m_timeLastLog.dwHighDateTime };
            LARGE_INTEGER liDifference;
            liDifference.QuadPart = liCurrent.QuadPart - liLastLog.QuadPart;

            return (liDifference.QuadPart > LOGEVENT_PERIOD);
        }

        void UpdateLogTime() {
            GetSystemTimeAsFileTime(&m_timeLastLog);
        }

    private:
        CEventLogHashKey m_key;
        FILETIME m_timeLastLog;
};

class CEventLogWrapper {
    public:
        CEventLogWrapper() {
            m_hEventLog = NULL;
        }

        //
        // Register your event source in the registry.
        //
        // Parameters:
        //   szEventSource - the name of the eventsource
        //   szMessageFile - the full path to the DLL which contains the 
        //                   eventlog strings
        //   fApplication - The eventsource is an application, not a system
        //     component
        //
        static
        HRESULT AddEventSourceToRegistry(char *szEventSource,
                                         char *szMessageFile,
                                         BOOL fApplication = FALSE);

        //
        // Unregister your event source in the registry.
        //
        // Parameters:
        //   szEventSource - the name of the eventsource
        //   fApplication - The eventsource is an application, not a system
        //     component
        //
        static
        HRESULT RemoveEventSourceFromRegistry(char *szEventSource, 
                                              BOOL fApplication = FALSE);

        //
        // Initialize the event logging library.  
        //
        // Parameters:
        //   szEventSource - the name of the eventsource
        //
        HRESULT Initialize(char *szEventSource);

        //
        // Write an event to the event log
        //
        // Parameters:
        //   idMessage - the eventlog ID
        //   cSubstrings - count of strings in rgszSubstrings
        //   rgszSubstrings - substrings for the eventlog text
        //   wType - eventlog error type.  Should be EVENTLOG_WARNING_TYPE,
        //     EVENTLOG_INFORMATION_TYPE or EVENTLOG_ERROR_TYPE.
        //   errCode - Win32 error code to log (or 0)
        //   iDebugLevel - debug level of the event.  1 = highest priority,
        //     2^16 = lowest priority.  normally anything above 2^15 isn't
        //     logged.
        //   szKey - a key which is used along with idMessage to uniquely
        //     identify this eventlog.  It is used to control the options.
        //   dwOptions - options for logging this event.
        // Optional Parameters:
        //   iMessageString - call FormatMessage on errCode and save
        //     the string into rgszSubstrings[iMessageString].
        //   HMODULE hModule - module with extra error codes for 
        //     FormatMessage.
        //
        HRESULT LogEvent(DWORD idMessage,
                         WORD cSubstrings,
                         LPCSTR *rgszSubstrings,
                         WORD wType,
                         DWORD errCode,
                         WORD iDebugLevel,
                         LPCSTR szKey,
                         DWORD dwOptions,
                         DWORD iMessageString = 0xffffffff,
                         HMODULE hModule = NULL);

        //
        // Reset any history about events using this message and key,
        // so that the next LogEvent with one-time or periodic logging
        // will cause the event to be logged.
        //
        // Parameters:
        //   idMessage - the eventlog ID
        //   szKey - a key which is used along with idMessage to uniquely
        //     identify this eventlog.  
        //
        HRESULT ResetEvent(DWORD idMessage,
                           LPCSTR szKey);

        ~CEventLogWrapper();
    private:
        // the handle returned from RegisterEventSource
        HANDLE m_hEventLog;

        // this hash table is used to remember which keys we have
        // used to support PERIODIC and ONETIME options
        TFHashEx<CEventLogHashItem, CEventLogHashKey *, CEventLogHashKey *> m_hash;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\flatfile.h ===
//
// flatfile.h -- This file contains the class definations for:
//  CFlatFile
//
// Created:
//   Sep 3, 1996 -- Alex Wetmore (awetmore)
// Changes:
//   May 7, 1998 -- Alex Wetmore (awetmore)
//      -- Modify for use in NNTP.  Remove sorting features, file handle
//         cache, etc.
//   Oct 23,1998 -- Kangrong Yan ( kangyan )
//      -- Added integrity flag
//

#ifndef __FLATFILE_H__
#define __FLATFILE_H__

#include <windows.h>
#include <stdio.h>
#include <writebuf.h>

//
// size of the read buffer used for GetFirstRecord/GetNextRecord()
//
#define FF_BUFFER_SIZE 8192

//
// maximum record size
//
#define MAX_RECORD_SIZE 4096

// do a automatic compaction if there are more then 10 deleted records and
// the ratio of records to deleted records is less then 10
#define FF_COMPACTION_MIN_DELETED_RECORDS 10
#define FF_COMPACTION_MIN_TOTAL_RECORDS 100
#define FF_COMPACTION_RATIO 10

//
// Integrity flag values
//
#define FF_FILE_GOOD    0x0000FFFF
#define FF_FILE_BAD     0x00010000

//
// file extensions for flat files
//
#define NEW_FF_EXT ".tmp"       // extension for new flatfile as its built
#define BAK_FF_EXT ".bak"       // extension for an old backup flatfile
#define FF_IDX_EXT ".idx"       // extension for an index file

#pragma pack(push, flatfile)
#pragma pack(1)

//
// the structure for the header of the file
//
typedef struct {
    DWORD   dwSignature;                    // file signature
	DWORD	dwFlags;						// file flags
} FLATFILE_HEADER;

#define FF_FLAG_COMPACT		0x01

#define FLATFILE_SIGNATURE (DWORD)'__fF'

//
// the record structure for the data file
//
// the size of it is RECORD_HEADER_SIZE + cData;
//
typedef struct {
    BOOL    fDeleted;                       // is this deleted?
    DWORD   cData;                          // length of the data
    BYTE    pData[MAX_RECORD_SIZE];         // data
} RECORD;

typedef struct {
    BOOL    fDeleted;                       // is this deleted?
    DWORD   cData;                          // length of the data
} RECORDHDR;

#define RECORD_HEADER_SIZE sizeof(RECORDHDR)

#pragma pack(pop, flatfile)

//
// A function of this type will be called whenever a record's offset 
// changes in the flatfile.  It is used to keep the owner up to date 
// on record offsets, so that the owner can make quick Delete's
//
typedef void (*PFN_OFFSET_UPDATE)(void *pContext, BYTE *pData, DWORD cData, DWORD iNewOffset);

class CFlatFile {
    public:

        friend class CFlatFileWriteBuf;
        
        CFlatFile(LPSTR szFilename, 
				  LPSTR szExtension, 
				  void *pContext,
				  PFN_OFFSET_UPDATE pfnOffsetUpdate,
				  DWORD dwSignature = FLATFILE_SIGNATURE,
				  BOOL fClear = FALSE, 
				  DWORD dwFileFlags = 0);
        ~CFlatFile();

		// insert a new record into the file
        HRESULT InsertRecord(LPBYTE pData, DWORD cData, DWORD *piOffset = NULL, DWORD dwVer = 0);

		// delete a record from the file
        HRESULT DeleteRecord(DWORD iOffset);

		// compact out any deleted records in the file
        HRESULT Compact();

		// get the first record in the file
        HRESULT GetFirstRecord(LPBYTE pData, 
							   DWORD *cData,
            				   DWORD *piByteOffset = NULL,
            				   DWORD *pdwVer = NULL );

		// get the next record in the file
        HRESULT GetNextRecord(LPBYTE pData, 
							  DWORD *cData,
            				  DWORD *piByteOffset = NULL,
            				  DWORD *pdwVer = NULL);

        // delete everything in the file
        void DeleteAll();

        // Dirty the integrity flag
        HRESULT DirtyIntegrityFlag();

        // Set the integrity flag
        HRESULT SetIntegrityFlag();

        // Is the file in good integrity ?
        BOOL  FileInGoodShape();

        // Enable the write buffer
        VOID EnableWriteBuffer( DWORD cbBuffer );

        // Check to see if the file has been opened
        BOOL IsFileOpened();

    private:
        //
        // open/close a file.  
        //
        // because this uses cached file handles, the position of the file
        // should not be assumed
        //
        HRESULT OpenFile(LPSTR szFilename = NULL,
                         DWORD dwOpenMode = OPEN_ALWAYS, 
						 DWORD dwFlags = 0);

		//
		// close the file handle
		//
		void CloseFile();

        //
        // set and get the file header
        //
        HRESULT SetFileHeader(FLATFILE_HEADER *pHeader);
        HRESULT GetFileHeader(FLATFILE_HEADER *pHeader);

        //
        // read the next chunk of the file into the temporary buffer
        // used by GetFirstRecord/GetNextRecord()
        //
        HRESULT ReadNextNBytes(LPBYTE pData, DWORD cData);
        HRESULT ReadNBytesFrom(LPBYTE pData, DWORD cData, DWORD iOffset, DWORD *pcDidRead = NULL);
        // iOffset can be set to infinite to append
        HRESULT WriteNBytesTo(LPBYTE pData, 
							  DWORD cData,
            				  DWORD *piOffset = NULL,
            				  DWORD iOffset = INFINITE,
            				  DWORD *pcDidWrite = NULL);
            				  
        HRESULT CFlatFile::WriteNBytesToInternal(
                                 LPBYTE pData,
								 DWORD cData,
								 DWORD *piOffset,
                              	 DWORD iOffset,
								 DWORD *pcDidWrite);

        HRESULT ReloadReadBuffer();

        //
		// the file handle for this file
        //
        HANDLE  m_hFile;

        //
        // flags for creating the file with
        //
        DWORD   m_dwFileFlags;

        //
        // filename for the flat file
        //
        char    m_szFilename[FILENAME_MAX];
        char    m_szBaseFilename[FILENAME_MAX];

        //
        // current read buffer
        //
        BYTE    m_pBuffer[FF_BUFFER_SIZE];

        //
        // current offset inside the buffer
        //
        DWORD   m_iBuffer;

        //
        // offset of the read buffer in the file
        //
        DWORD   m_iFile;

        //
        // size of the read buffer (zero means its not valid)
        //
        DWORD   m_cBuffer;

        //
        // clear the file on the next open
        //
        BOOL    m_fClearOnOpen;

        //
        // the number of deleted records in the file.  this is first 
		// computed by FindFirst/FindNext and then kept updated by
		// DeleteRecord and DeleteRecordAtOffset
        //
        DWORD   m_cDeletedRecords;

        //
        // the number of records in the file.  this is first 
		// computed by FindFirst/FindNext and then kept updated by
		// InsertRecord
        //
        DWORD   m_cRecords;

		//
		// context passed into callback functions
		//
		void *m_pContext;

		//
		// Whether the file is open
		//
		BOOL m_fOpen;

		//
		// The write buffer
		//
		CFlatFileWriteBuf m_wbBuffer;

		//
		// function to call when an items offset changes in the flatfile
		//
		PFN_OFFSET_UPDATE m_pfnOffsetUpdate;

		// 
		// signature for the file
		//
		DWORD m_dwSignature;
};

#define ret(__rc__) { /* TraceFunctLeave(); */ return(__rc__); }
#define retEC(__ec__, __rc__) { SetLastError(__ec__); /* TraceFunctLeave(); */ return(__rc__); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\domhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       domhash.h
//
//  Contents:   Definition and public include for domain lookup table.
//
//  History:    SethuR -- Implemented
//              MikeSwa - Modified for Domain Name lookup 2/98
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DOMAIN_NAME_TABLE_ENTRY,DOMAIN_NAME_TABLE_BUCKET and the
//              DOMAIN_NAME_TABLE.
//
//              The DOMAIN_NAME_TABLE is a hash table of DOMAIN_NAME_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DOMAIN_NAME_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//  2/98        The major difference between the DFS version and the domain
//              name lookup is the size of the table, the ability for
//              wildcard lookups (*.foo.com), and the reverse order of the
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick
//              mapping of the major files is (for those familiar with the
//              DFS code):
//                  domhash.h    (prefix.h)  -   Public include file
//                  _domhash.h   (prefixp.h) -   Private inlcude file
//                  domhash.cpp  (prefix.c)  -   Implementation of API
//                  _domhash.cpp (prefixp.c) -   Private helper functions.
//
//              Many functions defined an C macros have been converted to C++
//              style inline functions to make debugging easier.
//
//              The public API has moved to be public member functions of
//              the DOMAIN_NAME_TABLE *class*.
//--------------------------------------------------------------------------

#ifndef __DOMHASH_H__
#define __DOMHASH_H__

#include <windows.h>
//#include <ole2.h>
//#include <mapicode.h>
#include <stdio.h>
//#include <string.h>

// Transport specific headers - every component should use these
#include "transmem.h"
//#include "baseobj.h"
#include <dbgtrace.h>
//#include <rwnew.h>

#include <tchar.h>
#include <stdlib.h>

//Macro to ensure uniformity of domain strings
#define INIT_DOMAIN_STRING(str, cbDomain, szDomain) \
{ \
    _ASSERT(_tcslen(szDomain)*sizeof(TCHAR) == cbDomain); \
    str.Length = (USHORT) (cbDomain); \
    str.MaximumLength = str.Length; \
    str.Buffer = (szDomain); \
}

//Macro to init global or stack declared domain strings with
//constant string values
#define INIT_DOMAIN_STRING_AT_COMPILE(String) \
        { \
            (sizeof(String)-sizeof(TCHAR)), /*Length*/ \
            (sizeof(String)-sizeof(TCHAR)), /*Maximum*/ \
            String                          /*String buffer*/ \
        }

//Define internal HRESULTs
#define	DOMHASH_E_DOMAIN_EXISTS		HRESULT_FROM_WIN32(ERROR_DOMAIN_EXISTS)
#define DOMHASH_E_NO_SUCH_DOMAIN	HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN)

#define WILDCARD_SIG            'dliW'
#define ENTRY_SIG               'yrtN'
#define DOMAIN_NAME_TABLE_SIG   'hsHD'

#ifndef PAGE_SIZE
#define PAGE_SIZE 4000
#endif //PAGE_SIZE

//---[ UNICODE/ANSI Macros ]---------------------------------------------------
//
//
//  The domain hashing function depend on a string structure like UNICODE_STRING
//  or ANSI_STRING.  If UNICODE is defined, unicode strings and the
//  UNICODE_STRING structure will be used... otherwise ANSI_STRING will be used
//
//  However, because of the splintering of the NT Headers, I cannot always
//  include the files that have ANSI_STRING and UNICODE_STRING defined
//-----------------------------------------------------------------------------
typedef     TCHAR *         PTCHAR;
typedef     TCHAR *         PTSTR;

typedef     struct _DOMAIN_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PTCHAR Buffer;
} DOMAIN_STRING, *PDOMAIN_STRING;

//+---------------------------------------------------------------------
//
// Struct:  DOMAIN_NAME_TABLE_ENTRY
//
// History: 2/98 modifed from DFS_PREFIX_TABLE_ENTRY by MikeSwa
//
// Notes:   Each DOMAIN_NAME_TABLE_ENTRY is in reality a member of two linked
//          lists -- a doubly linked list chaining the entries in a bucket
//          and a singly linked list establishing the path from any entry to
//          the root of the name space. In addition we have the data associated
//          with each entry, viz., the name and the data (pData). We also
//          keep track of the number of children of each entry. It can also
//          be defined as the number of paths to the root of which this entry
//          is a member.
//
//----------------------------------------------------------------------

typedef struct _DOMAIN_NAME_TABLE_ENTRY_
{
   DWORD                            dwEntrySig;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pParentEntry;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pNextEntry;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pPrevEntry;

   //
   // pFirstChildEntry and pSiblingEntry are used purely for enumeration
   //
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pFirstChildEntry;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pSiblingEntry;

   ULONG                            NoOfChildren;

   DOMAIN_STRING                    PathSegment;
   PVOID                            pData;
   DWORD                            dwWildCardSig;
   PVOID                            pWildCardData;
} DOMAIN_NAME_TABLE_ENTRY, *PDOMAIN_NAME_TABLE_ENTRY;

//+---------------------------------------------------------------------
//
// Struct:  DOMAIN_NAME_TABLE_BUCKET
//
// History: 2/8 modified from DFS_PREFIX_TABLE_BUCKET
//
// Notes:   The DOMAIN_NAME_TABLE_BUCKET is a doubly linked list of
//          DOMAIN_NAME_TABLE_ENTRY's. The current implementation employs
//          the notion of a sentinel entry associated with each bucket. The
//          end pointers are never null but are always looped back to the
//          sentinel entry. The reason we employ such an organization is that
//          it considerably simplifies the list manipulation routines. The
//          reason this needs to be a doubly linked list is that we would like
//          to have the ability of deleting entries without having to traverse
//          the buckets from beginning.
//
//          The following inline methods ( macro defns. ) are provided for
//          inserting, deleting and looking up an entry in the bucket.
//
//----------------------------------------------------------------------

typedef struct _DOMAIN_NAME_TABLE_BUCKET_
{
   ULONG                    NoOfEntries;   // High water mark for entries hashing to the bkt.
   DOMAIN_NAME_TABLE_ENTRY  SentinelEntry;
} DOMAIN_NAME_TABLE_BUCKET, *PDOMAIN_NAME_TABLE_BUCKET;

//+---------------------------------------------------------------------
//
// Struct:  NAME_PAGE
//
// History:
//
// Notes:   The name segments associated with the various entries are all
//          stored together in a name page. This allows us to amortize the
//          memory allocation costs over a number of entries and also allows
//          us to speed up traversal ( for details see DOMAIN_NAME_TABLE
//          definition ).
//
//----------------------------------------------------------------------

#define FREESPACE_IN_NAME_PAGE ((PAGE_SIZE - sizeof(ULONG) - sizeof(PVOID)) / sizeof(TCHAR))

typedef struct _NAME_PAGE_
{
   struct _NAME_PAGE_  *pNextPage;
   LONG                cFreeSpace; // free space avilable in TCHAR's
   TCHAR               Names[FREESPACE_IN_NAME_PAGE];
} NAME_PAGE, *PNAME_PAGE;

typedef struct _NAME_PAGE_LIST_
{
   PNAME_PAGE  pFirstPage;
} NAME_PAGE_LIST, *PNAME_PAGE_LIST;

//+---------------------------------------------------------------------
//
// Struct:  DOMAIN_NAME_TABLE
//
// History: 2/98 modified from DFS_PREFIX_TABLE
//
// Notes:   The DOMAIN_NAME_TABLE is a hashed collection of DOMAIN_NAME_TABLE_ENTRY
//          organized in the form of buckets. In addition one other space
//          conserving measure is adopted. There is only one copy of each
//          name segment stored in the table. As an example consider the
//          two name foo.bar and bar.foo. We only store one copy of foo
//          and bar eventhough we accomdate both these paths. A beneficial
//          side effect of storing single copies is that our traversal of the
//          collision chain is considerably speeded up since once we have
//          located the pointer to the name, subsequent comparisons need merely
//          compare pointers as opposed to strings.
//
//----------------------------------------------------------------------

#define NO_OF_HASH_BUCKETS 997

//prototype of function passed to domain iterator
typedef VOID (* DOMAIN_ITR_FN) (
        IN PVOID pvContext,   //context passed to HrIterateOverSubDomains
        IN PVOID pvData,   //data entry to look at
        IN BOOL fWildcard,    //true if data is a wildcard entry
        OUT BOOL *pfContinue,   //TRUE if iterator should continue to the next entry
        OUT BOOL *pfDelete);  //TRUE if entry should be deleted

class DOMAIN_NAME_TABLE
{
private:
    DWORD               m_dwSignature;
    NAME_PAGE_LIST      NamePageList;
    //
    // NextEntry is used purely for enumeration
    //
    DOMAIN_NAME_TABLE_ENTRY  RootEntry;
    DOMAIN_NAME_TABLE_BUCKET Buckets[NO_OF_HASH_BUCKETS];
    HRESULT HrLookupDomainName(
                            IN  DOMAIN_STRING            *pPath,
                            OUT BOOL                     *pfExactMatch,
                            OUT PDOMAIN_NAME_TABLE_ENTRY *ppEntry);

    HRESULT HrPrivInsertDomainName(IN  PDOMAIN_STRING  pstrDomainName,
                                IN  DWORD dwDomainNameTableFlags,
                                IN  PVOID pvNewData,
                                OUT PVOID *ppvOldData);

    inline void LookupBucket(IN  PDOMAIN_NAME_TABLE_BUCKET pBucket,
                         IN  PDOMAIN_STRING  pName,
                         IN  PDOMAIN_NAME_TABLE_ENTRY pParentEntry,
                         OUT PDOMAIN_NAME_TABLE_ENTRY *ppEntry,
                         OUT BOOL  *pfNameFound);

    PDOMAIN_NAME_TABLE_ENTRY pNextTableEntry(
                         IN  PDOMAIN_NAME_TABLE_ENTRY pEntry,
                         IN  PDOMAIN_NAME_TABLE_ENTRY pRootEntry = NULL);

    void    DumpTableContents();
    void    RemoveTableEntry(IN PDOMAIN_NAME_TABLE_ENTRY pEntry);

    ULONG   m_cLookupAttempts;  //Total number of lookup attempts
    ULONG   m_cLookupSuccesses; //Number of those attempts that where successful
    ULONG   m_cLookupCollisions; //Number of lookups that had some sort of collision
    ULONG   m_cHashCollisions;  //Number of entries we had to check becuase another
                                //another string hashed to the same bucket.
                                //This can be decrease by a better hash or more buckets
    ULONG   m_cStringCollisions; //Number of entries we had to check becuase the
                                 //same string has different parents ("foo" in
                                 //"foo.com" and "foo.net"
    ULONG   m_cBucketsUsed;     //High water mark bucket usage count

    enum {
        DMT_INSERT_AS_WILDCARD = 0x00000001,
        DMT_REPLACE_EXISTRING  = 0x00000002,
    };
public:
    DOMAIN_NAME_TABLE();
    ~DOMAIN_NAME_TABLE();
    //NOTE: Init, Insert, and Remove require *external* exclusive lock,
    //find and next need a *external* read lock
    HRESULT HrInit();

    PVOID   pvNextDomainName(IN OUT PVOID *ppvContext); //NULL context restarts

    inline HRESULT HrInsertDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvData,
                                IN  BOOL  fTreatAsWildcard = FALSE,
                                OUT PVOID *ppvOldData = NULL);

    HRESULT HrRemoveDomainName( IN  PDOMAIN_STRING  pstrDomainName,
                                OUT PVOID *ppvData);
    HRESULT HrFindDomainName(   IN  PDOMAIN_STRING  pstrDomainName,
                                OUT PVOID *ppvData,
                                IN  BOOL  fExactMatch = TRUE);

    //Insert Domain Name and replaces old value if neccessary.  Returns old
    //data as well.
    inline HRESULT HrReplaceDomainName(IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvNewData, //New data to insert
                                IN  BOOL  fTreatAsWildcard,
                                OUT PVOID *ppvOldData); //Previous data

    HRESULT HrIterateOverSubDomains(
        IN DOMAIN_STRING *pstrDomain, //string to search for subdomains of
        IN DOMAIN_ITR_FN pfn, //mapping function (described below)
        IN PVOID pvContext);  //context ptr pass to mapping function

};

typedef DOMAIN_NAME_TABLE * PDOMAIN_NAME_TABLE;


//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrInsertDomainName
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//              [fTreatAsWildcard] -- TRUE if the domain is NOT a wildcard
//                      domain, but it should be treated as one (more efficient
//                      than reallocated a string to prepend "*.".
//
//              [ppvOldData] -- Old Data (if any) that was previously associated
//                      with this domain name.  If NULL, previous data will
//                      not be returned
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    05-11-98  MikeSwa Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrInsertDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvData,
                                IN  BOOL  fTreatAsWildcard,
                                OUT PVOID *ppvOldData)
{
    return (HrPrivInsertDomainName(pstrDomainName,
        (fTreatAsWildcard ? DMT_INSERT_AS_WILDCARD : 0), pvData, ppvOldData));
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrReplaceDomainName
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//              [fTreatAsWildcard] -- TRUE if the domain is NOT a wildcard
//                      domain, but it should be treated as one (more efficient
//                      than reallocated a string to prepend "*.".
//
//              [ppvOldData] -- Old Data (if any) that was previously associated
//                      with this domain name.  If NULL, previous data will
//                      not be returned
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    05-11-98  MikeSwa Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrReplaceDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvNewData,
                                IN  BOOL  fTreatAsWildcard,
                                OUT PVOID *ppvOldData)
{
    return (HrPrivInsertDomainName(pstrDomainName,
            (fTreatAsWildcard ? (DMT_INSERT_AS_WILDCARD | DMT_REPLACE_EXISTRING) :
                            DMT_REPLACE_EXISTRING),
            pvNewData, ppvOldData));
}


#endif // __DOMHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\listmacr.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    listmacr.h

Abstract:

    This module defines the macros that manipulates list
    structures defined in winnt.h.  Code is copied from the
    internal NT project.

Author:

    Johnson Apacible (JohnsonA)     30-Sept-1994

Revision History:

--*/

#ifndef _LISTMACR_
#define _LISTMACR_

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // ndef _LISTMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\nntptype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntptype.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _NNTPTYPE_
#define _NNTPTYPE_

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD FEED_TYPE;

#define FEED_TYPE_INVALID           0xffffffff

//
// Function types
//
typedef
BOOL
(*GET_DEFAULT_DOMAIN_NAME_FN)(PCHAR,DWORD);

//
// Type of feed we are managing
//

#define FEED_TYPE_PULL              0x00000000
#define FEED_TYPE_PUSH              0x00000001
#define FEED_TYPE_PASSIVE           0x00000002
#define FEED_ACTION_MASK            0x0000000f

//
// Type of server we are talking to
//

#define FEED_TYPE_PEER              0x00000000
#define FEED_TYPE_MASTER            0x00000010
#define FEED_TYPE_SLAVE             0x00000020
#define FEED_REMOTE_MASK            0x000000f0

//
// Should this go through a secure channel like SSL?
//

#define FEED_TYPE_SSL               0x00000100

//
// Valid bits
//

#define FEED_TYPE_MASK              (FEED_TYPE_PULL | FEED_TYPE_PUSH | \
                                    FEED_TYPE_PASSIVE | FEED_TYPE_PEER | \
                                    FEED_TYPE_MASTER | FEED_TYPE_SLAVE | \
                                    FEED_TYPE_SSL)


//
// Macros
//

#define FEED_IS_SSL( _x )           (((_x) & FEED_TYPE_SSL) != 0)
#define FEED_IS_SLAVE( _x )         (((_x) & FEED_TYPE_SLAVE) != 0)
#define FEED_IS_MASTER( _x )        (((_x) & FEED_TYPE_MASTER) != 0)
#define FEED_IS_PEER( _x )          (((_x) & 0x000000f0) == 0)
#define FEED_IS_PULL( _x )          (((_x) & 0x0000000f) == 0)
#define FEED_IS_PUSH( _x )          (((_x) & FEED_TYPE_PUSH) != 0)
#define FEED_IS_PASSIVE( _x )       (((_x) & FEED_TYPE_PASSIVE) != 0)

//
//  Simple types.
//

#define CHAR char                       // For consitency with other typedefs.

typedef DWORD APIERR;                   // An error code from a Win32 API.
typedef INT SOCKERR;                    // An error code from WinSock.

#ifdef __cplusplus
}
#endif

#endif _NNTPTYPE_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\gibtype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    gibtype.h

Abstract:

    This file contains information pertaining to any Gibraltar Service.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995
	Richard Kamicar	 (rkamicar)			20-Dec-1995
		-- changed from specific to each service to common.

--*/


#ifndef _GIBTYPE_
#define _GIBTYPE_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Simple types.
//

#define CHAR char                       // For consitency with other typedefs.

typedef DWORD APIERR;                   // An error code from a Win32 API.
typedef INT SOCKERR;                    // An error code from WinSock.

#ifdef _USE_NEW_INTERLOCKED
#define	INTERLOCKED_ADD(__pAddend__, __value__) \
		InterlockedExchangeAdd((LPLONG) (__pAddend__), (LONG) (__value__))

#define	INTERLOCKED_CMP_EXCH(__pDest__, __exch__, __cmp__, __ok__) \
		(__ok__) = InterlockedCompareExchange( \
				(PVOID *) (__pDest__), (PVOID) (__exch__), (PVOID) (__cmp__) \
				)

#define	INTERLOCKED_ADD_CHEAP(__pAddend__, __value__) \
		INTERLOCKED_ADD(__pAddend__, __value__)

#define	INTERLOCKED_CMP_EXCH_CHEAP(__pDest__, __exch__, __cmp__, __ok__) \
		INTERLOCKED_CMP_EXCH(__pDest__, __exch__, __cmp__, __ok__)

#else
#define	INTERLOCKED_ADD_CHEAP(__pAddend__, __value__) \
		*((LPLONG) (__pAddend__)) += (LONG) (__value__)

#define	INTERLOCKED_CMP_EXCH_CHEAP(__pDest__, __exch__, __cmp__, __ok__) \
		if (*(__pDest__) == (__cmp__)) { \
			*(__pDest__) = (__exch__); \
			(__ok__) = TRUE; \
		} else { \
			(__ok__) = FALSE; \
		} \

#define	INTERLOCKED_ADD(__pAddend__, __value__) \
		LockConfig(); \
		INTERLOCKED_ADD_CHEAP(__pAddend__, __value__); \
		UnLockConfig()

#define	INTERLOCKED_CMP_EXCH(__pDest__, __exch__, __cmp__, __ok__) \
		LockConfig(); \
		INTERLOCKED_CMP_EXCH_CHEAP(__pDest__, __exch__, __cmp__, __ok__) \
		UnLockConfig()
#endif

#define	INTERLOCKED_DEC(__pAddend__, __value__) \
		INTERLOCKED_ADD(__pAddend__, -((LONG)(__value__)))

#define	INTERLOCKED_BIGADD_CHEAP(__pAddend__, __value__) \
		{ \
			BOOL __ok__ = FALSE; \
			for (;!__ok__;) { \
				unsigned __int64 __old__ = *(__pAddend__); \
				unsigned __int64 __new__ = (__old__) + (__value__); \
				INTERLOCKED_CMP_EXCH_CHEAP(__pAddend__, __new__, __old__, __ok__); \
			} \
		}

#ifdef __cplusplus
}
#endif

#endif _GIBTYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\lockq.h ===
//
//	LOCKQ.H
//
//	This file contains classes which define a queue mechanism which will
//	safely synchronize additions and removals from the queue, where every
//	thread which appends to the Queue must be prepared to deal with owning the
//	queue.  Additionally, elements will come off the queue in the same order
//	that they are appended.
//
//	The structure of a thread using this stuff should be the following :
//
//	class	CUsefull : public CQElement { } ;
//	template	CLockQueue< CUsefull >	UsefullQ ;
//
//	
//		if( UsefullQ.Append( pUsefull ) ) {
//
//			while( UsefullQ.GetHead( &pUsefullWorkItem )  ) {
//				/* Do some usefull work. */
//
//				UsefullQ.Remove() ;
//			}
//		}
//
//	Implementation Schedule for all classes defined in this file :
//		1 day
//
//	Unit Test schedule for all classes defined in this file :
//		1 day
//		Unit Testing should consist of a multi theaded appli
//
//



#ifndef	_LOCKQ_H_
#define	_LOCKQ_H_

#include	"qbase.h"

#ifdef	DEBUG
#define	LOCKQ_DEBUG
#endif

#ifdef	_DEBUG
#ifndef	LOCKQ_DEBUG
#define	LOCKQ_DEBUG
#endif
#endif



//------------------------------------------------
class	CQueueLockV1	{
//
// This class implements a queue which is multi-threaded safe for append operations.
//	In addition, this queue will synchronize removal of elements amongst those
//	threads which are appending to the queue.  Each thread that appends to the
//	queue potentially becomes the owner of the removal lock of the queue.
//  (If Append() returns TRUE the thread owns the removal lock of the queue.)
//	There is no way to relinquish the removal lock except to empty the queue.
//	Emptying the queue must be done as a series of GetHead(), Remove() calls.
//	A GetHead() call MUST preceed each Remove() call.
//
//	Each time the thread calls GetHead, it will be
//	told whether it still owns the removallock (when the queue is emptied the lock is
//	relinquished.)
//	Owning the removal lock in no way interferes with other threads appending to the queue.
//
//	The class uses InterlockedExchange to handle all synchronization issues.
//
//	For appending - InterlockedExchange does the following :
//		Exchange the tail pointer with what we want to be the new tail.
//		Make the old tail that we got from the exchange point to the new element.
//		The list is now intact. Because there is an extra element in the queue
//		(m_special) the tail pointer never becomes NULL.
//
//	For synchronization safety -
//		InterlockedExchange is used on the element next pointers in order to
//		determine what thread has the removal lock.
//		Each call to GetHead Exchanges the head's next pointer with LOCKVAL.
//		Each Append call will also Exchange the old tail elements next value
//		with the new m_pTail value.  So there are only two threads which can
//		be exchanging the next pointer at any given instant.
//
//		The remove thread either gets 0 or a NON-NULL pointer after its Exchange.
//
//		If it gets Zero, it knows it Exchanged before the Appending thread,
//		in which case it loses the lock (since it can't safely do anything.)
//		If it gets a Non-Zero value, the other thread exchanged first.
//		In this case, the remover still has the lock and repairs the list.
//
//		In the case of the appending thread - after its Exchange it either gets
//		zero or LOCKVAL.
//
//		If the appending thread gets zero, it Exchanged first so the other thread
//		should hold onto the lock.   If the appending thread gets LOCKVAL then it
//		owns the lock.
//
//		Finally, note that there is ALWAYS AT LEAST ONE ELEMENT in the Queue (m_special).
//		This means that if there is anything of value in the queue at all then
//		there must be at least TWO elements in the queue (and m_pHead->p is non null).
//
//
//	Usage should be the following in each worker thread :
//		CQueueLockV1	*pQueue ;
//
//		if( pQueue->Append( p ) ) {
//			CQueueElement *pWork ;
//
//			while( pQueue->GetHead( pWork ) ) {
//				/* Do work on pWork It is safe to do further calls to pQueue->Append()
//					while doing whatever work.  That does not mean those Appended
//					elements will be processed on this thread. */
//
//				pQueue->Remove() ;
//			}
//		}
//
private :
	enum	CONSTANTS	{
		LOCKVAL	= -1,
	} ;

	CQElement	m_special ;	// element used ensure that the Queue always contains
							// something.
	CQElement	m_release ;	// element used with ReleaseLock calls to give up the
							//  RemovalLock on the Queue.

	//	This pointer is set after a call to ReleaseLock() - and
	//	will pointer to the queue element before the m_release element in
	//	the queue.
	CQElement	*m_pHead ;
	CQElement	*m_pTail ;

#ifdef	LOCKQ_DEBUG
	DWORD		m_dwOwningThread ;
	LONG		m_lock ;
#endif

	BOOL	OfferOwnership( CQElement* p ) ;
	CQElement*	GetFront( ) ;
public :
	CQueueLockV1( ) ;
	~CQueueLockV1( ) ;

	//
	//	Append - returns TRUE if we have added the first element into the queue
	//	and we now own the lock.
	//
	BOOL		Append( CQElement *p ) ;

	//
	// Remove - takes the head element off the list.  The head element should be
	//  examined with GetHead().  As long as we are calling GetHead() at least once
	//	before each call to Remove(), the synchronization aspects of the queue will
	//	work.
	//
	void		Remove( ) ;

	//
	//	GetHead - returns TRUE as long as there is an element to be had at the front
	//	 of the queue.  The element pointer is returned through the reference to a pointer.
	//
	BOOL		GetHead( CQElement *&p ) ;

	//
	// RemoveRelease - takes the head element off the list.
	//	Also offers the removal lock to any other thread out there.
	//	If the function returns TRUE then this thread still has the lock,
	//	otherwise another thread has it.
	//
	BOOL		RemoveAndRelease( ) ;

} ;


#ifndef _NO_TEMPLATES_
//--------------------------------------------------
template<	class	Element	>
class	TLockQueueV1	{
//
//	This template is designed for use with Elements derived from CQElement.
//	This will use the CQueueLockV1 class above to implement a locking queue containing
//	elements of type 'Element'.
//
private :
	CQueueLockV1		m_queue ;
public :
	inline	TLockQueueV1() ;
	inline	~TLockQueueV1() ;

	//	Add an element to the Queue - if this returns TRUE we own the lock.
	inline	BOOL		Append( Element* p ) ;

	// remove an element from the Queue - lock ownership does not change.
	inline	void		Remove( ) ;
	inline	BOOL		GetHead( Element *&p ) ;
	inline	BOOL		RemoveAndRelease( ) ;
} ;
#endif

#define	DECLARE_LOCKQ( Type )	\
class	LockQ ## Type	{	\
private :	\
	CQueueLockV1		m_queue ;	\
public :	\
	LockQ ## Type ()	{}	\
	~LockQ ## Type ()	{}	\
	BOOL	Append(	Type *	p )	{	return	m_queue.Append( (CQElement*)p ) ;	}	\
	void	Remove( )	{	m_queue.Remove() ;	}	\
	BOOL	GetHead(	Type	*&p	)	{	\
CQElement*	pTemp = 0;	\
BOOL	fTemp = m_queue.GetHead( pTemp ) ;	\
p = (Type*)pTemp ;	\
return	fTemp ;	\
}	\
	BOOL	RemoveAndRelease( )	{	\
return	m_queue.RemoveAndRelease() ;	\
}	\
} ;

#define	INVOKE_LOCKQ( Type )	LockQ ## Type


class	CQueueLock	{
//
// This class implements a queue which is multi-threaded safe for append operations.
//	In addition, this queue will synchronize removal of elements amongst those
//	threads which are appending to the queue.  Each thread that appends to the
//	queue potentially becomes the owner of the removal lock of the queue.
//  (If Append() returns TRUE the thread owns the removal lock of the queue.)
//	There is no way to relinquish the removal lock except to empty the queue.
//
//	Usage should be the following in each worker thread :
//		CQueueLock	*pQueue ;
//
//		if( pQueue->Append( p ) ) {
//			CQueueElement *pWork ;
//
//			while( (pWork = pQueue->RemoveAndRelease( )) ) {
//				/* Do work on pWork It is safe to do further calls to pQueue->Append()
//					while doing whatever work.  That does not mean those Appended
//					elements will be processed on this thread. */
//			}
//		}
//
private :

	//
	//	Class constants - LOCKVAL that special value marking the queue element
	//	which is ready to be grabbed !
	//
	enum	CONSTANTS	{
		LOCKVAL	= -1,
	} ;

	//
	//	Element which always remains in the list !
	//
	CQElement	m_special ;	

	//
	//	Head of the list
	//
	CQElement	*m_pHead ;

	//
	//	Tail of the list !
	//
	CQElement	*m_pTail ;

public :
	//
	//	Initialize the queue to an empty state -
	//	and also sets things up so that the first Append
	//	will own the lock !	
	//
	inline	CQueueLock( ) ;

	//
	//	Also initializes to an empty state, however
	//	allows caller to specify whether queue can be
	//	grabbed on the first Append !
	//
	inline	CQueueLock(	BOOL	fSet ) ;

#ifdef	LOCKQ_DEBUG
	//
	//	Check that the queue is emptied when it is destroyed !
	//
	inline	~CQueueLock( ) ;
#endif

	//
	//	Set the lock to the lockable state where the next
	//	call to Append() will acquire the lock !
	//	This function is not thread safe and should only
	//	be called when we are sure there is only one thread
	//	using the object !
	//
	inline	void		Reset() ;

	//
	//	Append - returns TRUE if we have added the first element into the queue
	//	and we now own the lock.
	//
	inline	BOOL		Append( CQElement *p ) ;

	//
	//	return the head of the Queue - if we return NULL then some other thread
	//	may own the lcok the queue implicitly implies !
	//
	inline	CQElement*	RemoveAndRelease( ) ;

	//
	//	return the head of the Queue - but don't let any other threads
	//	grab the queue !
	//
	inline	CQElement*	Remove( ) ;

} ;


template<	class	Element	>
class	TLockQueue	{
//
//	This template is designed for use with Elements derived from CQElement.
//	This will use the CQueueLock class above to implement a locking queue containing
//	elements of type 'Element'.
//
private :
	CQueueLock		m_queue ;

public :
	//
	//	Create an empty queue
	//
	inline	TLockQueue() ;

	//
	//	Create empty queue and specify whether the
	//	lock is initially available
	//
	inline	TLockQueue( BOOL	fSet ) ;

	//	
	//	Caller must already have lock and be only thread
	//	using object - make the lock available !
	//
	inline	void	Reset() ;
	
	//
	//	Add an element to the Queue - if this returns TRUE we own the lock.
	//
	inline	BOOL		Append( Element* p ) ;
	
	//
	// remove an element from the Queue - lock ownership does not change unless this
	//	returns NULL !
	//
	inline	Element*	RemoveAndRelease( ) ;

	//
	//	remove an element from the Queue - but don't relinquish lock !
	//
	inline	Element*	Remove() ;
} ;

#include	"lockq.inl"

#endif		// _LOCKQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\mailmsgprops.h ===
/*
        @doc MAILMSG PROPERTIES
        @module mailmsgprops.h | MailMsg Properties for SMTP and NNTP
*/

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mailmsgprops.h

Abstract:

    This module contains the definitions for the MailMsg 
    Object property ID's.


--*/

#ifndef __MAILMSGPROPS_H__
#define __MAILMSGPROPS_H__

/*=======================================================================*/
// These macros are used to define the tables of property ID's.


#define IMMPID_START_LIST(name,start,guid)    struct __declspec(uuid(guid)) tagIMMPID_##name##_STRUCT;\
                                            typedef enum tagIMMPID_##name##_ENUM {\
                                                IMMPID_##name##_BEFORE__ = (start)-1,
#define IMMPID_END_LIST(name)                    IMMPID_##name##_AFTER__\
                                            } IMMPID_##name##_ENUM;


/*=======================================================================*/


// These are the per-message properties.

IMMPID_START_LIST(MP,0x1000,"13384CF0-B3C4-11d1-AA92-00AA006BC80B")

    // @const IMMPID | IMMPID_MP_RECIPIENT_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_RECIPIENT_LIST,

    // @const IMMPID | IMMPID_MP_CONTENT_FILE_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_CONTENT_FILE_NAME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_SMTP | 
    //  ANSI String - SMTP Address of sender
    IMMPID_MP_SENDER_ADDRESS_SMTP,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X500 | 
    //  ANSI String - X500 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X500,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X400 | 
    //  String - X400 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X400,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN | 
    //  String - Legacy DN Address of sender
    IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN,

    // @const IMMPID | IMMPID_MP_DOMAIN_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_DOMAIN_LIST,

    // @const IMMPID | IMMPID_MP_PICKUP_FILE_NAME | 
    //  ANSI String - Filename of msg file in pickup directory
    IMMPID_MP_PICKUP_FILE_NAME,

    // @const IMMPID | IMMPID_MP_AUTHENTICATED_USER_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_AUTHENTICATED_USER_NAME,

    // @const IMMPID | IMMPID_MP_CONNECTION_IP_ADDRESS | 
    //  ANSI String - IP address of MTA or client that submitted this message
    IMMPID_MP_CONNECTION_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_HELO_DOMAIN | 
    //  ANSI String - Domain name used in HELO/EHLO when message was submitted
    IMMPID_MP_HELO_DOMAIN,

    // @const IMMPID | IMMPID_MP_EIGHTBIT_MIME_OPTION | 
    //  BOOL - TRUE if message body is 8-bit MIME
    IMMPID_MP_EIGHTBIT_MIME_OPTION,

    // @const IMMPID | IMMPID_MP_CHUNKING_OPTION | 
    //   *** OBSOLETE ***
    IMMPID_MP_CHUNKING_OPTION,

    // @const IMMPID | IMMPID_MP_BINARYMIME_OPTION | 
    //  BOOL - TRUE if message body is binary MIME
    IMMPID_MP_BINARYMIME_OPTION,

    // @const IMMPID | IMMPID_MP_REMOTE_AUTHENTICATION_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_AUTHENTICATION_TYPE,

    // @const IMMPID | IMMPID_MP_ERROR_CODE | 
    //   *** OBSOLETE ***
    IMMPID_MP_ERROR_CODE,

    // @const IMMPID | IMMPID_MP_DSN_ENVID_VALUE | 
    //  Value of RFC1891 ENVID of submitted message
    IMMPID_MP_DSN_ENVID_VALUE,

    // @const IMMPID | IMMPID_MP_DSN_RET_VALUE | 
    //  ANSI String of what follows ESMTP RET
    IMMPID_MP_DSN_RET_VALUE,                

    // @const IMMPID | IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE,    

    // @const IMMPID | IMMPID_MP_ARRIVAL_TIME | 
    //  FILETIME that message arrived in system
    IMMPID_MP_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MESSAGE_STATUS | 
    // MP_STATUS_* value describing status of message system 
    IMMPID_MP_MESSAGE_STATUS,

    // @const IMMPID | IMMPID_MP_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration
    IMMPID_MP_EXPIRE_DELAY,         

    // @const IMMPID | IMMPID_MP_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration
    IMMPID_MP_EXPIRE_NDR,           

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_DELAY,   

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_NDR,     

    // @const IMMPID | IMMPID_MP_ARRIVAL_FILETIME | 
    //  FILETIME when message was submitted to queue
    IMMPID_MP_ARRIVAL_FILETIME,     

    // @const IMMPID | IMMPID_MP_HR_CAT_STATUS | 
    //  HRESULT MsgCat status (ie CAT_W_SOME_UNDELIVERABLE_MSGS)
    IMMPID_MP_HR_CAT_STATUS,        

    // @const IMMPID | IMMPID_MP_MSG_GUID | 
    //  String GUID ID which is only used if you want need to be able to replace 
    //  this message with another newer version.  This property is only 
    //  effective when used for a small amount of mail on the server, and is
    //  best suited for versioned mail (like DS replication).
    IMMPID_MP_MSG_GUID,        

    // @const IMMPID | IMMPID_MP_SUPERSEDES_MSG_GUID | 
    //  String GUID ID which this message superscedes.  If a message with with a 
    //  IMMPID_MP_MSG_GUID equal to this property is still on the server, then
    //  that message will not be sent out.

    IMMPID_MP_SUPERSEDES_MSG_GUID,

    // @const IMMPID | IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input was scanned for <CRLF>.<CRLF> in the msg
    // body
    IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF,

    // @const IMMPID | IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input had any <CRLF>.<CRLF>
    //
    IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, 

    // @const IMMPID | IMMPID_MP_MSG_SIZE_HINT | 
    //  Provides an approximate size of the message content.  Does not convert
    //  message, or guarantee accuracy. For an accurate message size (but at 
    //  a higher performance cost) use IMailMsgProperties::GetContentSize.
    //
    IMMPID_MP_MSG_SIZE_HINT, 

    // @const IMMPID | IMMPID_MP_RFC822_MSG_ID | 
    //  String -- RFC 822 Message Id header.
    IMMPID_MP_RFC822_MSG_ID,

    // @const IMMPID | IMMPID_MP_RFC822_MSG_SUBJECT | 
    //  String -- RFC822 subject header
    IMMPID_MP_RFC822_MSG_SUBJECT,

    // @const IMMPID | IMMPID_MP_RFC822_FROM_ADDRESS | 
    //  String -- RFC822 from address
    IMMPID_MP_RFC822_FROM_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_TO_ADDRESS | 
    //  String -- RFC822 To address
    IMMPID_MP_RFC822_TO_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_CC_ADDRESS | 
    //  String -- RFC822 Cc address
    IMMPID_MP_RFC822_CC_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_BCC_ADDRESS | 
    //  String -- RFC822 Bcc address
    IMMPID_MP_RFC822_BCC_ADDRESS,

    // @const IMMPID | IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS | 
    //  String -- server IP Address
    IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_SERVER_NAME | 
    //  String -- server name
    IMMPID_MP_SERVER_NAME,

    // @const IMMPID | IMMPID_MP_SERVER_VERSION | 
    //  String -- server version
    IMMPID_MP_SERVER_VERSION,

    // @const IMMPID | IMMPID_MP_NUM_RECIPIENTS | 
    //  DWORD -- number of recipients
    IMMPID_MP_NUM_RECIPIENTS,


    // @const IMMPID | IMMPID_MP_X_PRIORITY | 
    //  DWORD -- the priority of message
    IMMPID_MP_X_PRIORITY,

    // @const IMMPID | IMMPID_MP_FROM_ADDRESS | 
    //  String -- From: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_FROM_ADDRESS,
    
    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS | 
    //  String -- Sender: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_SENDER_ADDRESS,

    // @const IMMPID | IMMPID_MP_DEFERRED_DELIVERY_FILETIME | 
    //  FILETIME -- Universal time to wait until before allowing
    //  message to be delivered.
    IMMPID_MP_DEFERRED_DELIVERY_FILETIME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_OTHER | 
    //  ANSI String - with the format "type:address"
    IMMPID_MP_SENDER_ADDRESS_OTHER,

    // @const IMMPID | IMMPID_MP_ORIGINAL_ARRIVAL_TIME | 
    //  FILETIME that message arrived in first exchange system
    IMMPID_MP_ORIGINAL_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MSG_CLASS | 
    //  The Message class of the mail, e.g. syste, replication, etc...
    IMMPID_MP_MSGCLASS,

    // @const IMMPID | IMMPID_MP_CONTENT_TYPE | 
    //  The content type of message.
    //  ANSI STRING.
    IMMPID_MP_CONTENT_TYPE,

    //@const IMMPID | IMMPID_MP_ENCRYPTION_TYPE |
    // DWORD - 0, no encryption
    //         1, signed only
    //         2, encrypted
    IMMPID_MP_ENCRYPTION_TYPE,

    //@const IMMPID | IMMPID_MP_CONNECTION_SERVER_PORT | 
    // DWORD - Port (if any) that this message was submitted on 
    IMMPID_MP_CONNECTION_SERVER_PORT,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_USER | 
    // ASCII STRING - Name of authenticated user
    IMMPID_MP_CLIENT_AUTH_USER,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_TYPE | 
    // ASCII STRING - Type of authentication used (AUTH keyword)
    IMMPID_MP_CLIENT_AUTH_TYPE,

    //@const IMMPID | IMMPID_MP_CRC_GLOBAL |
    // DWORD - Checksum for global properties (excluding the checksum properties!)
    IMMPID_MP_CRC_GLOBAL,

    //@const IMMPID | IMMPID_MP_CRC_RECIPS |
    // DWORD - Checksum for recipient properties
    IMMPID_MP_CRC_RECIPS,

    // @const IMMPID | IMMPID_MP_INBOUND_MAIL_FROM_AUTH | 
    //  ANSI String - Contents of the RFC2554 AUTH= string on a MAIL FROM on inbound messages
    IMMPID_MP_INBOUND_MAIL_FROM_AUTH,


    // Add new per-message properties above this line.
IMMPID_END_LIST(MP)


// Message classes
// @const DWORD | MP_MSGCLASS_SYSTEM
// for msgs of type -- system
#define MP_MSGCLASS_SYSTEM       1

// @const DWORD | MP_MSGCLASS_REPLICATION
// for msgs of type -- replication
#define MP_MSGCLASS_REPLICATION  2

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- delivery report
#define MP_MSGCLASS_DELIVERY_REPORT     3

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- non-delivery report
#define MP_MSGCLASS_NONDELIVERY_REPORT  4


// Message status property values defined:

// @const DWORD | MP_STATUS_SUCCESS | 
//  Initial status of message
#define MP_STATUS_SUCCESS                    0

// @const DWORD | MP_STATUS_RETRY | 
//  Status indicating retry.
#define MP_STATUS_RETRY                      1

// @const DWORD | MP_STATUS_ABORT_DELIVERY | 
//  Delivery of this message should be aborted and the message deleted.
#define MP_STATUS_ABORT_DELIVERY             2

// @const DWORD | MP_STATUS_BAD_MAIL | 
//  This message should be moved to badmail.
#define MP_STATUS_BAD_MAIL                   3

// @const DWORD | MP_STATUS_SUBMITTED | 
//  Message has been submitted for delivery.
#define MP_STATUS_SUBMITTED                  4

// @const DWORD | MP_STATUS_CATEGORIZED | 
//  Message has been categorized.
#define MP_STATUS_CATEGORIZED                5

// @const DWORD | MP_STATUS_ABANDON_DELIVERY | 
//  Delivery of this message should be abandoned until the service restarts
#define MP_STATUS_ABANDON_DELIVERY           6

//Per recipient flags for IMMPID_RP_RECIPIENT_FLAGS

// @const DWORD | RP_RECIP_FLAGS_RESERVED | 
//  You should not modify / use these bits
#define RP_RECIP_FLAGS_RESERVED     0x0000000F 

// @const DWORD | RP_DSN_NOTIFY_SUCCESS | 
//  Notify on success - set if RFC1891 NOTIFY=SUCCESS is used
#define RP_DSN_NOTIFY_SUCCESS       0x01000000 

// @const DWORD | RP_DSN_NOTIFY_FAILURE | 
//  Notify on failure - set if RFC1891 NOTIFY=FAILURE is used
#define RP_DSN_NOTIFY_FAILURE       0x02000000 

// @const DWORD | RP_DSN_NOTIFY_DELAY | 
//  Notify on delay - set if RFC1891 NOTIFY=DELAY is used
#define RP_DSN_NOTIFY_DELAY         0x04000000 

// @const DWORD | RP_DSN_NOTIFY_NEVER | 
//  Never notify - set if RFC1891 NOTIFY=NEVER is used
#define RP_DSN_NOTIFY_NEVER         0x08000000 

// @const DWORD | RP_DSN_NOTIFY_MASK | 
//  Mask of all notify parameters
#define RP_DSN_NOTIFY_MASK          0x0F000000

//The following flags can be used in searches, but should not be set directly

// @const DWORD | RP_HANDLED | 
//  Recipient has either been delivered or should not be delivered
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_HANDLED                  0x00000010 

// @const DWORD | RP_GENERAL_FAILURE | 
//  some form of hard failure happend
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_GENERAL_FAILURE          0x00000020 

// @const DWORD | RP_DSN_HANDLED | 
//  Final DSN has been sent (or no DSN needs to be sent)
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_DSN_HANDLED              0x00000040 

//The following constants define how a message can be RP_HANDLED

// @const DWORD | RP_DELIVERED | 
//  The recipient has been delivered successfully
#define RP_DELIVERED                0x00000110 

// @const DWORD | RP_DSN_SENT_NDR | 
//  NDR (FAILED DSN) for this recipient has been sent
#define RP_DSN_SENT_NDR             0x00000450 

// @const DWORD | RP_FAILED | 
//  Recipient has a hard failure
#define RP_FAILED                   0x00000830 

// @const DWORD | RP_UNRESOLVED | 
//  This recipient was not resolved by categorization
#define RP_UNRESOLVED               0x00001030 

// @const DWORD | RP_ENPANDED | 
//  ***OBSOLETE*** (replaced by RP_EXPANDED)
#define RP_ENPANDED                 0x00002010 

// @const DWORD | RP_EXPANDED | 
//  This recipient is an expanded DL
#define RP_EXPANDED                 0x00002010 

// @const DWORD | RP_DSN_SENT_DELAYED | 
//  At least one Delay DSN sent
#define RP_DSN_SENT_DELAYED         0x00004000 

// @const DWORD | RP_DSN_SENT_EXPANDED | 
//  Expanded DSN has been sent
#define RP_DSN_SENT_EXPANDED        0x00008040 

// @const DWORD | RP_DSN_SENT_RELAYED | 
//  Relayed DSN has been sent
#define RP_DSN_SENT_RELAYED         0x00010040 

// @const DWORD | RP_DSN_SENT_DELIVERED | 
//  Delivered DSN has been sent
#define RP_DSN_SENT_DELIVERED       0x00020040 


// @const DWORD | RP_REMOTE_MTA_NO_DSN | 
//  Remote MTA does not advertise DSN support (relay might be needed)
#define RP_REMOTE_MTA_NO_DSN        0x00080000 


// @const DWORD | RP_ERROR_CONTEXT_STORE | 
//  Error happened in store driver
#define RP_ERROR_CONTEXT_STORE      0x00100000 

// @const DWORD | RP_ERROR_CONTEXT_CAT | 
//  Error happened during categorization
#define RP_ERROR_CONTEXT_CAT        0x00200000 

// @const DWORD | RP_ERROR_CONTEXT_MTA | 
//  Error happened in a MTA (eg SMTP stack)
#define RP_ERROR_CONTEXT_MTA        0x00400000 


// @const DWORD | RP_VOLATILE_FLAGS_MASK | 
//  Flags that can be used for temp storage
#define RP_VOLATILE_FLAGS_MASK      0xF0000000 
                                               //while a component has access to recipients
                                               //Once control of recipients is passed, value
                                               //is un-defined.

// @const DWORD | RP_DSN_NOTIFY_INVALID | 
//  *** OBSOLETE ***
#define RP_DSN_NOTIFY_INVALID       0x00000000 

/*=======================================================================*/


// These are the per-recipient properties.

IMMPID_START_LIST(RP,0x2000,"79E82048-D320-11d1-9FF4-00C04FA37348")


    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_SUCCESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_SUCCESS,

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_INVALID | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_INVALID,    

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE,            

    // @const IMMPID | IMMPID_RP_ADDRESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS,                

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE_SMTP | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE_SMTP,    

    // @const IMMPID | IMMPID_RP_ERROR_CODE | 
    //   HRESULT status code
    IMMPID_RP_ERROR_CODE,            

    // @const IMMPID | IMMPID_RP_ERROR_STRING | 
    //   *** OBSOLETE ***
    IMMPID_RP_ERROR_STRING,            

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_VALUE | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_VALUE,        

    // @const IMMPID | IMMPID_RP_DSN_ORCPT_VALUE | 
    //   ANSI string - \<address type\>;\<address\>
    IMMPID_RP_DSN_ORCPT_VALUE,        

    // @const IMMPID | IMMPID_RP_ADDRESS_SMTP | 
    //   ANSI string - SMTP address
    IMMPID_RP_ADDRESS_SMTP,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X400 | 
    //   ANSI string - X.400 address
    IMMPID_RP_ADDRESS_X400,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X500 | 
    //   ANSI string - X.500 address
    IMMPID_RP_ADDRESS_X500,            

    // @const IMMPID | IMMPID_RP_LEGACY_EX_DN | 
    //   ANSI string - DN for Exchange 5.5 and prev
    IMMPID_RP_LEGACY_EX_DN,            

    // @const IMMPID | IMMPID_RP_RECIPIENT_FLAGS | 
    //   Per-recipient DSN/delivery flags. Flag constansts start with RP_.
    IMMPID_RP_RECIPIENT_FLAGS,      

    // @const IMMPID | IMMPID_RP_SMTP_STATUS_STRING | 
    //   ANSI string - SMTP status string... if defined
    IMMPID_RP_SMTP_STATUS_STRING,   
                                    // *must* start with 3-digit status code

    // @const IMMPID | IMMPID_RP_DSN_PRE_CAT_ADDRESS | 
    //   Original address as received by MTA in
    IMMPID_RP_DSN_PRE_CAT_ADDRESS,  
                                    // IMMPID_RP_DSN_ORCPT_VALUE format

    // @const IMMPID | IMMPID_RP_MDB_GUID | 
    //   Categorizer stamps the MDB guid
    IMMPID_RP_MDB_GUID,             
                                    // for this recipient here

    // @const IMMPID | IMMPID_RP_USER_GUID | 
    //   Categorizer stamps the
    IMMPID_RP_USER_GUID,            
                                    // objectGUID of the user object here
    // @const IMMPID | IMMPID_RP_DOMAIN | 
    //   Alternate SMTP domain for categorization
    IMMPID_RP_DOMAIN,            

    // @const IMMPID | IMMPID_RP_ADDRESS_OTHER | 
    //   ANSI string - other address type
    IMMPID_RP_ADDRESS_OTHER,            

    // @const IMMPID | IMMPID_RP_DISPLAY_NAME |
    //   Unicode string - recipient display name
    IMMPID_RP_DISPLAY_NAME,

    // Add new per-recipient properties above this line.
IMMPID_END_LIST(RP)


/*=======================================================================*/


// These are per-message volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(MPV,0x3000,"CBE69706-C9BD-11d1-9FF2-00C04FA37348")

    // @const IMMPID | IMMPID_MPV_STORE_DRIVER_HANDLE | 
    //  Store driver context for this message.
    IMMPID_MPV_STORE_DRIVER_HANDLE,

    // @const IMMPID | IMMPID_MPV_MESSAGE_CREATION_FLAGS | 
    //  Flags set at creation of mailmsg.
    IMMPID_MPV_MESSAGE_CREATION_FLAGS,

    // @const IMMPID | IMMPID_MPV_MESSAGE_OPEN_HANDLES | 
    // The number of handles (property and content) open for this message.
    //   0 means no handles open.
    //   1 means property or content open.
    //   2 means both property and content open.
    IMMPID_MPV_MESSAGE_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_HANDLES | 
    // The current total number of open message handles (of any type) 
    // on this server. 
    IMMPID_MPV_TOTAL_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES | 
    // The current total number of open property streams on this server. 
    IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES | 
    // The current total number of open content handles on this server. 
    IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES,

    // Add new per-message volatile properties above this line.
IMMPID_END_LIST(MPV)

// This is the structure for the IMMPID_MPV_STORE_DRIVER_HANDLE property.
typedef struct tagIMMP_MPV_STORE_DRIVER_HANDLE {
    GUID guidSignature;    // signature of the store driver whose handle this is
} IMMP_MPV_STORE_DRIVER_HANDLE;

// Define message object creation flags

// @const DWORD | MPV_INBOUND_CUTOFF_EXCEEDED | 
//  Mailmsg configured cutoff has been exceeded... if this is an external 
//  delivery attempt, we should indicate that we do not have sufficient 
//  resources to accept the mail.
#define MPV_INBOUND_CUTOFF_EXCEEDED            0x00000001

// @const DWORD | MPV_WRITE_CONTENT |
//  Indicates that the content of this message can be modified.
#define MPV_WRITE_CONTENT                      0x00000002

/*=======================================================================*/


// These are per-recipient volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(RPV,0x4000,"79E82049-D320-11d1-9FF4-00C04FA37348")

    // @const IMMPID | IMMPID_RPV_DONT_DELIVER | 
    //  IMMPID_RPV_DONT_DELIVER is a boolean.  If set to TRUE, mailmsg 
    //  ignores this recipient when doing WriteList() (the recipient will 
    //  not exist in the new list).

    IMMPID_RPV_DONT_DELIVER,

    // @const IMMPID | IMMPID_RPV_NO_NAME_COLLISIONS | 
    //  IMMPID_RPV_NO_NAME_COLLISIONS is a boolean.  If set to TRUE, mailmsg 
    //  does not detect duplicates with this recipient on future calls to 
    //  AddSecondary().

    IMMPID_RPV_NO_NAME_COLLISIONS,
    // Add new per-recipient volatile properties above this line.
IMMPID_END_LIST(RPV)


// These are defined for backwards-compatability.  They will be removed
// ASAP...

// @const DWORD | IMMPID_RP_DONT_DELIVER | 
//   *** OBSOLETE ***
#define IMMPID_RP_DONT_DELIVER            IMMPID_RPV_DONT_DELIVER

// @const DWORD | IMMPID_RP_NO_NAME_COLLISIONS | 
//   *** OBSOLETE ***
#define IMMPID_RP_NO_NAME_COLLISIONS    IMMPID_RPV_NO_NAME_COLLISIONS


/*=======================================================================*/

// These are the per-message properties for NNTP

IMMPID_START_LIST(NMP,0x6000,"7433a9aa-20e2-11d2-94d6-00c04fa379f1")

    // @const IMMPID | IMMPID_NMP_SECONDARY_GROUPS | 
    //  An array of pointers to INNTPPropertyBag objects for each of
    //  the newsgroups that the article is being posted into for the
    //  current driver.
    IMMPID_NMP_SECONDARY_GROUPS,        

    // @const IMMPID | IMMPID_NMP_SECONDARY_ARTNUM | 
    //  An array of article numbers for each of the newsgroups that
    //  the article is being posted into for the current driver.
    IMMPID_NMP_SECONDARY_ARTNUM,

    // @const IMMPID | IMMPID_NMP_PRIMARY_GROUP | 
    //  A pointer to the INNTPPropertyBag object which represents the
    //  primary group for the current driver.
    IMMPID_NMP_PRIMARY_GROUP,

    // @const IMMPID | IMMPID_NMP_PRIMARY_ARTID | 
    //  The primary article number for the primary group.
    IMMPID_NMP_PRIMARY_ARTID,

    // @const IMMPID | IMMPID_NMP_POST_TOKEN | 
    //   The HTOKEN representing the client context.
    IMMPID_NMP_POST_TOKEN,                

    // @const IMMPID | IMMPID_NMP_NEWSGROUP_LIST | 
    //   The string of newsgroups which this article is being stored in.
    IMMPID_NMP_NEWSGROUP_LIST,            

    // @const IMMPID | IMMPID_NMP_HEADERS | 
    //   A string containing the headers of the message.
    IMMPID_NMP_HEADERS,                    

    // @const IMMPID | IMMPID_NMP_NNTP_PROCESSING | 
    //   Flags which describe how the message should be processed.  The 
    //   possible values are: NMP_PROCESS_POST, NMP_PROCESS_CONTROL, 
    //   and NMP_PROCESS_MODERATOR.  
    IMMPID_NMP_NNTP_PROCESSING,            

    // @const IMMPID | IMMPID_NMP_NNTP_APPROVED_HEADER | 
    //   A string containing the Approved: header of the message  
    IMMPID_NMP_NNTP_APPROVED_HEADER,            

    // Add new per-message properties above this line.
IMMPID_END_LIST(NMP)

// flags for IMMPID_NMP_NNTP_PROCESSING

// @const DWORD | NMP_PROCESS_POST | 
//  Set this flag to allow the NNTP server to post this message.
#define NMP_PROCESS_POST            0x00000001

// @const DWORD | NMP_PROCESS_CONTROL | 
//  Set this flag to allow the NNTP server to process control headers in this
//  message.
#define NMP_PROCESS_CONTROL            0x00000002

// @const DWORD | NMP_PROCESS_MODERATOR | 
//  Set this flag to allow the NNTP server to run this message through the
//  default moderated posting path.
#define NMP_PROCESS_MODERATOR        0x00000004

/*=======================================================================*/


// This is the starting range for user-reserved properties

IMMPID_START_LIST(CPV,0x8000,"A2A76B2A-E52D-11d1-AA64-00C04FA35B82")

    // @const IMMPID | IMMPID_CP_START | 
    //  Start of range
    IMMPID_CP_START,
IMMPID_END_LIST(CPV)


/*=======================================================================*/

// This table collects the data about the properties so that range-
// checking can be performed.  If any new property ranges are
// defined, they must be added to this structure.


#define IMMPID_DECLARE_ENTRY(name)    {&_uuidof(tagIMMPID_##name##_STRUCT),\
                                     IMMPID_##name##_BEFORE__+1,\
                                     IMMPID_##name##_AFTER__-1}

extern const __declspec(selectany) struct tagIMMPID_GUIDLIST_ITEM {
                                       const GUID *pguid;
                                       DWORD dwStart;
                                       DWORD dwLast;
                                   } IMMPID_GUIDS[] = {IMMPID_DECLARE_ENTRY(MP),
                                                       IMMPID_DECLARE_ENTRY(RP),
                                                       IMMPID_DECLARE_ENTRY(MPV),
                                                       IMMPID_DECLARE_ENTRY(RPV),
                                                       {&GUID_NULL,0,0}};

#endif // _MAILMSGPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\lockq.inl ===
inline
CQueueLock::CQueueLock( ) : m_pHead( &m_special ), m_pTail( &m_special ) {

	//
	// This function initializes the queue to an empty state.
	// In the empty state the queue contains one element which
	// has a Next pointer of 'LOCKVAL'.
	// The next pointer is initialized to LOCKVAL so that the first
	// append to the Queue owns the removal lock.
	//
 	m_special.m_pNext = (CQElement*)((DWORD_PTR)LOCKVAL) ;
}

inline
CQueueLock::CQueueLock(	BOOL	fSet ) :
	m_pHead( &m_special ),
	m_pTail( &m_special )	{

	if( fSet ) {
		m_special.m_pNext = (CQElement*)((DWORD_PTR)LOCKVAL) ;
	}	else	{
		m_special.m_pNext = 0 ;
	}
}

#ifdef	LOCKQ_DEBUG

CQueueLock::~CQueueLock( ) {
//	_ASSERT( m_pHead == m_pTail ) ;
//	_ASSERT( m_pHead == &m_special ) ;
//	_ASSERT( m_dwOwningThread == 0 || m_dwOwningThread == GetCurrentThreadId() ) ;

}
#endif

inline void
CQueueLock::Reset(	)	{

	m_pTail->m_pNext = (CQElement*)((DWORD_PTR)LOCKVAL) ;

}



inline BOOL
CQueueLock::Append( CQElement*	pAppend ) {
	//
	// We must set the Next pointer to NULL so that the next
	//	we come to append the tail pointer is properly set up.
	//
//	_ASSERT( pAppend->m_pNext == 0 ) ;
	pAppend->m_pNext = 0 ;

	// Get the old tail pointer.  This guy won't be touched by the
	// remove thread if his next pointer is still NULL.
	CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (LPVOID *)&m_pTail, pAppend ) ;

	// After we set the old tail pointer's next pointer to NON NULL
	// he becomes fair game for whoever is removing from the queue.
	// We may become the thread removing from the queue if whoever was
	// previously removing got to the last element and changed its next pointer
	// to LOCKVAL.
	//
	// NOTE : This thread and any thread doing removals should be the only
	//	threads touching the pNext field of the pTemp element.
	//
	PVOID	l = InterlockedExchangePointer( (LPVOID *)&(pTemp->m_pNext), pAppend ) ;

	return	l == (PVOID)LOCKVAL ;
}

inline CQElement*
CQueueLock::RemoveAndRelease( void )	{


	CQElement*	p = (CQElement*)InterlockedCompareExchangePointer( (LPVOID*)&m_pHead->m_pNext,
												(LPVOID)LOCKVAL,
												0 ) ;

	_ASSERT( (DWORD_PTR)p != LOCKVAL ) ;

	if( p != 0 ) {

		//
		//	There is an element following the head element -
		//	so we can safely examine the head element has nobody
		//	will touch its next pointer but us !
		//

		CQElement*	pReturn = m_pHead ;
		m_pHead = p ;
		pReturn->m_pNext = 0 ;

		if( pReturn == &m_special ) {

			//
			//	We can ignore the return value of Append -
			//	it must always succeed as we are the only thread
			//	that is allowed to relinquish the lock, and we ain't going to
			//	do so !
			//
			Append( pReturn ) ;

			//
			//	Now, we must offer ownership again !
			//

			p = (CQElement*)InterlockedCompareExchangePointer( (LPVOID*)&m_pHead->m_pNext,
														(LPVOID)LOCKVAL,
														0 ) ;

			_ASSERT( (DWORD_PTR)p != LOCKVAL ) ;

			if( p != 0 ) {

				//
				//	The head element must not be the special element -
				//	we took pains already to see that that didn't happen -
				//	so we can safely remove the element from the head of the queue.
				//

				pReturn = m_pHead ;
				m_pHead = p ;
				pReturn->m_pNext = 0 ;
		
				return	pReturn ;
			}

		}	else	{

			return	pReturn ;

		}
	
	}

	//
	//	_ASSERT( p==0 ) ;
	//

	return	p ;
}

inline CQElement*
CQueueLock::Remove( void )	{


	CQElement*	p = m_pHead->m_pNext ;
	if( p != 0 ) {

		//
		//	There is an element following the head element -
		//	so we can safely examine the head element has nobody
		//	will touch its next pointer but us !
		//
		p = m_pHead ;

		if( p == &m_special ) {

			//
			//	The head element is the special element, so we want
			//	to send it to the back and try examining the front again !
			//

			m_pHead = p->m_pNext ;
			p->m_pNext = 0 ;

			//
			//	We can ignore the return value of Append -
			//	it must always succeed as we are the only thread
			//	that is allowed to relinquish the lock, and we ain't going to
			//	do so !
			//
			Append( p ) ;

			//
			//	Ok, lets see if we can remove the head element now !
			//

			p = m_pHead->m_pNext ;
		}
	
		//
		//	If this ain't 0, then the next pointer is set
		//	and no other threads will be touching the next pointer,
		//	so we can safely advance the head pointer and return
		//	the first element.
		//
		if( p != 0 ) {

			p = m_pHead ;
			//
			//	The head element must not be the special element -
			//	we took pains already to see that that didn't happen -
			//	so we can safely remove the element from the head of the queue.
			//
			m_pHead = p->m_pNext ;
			p->m_pNext = 0 ;
	
			return	p ;
		}
	}

	return	0 ;
}


template< class Element >
inline	TLockQueue< Element >::TLockQueue( ) { }

template< class	Element >
inline	TLockQueue< Element >::TLockQueue( BOOL fSet ) :
	m_queue( fSet ) { }

template< class Element >
inline	void	TLockQueue< Element >::Reset()	{
	m_queue.Reset() ;
}

template< class Element >
inline	BOOL	TLockQueue< Element >::Append( Element *p ) {
	return	m_queue.Append( (CQElement*)p ) ;
}

template< class Element >
inline	Element*	TLockQueue< Element >::Remove( ) {
	return	(Element*) m_queue.Remove( ) ;
}

template< class Element >
inline	Element*	TLockQueue< Element >::RemoveAndRelease( ) {
	return	(Element*) m_queue.RemoveAndRelease( ) ;
}



#ifndef _NO_TEMPLATES_

template< class Element >
inline	TLockQueueV1< Element >::TLockQueueV1( ) { }

template< class Element >
inline	TLockQueueV1< Element >::~TLockQueueV1( ) { }

template< class Element >
inline	BOOL	TLockQueueV1< Element >::Append( Element *p ) {
	return	m_queue.Append( (CQElement*)p ) ;
}

template< class Element >
inline	void	TLockQueueV1< Element >::Remove( ) {
	m_queue.Remove( ) ;
}

template< class Element >
inline	BOOL	TLockQueueV1< Element >::GetHead( Element* &p ) {
	CQElement	*pTemp = 0 ;
	BOOL	fTemp = m_queue.GetHead( pTemp ) ;
	p = (Element*)pTemp ;
	return	fTemp ;
}

template< class Element >
inline	BOOL	TLockQueueV1< Element >::RemoveAndRelease( ) {
	return	m_queue.RemoveAndRelease( ) ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\mapfile.h ===
/* -------------------------------------------------------------------------
  mapfile.h
      (was bbmpfile.h)
  	Definitions for the mapped file class.

  Copyright (C) 1995   Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:49 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on pvMapFile() and derivatives.

   ------------------------------------------------------------------------- */

/*
 *    Generic class to handle mapped files.  Part of the reason for
 *  turning this into a class is to allow tracking of mapping/unmapping
 *  and thus to handle clean up of dangling mappings in exception
 *  handling code.  Tracking is enabled if the fTrack parameter is
 *  specified.
 */

#ifndef _MAPFILE_H_
#define _MAPFILE_H_

//   Bits used in the m_fFlags field below.
#define	MF_TRACKING		0x0001			// Tracking use of this item.
#define	MF_RELINQUISH	0x0002			// Someone else to free this item.

class CCreateFile
{
public:
    virtual HANDLE CreateFileHandle( LPCSTR szFileName ) = 0;
};

class  CMapFile
{
public:
	CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease = 0, CCreateFile *pCreateFile = NULL);
	CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack );
	CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbSizeIncrease = 0 );
	CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0, BOOL fZero = FALSE );

	~CMapFile( void );

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

private:
	DWORD	 m_cb;			// Size of this file.
	void	*m_pv;			// Address to use.
	DWORD	 m_fFlags;		// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero = FALSE );
};


/*
 *    For compatability with old code, the original functions remain.
 */

void *pvMapFile( DWORD *pdwSize, const char  *pchFileName, BOOL bWriteEnable );
void *pvMapFile( DWORD *pdwSize, const WCHAR *pwchFileName, BOOL bWriteEnable );

void *pvMapFile(const char  *pchFileName, BOOL bWriteEnable,
		 DWORD  *pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

void * pvFromHandle( HANDLE hFile,	BOOL bWriteEnable,
		DWORD * pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

class  CMapFileEx
{
public:
	CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0 );
	~CMapFileEx( void );
	void Cleanup( void );		// cleanup in case of failure !

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return (void*)m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

	//	Protect and Unprotect mapping
	BOOL	ProtectMapping();
	BOOL	UnprotectMapping();

private:
	DWORD	 m_cb;								// Size of this file.
	LPBYTE	 m_pv;								// Address to use.
	DWORD	 m_fFlags;							// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	HANDLE	 m_hFile;							// handle to the mapped file
	LPBYTE	 m_pvFrontGuard;					// front guard page
	DWORD	 m_cbFrontGuardSize;				// front guard page size
	LPBYTE	 m_pvRearGuard;						// rear guard page
	DWORD	 m_cbRearGuardSize;					// rear guard page size
	CRITICAL_SECTION m_csProtectMap;			// crit sect to protect/unprotect mapping

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease );
};

#endif // DEBUG
#endif // _MAPFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\nntpapi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nntpapi.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _NNTPAPI_
#define _NNTPAPI_

#ifdef __cplusplus
extern "C" {
#endif

#include <inetcom.h>
#ifndef NET_API_FUNCTION
#define NET_API_FUNCTION _stdcall
#endif

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

//
// 0 - Perfmon stats
//

typedef struct _NNTP_STATISTICS_0 {

    //
    // total bytes sent/received, including protocol msgs
    //

    LARGE_INTEGER   TotalBytesSent;
    LARGE_INTEGER   TotalBytesReceived;

    //
    // incoming connections (includes all connections including hubs)
    //

    DWORD           TotalConnections;       // total connects from Nntp clients
    DWORD           TotalSSLConnections;
    DWORD           CurrentConnections;     // current number
    DWORD           MaxConnections;         // max simultaneous

    DWORD           CurrentAnonymousUsers;
    DWORD           CurrentNonAnonymousUsers;
    DWORD           TotalAnonymousUsers;
    DWORD           TotalNonAnonymousUsers;
    DWORD           MaxAnonymousUsers;
    DWORD           MaxNonAnonymousUsers;

    //
    // outgoing connections
    //

    DWORD           TotalOutboundConnects;      // total
    DWORD           OutboundConnectsFailed;
    DWORD           CurrentOutboundConnects;    // current
    DWORD           OutboundLogonFailed;        // failed logon

    //
    // common
    //

    DWORD           TotalPullFeeds;
    DWORD           TotalPushFeeds;
    DWORD           TotalPassiveFeeds;

    DWORD           ArticlesSent;           // articles sent by us
    DWORD           ArticlesReceived;       // articles received

    DWORD           ArticlesPosted;
    DWORD           ArticleMapEntries;
    DWORD           HistoryMapEntries;
    DWORD           XoverEntries;

    DWORD           ControlMessagesIn;          // number of control messages received
    DWORD           ControlMessagesFailed;      // number of control messages failed
    DWORD           ModeratedPostingsSent;      // number of moderated postings we attempt to send to an smtp server
    DWORD           ModeratedPostingsFailed;    // number of moderated postings we failed to send to an smtp server

    //
    // The number of sessions currently in a flow controlled state where
    // writes to disk are not keeping up with network reads.
    //

    DWORD           SessionsFlowControlled;

    //
    // The number of articles expired since the service was started
    //
    
    DWORD           ArticlesExpired;

    //
    // User command counters - one counter for each type of command
    //
    
    DWORD           ArticleCommands;
    DWORD           GroupCommands;
    DWORD           HelpCommands;
    DWORD           IHaveCommands;
    DWORD           LastCommands;
    DWORD           ListCommands;
    DWORD           NewgroupsCommands;
    DWORD           NewnewsCommands;
    DWORD           NextCommands;
    DWORD           PostCommands;
    DWORD           QuitCommands;
    DWORD           StatCommands;
    DWORD           LogonAttempts;          // validations
    DWORD           LogonFailures;          // validation failures
    DWORD			CheckCommands;
    DWORD			TakethisCommands;
    DWORD			ModeCommands;
    DWORD			SearchCommands;
    DWORD			XHdrCommands;
    DWORD			XOverCommands;
    DWORD			XPatCommands;
    DWORD			XReplicCommands;

    DWORD           TimeOfLastClear;        // statistics last cleared

} NNTP_STATISTICS_0, *LPNNTP_STATISTICS_0;

typedef struct _NNTP_STATISTICS_BLOCK {
    DWORD               dwInstance;
    NNTP_STATISTICS_0   Stats_0;
} NNTP_STATISTICS_BLOCK, *LPNNTP_STATISTICS_BLOCK;

typedef struct _NNTP_STATISTICS_BLOCK_ARRAY {
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is(cEntries)]
#endif
    NNTP_STATISTICS_BLOCK   aStatsBlock[];
} NNTP_STATISTICS_BLOCK_ARRAY, *LPNNTP_STATISTICS_BLOCK_ARRAY;

//
// Information about the server
//

typedef struct _NNTP_CONFIG_INFO {

    //
    // Arcane Gibraltar field
    //

    FIELD_CONTROL FieldControl;

#if 0

    // !!!newfields
    // Notes:

    // None of the old fields really need to be here.  The ui doesn't
    // use them.

    // _INET_INFO_CONFIG_INFO must be fully supported by the nntpsvc.
    // The apis are defined in inetinfo.h

    // The virtual root structure must be extended to support retention
    // policy on directories.  Retention policy is by posted date (days) or
    // by newsgroup size (megabytes).

    //
    // The new fields:
    //

    //
    // Connection Information
    //

    BOOL            AllowClientConnections;     // Allow clients to connect?
    BOOL            AllowServerFeeds;           // Allow servers to connect?
    DWORD           MaximumFeedConnections;     // Max Number of server feeds

    //
    // Organization & Path ID
    //

    LPWSTR          Organization;
    LPWSTR          PathID;

#endif

    //  Following 2 fields controlled by FC_NNTP_POSTINGMODES
    
    //
    //  If TRUE then clients are allowed to post
    //
    BOOL            AllowClientPosting ;

    //
    //  If TRUE then we accept articles from feeds !
    //
    BOOL            AllowFeedPosting ;

    //  Following field controlled by FC_NNTP_ORGANIZATION

    //
    //  For the organization header in postings !
    //
    LPSTR           Organization ;

    //  Following 2 fields controlled by FC_NNTP_POSTLIMITS

    //
    //  Number of bytes a user can post into a file before we break the socket !
    //
    DWORD           ServerPostHardLimit ;       

    //
    //  Maximum posting sizes the server will accept - if the user exceeds this 
    //  (without exceeding the hard limit) we will reject the post.
    //
    DWORD           ServerPostSoftLimit ;

    //
    //  Maximum size of articles from a feed - hard and soft limits
    //
    DWORD           ServerFeedHardLimit ;
    DWORD           ServerFeedSoftLimit ;

    //
    // Encryption Capabilities flags
    //

    DWORD           dwEncCaps;

    //
    // SMTP address for moderated postings
    //

    LPWSTR          SmtpServerAddress;

    //
    // server's UUCP name
    //

    LPWSTR          UucpServerName;

    //
    // Control Messages allowed ?
    //

    BOOL            AllowControlMessages;

    //
    // Default moderator for moderated postings
    //

    LPWSTR          DefaultModerator;

} NNTP_CONFIG_INFO, * LPNNTP_CONFIG_INFO;

#define FC_NNTP_POSTINGMODES        	((FIELD_CONTROL)BitFlag(0))
#define FC_NNTP_ORGANIZATION        	((FIELD_CONTROL)BitFlag(1))
#define FC_NNTP_POSTLIMITS          	((FIELD_CONTROL)BitFlag(2))
#define FC_NNTP_FEEDLIMITS          	((FIELD_CONTROL)BitFlag(3))
#define FC_NNTP_ENCRYPTCAPS         	((FIELD_CONTROL)BitFlag(4))
#define FC_NNTP_SMTPADDRESS         	((FIELD_CONTROL)BitFlag(5))
#define FC_NNTP_UUCPNAME            	((FIELD_CONTROL)BitFlag(6))
#define FC_NNTP_CONTROLSMSGS        	((FIELD_CONTROL)BitFlag(7))
#define FC_NNTP_DEFAULTMODERATOR		((FIELD_CONTROL)BitFlag(8))
#define FC_NNTP_AUTHORIZATION			((FIELD_CONTROL)BitFlag(9))
#define FC_NNTP_DISABLE_NEWNEWS     	((FIELD_CONTROL)BitFlag(10))
#define FC_MD_SERVER_SS_AUTH_MAPPING  	((FIELD_CONTROL)BitFlag(11))
#define FC_NNTP_CLEARTEXT_AUTH_PROVIDER ((FIELD_CONTROL)BitFlag(12))
#define FC_NTAUTHENTICATION_PROVIDERS  	((FIELD_CONTROL)BitFlag(13))
#define FC_NNTP_ALL                 (                             \
                                      FC_NNTP_POSTINGMODES			| \
                                      FC_NNTP_ORGANIZATION			| \
                                      FC_NNTP_POSTLIMITS			| \
                                      FC_NNTP_FEEDLIMITS        	| \
                                      FC_NNTP_ENCRYPTCAPS       	| \
                                      FC_NNTP_SMTPADDRESS       	| \
                                      FC_NNTP_UUCPNAME				| \
                                      FC_NNTP_CONTROLSMSGS      	| \
                                      FC_NNTP_DEFAULTMODERATOR  	| \
                                      FC_NNTP_AUTHORIZATION     	| \
                                      FC_NNTP_DISABLE_NEWNEWS   	| \
                                      FC_MD_SERVER_SS_AUTH_MAPPING  | \
                                      FC_NNTP_CLEARTEXT_AUTH_PROVIDER	| \
                                      FC_NTAUTHENTICATION_PROVIDERS | \
                                      0 )

//
// Feed Server information
//

typedef struct _NNTP_FEED_INFO {

    LPWSTR          ServerName;         // feed server
    FEED_TYPE       FeedType;

    //
    // date/time specified when doing a NEWNEWS/NEWGROUP
    //

    FILETIME        PullRequestTime;

    //
    // Date/Time scheduling is to start
    //

    FILETIME        StartTime;

    //
    // Time the next feed is scheduled
    //

    FILETIME        NextActiveTime;

    //
    // Interval in minutes between feeds.  If 0, a one time feed
    // specified by StartTime
    //

    DWORD           FeedInterval;

    //
    // Unique number assigned to this feed
    //

    DWORD           FeedId;

    //
    // Create automatically?
    //

    BOOL            AutoCreate;

    //
    //  Disable the feed ?
    //
    BOOL            Enabled ;

    DWORD           cbNewsgroups;
    LPWSTR          Newsgroups;
    DWORD           cbDistribution;
    LPWSTR          Distribution;
    DWORD           cbUucpName ;
    LPWSTR          UucpName ;
    DWORD           cbFeedTempDirectory ;
    LPWSTR          FeedTempDirectory ;

    //
    //  For outgoing feeds - maximum number of connect attempts
    //  before we disable the feed !
    //
    DWORD           MaxConnectAttempts ;

    //
    //  For outgoing feeds - the number of concurrent sessions 
    //  to start.
    //
    DWORD           ConcurrentSessions ;

    //
    //  Feed session security - do we use a protocol like SSL 
    //  or PCT to encrypt the session !
    //
    
    DWORD           SessionSecurityType ;

    //
    //  Feed Nntp security - do we do some variotion of a logon 
    //  protocol !!
    //
    
    DWORD           AuthenticationSecurityType ;
    
    DWORD           cbAccountName ;
    LPWSTR          NntpAccountName ;
    DWORD           cbPassword ;
    LPWSTR          NntpPassword ;

    //
    //  Allow control messages on this feed ?
    //
    BOOL            fAllowControlMessages;

	//
	//	Port to use for outgoing feeds
	//
	DWORD			OutgoingPort;

	//
	//	Associated feed pair id
	//
	DWORD			FeedPairId;

} NNTP_FEED_INFO, *LPNNTP_FEED_INFO;


#define AUTH_PROTOCOL_NONE  0   
#define AUTH_PROTOCOL_MSN   1       // Sicily
#define AUTH_PROTOCOL_NTLM  2       // NTLM
#define AUTH_PROTOCOL_CLEAR 10      // clear text authinfo user/authinfo pass

#define SESSION_PROTOCOL_SSL    3
#define SESSION_PROTOCOL_PCT    4


//
// Flags for feed admin handshake
//
#define FEED_UPDATE_CONFIRM     0x00000000
#define FEED_UPDATING           0x00000001
#define FEED_UPDATE_COMPLETE    0x00000002

//
// Parameter mask. Used to indicate where the error was during a set.
//

#define FEED_PARM_FEEDTYPE          0x00000001
#define FEED_PARM_STARTTIME         0x00000002
#define FEED_PARM_FEEDID            0x00000004
#define FEED_PARM_FEEDINTERVAL      0x00000008
#define FEED_PARM_NEWSGROUPS        0x00000010
#define FEED_PARM_DISTRIBUTION      0x00000020
#define FEED_PARM_SERVERNAME        0x00000040
#define FEED_PARM_AUTOCREATE        0x00000080
#define FEED_PARM_ENABLED           0x00000100
#define FEED_PARM_UUCPNAME          0x00000200
#define FEED_PARM_TEMPDIR           0x00000400
#define FEED_PARM_MAXCONNECT        0x00000800
#define FEED_PARM_SESSIONSECURITY   0x00001000
#define FEED_PARM_AUTHTYPE          0x00002000
#define FEED_PARM_ACCOUNTNAME       0x00004000
#define FEED_PARM_PASSWORD          0x00008000
#define FEED_PARM_CONCURRENTSESSION 0x00010000
#define FEED_PARM_ALLOW_CONTROL     0x00020000
#define FEED_PARM_OUTGOING_PORT     0x00040000
#define FEED_PARM_FEEDPAIR_ID		0x00080000
#define FEED_PARM_PULLREQUESTTIME   0x00100000

#define FEED_ALL_PARAMS             0xffffffff

//
// Indicates whether this field is to be changed
//

#define FEED_FEEDTYPE_NOCHANGE      0xffffffff
#define FEED_AUTOCREATE_NOCHANGE    0xffffffff
#define FEED_STARTTIME_NOCHANGE     0xffffffff
#define FEED_PULLTIME_NOCHANGE      0xffffffff
#define FEED_FEEDINTERVAL_NOCHANGE  0xffffffff
#define	FEED_MAXCONNECTS_NOCHANGE	0xffffffff
#define FEED_STRINGS_NOCHANGE       NULL

//
// Sessions
//
#define MAX_USER_NAME_LENGTH        64

typedef struct _NNTP_SESSION_INFO {

    FILETIME        SessionStartTime;
    DWORD           IPAddress;          // ipaddress
    DWORD           AuthenticationType; // type of authentication
    DWORD           PortConnected;      // port connected to
    BOOL            fAnonymous;         // using anonymous?
    CHAR            UserName[MAX_USER_NAME_LENGTH+1]; // logged on user

} NNTP_SESSION_INFO, *LPNNTP_SESSION_INFO;




typedef struct  _NNTP_EXPIRE_INFO   {
    //
    //  Expiration policies are numbered
    //
    DWORD       ExpireId ;

    //
    //  Units of Megabytes
    //
    DWORD       ExpireSizeHorizon ;

    //
    //  In retail builds - units of hours, debug builds - units of ??
    //
    DWORD       ExpireTime ;

    //
    //  MULTISZ expiration pattern and size !
    //

    DWORD       cbNewsgroups ;
    PUCHAR      Newsgroups;

	//
	//	Name of expire policy
	//

	LPWSTR		ExpirePolicy ;

} NNTP_EXPIRE_INFO, *LPNNTP_EXPIRE_INFO ;


typedef struct  _NNTP_NEWSGROUP_INFO    {

    DWORD       cbNewsgroup ;

    PUCHAR      Newsgroup ;

    DWORD       cbDescription ;

    PUCHAR      Description ;

    DWORD       cbModerator ;

    PUCHAR      Moderator ;

	BOOL		fIsModerated ;
	
    BOOL        ReadOnly ;

    DWORD       cbPrettyname ;

    PUCHAR      Prettyname ;

	FILETIME	ftCreationDate;

}   NNTP_NEWSGROUP_INFO,    *LPNNTP_NEWSGROUP_INFO ;

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

//
// Find RPC structs
//

typedef struct _NNTP_FIND_ENTRY
{
    LPWSTR      lpszName;
} NNTP_FIND_ENTRY, *LPNNTP_FIND_ENTRY;


typedef struct _NNTP_FIND_LIST
{
    DWORD       cEntries;
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    NNTP_FIND_ENTRY aFindEntry[];
} NNTP_FIND_LIST, *LPNNTP_FIND_LIST;


//
// Retention policy flags
//

#define NEWS_EXPIRE_BOTH                0x30000000
#define NEWS_EXPIRE_TIME                0x10000000
#define NEWS_EXPIRE_SIZE                0x20000000
#define NEWS_EXPIRE_OLDEST              0x00000001
#define NEWS_EXPIRE_BIGGEST             0x00000002
#define NEWS_EXPIRE_SIZE_OLDEST         (NEWS_EXPIRE_SIZE | NEWS_EXPIRE_OLDEST)
#define NEWS_EXPIRE_SIZE_BIGGEST        (NEWS_EXPIRE_SIZE | NEWS_EXPIRE_BIGGEST)
#define NEWS_EXPIRE_BOTH_OLDEST         (NEWS_EXPIRE_BOTH | NEWS_EXPIRE_OLDEST)
#define NEWS_EXPIRE_BOTH_BIGGEST        (NEWS_EXPIRE_BOTH | NEWS_EXPIRE_BIGGEST)

//
// Get Server Statistics
//

NET_API_STATUS
NET_API_FUNCTION
NntpQueryStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  Level,
    OUT LPBYTE * Buffer
    );

//
// Clear server statistics
//

NET_API_STATUS
NET_API_FUNCTION
NntpClearStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId
    );

//
// Statistics clear flags
//

#define NNTP_STAT_CLEAR_OUTGOING         0x00000001
#define NNTP_STAT_CLEAR_INGOING          0x00000002


//
// Getting and setting server Information
//
//

NET_API_STATUS
NET_API_FUNCTION
NntpGetAdminInformation(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPNNTP_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
NntpSetAdminInformation(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_CONFIG_INFO pConfig,
    OUT LPDWORD pParmError OPTIONAL
    );


//
// Sessions
//

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateSessions(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_SESSION_INFO *Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
NntpTerminateSession(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPSTR UserName OPTIONAL,
    IN LPSTR IPAddress OPTIONAL
    );

//
// Feeds
//

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateFeeds(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_FEED_INFO *FeedInfo
    );

NET_API_STATUS
NET_API_FUNCTION
NntpGetFeedInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN DWORD FeedId,
    OUT LPNNTP_FEED_INFO *FeedInfo
    );

NET_API_STATUS
NET_API_FUNCTION
NntpSetFeedInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NntpAddFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL,
	OUT LPDWORD pdwFeedId
    );

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN DWORD FeedId
    );

NET_API_STATUS
NET_API_FUNCTION
NntpEnableFeed(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  DWORD           FeedId,
    IN  BOOL            Enable,
    IN  BOOL            Refill,
    IN  FILETIME        RefillTime 
    ) ;


NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateExpires(
    IN  LPWSTR      ServerName,
    IN	DWORD		InstanceId,
    OUT LPDWORD         EntriesRead,
    OUT LPNNTP_EXPIRE_INFO* Buffer 
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpAddExpire(
    IN  LPWSTR              ServerName,
    IN	DWORD				InstanceId,
    IN  LPNNTP_EXPIRE_INFO  ExpireInfo,
    OUT LPDWORD             ParmErr OPTIONAL,
	OUT LPDWORD				pdwExpireId
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteExpire(
    IN  LPWSTR              ServerName,
    IN	DWORD				InstanceId,
    IN  DWORD               ExpireId 
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpGetExpireInformation(
    IN  LPWSTR              ServerName,
    IN	DWORD				InstanceId,
    IN  DWORD               ExpireId,
    OUT LPNNTP_EXPIRE_INFO  *Buffer
    ) ;


NET_API_STATUS
NET_API_FUNCTION
NntpSetExpireInformation(
    IN  LPWSTR              ServerName  OPTIONAL,
    IN	DWORD				InstanceId,
    IN  LPNNTP_EXPIRE_INFO  ExpireInfo,
    OUT LPDWORD             ParmErr OPTIONAL
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpGetNewsgroup(
    IN  LPWSTR              ServerName  OPTIONAL,
    IN	DWORD				InstanceId,
    IN OUT  LPNNTP_NEWSGROUP_INFO   *NewgroupInfo
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpSetNewsgroup(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  LPNNTP_NEWSGROUP_INFO   NewgroupInfo
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpCreateNewsgroup(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  LPNNTP_NEWSGROUP_INFO   NewsgroupInfo
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteNewsgroup(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  LPNNTP_NEWSGROUP_INFO   NewsgroupInfo
    ) ;

//
//  Find RPCs
//
NET_API_STATUS
NET_API_FUNCTION
NntpFindNewsgroup(
    IN   LPWSTR                 ServerName,
    IN	 DWORD					InstanceId,
    IN   LPWSTR                 NewsgroupPrefix,
    IN   DWORD                  MaxResults,
    OUT  LPDWORD                pdwResultsFound,
    OUT  LPNNTP_FIND_LIST       *ppFindList
    ) ;

#define NNTPBLD_DEGREE_THOROUGH			0x00000000
#define NNTPBLD_DEGREE_STANDARD			0x00000001
#define NNTPBLD_DEGREE_MEDIUM			0x00000010

//
//	Nntpbld structs and RPCs
//

typedef struct _NNTPBLD_INFO	{

	//
	//	Verbosity of reporting
	//
	BOOL	Verbose ;

	//
	//	Specify whether to blow away all old data structures 
	//
	BOOL	DoClean ;

	//
	//	If TRUE then don't delete the history file regardless of other settings.
	//
	BOOL	NoHistoryDelete ;

	//
	//	0x00000000 for thorough ie delete all index files
	//	0x00000001 for standard ie reuse all index files
	//	0x00000101 for standard with skip corrupt group enabled
	//  0x00000010 for medium   ie validate index files
	//
	DWORD	ReuseIndexFiles ;

	//
	//	If TRUE, omit non-leaf dirs
	//
	BOOL	OmitNonleafDirs ;

	//
	//	Name of a file containing either an INN style 'Active' file or 
	//	a tool generated newsgroup list file.  Either way, we will pull
	//	newsgroups out of this file and use them to build a news tree.	
	//
	DWORD	cbGroupFile ;
	LPWSTR	szGroupFile ;

	//
	//	Name of report file
	//
	DWORD	cbReportFile ;
	LPWSTR	szReportFile ;

	//
	//	If TRUE then szGroupFile specifies an INN style Active file,
	//	otherwise it specifies a tool generated human edit newsgroup list.
	//
	BOOL IsActiveFile ;	

	//
	//	Number of rebuild threads
	//

	DWORD NumThreads;

} NNTPBLD_INFO, *LPNNTPBLD_INFO ;

//
// Nntpbld RPCs
//
//

NET_API_STATUS
NET_API_FUNCTION
NntpStartRebuild(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTPBLD_INFO pBuildInfo,
    OUT LPDWORD pParmError OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NntpGetBuildStatus(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  BOOL	fCancel,
    OUT LPDWORD pdwProgress
    );

//
// Nntp vroot PRCs
//

NET_API_STATUS
NET_API_FUNCTION
NntpGetVRootWin32Error(
    IN LPWSTR wszServer,
    IN DWORD dwInstanceId,
    IN LPWSTR wszVRootPath,
    OUT LPDWORD pdwWin32Error
    );

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntpAddDropNewsgroup(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  LPCSTR	szNewsgroup
);

NET_API_STATUS
NET_API_FUNCTION
NntpRemoveDropNewsgroup(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  LPCSTR	szNewsgroup
);
#endif

NET_API_STATUS
NET_API_FUNCTION
NntpCancelMessageID(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  LPCSTR	szMessageID
);
		

//
// Used to free buffers returned by APIs
//

VOID
NntpFreeBuffer(
    LPVOID Buffer
    );

#ifdef __cplusplus
}
#endif

#endif _NNTPAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\propid.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	propid.h

Abstract:

	This module contains the definition of the property ID related types
	and values

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/03/98	created

--*/

#ifndef _PROPID_H_
#define _PROPID_H_

// Define a type for the property ID, we don't want to lock in to
// a specific data type
typedef DWORD PROP_ID;

// Define a bunch of values pertaining to the PROP ID type
#define MAX_PROP_ID							((PROP_ID)-1)
#define FIRST_AVAILABLE_PROP_ID				((PROP_ID)1)
#define UNDEFINED_PROP_ID					((PROP_ID)0)

// 
// Prop ID 0 is reserved for many things ...
//
#define PROP_ID_RESERVED					((PROP_ID)0)
#define PROP_ID_DELETED						((PROP_ID)0)
#define PROP_ID_NOT_FOUND					((PROP_ID)0)

//
// Define a structure for PROP ID management
//
typedef struct _PROP_ID_MANAGEMENT_ITEM
{
	GUID			idRange;	// GUID identifying the range of PROP IDs
	PROP_ID			idStartId;	// PROP ID of first ID in the managed range
	DWORD			dwLength;	// Number of contiguous PROP IDs in this range

} PROP_ID_MANAGEMENT_ITEM, *LPPROP_ID_MANAGEMENT_ITEM;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\perfcat.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: perfcat.h
//
// Contents: Categorizer performance counter block
//
// History:
// jstamerj 1999/02/26 21:17:46: Created.
//
//-------------------------------------------------------------
#ifndef __PERFCAT_H__
#define __PERFCAT_H__


typedef struct _tagCATLDAPPERFBLOCK
{
    //
    // LDAP counters
    //
    DWORD Connections;
    DWORD ConnectFailures;
    DWORD OpenConnections;
    DWORD Binds;
    DWORD BindFailures;
    DWORD Searches;
    DWORD PagedSearches;
    DWORD SearchFailures;
    DWORD PagedSearchFailures;
    DWORD SearchesCompleted;
    DWORD PagedSearchesCompleted;
    DWORD SearchCompletionFailures;
    DWORD PagedSearchCompletionFailures;
    DWORD GeneralCompletionFailures;
    DWORD AbandonedSearches;
    DWORD PendingSearches;

} CATLDAPPERFBLOCK, *PCATLDAPPERFBLOCK;


typedef struct _tagCATPERFBLOCK
{
    //
    // Counters per-categorization
    //
    DWORD CatSubmissions;
    DWORD CatCompletions;
    DWORD CurrentCategorizations;
    DWORD SucceededCategorizations;
    DWORD HardFailureCategorizations;
    DWORD RetryFailureCategorizations;
    DWORD RetryOutOfMemory;
    DWORD RetryDSLogon;
    DWORD RetryDSConnection;
    DWORD RetryGeneric;
    
    //
    // Counters per message
    //
    DWORD MessagesSubmittedToQueueing;
    DWORD MessagesCreated;
    DWORD MessagesAborted;

    //
    // Counters per recip
    //
    DWORD PreCatRecipients;
    DWORD PostCatRecipients;
    DWORD NDRdRecipients;

    DWORD UnresolvedRecipients;
    DWORD AmbiguousRecipients;
    DWORD IllegalRecipients;
    DWORD LoopRecipients;
    DWORD GenericFailureRecipients;
    DWORD RecipsInMemory;

    //
    // Counters per sender
    //
    DWORD UnresolvedSenders;
    DWORD AmbiguousSenders;

    //
    // Counters per address lookup
    //
    DWORD AddressLookups;
    DWORD AddressLookupCompletions;
    DWORD AddressLookupsNotFound;

    //
    // Misc counters
    //
    DWORD MailmsgDuplicateCollisions;

    //
    // LDAP counters
    //
    CATLDAPPERFBLOCK LDAPPerfBlock;

} CATPERFBLOCK, *PCATPERFBLOCK;



#endif //__PERCAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\qbase.h ===
//
// QBASE.h
//
//	This file defines CQElement - a base class for all types which
//	are to be used in the lockq.h and other templated queue manipulation
//	classes.
// 
// 




#ifndef	_QBASE_H_
#define	_QBASE_H_

#include	"dbgtrace.h"

//-----------------------------------------------
// Base Element Class
//
// This is the base class for Queue and stack Elements.
// The various implementations of Stacks and Queues are friends.
//	
class	CQElement	{
public : 
	CQElement	*m_pNext ;

	inline	CQElement( ) ;
	inline	CQElement( CQElement*	p ) ;
	inline	~CQElement( ) ;
} ;

CQElement::CQElement( ) : 
	m_pNext( 0 )  {
//
//	Construct a queue element - not in any list pointer must be NULL
//
}

CQElement::~CQElement( ) 	{
//
//	Destroy a queue element - next pointer must be NULL or
//	-1 (for lockq.h) so that we know the element is not 
//	on a queue at destruction time and the user has properly 
//	managed the linking and unlinking of the queue.
//
	_ASSERT( m_pNext == 0 || m_pNext == (CQElement*)(DWORD_PTR)-1 ) ;
}

CQElement::CQElement( CQElement *pIn ) : 
	m_pNext( pIn ) {
//
//	Constructor which sets the initial next pointer value !
//
}

#endif	// _CQUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\propstr.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       propstr.h
//
//  Contents:   Property name strings for all public IMsg properties
//
//  Classes:    None
//
//  Functions:  None
//
//  History:    November 7, 1997 - Milans, Created
//
//-----------------------------------------------------------------------------

#ifndef _PROPSTR_H_
#define _PROPSTR_H_

//
// IMsg property names. The MP_ prefix stands for Message Property
//

#define MP_RECIPIENT_LIST   "Recipients"
#define MP_RECIPIENT_LIST_W L"Recipients"

#define MP_CONTENT_FILE_NAME "ContentFileName"
#define MP_CONTENT_FILE_NAME_W L"ContentFileName"

#define MP_SENDER_ADDRESS_TYPE "SenderAddressType"
#define MP_SENDER_ADDRESS_TYPE_W L"SenderAddressType"

#define MP_SENDER_ADDRESS "SenderAddress"
#define MP_SENDER_ADDRESS_W L"SenderAddress"

#define MP_DOMAIN_LIST "DomainList"
#define MP_DOMAIN_LIST_W L"DomainList"

#define MP_PICKUP_FILE_NAME "PickupFileName"
#define MP_PICKUP_FILE_NAME_W L"PickupFileName"

#define MP_AUTHENTICATED_USER_NAME "AuthenticatedUserName"
#define MP_AUTHENTICATED_USER_NAME_W L"AuthenticatedUserName"

#define MP_CONNECTION_IP_ADDRESS "ConnectionIpAddress"
#define MP_CONNECTION_IP_ADDRESS_W L"ConnectionIpAddress"

#define MP_HELO_DOMAIN "HeloDomain"
#define MP_HELO_DOMAIN_W L"HeloDomain"

#define MP_EIGHTBIT_MIME_OPTION "EightBitMime"
#define MP_EIGHTBIT_MIME_OPTION_W L"EightBitMime"

#define MP_CHUNKING_OPTION "Chunking"
#define MP_CHUNKING_OPTION_W L"Chunking"

#define MP_BINARYMIME_OPTION "BinaryMime"
#define MP_BINARYMIME_OPTION_W L"BinaryMime"

#define MP_REMOTE_AUTHENTICATION_TYPE "RemoteAuthenticationType"
#define MP_REMOTE_AUTHENTICATION_TYPE_W L"RemoteAuthenticationType"

#define MP_ERROR_CODE "IMsgErrorCode"
#define MP_ERROR_CODE_W L"IMsgErrorCode"

#define MP_DSN_ENVID_VALUE "EnvidDsnOption"
#define MP_DSN_ENVID_VALUE_W L"EnvidDsnOption"

#define MP_DSN_RET_VALUE "RetDsnValue"
#define MP_DSN_RET_VALUE_W L"RetDsnValue"

#define MP_REMOTE_SERVER_DSN_CAPABLE "RemoteServerDsnCapable"
#define MP_REMOTE_SERVER_DSN_CAPABLE_W L"RemoteServerDsnCapable"


//
// Recipient property names. The RP_ prefix stands for Recipient Property
//

#define DSN_NOTIFY_SUCCESS	0x00000001
#define DSN_NOTIFY_FAILURE	0x00000002
#define DSN_NOTIFY_DELAY	0x00000004
#define DSN_NOTIFY_NEVER	0x00000008
#define DSN_NOTIFY_INVALID	0x10000000

#define IMMPID_RP_DSN_NOTIFY_SUCCESS_W	L"DSN_Notify_Success"
#define IMMPID_RP_DSN_NOTIFY_FAILURE_W	L"DSN_Notify_Failure"
#define IMMPID_RP_DSN_NOTIFY_DELAY_W	L"DSN_Notify_Delay"
#define IMMPID_RP_DSN_NOTIFY_NEVER_W	L"DSN_Notify_Never"
#define IMMPID_RP_DSN_NOTIFY_INVALID_W	L"DSN_Notify_Invalid"

#define IMMPID_RP_ADDRESS_SMTP_W		L"SMTPAddress"
#define IMMPID_RP_ADDRESS_X400_W		L"X400Address"
#define IMMPID_RP_ADDRESS_X500_W		L"X500Address"

#define RP_ADDRESS_TYPE "AddressType"
#define RP_ADDRESS_TYPE_W L"AddressType"
#define RP_ADDRESS "Address"
#define RP_ADDRESS_W L"Address"

#define RP_ADDRESS_TYPE_SMTP "SMTP"
#define RP_ADDRESS_TYPE_SMTP_W L"SMTP"

#define RP_ADDRESS_TYPE_EX "EX"
#define RP_ADDRESS_TYPE_EX_W L"EX"

#define RP_ADDRESS_TYPE_X400 "X400"
#define RP_ADDRESS_TYPE_X400_W L"X400"

#define RP_ADDRESS_TYPE_X500 RP_ADDRESS_TYPE_EX
#define RP_ADDRESS_TYPE_X500_W RP_ADDRESS_TYPE_EX_W

#define RP_ADDRESS_TYPE_DN "DN"
#define RP_ADDRESS_TYPE_DN_W L"DN"

#define RP_ADDRESS_TYPE_LEGACY_EX_DN "LegacyExDN"
#define RP_ADDRESS_TYPE_LEGACY_EX_DN_W L"LegacyExDN"

#define RP_ERROR_CODE "RcptErrorCode"
#define RP_ERROR_CODE_W L"RcptErrorCode"

#define RP_ERROR_STRING "RcptErrorString"
#define RP_ERROR_STRING_W L"RcptErrorString"

#define RP_DSN_NOTIFY_VALUE "NotifyDsnValue"
#define RP_DSN_NOTIFY_VALUE_W L"NotifyDsnValue"

#define RP_DSN_ORCPT_VALUE "OrcptDsnValue"
#define RP_DSN_ORCPT_VALUE_W L"OrcptDsnValue"

#define IMMPID_RP_LEGACY_EX_DN_W	L"LegacyExDN"

#endif _PROPSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\randfail.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    randfail.h

Abstract :

    This module contains macros used to instrument code for random failures

Author :

    Sam Neely

Revision History :

--*/

#if !defined(_WINDOWS_) && !defined(_WINBASE_)
#error This file must be included after other header files
#endif

#ifdef __cplusplus
extern "C" {
#endif

// If this is a debug build, expose the fTimeToFail(g_TestTrace) entry
// and a handful of utility macros

#if defined(DEBUG)
extern int __stdcall g_TestTrace(void);
extern void __stdcall g_TestTraceEnable();
extern void __stdcall g_TestTraceDisable();

#define FAILURE_MACRO0(api,err,ret) \
	(g_TestTrace() ? SetLastError(err), ret : api())

#define FAILURE_MACRO1(api,err,ret,arg1) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1))

#define FAILURE_MACRO2(api,err,ret,arg1,arg2) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2))

#define FAILURE_MACRO3(api,err,ret,arg1,arg2,arg3) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3))

#define FAILURE_MACRO4(api,err,ret,arg1,arg2,arg3,arg4) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4))

#define FAILURE_MACRO5(api,err,ret,arg1,arg2,arg3,arg4,arg5) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5))

#define FAILURE_MACRO6(api,err,ret,arg1,arg2,arg3,arg4,arg5,arg6) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6))

#define FAILURE_MACRO7(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7))

#define FAILURE_MACRO8(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7,arg8) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7,arg8))

#define FAILURE_MACRO9(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7,arg8,arg9) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7,arg8,arg9))

#define FAILURE_MACRO10(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7,arg8,arg9,arg10) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7,arg8,arg9,arg10))

#define RandFailDisable() g_TestTraceDisable()
#define RandFailEnable() g_TestTraceEnable()

#else			// !DEBUG
#define RandFailDisable() (void)0
#define RandFailEnable() (void)0

#endif


#if defined(DEBUG) && !defined(NOFAIL_WIN32API)

#define CreateDirectoryA(arg1,arg2) \
	FAILURE_MACRO2(CreateDirectoryA, ERROR_ARENA_TRASHED, 0, arg1, arg2)
#define CreateDirectoryW(arg1,arg2) \
	FAILURE_MACRO2(CreateDirectoryW, ERROR_ARENA_TRASHED, 0, arg1, arg2)

#define CreateDirectoryExA(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateDirectoryExA, ERROR_ARENA_TRASHED, 0, \
		       arg1,arg2,arg3)
#define CreateDirectoryExW(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateDirectoryExW, ERROR_ARENA_TRASHED, 0, \
		       arg1,arg2,arg3)

#define CreateEventA(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateEventA, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3,arg4)
#define CreateEventW(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateEventW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3,arg4)

#define CreateFileA(arg1,arg2,arg3,arg4,arg5,arg6,arg7) \
	FAILURE_MACRO7(CreateFileA, ERROR_ARENA_TRASHED, INVALID_HANDLE_VALUE,\
		       arg1,arg2,arg3,arg4,arg5,arg6,arg7)
#define CreateFileW(arg1,arg2,arg3,arg4,arg5,arg6,arg7) \
	FAILURE_MACRO7(CreateFileW, ERROR_ARENA_TRASHED, INVALID_HANDLE_VALUE,\
		       arg1,arg2,arg3,arg4,arg5,arg6,arg7)

#define CreateFileMappingA(arg1,arg2,arg3,arg4,arg5,arg6) \
	FAILURE_MACRO6(CreateFileMappingA, ERROR_ARENA_TRASHED, NULL,\
		       arg1,arg2,arg3,arg4,arg5,arg6)
#define CreateFileMappingW(arg1,arg2,arg3,arg4,arg5,arg6) \
	FAILURE_MACRO6(CreateFileMappingW, ERROR_ARENA_TRASHED, NULL,\
		       arg1,arg2,arg3,arg4,arg5,arg6)

#define CreateIoCompletionPort(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateIoCompletionPort, ERROR_ARENA_TRASHED, NULL,\
		      arg1,arg2,arg3,arg4)

#define CreateMutexA(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateMutexA, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)
#define CreateMutexW(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateMutexW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define CreateProcessA(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) \
	FAILURE_MACRO10(CreateProcessA, ERROR_ARENA_TRASHED, 0, \
		      arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)
#define CreateProcessW(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) \
	FAILURE_MACRO10(CreateProcessW, ERROR_ARENA_TRASHED, 0, \
			arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)

#define CreateSemaphoreA(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateSemaphoreA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3,arg4)
#define CreateSemaphoreW(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateSemaphoreW, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3,arg4)

#define CreateThread(arg1,arg2,arg3,arg4,arg5,arg6) \
	FAILURE_MACRO6(CreateThread, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3,arg4,arg5,arg6)

#define GetQueuedCompletionStatus(arg1,arg2,arg3,arg4,arg5) \
	FAILURE_MACRO5(GetQueuedCompletionStatus, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3,arg4,arg5)

#define OpenEventA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenEventA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3)
#define OpenEventW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenEventW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenFileMappingA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenFileMappingA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3)
#define OpenFileMappingW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenFileMappingW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenMutexA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenMutexA, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)
#define OpenMutexW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenMutexW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenProcess(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenProcess, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenSemaphoreA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenSemaphoreA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3)
#define OpenSemaphoreW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenSemaphoreW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define PostQueuedCompletionStatus(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(PostQueuedCompletionStatus, ERROR_ARENA_TRASHED, 0, \
		      arg1,arg2,arg3,arg4)

#define ReadFile(arg1,arg2,arg3,arg4,arg5) \
	FAILURE_MACRO5(ReadFile, ERROR_ARENA_TRASHED, 0, \
		      arg1,arg2,arg3,arg4,arg5)

#define WriteFile(arg1,arg2,arg3,arg4,arg5) \
	FAILURE_MACRO5(WriteFile, ERROR_ARENA_TRASHED, 0, \
		       arg1,arg2,arg3,arg4,arg5)



#endif

#if defined(DEBUG) && !defined(NOFAIL_RANDOM)
#define fTimeToFail() g_TestTrace()
#else
#define fTimeToFail() (0)
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\rw.h ===
/*++

	rw.h

	This file defines some locks with the following performance characteristics : 

	* A constant number of handles is used per lock instance 
	* The lock entry/exit protocols use Interlocked operations and do not 
		cause context switches in themselves.


--*/

#ifndef	_CRW_H
#define	_CRW_H
						
#include	<limits.h>

//
// This class contains the meat - does actual locking etc...
//
class	CShareLock {
/*++

Class Description : 

	This class implements a reader writer lock.
	
	Multiple threads can successfully enter the lock by calling
	ShareLock().  Once any thread has entered the lock through
	ShareLock(), all threads calling ExclusiveLock() are blocked 
	untill ShareUnlock() is called for each successfull ShareLock().

	This lock is fair - If multiple threads have passed through
	ShareLock(), and a thread calls ExclusiveLock(), all threads
	that arrive after the call to ExclusiveLock() will block untill
	the ExclusiveLock() thread has acquired and released the lock.
	This property is symetrical with ShareLock() and ExclusiveLock().


--*/
private : 

	//
	// Number of Readers who have passed through the lock OR 
	// the number of readers waiting for the lock (will be negative).
	// A value of 0 means nobody in the lock
	//
	volatile	long	cReadLock ;			

	//
	// The number of readers remainin in the lock if 
	// there is a writer waiting.  This can become temporarily negative
	//
	volatile	long	cOutRdrs ;			

	//
	// Critical section to allow only one writer into the lock at a time
	//
	CRITICAL_SECTION	critWriters ; 	

	//
	// Semaphore for waiting writers to block on (Only 1 ever, others will 
	// be queued on critWriters)
	//
	HANDLE	hWaitingWriters ;	

	//
	// Semaphore for waiting readers to block on 
	//
	HANDLE	hWaitingReaders ;	

	//
	//	You may not copy these objects - so this lock is private !
	//
	CShareLock( CShareLock& ) ;

	//
	//	You may not copy through assignment - so this operator is private !
	//
	CShareLock&	operator=( CShareLock& ) ;

public : 

	//
	//	Construct and Destroy a CShareLock !
	//
	CShareLock( ) ;
	~CShareLock( ) ;

	//
	//	Check that the lock is correctly initialized - call only
	//	after construction !
	//
	BOOL
	IsValid() ;

	//
	//	Grab the lock for shared mode.
	//	each call to ShareLock() must be paired with exactly 1 call
	//	to ShareUnlock().  A thread that successfully calls ShareLock()
	//	can only call ShareUnlock(), otherwise a deadlock can occur.
	//	( the sequence ShareLock(); ShareLock(); ShareUnlock(); ShareUnlock();
	//	can also deadlock)
	//
	void	
	ShareLock( ) ;
	
	//
	//	Release the lock from shared mode !	
	//
	void	
	ShareUnlock( ) ;

	//
	//	Grab the lock for Exclusive mode.
	//	each call to ExclusiveLock() must be paired with exactly 1 call
	//	to ExclusiveUnlock().  A thread that successfully calls ExclusiveLock()
	//	can only call ExclusiveUnlock(), otherwise a deadlock can occur.
	//	( the sequence ExclusiveLock(); ExclusiveLock(); ExclusiveUnlock(); ExclusiveUnlock();
	//	can also deadlock)
	//
	void	
	ExclusiveLock( ) ;

	//
	//	Release the lock from Exclusive mode !
	//
	void	
	ExclusiveUnlock( ) ;

	//
	//	Given that we've already acquired the lock Exclusively, convert to 
	//	Shared.  This cannot fail.  ShareUnlock() must be called after 
	//	we have done this.
	//
	void
	ExclusiveToShared() ;

	//
	//	Given that we've acquired the lock in shared mode try to get 
	//	it exclusively.
	//	This can fail for two reasons : 
	//		Another thread is trying to get the lock Exclusively
	//		A bunch of other threads are also in the lock in shared mode.
	//	
	//	The function will return FALSE if it fails, in which case the 
	//	Shared lock is still held !
	//
	BOOL
	SharedToExclusive() ;

	//
	//	Try to acquire the lock in shared mode.
	//	This will only fail if an ExclusiveLock is held or being 
	//	waited for.
	//	TRUE is returned if we get the lock Shared, FALSE otherwise !
	//
	BOOL
	TryShareLock() ;

	//	
	//	Try to acquire the lock in Exclusive mode.
	//	This will fail if another thread is in the ExclusiveLock()
	//	or ShareLock's are held.
	//	TRUE is returned if we get the Exclusive Lock, FALSE otherwise !
	//
	BOOL
	TryExclusiveLock() ;


	//
	//	PartialLocks - 
	//
	//	Partial Locks are similar to Exclusive Locks - only one thread
	//	can successfully call PartialLock(), any other threads calling
	//	PartialLock() or ExclusiveLock() will block.
	//	HOWEVER - while a PartialLock() is held, Readers (threads calling
	//	ShareLock()) may enter the lock.
	//
	void	PartialLock() ;

	//
	//	Release the PartialLock - Other Exclusive() or Partial lock acquirers
	//	may now enter.
	//
	void	PartialUnlock() ;

	//
	//	Convert a Partial Lock to an Exclusive Lock.  This function is 
	//	guaranteed to succeed, HOWEVER a lock can only be converted with 
	//	this function once, i.e. a thread doing
	//		PartialLock() ;
	//		FirstPartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		FirstPartialToExclusive() ;
	//	will have problems - the second call to FirstPartialToExclusive()
	//	may mess up the lock state and cause the lock to fail horribly.
	//	If a user wishes to convert as above they must have a call sequence like : 
	//
	//		PartialLock() ;
	//		FirstPartialToExclusive() or PartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		PartialToExclusive() ;
	//
	//	If you change lock states more than once - you take your chances !
	//
	void	FirstPartialToExclusive() ;

	//
	//	Returns TRUE if we can get the lock Exclusively, otherwise
	//	we return FALSE with the lock remaining in the Partially held state.
	//
	//	NOTE : This function will fail in CShareLockNH, but will always
	//	succeed for CShareLock() locks !
	//
	BOOL	PartialToExclusive() ;

	//
	//	We can always go from an ExclusiveLock() to a PartialLock() state.
	//
	void	ExclusiveToPartial() ;

	//
	//	We can always go from a PartialLock() state to a SharedLock() state
	//
	void	PartialToShared() ;

	//
	//	Returns TRUE if we can get the lock Partially !
	//	If it returns FALSE we remain with the lock held Shared()
	//
	BOOL	SharedToPartial() ;

	//
	//	Returns TRUE only if no other threads are trying to get the lock
	//	ExclusiveLy or Partially !
	//
	BOOL	TryPartialLock() ;
	
} ;



class	CSymLock	{
/*++

Class Description : 

	This class implements a symmetric lock, where multiple threads can simultaneously 
	acquire the lock if they are all of the same group.

	For instance, multiple threads can call Group1Lock() and all enter the lock.
	Any thread successfully acquiring the lock through Group1Lock() blocks all threads
	trying to acquire the lock through Group2Lock(), and vice versa.	

--*/
private : 

	//
	//	Main lock point where all acquiring threads determine who gets the lock !
	//
	volatile	long	m_lock ;

	//
	//	Two variables for the lock exit procotol - used to determine the last thread
	//	to leave the lock !
	//
	volatile	long	m_Departures ;
	volatile	long	m_left ;

	//
	//	Handles for blocking threads !
	//
	HANDLE	m_hSema4Group1 ;
	HANDLE	m_hSema4Group2 ;

	//
	//	Utility function - implements lock exit protocol when there
	//	is no contention for the lock !
	//
	BOOL
	InterlockedDecWordAndMask(	volatile	long*	plong,	
								long	mask,	
								long	decrement 
								) ;

	//
	//	Utility functions - implement lock exit protocol for case where
	//	InterlockedDecWordAndMask determines that there is contention for the lock !
	//

	//
	//	How Group1 Leaves the lock under contention
	//	
	BOOL
	Group1Departures(	long	bump	) ;

	//
	//	How Group2 Leaves the lock under contention 
	//
	BOOL
	Group2Departures(	long	bump	) ;

	//
	//	You may not copy these objects - so the copy constructor is private !
	//
	CSymLock( CSymLock& ) ;

	//
	//	You may not copy through assignment - so this operator is private !
	//
	CSymLock&	operator=( CSymLock& ) ;

public : 

	//
	//	Construct and Destruct the asymetric lock !
	//
	CSymLock() ;
	~CSymLock() ;

	//
	//	Check that the lock is correctly initialized - call only
	//	after construction !
	//
	BOOL
	IsValid() ;

	//
	//	Grab the lock for a group1 thread.
	//	This function may not be called again on the same
	//	thread until Group1Unlock() is called.
	//	Group1Unlock() must be called exactly once for each
	//	Group1Lock() !
	//
	void
	Group1Lock() ;

	//
	//	Release the lock for a group1 thread.
	//
	void
	Group1Unlock() ;

	//
	//	Grab the lock for a group2 thread.
	//	This function may not be called again on the same
	//	thread until Group2Unlock() is called.
	//	Group2Unlock() must be called exactly once for each
	//	Group2Lock() !
	//
	void
	Group2Lock() ;

	//
	//	Release the lock for a Group2 thread !
	//
	void
	Group2Unlock() ;

} ;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\rwex.h ===
#ifndef _RWEX_INC
#define _RWEX_INC

namespace rwex {
	#include "rw.h"
}

typedef rwex::CShareLock CExShareLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\rwexport.h ===
/*++

	rwexport.h

	This file defines a reader/writer lock implemented in rwnh.dll.
	We define the locks so that none of their internal workings is exposed.

--*/


#ifndef	_RWEXPORT_H
#define	_RWEXPORT_H

#ifdef	_RW_IMPLEMENTATION_
#define	_RW_INTERFACE_ __declspec( dllexport ) 
#else
#define	_RW_INTERFACE_	__declspec( dllimport ) 
#endif


class	_RW_INTERFACE_	CShareLockExport	{
private : 
	DWORD	m_dwSignature ;

	enum	constants	{
		//
		//	Signature in our objects !
		//
		SIGNATURE = (DWORD)'opxE'
	} ;

	//
	//	Reserved space for the implementation !
	//
	DWORD	m_dwReserved[16] ;

public : 

	CShareLockExport() ;
	~CShareLockExport() ;

	//
	//	Grab the lock Shared - other threads may pass through ShareLock() as well
	//
	void	ShareLock() ;

	//
	//	Releases the lock - if we are the last reader to leave writers may
	//	start to enter the lock !
	//
	void	ShareUnlock() ;

	//
	//	Grab the lock Exclusively - no other readers or writers may enter !!
	//
	void	ExclusiveLock() ;

	//
	//	Release the Exclusive Locks - if there are readers waiting they 
	//	will enter before other waiting writers !
	//
	void	ExclusiveUnlock() ;

	//
	//	Convert an ExclusiveLock to a Shared - this cannot fail !
	//
	void	ExclusiveToShared() ;

	//
	//	Convert a Shared Lock to an Exclusive one - this can fail - returns
	//	TRUE if successfull !
	//
	BOOL	SharedToExclusive() ;

	BOOL	TryShareLock() ;
	BOOL	TryExclusiveLock() ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\rwnew.h ===
/*++
	
	rwnew.h

	This file defines several variations of Reader/Writer locks
	with different properties regarding handles used, and other 
	implementation details.

	Also defined are some variations of CRITICAL_SECTIONS which use
	fewer or no handles.

--*/



#ifndef	_RWNEW_H
#define	_RWNEW_H

#ifdef	_RW_IMPLEMENTATION_
#define	_RW_INTERFACE_ __declspec( dllexport ) 
#else
#define	_RW_INTERFACE_	__declspec( dllimport ) 
#endif

#pragma	warning( disable:4251 )
						
#include	<limits.h>
#include	"lockq.h"
#include	"rwintrnl.h"


class	_RW_INTERFACE_	CCritSection	{
private :

	//
	//	Handle of thread owning the lock !
	//
	HANDLE		m_hOwner ;

	//
	//	Count of Recursive Calls 
	//
	long	m_RecursionCount ;	

	//
	//	Count used to see who gets the lock next !
	//
	long	m_lock ;

	//
	//	Queue of waiting threads 
	//
	CSingleReleaseQueue		m_queue ;

	//
	//	Copying of these objects is not allowed !!!!
	//
	CCritSection( CCritSection& ) ;
	CCritSection&	operator=( CCritSection& ) ;

public : 

#ifdef	DEBUG
	DWORD	m_dwThreadOwner ;
#endif	

	//
	//	Construct a critical section object
	//
	CCritSection( ) :	
		m_queue( FALSE ),
		m_hOwner( INVALID_HANDLE_VALUE ), 
		m_RecursionCount( 0 ), 
		m_lock( -1 ) {
	}

	//
	//	Acquire the critical section
	//
	void	
	Enter(	
			CWaitingThread&	myself 
			) ;

	//
	//	Another version which acquires the critical section - 
	//	creates its own CWaitingThread object !
	//
	void	
	Enter() ;

	//
	//	REturns TRUE if the lock is available right now !
	//
	BOOL
	TryEnter(
			CWaitingThread&	myself 
			) ;

	//
	//	Returns TRUE if we can get the lock right now !
	//
	BOOL
	TryEnter()	{
		CWaitingThread	myself ;
		return	TryEnter( myself ) ;
	}

	//
	//	Release the critical section !
	//
	void
	Leave() ;

		
} ;


//
//	This version of critical section is more like an event - doesn't
//	care who releases locks - and doesn't handle recursive grabs !
//
class	_RW_INTERFACE_	CSimpleCritSection	{
private :

	//
	//	Count used to see who gets the lock next !
	//
	long	m_lock ;

	//
	//	Queue of waiting threads 
	//
	CSingleReleaseQueue		m_queue ;

	//
	//	Copying of these objects is not allowed !!!!
	//
	CSimpleCritSection( CCritSection& ) ;
	CSimpleCritSection&	operator=( CCritSection& ) ;

public : 

#ifdef	DEBUG
	DWORD	m_dwThreadOwner ;
#endif	

	//
	//	Construct a critical section object
	//
	CSimpleCritSection( ) :	
		m_queue( FALSE ),
#ifdef	DEBUG
		m_dwThreadOwner( 0 ),
#endif
		m_lock( -1 ) {
	}

	//
	//	Acquire the critical section
	//
	void	
	Enter(	
			CWaitingThread&	myself 
			) ;

	//
	//	Another version which acquires the critical section - 
	//	creates its own CWaitingThread object !
	//
	void	
	Enter() ;

	//
	//	REturns TRUE if the lock is available right now !
	//
	BOOL
	TryEnter(
			CWaitingThread&	myself 
			) ;

	//
	//	Returns TRUE if we can get the lock right now !
	//
	BOOL
	TryEnter()	{
		CWaitingThread	myself ;
		return	TryEnter( myself ) ;
	}

	//
	//	Release the critical section !
	//
	void
	Leave() ;
	
} ;

//
//	Another class which tries to create Reader/Write locks with
//	no handles !!
//

class	_RW_INTERFACE_	CShareLockNH	{
private : 

	//	
	//	Lock grabbed by writers to have exclusive access
	//
	CSimpleCritSection	m_lock ;

	//
	//	Number of readers who have grabbed the Read Lock - 
	//	Negative if a writer is waiting !
	//
	volatile	long	m_cReadLock ;

	//
	//	Number of Readers who have left the lock since a 
	//	writer tried to grab it !
	//
	volatile	long	m_cOutReaders ;

	//
	//	Number of readers who are entering the lock after 
	//	being blocked !!!
	//
	volatile	long	m_cOutAcquiringReaders ;

	//
	//	Number of threads needing m_lock to be held right now !
	//
	volatile	long	m_cExclusiveRefs ;

	//
	//	Handle that all the readers who are waiting try to grab !
	//
	volatile	HANDLE	m_hWaitingReaders ;

	//
	//	Handle that the single writer waiting for the lock is trying
	//	to grab !
	//
	volatile	HANDLE	m_hWaitingWriters ;

	void	inline
	WakeReaders() ;

	//
	//	The internal work of ShareLock - does a lot more of the stuff required
	//	when a writer is present !!!
	//
	void
	ShareLockInternal() ;

	//
	//	The internal work of ShareLock - does a lot more of the stuff required
	//	when a writer is present !!!
	//
	void
	ShareUnlockInternal() ;
	

	//
	//	You may not copy these objects - so this lock is private !
	//
	CShareLockNH( CShareLockNH& ) ;

	//
	//	You may not copy through assignment - so this operator is private !
	//
	CShareLockNH&	operator=( CShareLockNH& ) ;
	
public : 

	//
	//	Construction of CShareLockNH() objects always succeeds and there
	//	are no error cases !
	//
	CShareLockNH() ;

	//
	//	Grab the lock Shared - other threads may pass through ShareLock() as well
	//
	void	ShareLock() ;

	//
	//	Releases the lock - if we are the last reader to leave writers may
	//	start to enter the lock !
	//
	void	ShareUnlock() ;

	//
	//	Grab the lock Exclusively - no other readers or writers may enter !!
	//
	void	ExclusiveLock() ;

	//
	//	Release the Exclusive Locks - if there are readers waiting they 
	//	will enter before other waiting writers !
	//
	void	ExclusiveUnlock() ;

	//
	//	Convert an ExclusiveLock to a Shared - this cannot fail !
	//
	void	ExclusiveToShared() ;

	//
	//	Convert a Shared Lock to an Exclusive one - this can fail - returns
	//	TRUE if successfull !
	//
	BOOL	SharedToExclusive() ;

	//
	//	Return TRUE if we can get the lock shared.  Only fails when 
	//	somebody is attempting or has the lock exclusively, we will enter
	//	if there are only other readers in the lock.
	//
	BOOL	TryShareLock() ;

	//
	//	Return TRUE if we can get the lock Exclusively.  Only succeeds
	//	when nobody else is near the lock.
	//
	BOOL	TryExclusiveLock() ;

	//
	//	PartialLocks - 
	//
	//	Partial Locks are similar to Exclusive Locks - only one thread
	//	can successfully call PartialLock(), any other threads calling
	//	PartialLock() or ExclusiveLock() will block.
	//	HOWEVER - while a PartialLock() is held, Readers (threads calling
	//	ShareLock()) may enter the lock.
	//
	void	PartialLock() ;

	//
	//	Release the PartialLock - Other Exclusive() or Partial lock acquirers
	//	may now enter.
	//
	void	PartialUnlock() ;

	//
	//	Convert a Partial Lock to an Exclusive Lock.  This function is 
	//	guaranteed to succeed, HOWEVER a lock can only be converted with 
	//	this function once, i.e. a thread doing
	//		PartialLock() ;
	//		FirstPartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		FirstPartialToExclusive() ;
	//	will have problems - the second call to FirstPartialToExclusive()
	//	may mess up the lock state and cause the lock to fail horribly.
	//	If a user wishes to convert as above they must have a call sequence like : 
	//
	//		PartialLock() ;
	//		FirstPartialToExclusive() or PartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		PartialToExclusive() ;
	//
	//	If you change lock states more than once - you take your chances !
	//
	void	FirstPartialToExclusive() ;

	//
	//	Returns TRUE if we can get the lock Exclusively, otherwise
	//	we return FALSE with the lock remaining in the Partially held state.
	//
	//	NOTE : NYI in CShareLockNH - will always return FALSE !
	//
	BOOL	PartialToExclusive() ;

	//
	//	We can always go from an ExclusiveLock() to a PartialLock() state.
	//
	void	ExclusiveToPartial() ;

	//
	//	We can always go from a PartialLock() state to a SharedLock() state
	//
	void	PartialToShared() ;

	//
	//	Returns TRUE if we can get the lock Partially !
	//	If it returns FALSE we remain with the lock held Shared()
	//
	BOOL	SharedToPartial() ;

	//
	//	Returns TRUE only if no other threads are trying to get the lock
	//	ExclusiveLy or Partially !
	//
	BOOL	TryPartialLock() ;

} ;

//
//  This is a utility function to get an Event Handle we save 
//  for each thread - the handle is Created as: 
//      CreateEvent( NULL, 
//                  FALSE, 
//                  FALSE,
//                  NULL ) ;
//  This results in an auto-reset event which goes back to non signalled whenever a thread
//  is released.
//
HANDLE
_RW_INTERFACE_
GetPerThreadEvent() ;



#endif	//	_RWNEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\rwintrnl.h ===
/*++

	rwintrnl.h

	Reader/Writer locks internal header file

	This file defines several objects used to implement
	reader/writer locks, however these objects should
	not be directly used by any client of rw.h



--*/


#ifndef	_RWINTRNL_H_
#define	_RWINTRNL_H_



class	CHandleInfo	{
/*++

	This class keeps track of all the handles we've allocated for
	use by various threads.  We can't use Thread Local Storage
	directly because we can be dynamically unloaded, in which case
	we need to free all of our HANDLES !

--*/
private :
	//
	//	Signature for our
	//
	DWORD	m_dwSignature ;
	class	CHandleInfo*	m_pNext ;
	class	CHandleInfo*	m_pPrev ;

	CHandleInfo( CHandleInfo& ) ;
	CHandleInfo&	operator=( CHandleInfo& ) ;

	//
	//	Global lock to protect free and allocated lists !
	//
	static	CRITICAL_SECTION	s_InUseList ;
	//
	//	Allocated CHandleInfo objects !
	//
	static	CHandleInfo			s_Head ;
	//
	//	Free CHandleInfo objects
	//
	static	CHandleInfo			s_FreeHead ;
	//
	//	Number of Free CHandleInfo objects in the s_FreeHead list
	//
	static	DWORD	s_cFreeList ;

	enum	constants	{
		//
		//	Maximum number of CHandleInfo objects we'll hold onto !
		//
		MAX_FREE = 64,		
		//
		//	Initial number of CHandleInfo objects we'll allocate !
		//
		INITIAL_FREE = 32,
		//
		//	Signature in our objects !
		//
		SIGNATURE = (DWORD)'hnwR'
	} ;

	//
	//	Memory Allocation is done the hard way !
	//
	void*	operator new( size_t size ) ;
	void	operator delete( void *pv ) ;

	//
	//	List Manipulation routines !
	//
	void	
	InsertAtHead( CHandleInfo*	pHead	)	;

	//
	//	Remove the element from the list - returns this pointer !
	//
	CHandleInfo*
	RemoveList( )  ;

public :

	//
	//	Constructor and Destructor !
	//
	CHandleInfo() ;
	~CHandleInfo() ;

	//
	//	This is public for all to use !
	//
	HANDLE	m_hSemaphore ;

    //
    //  This is an auto-reset event handle available for anybody
    //  and retrievable through GetPerThreadEvent() ;
    //
    HANDLE  m_hEvent ;

	//
	//	Initialize the class
	//
	static	BOOL
	InitClass() ;
	
	//
	//	Terminate the class - release all outstanding handles !
	//
	static	void
	TermClass() ;

	//
	//	Get a CHandleInfo object !
	//
	static	CHandleInfo*
	AllocHandleInfo() ;

	//
	//	release a CHandleInfo object !
	//
	static	void
	ReleaseHandleInfo( CHandleInfo* ) ;

	//
	//	Check that the object is valid !
	//
	BOOL
	IsValid()	{
		return	m_dwSignature == SIGNATURE &&
				m_pNext != 0 &&
				m_pPrev != 0 ;
	}

} ;


//
//	This class serves two purposes : to provide for a linkable object
//	on which we can queue threads blocked upon semaphore handles, and
//	a mechanism to get and set semaphore handles for reader/writer locks etc...
//
class	CWaitingThread : public	CQElement	{
private :

	enum	{
		POOL_HANDLES = 64,
	} ;

	//
	//	Semaphore that we can use to block the thread !
	//
	CHandleInfo	*m_pInfo ;

	//
	//	Var to hold error that may have occurred manipulating the lock !
	//
	DWORD	m_dwError ;

	//
	//	Thread Local Storage offset for holding the handles !
	//
	static	DWORD	g_dwThreadHandle ;

	//
	//	Array of Handles to Semaphores which we stash away in case
	//	we have to release the handle being used by a thread at some point !
	//
	static	HANDLE	g_rghHandlePool[ POOL_HANDLES ] ;

	//
	//	No copying of these objects allowed !!!
	//
	CWaitingThread( CWaitingThread& ) ;
	CWaitingThread&	operator=( CWaitingThread& ) ;

public :

#ifdef	DEBUG

	//
	//	Thread Id - handy for debuggiing
	//
	DWORD	m_dwThreadId ;
#endif

	CWaitingThread() ;


	//
	//	Functions to be called from the DllEntryProc function !
	//
	static	BOOL	
	InitClass() ;

	static	BOOL	
	TermClass() ;

	//
	//	Thread Entry/Exit routines which can allocate semaphore handles for us !
	//
	static	void	
	ThreadEnter() ;

	static	void	
	ThreadExit() ;

    //
    //  Function which gives us our Event Handle
    //
    inline  HANDLE
    GetThreadEvent()    const ;

	//
	//	Function which gives us our thread handle !
	//
	inline	HANDLE	
	GetThreadHandle()	const ;

	//
	//	Function which will release a HANDLE to the Pool of available
	//	semaphore handles !
	//
	inline	void
	PoolHandle(
				HANDLE	h
				)	const ;

	//
	//	Function which will remove a handle from our thread's TLS !
	//	The argument must originally be from the calling thread's TLS
	//
	inline	void
	ClearHandle(	
				HANDLE	h
				) ;
	

	//
	//	Function which blocks the calling thread !!
	//
	inline	BOOL	
	Wait() const ;

	//
	//	Function which can release a thread !!
	//
	inline	BOOL	
	Release() const	;

	//
	//	This function is used in debug builds to check the state of our semaphore handles !
	//
	static	inline
	BOOL	ValidateHandle(
				HANDLE	h
				) ;

} ;

typedef	TLockQueue< CWaitingThread >	TThreadQueue ;	

class	CSingleReleaseQueue {
private :
	//
	//	Queue of threads waiting to own the lock !
	//
	TThreadQueue	m_Waiting ;

public :

#ifdef	DEBUG
	DWORD			m_ThreadIdNext ;
#endif

	CSingleReleaseQueue(	
				BOOL	IsSignalled = TRUE
				) ;

	//
	//	Release a single waiting thread !
	//
	void	Release( ) ;

	//
	//	Wait for the queue to become signalled !
	//
	void	WaitForIt(
				CWaitingThread&	myself
				) ;

	//
	//	Wait for the queue to become signalled
	//
	void	WaitForIt( ) ;

} ;

//
//	This class is similar to a semaphore -
//	Threads block indefinately on WaitForIt() and another
//	thread may release as many threads as required by calling
//	Release().
//	
class	CEventQueue	{
private :

	//
	//	Number of threads that should be allowed to pass
	//	through the event !!!
	//
	long			m_ReleaseCount ;

	//
	//	Queue of threads blocked on this event !
	//
	TThreadQueue	m_WaitingThreads ;

	//
	//	Any thread may call this to release threads from the queue
	//
	BOOL	ResumeThreads(	
					CWaitingThread*
					) ;

public :

	//
	//	Create an event queue object
	//
	CEventQueue(	
				long	cInitial = 0
				) ;

	~CEventQueue() ;

	void	Release(	
				long	NumberToRelease
				) ;

	void	WaitForIt(
				CWaitingThread&	myself
				) ;

	void	WaitForIt() ;

	void	Reset() ;
} ;




//
//	Function which gives us our thread handle !
//
inline	HANDLE	
CWaitingThread::GetThreadHandle()	const	{

	_ASSERT( ValidateHandle( m_pInfo->m_hSemaphore ) ) ;

	return	m_pInfo->m_hSemaphore ;	
}

//
//	Function which takes a handle (must not be ours)
//	and places it into a pool of handles available for other threads !
//
inline	void
CWaitingThread::PoolHandle(	HANDLE	h )	const	{

	_ASSERT( h != m_pInfo->m_hSemaphore && h != 0 ) ;
	_ASSERT( ValidateHandle( h ) ) ;

	for( int i=0;
			i < sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] ) &&
			h != 0;
			i++ ) {
		h = (HANDLE)InterlockedExchangePointer( (PVOID*)&g_rghHandlePool[i], h ) ;
	}

	if( h != 0 ) {
		_VERIFY( CloseHandle( h ) ) ;
	}
}

//
//	Release our Handle from TLS, somebody else is going to use it !
//
inline	void
CWaitingThread::ClearHandle(	HANDLE	h )		{

	_ASSERT( h != 0 && h == m_pInfo->m_hSemaphore ) ;

	m_pInfo->m_hSemaphore = 0 ;
	//TlsSetValue( g_dwThreadHandle, (LPVOID) 0 ) ;

}



//
//	Block on the handle held within our object !
//
inline	BOOL	
CWaitingThread::Wait()	const	{	

	_ASSERT( m_pInfo->m_hSemaphore != 0 ) ;
	
	return	WAIT_OBJECT_0 == WaitForSingleObject( m_pInfo->m_hSemaphore, INFINITE ) ;	
}

//
//	Release a thread which is blocked on the semaphore within !!
//
inline	BOOL	
CWaitingThread::Release()	const	{	

	_ASSERT( m_pInfo->m_hSemaphore != 0 ) ;
	_ASSERT( ValidateHandle( m_pInfo->m_hSemaphore ) ) ;

	return	ReleaseSemaphore( m_pInfo->m_hSemaphore, 1, NULL ) ;	
}

//
//
//
inline	BOOL
CWaitingThread::ValidateHandle( HANDLE	h )	{

	DWORD	dw = WaitForSingleObject( h, 0 ) ;
	_ASSERT( dw == WAIT_TIMEOUT ) ;

	return	dw == WAIT_TIMEOUT ;
}

inline  HANDLE
CWaitingThread::GetThreadEvent() const   {
   return   m_pInfo->m_hEvent ;
}














#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\rwinst.h ===
//-----------------------------------------------------------------------------
//
//
//  File: rwinst.h
//
//  Description:  Instramented share lock implementations.  Our current 
//      sharelock implementation is non-reentrant.  This wrapper can also
//      be used to check for possible deadlocks.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/10/99 - MikeSwa Created 
//      8/6/99 - MikeSwa created phatq version
//      11/6/99 - MikeSwa updated to use CShareLockNH
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __PTRWINST_H__
#define __PTRWINST_H__

#include "rwnew.h"
#include "listmacr.h"

#define SHARE_LOCK_INST_SIG         'kcoL'
#define SHARE_LOCK_INST_SIG_FREE    '!koL'


#define THREAD_ID_BLOCK_SIG         'klBT'
#define THREAD_ID_BLOCK_SIG_FREE    '!lBT'
#define THREAD_ID_BLOCK_UNUSED      0xFFFFFFFF 

//Flag values that describe the type of tracking to do
//These can be passed to the constructor to allow different levels of 
//tracking for different instances.
enum
{
    SHARE_LOCK_INST_TRACK_CONTENTION        = 0x00000001,
    SHARE_LOCK_INST_TRACK_SHARED_THREADS    = 0x00000002,
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS = 0x00000004,
    SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS = 0x00000008,
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST    = 0x00000010,
    SHARE_LOCK_INST_TRACK_NOTHING           = 0x80000000,
};

//Define some useful flag combinations

//This combination of flags has minimal perf impact, but does
//allow easier exclusive deadlock detection 
#define SHARE_LOCK_INST_TRACK_MINIMALS ( \
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS | \
    SHARE_LOCK_INST_TRACK_SHARED_THREADS | \
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST )

//This combination of flags uses all of the tracking functionality of
//this class.
#define SHARE_LOCK_INST_TRACK_ALL (\
    SHARE_LOCK_INST_TRACK_CONTENTION | \
    SHARE_LOCK_INST_TRACK_SHARED_THREADS | \
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS | \
    SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS | \
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST )

//A user can define their own defaults before including this file
//$$TODO - scale back the defaults for debug builds
#ifndef SHARE_LOCK_INST_TRACK_DEFAULTS
#ifdef DEBUG
#define SHARE_LOCK_INST_TRACK_DEFAULTS SHARE_LOCK_INST_TRACK_ALL
#else //not DEBUG
#define SHARE_LOCK_INST_TRACK_DEFAULTS SHARE_LOCK_INST_TRACK_MINIMALS
#endif //not DEBUG
#endif //SHARE_LOCK_INST_TRACK_DEFAULTS

#ifndef SHARE_LOCK_INST_DEFAULT_MAX_THREADS
#define SHARE_LOCK_INST_DEFAULT_MAX_THREADS 200
#endif //SHARE_LOCK_INST_DEFAULT_MAX_THREADS

//---[ CThreadIdBlock ]--------------------------------------------------------
//
//
//  Description: 
//      An structure that represents a thread and the required info to
//      hash it.
//  Hungarian: 
//      tblk, ptblk
//  
//-----------------------------------------------------------------------------
class CThreadIdBlock
{
  protected:
    DWORD            m_dwSignature;
    DWORD            m_dwThreadId;
    DWORD            m_cThreadRecursionCount;
    CThreadIdBlock  *m_ptblkNext;
  public:
    CThreadIdBlock()
    {
        m_dwSignature = THREAD_ID_BLOCK_SIG;
        m_dwThreadId = THREAD_ID_BLOCK_UNUSED;
        m_cThreadRecursionCount = 0;
        m_ptblkNext = NULL;
    };
    ~CThreadIdBlock()
    {
        m_dwSignature = THREAD_ID_BLOCK_SIG_FREE;
        if (m_ptblkNext)
            delete m_ptblkNext;
        m_ptblkNext = NULL;
    };

    DWORD   cIncThreadCount(DWORD dwThreadId);
    DWORD   cDecThreadCount(DWORD dwThreadId);
    DWORD   cMatchesId(DWORD dwThreadId);
};

//---[ dwHashThreadId ]--------------------------------------------------------
//
//
//  Description: 
//      Given a thread ID (return by GetCurrentThreadId()) it returns a hashed
//      index.  This is designed to be used in conjuction with a array (of
//      size dwMax) of CThreadIdBlock's.  Each CThreadIdBlock will implement
//      linear chaining.  A hash lookup can be implemented by somehthing as
//      simple as:
//          rgtblk[dwhashThreadId(GetCurrentThreadId()), 
//                                sizeof(rgtblk)].cIncThreadCount();
//  Parameters:
//      dwThreadId      Thread Id to hash
//      dwMax           Max hash value (actual max value +1)
//  Returns:
//      Hashed thread Id
//  History:
//      8/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline DWORD dwHashThreadId(DWORD dwThreadId, DWORD dwMax)
{
    //Typically IDs are between 0x100 and 0xFFF
    //Also, the handles are multiples of 4 (ie end in 0, 4, 8, or C)
    //For these conditions, this hash will give unique results for
    //dwMax of 1000. (0xFFF-0x100)/4 < 1000
    const   DWORD   dwMinExpectedThread = 0x100;
    DWORD   dwHash = dwThreadId;

    dwHash -= dwMinExpectedThread;
    dwHash >>= 2;
    dwHash %= dwMax;
    return dwHash;
};

typedef CShareLockNH  CShareLockInstBase;
//---[ CShareLockInst ]--------------------------------------------------------
//
//
//  Description: 
//      An intstramented version of CShareLockInstBase
//  Hungarian: 
//      sli, psli
//  
//-----------------------------------------------------------------------------
class CShareLockInst : public CShareLockInstBase
{
  protected:
    //Static lock-tracking variables
    static              LIST_ENTRY  s_liLocks;
    static volatile     DWORD       s_dwLock;
    static              DWORD       s_cLockSpins;
    static              DWORD       s_dwSignature;

    static inline void AcquireStaticSpinLock();
    static inline void ReleaseStaticSpinLock();
  protected:
    DWORD               m_dwSignature;

    //Flags describing types of tracking to be performed
    DWORD               m_dwFlags;

    //List entry for list of all locks  - used by a debugger extension
    LIST_ENTRY          m_liLocks;

    //The total number of attempts to enter this lock in a shared mode
    DWORD               m_cShareAttempts;

    //The total number of attempts to enter shared that blocked
    DWORD               m_cShareAttemptsBlocked;

    //The total number ot attempts to enter this lock exclusively
    DWORD               m_cExclusiveAttempts;

    //The total number ot attempts to enter this lock exclusively that blocked
    DWORD               m_cExclusiveAttemptsBlocked;

    //Constant string descrition passed in 
    LPCSTR              m_szDescription;

    //ID of the thread that holds this lock exclusively
    DWORD               m_dwExclusiveThread;

    //Array of thread IDs that hold this lock shared
    CThreadIdBlock     *m_rgtblkSharedThreadIDs;

    //Maximum number of shared threads that can be tracked
    DWORD               m_cMaxTrackedSharedThreadIDs;

    //The current number of shared threads
    DWORD               m_cCurrentSharedThreads;

    //The most theads that have ever held this lock shared
    DWORD               m_cMaxConcurrentSharedThreads;

    //Used internally, to see if the private functions need to be called
    inline BOOL    fTrackingEnabled();
    

    BOOL    fTrackContention() 
        {return (SHARE_LOCK_INST_TRACK_CONTENTION & m_dwFlags);};

    BOOL    fTrackSharedThreads()
        {return (m_cMaxTrackedSharedThreadIDs && 
                (SHARE_LOCK_INST_TRACK_SHARED_THREADS & m_dwFlags));};

    BOOL    fTrackExclusiveThreads() 
        {return (SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS & m_dwFlags);};

    BOOL    fAssertSharedDeadlocks() 
        {return (fTrackSharedThreads() && 
                (SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS & m_dwFlags));};

    BOOL    fTrackInGlobalList()
        {return (SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST & m_dwFlags);};

    //statisics helper functions
    void LogAcquireShareLock(BOOL fTry);
    void LogReleaseShareLock();

    void PrvShareLock();
    void PrvShareUnlock();
    BOOL PrvTryShareLock();
    void PrvExclusiveLock();
    void PrvExclusiveUnlock();
    BOOL PrvTryExclusiveLock();

    void PrvAssertIsLocked();
  public:
    CShareLockInst(
        LPCSTR szDescription = NULL,
        DWORD dwFlags = SHARE_LOCK_INST_TRACK_DEFAULTS, 
        DWORD cMaxTrackedSharedThreadIDs = SHARE_LOCK_INST_DEFAULT_MAX_THREADS);

    ~CShareLockInst();

    //wrappers for sharelock functions
    inline void ShareLock();
    inline void ShareUnlock();
    inline BOOL TryShareLock();
    inline void ExclusiveLock();
    inline void ExclusiveUnlock();
    inline BOOL TryExclusiveLock();

    inline void AssertIsLocked();

};

//---[ inline ShareLock wrapper functions ]------------------------------------
//
//
//  Description: 
//      These functions are all thin wrappers for the sharelock wrapper 
//      functions.  If there is any tracking enabled for this object, then 
//      the private (non-inline) functions are called.
//
//      The idea is that you should be able to have these sharelocks in your
//      code with minimal perf-impact when logging is turned off.
//  Parameters:
//      
//  Returns:
//
//  History:
//      5/24/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::ShareLock()
{
    if (fTrackContention() || fTrackSharedThreads() || fAssertSharedDeadlocks())
        PrvShareLock();
    else
        CShareLockInstBase::ShareLock();
};


void CShareLockInst::ShareUnlock()
{
    if (fTrackSharedThreads() || fAssertSharedDeadlocks())
        PrvShareUnlock();
    else
        CShareLockInstBase::ShareUnlock();
};

BOOL CShareLockInst::TryShareLock()
{
    if (fTrackContention() || fTrackSharedThreads() || fAssertSharedDeadlocks())
        return PrvTryShareLock();
    else
        return CShareLockInstBase::TryShareLock();
};

void CShareLockInst::ExclusiveLock()
{
    if (fTrackContention() || fTrackExclusiveThreads())
        PrvExclusiveLock();
    else
        CShareLockInstBase::ExclusiveLock();
};

void CShareLockInst::ExclusiveUnlock()
{
    if (fTrackExclusiveThreads())
        PrvExclusiveUnlock();
    else
        CShareLockInstBase::ExclusiveUnlock();
};

BOOL CShareLockInst::TryExclusiveLock()
{
    if (fTrackContention() || fTrackExclusiveThreads())
        return PrvTryExclusiveLock();
    else
        return CShareLockInstBase::TryExclusiveLock();
};


//---[ AssertIsLocked ]--------------------------------------------------------
//
//
//  Description: 
//      In Debug code, will assert if this is not locked by the calling thread.
//      NOTE: This requires the following flags are specified at object
//      creation time:
//          SHARE_LOCK_INST_TRACK_SHARED_THREADS
//          SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/24/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::AssertIsLocked()
{
#ifdef DEBUG
    if ((SHARE_LOCK_INST_TRACK_SHARED_THREADS & m_dwFlags) &&
        (SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS & m_dwFlags))
    {
        PrvAssertIsLocked();
    }
#endif //DEBUG
};

#endif //__PTRWINST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\seoexports.h ===
//-----------------------------------------------------------------------------
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Description:
//      This header file defines stuff published by SEO to other (Microsoft
//      internal) projects in additon to the seo.idl file.
//
//-----------------------------------------------------------------------------

#ifndef __SEOEXPORTS_H__
#define __SEOEXPORTS_H__

class CStringGUID {
	public:
		CStringGUID() { m_bValid=FALSE; };
		CStringGUID(const CStringGUID& objGuid) { m_bValid=FALSE; Assign(objGuid); };
		CStringGUID(REFGUID rGuid) { m_bValid=FALSE; Assign(rGuid); };
		CStringGUID(LPCOLESTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(LPCSTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(const VARIANT *pvarGuid) { m_bValid=FALSE; Assign(pvarGuid); };
		CStringGUID(const VARIANT& varGuid) { m_bValid=FALSE; Assign(varGuid); };
		CStringGUID(REFGUID rGuid, DWORD dwIndex) {
			GUID tmp = rGuid;
			tmp.Data4[7] |= 0x80;
			tmp.Data2 = (WORD) (dwIndex >> 16);
			tmp.Data3 = (WORD) dwIndex;
			Assign(rGuid,dwIndex); };
		BOOL ReCalcFromGuid() {
			m_bValid = FALSE;
			if (SUCCEEDED(StringFromGUID2(m_guid,m_szGuidW,sizeof(m_szGuidW)/sizeof(m_szGuidW[0])))) {
				ATLW2AHELPER(m_szGuidA,m_szGuidW,sizeof(m_szGuidA)/sizeof(m_szGuidA[0])); m_bValid=TRUE; };
#ifdef DEBUG
			USES_CONVERSION;
			_ASSERTE(!m_bValid||(!strcmp(W2A(m_szGuidW),m_szGuidA)&&!wcscmp(m_szGuidW,A2W(m_szGuidA))));
#endif
			return (m_bValid); };
		BOOL CalcNew() {
			if (!SUCCEEDED(CoCreateGuid(&m_guid))) { m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCOLESTR pszProgID) {
			if (!pszProgID || !SUCCEEDED(CLSIDFromProgID(pszProgID,&m_guid))) {
				m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCSTR pszProgID) {
			USES_CONVERSION; return (CalcFromProgID(pszProgID?A2W(pszProgID):NULL)); };
		BOOL Assign(const CStringGUID& objGuid) { operator =(objGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid) { operator =(rGuid); return (m_bValid); };
		BOOL Assign(LPCOLESTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(LPCSTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(const VARIANT *pvarGuid) { operator =(pvarGuid); return (m_bValid); };
		BOOL Assign(const VARIANT& varGuid) { operator =(varGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid, DWORD dwIndex) {
			// For index'ed GUID's, we set the high-bit of the MAC-address in the GUID - this
			// is the multicast bit, and will never be set for any real MAC-address.  Then we
			// XOR the index value over the Data2 and Data 3 fields of the GUID.  Since we
			// leave the timestamp fields completely untouched, confidence is "high" that this
			// algorithm will never create collisions with any other GUID's.
			GUID tmp = rGuid;
			tmp.Data4[2] |= 0x80;
			tmp.Data2 ^= (WORD) (dwIndex >> 16);
			tmp.Data3 ^= (WORD) dwIndex;
			operator =(tmp);
			return (m_bValid); };
		BOOL GetIndex(REFGUID rGuid, DWORD *dwIndex) {
			// check to see if this is an indexed GUID by seeing if the
			// multicast bit is set to 1
			if ((m_guid.Data4[2] & 0x80) != 0x80) return FALSE;
			*dwIndex = 0;
			// get the high part
			*dwIndex = ((WORD) (rGuid.Data2) ^ (m_guid.Data2)) << 16;
			// get the low part
			*dwIndex += (WORD) ((rGuid.Data3) ^ (m_guid.Data3));
			// This does not check that rGuid mangles into m_guid
			// if you run it through the index function with dwIndex
			return TRUE;
		}
		operator REFGUID() { _ASSERTE(m_bValid); return (m_guid); };
		operator LPCOLESTR() { _ASSERTE(m_bValid); return (m_szGuidW); };
		operator LPCSTR() { _ASSERTE(m_bValid); return (m_szGuidA); };
		const CStringGUID& operator =(const CStringGUID& objGuid) {
			if (!objGuid) { m_bValid=FALSE; return (*this); };
			return (operator=((REFGUID) objGuid)); };
		const CStringGUID& operator =(REFGUID rGuid) {
			m_guid = rGuid; ReCalcFromGuid(); return (*this); };
		const CStringGUID& operator =(LPCOLESTR pszGuid) {
			m_bValid=FALSE;
			if (pszGuid && SUCCEEDED(CLSIDFromString((LPOLESTR) pszGuid,&m_guid))) ReCalcFromGuid();
			return (*this); };
		const CStringGUID& operator =(LPCSTR pszGuid) {
			USES_CONVERSION; return (operator=(pszGuid?A2W(pszGuid):NULL)); };
		const CStringGUID& operator =(const VARIANT *pvarGuid) {
			if (!pvarGuid) { m_bValid=FALSE; return (*this); } return (operator =(*pvarGuid)); };
		const CStringGUID& operator =(const VARIANT& varGuid) {
				CComVariant varTmp(varGuid);
				if (!SUCCEEDED(varTmp.ChangeType(VT_BSTR))) { m_bValid=FALSE; return (*this); };
				return (operator =(varTmp.bstrVal)); };
		GUID* operator &() { _ASSERTE(!m_bValid); return (&m_guid); };
		BOOL operator !() const { return (!m_bValid); };
	private:
		BOOL m_bValid;
		GUID m_guid;
		WCHAR m_szGuidW[40];
		CHAR m_szGuidA[40];
};

#endif // __SEOEXPORTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\seolib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolib.h

Abstract:

	This module contains definitions for useful utility
	classes and functions for the Server Extentions Object
	system.

Author:

	Don Dumitru (dondu@microsoft.com)

Revision History:

	dondu	05/20/97	Created.
	dondu	07/03/97	Rewrite.

--*/

#include "rwnew.h"
#include "seoexports.h"

/*

	See the ddrop2 test program for an example of how to
	use the CEventBaseDispatcher class.

*/


template<class T, DWORD dwGrowBy=4>
class CSEOGrowableList {
	public:

		CSEOGrowableList() {
			m_dwCount = 0;
			m_dwAlloc = 0;
			m_apData = NULL;
		};

		~CSEOGrowableList() {
			RemoveAll();
		};

		DWORD Count() {
			return (m_dwCount);
		};

		T* Index(DWORD dwIdx) {
		    T *pRet = NULL;

		    m_slData.ShareLock();

			if (dwIdx<m_dwCount) {
			    pRet = m_apData[dwIdx];
			}

			m_slData.ShareUnlock();

			return pRet;
		};

		T& operator[](DWORD dwIdx) {
		    T *pRet = Index(dwIdx);
		    _ASSERTE(pRet);
		    return *pRet;
		};

		virtual int Compare(T* p1, T* p2) {
			// don't sort by default
			return (1);
		};

		HRESULT Add(T* pNewData) {

			if (!pNewData) {
				return (E_POINTER);
			}

			m_slData.ExclusiveLock();

			// Check if we have space for the new item and allocate more memory if necessary
			if (m_dwCount == m_dwAlloc) {

			    // Allocate
			    T** pNewData = (T**)realloc(m_apData,sizeof(T*)*(m_dwAlloc+dwGrowBy));
			    if (!pNewData) {
				    m_slData.ExclusiveUnlock();
					return(E_OUTOFMEMORY);
			    }
			    m_apData = pNewData;
			    m_dwAlloc += dwGrowBy;

			    // Clear new memory
			    memset(m_apData+m_dwCount,0,sizeof(T*)*dwGrowBy);
			}

			// Now find the position for the new item - we loop from the
			// end to the start so that we can minimize the cost inserting
			// unsorted items
			for (DWORD dwIdx=m_dwCount;dwIdx>0;dwIdx--) {
				int iCmpRes = Compare(pNewData,m_apData[dwIdx-1]);
				if (iCmpRes < 0) {
					continue;
				}
				break;
			}

            // Now move the items past the new item and insert it
            memmove(m_apData+dwIdx+1,m_apData+dwIdx,sizeof(T*)*(m_dwCount-dwIdx));
			m_apData[dwIdx] = pNewData;
			m_dwCount++;

			m_slData.ExclusiveUnlock();

			return (S_OK);
		};

		void Remove(DWORD dwIdx, T **ppT) {
			if (!ppT) {
				_ASSERTE(FALSE);
				return;
			}

			m_slData.ExclusiveLock();

			if (dwIdx >= m_dwCount) {
				_ASSERTE(FALSE);
				*ppT = NULL;
				return;
			}
			*ppT = m_apData[dwIdx];
			memmove(&m_apData[dwIdx],&m_apData[dwIdx+1],sizeof(m_apData[0])*(m_dwCount-dwIdx-1));
			m_dwCount--;

			m_slData.ExclusiveUnlock();
		};

		void Remove(DWORD dwIdx) {
			T *pT;
			Remove(dwIdx,&pT);
			delete pT;
		};

		void RemoveAll() {

		    m_slData.ExclusiveLock();

			if (m_apData) {
				for (DWORD dwIdx=0;dwIdx<m_dwCount;dwIdx++) {
					delete m_apData[dwIdx];
				}
				free(m_apData);
			}
			m_dwCount = 0;
			m_dwAlloc = 0;
			m_apData = NULL;

			m_slData.ExclusiveUnlock();
		}

	protected:
		DWORD           m_dwCount;
		DWORD           m_dwAlloc;
		T**             m_apData;
		CShareLockNH    m_slData;
};


class CEventBaseDispatcher : public IEventDispatcher {
	public:

		CEventBaseDispatcher();

		virtual ~CEventBaseDispatcher();

		class CBinding {
			public:
				CBinding();
				virtual ~CBinding();
				virtual HRESULT Init(IEventBinding *piBinding);
				virtual int Compare(const CBinding& b) const;
				static HRESULT InitRuleEngine(IEventBinding *piBinding, REFIID iidDesired, IUnknown **ppUnkRuleEngine);
				virtual HRESULT InitRuleEngine();
			public:
				BOOL m_bIsValid;
				CComPtr<IEventBinding> m_piBinding;
				BOOL m_bExclusive;
				DWORD m_dwPriority;
		};

		class CBindingList : public CSEOGrowableList<CBinding> {
			public:
				virtual int Compare(CBinding* p1, CBinding* p2);
		};

		class CParams {
			public:
				virtual HRESULT CheckRule(CBinding& bBinding);
					// returns S_OK if the object should be called
					// returns S_FALSE if the object should not be called
					// any other return value causes the object to not be called
				virtual HRESULT CallObject(IEventManager *piManager, CBinding& bBinding);
					// returns S_OK if the object was called
					// returns S_FALSE if the object was called and if no other objects should be called
					// returns FAILED() if the object was not called
				virtual HRESULT CallObject(CBinding& bBinding, IUnknown *pUnkSink);
					// returns S_OK if the object was called
					// returns S_FALSE if the object was called and if no other objects should be called
					// returns FAILED() if the object was not called
				virtual HRESULT Abort();
					// returns S_OK if processing should end
					// returns S_FALSE if processing should continue
					// any other return value causes processing to continue
		};

		virtual HRESULT Dispatcher(REFGUID rguidEventType, CParams *pParams);
		// returns S_OK if at least one sink was called
		// returns S_FALSE if no sinks were called
		// returns FAILED() if some super-catastrophic error happened

	// IEventDispatcher
	public:
		HRESULT STDMETHODCALLTYPE SetContext(REFGUID rguidEventType,
											 IEventRouter *piRouter,
											 IEventBindings *piBindings);

	public:

		class CETData : public CBindingList {
			public:
				CETData();
				virtual ~CETData();
			public:
				GUID m_guidEventType;
		};

		class CETDataList : public CSEOGrowableList<CETData> {
			public:
				CETData* Find(REFGUID guidEventType);
		};

		virtual HRESULT AllocBinding(REFGUID rguidEventType,
									 IEventBinding *pBinding,
									 CBinding **ppNewBinding);
		virtual HRESULT AllocETData(REFGUID rguidEventType,
									IEventBindings *piBindings,
									CETData **ppNewETData);

		CComPtr<IEventRouter> m_piRouter;
		CETDataList m_Data;
		CComPtr<IEventManager> m_piEventManager;
};

class CEventCreateOptionsBase : public IEventCreateOptions {
	HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riidDesired, LPVOID *ppvResult) {

		if (ppvResult) {
			*ppvResult = NULL;
		}
		if (!ppvResult) {
			return (E_NOTIMPL);
		}
		if (riidDesired == IID_IUnknown) {
			*ppvResult = (IUnknown *) this;
		} else if (riidDesired == IID_IDispatch) {
			*ppvResult = (IDispatch *) this;
		} else if (riidDesired == IID_IEventCreateOptions) {
			*ppvResult = (IEventCreateOptions *) this;
		}
		return ((*ppvResult)?S_OK:E_NOINTERFACE);
	};
	ULONG STDMETHODCALLTYPE AddRef() {
		return (2);
	};
	ULONG STDMETHODCALLTYPE Release() {
		return (1);
	};
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE GetTypeInfo(unsigned int, LCID, ITypeInfo **) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID, LPOLESTR *, unsigned int, LCID, DISPID *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, unsigned int *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE CreateBindCtx(DWORD, IBindCtx **) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE MkParseDisplayName(IBindCtx *, LPCOLESTR, ULONG *, IMoniker **) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE BindToObject(IMoniker *, IBindCtx *, IMoniker *, REFIID, LPVOID *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE CoCreateInstance(REFCLSID, IUnknown *, DWORD, REFIID, LPVOID *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE Init(REFIID riidDesired, IUnknown **ppObject, IEventBinding *pBinding, IUnknown *pInitProps) {
		return (E_NOTIMPL);
	};
};


// All these functions return S_OK if they succeed, and S_FALSE if the source type or source is
// not present.  They return FAILED() on various catastrophic errors.
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSource, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventSource **ppSource);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSource, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventRouter **ppRouter);

STDMETHODIMP SEOGetServiceHandle(IUnknown **ppUnkHandle);

STDMETHODIMP SEOCreateObject(VARIANT *pvarClass, IEventBinding *pBinding, IUnknown *pInitProperties, REFIID iidDesired, IUnknown **ppUnkObject);
STDMETHODIMP SEOCreateObjectEx(VARIANT *pvarClass, IEventBinding *pBinding, IUnknown *pInitProperties, REFIID iidDesired, IUnknown *pUnkCreateOptions, IUnknown **ppUnkObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\signatur.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	signatur.h

Abstract:

	This module contains the definition of object signatures

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/03/98	created

--*/

#ifndef _SIGNATUR_H_
#define _SIGNATUR_H_

// =================================================================
// Signatures
//

//
// CMailMsg
//
#define CMAILMSG_SIGNATURE_VALID						((DWORD)'MMCv')
#define CMAILMSG_SIGNATURE_INVALID						((DWORD)'MMCi')

//
// Block manager
//
#define BLOCK_HEAP_SIGNATURE_VALID						((DWORD)'SHPv')
#define BLOCK_HEAP_SIGNATURE_INVALID					((DWORD)'SHPi')

#define BLOCK_CONTEXT_SIGNATURE_VALID					((DWORD)'SBCv')
#define BLOCK_CONTEXT_SIGNATURE_INVALID					((DWORD)'SBCi')

//
// Property table
//
#define CPROPERTY_TABLE_SIGNATURE_VALID					((DWORD)'TPCv')
#define CPROPERTY_TABLE_SIGNATURE_INVALID				((DWORD)'TPCi')

#define GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID			((DWORD)'TPGv')
#define RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID		((DWORD)'TPLv')
#define RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID		((DWORD)'TPRv')
#define PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID		((DWORD)'TPMv')
#define PTABLE_INSTANCE_SIGNATURE_INVALID				((DWORD)'TPXi')

#define PROPERTY_FRAGMENT_SIGNATURE_VALID				((DWORD)'SFPv')
#define PROPERTY_FRAGMENT_SIGNATURE_INVALID				((DWORD)'SFPi')



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\synconst.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

        synconst.h

Abstract:

        This module contains the definition of some of the definitions for
		synchronization

Author:

        Keith Lau       (keithlau@microsoft.com)

Revision History:

        keithlau        03/02/98        created

--*/

#ifndef __SYNCONST_H__
#define __SYNCONST_H__

// Lock ranks
extern int		rankBlockMgr;
extern int		rankRecipientHash;
extern int		rankLoggingPropertyBag;

// Instance names
extern TCHAR 			*szBlockMgr;
extern TCHAR			*szRecipientHash;
extern TCHAR			*szLoggingPropertyBag;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\seolib2.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	seolib2.h

Abstract:

	This module contains definitions for useful utility
	classes and functions for the Server Extentions Object
	system.

Author:

	Don Dumitru (dondu@microsoft.com)

Revision History:

	dondu	06/22/98	Created.

--*/


class __declspec(uuid("208DB171-097B-11d2-A011-00C04FA37348")) CEDEnumGUID :
	public IEnumGUID,	// list this first
	public CComObjectRootEx<CComMultiThreadModelNoCS>
{
	public:
	    DECLARE_PROTECT_FINAL_CONSTRUCT();
	    
	    DECLARE_GET_CONTROLLING_UNKNOWN();

	    DECLARE_NOT_AGGREGATABLE(CEDEnumGUID);

	    BEGIN_COM_MAP(CEDEnumGUID)
	        COM_INTERFACE_ENTRY(IEnumGUID)
			COM_INTERFACE_ENTRY_IID(__uuidof(CEDEnumGUID),CEDEnumGUID)
	    END_COM_MAP()

	public:
		CEDEnumGUID() {
			m_dwIdx = 0;
			m_ppGUID = NULL;
		};
		static HRESULT CreateNew(IUnknown **ppUnkNew, const GUID **ppGUID, DWORD dwIdx=0) {
			HRESULT hrRes;
			CComQIPtr<CEDEnumGUID,&__uuidof(CEDEnumGUID)> pInit;

			if (ppUnkNew) {
				*ppUnkNew = NULL;
			}
			if (!ppUnkNew) {
				return (E_POINTER);
			}
			if (!ppGUID) {
				return E_INVALIDARG;
			}
			hrRes = CComObject<CEDEnumGUID>::_CreatorClass::CreateInstance(NULL,
																		   __uuidof(IEnumGUID),
																		   (LPVOID *) ppUnkNew);
			if (SUCCEEDED(hrRes)) {
				pInit = *ppUnkNew;
				if (!pInit) {
					hrRes = E_NOINTERFACE;
				}
			}
			if (SUCCEEDED(hrRes)) {
				hrRes = pInit->InitNew(dwIdx,ppGUID);
			}
			if (!SUCCEEDED(hrRes) && *ppUnkNew) {
				(*ppUnkNew)->Release();
				*ppUnkNew = NULL;
			}
			return (hrRes);
		};

	// IEnumGUID
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, GUID *pelt, ULONG *pceltFetched) {
			HRESULT hrRes = S_FALSE;

			if (!m_ppGUID) {
				return (E_FAIL);
			}
			if (pceltFetched) {
				*pceltFetched = 0;
			}
			if (!pelt) {
				return (E_POINTER);
			}
			if ((celt > 1) && !pceltFetched) {
				return (E_INVALIDARG);
			}
			while (celt && (*(m_ppGUID[m_dwIdx]) != GUID_NULL)) {
				*pelt = *(m_ppGUID[m_dwIdx]);
				pelt++;
				celt--;
				m_dwIdx++;
				if (pceltFetched) {
					(*pceltFetched)++;
				}
			}
			if (!celt) {
				hrRes = S_OK;
			}
			return (hrRes);
		};
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt) {
			HRESULT hrRes = S_FALSE;

			if (!m_ppGUID) {
				return (E_FAIL);
			}
			while (celt && (*(m_ppGUID[m_dwIdx]) != GUID_NULL)) {
				celt--;
				m_dwIdx++;
			}
			if (!celt) {
				hrRes = S_OK;
			}
			return (hrRes);
		};
		HRESULT STDMETHODCALLTYPE Reset() {
			m_dwIdx = 0;
			return (S_OK);
		};
		HRESULT STDMETHODCALLTYPE Clone(IEnumGUID **ppClone) {
			return (CreateNew((IUnknown **) ppClone,m_ppGUID,m_dwIdx));
		};

	private:
		HRESULT InitNew(DWORD dwIdx, const GUID **ppGUID) {
			m_dwIdx = dwIdx;
			m_ppGUID = ppGUID;
			return (S_OK);
		};
		DWORD m_dwIdx;
		const GUID **m_ppGUID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\writebuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    writebuf.h

Abstract:

    This module contains class declarations/definitions for

        CFlatFileWriteBuf
        
    **** Overview ****

    The write buffer that buffers up a batch of writes for flatfile.
    Using sequential scan is good for reads, but may not be sufficient
    for sequential writes.  This buffer is only enabled when data
    being written to the file is not critical ( meaning losing of data
    is OK if the system crashes ).
    
Author:

    Kangrong Yan    ( KangYan )     5-6-1999

Revision History:

--*/
#ifndef _WRITEBUF_H_
#define _WRITEBUF_H_

class CFlatFile;

class CFlatFileWriteBuf {   //wb

public:

    //
    // Constructor, destructor
    //

    CFlatFileWriteBuf( CFlatFile* pParentFile );
    ~CFlatFileWriteBuf();

    //
    // Write the byte range
    //
    
    HRESULT WriteFileBuffer( 
                const DWORD   dwOffset, 
                const PBYTE   pb, 
                const DWORD   cb,
                PDWORD  pdwOffset,
                PDWORD  pcbWritten );
    
    //
    // Flush the buffer into the file
    //

    HRESULT FlushFile();

    //
    // Tell the outside world if we are enabled
    //

    BOOL IsEnabled() const;

    //
    // Enable the write buffer and give it the buffer size
    //

    VOID Enable( const DWORD cbBuffer );

    //
    // Check to see if the buffer needs flush
    //

    BOOL NeedFlush() const;

private:

    //
    // Private functions
    //

    HRESULT WriteFileReal(
                    const DWORD dwOffset,
                    const PBYTE pbBuffer,
                    const DWORD cbBuffer,
                    PDWORD      pdwOffset,
                    PDWORD      pcbWritten
                    );

    DWORD BufferAvail() const;

    VOID FillBuffer(
                    const DWORD     dwOffset,
                    const PBYTE     pbBuffer,
                    const DWORD     cbBuffer,
                    PDWORD          pdwOffset,
                    PDWORD          pcbWritten
                    );

    BOOL NeedFlush( 
                    const DWORD dwOffset,
                    const DWORD cbData 
                    ) const;

    //
    // Back pointer to parent flat file
    //

    CFlatFile*  m_pParentFile;

    //
    // Buffer pointer
    //

    PBYTE m_pbBuffer;

    //
    // Buffer size
    //

    DWORD m_cbBuffer;

    //
    // Starting offset that we have buffered
    //

    DWORD m_iStart;

    //
    // Ending offset that we have buffered
    //

    DWORD m_iEnd;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\smtpguid.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: smtpguid.h
//
// Contents: Event related GUIDS published from SMTPSVC
//
// Instructions: Include this file to declare the various
//               GUIDS/strings as external global variables.
//               To actually define these global variables,
//               #define SMTPINITGUID and #include <initguid.h> before this
//               header file.
//
// History:
// Jeffrey C Stamerjohn 1998/07/14 15:22:29: Created.
//
//-------------------------------------------------------------
#ifndef __SMTPGUID_H__
#define __SMTPGUID_H__

#ifdef SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    CONST WCHAR Name##[] = L##Value

#else //SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    extern CONST WCHAR Name##[]

#endif //SMTPINITGUID

// SMTP SourceType GUID
// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSourceType, "{fb65c4dc-e468-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTP_SOURCE_TYPE, 0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
** SMTP Source GUID
*/
// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSvcSource, "{1b3c0666-e470-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTPSVC_SOURCE, 0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
**  Protocol Events
*/
// SMTP OnInboundCommand
// {F6628C8D-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnInboundCommand, "{F6628C8D-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_INBOUND_COMMAND, 0xf6628c8d, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnServerResponse
// {F6628C8E-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnServerResponse, "{F6628C8E-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SERVER_RESPONSE, 0xf6628c8e, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionStart
// {F6628C8F-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionStart, "{F6628C8F-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_START, 0xf6628c8f, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnMessageStart
// {F6628C90-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnMessageStart, "{F6628C90-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_MESSAGE_START, 0xf6628c90, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnPerRecipient
// {F6628C91-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPerRecipient, "{F6628C91-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_PER_RECIPIENT, 0xf6628c91, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// Smtp OnBeforeData
// {F6628C92-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnBeforeData, "{F6628C92-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_BEFORE_DATA, 0xf6628c92, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionEnd
// {F6628C93-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionEnd, "{F6628C93-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_END, 0xf6628c93, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);


/*
** Transport Events
*/

// SMTP Store Events
// {59175850-e533-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpStoreDriver, "{59175850-e533-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(CATID_SMTP_STORE_DRIVER, 0x59175850, 0xe533, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// SMTP OnTransportSubmission
// {FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportSubmission, "{FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_SUBMISSION, 0xff3caa23, 0xb9, 0x11d2, 0x9d, 0xfb, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP onPrecategorize
// {A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPrecategorize, "{A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_PRECATEGORIZE, 0xa3acfb0d, 0x83ff, 0x11d2, 0x9e, 0x14, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP Categorizer events
// {960252A3-0A3A-11d2-9E00-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnCategorize, "{960252A3-0A3A-11d2-9E00-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_CATEGORIZE, 0x960252a3, 0xa3a, 0x11d2, 0x9e, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP onPostcategorize
// {76719654-05A6-11d2-9DFD-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPostcategorize, "{76719654-05A6-11d2-9dfd-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_POSTCATEGORIZE,
0x76719654, 0x5a6, 0x11d2, 0x9d, 0xfd, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP OnTransportRouter
// {283430C9-1850-11d2-9E03-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportRouter, "{283430C9-1850-11d2-9E03-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_ROUTER, 0x283430c9, 0x1850, 0x11d2, 0x9e, 0x3, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP MsgTrackLog
// {c6df52aa-7db0-11d2-94f4-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMsgTrackLog, "{c6df52aa-7db0-11d2-94f4-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MSGTRACKLOG, 0xc6df52aa, 0x7db0, 0x11d2, 0x94, 0xf4, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP DnsResolver
// {bd0b4366-8e03-11d2-94f6-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpDnsResolver, "{bd0b4366-8e03-11d2-94f6-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_DNSRESOLVERRECORDSINK, 0xbd0b4366, 0x8e03, 0x11d2, 0x94, 0xf6, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP MaxMsgSize
// {ebf159de-a67e-11d2-94f7-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMaxMsgSize, "{ebf159de-a67e-11d2-94f7-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MAXMSGSIZE, 0xebf159de, 0xa67e, 0x11d2, 0x94, 0xf7, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP Log
// {93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpLog, "{93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}");
DEFINE_GUID(CATID_SMTP_LOG, 0x93d0a538, 0x2c1e, 0x4b68, 0xa7, 0xc9, 0xd7, 0x3a, 0x8a, 0xa6, 0xee, 0x97);

// SMTP GET_AUX_DOMAIN_INFO_FLAGS
// {84ff368a-fab3-43d7-bcdf-692c5b46e6b1}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpGetAuxDomainInfoFlags, "{84ff368a-fab3-43d7-bcdf-692c5b46e6b1}");
DEFINE_GUID(CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS, 0x84ff368a, 0xfab3, 0x43d7, 0xbc, 0xdf, 0x69, 0x2c, 0x5b, 0x46, 0xe6, 0xb1);

//
// CLSID of the CoCreateable categorizer
//
// {B23C35B7-9219-11d2-9E17-00C04FA322BA}"
DEFINE_GUID(CLSID_SmtpCat, 0xb23c35b7, 0x9219, 0x11d2, 0x9e, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

//
// SMTP DSN
//
// {22B55731-F5F8-4d23-BD8F-87B52371A73A}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpDSN, "{22B55731-F5F8-4D23-BD8F-87B52371A73A}");
DEFINE_GUID(CATID_SMTP_DSN, 0x22b55731, 0xf5f8, 0x4d23, 0xbd, 0x8f, 0x87, 0xb5, 0x23, 0x71, 0xa7, 0x3a);

#define SZ_PROGID_SMTPCAT   "Smtp.Cat"


#endif //__SMTPGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\smtpinet.h ===
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  SMTP specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define SMTP_SERVICE_NAME          TEXT("SMTPSVC")
# define SMTP_SERVICE_NAME_A        "SMTPSVC"
# define SMTP_SERVICE_NAME_W        L"SMTPSVC"
# define SMTP_MD_ROOT_PATH          "/LM/SmtpSvc/"
# define SMTP_MD_LOCAL_DOMAINS_PATH "/LocalDomains"
# define SMTP_MD_DOMAIN_ROUTES_PATH "/DomainRoutes"

//
//   Client Interface Name for RPC connections over named pipes
//

# define  SMTP_INTERFACE_NAME     SMTP_SERVICE_NAME
# define  SMTP_NAMED_PIPE         TEXT("\\PIPE\\") ## SMTP_INTERFACE_NAME
# define  SMTP_NAMED_PIPE_W       L"\\PIPE\\" ## SMTP_SERVICE_NAME_W


//service location junk
#define INET_SMTP_SVCLOC_ID         (ULONGLONG)(0x2000000000000000)

//Domain routing table bit fields
typedef DWORD DOMAIN_ROUTE_ACTION_TYPE;

#define SMTP_NO_ACTION      ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000000))
#define SMTP_DROP           ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000001))
#define SMTP_SMARTHOST      ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000002))
#define SMTP_SSL            ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000004))
#define SMTP_SASL           ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000008))
#define SMTP_ALIAS          ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000010))
#define SMTP_DELIVER        ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000020))
#define SMTP_DEFAULT        ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000040))
#define SMTP_AUTH_NTLM      ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000080))
#define SMTP_AUTH_CLEARTEXT ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000100))
#define SMTP_ETRN_CMD       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000200))
#define SMTP_IP_RELAY       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000400))
#define SMTP_AUTH_RELAY     ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000800))
#define SMTP_DOMAIN_RELAY   ((DOMAIN_ROUTE_ACTION_TYPE)(0x00001000))
#define SMTP_CSIDE_TURN     ((DOMAIN_ROUTE_ACTION_TYPE)(0x00002000))
#define SMTP_CSIDE_ETRN     ((DOMAIN_ROUTE_ACTION_TYPE)(0x00004000))
#define SMTP_DISABLE_ETRN   ((DOMAIN_ROUTE_ACTION_TYPE)(0x00008000))
#define SMTP_CHUNKING       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00010000))
#define SMTP_DISABLE_CHUNK  ((DOMAIN_ROUTE_ACTION_TYPE)(0x00020000))
#define SMTP_DISABLE_BMIME  ((DOMAIN_ROUTE_ACTION_TYPE)(0x00040000))
#define SMTP_DISABLE_DSN    ((DOMAIN_ROUTE_ACTION_TYPE)(0x00080000))
#define SMTP_DISABLE_PIPELINE ((DOMAIN_ROUTE_ACTION_TYPE)(0x00100000))
#define SMTP_AUTH_KERBEROS  ((DOMAIN_ROUTE_ACTION_TYPE)(0x00200000))
#define SMTP_USE_HELO       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00400000))
#define SMTP_DISABLE_DROP_QUOTA ((DOMAIN_ROUTE_ACTION_TYPE)(0x00800000))

#define SMTP_ALL_ROUTE_FLAGS    ( \
	SMTP_DROP | SMTP_SMARTHOST | SMTP_SSL | SMTP_SASL |\
	SMTP_ALIAS | SMTP_DELIVER | SMTP_DEFAULT | SMTP_AUTH_NTLM |\
	SMTP_AUTH_CLEARTEXT | SMTP_ETRN_CMD | SMTP_IP_RELAY | SMTP_AUTH_RELAY |\
	SMTP_DOMAIN_RELAY | SMTP_CSIDE_TURN | SMTP_CSIDE_ETRN | SMTP_DISABLE_ETRN |\
	SMTP_CHUNKING | SMTP_DISABLE_CHUNK | SMTP_DISABLE_BMIME | SMTP_DISABLE_DSN |\
	SMTP_DISABLE_PIPELINE | SMTP_AUTH_KERBEROS | SMTP_USE_HELO | SMTP_DISABLE_DROP_QUOTA \
	)


#define SMTP_ALL_AUTH_FLAGS ( \
                            SMTP_AUTH_NTLM |\
                            SMTP_AUTH_CLEARTEXT \
                            )
//

typedef DWORD INBOUND_COMMAND_SUPPORT_OPTIONS;

#define SMTP_I_SUPPORT_VRFY         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000001))
#define SMTP_I_SUPPORT_VRFY_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000002))
#define SMTP_I_SUPPORT_VRFY_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000004))
#define SMTP_I_SUPPORT_EXPN         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000008))
#define SMTP_I_SUPPORT_EXPN_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000010))
#define SMTP_I_SUPPORT_EXPN_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000020))
#define SMTP_I_SUPPORT_DSN          ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000040))
#define SMTP_I_SUPPORT_ETRN         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000080))
#define SMTP_I_SUPPORT_ETRN_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000100))
#define SMTP_I_SUPPORT_ETRN_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000200))
#define SMTP_I_SUPPORT_TURN         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000400))
#define SMTP_I_SUPPORT_TURN_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000800))
#define SMTP_I_SUPPORT_ECODES       ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00001000))
#define SMTP_I_SUPPORT_PIPELINING   ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00002000))
#define SMTP_I_SUPPORT_AUTH         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00004000))
#define SMTP_I_SUPPORT_AUTH_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00008000))
#define SMTP_I_SUPPORT_LOGIN        ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00010000))
#define SMTP_I_SUPPORT_LOGIN_ON_SSL ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00020000))
#define SMTP_I_SUPPORT_HELP         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00040000))
#define SMTP_I_SUPPORT_HELP_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00080000))
#define SMTP_I_SUPPORT_CHUNK        ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00100000))
#define SMTP_I_SUPPORT_BMIME        ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00200000))
#define SMTP_I_SUPPORT_8BITMIME    ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00400000))

#define SMTP_DEFAULT_CMD_SUPPORT    ( \
                                SMTP_I_SUPPORT_VRFY |\
                                SMTP_I_SUPPORT_DSN |\
                                SMTP_I_SUPPORT_TURN |\
                                SMTP_I_SUPPORT_ETRN |\
                                SMTP_I_SUPPORT_AUTH |\
                                SMTP_I_SUPPORT_LOGIN |\
                                SMTP_I_SUPPORT_HELP |\
                                SMTP_I_SUPPORT_CHUNK |\
                                SMTP_I_SUPPORT_BMIME |\
                                SMTP_I_SUPPORT_ECODES |\
                                SMTP_I_SUPPORT_PIPELINING |\
                                SMTP_I_SUPPORT_8BITMIME )

#define SMTP_IS_SSL_CONNECTION (0x00000001)
#define SMTP_IS_AUTH_CONNECTION (0x00000002)

//

typedef DWORD OUTBOUND_COMMAND_SUPPORT_OPTIONS;

#define SMTP_0_SUPPORT_DSN      ((OUTBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000001))
#define SMTP_0_FORCE_CHUNK    ((OUTBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000002))
#define SMTP_0_SUPPORT_BMIME    ((OUTBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000004))

#define SMTP_DEFAULT_OUTBOUND_SUPPORT   ( \
                                    SMTP_0_SUPPORT_DSN )

typedef DWORD REVERSE_DNS_OPTIONS;

#define SMTP_I_HELOEHLO_RDNS            ((REVERSE_DNS_OPTIONS)(0x00000001))
#define SMTP_I_HELOEHLO_RDNS_DISCONNECT ((REVERSE_DNS_OPTIONS)(0x00000002))
#define SMTP_I_MAILFROM_RDNS            ((REVERSE_DNS_OPTIONS)(0x00000004))
#define SMTP_I_MAILFROM_RDNS_DISCONNECT ((REVERSE_DNS_OPTIONS)(0x00000008))


//  these should be added in the
//  metabase with a user type of IIS_MD_UT_SERVER
//

#define MD_COMMAND_LOG_MASK             (SMTP_MD_ID_BEGIN_RESERVED )			// 36864
#define MD_FLUSH_MAIL_FILE              (SMTP_MD_ID_BEGIN_RESERVED+2 )
#define MD_BATCH_MSG_LIMIT              (SMTP_MD_ID_BEGIN_RESERVED+7 )
#define MD_MAX_MAIL_OBJECTS             (SMTP_MD_ID_BEGIN_RESERVED+9 )
#define MD_ROUTING_THREADS              (SMTP_MD_ID_BEGIN_RESERVED+10 )
#define MD_MAIL_QUEUE_DIR               (SMTP_MD_ID_BEGIN_RESERVED+11 )
#define MD_SHOULD_PICKUP_MAIL           (SMTP_MD_ID_BEGIN_RESERVED+12 )
#define MD_MAX_DIR_BUFFERS              (SMTP_MD_ID_BEGIN_RESERVED+13 )
#define MD_MAX_DIR_CHANGE_IO_SIZE       (SMTP_MD_ID_BEGIN_RESERVED+14 )
#define MD_MAX_DIR_PENDING_IOS          (SMTP_MD_ID_BEGIN_RESERVED+15 )
#define MD_MAIL_PICKUP_DIR              (SMTP_MD_ID_BEGIN_RESERVED+16 )			// 36880
#define MD_SHOULD_DELIVER               (SMTP_MD_ID_BEGIN_RESERVED+17 )
#define MD_MAIL_DROP_DIR                (SMTP_MD_ID_BEGIN_RESERVED+18 )
#define MD_ROUTING_DLL                  (SMTP_MD_ID_BEGIN_RESERVED+19 )
#define MD_REVERSE_NAME_LOOKUP          (SMTP_MD_ID_BEGIN_RESERVED+20 )
#define MD_NAME_RESOLUTION_TYPE         (SMTP_MD_ID_BEGIN_RESERVED+21 )
#define MD_HOP_COUNT                    (SMTP_MD_ID_BEGIN_RESERVED+22 )
#define MD_MAX_SMTP_ERRORS              (SMTP_MD_ID_BEGIN_RESERVED+23 )
#define MD_MAX_MSG_SIZE                 (SMTP_MD_ID_BEGIN_RESERVED+27 )
#define MD_MAX_MSG_SIZE_B4_CLOSE        (SMTP_MD_ID_BEGIN_RESERVED+28 )
//#define MD_OUTBOUND_TIMEOUT             (SMTP_MD_ID_BEGIN_RESERVED+29 )
#define MD_MAX_OUTBOUND_CONNECTION      (SMTP_MD_ID_BEGIN_RESERVED+30 )
#define MD_MAX_RECIPIENTS               (SMTP_MD_ID_BEGIN_RESERVED+31 )
#define MD_LOCAL_RETRY_ATTEMPTS         (SMTP_MD_ID_BEGIN_RESERVED+32 )
#define MD_LOCAL_RETRY_MINUTES          (SMTP_MD_ID_BEGIN_RESERVED+33 )
#define MD_REMOTE_RETRY_ATTEMPTS        (SMTP_MD_ID_BEGIN_RESERVED+34 )
#define MD_REMOTE_RETRY_MINUTES         (SMTP_MD_ID_BEGIN_RESERVED+35 )
//#define MD_SHARE_RETRY_MINUTES          (SMTP_MD_ID_BEGIN_RESERVED+36 )			// 36900
#define MD_SHOULD_PIPELINE_OUT          (SMTP_MD_ID_BEGIN_RESERVED+37 )
#define MD_SHOULD_PIPELINE_IN           (SMTP_MD_ID_BEGIN_RESERVED+38 )
#define MD_SMARTHOST_TYPE               (SMTP_MD_ID_BEGIN_RESERVED+41 )
#define MD_SMARTHOST_NAME               (SMTP_MD_ID_BEGIN_RESERVED+42 )
#define MD_CONNECT_RESPONSE             (SMTP_MD_ID_BEGIN_RESERVED+43 )
#define MD_DEFAULT_DOMAIN_VALUE         (SMTP_MD_ID_BEGIN_RESERVED+44 )
#define MD_BAD_MAIL_DIR                 (SMTP_MD_ID_BEGIN_RESERVED+45 )
#define MD_ROUTING_SOURCES              (SMTP_MD_ID_BEGIN_RESERVED+46 )
//#define MD_REMOTE_HANG_TIME             (SMTP_MD_ID_BEGIN_RESERVED+47 )
#define MD_MASQUERADE_NAME              (SMTP_MD_ID_BEGIN_RESERVED+48 )
#define MD_DO_MASQUERADE                (SMTP_MD_ID_BEGIN_RESERVED+49 )
#define MD_REMOTE_SMTP_PORT             (SMTP_MD_ID_BEGIN_RESERVED+50 )

// added by feisu
//#define MD_SSLPORT                      (SMTP_MD_ID_BEGIN_RESERVED+51 )
#define MD_POSTMASTER_EMAIL             (SMTP_MD_ID_BEGIN_RESERVED+52 )
#define MD_POSTMASTER_NAME              (SMTP_MD_ID_BEGIN_RESERVED+53 )
#define MD_ETRN_DAYS                    (SMTP_MD_ID_BEGIN_RESERVED+54 )
// end added by feisu

#define MD_LOCAL_DOMAINS                (SMTP_MD_ID_BEGIN_RESERVED+55)
#define MD_DOMAIN_ROUTING               (SMTP_MD_ID_BEGIN_RESERVED+56)			// 36920
#define MD_REMOTE_TIMEOUT               (SMTP_MD_ID_BEGIN_RESERVED+57)

#define MD_SEND_NDR_TO                  (SMTP_MD_ID_BEGIN_RESERVED+58)
#define MD_SEND_BAD_TO                  (SMTP_MD_ID_BEGIN_RESERVED+59)
#define MD_ALWAYS_USE_SSL               (SMTP_MD_ID_BEGIN_RESERVED+60)
#define MD_MAX_OUT_CONN_PER_DOMAIN      (SMTP_MD_ID_BEGIN_RESERVED+61)
#define MD_LIMIT_REMOTE_CONNECTIONS     (SMTP_MD_ID_BEGIN_RESERVED+62)
#define MD_REMOTE_SECURE_PORT           (SMTP_MD_ID_BEGIN_RESERVED+65)
//#define MD_SORT_TEMP_DIR                (SMTP_MD_ID_BEGIN_RESERVED+66)
#define MD_SMTP_SERVICE_VERSION         (SMTP_MD_ID_BEGIN_RESERVED+67)

//#define MD_SMTP_EXTENSION_DLLS          (SMTP_MD_ID_BEGIN_RESERVED+68)
//#define MD_SMTP_NUM_RESOLVER_SOCKETS    (SMTP_MD_ID_BEGIN_RESERVED+69)
//#define MD_SMTP_USE_MX_RESOLVER         (SMTP_MD_ID_BEGIN_RESERVED+70)
#define MD_FQDN_VALUE                   (SMTP_MD_ID_BEGIN_RESERVED+71)
#define MD_UPDATED_FQDN                 (SMTP_MD_ID_BEGIN_RESERVED+72)
#define MD_UPDATED_DEFAULT_DOMAIN       (SMTP_MD_ID_BEGIN_RESERVED+73)
#define MD_ETRN_SUBDOMAINS              (SMTP_MD_ID_BEGIN_RESERVED+74)
//#define MD_MAX_POOL_THREADS             (SMTP_MD_ID_BEGIN_RESERVED+75)
#define MD_SASL_LOGON_DOMAIN            (SMTP_MD_ID_BEGIN_RESERVED+76)			// 36940
//#define MD_SERVER_SS_AUTH_MAPPING       (SMTP_MD_ID_BEGIN_RESERVED+77)
#define MD_SMTP_CLEARTEXT_AUTH_PROVIDER (SMTP_MD_ID_BEGIN_RESERVED+78)
//#define MD_ALWAYS_USE_SASL              (SMTP_MD_ID_BEGIN_RESERVED+79)
//#define MD_SMTP_AUTHORIZATION           (SMTP_MD_ID_BEGIN_RESERVED+80)
#define MD_MAX_SMTP_AUTHLOGON_ERRORS    (SMTP_MD_ID_BEGIN_RESERVED+81)

#define MD_ROUTE_ACTION                 (SMTP_MD_ID_BEGIN_RESERVED+82)
#define MD_ROUTE_ACTION_TYPE            (SMTP_MD_ID_BEGIN_RESERVED+83)
#define MD_ROUTE_USER_NAME              (SMTP_MD_ID_BEGIN_RESERVED+84)
#define MD_ROUTE_PASSWORD               (SMTP_MD_ID_BEGIN_RESERVED+85)

#define MD_SMTP_DS_TYPE                 (SMTP_MD_ID_BEGIN_RESERVED+86)
#define MD_SMTP_DS_DATA_DIRECTORY       (SMTP_MD_ID_BEGIN_RESERVED+87)
#define MD_SMTP_DS_DEFAULT_MAIL_ROOT    (SMTP_MD_ID_BEGIN_RESERVED+88)
#define MD_SMTP_DS_BIND_TYPE            (SMTP_MD_ID_BEGIN_RESERVED+89)
#define MD_SMTP_DS_SCHEMA_TYPE          (SMTP_MD_ID_BEGIN_RESERVED+90)
#define MD_SMTP_DS_HOST                 (SMTP_MD_ID_BEGIN_RESERVED+91)
#define MD_SMTP_DS_NAMING_CONTEXT       (SMTP_MD_ID_BEGIN_RESERVED+92)
#define MD_SMTP_DS_ACCOUNT              (SMTP_MD_ID_BEGIN_RESERVED+93)
#define MD_SMTP_DS_PASSWORD             (SMTP_MD_ID_BEGIN_RESERVED+94)
//#define MD_SMTP_DS_MAX_RESOLVE_BUFFERS  (SMTP_MD_ID_BEGIN_RESERVED+95)
//#define MD_SMTP_DS_MAX_VIRTUAL_SERVERS  (SMTP_MD_ID_BEGIN_RESERVED+96)			// 36960
//#define MD_SMTP_DS_MAX_HANDLE_CACHE_ENTRIES  (SMTP_MD_ID_BEGIN_RESERVED+97)
//#define MD_SMTP_DS_SORT_THRESHOLD       (SMTP_MD_ID_BEGIN_RESERVED+98)
//#define MD_SMTP_PREFERRED_AUTH          (SMTP_MD_ID_BEGIN_RESERVED+99)
#define MD_SMTP_MAX_REMOTEQ_THREADS     (SMTP_MD_ID_BEGIN_RESERVED+100)
#define MD_SMTP_MAX_LOCALQ_THREADS      (SMTP_MD_ID_BEGIN_RESERVED+101)
#define MD_SMTP_AUTHORIZED_TURN_LIST    (SMTP_MD_ID_BEGIN_RESERVED+102)
#define MD_SMTP_CSIDE_ETRN_DELAY        (SMTP_MD_ID_BEGIN_RESERVED+103)
#define MD_SMTP_CSIDE_ETRN_DOMAIN       (SMTP_MD_ID_BEGIN_RESERVED+104)
//#define MD_SMTP_VALIDATE_HELO_ARG       (SMTP_MD_ID_BEGIN_RESERVED+105)
#define MD_SMTP_IP_RELAY_ADDRESSES      (SMTP_MD_ID_BEGIN_RESERVED+106)

//#define MD_SYSTEM_ROUTING_THREADS       (SMTP_MD_ID_BEGIN_RESERVED+108)
#define MD_SMTP_RELAY_FOR_AUTH_USERS    (SMTP_MD_ID_BEGIN_RESERVED+109)
#define MD_SMTP_DISABLE_RELAY           (SMTP_MD_ID_BEGIN_RESERVED+110)

//Chunking advertisement flags
//#define MD_SHOW_BINARY_MIME             (SMTP_MD_ID_BEGIN_RESERVED+111)
//#define MD_SHOW_CHUNKING                (SMTP_MD_ID_BEGIN_RESERVED+112)

//#define MD_SMTP_RDNS_OPTIONS            (SMTP_MD_ID_BEGIN_RESERVED+113)
//#define MD_SMTP_DSN_DELAY               (SMTP_MD_ID_BEGIN_RESERVED+114)
#define MD_ROUTE_AUTHTARGET             (SMTP_MD_ID_BEGIN_RESERVED+115)
																				// (+116) 36980
#define MD_SMTP_HELO_NODOMAIN           (SMTP_MD_ID_BEGIN_RESERVED+117)
#define MD_SMTP_MAIL_NO_HELO            (SMTP_MD_ID_BEGIN_RESERVED+118)
#define MD_SMTP_INBOUND_NAGLE           (SMTP_MD_ID_BEGIN_RESERVED+119)
#define MD_SMTP_OUTBOUND_NAGLE          (SMTP_MD_ID_BEGIN_RESERVED+120)
#define MD_SMTP_INBOUND_SND_BUFF        (SMTP_MD_ID_BEGIN_RESERVED+121)
#define MD_SMTP_INBOUND_RCV_BUFF        (SMTP_MD_ID_BEGIN_RESERVED+122)

//DLL specifiers flags
#define MD_AQUEUE_DLL                   (SMTP_MD_ID_BEGIN_RESERVED+123)
//#define MD_MAPIDRV_DLL                  (SMTP_MD_ID_BEGIN_RESERVED+124)
//#define MD_CAT_DLL                      (SMTP_MD_ID_BEGIN_RESERVED+125)
#define MD_SMTP_AQUEUE_WAIT             (SMTP_MD_ID_BEGIN_RESERVED+126)
//#define MD_SMTP_USE_REMOTE_DS           (SMTP_MD_ID_BEGIN_RESERVED+127)

//Address validation flags
#define MD_DOMAIN_VALIDATION_FLAGS      (SMTP_MD_ID_BEGIN_RESERVED+128)
#define MD_SMTP_DS_DOMAIN               (SMTP_MD_ID_BEGIN_RESERVED+129)
#define MD_SMTP_DS_USE_CAT              (SMTP_MD_ID_BEGIN_RESERVED+130)


//New Retry related flags
#define MD_SMTP_REMOTE_RETRY_THRESHOLD           (SMTP_MD_ID_BEGIN_RESERVED+131)
#define MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES (SMTP_MD_ID_BEGIN_RESERVED+132)

#define MD_SMTP_USE_TCP_DNS             (SMTP_MD_ID_BEGIN_RESERVED+133)

#define MD_INBOUND_COMMAND_SUPPORT_OPTIONS  (SMTP_MD_ID_BEGIN_RESERVED+134)
#define MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS  (SMTP_MD_ID_BEGIN_RESERVED+135)
#define MD_ADD_NOHEADERS                (SMTP_MD_ID_BEGIN_RESERVED+136)			// 37000


//Relocated due to ID conflict
#define MD_SMTP_CONNECT_TIMEOUT         (SMTP_MD_ID_BEGIN_RESERVED+137)
#define MD_SMTP_MAILFROM_TIMEOUT        (SMTP_MD_ID_BEGIN_RESERVED+138)
#define MD_SMTP_RCPTTO_TIMEOUT          (SMTP_MD_ID_BEGIN_RESERVED+139)
#define MD_SMTP_DATA_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+140)
#define MD_SMTP_BDAT_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+141)
#define MD_SMTP_AUTH_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+142)
#define MD_SMTP_SASL_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+143)
//#define MD_SMTP_ETRN_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+144)
#define MD_SMTP_TURN_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+145)
#define MD_SMTP_RSET_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+146)
//#define MD_SMTP_QUIT_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+147)
#define MD_SMTP_HELO_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+148)
//#define MD_SMTP_EHLO_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+149)
//#define MD_SMTP_DATATERMINATION_TIMEOUT (SMTP_MD_ID_BEGIN_RESERVED+150)
//#define MD_SMTP_BDATTERMINATION_TIMEOUT (SMTP_MD_ID_BEGIN_RESERVED+151)
//#define MD_SMTP_TLS_TIMEOUT             (SMTP_MD_ID_BEGIN_RESERVED+152)

//For setting DSN expire intervals (in minutes)
#define MD_SMTP_EXPIRE_LOCAL_DELAY_MIN  (SMTP_MD_ID_BEGIN_RESERVED+153)
#define MD_SMTP_EXPIRE_LOCAL_NDR_MIN    (SMTP_MD_ID_BEGIN_RESERVED+154)
#define MD_SMTP_EXPIRE_REMOTE_DELAY_MIN (SMTP_MD_ID_BEGIN_RESERVED+155)
#define MD_SMTP_EXPIRE_REMOTE_NDR_MIN   (SMTP_MD_ID_BEGIN_RESERVED+156)			// 37020

//DSN specific keys
#define MD_SMTP_DSN_OPTIONS             (SMTP_MD_ID_BEGIN_RESERVED+157)
#define MD_SMTP_DSN_LANGUAGE_ID         (SMTP_MD_ID_BEGIN_RESERVED+158)

//
// jstamerj 1998/10/27 08:36:59: To specify the remote ldap tcp port
//
#define MD_SMTP_DS_PORT                 (SMTP_MD_ID_BEGIN_RESERVED+159)
#define MD_SMTP_DS_FLAGS                (SMTP_MD_ID_BEGIN_RESERVED+160)

// SSL keys
#define MD_SMTP_SSL_REQUIRE_TRUSTED_CA       (SMTP_MD_ID_BEGIN_RESERVED+161)
#define MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION (SMTP_MD_ID_BEGIN_RESERVED+162)

// logging level
#define MD_SMTP_EVENTLOG_LEVEL          (SMTP_MD_ID_BEGIN_RESERVED+163)

//#define MD_SMTP_MAX_INBOUND_CONNECTIONS_PER_IP (SMTP_MD_ID_BEGIN_RESERVED+164 )
//#define MD_SMTP_SSL_CERT_HOSTNAME_OVERRIDE  (SMTP_MD_ID_BEGIN_RESERVED+165)

#define MD_SMTP_DISABLE_PICKUP_DOT_STUFF     (SMTP_MD_ID_BEGIN_RESERVED+166)
#define MD_SMTP_DENIED_IP_ACTION        (SMTP_MD_ID_BEGIN_RESERVED+167)
#define MD_SMTP_POST_DNS_SMARTHOST      (SMTP_MD_ID_BEGIN_RESERVED+168)

//
// Flags for the MD_SMTP_DS_FLAGS DWORD key:
//
#define SMTPDSFLAG_RESOLVELOCAL         0x00000001
#define SMTPDSFLAG_RESOLVEREMOTE        0x00000002
#define SMTPDSFLAG_RESOLVESENDER        0x00000004
#define SMTPDSFLAG_RESOLVERECIPIENTS    0x00000008
#define SMTPDSFLAG_ALLFLAGS             0x0000000F
//
//Flags for the MD_SMTP_DS_USE_CAT DWORD key:
//
#define SMTPDSUSECAT_ENABLED            0xFFFFFFFF
#define SMTPDSUSECAT_DISABLED           0x00000000
//
// Settings for the MD_SMTP_DENIED_IP_ACTION
//
#define SMTPDENIEDIP_DROPCONN           0x0
#define SMTPDENIEDIP_REQAUTH            0x1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\thrdpl2.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpl2.h
//
//  Contents:    definitions needed for clients of the thrdpool2 lib
//
//	Description: The thrdpool library defines the CThreadPool base class.
//				 Users of this lib should define their own derived class
//				 that inherits from CThreadPool. A CThreadPool object
//				 has a set of threads that is used to do some work. It also
//				 has a common completion port that is used to queue work items.
//               All worker threads will normally block on 
//               GetQueuedCompletionStatus(). Clients of the CThreadPool 
//				 object will call PostWork() to get work done. This will
//				 result in one of the worker threads returning from 
//				 GetQueuedCompletionStatus() and calling the derived class'
//				 WorkCompletion() routine with a pvContext.
//
//               CThreadPool provides the following features:
//               -  creation with an initial number of threads
//               -  deletion
//               -  ability to submit work items
//               -  grow pool of threads
//               -  shrink pool of threads
//
//				 NOTE: the base class has no knowledge of the type of work
//				 getting done. It just manages the details of getting work
//				 requests and distributing it to threads in its pool. This 
//				 allows the derived class to focus on processing the actual
//				 work item without bothering about queueing etc.
//
//				 Completion ports are used merely to leverage its queueing
//				 semantics and not for I/O. If the work done by each thread
//				 is fairly small, LIFO semantics of completion ports will 
//				 reduce context switches.
//
//  Functions:  
//
//  History:     09/18/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------

#ifndef THRDPL2_H
#define THRDPL2_H

//
//	Base thread pool class
//
class CThreadPool
{
public:
	//
	//	Constructor, destructor
	//
	CThreadPool();
	virtual ~CThreadPool();

	//
	//	creates the required number of worker threads and completion port
	//
	BOOL Initialize( DWORD dwConcurrency, DWORD dwMaxThreads, DWORD dwInitThreads );

	//
	//	shutdown the thread pool
	//
	BOOL Terminate( BOOL fFailedInit = FALSE, BOOL fShrinkPool = TRUE );

	//
	//	clients should call this to post work items
	//
	BOOL 						PostWork(PVOID pvWorkContext);

	//
	//	expose shutdown event
	//
	HANDLE QueryShutdownEvent() { return m_hShutdownEvent; }

    //
    //  A job represents a series of PostWork() items
    //
    VOID  BeginJob( PVOID pvContext );

    //
    //  Wait for job to complete ie all PostWork() items are done
    //
    DWORD  WaitForJob( DWORD dwTimeout );

    //
    //  Job context is used to process all work items in a job
    //
    PVOID  QueryJobContext() { return m_pvContext; }

    //
    //  shrink pool by dwNumThreads
    //
    BOOL ShrinkPool( DWORD dwNumThreads );

    //
    //  grow pool by dwNumThreads
    //
    BOOL GrowPool( DWORD dwNumThreads );

    //
    // Shrink all the existing threads
    //
    VOID ShrinkAll();

protected:

	//
	//	derived method called when work items are posted
	//
	virtual VOID 				WorkCompletion(PVOID pvWorkContext) = 0;

	//
	//  For those who has knowledge about automatic shutdown of the thread
	//  pool, this function is used as an interface for implementing 
	//  shutting down the thread pool for itself.  The function is called
	//  when the last thread in the pool goes away because of shutdown
	//  event has been fired.  
	//
	//  The reason for this interface is: in some scenarios the shutting
	//  down thread is from the same thread pool and it will cause deadlock.
	//  Users of thread pool who expects this will happen should not call
	//  WaitForJob, and should call Terminate and delete in this call back.
	//
	virtual VOID                AutoShutdown() {
        // 
        // People who doesn't care about this function does a no-op 
        //
    };
    
private:

	friend DWORD __stdcall 		ThreadDispatcher(PVOID pvWorkerThread);

	//
	//	check for matching Init(), Term() calls
	//
	LONG				        m_lInitCount;

	//
	//	handle to completion port
	//
	HANDLE				        m_hCompletionPort;

	//
	//	shutdown event
	//
	HANDLE						m_hShutdownEvent;

    //
    //  array of worker thread handles
    //
    HANDLE*                     m_rgThrdpool;

    //
    //  array of thread id's. BUGBUG: may be able to get rid of this if
    //  we have per thread handle
    //
    DWORD*                      m_rgdwThreadId;

    //
    //  number of worker threads
    //
    DWORD                       m_dwNumThreads;

    //
    //  max number of worker threads
    //
    DWORD                       m_dwMaxThreads;

    //
    //  count work items in current job
    //
    LONG                        m_lWorkItems;

    //
    //  event used to sync job completion
    //
    HANDLE                      m_hJobDone;

    //
    //  context for current job
    //
    PVOID                       m_pvContext;

    //
    //  crit sect to protect incs/decs to m_lWorkItems
    //
    CRITICAL_SECTION            m_csCritItems;

    //
    //  access completion port - needed by worker threads
    //
	HANDLE QueryCompletionPort() { return m_hCompletionPort; }

	//
	//	thread function
	//
	static DWORD __stdcall 		ThreadDispatcher(PVOID pvWorkerThread);
};

#endif		// #ifndef THRDPL2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\export\smtpseo.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: smtpseo.h
//
// Contents:
//   Common types definitions needed across projects for SMTP's seo
//   dispatcher
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980608 12:29:40: Created.
//
//-------------------------------------------------------------
#ifndef __SMTPSEO_H__
#define __SMTPSEO_H__

#include <mailmsg.h>
#include <smtpevent.h>

//+------------------------------------------------------------
//
// Function: SMTP SEO completion function
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 16:13:28: Created.
//
//-------------------------------------------------------------
typedef HRESULT (*PFN_SMTPEVENT_CALLBACK)(HRESULT hrStatus,
                                          PVOID pvContext);


typedef enum _SMTP_DISPATCH_EVENT_TYPE
{
    SMTP_EVENT_NONE = 0,
    SMTP_MAIL_DROP_EVENT,
    SMTP_STOREDRV_DELIVERY_EVENT,
    SMTP_STOREDRV_ALLOC_EVENT,
    SMTP_STOREDRV_STARTUP_EVENT,
    SMTP_STOREDRV_PREPSHUTDOWN_EVENT,
    SMTP_STOREDRV_SHUTDOWN_EVENT,
    SMTP_MAILTRANSPORT_SUBMISSION_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT,
    SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT,
    SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT,
    SMTP_STOREDRV_ENUMMESS_EVENT,
    SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT,
    SMTP_MSGTRACKLOG_EVENT,
    SMTP_DNSRESOLVERRECORDSINK_EVENT,
    SMTP_MAXMSGSIZE_EVENT,
    SMTP_LOG_EVENT,
    SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT
} SMTP_DISPATCH_EVENT_TYPE;

typedef struct _EVENTPARAMS_SUBMISSION {
    IMailMsgProperties *pIMailMsgProperties;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatMsgQueue;
} EVENTPARAMS_SUBMISSION, *PEVENTPARAMS_SUBMISSION;

typedef struct _EVENTPARAMS_PRECATEGORIZE {
    IMailMsgProperties *pIMailMsgProperties;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatMsgQueue;
} EVENTPARAMS_PRECATEGORIZE, *PEVENTPARAMS_PRECATEGORIZE;

typedef struct _EVENTPARAMS_POSTCATEGORIZE {
    IMailMsgProperties *pIMailMsgProperties;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatMsgQueue;
} EVENTPARAMS_POSTCATEGORIZE, *PEVENTPARAMS_POSTCATEGORIZE;

typedef struct _EVENTPARAMS_CATREGISTER {
    ICategorizerParameters *pICatParams;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    LPSTR pszSourceLine;
    LPVOID pvCCategorizer;
    HRESULT hrSinkStatus;
} EVENTPARAMS_CATREGISTER, *PEVENTPARAMS_CATREGISTER;

typedef struct _EVENTPARAMS_CATBEGIN {
    ICategorizerMailMsgs *pICatMailMsgs;
} EVENTPARAMS_CATBEGIN, *PEVENTPARAMS_CATBEGIN;

typedef struct _EVENTPARAMS_CATEND {
    ICategorizerMailMsgs *pICatMailMsgs;
    HRESULT hrStatus;
} EVENTPARAMS_CATEND, *PEVENTPARAMS_CATEND;

typedef struct _EVENTPARAMS_CATBUILDQUERY {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pCCatAddr;
} EVENTPARAMS_CATBUILDQUERY, *PEVENTPARAMS_CATBUILDQUERY;

typedef struct _EVENTPARAMS_CATBUILDQUERIES {
    ICategorizerParameters *pICatParams;
    DWORD dwcAddresses;
    ICategorizerItem **rgpICatItems;
    ICategorizerQueries *pICatQueries;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pblk;
} EVENTPARAMS_CATBUILDQUERIES, *PEVENTPARAMS_CATBUILDQUERIES;

typedef struct _EVENTPARAMS_CATSENDQUERY {
    //
    // Params needed to call real sinks
    //
    ICategorizerParameters *pICatParams;
    ICategorizerQueries *pICatQueries;
    ICategorizerAsyncContext *pICatAsyncContext;
    //
    // Params needed by our implementation of ICategorizerAsyncContext
    //
    IMailTransportNotify *pIMailTransportNotify;
    PVOID pvNotifyContext;
    HRESULT hrResolutionStatus;
    PVOID pblk;
    //
    // Default/completion processing functions
    //
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;

} EVENTPARAMS_CATSENDQUERY, *PEVENTPARAMS_CATSENDQUERY;

typedef struct _EVENTPARAMS_CATSORTQUERYRESULT {
    ICategorizerParameters *pICatParams;
    HRESULT hrResolutionStatus;
    DWORD dwcAddresses;
    ICategorizerItem **rgpICatItems;
    DWORD dwcResults;
    ICategorizerItemAttributes **rgpICatItemAttributes;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pblk;
} EVENTPARAMS_CATSORTQUERYRESULT, *PEVENTPARAMS_CATSORTQUERYRESULT;

typedef struct _EVENTPARAMS_CATPROCESSITEM {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pCCatAddr;
} EVENTPARAMS_CATPROCESSITEM, *PEVENTPARAMS_CATPROCESSITEM;

typedef struct _EVENTPARAMS_CATEXPANDITEM {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatAddr;
    IMailTransportNotify *pIMailTransportNotify;
    PVOID pvNotifyContext;
} EVENTPARAMS_CATEXPANDITEM, *PEVENTPARAMS_CATEXPANDITEM;

typedef struct _EVENTPARAMS_CATCOMPLETEITEM {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pCCatAddr;
} EVENTPARAMS_CATCOMPLETEITEM, *PEVENTPARAMS_CATCOMPLETEITEM;

typedef struct _EVENTPARAMS_ROUTER {
    DWORD dwVirtualServerID;
    IMailMsgProperties *pIMailMsgProperties;
    IMessageRouter *pIMessageRouter;
    IMailTransportRouterReset *pIRouterReset;
    IMailTransportRoutingEngine *pIRoutingEngineDefault;
} EVENTPARAMS_ROUTER, *PEVENTPARAMS_ROUTER;


typedef struct _EVENTPARAMS_MSGTRACKLOG
{
    IUnknown           *pIServer;
    IMailMsgProperties *pIMailMsgProperties;
    LPMSG_TRACK_INFO    pMsgTrackInfo;
} EVENTPARAMS_MSGTRACKLOG, *PEVENTPARAMS_MSGTRACKLOG;


typedef struct _EVENTPARAMS_DNSRESOLVERRECORD {
    LPSTR                  pszHostName;
    LPSTR                  pszFQDN;
    DWORD                  dwVirtualServerId;
    DNS_SERVER_INFO      **ppDnsServerInfo;  
    IDnsResolverRecord   **ppIDnsResolverRecord;
} EVENTPARAMS_DNSRESOLVERRECORD, *PEVENTPARAMS_DNSRESOLVERRECORD;

typedef struct _EVENTPARAMS_MAXMSGSIZE
{
    IUnknown           *pIUnknown;
    IMailMsgProperties *pIMailMsg;
    BOOL               *pfShouldImposeLimit;
} EVENTPARAMS_MAXMSGSIZE, *PEVENTPARAMS_MAXMSGSIZE;

typedef struct _EVENTPARAMS_LOG
{
    LPSMTP_LOG_EVENT_INFO   pSmtpEventLogInfo;
    PVOID                   pDefaultEventLogHandler;
    DWORD                   iSelectedDebugLevel;
} EVENTPARAMS_LOG, *PEVENTPARAMS_LOG;

typedef struct _EVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS
{
    IUnknown               *pIServer;
    LPCSTR                  pszDomainName;
    DWORD                  *pdwDomainInfoFlags;
} EVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS, *PEVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS;

#endif //__SMTPSEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\applmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Application Object Manager

File: Applmgr.cpp

Owner: PramodD

This is the Application Manager source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "activdbg.h"
#include "mtacb.h"
#include "debugger.h"
#include "memchk.h"
#include <iismsg.h>

PTRACE_LOG          CAppln::gm_pTraceLog = NULL;
CApplnMgr           g_ApplnMgr;
CApplnCleanupMgr    g_ApplnCleanupMgr;
DWORD               g_nApplications = 0;
DWORD               g_nApplicationObjectsActive = 0;
DWORD               g_nApplicationsRestarting = 0;
DWORD               g_nApplicationsRestarted = 0;
LONG		    g_fProceedWithShutdownAppln = 1;

#define DENALI_FILE_NOTIFY_FILTER 0

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
   S c r i p t E n g i n e C l e a n u p

Node type for linked list of script engines to cleanup
===================================================================*/

struct CScriptEngineCleanupElem : CDblLink
    {
    CActiveScriptEngine *m_pEngine;
    CScriptEngineCleanupElem(CActiveScriptEngine *pEngine) : m_pEngine(pEngine)
        {
        m_pEngine->AddRef();
        }

    ~CScriptEngineCleanupElem()
        {
        m_pEngine->FinalRelease();
        }
    };

/*===================================================================
   C A p p l n V a r i a n t s
===================================================================*/

/*===================================================================
CApplnVariants::CApplnVariants

Constructor

Parameters:

Returns:
===================================================================*/
CApplnVariants::CApplnVariants()
    :
    m_cRefs(1),
    m_pAppln(NULL),
    m_ctColType(ctUnknown),
    m_ISupportErrImp(this, this, IID_IVariantDictionary)
    {
    CDispatch::Init(IID_IVariantDictionary);
    }

/*===================================================================
CApplnVariants::~CApplnVariants

Constructor

Parameters:

Returns:
===================================================================*/
CApplnVariants::~CApplnVariants()
    {
    Assert(!m_pAppln);
    }

/*===================================================================
CApplnVariants::Init

Init ApplnVariants

Parameters:
    CAppln   *pAppln            application
    CompType  ctColType         component collection type

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::Init
(
CAppln *pAppln,
CompType ctColType
)
    {
    Assert(pAppln);
    pAppln->AddRef();

    Assert(!m_pAppln);

    m_pAppln    = pAppln;
    m_ctColType = ctColType;
    return S_OK;
    }

/*===================================================================
CApplnVariants::UnInit

UnInit ApplnVariants

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::UnInit()
    {
    if (m_pAppln)
        {
        m_pAppln->Release();
        m_pAppln = NULL;
        }
    return S_OK;
    }

/*===================================================================
CApplnVariants::QueryInterface
CApplnVariants::AddRef
CApplnVariants::Release

IUnknown members for CApplnVariants object.
===================================================================*/
STDMETHODIMP CApplnVariants::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown || iid == IID_IDispatch ||
        iid == IID_IVariantDictionary)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }
    else if (iid == IID_ISupportErrorInfo)
        {
        m_ISupportErrImp.AddRef();
        *ppvObj = &m_ISupportErrImp;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }

STDMETHODIMP_(ULONG) CApplnVariants::AddRef()
    {
    return InterlockedIncrement((LPLONG)&m_cRefs);
    }

STDMETHODIMP_(ULONG) CApplnVariants::Release()
    {
    ULONG cRef = InterlockedDecrement((LPLONG)&m_cRefs);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
    }

/*===================================================================
CApplnVariants::ObjectNameFromVariant

Gets name from variant. Resolves operations by index.
Allocates memory for name.

Parameters:
    vKey        VARIANT
    ppwszName   [out] allocated name
    fVerify     flag - check existance if named

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::ObjectNameFromVariant
(
VARIANT &vKey,
WCHAR **ppwszName,
BOOL fVerify
)
    {

    HRESULT hr = S_OK;

    *ppwszName = NULL;

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    VARIANT *pvarKey = &vKey;
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    if (V_VT(pvarKey) != VT_BSTR && V_VT(pvarKey) != VT_I2 && V_VT(pvarKey) != VT_I4)
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &vKey, IID_IVariantDictionary, IDE_APPLICATION)))
            {
            ExceptionId(IID_IVariantDictionary, IDE_APPLICATION, IDE_EXPECTING_STR);
            VariantClear(&varKeyCopy);
            return E_FAIL;
            }
        pvarKey = &varKeyCopy;
        }

    LPWSTR pwszName = NULL;

    switch (V_VT(pvarKey))
        {
        case VT_BSTR:
            {
            pwszName = V_BSTR(pvarKey);

            if (fVerify && pwszName)
                {
                CComponentObject *pObj = NULL;

                Assert(m_pAppln);
                Assert(m_pAppln->PCompCol());

                if (m_ctColType == ctTagged)
                    m_pAppln->PCompCol()->GetTagged(pwszName, &pObj);
                else
                    m_pAppln->PCompCol()->GetProperty(pwszName, &pObj);

                if (!pObj || pObj->GetType() != m_ctColType)
                    pwszName = NULL; // as if not found
                }
            break;
            }

        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                return E_FAIL;

        // fallthru to VT_I4

        case VT_I4:
            {
            int i;
            // Look up the object by index
            i = V_I4(pvarKey);

            if (i > 0)
                {
                Assert(m_pAppln);
                Assert(m_pAppln->PCompCol());

                m_pAppln->PCompCol()->GetNameByIndex
                    (
                    m_ctColType,
                    i,
                    &pwszName
                    );
                }
            break;
            }
        }

    if (pwszName)
    {
        *ppwszName = StringDupW(pwszName);
        if (*ppwszName == NULL)
            hr = E_OUTOFMEMORY;
    }
    VariantClear(&varKeyCopy);
    return hr;

    }

/*===================================================================
CApplnVariants::get_Item

Function called from DispInvoke to get keys from the collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - integers access collection as an array
    pvarReturn    VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::get_Item
(
VARIANT varKey,
VARIANT *pVar
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    // Initialize return value
    VariantInit(pVar);

    if (!m_pAppln->PCompCol())
        return S_OK;

    // Get HitObj from Viper if Tagged Variants
    CHitObj *pHitObj = NULL;
    if (m_ctColType == ctTagged)
        {
        ViperGetHitObjFromContext(&pHitObj);
        if (!pHitObj)
            return S_OK; // return emtpy variant
        }

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        {
        m_pAppln->UnLock();
        return hr;
        }

    // Find object by name
    CComponentObject *pObj = NULL;

    if (m_ctColType == ctTagged)
        {
        Assert(pHitObj);
        // need to go through HitObj for instantiation
        pHitObj->GetComponent(csAppln, pwszName, CbWStr(pwszName), &pObj);
        if (pObj && (pObj->GetType() != ctTagged))
            pObj = NULL;
        }
    else
        {
        m_pAppln->PCompCol()->GetProperty(pwszName, &pObj);
        }

    if (pObj)
        pObj->GetVariant(pVar);

    m_pAppln->UnLock();

    free(pwszName);
    return S_OK;
    }

/*===================================================================
CApplnVariants::put_Item

OLE automation put for Item property

Parameters:
    varKey     key
    Var        value

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::put_Item
(
VARIANT varKey,
VARIANT Var
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    m_pAppln->Lock();

    // Resolve the variant
    VARIANT varResolved;
    HRESULT hr = VariantResolveDispatch
        (
        &varResolved,
        &Var,
        IID_IApplicationObject,
        IDE_APPLICATION
        );
    if (FAILED(hr))
        {
        m_pAppln->UnLock();
        return hr;      // exception already raised
        }

    // Get name
    WCHAR *pwszName = NULL;
    hr = ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        // Set the property
        if (m_pAppln->PCompCol())
            hr = m_pAppln->PCompCol()->AddProperty(pwszName, &varResolved);
        else
            hr = E_FAIL; // not likely if application not UnInited
        }

    VariantClear(&varResolved);
    m_pAppln->UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    free(pwszName);
    return hr;
    }

/*===================================================================
CApplnVariants::putref_Item

OLE automation putref for Item property

Parameters:
    varKey     key
    Var        value

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::putref_Item
(
VARIANT varKey,
VARIANT Var
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    if (FIsIntrinsic(&Var))
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_INTRINSIC);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        // Set the property
        if (m_pAppln->PCompCol())
            hr = m_pAppln->PCompCol()->AddProperty(pwszName, &Var);
        else
            hr = E_FAIL; // not likely if application not UnInited
        }

    m_pAppln->UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    if (pwszName)
        free(pwszName);
    return hr;
    }

/*===================================================================
CApplnVariants::get_Key

Function called from DispInvoke to get values from the collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - integers access collection as an array
    pvarReturn    VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::get_Key
(
VARIANT varKey,
VARIANT *pVar
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    VariantInit(pVar);

    if (!m_pAppln->PCompCol())
        return S_OK;

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName, TRUE);

    m_pAppln->UnLock();

    if (!pwszName)
        return hr;

    // Return BSTr
    BSTR bstrT = SysAllocString(pwszName);
    free(pwszName);

    if (!bstrT)
        return E_OUTOFMEMORY;

    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = bstrT;
    return S_OK;
    }

/*===================================================================
CApplnVariants::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/
STDMETHODIMP CApplnVariants::get_Count
(
int *pcValues
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        *pcValues = m_pAppln->m_pApplCompCol->GetTaggedObjectCount();
    else
        *pcValues = m_pAppln->m_pApplCompCol->GetPropertyCount();

    return S_OK;
    }

/*===================================================================
CApplnVariants::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CApplnVariants::get__NewEnum
(
IUnknown **ppEnumReturn
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CVariantsIterator *pIterator = new CVariantsIterator(m_pAppln, m_ctColType);
    if (pIterator == NULL)
        {
        ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CApplnVariants::Remove

Remove item

Parameters:
    varKey     key

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::Remove
(
VARIANT varKey
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        CComponentCollection *pCompCol = m_pAppln->PCompCol();

        // Set the property
        if (pCompCol)
            pCompCol->RemoveProperty(pwszName);

        free(pwszName);
        }

    m_pAppln->UnLock();
    return S_OK;
    }

/*===================================================================
CApplnVariants::RemoveAll

Remove all items

Parameters:
    varKey     key

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::RemoveAll()
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    m_pAppln->Lock();

    CComponentCollection *pCompCol = m_pAppln->PCompCol();

    if (pCompCol)
        {
        pCompCol->RemoveAllProperties();
        }

    m_pAppln->UnLock();
    return S_OK;
    }


/*===================================================================
  C A p p l n
===================================================================*/

/*===================================================================
CAppln::CAppln

Constructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CAppln::CAppln()
    :
    m_fInited(FALSE),
    m_fFirstRequestRan(FALSE),
    m_fGlobalChanged(FALSE),
    m_fDeleteInProgress(FALSE),
    m_fTombstone(FALSE),
    m_fDebuggable(FALSE),
    m_fInternalLockInited(FALSE),
    m_fApplnLockInited(FALSE),
    m_cRefs(1),
    m_pszMetabaseKey(NULL),
    m_pszApplnPath(NULL),
    m_pszGlobalAsa(NULL),
    m_pGlobalTemplate(NULL),
    m_cSessions(0),
    m_cRequests(0),
    m_pSessionMgr(NULL),
    m_pApplCompCol(NULL),
    m_pProperties(NULL),
    m_pTaggedObjects(NULL),
    m_pAppRoot(NULL),
    m_pActivity(NULL),
    m_pUnkFTM(NULL),
    m_dwLockThreadID(INVALID_THREADID),
    m_cLockRefCount(0),
    m_pdispGlobTypeLibWrapper(NULL),
    m_pServicesConfig(NULL),
    m_fSWC_PartitionAccessDenied(FALSE),
    m_fSWC_InvalidPartitionGUID(FALSE)
{

    // COM stuff
    m_ISuppErrImp.Init(static_cast<IApplicationObject *>(this),
                        static_cast<IApplicationObject *>(this),
                        IID_IApplicationObject);
    CDispatch::Init(IID_IApplicationObject);

    InterlockedIncrement((LPLONG)&g_nApplicationObjectsActive);

    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
    }
}

/*===================================================================
CAppln::~CAppln

Destructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CAppln::~CAppln()
    {
    Assert(m_fTombstone);  // must be tombstoned before destructor
    Assert(m_cRefs == 0);  // must have 0 ref count

    #ifdef DBG_NOTIFICATION
    DBGPRINTF((DBG_CONTEXT, "Deleting application %p\n", this));
    #endif // DBG_NOTIFICATION

    if ( m_pUnkFTM != NULL )
    {
        m_pUnkFTM->Release();
        m_pUnkFTM = NULL;
    }
    }

/*===================================================================
HRESULT CAppln::Init

Initialize object

Parameters:
    char *pszApplnKey           application's metabase key
    char *pszApplnPath          application's directory path
    CIsapiReqInfo  *pIReq       Isapi Req Info

Returns:
    S_OK              Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory failure
===================================================================*/
HRESULT CAppln::Init
(
TCHAR *pszApplnKey,
TCHAR *pszApplnPath,
CIsapiReqInfo *pIReq
)
{
    HRESULT         hr = S_OK;
    CMBCSToWChar    convStr;

    InterlockedIncrement((LPLONG)&g_nApplications);

    Assert(pszApplnKey);
    Assert(pszApplnPath);

    void *pHashKey = NULL;
    DWORD dwHashKeyLength = 0;
    DWORD cch;

    // Debugging variables (These are placed here for possible cleanup)
    IDebugApplicationNode *pVirtualServerRoot = NULL;
    CFileNode *pFileNode = NULL;


    // Create the FTM
    if (m_pUnkFTM == NULL)
    {
        hr = CoCreateFreeThreadedMarshaler( (IUnknown*)this, &m_pUnkFTM );
        if ( FAILED(hr) )
        {
            Assert( m_pUnkFTM == NULL );
            return (hr);
        }
    }
    Assert( m_pUnkFTM != NULL );


    // Critical sections created together --
    // they are deleted in the destructor based on m_fInited flag

    ErrInitCriticalSection(&m_csInternalLock, hr);
    if (SUCCEEDED(hr))
    {
        ErrInitCriticalSection(&m_csApplnLock, hr);
        if (FAILED(hr))
            DeleteCriticalSection(&m_csInternalLock);
    }

    if (FAILED(hr))
    	{
    	DBGPRINTF((DBG_CONTEXT, "New Application Failed to acquire Critical Section, hr = %08x\n", hr));
        return hr;
        }

    m_fInternalLockInited = TRUE;
    m_fApplnLockInited    = TRUE;

    // Remember (copy of) metabase key

    cch = _tcslen(pszApplnKey);
    m_pszMetabaseKey = new TCHAR[(cch+1) * sizeof(TCHAR)];
    if (!m_pszMetabaseKey)
    	goto LCleanupOOM;
    memcpy(m_pszMetabaseKey, pszApplnKey, (cch+1)*sizeof(TCHAR));

    pHashKey = m_pszMetabaseKey;
    dwHashKeyLength = cch * sizeof(TCHAR);

    // Remember (copy of) appln path
    cch = _tcslen(pszApplnPath);
    m_pszApplnPath = new TCHAR[(cch+1) * sizeof(TCHAR)];
    if (!m_pszApplnPath)
        goto LCleanupOOM;
    memcpy(m_pszApplnPath, pszApplnPath, (cch+1)*sizeof(TCHAR));

    // Get virtual path of appln & remember what it is
    TCHAR szApplnVRoot[MAX_PATH];
    if (FAILED(hr = FindApplicationPath(pIReq, szApplnVRoot, sizeof szApplnVRoot)))
    	{
        DBGWARN((DBG_CONTEXT, "New Application Failed to FindApplicationPath(), hr = %#08x\n", hr));
        goto LCleanup;
        }

    if ((m_pszApplnVRoot = new TCHAR [(_tcslen(szApplnVRoot) + 1)*sizeof(TCHAR)]) == NULL)
        goto LCleanupOOM;
    _tcscpy(m_pszApplnVRoot, szApplnVRoot);

    // Get Session cookie names, both secure and non-secure
    InitSessionCookieNames();

    // Initialize link element with key
    Assert(pHashKey);
    Assert(dwHashKeyLength);

    if (FAILED(CLinkElem::Init(pHashKey, dwHashKeyLength)))
    	goto LCleanupOOM;

    m_cSessions = 0;
    m_cRequests = 0;

    // Create and init app config
    m_pAppConfig = new CAppConfig();
    if (!m_pAppConfig)
		goto LCleanupOOM;

    hr = m_pAppConfig->Init(pIReq, this);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the AppConfig, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // Create and init application level component collection
    m_pApplCompCol = new CComponentCollection;
    if (!m_pApplCompCol)
        goto LCleanupOOM;

    hr = m_pApplCompCol->Init(csAppln,m_pAppConfig->fExecuteInMTA());
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Component Collection, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // initialize application properties collection
    m_pProperties = new CApplnVariants;
    if (!m_pProperties)
        goto LCleanupOOM;
    hr = m_pProperties->Init(this, ctProperty);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Application Properties, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // initialize application tagged object collection
    m_pTaggedObjects = new CApplnVariants;
    if (!m_pTaggedObjects)
        goto LCleanupOOM;
    hr = m_pTaggedObjects->Init(this, ctTagged);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Application Tagged Objects, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // Initialize the CServicesConfig Object

    hr = InitServicesConfig();
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init ServicesConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    // Debugging support  - Create an application node
    // If PDM does not exist it means debugger not installed or it's Win 95
    //
    if (g_pPDM)
        {
        // Debugging directories are shown as:
        //
        //      <virtual web server>
        //         <application name>
        //              <path to ASP>
        //
        // Get a pointer to the document node containing the virtual web server.
        if (FAILED(hr = GetServerDebugRoot(pIReq, &pVirtualServerRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not GetServerDebugRoot(), hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Create a node for this application
        if (FAILED(hr = g_pDebugApp->CreateApplicationNode(&m_pAppRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not CreateApplicationNode(), hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Create a doc provider for the node
        if ((pFileNode = new CFileNode) == NULL)
            goto LCleanupOOM;

        // Name the application
        TCHAR szDebugApp[256];
        TCHAR *pchEnd = strcpyEx(szDebugApp, m_pszApplnVRoot);
        if (! QueryAppConfig()->fAllowDebugging()) {
#if UNICODE
            CwchLoadStringOfId(
#else
            CchLoadStringOfId(
#endif
            IDS_DEBUGGING_DISABLED, pchEnd, DIFF(&szDebugApp[sizeof (szDebugApp)/sizeof(TCHAR)] - pchEnd));
            m_fDebuggable = FALSE;
        }
        else
            m_fDebuggable = TRUE;
        Assert (_tcslen(szDebugApp) < (sizeof(szDebugApp)/sizeof(TCHAR)));

        WCHAR   *pswzDebugApp;
#if UNICODE
        pswzDebugApp = szDebugApp;
#else
        if (FAILED(hr = convStr.Init(szDebugApp))) {
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Cannot convert szDebugApp to UNICODE, hr = %#08x\n", hr));
            goto LCleanup;
        }
        pswzDebugApp = convStr.GetString();
#endif

        if (FAILED(hr = pFileNode->Init(pswzDebugApp)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Cannot Init CFileNode, hr = %#08x\n", hr));
            goto LCleanup;
            }

        if (FAILED(hr = m_pAppRoot->SetDocumentProvider(pFileNode)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: SetDocumentProvider failed, hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Attach to the UI
        if (FAILED(hr = m_pAppRoot->Attach(pVirtualServerRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Attach to debugger, hr = %#08x\n", hr));
            goto LCleanup;
            }

        // If this application had a previous incarnation (changed global.asa
        // or debugging being flipped on in midstream), then there may be some
        // documents in the cache which should be added to the debugger now.
        if (m_fDebuggable)
            {
            g_TemplateCache.AddApplicationToDebuggerUI(this);

            // create the global debug activity if it hasn't been created already
            if (g_pDebugActivity == NULL) {
                g_pDebugActivity = new CViperActivity;
                if (g_pDebugActivity == NULL) {
                    hr = E_OUTOFMEMORY;
                    goto LCleanup;
                }
                if (FAILED(hr = g_pDebugActivity->Init(m_pServicesConfig))) {
				    DBGWARN((DBG_CONTEXT, "New Application Failed: Could not create global debug activity, hr = %#08x\n", hr));
				    goto LCleanup;
                }
            }

            // In DEBUG mode: all requests run on the same thread
            if (FAILED(hr = BindToActivity(g_pDebugActivity)))
				{
				DBGWARN((DBG_CONTEXT, "New Application Failed: Could not bind application to debugging activity, hr = %#08x\n", hr));
				goto LCleanup;
				}
            }
        }

    // Create and init session manager
    m_pSessionMgr = new CSessionMgr;
    if (!m_pSessionMgr)
        goto LCleanupOOM;

    hr = m_pSessionMgr->Init(this);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init session manager, hr = %#08x\n", hr));
		goto LCleanup;
		}

LCleanup:
    // Release interfaces
    if (pFileNode)
        pFileNode->Release();

    if (pVirtualServerRoot)
        pVirtualServerRoot->Release();

    if (SUCCEEDED(hr))
        m_fInited = TRUE;


    return hr;

LCleanupOOM:
	hr = E_OUTOFMEMORY;
	DBGERROR((DBG_CONTEXT, "New Application Failed: E_OUTOFMEMORY\n"));
	goto LCleanup;
    }

/*===================================================================
CAppln::InitServicesConfig

Initializes the Application scoped CServicesConfig object
===================================================================*/
HRESULT CAppln::InitServicesConfig()
{
    HRESULT                         hr;
    IServiceThreadPoolConfig        *pIThreadPool = NULL;
    IServiceSynchronizationConfig   *pISyncConfig = NULL;
    IServicePartitionConfig         *pIPartitionConfig = NULL;
    IServiceSxsConfig               *pISxsConfig = NULL;

	hr = CoCreateInstance(CLSID_CServiceConfig,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void **)&m_pServicesConfig);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not CCI ServicesConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = m_pServicesConfig->QueryInterface(IID_IServiceThreadPoolConfig, (void **)&pIThreadPool);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServiceThreadPoolConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    if (m_pAppConfig->fExecuteInMTA()) {
        hr = ViperConfigureMTA();
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Failed to Configure MTA, hr = %#08x\n", hr));
		    goto LCleanup;
        }
    }
    else {
        hr = ViperConfigureSTA();
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Failed to Configure STA, hr = %#08x\n", hr));
		    goto LCleanup;
        }
    }

    hr = pIThreadPool->SelectThreadPool(m_pAppConfig->fExecuteInMTA() ? CSC_MTAThreadPool : CSC_STAThreadPool);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Failed to SelectThreadPool, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = m_pServicesConfig->QueryInterface(IID_IServiceSynchronizationConfig, (void **)&pISyncConfig);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServiceSynchronizationConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = pISyncConfig->ConfigureSynchronization (m_pAppConfig->fExecuteInMTA() ? CSC_NewSynchronization : CSC_IfContainerIsSynchronized);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not ConfigureSynchronization, hr = %#08x\n", hr));
		goto LCleanup;
    }

    if (m_pAppConfig->fUsePartition()) {

        if (m_pAppConfig->PPartitionGUID()) {

            hr = m_pServicesConfig->QueryInterface(IID_IServicePartitionConfig, (void **)&pIPartitionConfig);
            if (FAILED(hr)) {
		        DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServicePartitionConfig, hr = %#08x\n", hr));
		        goto LCleanup;
            }

            hr = pIPartitionConfig->PartitionConfig(CSC_NewPartition);
            if (FAILED(hr)) {
		        DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set PartitionConfig, hr = %#08x\n", hr));
		        goto LCleanup;
            }

            hr = pIPartitionConfig->PartitionID(*m_pAppConfig->PPartitionGUID());
            if (FAILED(hr)) {
		        DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set PartitionID, hr = %#08x\n", hr));
		        goto LCleanup;
            }
        }
        else {
            LogSWCError(InvalidPartitionGUID);
            hr = E_FAIL;
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - fUsePartition Set, but no PartitionID\n", hr));
		    goto LCleanup;
        }
    }

    if (m_pAppConfig->fSxsEnabled()) {

        hr = m_pServicesConfig->QueryInterface(IID_IServiceSxsConfig, (void **)&pISxsConfig);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServiceSxsConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        hr = pISxsConfig->SxsConfig(CSC_NewSxs);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set SxsConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        LPWSTR  pwszApplnPath;
#if UNICODE
        pwszApplnPath = m_pszApplnPath;
#else
        CMBCSToWChar    convPath;

        hr = convPath.Init(m_pszApplnPath);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not convert ApplnPath to UNICODE, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        pwszApplnPath = convPath.GetString();
#endif
        hr = pISxsConfig->SxsDirectory(pwszApplnPath);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set SxsDirectory, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        if (m_pAppConfig->szSxsName() && *m_pAppConfig->szSxsName()) {
            CMBCSToWChar    convName;

            hr = convName.Init(m_pAppConfig->szSxsName());
            if (FAILED(hr)) {
    		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not convert SxsName to UNICODE, hr = %#08x\n", hr));
	    	    goto LCleanup;
            }

            hr = pISxsConfig->SxsName(convName.GetString());
            if (FAILED(hr)) {
		        DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set SxsName, hr = %#08x\n", hr));
		        goto LCleanup;
            }
        }
    }

LCleanup:

    if (pIThreadPool)
        pIThreadPool->Release();

    if (pISyncConfig)
        pISyncConfig->Release();

    if (pIPartitionConfig)
        pIPartitionConfig->Release();

    if (pISxsConfig)
        pISxsConfig->Release();

    return hr;
}

/*===================================================================
HRESULT CAppln::InitSessionCookieNames

Initialize session cookie names. called during CApplin::Init. Introduced in QFE fix 28823 by markzh.

Every application will have a unique session cookie name assigned by this function. This contrast
to the pre-28823 behavior where we have one session cookie shared by all applications. (Note
we still had separate cookies if applications are running in different processes). Sharing session
cookie requires us to accept cookie values generated for another application. That was ok until
we introduced KeepSessionIDSecure - cookies generated for other applications are reset by
current application if the current session is secure.

Session-id cookie name used to be process-wide. The naming scheme was prefix+processid.
Here we generate a news one for each application. The naming scheme is expanded to prefix +
processid + appid. The appid is from a monotonous counter. Appid assignment may change
when process restarts. But that doesn't matter because the old cookie shouldn't be accepted
anyway. Instead of increasing string length of cookie name to accomodate appid, we made it
stay at prefix + 8 chars, by better utilization of each digit. Now we allow 32 different values
in each of the 8 character positions. That gives us 40 bits of information space. 24 bits are
used by processid, 15 bits are used by appid, 1 bit is used to distinguish cookies on secure
and non-secure sessions. Only 24 bits of process id (not all 32 bits) are used, because the
most significant 8 bits of process id is always 0 on current Windows implementation (see
ExpLookupHandleTableEntry).

The above method alone will give the same session-id cookie name from every computer
as long as process id is 123 and application id is 5. If a browser happened to simultaneously
visit two different severs with the same process id and application id, they will share the
same cookie name. However, their cookies should not overwrite each other because the client
should store them separately for two different servers. Regardless, we still wish to have some
randomness in cookie name and try to minimize name coincidence by injecting some data unique
to the system. But this is NOT done perfectly. The way we implement this is by adding the
system start time (as system signature) to bit 8 to bit 23 of process id. "Add" is a reversable
operator which will maintain one-to-one mapping given a fixed system signature. That will
ensure different cookie names are issued if process ids are different.


Parameters:
	none

Returns:
	none
===================================================================*/
void CAppln::InitSessionCookieNames()
{
	DWORD pid = GetCurrentProcessId();
	DWORD aid = g_ApplnMgr.NextApplicationID();
	ASSERT(aid <= 0x7fff);	// not likely to have so many applications

	aid <<=1;	// last bit for secure flag

	// Avoid name conflict between computers, inject system signature.
	// The API GetTickCount is used to calculate system boot time. It returns a
	// DWORD which will wrap around every 49 days. But that's fine because we
	// only care about some bits of the result. Those are not affected by the
	// wrap around. We avoided querying perf data for precise boot up time,
	// as we may run into permission problems.
	
	time_t curtime;
	time(&curtime);

	DWORD tic = GetTickCount();

	// uptime is what time() would return when system booted, it will:
	//   - stay same (within accuracy) as time passes
	//   - stay same when tic wraps around 4G
	//   - be process independent
	
	DWORD uptime = curtime*1000 - tic;

	// set signature to uptime devided by accuracy (4 seconds). max ushort= 3 days
	USHORT localSignature = (USHORT)(uptime / 4096);

	// blend in system signature to process id.
	pid += ((DWORD)localSignature) << 8;

    // Encode the Non-secure version of th cookie
    EncodeCookie(m_szSessionCookieName, pid, aid, FALSE);

    // Encode the Secure version of the cookie
    EncodeCookie(m_szSessionCookieNameSecure, pid, aid, TRUE);	

    return;

}


/*===================================================================
HRESULT CAppln::EncodeCookie

Dependingon the fIsSecure flag. we will either encode the cookie from numbers to a string.

Parameters:
    pszCookie   -   pointer to the string to be returned
    pid         -   Process ID
    aid         -   Application ID
    fIsSecure   -   Should this be encoded as a secure cookie.
Returns:

	String filled with the Cookie
===================================================================*/
void CAppln::EncodeCookie (char *pszCookie, DWORD pid, DWORD aid,  BOOL fIsSecure)
{
	strcpy(pszCookie, SZ_SESSION_ID_COOKIE_PREFIX);
	pszCookie += CCH_SESSION_ID_COOKIE_PREFIX;

	// the number of digits is hard coded to 8 here.
	// it doesn't scale by simply adjusting a macro. sorry
	// set cookie value to zero - we'll "bit or" 1's into it
	memset(pszCookie, 0, 8+1);	// +1 for null terminator

    //
	// Recommended for all versions of IIS except new products.
	// This limits our behavior change to secure connections only.
	// It may be lifted if someone request this later. When we'll
	// have more confidence on this feature change.
	//
	
	USHORT  wCookieSerial[3];	// cookie name in three words format
	wCookieSerial[0] = (USHORT)pid;
	wCookieSerial[1] = fIsSecure ? (USHORT)aid : 0;
	wCookieSerial[2] = (USHORT)(pid>>16) & 0xFF;

	// redistribute bits in w0-w2 (8*5) to pszCookie (5*8)

	USHORT val;  // keeps the sack of bits from wCookieSerial[], then seed them into pszCookie

	for (int bit=0; bit<5; bit++)
	{
	    //
		// load value from wCookieSerial[]
		//
		if (bit%2==0)
		{
			val = wCookieSerial[bit/2];
		}

        //
		// fill in the same bit for all 8 digits
		//
		for (int digit=0; digit<8; digit++)
		{
			pszCookie[digit] |= (char)((val & 1) << bit);
			val >>= 1;
		}
		
		//
		// advance to next bit
		//
	}

    //
	// encode numbers to string
	//
	static char EncodingTable[]=
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"012345";	// 32 token characters

    //
    // Replace numbers by characters
    //
	for (int i=0; i<8; i++)
	{
		pszCookie[i] = EncodingTable[pszCookie[i]];
	}

	return;
}


/*===================================================================
CAppln::Restart

Restart an application. (used for when global.asa changes or
debugging enable metabase key changes)
===================================================================*/
HRESULT CAppln::Restart(BOOL  fForceRestart /* = FALSE*/)
    {
    AddRef();  // keep addref'd while restarting

    DBGPRINTF((DBG_CONTEXT, "Restarting  application %S, %p\n", m_pszMetabaseKey, this));

    g_ApplnMgr.Lock();

    // If   already restarted or
    //      in the tombstone state or
    //      restart not allowed
    //      shutting down -> don't restart
    if (m_fGlobalChanged ||
        m_fTombstone ||
        (!m_pAppConfig->fEnableApplicationRestart() && !fForceRestart) ||
        IsShutDownInProgress())
        {
        // Give back the lock and refcount
        // since we don't need them
        g_ApplnMgr.UnLock();
        Release();
        return S_OK;
        }

    // remove the application from the global hash

    CLinkElem *pLinkElem = g_ApplnMgr.DeleteElem
        (
        m_pszMetabaseKey,
        _tcslen(m_pszMetabaseKey) * sizeof(TCHAR)
        );
    Assert(pLinkElem);
    Assert(static_cast<CAppln *>(pLinkElem) == this);

    //
    // Indicate to Delete All Sessions.
    // This also doubles up as a flag to indicate that this application has been placed on the application cleanup queue.
    //
    m_fGlobalChanged = TRUE;

    // Unlock
    g_ApplnMgr.UnLock();

    // Increment the count of restarting applications
    InterlockedIncrement((LPLONG)&g_nApplicationsRestarting);

    // Increment the count of restarted applications
    InterlockedIncrement((LPLONG)&g_nApplicationsRestarted);

    m_pSessionMgr->UnScheduleSessionKiller();

    // cleanup the directory monitor entries

    Lock(); // Place critical Section around access to m_rgpvDME
    while (m_rgpvDME.Count())
    {
        static_cast<CDirMonitorEntry *>(m_rgpvDME[0])->Release();
        m_rgpvDME.Remove(0);
    }

    m_rgpvDME.Clear();
    UnLock();


    // add this application to the CleanupManager...
    g_ApplnCleanupMgr.AddAppln(this);

    return S_OK;
}

/*===================================================================
CAppln::ApplnCleanupProc

Called by the g_ApplnCleanupMgr thread to complete cleanup

===================================================================*/
DWORD __stdcall CAppln::ApplnCleanupProc(VOID  *pArg)
{
    CAppln *pAppln = (CAppln *)pArg;

    DBGPRINTF((DBG_CONTEXT, "[ApplnCleanupProc] enterred for %S, %p\n", pAppln->m_pszMetabaseKey, pArg));

    // Let the requests to drain while trying to delete sessions
    while ((pAppln->m_cRequests || pAppln->m_cSessions))
        {
        if (pAppln->m_cSessions)
            pAppln->m_pSessionMgr->DeleteAllSessions(FALSE);

        if (pAppln->m_cSessions || pAppln->m_cRequests)
            Sleep(200);
        }

    g_ApplnMgr.DeleteApplicationIfExpired(pAppln);

    // Decrement the count of restarting applications
    InterlockedDecrement((LPLONG)&g_nApplicationsRestarting);

    // Wake up the thread so that other threads can run.
    g_ApplnCleanupMgr.Wakeup();

    //
    // Corresponds to the Addref in Restart.
    // Once the request has been queued to COM we can release its reference
    //
    pAppln->Release();

    return 0;
}

/*===================================================================
CAppln::UnInit

Convert to tombstone state

Parameters:
    NONE

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CAppln::UnInit()
    {
    Assert(!m_fTombstone);  // don't do it twice

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Uniniting  application %S, %p\n", m_pszApplnPath, this));
#else
    DBGPRINTF((DBG_CONTEXT, "Uniniting  application %s, %p\n", m_pszApplnPath, this));
#endif
#endif // DBG_NOTIFICATION

    // Flush the global.asa from the script engine cache
    if (m_pszGlobalAsa)
        {
        g_ScriptManager.FlushCache(m_pszGlobalAsa);
        }

    if (m_pGlobalTemplate)
        {
        // Keep template (and inc file) cache locked while releasing
        // GLOBAL.ASA template so that it wouldn't step onto Flush logic
        //
        // NOTE: CTemplate::End potentially queues global.asa for cleanup on
        //       our thread!  CleanupEngines() must therefore be called
        //       *after* this step.
        //
        LockTemplateAndIncFileCaches();
        m_pGlobalTemplate->End();
        UnLockTemplateAndIncFileCaches();

        m_pGlobalTemplate = NULL;
        }

    //If NT, remove this app from any file/appln mappings it may be in
    g_FileAppMap.Lock();
    int i = m_rgpvFileAppln.Count();
    while (i > 0)
    {
#ifdef DBG_NOTIFICATION
        DBGPRINTF((DBG_CONTEXT, "Removing application from File/App mapping\n"));
#endif // DBG_NOTIFICATION

        static_cast<CFileApplnList *>(m_rgpvFileAppln[0])->RemoveApplication(this);
        m_rgpvFileAppln.Remove(0);
        i--;
    }
    g_FileAppMap.UnLock();
    m_rgpvFileAppln.Clear();

    Lock(); // Protecting m_rqpvDME with a critical section
    //
    // In case there are some DME's left around then release them.
    //
    while (m_rgpvDME.Count())
    {
        static_cast<CDirMonitorEntry *>(m_rgpvDME[0])->Release();
        m_rgpvDME.Remove(0);
    }

    //
    // Safe to free the array now.
    //
    m_rgpvDME.Clear();

    UnLock();

        // If debuggable application, clean up pending scripts
    if (m_fDebuggable)
        g_ApplnMgr.CleanupEngines();


    // Free the properties collection
    if (m_pProperties)
        {
        m_pProperties->UnInit();
        m_pProperties->Release();
        m_pProperties = NULL;
        }

    // Free the tagged objects collection
    if (m_pTaggedObjects)
        {
        m_pTaggedObjects->UnInit();
        m_pTaggedObjects->Release();
        m_pTaggedObjects = NULL;
        }

    // Before we close down, debuggable templates need to be made non-debuggable
    if (m_fDebuggable)
        g_TemplateCache.RemoveApplicationFromDebuggerUI(this);

    if (m_pAppRoot)
        {
        m_pAppRoot->Detach();
        m_pAppRoot->Close();
        m_pAppRoot->Release();
        m_pAppRoot = NULL;
        }

    if (m_pApplCompCol)
        {
        delete m_pApplCompCol;
        m_pApplCompCol = NULL;
        }

    if (m_pActivity)
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    if (m_pSessionMgr)
        {
        delete m_pSessionMgr;
        m_pSessionMgr = NULL;
        }

    if (m_pAppConfig)
        {
		m_pAppConfig->UnInit();

        // Using Reference counting on the CAppConfig object.
        m_pAppConfig->Release();

        m_pAppConfig = NULL;
        }

    if (m_pdispGlobTypeLibWrapper)
        {
        m_pdispGlobTypeLibWrapper->Release();
        m_pdispGlobTypeLibWrapper = NULL;
        }

    if (m_pszGlobalAsa)
        {
        // If there was a change notification on global.asa
        // then flush the template now.
        // UNDONE: flush correct global.asa
        if (m_fGlobalChanged)
            g_TemplateCache.Flush(m_pszGlobalAsa, MATCH_ALL_INSTANCE_IDS);

        delete [] m_pszGlobalAsa;
        m_pszGlobalAsa = NULL;
        }

    if (m_pszMetabaseKey)
        {
        delete [] m_pszMetabaseKey;
        m_pszMetabaseKey = NULL;
        }

    if (m_pszApplnPath)
        {
        delete [] m_pszApplnPath;
        m_pszApplnPath = NULL;
        }

    if (m_pszApplnVRoot)
        {
        delete [] m_pszApplnVRoot;
        m_pszApplnVRoot = NULL;
        }

    if (m_fInternalLockInited)
        DeleteCriticalSection(&m_csInternalLock);

    if (m_fApplnLockInited)
        DeleteCriticalSection(&m_csApplnLock);

    if (m_pServicesConfig)
    {
        m_pServicesConfig->Release();
        m_pServicesConfig = NULL;
    }

    // Mark this application as Tombstone
    m_fTombstone = TRUE;

    InterlockedDecrement((LPLONG)&g_nApplications);

	// Disconnennect from proxies (in case we are shutting down or will shortly shut down)

	CoDisconnectObject(static_cast<IApplicationObject *>(this), 0);

    return S_OK;
    }

/*===================================================================
CAppln::BindToActivity

Creates application level activity either
    as a clone of the given activity or
    as a brand new activity

Must be called within critical section. Does not lock itself.

Parameters:
    CViperActivity *pActivity       activity to clone (could be NULL)

Returns:
    NONE
===================================================================*/
HRESULT CAppln::BindToActivity
(
CViperActivity *pActivity
)
    {
    if (m_pActivity)
        {
        // multiple requests to bind to new activity are ok
        if (!pActivity)
            return S_OK;
        // but not to clone from an existing activity
        Assert(FALSE);
        return E_FAIL;
        }

    m_pActivity = new CViperActivity;
    if (!m_pActivity)
        return E_OUTOFMEMORY;

    HRESULT hr;

    if (pActivity)
        hr = m_pActivity->InitClone(pActivity);
    else
        hr = m_pActivity->Init(m_pServicesConfig);

    if (FAILED(hr))
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    return hr;
    }

/*===================================================================
CAppln::SetGlobalAsa

Remembers GLOBAL.ASA file path for this application

Parameters:
    const char *pszGlobalAsa    path to (copy and) remember

Returns:
    HRESULT
===================================================================*/
HRESULT CAppln::SetGlobalAsa
(
const TCHAR *pszGlobalAsa
)
    {
    // remove existing
    if (m_pszGlobalAsa)
        {
        delete [] m_pszGlobalAsa;
        m_pszGlobalAsa = NULL;
        }

    // store new
    if (pszGlobalAsa)
        {
        DWORD cch = _tcslen(pszGlobalAsa);
        DWORD cb = (cch + 1) * sizeof(TCHAR);

        m_pszGlobalAsa = new TCHAR[cch+1];
        if (!m_pszGlobalAsa)
            return E_OUTOFMEMORY;

        memcpy(m_pszGlobalAsa, pszGlobalAsa, cb);
        }

    return S_OK;
    }

/*===================================================================
CAppln::AddDirMonitorEntry

Remembers change notifcation monitor entries for this application

Parameters:
    pDirMonitorEntry    pointer to DME

Returns:
    S_OK if the monitor entry was added to the list
===================================================================*/
HRESULT CAppln::AddDirMonitorEntry(CDirMonitorEntry *pDirMonitorEntry)
    {
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pDirMonitorEntry);

    HRESULT hr = S_OK;

   // Add the DME to the list
   Lock(); // Protect m_rgpvDME by critical section
   if (FAILED(hr = m_rgpvDME.Append(pDirMonitorEntry)))
        {
        pDirMonitorEntry->Release();
        }
   UnLock();
    return hr;

    }

/*===================================================================
CAppln::AddFileApplnEntry

Remembers change notifcation monitor entries for this application

Parameters:
    pFileAppln    pointer to FileApplnEntry

Returns:
    S_OK if the monitor entry was added to the list
    S_FALSE if the monitor entry was alread in the list
===================================================================*/
HRESULT CAppln::AddFileApplnEntry(CFileApplnList *pFileAppln)
    {
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pFileAppln);

    HRESULT hr = S_OK;
    int index;

    // See if the file/application entry is alreay in the list
    hr = m_rgpvFileAppln.Find(pFileAppln, &index);
    if (hr == S_FALSE)
        {
       // Add the file/application entry to the list
       hr = m_rgpvFileAppln.Append(pFileAppln);
        }
    else
        {
        // The file/application entry was already in the list
        hr = S_FALSE;
        }
    return hr;

    }

/*===================================================================
CAppln::LogSWCError

Logs an error to the NT Event log for any config errors that arise
in using COM+ Services Without Components.

Parameters:
    REFIID riid
    void **ppv

Returns:
    HRESULT
===================================================================*/
void CAppln::LogSWCError(enum    eSWCERRORS     error)
{
    LPCSTR  szStrings[4];
    LPCWSTR szwStrings[4];
    WORD    cStrings = 0;
    DWORD   dwEventID = 0;
    BOOL    fUnicode = FALSE;


    switch(error) {

        case PartitionAccessDenied : {
            if (m_fSWC_PartitionAccessDenied == FALSE) {
                m_fSWC_PartitionAccessDenied = TRUE;
                dwEventID    = MSG_SWC_PARTITION_ACCESS_DENIED;
                szStrings[0] = m_pAppConfig->szPartition();
                cStrings     = 1;
            }
            break;
        }

        case InvalidPartitionGUID: {
            if (m_fSWC_InvalidPartitionGUID == FALSE) {
                m_fSWC_InvalidPartitionGUID = TRUE;
                dwEventID   = MSG_SWC_INVALID_PARTITION_GUID;
                szwStrings[0] = m_pszApplnVRoot;
                cStrings = 1;
                fUnicode = TRUE;
            }
            break;
        }
    }
    if (dwEventID) {

        if (fUnicode)
            ReportAnEventW(dwEventID, (WORD) EVENTLOG_ERROR_TYPE, cStrings, szwStrings);
        else
            ReportAnEvent(dwEventID, (WORD) EVENTLOG_ERROR_TYPE, cStrings, szStrings);
    }
}



/*===================================================================
CAppln::QueryInterface

QueryInterface() -- IApplicationObject implementation.

Parameters:
    REFIID riid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CAppln::QueryInterface
(
REFIID riid,
void **ppv
)
    {
    *ppv = NULL;

    if (IID_IUnknown           == riid ||
        IID_IDispatch          == riid ||
        IID_IApplicationObject == riid ||
        IID_IDenaliIntrinsic   == riid)
        {
        *ppv = static_cast<IApplicationObject *>(this);
        }
    else if (IID_ISupportErrorInfo == riid)
        {
        *ppv = &m_ISuppErrImp;
        }
    else if (IID_IMarshal == riid)
        {
        Assert( m_pUnkFTM != NULL );

        if ( m_pUnkFTM == NULL )
        {
            return E_UNEXPECTED;
        }

        return m_pUnkFTM->QueryInterface( riid, ppv );

        }
    if (*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }

/*===================================================================
CAppln::AddRef

AddRef() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CAppln::AddRef()
{
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);

    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }
    return cRefs;
}

/*===================================================================
CAppln::Release

Release() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CAppln::Release()
    {

    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);

    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }

    if (cRefs)
        return cRefs;

    delete this;

    InterlockedDecrement((LPLONG)&g_nApplicationObjectsActive);

    return 0;
    }

/*===================================================================
CAppln::CheckForTombstone

Tombstone stub for IApplicationObject methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CAppln::CheckForTombstone()
    {
    if (!m_fTombstone)
        return S_OK;

    ExceptionId
        (
        IID_IApplicationObject,
        IDE_APPLICATION,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }
/*===================================================================
CAppln::Lock

IApplicationObject method.

Will allow the user to lock the application intrinsic for the
purpose of adding/deleting values.

Parameters:
    NONE

Returns:
    HRESULT        S_OK on success
                E_FAIL otherwise
===================================================================*/
STDMETHODIMP CAppln::Lock()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    Assert(m_fApplnLockInited);

    DWORD dwId = GetCurrentThreadId();

    // If this thread already has the lock, increment lock ref count

    if (m_dwLockThreadID == dwId)
        {
        m_cLockRefCount++;
        }
    else
        {
        EnterCriticalSection(&m_csApplnLock);
        m_cLockRefCount = 1;
        m_dwLockThreadID = dwId;
        }

    return S_OK;
    }

/*===================================================================
CAppln::UnLock

IApplicationObject method.

Will allow the user to unlock the application intrinsic only
if it has been locked by this user.

Parameters:
    NONE

Returns:
    HRESULT        S_OK
===================================================================*/
STDMETHODIMP CAppln::UnLock()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_dwLockThreadID == GetCurrentThreadId())
        {
        if (--m_cLockRefCount == 0)
            {
            // Unlock the application
            m_dwLockThreadID = INVALID_THREADID;
            LeaveCriticalSection(&m_csApplnLock);
            }
        }

    return S_OK;
    }

/*===================================================================
CAppln::UnLockAfterRequest

Remove any application locks left by the user script

Parameters:
    NONE

Returns:
    HRESULT        S_OK
===================================================================*/
HRESULT CAppln::UnLockAfterRequest()
    {
    Assert(!m_fTombstone);

    if (m_cLockRefCount > 0 && m_dwLockThreadID == GetCurrentThreadId())
        {
        m_cLockRefCount = 0;
        m_dwLockThreadID = INVALID_THREADID;
        LeaveCriticalSection(&m_csApplnLock);
        }
    return S_OK;
    }

/*===================================================================
CAppln::get_Value

IApplicationObject method.

Will allow the user to retreive a application state variable,
the variable will come as a named pair, bstr is the name and
var is the value or object to be returned for that name

Parameters:
    BSTR FAR *     bstrName    Name of the variable to get
    VARIANT *    pVar         Value/object to get for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::get_Value
(
BSTR bstrName,
VARIANT *pVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    VariantInit(pVar); // default variant empty

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        return S_OK; // no name - no value - no error
    //_wcsupr(pwszName);

    Assert(m_pApplCompCol);

    HRESULT           hr   = S_OK;
    CComponentObject *pObj = NULL;

    // Lock the application
    Lock();

    hr = m_pApplCompCol->GetProperty(pwszName, &pObj);

    if (SUCCEEDED(hr))
        {
        Assert(pObj);
        hr = pObj->GetVariant(pVar);
        }

    // UnLock the application
    UnLock();

    return S_OK;
    }

/*===================================================================
CAppln::putref_Value

IApplicationObject method.

Will allow the user to assign a application state variable to be saved
the variable will come as a named pair, bstr is the name and
var is the value or object to be stored for that name

Parameters:
    BSTR     bstrName    Name of the variable to set
    VARIANT Var            Value/object to set for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::putref_Value
(
BSTR bstrName,
VARIANT Var
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FIsIntrinsic(&Var))
        {
        ExceptionId(IID_IApplicationObject, IDE_APPLICATION,
                    IDE_APPLICATION_CANT_STORE_INTRINSIC);
        return E_FAIL;
        }

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    HRESULT hr;

    Assert(m_pApplCompCol);

    // Prepare property name
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }
    //_wcsupr(pwszName);

    // Lock the application
    Lock();

    hr = m_pApplCompCol->AddProperty(pwszName, &Var);

    // Unlock the application
    UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    return hr;
    }

/*===================================================================
CAppln::put_Value

IApplicationObject method.

Implement property put by dereferencing variants before
calling putref.

Parameters:
    BSTR FAR *     bstrName    Name of the variable to set
    VARIANT     Var            Value/object to set for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::put_Value
(
BSTR bstrName,
VARIANT Var
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    HRESULT hr;

    Assert(m_pApplCompCol);

    // Prepare property name
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }
    //_wcsupr(pwszName);

    // Lock the application
    Lock();

    VARIANT varResolved;
    hr = VariantResolveDispatch(&varResolved, &Var,
                                IID_IApplicationObject,
                                IDE_APPLICATION);
    if (SUCCEEDED(hr))
        {
        hr = m_pApplCompCol->AddProperty(pwszName, &varResolved);
        VariantClear(&varResolved);
        }

    // Unlock the application
    UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    return hr;
    }

/*===================================================================
CAppln::get_Contents

Return the application contents dictionary
===================================================================*/

STDMETHODIMP CAppln::get_Contents(IVariantDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()) || !m_pProperties)
        return E_FAIL;

    return m_pProperties->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

/*===================================================================
CAppln::get_StaticObjects

Return the application static objects dictionary
===================================================================*/
STDMETHODIMP CAppln::get_StaticObjects(IVariantDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()) || !m_pTaggedObjects)
        return E_FAIL;

    return m_pTaggedObjects->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

/*===================================================================
CAppln::UpdateConfig

Updates configuration from metabase if needed
===================================================================*/
HRESULT CAppln::UpdateConfig(CIsapiReqInfo  *pIReq, BOOL *pfRestart, BOOL *pfFlushAll)
    {
    BOOL fRestart = FALSE;
    BOOL fFlushAll = FALSE;

    if (m_pAppConfig->fNeedUpdate())
        {
        InternalLock();

        if (m_pAppConfig->fNeedUpdate()) // still need update?
            {

            char lastPartitionGUID[64];
            lastPartitionGUID[0] = '\0';

            BOOL fAllowedDebugging   = m_pAppConfig->fAllowDebugging();
            BOOL fAllowedClientDebug = m_pAppConfig->fAllowClientDebug();
            BOOL fAllowedRestart     = m_pAppConfig->fEnableApplicationRestart();
            BOOL fParentPathsEnabled = m_pAppConfig->fEnableParentPaths();
            UINT uLastCodePage       = m_pAppConfig->uCodePage();
            LCID uLastLCID           = m_pAppConfig->uLCID();
            BOOL fPrevSxsEnabled     = m_pAppConfig->fSxsEnabled();
            BOOL fPrevUsePartition   = m_pAppConfig->fUsePartition();
            BOOL fPrevUseTracker     = m_pAppConfig->fTrackerEnabled();
            BOOL fPrevKeepSessionIDSecure = m_pAppConfig->fKeepSessionIDSecure();
            BOOL fPrevCalcLineNumber = m_pAppConfig->fCalcLineNumber();
            if (m_pAppConfig->fUsePartition() && m_pAppConfig->szPartition()) {
                strncpy(lastPartitionGUID, m_pAppConfig->szPartition(), sizeof(lastPartitionGUID));
                lastPartitionGUID[sizeof(lastPartitionGUID)-1] = '\0';
            }

            BOOL fRestartEnabledUpdated = m_pAppConfig->fRestartEnabledUpdated();
			char szLastDefaultEngine[64];
			strncpy(szLastDefaultEngine, m_pAppConfig->szScriptLanguage(), sizeof szLastDefaultEngine);
			szLastDefaultEngine[sizeof(szLastDefaultEngine) - 1] = '\0';

            m_pAppConfig->Update(pIReq);

            BOOL fAllowDebugging     = m_pAppConfig->fAllowDebugging();
            BOOL fAllowClientDebug   = m_pAppConfig->fAllowClientDebug();
            BOOL fAllowRestart       = m_pAppConfig->fEnableApplicationRestart();
            BOOL fEnableParentPaths  = m_pAppConfig->fEnableParentPaths();
            UINT uCodePage           = m_pAppConfig->uCodePage();
            LCID uLCID               = m_pAppConfig->uLCID();
            BOOL fCurSxsEnabled      = m_pAppConfig->fSxsEnabled();
            BOOL fCurUsePartition    = m_pAppConfig->fUsePartition();
            BOOL fCurUseTracker      = m_pAppConfig->fTrackerEnabled();
            BOOL fCurKeepSessionIDSecure = m_pAppConfig->fKeepSessionIDSecure();
            BOOL fCurCalcLineNumber = m_pAppConfig->fCalcLineNumber();

			const char *szNewDefaultEngine = m_pAppConfig->szScriptLanguage();

            fFlushAll = strcmpi(szLastDefaultEngine, szNewDefaultEngine) != 0
                        || (fParentPathsEnabled != fEnableParentPaths)
                        || (uLastCodePage != uCodePage)
                        || (uLastLCID != uLCID);

            fRestart = (fAllowDebugging != fAllowedDebugging) ||
                       (fAllowClientDebug != fAllowedClientDebug) ||
                       ((fAllowRestart  != fAllowedRestart) && fAllowRestart) ||
                       ((fAllowRestart == fAllowedRestart) && fRestartEnabledUpdated) ||
                       (fCurSxsEnabled != fPrevSxsEnabled) ||
                       (fCurUsePartition != fPrevUsePartition) ||
                       (fCurUseTracker != fPrevUseTracker) ||
                       (fCurKeepSessionIDSecure != fPrevKeepSessionIDSecure) ||
                       (fCurCalcLineNumber != fPrevCalcLineNumber) ||
                       (fCurUsePartition
                            && fPrevUsePartition
                            && ((m_pAppConfig->szPartition() == NULL)
                                || (strcmpi(lastPartitionGUID, m_pAppConfig->szPartition()) != 0))) ||
                       fFlushAll;
            }
        InternalUnLock();
        }

    if (pfRestart)
        *pfRestart = fRestart;

    if (pfFlushAll)
        *pfFlushAll = fFlushAll;

    return S_OK;
    }

/*===================================================================
CAppln::FPathMonitored()

Checks the list of DMEs in application to see if the specified path
is already being monitored.

===================================================================*/
CASPDirMonitorEntry  *CAppln::FPathMonitored(LPCTSTR  pszPath)
{
    int i;

    Lock(); // Protect m_rqpvDME by a critical section
    int cDMEs = m_rgpvDME.Count();
    for (i=0; i < cDMEs; i++) {
        CASPDirMonitorEntry  *pDME = static_cast<CASPDirMonitorEntry *>(m_rgpvDME[i]);
        if (pDME == NULL)
            break;
        if (pDME->FPathMonitored(pszPath))
        {
            UnLock();
            return pDME;
        }
    }

    UnLock();
    return NULL;
}

#ifdef DBG
/*===================================================================
CAppln::AssertValid

Test to make sure that the CAppln object is currently correctly
formed and assert if it is not.

Returns:
    Nothing

Side effects:
    None.
===================================================================*/
void CAppln::AssertValid() const
    {
    Assert(m_fInited);

    Assert(m_pSessionMgr);

    Assert(m_pApplCompCol);
    m_pApplCompCol->AssertValid();
    }
#endif // DBG


/*===================================================================
  C  A p p l n  M g r
===================================================================*/

/*===================================================================
CApplnMgr::CApplnMgr

Application Manager constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnMgr::CApplnMgr()
    : m_fInited(FALSE),
      m_fHashTableInited(FALSE),
      m_fCriticalSectionInited(FALSE),
      m_cntApp(0),
      m_pMetabase(NULL),
      m_pMetabaseSink(NULL),
      m_dwMDSinkCookie(0)
    {
    }

/*===================================================================
CApplnMgr::~CApplnMgr

Application Manager destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnMgr::~CApplnMgr()
{
    if (!m_fInited)
        UnInit();
}

/*===================================================================
HRESULT CApplnMgr::Init

Initializes the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnMgr::Init( void )
    {
    HRESULT hr = S_OK;

    Assert(!m_fInited);

    // Init hash table

    hr = CHashTable::Init(NUM_APPLMGR_HASHING_BUCKETS);
    if (FAILED(hr))
        return hr;
    m_fHashTableInited = TRUE;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
    m_fCriticalSectionInited = TRUE;

    m_fInited = TRUE;

    return g_ApplnCleanupMgr.Init();
    }

/*===================================================================
HRESULT CApplnMgr::UnInit

UnInitializes the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/
HRESULT CApplnMgr::UnInit( void )
{
    //
    // release the metabase change notification. Ignore return value as it is always S_OK
    //
    UnInitMBListener();

    //
    // Wait for COM to release all Sinks
    //
    while (!g_fProceedWithShutdownAppln)
       Sleep (100);


    if (m_fHashTableInited)
        {
        CHashTable::UnInit();
        m_fHashTableInited = FALSE;
        }

    if (m_fCriticalSectionInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
        }

    m_fInited = FALSE;
    return g_ApplnCleanupMgr.UnInit();
}

/*===================================================================
HRESULT CApplnMgr::InitMBListener

Registers the CMDAppConfigSink object to listen to sink notifications. Performs an Advise on the ABO

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/

HRESULT CApplnMgr::InitMBListener( )
{

    HRESULT                         hr = S_OK;
    IConnectionPointContainer		*pConnPointContainer = NULL;
	IConnectionPoint				*pConnPoint = NULL;
	IClassFactory 					*pcsfFactory = NULL;
	HANDLE                          hCurrentUser = INVALID_HANDLE_VALUE;

    //
    // Get a pointer to the Metabase
    //

    AspDoRevertHack (&hCurrentUser);

    hr = GetMetabaseIF(&m_pMetabase);

    if (FAILED(hr))
    {
        AspUndoRevertHack (&hCurrentUser);
        return hr;
    }

    //
    // Register to get notifications on the Sink
    //
	m_pMetabaseSink = new CMDAppConfigSink(this);
    if (!m_pMetabaseSink)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

	m_dwMDSinkCookie = 0;

    if (SUCCEEDED(hr))
    {
	    //Advise Metabase about SinkNotify().
	    hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);

	    if (pConnPointContainer != NULL)
	    {
		    //Find the requested Connection Point.  This AddRef's the return pointer.
		    hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
		    pConnPointContainer->Release();

		    if (pConnPoint != NULL)
		    {
			    hr = pConnPoint->Advise((IUnknown *)m_pMetabaseSink, &m_dwMDSinkCookie);
			    pConnPoint->Release();
		    }
	    }
    }

LExit:
    if (FAILED(hr))
    {
        m_pMetabase->Release();
        m_pMetabase = NULL;
    }

    AspUndoRevertHack(&hCurrentUser);

    return hr;
}

/*===================================================================
HRESULT CApplnMgr::UnInitMBListener

Unregisters the Application manager from receiving sink notifications. Performs an UnAdvise on the ABO

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnMgr::UnInitMBListener( )
{
    HRESULT 						hr 						= S_OK;
	IConnectionPointContainer		*pConnPointContainer	= NULL;
	IConnectionPoint				*pConnPoint 			= NULL;
    CHAR                            szErr[256];
	HANDLE                          hCurrentUser = INVALID_HANDLE_VALUE;
	
    AspDoRevertHack (&hCurrentUser);

    if (m_pMetabase) {

        //Advise Metabase about SinkNotify().
	    hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
	    if (pConnPointContainer != NULL)
		    {
		    //Find the requested Connection Point.  This AddRef's the return pointer.
		    hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);

		    if (FAILED(hr))
		        {
                DBGPRINTF((DBG_CONTEXT, "FindConnectionPoint failed. hr = %08x\n", hr));
                }

		    pConnPointContainer->Release();
		    if (pConnPoint != NULL)
			    {
			    hr = pConnPoint->Unadvise(m_dwMDSinkCookie);
			    if (FAILED(hr))
				    {
				    DBGPRINTF((DBG_CONTEXT, "UnAdvise App Config Change Notify failed. hr = %08x\n", hr));
				    }
			    hr = S_OK; // benign failure if Advise was not called (happens with unknown script lang)
			    pConnPoint->Release();
			    m_dwMDSinkCookie = 0;
			    }
		    }
	    else
	        {
	        DBGPRINTF((DBG_CONTEXT, "QueryInterface failed. hr = %08x\n", hr));
	        }
        m_pMetabase->Release();
        m_pMetabase = NULL;
    }

    if (m_pMetabaseSink) {
		m_pMetabaseSink->Release();
		m_pMetabaseSink = NULL;
    }

    AspUndoRevertHack (&hCurrentUser);

    //
    // Always return S_OK.  In the new world, the metabase may have gone away
    // because of a WAS recycle.  So, it can happen that even the QI's above will fail.
    //
    return S_OK;
}


/*===================================================================
HRESULT CApplnMgr::NotifyAllMBListeners

When the RPC thread calls the CMDAppConfigSink objects SinkNotify method. This method is called
which will iterate through all the applications and call each applications appconfig object to update thier
config information

Parameters:
    dwMDNumElements - number of elements in the change list.

    pcoChangeList - The list of changes

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnMgr::NotifyAllMBListeners( DWORD dwMDNumElements, MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList [ ] )
{
    HRESULT hr = S_OK;

    Lock();

    CLinkElem *pLink = CHashTable::Head();

    while (pLink)
    {
        CAppln *pAppln = static_cast<CAppln *>(pLink);
        pLink = pLink->m_pNext;

        if (pAppln->m_fDeleteInProgress)
            continue;

        hr = pAppln->QueryAppConfig()->SinkNotify(dwMDNumElements, pcoChangeList);
        if (FAILED(hr))
            break;
    }

    UnLock();
    return hr;
}


/*===================================================================
CApplnMgr::AddAppln

Adds a CAppln element to link list / hash table.
User has to check if Appln already exists before calling this.
Critical sectioning is in CHitObj::BrowserRequestInit().

Parameters:
    char   *pszApplnKey         Application metabase key
    char   *pszApplnPath        Application directory path
    CIsapiReqInfo   *pIReq

    CAppln **ppAppln            [out] Application created

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::AddAppln
(
TCHAR    *pszApplnKey,
TCHAR    *pszApplnPath,
CIsapiReqInfo   *pIReq,
CAppln **ppAppln
)
    {
    *ppAppln = NULL;   // return NULL if failed

    // Create CAppln object

    CAppln *pAppln = new CAppln;

    if (!pAppln)
        return E_OUTOFMEMORY;

    // Init CAppln object

    HRESULT hr;

    hr = pAppln->Init
        (
        pszApplnKey,
        pszApplnPath,
        pIReq
        );

    if (FAILED(hr))
        {
        pAppln->UnInit();
        pAppln->Release();
        return hr;
        }

    // Add to hash table

    if (!CHashTable::AddElem(pAppln))
        {
        pAppln->UnInit();
        pAppln->Release();
        return E_FAIL;
        }

    *ppAppln = pAppln;
    return S_OK;
    }

/*===================================================================
CApplnMgr::FindAppln

Finds CAppln in hash table
Critical sectioning must be done outside

Parameters:
    char   *pszApplnKey         Application metabase key
    CAppln **ppAppln            [out] Application found

Returns:
    S_OK            if found
    S_FALSE         if not found
===================================================================*/
HRESULT CApplnMgr::FindAppln
(
TCHAR *pszApplnKey,
CAppln **ppAppln
)
    {
    CLinkElem *pLinkElem = CHashTable::FindElem
        (
        pszApplnKey,
        _tcslen(pszApplnKey)*sizeof(TCHAR)
        );

    if (!pLinkElem)
        {
        *ppAppln = NULL;
        return S_FALSE;
        }

    *ppAppln = static_cast<CAppln *>(pLinkElem);
    return S_OK;
    }
/*===================================================================
CApplnMgr::AddEngine

When a change notification occurs for a file being debugged,
we need to delete its associated scripting engine.  The naive
approach of Releasing the engine during notification won't work
because the engine is on the wrong thread.  Instead of marshaling
to the thread (which raises possibilities of deadlock or starving
the notification thread if debugging is happening on the debug
thread), the engines are added to a queue in the application.
When a request is serviced for debugging (which is now in the
correct thread context), the application object first flushes
this list by releasing the engines
===================================================================*/
HRESULT CApplnMgr::AddEngine(CActiveScriptEngine *pEngine)
    {
    CScriptEngineCleanupElem *pScriptElem = new CScriptEngineCleanupElem(pEngine);
    if (pScriptElem == NULL)
        return E_OUTOFMEMORY;

    pScriptElem->AppendTo(m_listEngineCleanup);
    return S_OK;
    }

/*===================================================================
CApplnMgr::CleanupEngines()

Call Release all engine cleanup list.
===================================================================*/
void CApplnMgr::CleanupEngines()
    {
    while (! m_listEngineCleanup.FIsEmpty())
        delete m_listEngineCleanup.PNext();
    }


/*===================================================================
CApplnMgr::DeleteApplicationIfExpired

Removes CAppln object if exprired
Critical sectioning must be done outside

Parameters:
    CAppln *pAppln      application to delete

Returns:
    NONE
===================================================================*/
HRESULT CApplnMgr::DeleteApplicationIfExpired
(
CAppln *pAppln
)
    {
    if (!pAppln->m_fGlobalChanged)
        return S_OK;

    if (pAppln->m_cSessions || pAppln->m_cRequests)
        return S_OK;

    if (pAppln->m_fDeleteInProgress)
        return S_OK;

    pAppln->m_fDeleteInProgress = TRUE;

    HRESULT hr = S_OK;

    // Queue it up for deletion
    CHitObj *pHitObj = new CHitObj;
    if (!pHitObj)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        pHitObj->ApplicationCleanupInit(pAppln);

        // Ask Viper to queue this request
        hr = pHitObj->PostViperAsyncCall();
        }

    // cleanup
    if (FAILED(hr) && pHitObj) {
        pAppln->UnInit();
        pAppln->Release();
        delete pHitObj;
    }

    return hr;
    }

/*===================================================================
CApplnMgr::DeleteAllApplications

Removes CAppln objects from the application manager link list
and hash table.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::DeleteAllApplications()
    {
    HRESULT hr = S_OK;

    Lock();

    CLinkElem *pLink = CHashTable::Head();
    CHashTable::ReInit();

    while (pLink)
        {
        CAppln *pAppln = static_cast<CAppln *>(pLink);
        pLink = pLink->m_pNext;

        if (pAppln->m_fDeleteInProgress)
            continue;

        pAppln->m_fDeleteInProgress = TRUE;


        // Queue it up for deletion
        CHitObj *pHitObj = new CHitObj;
        if (!pHitObj)
            {
            hr = E_OUTOFMEMORY;
            break;
            }

        // If NT, Unregister for notifications
        while ((pAppln->m_rgpvDME).Count())
        {
            static_cast<CDirMonitorEntry *>(pAppln->m_rgpvDME[0])->Release();
            (pAppln->m_rgpvDME).Remove(0);
        }
        pAppln->m_rgpvDME.Clear();


        pHitObj->ApplicationCleanupInit(pAppln);

        // Ask Viper to queue this request
        hr = pHitObj->PostViperAsyncCall();
        if (FAILED(hr))
            {
            pAppln->UnInit();
            pAppln->Release();

            delete pHitObj;
            break;
            }

        }

    UnLock();
    return hr;
    }

/*===================================================================
CApplnMgr::RestartAllChagnedApplications

Restarts CAppln objects from the application manager link list
We walk the list recording which applications are dependent
on files that have changed since they were compiled. Once we
have the list, we restart each of the applications.

This is a fall back when we may have missed a change notification,
for instance when we had insufficient buffer to record all the changes
that occured.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::RestartApplications(BOOL fRestartAllApplications)
    {
    HRESULT hr = S_OK;

    Lock();

    CLinkElem *pLink = CHashTable::Head();

    // Find out which applications need restarting

    while (pLink)
    {
        CAppln *pAppln = static_cast<CAppln *>(pLink);
        pLink = pLink->m_pNext;
        if (!pAppln->FTombstone() && (fRestartAllApplications || (pAppln->m_pGlobalTemplate != NULL && pAppln->m_pGlobalTemplate->FTemplateObsolete())))
        {
            pAppln->Restart();
        }
    }

    UnLock();

    return hr;
}

/*===================================================================
  C  A p p l n  C l e a n u p  M g r
===================================================================*/

/*===================================================================
CApplnMgr::CApplnCleanupMgr

Application Cleanup Manager constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnCleanupMgr::CApplnCleanupMgr()
    : m_fInited(FALSE),
      m_fCriticalSectionInited(FALSE),
      m_hThreadAlive(NULL),
      m_cCleanupThreads(0),
      m_hAppToCleanup(INVALID_HANDLE_VALUE)
    {
    m_List.m_pPrev = &m_List;
    m_List.m_pNext = &m_List;

    // Clean out the thread count
    ZeroMemory(&m_hCleanupThreads, sizeof (m_hCleanupThreads));

    }

/*===================================================================
CApplnCleanupMgr::~CApplnCleanupMgr

Application Cleanup Manager destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnCleanupMgr::~CApplnCleanupMgr()
{
    // safety measure to prevent UnInit() from calling Sleep()
    UnInit();
}

/*===================================================================
HRESULT CApplnCleanupMgr::Init

Initializes the Appln Cleanup Manager.

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnCleanupMgr::Init( void )
{
    HRESULT hr = S_OK;

    Assert(!m_fInited);

    // Create delete app event

    m_hAppToCleanup = IIS_CREATE_EVENT(
                              "CApplnCleanupMgr::m_hAppToCleanup",
                              this,
                              FALSE,
                              FALSE
                              );

    if (!m_hAppToCleanup)
        return E_FAIL;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
    m_fCriticalSectionInited = TRUE;

    m_hThreadAlive = CreateThread(NULL, 0, CApplnCleanupMgr::ApplnCleanupThread, NULL , CREATE_SUSPENDED , NULL);

    if (!m_hThreadAlive)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    m_fInited = TRUE;

    if (ResumeThread (m_hThreadAlive) == (DWORD) -1)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

/*===================================================================
HRESULT CApplnCleanupMgr::UnInit

UnInitializes the Appln Cleanup Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/
HRESULT CApplnCleanupMgr::UnInit( void )
{
    HRESULT hr = S_OK;
    // set fInited to FALSE here so that the cleanup thread
    // can safely detect that we're shutting down.

    m_fInited = FALSE;

    if (m_hAppToCleanup != INVALID_HANDLE_VALUE) {
        // Set the event one last time so that the thread
        // wakes up, sees that shutdown is occurring and
        // exits.
        SetEvent(m_hAppToCleanup);
        CloseHandle(m_hAppToCleanup);
        m_hAppToCleanup = INVALID_HANDLE_VALUE;
    }

    // we'll wait for the thread to finish its work
    if (m_hThreadAlive)
    {
        if (WaitForSingleObject(m_hThreadAlive, INFINITE) == WAIT_FAILED)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        CloseHandle (m_hThreadAlive);

        m_hThreadAlive = NULL;
    }

    if (m_fCriticalSectionInited) {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
    }

    return hr;
}

/*===================================================================
CApplnCleanupMgr::AddAppln

Adds a CAppln element to link list / hash table.


Parameters:
    CAppln *pAppln            Application to cleanup

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnCleanupMgr::AddAppln
(
CAppln *pAppln
)
{
    HRESULT     hr = S_OK;

#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Adding App (%S)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#else
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Adding App (%s)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#endif

    Lock();

    AddElem(pAppln);

    UnLock();

    if (SUCCEEDED(hr)) {
        Wakeup();
    }

    return hr;
}

/*===================================================================
CApplnCleanupMgr::ApplnCleanupThread

The thread that does the work to cleanup applications

Parameters:

Returns:
    HRESULT
===================================================================*/
DWORD __stdcall CApplnCleanupMgr::ApplnCleanupThread(VOID  *pArg)
{
    g_ApplnCleanupMgr.ApplnCleanupDoWork();

    return 0;
}

/*===================================================================
CApplnCleanupMgr::ApplnCleanupDoWork

Proc that actually does the work

Parameters:

Returns:
    HRESULT
===================================================================*/
void CApplnCleanupMgr::ApplnCleanupDoWork()
{
    CAppln          *pAppln = NULL;
    DWORD           nThreadIndex = 0;
    HANDLE          hThread = NULL;

    // this thread will be in a constant loop checking for work

    while(1)
    {
        if (m_fInited)
            WaitForSingleObject(m_hAppToCleanup, INFINITE);

        if (Head() == NULL && m_fInited)
            continue;

        // hold the lock while in this loop.  This shouldn't hold it
        // for long as there are no long running operations in this loop.
        // If a thread can't be created and the application cleanup
        // must occur on this thread, then the lock is released.
        //
        // Rely on Head() returning NULL to break out of this loop in case of shutdown.
        // In the shutdown case we will not wait
        //

        Lock();

        pAppln = static_cast<CAppln *>(Head());

        if (!pAppln && !m_fInited)
        {
            UnLock();
            break;
        }

        RemoveElem(Head());

        UnLock();

        //
        // This loop will execute while there is work and there aren't too many
        // threads active or we're in shutdown.  The theory here is that in the
        // non-shutdown case, let's not spin up more than 4 threads at a time to
        // do the cleanup.  If in shutdown, create as many threads as necessary.
        // if no threads started yet, use the first slot
        //
        if ((m_cCleanupThreads < 4) || (IsShutDownInProgress() && (m_cCleanupThreads < MAX_CLEANUP_THREADS)))
        {
            //
            // just get the next index
            //
            nThreadIndex = m_cCleanupThreads;
        }
        else
        {
            //
            // At full capacity. So wait till one of the threads returns / terminated
            //
            nThreadIndex = WaitForMultipleObjects( m_cCleanupThreads,
                                               m_hCleanupThreads,
                                               FALSE, // wait for any event
                                               INFINITE);    // return immediately
            Assert(nThreadIndex != WAIT_TIMEOUT);
        }

        DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Cleanup Thread working on (%S)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));

        hThread = CreateThread(NULL, 0, CAppln::ApplnCleanupProc, pAppln, 0, NULL);

        // failed to create a thread to do the work.  Cleanup the app right here.
        // Unlock the cleanup manager while we are doing this.

        if (hThread == NULL)
        {
            pAppln->ApplnCleanupProc(pAppln);
        }
        else
        {
            //
            // close the previous handle if we are reusing an entry
            //
            if (nThreadIndex < m_cCleanupThreads)
            {
                //
                // we are reusing a slot from a terminated thread
                //
                CloseHandle(m_hCleanupThreads[ nThreadIndex ]);
            }
            else
            {
                //
                // we are using a new slot
                //
                Assert(nThreadIndex == m_cCleanupThreads);

                m_cCleanupThreads++;
            }

            m_hCleanupThreads[ nThreadIndex ] = hThread;
        }

    }

    if (m_cCleanupThreads)
    {
        WaitForMultipleObjects(
                 m_cCleanupThreads,
                 m_hCleanupThreads,
                 TRUE,         // wait for ALL event
                 INFINITE);    // wait for as long as it takes.

        while( m_cCleanupThreads )
        {
            CloseHandle(m_hCleanupThreads[ --m_cCleanupThreads ]);
        }
    }
}

#define            WSTR_NULL       L"\0"

/*===================================================================
  C  A p p l n  I t e r a t o r
===================================================================*/

/*===================================================================
CApplnIterator::CApplnIterator

Constructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CApplnIterator::CApplnIterator()
    : m_pApplnMgr(NULL), m_pCurr(NULL), m_fEnded(FALSE)
    {
    }

/*===================================================================
CApplnIterator::~CApplnIterator

Destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CApplnIterator::~CApplnIterator( void )
    {
    if (m_pApplnMgr != NULL)
        Stop();
    }

/*===================================================================
HRESULT CApplnIterator::Start

Starts iterator on the Appln Manager.

Parameters:
    CApplnMgr * pApplnMgr   Appln Manager
                            (if NULL g_ApplnManager is assumed)

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/

HRESULT CApplnIterator::Start
(
CApplnMgr *pApplnMgr
)
    {
    m_pApplnMgr = pApplnMgr ? m_pApplnMgr : &g_ApplnMgr;

    m_pApplnMgr->Lock();

    m_pCurr  = NULL;
    m_fEnded = FALSE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnIterator::Stop

Stops iterator on the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/

HRESULT CApplnIterator::Stop()
    {
    if (m_pApplnMgr)
        {
        m_pApplnMgr->UnLock();
        m_pApplnMgr = NULL;
        }

    m_pCurr  = NULL;
    m_fEnded = FALSE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnIterator::Next

Iterates to the next Appln.

Parameters:
    NONE

Returns:
    Appln * or NULL
===================================================================*/

CAppln *CApplnIterator::Next( void )
    {
    if (m_pApplnMgr == NULL || m_fEnded)
        return NULL;  // didn't start or already ended

    CLinkElem *pT = m_pCurr ? m_pCurr->m_pNext : m_pApplnMgr->Head();
    if (pT)
        {
        m_pCurr = static_cast<CAppln *>(pT);
        return m_pCurr;
        }

    m_fEnded = TRUE;
    return NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\appcnfg.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: AppCnfg.h

Owner: AndrewS

Useful globals
===================================================================*/

#ifndef __APPCNFG_H
#define __APPCNFG_H

#include "util.h"
#include <schnlsp.h>
#include <wincrypt.h>
#include <iadmw.h>

extern "C" {

#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs

}

//
// Defaults for registry values
//
#define DEFAULT_MAX_THREAD  100

class CAppln;   // forward declaration
class CApplnMgr;


//
//  BUGBUG:: We can have only one instance of CMDAppConfigSink. 
//  ASP Just requires one instance of this object and because we signal a global variable
//  in its destructor. Having multiple instances will cause a bug. Evaluate a change of design, behaviour 
//  in case it becomes absolutely necessary that this class needs more instances
//
class CMDAppConfigSink : public IMSAdminBaseSinkW
{
        private:
        ULONG                m_cRef;
        CApplnMgr           *m_pApplnMgr;
        
        public:        
        CMDAppConfigSink (CApplnMgr *pApplnMgr);
        
        ~CMDAppConfigSink(); 


        HRESULT STDMETHODCALLTYPE       QueryInterface(REFIID riid, void **ppv);
        ULONG   STDMETHODCALLTYPE       AddRef(void);
        ULONG   STDMETHODCALLTYPE       Release(void);

        HRESULT STDMETHODCALLTYPE       SinkNotify(
                        DWORD   dwMDNumElements,
                        MD_CHANGE_OBJECT        __RPC_FAR       pcoChangeList[]);

        HRESULT STDMETHODCALLTYPE ShutdownNotify( void)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }
};

//      Index used in ReadPropsfromRegistry().  Also, we can use the same index to enable the global
//      data to be table-driven.

#define IApp_AllowSessionState                                  0x0
#define IApp_BufferingOn                                        0x1
#define IApp_ScriptLanguage                                     0x2
#define IApp_EnableParentPaths                                  0x3
#define IApp_ScriptErrorMessage                                 0x4
#define IApp_SessionTimeout                                     0x5
#define IApp_CodePage                                           0x6
#define IApp_ScriptTimeout                                      0x7
#define IApp_ScriptErrorsSenttoBrowser                          0x8
#define IApp_AllowDebugging                                     0x9
#define IApp_AllowClientDebug                                   0xa
#define IApp_QueueTimeout                                       0xb
#define IApp_EnableApplicationRestart                           0xc
#define IApp_QueueConnectionTestTime                            0xd
#define IApp_SessionMax                                         0xe
#define IApp_ExecuteInMTA                                       0xf
#define IApp_LCID                                               0x10
#define IApp_KeepSessionIDSecure                                0x11
#define IApp_ServiceFlags                                       0x12
#define IApp_PartitionGUID                                      0x13
#define IApp_SxsName                                            0x14
#define IApp_CalcLineNumber                                 	0x15
#define IApp_RunOnEndAsAnon                                     0x16
#define IApp_BufferLimit                                        0x17
#define IApp_RequestEntityLimit                           0x18
#define IApp_MAX                                                0x19

// flags within IApp_ServiceFlags
#define IFlag_SF_TrackerEnabled     1
#define IFlag_SF_SxsEnabled         2
#define IFlag_SF_UsePartition       4

//      Index to glob's szMessage array.
#define IAppMsg_SCRIPTERROR             0
#define IAppMsg_SCRIPTLANGUAGE          1
#define IAppMsg_PARTITIONGUID           2
#define IAppMsg_SXSNAME                 3
#define APP_CONFIG_MESSAGEMAX           4

//      Default limit for response buffering
#define DEFAULT_BUFFER_LIMIT            (4 * 1024 * 1024)           // 4 M
#define DEFAULT_REQUEST_ENTITY_LIMIT            (200 * 1024)        // 200K

//      Glob data object
class CAppConfig
        {
        friend class CMDAppConfigSink;
        friend HRESULT  ReadConfigFromMD(CIsapiReqInfo *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
        friend HRESULT  SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob);

private:

        CAppln          *m_pAppln;
        BOOL            m_fNeedUpdate;
        BOOL            m_fInited:1;
        BOOL            m_fRestartEnabledUpdated:1;
		BOOL            m_fIsValidProglangCLSID:1;
        BOOL            m_fIsValidPartitionGUID:1;
        BOOL            m_fCSInited:1;
        
        //
        // Configurable values from Metabase
        //
        BOOL            m_fScriptErrorsSentToBrowser;
        BOOL            m_fBufferingOn;                                 // Is buffering on by default?
        BOOL            m_fEnableParentPaths;
        BOOL            m_fAllowSessionState;
        BOOL            m_fAllowOutOfProcCmpnts;
        BOOL            m_fAllowDebugging;
        BOOL            m_fAllowClientDebug;
        BOOL            m_fEnableApplicationRestart;
        BOOL            m_fKeepSessionIDSecure;
        BOOL            m_fCalcLineNumber;
        UINT            m_uCodePage;
        DWORD           m_dwScriptTimeout;
        DWORD           m_dwSessionTimeout;
        DWORD           m_dwQueueTimeout;
        CLSID           m_DefaultScriptEngineProgID;
        DWORD           m_dwQueueConnectionTestTime;
        DWORD           m_dwSessionMax;
        BOOL            m_fExecuteInMTA;
        LCID            m_uLCID;
        CLSID           m_PartitionGUID;
        BOOL            m_fSxsEnabled;
        BOOL            m_fTrackerEnabled;
        BOOL            m_fUsePartition;
        BOOL            m_fRunOnEndAsAnon;
        HANDLE          m_hAnonToken;
        DWORD           m_dwBufferLimit;
        DWORD           m_dwRequestEntityLimit;

        //
        // Critical Section to provide locking during update
        //
        CRITICAL_SECTION    m_csLock;
        
        LPSTR           m_szString[APP_CONFIG_MESSAGEMAX];

        ULONG           m_cRefs;

        //Private functions
        HRESULT         SetValue(unsigned int index, BYTE *lpByte);

public:

        CAppConfig();
        ~CAppConfig()  { if (m_fCSInited) DeleteCriticalSection(&m_csLock); }
        HRESULT         Init(CIsapiReqInfo  *pIReq, CAppln *pAppln);
        HRESULT         UnInit(void);

        ULONG     STDMETHODCALLTYPE          AddRef(void);
        ULONG     STDMETHODCALLTYPE         Release(void);

        void            NotifyNeedUpdate(void);
        BOOL            fNeedUpdate()                           {return m_fNeedUpdate;};
        BOOL            fRestartEnabledUpdated()                {return m_fRestartEnabledUpdated;};
        void            NotifyRestartEnabledUpdated()           { m_fRestartEnabledUpdated = TRUE;};
        HRESULT         Update(CIsapiReqInfo  *pIReq);

        UINT            uCodePage()                             {return m_uCodePage;};
        DWORD           dwSessionTimeout()                      {return m_dwSessionTimeout;};
        DWORD           dwQueueTimeout()                        {return m_dwQueueTimeout;};
        DWORD           dwScriptTimeout()                       {return m_dwScriptTimeout;};
        BOOL            fScriptErrorsSentToBrowser()            {return m_fScriptErrorsSentToBrowser;};
        BOOL            fBufferingOn()                          {return m_fBufferingOn;};
        BOOL            fEnableParentPaths()                    {return !m_fEnableParentPaths;};
        BOOL            fAllowSessionState()                    {return m_fAllowSessionState;};
        BOOL            fAllowOutOfProcCmpnts()                 {return m_fAllowOutOfProcCmpnts;};
        BOOL            fAllowDebugging()                       {return m_fAllowDebugging;};
        BOOL            fAllowClientDebug()                     {return m_fAllowClientDebug;};
        BOOL            fInited()                               {return m_fInited;};
        BOOL            fKeepSessionIDSecure()                  {return m_fKeepSessionIDSecure;};
        BOOL            fCalcLineNumber()                  {return m_fCalcLineNumber;};
        BOOL            fExecuteInMTA()                         {return m_fExecuteInMTA;};
        LCID            uLCID()                                 {return m_uLCID; };
        LPCSTR          szScriptErrorMessage()                  {return (m_szString[IAppMsg_SCRIPTERROR]);};
        LPCSTR          szScriptLanguage()                      {return (m_szString[IAppMsg_SCRIPTLANGUAGE]);};
        CLSID           *pCLSIDDefaultEngine()                  {return m_fIsValidProglangCLSID? &m_DefaultScriptEngineProgID : NULL;};
        BOOL            fSxsEnabled()                           {return m_fSxsEnabled;};
        BOOL            fTrackerEnabled()                       {return m_fTrackerEnabled;};
        BOOL            fUsePartition()                         {return m_fUsePartition;};
        CLSID           *PPartitionGUID()                       {return m_fIsValidPartitionGUID ? & m_PartitionGUID : NULL;};
        LPCSTR          szPartition()                           {return (m_szString[IAppMsg_PARTITIONGUID]);};
        LPCSTR          szSxsName()                             {return (m_szString[IAppMsg_SXSNAME]);};
        BOOL            fRunOnEndAsAnon()                       {return m_fRunOnEndAsAnon; };
        HANDLE          AnonToken()                             {return m_hAnonToken; };
        DWORD           dwBufferLimit()                         {return m_dwBufferLimit; };
        DWORD           dwRequestEntityLimit()                         {return m_dwRequestEntityLimit; };

        BOOL            fEnableApplicationRestart() { return m_fEnableApplicationRestart; }
        DWORD           dwQueueConnectionTestTime() { return m_dwQueueConnectionTestTime; }
        DWORD           dwSessionMax() { return m_dwSessionMax; }

        LPTSTR           SzMDPath();

        void Lock() { Assert(m_fCSInited); EnterCriticalSection(&m_csLock); }
        void UnLock() { Assert(m_fCSInited); LeaveCriticalSection(&m_csLock); }

        HRESULT STDMETHODCALLTYPE       SinkNotify(
                        DWORD   dwMDNumElements,
                        MD_CHANGE_OBJECT        __RPC_FAR       pcoChangeList[]);        
        };

inline void CAppConfig::NotifyNeedUpdate(void)
{
        InterlockedExchange((LPLONG)&m_fNeedUpdate, 1);
}
#endif // __APPCNFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\aspdmon.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       aspdirmon.cpp

   Abstract:
       This module includes derivation of class supporting change
       notification for ASP template cache, from abstract class DIR_MON_ENTRY

   Author:

       Charles Grant    ( cgrant )     June-1997 

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "denpre.h"
#pragma hdrstop

#include "aspdmon.h"
#include "ie449.h"
#include "memchk.h"

#ifndef UNICODE
#error "ASPDMON.CPP must be compiled with UNICODE defined"
#endif

/************************************************************
 *    Inlined Documentation on change notification
 *
 * Change Notification:
 *      This module is to used to monitor the file system for changes
 *      to scripts. We need to know about changes to scripts for two 
 *      reasons:
 *      1) To keep the template cache current
 *      2) To manage applications lifetimes. If the GLOBAL.ASA
 *          for an application, or a file included in the GLOBAL.ASA
 *          changes, that application should be restarted.
 *      
 *
 *  Outline of Change Notification System
 *
 *      To obtain change notification we use the ReadDirectoryChangesW
 *      API as wrapped by the CDirMonitor and CDirMonitorEntry classes.
 *      Three hash tables are used by the change notifcation system:
 *
 *      CTemplateCacheManager   g_TemplateCache
 *      CDirMonitor             g_DirMonitor
 *      CFileApplicationMap     g_FileAppMap
 *
 *      When a template is compiled and inserted into the g_TemplateCache
 *      the template is provided with a list of files included in that
 *      template. For each file included in the template, we search the
 *      g_DirMonitor table to see if see if we are already monitoring the
 *      files parent directory for changes. If so we simply addref the 
 *      CDirMonitorEntry instance we obtain, and save a pointer to the
 *      monitor entry in an array in the corresponding file map. If the
 *      directory is not being monitored we create a new CDirMonitorEntry'
 *      instance and add it to g_DirMonitor. When we add the monitor entry
 *      to the g_DirMonitor we launch an asynchronous request to ReadDirectoryChangesW
 *      for that directory.
 *      
 *      Managing the template cache and application life times are logically 
 *      independent activities. We must monitor GLOBAL.ASA for changes even if
 *      the GLOBAL.ASA template is not currently in the template cache.
 *      So, if the template is a GLOBAL.ASA for an application, additional work
 *      must be done. For each file included in the GLOBAL.ASA we add an entry
 *      to g_FileAppMap relating that file to the applications that depend on it.
 *      We store a back pointer to the file/application mappping in the application
 *      instance, so that the application can remove the mapping when it shuts down.
 *      In the application we store a pointer to the GLOBAL.ASA template. For
 *      each file in the GLOBAL.ASA, We check g_DirMonitor to find the monitor entry
 *      for the parent directory for that file, AddRef the monitor entry we find, and
 *      add it to a list of monitor entries in the application.
 *
 *      When a change occurs to a directory we are monitoring, the callback function
 *      DirMontiorCompletionFunction will be invoked, and in turn will invoke the
 *      the ActOnNotification method of the monitor entry for that directory. If a file
 *      has changed we use g_FileAppMap to shut down those applications that depend on
 *      that file and flush the file from the template cache.
 *
 ************************************************************/

#define MAX_BUFFER_SIZE 8192

extern BOOL g_fLazyContentPropDisabled;

PTRACE_LOG CASPDirMonitorEntry::gm_pTraceLog = NULL;
CDirMonitor *g_pDirMonitor = NULL;

CASPDirMonitorEntry::CASPDirMonitorEntry() :
    m_cNotificationFailures(0)
/*++

Routine Description:

    Constructor
    
Arguments:

    None

Return Value:

    None
--*/
{
}

CASPDirMonitorEntry::~CASPDirMonitorEntry()
/*++

Routine Description:

    Destructor
    
Arguments:

    None

Return Value:

    None
--*/
{
}


/*++
increment refcount for an entry -- writes to reftrace log if it is defined
--*/
VOID CASPDirMonitorEntry::AddRef(VOID)
{
	CDirMonitorEntry::AddRef();
	IF_DEBUG(FCN)
		WriteRefTraceLogEx(gm_pTraceLog, m_cDirRefCount, this, PVOID(UIntToPtr(m_cIORefCount)), m_pszPath, 0);
}

BOOL CASPDirMonitorEntry::Release(VOID)
/*++

Routine Description:

    Decrement refcount to an entry, we override the base class because
    otherwise Denali's memory manager can't track when we free the object
    and reports  it as a memory leak

Arguments:

    None

Return Value:

    TRUE if object still alive, FALSE if was last release and object
    destroyed

--*/
{
	BOOL fAlive = CDirMonitorEntry::Release();

	IF_DEBUG(FCN)
		WriteRefTraceLogEx(gm_pTraceLog, m_cDirRefCount, this, PVOID(UIntToPtr(m_cIORefCount)), m_pszPath, 0);

	return fAlive;
}


BOOL 
CASPDirMonitorEntry::ActOnNotification(
                        DWORD dwStatus, 
                        DWORD dwBytesWritten)
/*++

Routine Description:

    Do any work associated with a change notification, i.e.

Arguments:

    None

Return Value:

    TRUE if application should continue to be monitored, otherwise FALSE

--*/
{
    FILE_NOTIFY_INFORMATION *pNotify = NULL;
    FILE_NOTIFY_INFORMATION *pNextNotify = NULL;
    WCHAR                   *pwstrFileName = NULL; // Wide file name

    pNextNotify = (FILE_NOTIFY_INFORMATION *) m_pbBuffer;

    if (IsShutDownInProgress())
        return FALSE;

    // If the status word is not S_OK, then the ReadDirectoryChangesW failed
    if (dwStatus)
    {
        // If the status is ERROR_ACCESS_DENIED the directory may be deleted
        // or secured so we want to stop watching it for changes. The changes to the
        // individual scripts will flush the template cache, but we may also be watching
        // the directory for the addition of a GLOBAL.ASA. By calling FileChanged on 
        // global.asa we will force that handle on the directory to close.

        if (dwStatus == ERROR_ACCESS_DENIED)
            {
            FileChanged(SZ_GLOBAL_ASA, false);
            
            // No further notificaitons desired
            // so return false
            
            return FALSE;
            }
            
        // If we return TRUE, we'll try change notification again
        // If we return FALSE, we give up on any further change notifcation
        // We'll try a MAX_NOTIFICATION_FAILURES times and give up.
        
        if (m_cNotificationFailures < MAX_NOTIFICATION_FAILURES)
        {
            IF_DEBUG(FCN)
				DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed. Status = %d\n", dwStatus));

            m_cNotificationFailures++;
            return TRUE;    // Try to get change notification again
        }
        else
        {
			IF_DEBUG(FCN)
				DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed too many times. Giving up.\n"));
            return FALSE;   // Give up trying to get change notification
        }
    }
    else
    {
        // Reset the number of notification failure
        
        m_cNotificationFailures = 0;
    }

    // If dwBytesWritten is 0, then there were more changes then could be
    // recorded in the buffer we provided. Flush the whole cache just in case
    // CONSIDER: is this the best course of action, or should iterate through the
    // cache and test which files are expired

    if (dwBytesWritten == 0)
    {
        DBGPRINTF ((DBG_CONTEXT,"[CASPDirMonitorEntry] Insufficient Buffer for Act on Notification."));

        IF_DEBUG(FCN)
			DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed, too many changes for buffer\n"));
FlushAll:

        if (IsShutDownInProgress())
            return FALSE;

        // Flush the 449 response file cache
        
        Do449ChangeNotification();

        // Flush everything in the cache as a precaution however, if LazyContentProp is not diabled, just change the
        // cache tag and let the cache get updated when the page is requested next.
        g_TemplateCache.FlushAll(g_fLazyContentPropDisabled ? FALSE: TRUE);

        // Check all applications to see if they need to be restarted

        g_ApplnMgr.RestartApplications();

		// Flush the script engine cache as a precaution (should be flushed via TemplateCache, but just in case.)

		// g_ScriptManager.FlushAll();

        // Try to increase the buffer size so this doesn't happen again
        // Unfortunately the first call to ReadDirectoryChangesW on this
        // file handle establishes the buffer size. We must close and re-open
        // the file handle to change the buffer size

        if (ResetDirectoryHandle() && (GetBufferSize() < MAX_BUFFER_SIZE))
        {
        	SetBufferSize(2 * GetBufferSize());
        }

        return TRUE;
    }

    STACK_BUFFER(filename, MAX_PATH * sizeof(WCHAR));

    while ( pNextNotify != NULL )
    {
        DWORD   cch;

        if (IsShutDownInProgress())
            return FALSE;

        pNotify        = pNextNotify;            
        pNextNotify = (FILE_NOTIFY_INFORMATION    *) ((PCHAR) pNotify + pNotify->NextEntryOffset);

        // Resize the stack buffer to the size of the filename.  I know it's
        // ugly, but if it fails, jump back up to the flush all logic.

        // NOTE that the FileNameLength in the NOTIFY structure is in Bytes, not chars

        if (!filename.Resize(pNotify->FileNameLength+2)) {
            goto FlushAll;
        }
    
        pwstrFileName = (WCHAR *)filename.QueryPtr();

        memcpy(pwstrFileName, pNotify->FileName, pNotify->FileNameLength);

        cch = pNotify->FileNameLength/sizeof(WCHAR);

        pwstrFileName[cch] = L'\0';

        // Take the appropriate action for the directory change
        switch (pNotify->Action)
        {
            case FILE_ACTION_ADDED:
            case FILE_ACTION_RENAMED_NEW_NAME:
                // 'File Added' only matters for GLOBAL.ASA
				IF_DEBUG(FCN)
					DBGPRINTF((DBG_CONTEXT, "Change Notification: New file added: %S\n", pwstrFileName));

                if (cch != CCH_GLOBAL_ASA || 
                    wcsicmp(pwstrFileName, SZ_GLOBAL_ASA) != 0)
                {
                    break;
                }
            case FILE_ACTION_REMOVED:
            case FILE_ACTION_MODIFIED:
            case FILE_ACTION_RENAMED_OLD_NAME:
				IF_DEBUG(FCN)
					DBGPRINTF((DBG_CONTEXT, "Change Notification: File %s: %S\n", pNotify->Action == FILE_ACTION_MODIFIED? "changed" : "removed", pwstrFileName));

                FileChanged(pwstrFileName, pNotify->Action != FILE_ACTION_MODIFIED);
                break;
            default:
                break;
        }
        
        if(pNotify == pNextNotify)
        {
            break;
        }  
    }
    
    // We should sign up for further change notification
    
    return TRUE;        
}

void 
CASPDirMonitorEntry::FileChanged(const WCHAR *pszScriptName, bool fFileWasRemoved)
/*++

Routine Description:

    An existing file has been modified or deleted
    Flush scripts from cache or mark application as expired

Arguments:

    pszScriptName   Name of file that changed

Return Value:

    None    Fail silently

--*/
{

    // The file name is set by the application that
    // modified the file, so old applications like EDIT
    // may hand us a munged 8.3 file name which we should
    // convert to a long name. All munged 8.3 file names contain '~'
    // We assume the path does not contain any munged names.
    WIN32_FIND_DATA wfd;

    STACK_BUFFER( tempScriptName, MAX_PATH );
    STACK_BUFFER( tempScriptPath, MAX_PATH );
	
	bool fRemoveMultiple = false;
	WCHAR *pT = wcschr(pszScriptName, '~');
    if (pT)
    {
        
        if (ConvertToLongFileName(m_pszPath, pszScriptName, &wfd))
        {
            pszScriptName = (WCHAR *) &wfd.cFileName;
        }
        else
        {
			// It could be a long filename that was deleted, so remove everything in cache past the '~'.
			if (fFileWasRemoved)
			{
				fRemoveMultiple = true;
				DWORD cchToCopy = (DWORD)(pT - pszScriptName)/sizeof(WCHAR);
                if (tempScriptName.Resize((cchToCopy+1)*sizeof(WCHAR)) == FALSE) {
                    return;
                }
                WCHAR *szScriptNameCopy = (WCHAR *)tempScriptName.QueryPtr();

				// copy prefix to delete into local buffer.
				wcsncpy(szScriptNameCopy, pszScriptName, cchToCopy);
				szScriptNameCopy[cchToCopy] = '\0';

				pszScriptName = szScriptNameCopy;
			}
			else
				return;
        }
    }

    // Allocate enough memory to concatentate the 
    // application path and script name

    DWORD cch = m_cPathLength + wcslen(pszScriptName);
    if (tempScriptPath.Resize((cch + 1)*sizeof(WCHAR)) == FALSE) {
        return;
    }
    LPWSTR pszScriptPath = (LPWSTR) tempScriptPath.QueryPtr(); 
    Assert(pszScriptPath != NULL);
    
    // Copy the application path into the script path
    // pT will point to the terminator of the application path

    pT = strcpyEx(pszScriptPath, m_pszPath);

    // Now append the script name. Note that the script name is
    // relative to the directory that we received the notification for

    wcscpy(pT, pszScriptName);
    Normalize(pszScriptPath);

    if (IsShutDownInProgress())
        return;

    // It is important that we flush the cache and then shutdown applications
    // The call to shut down applications is asynch, and could result in the 
    // template being delted while we are in the process of flushing it.
    // CONSIDER: Is this really indicative of a ref-counting problem?
    
	if (fRemoveMultiple)
	{
		IF_DEBUG(FCN)
			DBGPRINTF((DBG_CONTEXT, "ChangeNotification: Flushing \"%S*\" from cache.\n", pszScriptPath));

		g_IncFileMap.FlushFiles(pszScriptPath);
		g_TemplateCache.FlushFiles(pszScriptPath);
		Do449ChangeNotification(NULL);   // not used often, no selective delete
	}
	else
	{
		g_IncFileMap.Flush(pszScriptPath);
		g_TemplateCache.Flush(pszScriptPath, MATCH_ALL_INSTANCE_IDS);
		Do449ChangeNotification( pszScriptPath );
	}

    // g_FileAppMap will shutdown any applications
    // that depend on this file.
    g_FileAppMap.ShutdownApplications( pszScriptPath );
}


BOOL CASPDirMonitorEntry::FPathMonitored(LPCWSTR pszPath)
{
    if (m_fWatchSubdirectories && (wcsncmp(m_pszPath,pszPath, m_cPathLength) == 0)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
RegisterASPDirMonitorEntry(
            LPCWSTR pcwszDirectoryName,
            CASPDirMonitorEntry **ppDME,
            BOOL    fWatchSubDirs /* = FALSE */
    )
/*++

Routine Description:

    Find entry and create a new one and start monitoring
    if not found.

Arguments:

    pszDirectory - directory to monitor
    ppDNE - Found (or newly created) entry (optional)

Return Value:

    TRUE if success, otherwise FALSE

Remarks:

    Not compatible with WIN95

--*/
{

    DWORD           cchDirectory;
    WCHAR           *pwszDirectory = (WCHAR *)pcwszDirectoryName;
    
    STACK_BUFFER(tempDirectory, 256);

    cchDirectory = wcslen(pcwszDirectoryName);

    // The directory monitor code requires, or possibly ASP's use of the directory
    // monitor, that the directory contain a trailing backslash

    if( cchDirectory 
        && (pcwszDirectoryName[cchDirectory - 1] != L'\\') ) {

        // we need to add the backslash.  To do this, we'll need to allocate 
        // memory from somewhere to make a copy of the converted string with
        // the trailing backslash.

        if (tempDirectory.Resize((cchDirectory + 2) * sizeof(WCHAR)) == FALSE) {
            return FALSE;
        }

        // copy the converted string to the just allocated buffer and add
        // the trailing backslash and NULL terminator

        wcscpy((WCHAR *)tempDirectory.QueryPtr(), pcwszDirectoryName);
        
        pwszDirectory = (WCHAR *)tempDirectory.QueryPtr();

        pwszDirectory[cchDirectory] = L'\\';
        cchDirectory++;
        pwszDirectory[cchDirectory] = '\0';

    }

    // Don't loop forever
    BOOL fTriedTwice = FALSE;

TryAgain:	

    // Check Existing first
    CASPDirMonitorEntry *pDME = (CASPDirMonitorEntry *)g_pDirMonitor->FindEntry( pwszDirectory );

    if ( pDME == NULL )
    {
        // Not found - create new entry

        pDME = new CASPDirMonitorEntry;
        
        if ( pDME )
        {
            pDME->AddRef();
            pDME->Init(NULL);

            // Start monitoring
            if ( !g_pDirMonitor->Monitor(pDME, pwszDirectory, fWatchSubDirs, FILE_NOTIFY_FILTER) )
            {
                // Cleanup if failed
                pDME->Release();
                pDME = NULL;
                
                //
                // We might still be successful if the monitor failed because
                // someone slipped it into the hash table before we had 
                // a chance
                //
                
                if ( GetLastError() == ERROR_ALREADY_EXISTS &&
                     !fTriedTwice )
                {
                    fTriedTwice = TRUE;
                    goto TryAgain;
                }
            }
        }
    }

    // Return entry if found
    if ( pDME != NULL )
    {
        *ppDME = static_cast<CASPDirMonitorEntry *>(pDME);
        return TRUE;
    }
    else
    {
        *ppDME = NULL;
        return FALSE;
    }
}


BOOL 
ConvertToLongFileName(
                const WCHAR *pszPath, 
                const WCHAR *pszName, 
                WIN32_FIND_DATA *pwfd)
/*++

Routine Description:

    Finds the long filename corresponding to a munged 8.3 filename.
    
Arguments:

    pszPath     The path to the file
    pszName     The 8.3 munged version of the file name
    pwfd        Find data structure used to contain the long
                version of the file name.

Return Value:

    TRUE        if the file is found,
    FALSE       otherwise
--*/
{
    STACK_BUFFER( tempName, MAX_PATH*sizeof(WCHAR) );

    // Allocate enough memory to concatentate the file path and name

    DWORD cb = (wcslen(pszPath) + wcslen(pszName)) * sizeof(WCHAR);

    if (tempName.Resize(cb + sizeof(WCHAR)) == FALSE) {
        return FALSE;
    }
    WCHAR *pszFullName = (WCHAR *) tempName.QueryPtr();
    Assert(pszFullName != NULL);

    // Copy the path into the working string
    // pT will point to the terminator of the application path

    WCHAR* pT = strcpyEx(pszFullName,
                         pszPath);

    // Now append the file name. Note that the script name is
    // relative to the directory that we received the notification for

    wcscpy(pT, pszName);


    // FindFirstFile will find using the short name
    // We can then find the long name from the WIN32_FIND_DATA

    HANDLE hFindFile = FindFirstFile(pszFullName, pwfd);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
           return FALSE;
    }

    // Now that we have the find data we don't need the handle
    FindClose(hFindFile);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\applmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Appln Manager

File: Applmgr.h

Owner: PramodD

This is the application manager header file.
===================================================================*/
#ifndef APPLMGR_H
#define APPLMGR_H

#include "debug.h"
#include "hashing.h"
#include "cachemgr.h"
#include "appcnfg.h"
#include "compcol.h"
#include "fileapp.h"
#include "idhash.h"

#include "memcls.h"

#include "disptch2.h"

/*===================================================================
  #defines
===================================================================*/

#define    NUM_APPLMGR_HASHING_BUCKETS            17
#define    NOTIFICATION_BUFFER_SIZE            4096

#define    INVALID_THREADID            0xFFFFFFFF

#include "asptlb.h"

// Session ID Cookie 
// consist of 12 char literal constant and 8 hex process ID
#define     CCH_SESSION_ID_COOKIE           20
#define     CCH_SESSION_ID_COOKIE_PREFIX    12
#define		SZ_SESSION_ID_COOKIE_PREFIX     "ASPSESSIONID"

// CLIENT DEBUG (flag) Cookie
#define		SZ_CLIENT_DEBUG_COOKIE	"ASPCLIENTDEBUG"


// Use to specify which source file name you want (pathInfo or pathTranslated)
#ifndef _SRCPATHTYPE_DEFINED
#define _SRCPATHTYPE_DEFINED

enum SOURCEPATHTYPE
	{
	SOURCEPATHTYPE_VIRTUAL = 0,
	SOURCEPATHTYPE_PHYSICAL = 1
	};

#endif

enum    eSWCERRORS {
    PartitionAccessDenied,
    InvalidPartitionGUID
};


/*===================================================================
  Forward declarations
===================================================================*/

class CComponentCollection;
class CSessionMgr;
class CViperActivity;
class CActiveScriptEngine;
struct IDebugApplication;
struct IDebugApplicationNode;

/*===================================================================
  C A p p l n V a r i a n t s
===================================================================*/
class CApplnVariants : public IVariantDictionaryImpl
    {
private:
    ULONG               m_cRefs;            // ref count
    CAppln *            m_pAppln;           // pointer to parent object
    CompType            m_ctColType;        // type of components in collection
    CSupportErrorInfo   m_ISupportErrImp;   // implementation of ISupportErr

	HRESULT ObjectNameFromVariant(VARIANT &vKey, WCHAR **ppwszName,
	                              BOOL fVerify = FALSE);

public:
	CApplnVariants();
	~CApplnVariants();

	HRESULT Init(CAppln *pAppln, CompType ctColType);
	HRESULT UnInit();

    // The Big Three

    STDMETHODIMP         QueryInterface(const GUID &, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // OLE Automation Interface

    STDMETHODIMP get_Item(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP put_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP putref_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP get_Key(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
    STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };


/*===================================================================
  C  A p p l n
===================================================================*/

class CAppln : public IApplicationObjectImpl, public CLinkElem
    {

friend class CApplnMgr;
friend class CApplnCleanupMgr;
friend class CDirMonitorEntry;
friend class CApplnVariants;
    
private:

    //========= Misc flags
    
    DWORD m_fInited : 1;            // Are we initialized?
    DWORD m_fFirstRequestRan : 1;   // 1st request for this app ran?
    DWORD m_fGlobalChanged : 1;     // Global.asa has changed?
    DWORD m_fDeleteInProgress : 1;  // Delete event posted?
    DWORD m_fTombstone : 1;         // ASP is done with the app?
    DWORD m_fDebuggable : 1;        // Debugging enabled for this app?
    DWORD m_fInternalLockInited:1;  // m_csInternalLock inited?
    DWORD m_fApplnLockInited:1;     // m_csApplnLock inited?

    //========= SWC Errors Logged
    DWORD m_fSWC_PartitionAccessDenied : 1;
    DWORD m_fSWC_InvalidPartitionGUID : 1;

    //========= Ref counts

    DWORD m_cRefs;
    DWORD        m_cRequests;    // Active requests count
    DWORD        m_cSessions;    // Session count

    //========= Application's key, path, global.asa

    // metabase key (unique app id)
    TCHAR *m_pszMetabaseKey;
    // physical application directory path
    TCHAR *m_pszApplnPath;
    // virtual application directory path
    TCHAR *m_pszApplnVRoot;
    // Path to global.asa for application
    TCHAR *m_pszGlobalAsa;
    // Pointer to compliled template for global.asa
    CTemplate *m_pGlobalTemplate;

    //========= Application's Session Manager

    CSessionMgr *m_pSessionMgr;  // Session manager for this app

    //========= Application's Configuration Settings
    
    CAppConfig  *m_pAppConfig; // Application Configuration object

    //========= Application's Component Collection
    
    CComponentCollection *m_pApplCompCol;      // Application scope objects

    //========= Application's dictionaries for presenting component collection
    CApplnVariants    *m_pProperties;
    CApplnVariants    *m_pTaggedObjects;

    //========= Viper Activity
    
    // Application's activity (for thread-locked appls)

    CViperActivity    *m_pActivity;

    // ======== COM+ Services Config Object

    IUnknown    *m_pServicesConfig;
    
    //========= Critical section for internal lock
    
    CRITICAL_SECTION m_csInternalLock;

    //========= External lock support
    
    CRITICAL_SECTION m_csApplnLock;
    DWORD            m_dwLockThreadID; // thread which locked
    DWORD            m_cLockRefCount;  // lock count

    //========= Notification support    
    
    // Identifiers stored by notification system
    CPtrArray	m_rgpvDME;			// list of directory monitor entries
    CPtrArray	m_rgpvFileAppln;	// list of entries relating files to applications

    //========= Type Library wrapper from GLOBAL.ASA
   	IDispatch *m_pdispGlobTypeLibWrapper;

    //========= SupportErrorInfo
    
    // Interface to indicate that we support ErrorInfo reporting
    CSupportErrorInfo m_ISuppErrImp;
    
    //========= Debugging Support

    // root node for browsing of running documents
    IDebugApplicationNode *m_pAppRoot;

    // FTM Support
    IUnknown    *m_pUnkFTM;

    //========= Session ID Cookie Name
    char   m_szSessionCookieName[CCH_SESSION_ID_COOKIE+1];
    char   m_szSessionCookieNameSecure[CCH_SESSION_ID_COOKIE+1];

    void    InitSessionCookieNames();
    void    EncodeCookie (char *pszCookie, DWORD pid, DWORD aid,  BOOL fIsSecure);

    HRESULT InitServicesConfig();

    // proc used to asynchronously cleanup the app

    static  DWORD __stdcall ApplnCleanupProc(VOID  *pArg);

public:
    CAppln();
    ~CAppln();
    
    HRESULT Init
        (
        TCHAR *pszApplnKey, 
        TCHAR *pszApplnPath, 
        CIsapiReqInfo   *pIReq
        );

    // cnvert to tombstone state
    HRESULT UnInit();

    // create application's activity as clone of param
    HRESULT BindToActivity(CViperActivity *pActivity = NULL);

    // set (and remember) global.asa for this app
    HRESULT SetGlobalAsa(const TCHAR *pszGlobalAsa);

    // make sure script didn't leave locks
    HRESULT UnLockAfterRequest();

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
    HRESULT CheckForTombstone();

    // Restart an application (such as when global.asa changes)
    HRESULT Restart(BOOL fForceRestart = FALSE);

    // IApplicationObject functions
    STDMETHODIMP Lock();
    STDMETHODIMP UnLock();
    STDMETHODIMP get_Value(BSTR bstr, VARIANT *pvar);
    STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);
    STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);

    // Application config related methods
    CAppConfig *QueryAppConfig();
    BOOL        FConfigNeedsUpdate();
    HRESULT     UpdateConfig(CIsapiReqInfo   *pIReq, BOOL *pfRestart = NULL, BOOL *pfFlushAll = NULL);

    // inline methods to access member properties
    CSessionMgr           *PSessionMgr();
    CComponentCollection  *PCompCol();
    CViperActivity        *PActivity();
	IDebugApplicationNode *PAppRoot();
	CTemplate             *PGlobalTemplate();
	void                   SetGlobalTemplate(CTemplate *);
	TCHAR                 *GetMetabaseKey();
	TCHAR                 *GetApplnPath(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);
	TCHAR                 *GetGlobalAsa();
	DWORD                  GetNumSessions();
	DWORD                  GetNumRequests();
	BOOL                   FGlobalChanged();
	BOOL                   FDebuggable();
	BOOL                   FTombstone();
	BOOL                   FHasGlobalAsa();
	BOOL                   FFirstRequestRun();
   	IDispatch             *PGlobTypeLibWrapper();
    IUnknown              *PServicesConfig();
    CHAR*                  GetSessionCookieName(BOOL secure);


    void SetFirstRequestRan();
   	void SetGlobTypeLibWrapper(IDispatch *);
    HRESULT AddDirMonitorEntry(CDirMonitorEntry *);
    HRESULT AddFileApplnEntry(CFileApplnList *pFileAppln);

    CASPDirMonitorEntry  *FPathMonitored(LPCTSTR  pszPath);

    void    LogSWCError(enum    eSWCERRORS);
    
    // Misc inline methods
    void InternalLock();
    void InternalUnLock();
    void IncrementSessionCount();
    void DecrementSessionCount();
    void IncrementRequestCount();
    void DecrementRequestCount();

    // AssertValid()
public:

#ifdef DBG
    virtual void AssertValid() const;
#else
    virtual void AssertValid() const {}
#endif
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

	// Trace Log info -- keep in both free & checked builds so that ntsd extension will work for both builds
	// for FREE build, trace log is always NULL.  Checked builds, it must be enabled.
	static PTRACE_LOG gm_pTraceLog;
    };

/*===================================================================
  C  A p p l n   inlines
===================================================================*/

inline CSessionMgr *CAppln::PSessionMgr()
    {
    return m_pSessionMgr;
    }

inline CComponentCollection *CAppln::PCompCol()
    {
    return m_pApplCompCol;
    }

inline CViperActivity *CAppln::PActivity()
    {
    return m_pActivity;
    }

inline IDebugApplicationNode *CAppln::PAppRoot()
    {
    return m_pAppRoot;
    }

inline TCHAR *CAppln::GetMetabaseKey()
    {
    return m_pszMetabaseKey;
    }

inline TCHAR *CAppln::GetApplnPath(SOURCEPATHTYPE pathtype)
    {
	return (pathtype == SOURCEPATHTYPE_VIRTUAL? m_pszApplnVRoot :
			(pathtype == SOURCEPATHTYPE_PHYSICAL? m_pszApplnPath : NULL));
    }

inline CTemplate *CAppln::PGlobalTemplate()
    {
    return m_pGlobalTemplate;
    }

inline void CAppln::SetGlobalTemplate(CTemplate *pTemplate)
    {
    pTemplate->AddRef();
    m_pGlobalTemplate = pTemplate;
    }

inline TCHAR *CAppln::GetGlobalAsa()
    {
    return m_pszGlobalAsa;
    }

inline DWORD CAppln::GetNumSessions()
    {
    return m_cSessions;
    }

inline DWORD CAppln::GetNumRequests()
    {
    return m_cRequests;
    }

inline BOOL CAppln::FGlobalChanged()
    {
    return m_fGlobalChanged;
    }

inline BOOL CAppln::FDebuggable()
    {
    return m_fDebuggable;
    }

inline BOOL CAppln::FTombstone()
    {
    return m_fTombstone;
    }

inline BOOL CAppln::FHasGlobalAsa()
    {
    return (m_pszGlobalAsa != NULL);
    }

inline BOOL CAppln::FFirstRequestRun()
    {
    return m_fFirstRequestRan;
    }

inline void CAppln::SetFirstRequestRan()
    {
    Assert(m_fInited);
    m_fFirstRequestRan = TRUE;
    }

inline IDispatch *CAppln::PGlobTypeLibWrapper()
    {
    return m_pdispGlobTypeLibWrapper;
    }

inline IUnknown *CAppln::PServicesConfig() {
    return m_pServicesConfig;
}
    
inline void CAppln::SetGlobTypeLibWrapper(IDispatch *pdisp)
    {
    if (m_pdispGlobTypeLibWrapper)
        m_pdispGlobTypeLibWrapper->Release();
        
    m_pdispGlobTypeLibWrapper = pdisp;
    
    if (m_pdispGlobTypeLibWrapper)
        m_pdispGlobTypeLibWrapper->AddRef();
    }

inline CHAR* CAppln::GetSessionCookieName(BOOL secure)
{
    return ( secure && QueryAppConfig()->fKeepSessionIDSecure() )
        ? m_szSessionCookieNameSecure: m_szSessionCookieName;
}

inline void CAppln::IncrementSessionCount()
    {
    Assert(m_fInited);
    InterlockedIncrement((LPLONG)&m_cSessions);
    }
    
inline void CAppln::DecrementSessionCount()
    {
    Assert(m_fInited);
    InterlockedDecrement((LPLONG)&m_cSessions);
    }

inline void CAppln::IncrementRequestCount()
    {
    Assert(m_fInited);
    InterlockedIncrement((LPLONG)&m_cRequests);
    }
    
inline void CAppln::DecrementRequestCount()
    {
    Assert(m_fInited);
    InterlockedDecrement((LPLONG)&m_cRequests);
    }
    
inline void CAppln::InternalLock()
    {
    Assert(m_fInternalLockInited);
    EnterCriticalSection(&m_csInternalLock);
    }
    
inline void CAppln::InternalUnLock()
    {
    Assert(m_fInternalLockInited);
    LeaveCriticalSection(&m_csInternalLock); 
    }

inline CAppConfig * CAppln::QueryAppConfig()
    {
    return m_pAppConfig;
    }

inline BOOL CAppln::FConfigNeedsUpdate()
    {
    return m_pAppConfig->fNeedUpdate();
    }

/*===================================================================
  C  A p p l n  M g r
===================================================================*/

class CApplnMgr : public CHashTable
    {
private:
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fHashTableInited : 1;       // Need to UnInit hash table?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

    // List of script engines that need to be closed on next request.
    // (See comments in code, esp. CApplnMgr::AddEngine)
    CDblLink m_listEngineCleanup;

    // Sequential count of application for cookie name generation
    LONG m_cntApp;
    
    //
    // Metabase related variables
    //
    IMSAdminBase            *m_pMetabase;            
    CMDAppConfigSink        *m_pMetabaseSink;      
    DWORD                   m_dwMDSinkCookie;     


public:    
    CApplnMgr();
    ~CApplnMgr();

    HRESULT    Init();
    HRESULT    UnInit();

    HRESULT    InitMBListener( );
    HRESULT    UnInitMBListener( );
    HRESULT    NotifyAllMBListeners(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList [ ]);

    // CAppln manipulations
    
    HRESULT AddAppln
        (
        TCHAR *pszApplnKey, 
        TCHAR *pszApplnPath, 
        CIsapiReqInfo   *pIReq,
        CAppln **ppAppln
        );
    
    HRESULT FindAppln
        (
        TCHAR *pszApplnKey, 
        CAppln **ppAppln
        );
        
    HRESULT DeleteApplicationIfExpired(CAppln *pAppln);
    HRESULT DeleteAllApplications();
    HRESULT RestartApplications(BOOL fRestartAllApplications = FALSE);
    
    // Add an engine to the deferred cleanup list/release engines in the list
	HRESULT AddEngine(CActiveScriptEngine *pEng);
	void CleanupEngines();

    // inlines
    
    void   Lock();
    void   UnLock();
    HANDLE HDeleteEvent();
    void   SetDeleteEvent(void);
    DWORD NextApplicationID(void);    
    
    };

/*===================================================================
  C  A p p l n  M g r   inlines
===================================================================*/

inline void    CApplnMgr::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void    CApplnMgr::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock ); 
    }

inline DWORD CApplnMgr::NextApplicationID()
{
	return InterlockedIncrement(&m_cntApp);
}

    
/*===================================================================
  C  A p p l n  C l e a n u p M g r
===================================================================*/

class CApplnCleanupMgr
    {
private:
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?
    
    HANDLE m_hThreadAlive;           // worker thread alive?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

    HANDLE m_hCleanupThreads[MAX_CLEANUP_THREADS];
    DWORD m_cCleanupThreads;

    HANDLE m_hAppToCleanup; // event to signal when there is an app to cleanup

    CLinkElem m_List;

    CAppln      *Head();
    void        AddElem(CAppln *pAppln);
    void        RemoveElem(CAppln  *pAppln);

public:    
    CApplnCleanupMgr();
    ~CApplnCleanupMgr();

    HRESULT    Init();
    HRESULT    UnInit();

    // CAppln manipulations
    
    HRESULT AddAppln
        (
        CAppln *ppAppln
        );

    void Wakeup();    
    
private:
    // inlines
    
    void   Lock();
    void   UnLock();

    // thread proc used to cleanup deleted applications
    static  DWORD __stdcall ApplnCleanupThread(VOID  *pArg);
    void    ApplnCleanupDoWork();
    
    };

/*===================================================================
  C  A p p l n  C l e a n u p M g r   inlines
===================================================================*/

inline void    CApplnCleanupMgr::Lock()
    {
    Assert(m_fCriticalSectionInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void    CApplnCleanupMgr::UnLock()
    {
    Assert(m_fCriticalSectionInited);
    LeaveCriticalSection( &m_csLock ); 
    }

inline CAppln  *CApplnCleanupMgr::Head()
{
    return ((m_List.m_pNext == &m_List) ? NULL : (CAppln *)m_List.m_pNext);
}
inline void    CApplnCleanupMgr::AddElem(CAppln *pAppln)
{
    pAppln->m_pNext = &m_List;
    pAppln->m_pPrev = m_List.m_pPrev;
    m_List.m_pPrev->m_pNext = pAppln;
    m_List.m_pPrev = pAppln;
}

inline void    CApplnCleanupMgr::RemoveElem(CAppln *pAppln)
{
    pAppln->m_pPrev->m_pNext = pAppln->m_pNext;
    pAppln->m_pNext->m_pPrev = pAppln->m_pPrev;
}

inline void    CApplnCleanupMgr::Wakeup()
{
    SetEvent(m_hAppToCleanup);
}
    
/*===================================================================
C A p p l n M g r thread proc prototype
===================================================================*/
void __cdecl RestartAppsThreadProc(VOID *arg);

/*===================================================================
  Globals
===================================================================*/

extern CApplnMgr    g_ApplnMgr;
extern DWORD        g_nApplications;
extern DWORD        g_nApplicationsRestarting;

/*===================================================================
  C  A p p l n  I t e r a t o r
===================================================================*/

class CApplnIterator
    {
private:
    CApplnMgr   *m_pApplnMgr;
    CAppln      *m_pCurr;
    BOOL         m_fEnded; // iterator ended

public:
                CApplnIterator(void);
    virtual        ~CApplnIterator(void);

public:
    HRESULT            Start(CApplnMgr *pApplnMgr = NULL);
    HRESULT            Stop(void);
    CAppln *        Next(void);
    };

#endif // APPLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\asperror.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: ASPError object

File: asperror.cpp

Owner: dmitryr

This file contains the code for the implementation of 
the ASPError class.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "asperror.h"

#include "memchk.h"

/*===================================================================
CASPError::CASPError

Constructor for the empty error object

Returns:
===================================================================*/
CASPError::CASPError()
    :
    m_cRefs(1),
    m_szASPCode(NULL),
    m_lNumber(0),
    m_szSource(NULL),
    m_szFileName(NULL),
    m_lLineNumber(0),
    m_szDescription(NULL),
    m_szASPDescription(NULL),
	m_bstrLineText(NULL)
	{
	CDispatch::Init(IID_IASPError);
	}

/*===================================================================
CASPError::CASPError

Constructor for real error object given CErrInfo

Parameters
    pErrInfo        [in] copy data from there

Returns:
===================================================================*/
CASPError::CASPError(CErrInfo *pErrInfo)
    :
    m_cRefs(1),
    m_szASPCode(NULL),
    m_lNumber(0),
    m_szSource(NULL),
    m_szFileName(NULL),
    m_lLineNumber(0),
    m_szDescription(NULL),
    m_szASPDescription(NULL),
	m_bstrLineText(NULL)
	{
	CDispatch::Init(IID_IASPError);

    if (!pErrInfo)
        return;

    // Parse ASP error code and HRESULT from szErrorCode
    CHAR *szErrorCode =  StringDupA(pErrInfo->GetItem(Im_szErrorCode));
    if (szErrorCode != NULL)
        {
        CHAR *szC = strchr(szErrorCode, ':');
        if (szC)
            {
            // format "ASP XXX : HRESULT"
            szC[-1] = '\0';
            m_szASPCode = szErrorCode;
            m_lNumber = strtoul(szC+2, NULL, 16);
            }
        else if (strncmp(szErrorCode, "ASP", 3) == 0)
            {
            // format "ASP XXX"
            m_szASPCode = szErrorCode;
            m_lNumber = E_FAIL;
            }
        else
            {
            // format "HRESULT"
            m_szASPCode = NULL;
            m_lNumber = strtoul(szErrorCode, NULL, 16);
            free(szErrorCode);
            }
        }
    else
        {
        // no error description available
        m_szASPCode = NULL;
        m_lNumber = E_FAIL;
        }

    // Copy the rest
	m_szSource         = StringDupA(pErrInfo->GetItem(Im_szEngine));
	m_szFileName       = StringDupA(pErrInfo->GetItem(Im_szFileName));
	m_szDescription    = StringDupA(pErrInfo->GetItem(Im_szShortDescription));
	m_szASPDescription = StringDupA(pErrInfo->GetItem(Im_szLongDescription));

	// Get line text & column (supplies init. values if not available)
	BSTR bstrLineText;
	pErrInfo->GetLineInfo(&bstrLineText, &m_nColumn);
	m_bstrLineText = SysAllocString(bstrLineText);

    // Line number if present
	if (pErrInfo->GetItem(Im_szLineNum))
    	m_lLineNumber = atoi(pErrInfo->GetItem(Im_szLineNum));
	}

/*===================================================================
CASPError::~CASPError

Destructor

Parameters:
					
Returns:
===================================================================*/
CASPError::~CASPError()
    {
    Assert(m_cRefs == 0);  // must have 0 ref count

    if (m_szASPCode)
        free(m_szASPCode);
    if (m_szSource)
        free(m_szSource);
    if (m_szFileName)
        free(m_szFileName);
    if (m_szDescription)
        free(m_szDescription);
    if (m_szASPDescription)
        free(m_szASPDescription);
	if (m_bstrLineText)
		SysFreeString(m_bstrLineText);
    }

/*===================================================================
CASPError::ToBSTR

Produce a BSTR to be returned by get_XXX methods

Parameters:
    sz      return this string as BSTR
					
Returns:
    BSTR or NULL if FAILED
===================================================================*/
BSTR CASPError::ToBSTR(CHAR *sz)
    {
    BSTR bstr;
    if (sz == NULL || *sz == '\0')
        bstr = SysAllocString(L"");
    else if (FAILED(SysAllocStringFromSz(sz, 0, &bstr)))
        bstr = NULL;
    return bstr;
    }

/*===================================================================
CASPError::QueryInterface
CASPError::AddRef
CASPError::Release

IUnknown members for CASPError object.
===================================================================*/
STDMETHODIMP CASPError::QueryInterface(REFIID riid, VOID **ppv)
	{
	if (IID_IUnknown == riid ||	IID_IDispatch == riid || IID_IASPError == riid)
		{
		AddRef();
		*ppv = this;
		return S_OK;
		}
		
	*ppv = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CASPError::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}

STDMETHODIMP_(ULONG) CASPError::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}

/*===================================================================
CASPError::get_ASPCode
CASPError::get_Number
CASPError::get_Source
CASPError::get_FileName
CASPError::get_LineNumber
CASPError::get_Description
CASPError::get_ASPDescription

IASPError members for CASPError object.
===================================================================*/
STDMETHODIMP CASPError::get_ASPCode(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szASPCode);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_Number(long *plNumber)
    {
    *plNumber = m_lNumber;
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Category(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szSource);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_File(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szFileName);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_Line(long *plLineNumber)
    {
    *plLineNumber = m_lLineNumber;
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Column(long *pnColumn)
    {
    *pnColumn = long(m_nColumn);
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Source(BSTR *pbstrLineText)
    {
	*pbstrLineText = SysAllocString(m_bstrLineText? m_bstrLineText : L"");
	return (*pbstrLineText) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_Description(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szDescription);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_ASPDescription(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szASPDescription);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\cachemgr.cpp ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Template Cache Manager

File: CacheMgr.cpp

Owner: DGottner

Template cache manager implementation
-----------------------------------------------------------------------------*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

CTemplateCacheManager   g_TemplateCache;
CIncFileMap             g_IncFileMap;

BOOL  CTemplateCacheManager::m_fFailedToInitPersistCache = FALSE;
char  CTemplateCacheManager::m_szPersistCacheDir[MAX_PATH];

DWORD   g_nScavengedPersisted = 0;
DWORD   g_nScavengedPurged = 0;
DWORD   g_nScavengedPersistFailed = 0;

extern BOOL g_fUNCChangeNotificationEnabled;

/*===================================================================
ZapTemplate

Decrement the ref. count of a template to remove it from cache.
If the template is global.asa, that's all we do because application
manager has the last reference.  Otherwise, we Release the template
by calling CTemplate::End() to also free references to it from the
debugger.

Parameters: pTemplate - template pointer to Release() from cache

Returns: new ref. count
===================================================================*/

static inline
ULONG ZapTemplate(CTemplate *pTemplate)
    {
    if (! pTemplate->FGlobalAsa())
        return pTemplate->End();

    else
        return pTemplate->Release();
    }


/*  ****************************************************************************
    CCacheManager member functions
*/

/*===================================================================
CTemplateCacheManager::CTemplateCacheManager

Parameters: N/A

Returns: N/A
===================================================================*/

CTemplateCacheManager::CTemplateCacheManager()
{
    m_pHashTemplates = NULL;
    m_szPersistCacheDir[0] = '\0';
    m_fFailedToInitPersistCache = FALSE;
    m_dwTemplateCacheTag = 0;
    m_hOnInitCleanupThread = NULL;
    m_cCleanupThreads = 0;

    ZeroMemory (&m_hCleanupThreads, sizeof(m_hCleanupThreads));
}


/*===================================================================
CTemplateCacheManager::~CTemplateCacheManager

Parameters: N/A

Returns: N/A
===================================================================*/

CTemplateCacheManager::~CTemplateCacheManager()
{
    if (m_hOnInitCleanupThread != NULL) {
        WaitForSingleObject(m_hOnInitCleanupThread, INFINITE);
        CloseHandle(m_hOnInitCleanupThread);
        m_hOnInitCleanupThread = NULL;
    }

    if (!m_fFailedToInitPersistCache) {
        RemoveDirectoryA(m_szPersistCacheDir);
    }
}


/*===================================================================
CTemplateCacheManager::Init

Init the template cache manager - phase 1 - that which can be done
with just default values in Glob.

Parameters: None

Returns: Completion Status
===================================================================*/

HRESULT CTemplateCacheManager::Init()
    {
    HRESULT hrInit;
    ErrInitCriticalSection(&m_csUpdate, hrInit);
    if (FAILED(hrInit))
        return(hrInit);

    // allocate the initial CTemplateHashTable

    m_pHashTemplates = new CTemplateHashTable;

    // Initialize the Cache Tag.
   	m_dwTemplateCacheTag = GetTickCount();

    return S_OK;
    }

/*  ****************************************************************************
    CTemplateCacheManager member functions
*/

/*===================================================================
CTemplateCacheManager::UnInit

Parameters: N/A

Returns: Completion status
===================================================================*/

HRESULT CTemplateCacheManager::UnInit()
{

    if (m_pHashTemplates) {
        while (! m_pHashTemplates->FMemoryTemplatesIsEmpty()) {
		    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesBegin());
		    m_pHashTemplates->RemoveTemplate(pTemplate);
		    ZapTemplate(pTemplate);
		}

        while (! m_pHashTemplates->FPersistTemplatesIsEmpty()) {
		    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->PersistTemplatesBegin());
		    m_pHashTemplates->RemoveTemplate(pTemplate);
		    ZapTemplate(pTemplate);
		}
    }
    delete m_pHashTemplates;
    m_pHashTemplates = NULL;

    // give any flush threads a chance to finish.  This is necessary
    // to prevent an AV by LKRHash.

    LockTemplateCache();

    if (m_cCleanupThreads)
    {
        WaitForMultipleObjects(
                 m_cCleanupThreads,
                 m_hCleanupThreads,
                 TRUE,         // wait for ALL event
                 INFINITE);    // Wait for as long as it takes.

        while( m_cCleanupThreads ) {
            CloseHandle(m_hCleanupThreads[ --m_cCleanupThreads ]);
        }
    }

    UnLockTemplateCache();

#ifndef PERF_DISABLE
    g_PerfData.Zero_MEMORYTEMPLCACHE();
    g_PerfData.Zero_TEMPLCACHE();
#endif
    DeleteCriticalSection(&m_csUpdate);

    return S_OK;
}

/*===================================================================
CTemplateCacheManager::FindCached

    Get a template from the cache only

NOTE: FindCached just checks for the existance of the template. It will not check if the files that make up the
template are valid or not like Load does. Please keep this assumption in mind while using this Method.

Parameters:
    szFile       - file to find in the cache
    ppTemplate   - [out] template object found

Returns:
    HRESULT (S_OK if found, S_FALSE if noe found)
===================================================================*/

HRESULT CTemplateCacheManager::FindCached(const TCHAR *szFile, DWORD dwInstanceID, CTemplate **ppTemplate)
{

    Assert(IsNormalized(szFile));
    if (!ppTemplate)
    	return E_POINTER;

    LockTemplateCache();

    m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate);
    if (*ppTemplate)
        {
        if (!(*ppTemplate)->m_fReadyForUse)
            *ppTemplate = NULL;         // not ready - as if nor found
        else
            (*ppTemplate)->AddRef();    // addref inside critical section
        }

    UnLockTemplateCache();

    return *ppTemplate? S_OK : S_FALSE;
}

/*===================================================================
CTemplateCacheManager::Load

    Get a template from the cache, or load it into cache

Parameters:
    szFile - file to load into the cache

Returns: N/A
===================================================================*/

HRESULT CTemplateCacheManager::Load(BOOL fRunGlobalAsp, const TCHAR *szFile, DWORD dwInstanceID, CHitObj *pHitObj, CTemplate **ppTemplate, BOOL *pfTemplateInCache)
    {
    HRESULT hr = S_OK;                   // return value
    HRESULT (CTemplate::*pmAction)(CHitObj *);  // do we need to compile a new template or deliver an existing one?
    BOOL    fNeedsCheck = FALSE;

    Assert(IsNormalized(szFile));

    BOOL fLocked = FALSE;

    // If this is the GLOBAL.ASA we can pick up
    // template directly from the application
    if (fRunGlobalAsp && pHitObj->PAppln()->PGlobalTemplate())
        {
        *ppTemplate = pHitObj->PAppln()->PGlobalTemplate();
        }
    // see if we already have looked up the template on the I/O thread...
    else if (!fRunGlobalAsp && pHitObj->GetTemplate())
        {
        *ppTemplate = pHitObj->GetTemplate();
        pHitObj->SetTemplate(NULL);
        }
    else
    // Otherwise we have to look for it in the cache
        {
        LockTemplateCache();
        fLocked = TRUE;
        m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate,&fNeedsCheck);
        }

    if (*ppTemplate != NULL)
        {
        // Template found in cache -> use it
        (*ppTemplate)->AddRef();
        *pfTemplateInCache = TRUE;

        (*ppTemplate)->IncrUseCount();

        if (fLocked)    // Global.Asa from App - no lock
            UnLockTemplateCache();

        pmAction = CTemplate::Deliver;
        }
    else
        {
        *pfTemplateInCache = FALSE;

        Assert(fLocked); // only could get here if not found in the hash table
        UnLockTemplateCache();

        // Create and init new template outside of crirical section

        CTemplate *pNewTemplate = new CTemplate;

        if (!pNewTemplate)
            hr = E_OUTOFMEMORY;

        if (SUCCEEDED(hr))
            hr = pNewTemplate->Init(pHitObj, !!fRunGlobalAsp, CTemplateKey(szFile, dwInstanceID));

        if (SUCCEEDED(hr))
            {
            LockTemplateCache();

            // Try to find if inserted by another thread
            m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate,&fNeedsCheck);

            if (*ppTemplate != NULL)
                {
                // Template found in cache -> use it
                (*ppTemplate)->AddRef();
                (*ppTemplate)->IncrUseCount();
                UnLockTemplateCache();
                pmAction = CTemplate::Deliver;
                }
            else
                {

                // since we are creating a new template, call FlushCache to make
                // sure that no script engines are cached with this name

                g_ScriptManager.FlushCache(szFile);

                // Insert the newly created template

                *ppTemplate = pNewTemplate;
                pNewTemplate = NULL; // not to be deleted later

                m_pHashTemplates->InsertTemplate(*ppTemplate);
                (*ppTemplate)->AddRef();

                if (Glob(dwScriptFileCacheSize) == 0) {
                    // This is special case when a valid template
                    // does not get added to the cache
                    // Don't attach such templates to debugger
                    (*ppTemplate)->m_fDontAttach = TRUE;
                }

                UnLockTemplateCache();

                pmAction = CTemplate::Compile;
                }
            }

        // cleanup new template if created but unused
        if (pNewTemplate)
            pNewTemplate->Release();
        }

    if (FAILED(hr))
        return hr;


    // init succeeded: compile or deliver the template, as required
    hr = ((*ppTemplate)->*pmAction)(pHitObj);

    if (pmAction == CTemplate::Compile && (*ppTemplate)->m_fDontCache)
        {
        /*  We were compiling and the compiler alerted us not to cache the failed template.
            Typically, this occurs when compile failure was caused by something other than
            bad template syntax (permissions failure, bad include file reference, etc.).

            We need to roll back to where the template did not exist.
        */

        // de-cache and release the template
        // NOTE we don't nullify template ptr, because we want ExecuteRequest to do the final release

        LockTemplateCache();
        if (m_pHashTemplates->RemoveTemplate(*ppTemplate) == LK_SUCCESS)
            ZapTemplate(*ppTemplate);
        UnLockTemplateCache();

		(*ppTemplate)->Release();
		*ppTemplate = NULL;
        }

    if (SUCCEEDED(hr) && fNeedsCheck && *ppTemplate != NULL)
    {
        if (!(*ppTemplate)->ValidateSourceFiles(pHitObj->PIReq()))
        {
            // Template is invalid (out of date)
            LockTemplateCache();

            if (m_pHashTemplates->RemoveTemplate(*ppTemplate) == LK_SUCCESS)
                ZapTemplate (*ppTemplate);

            UnLockTemplateCache();
        }
    }

    LockTemplateCache();

    BOOL    bTemplateRemoved = FALSE;

    // Remove old scripts from cache

    while (!m_pHashTemplates->FMemoryTemplatesIsEmpty()
           && (m_pHashTemplates->InMemoryTemplates() > Glob(dwScriptFileCacheSize))) {
        Assert (!m_pHashTemplates->FMemoryTemplatesIsEmpty());
        CTemplate *pOldTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesEnd());

        // don't call ScavengePersistCache in this call.  We'll call it once at the end

        m_pHashTemplates->RemoveTemplate(pOldTemplate, TRUE, FALSE);

        bTemplateRemoved = TRUE;

        // flush the corresponding script engines.  But only if the template
        // is valid.

        if (pOldTemplate->FIsValid()) {
            g_ScriptManager.FlushCache(pOldTemplate->GetSourceFileName());
        }

        // Only Zap the template if it is not persisted.  The result of the above
        // call to RemoveTemplate is that the template may have been moved from the
        // memory cache to the persist cache.  In which case, the template is still
        // effectively cached.

        if (pOldTemplate->FIsPersisted() == FALSE) {

            ZapTemplate(pOldTemplate);
        }
    }

    // call ScavengePersistCache() once here...

    if (bTemplateRemoved)
        m_pHashTemplates->ScavengePersistCache();

    UnLockTemplateCache();

    // Store a pointer to the template with the application
    // if we haven't already done so
    if (SUCCEEDED(hr) && *ppTemplate && fRunGlobalAsp && pHitObj->PAppln()->PGlobalTemplate() == NULL)
        pHitObj->PAppln()->SetGlobalTemplate(*ppTemplate);

    // If we are shutting down, don't request change notification

    if (!IsShutDownInProgress() && *ppTemplate)
        {
        // If running on NT, and we just compiled the template
        // register all the directories used by this template
        // for change notification
        if (pmAction == CTemplate::Compile && SUCCEEDED(hr)) {
            if (!RegisterTemplateForChangeNotification(*ppTemplate, pHitObj->PAppln())) {
                LockTemplateCache();
                if (m_pHashTemplates->RemoveTemplate(*ppTemplate) == LK_SUCCESS)
                    ZapTemplate(*ppTemplate);
                UnLockTemplateCache();
            }

            // also create the services config object

            hr = (*ppTemplate)->CreateTransServiceConfig(pHitObj->PAppln()->QueryAppConfig()->fTrackerEnabled());
        }

        // If running on NT, this is a new application, and the template is a global.asa
        // register this application for file change notifications
        if (SUCCEEDED(hr) && (*ppTemplate)->m_fGlobalAsa && pHitObj->FStartApplication())
            {
            RegisterApplicationForChangeNotification(*ppTemplate, pHitObj->PAppln());
            }
        }

    return hr;
    }



/*===================================================================
CTemplateCacheManager::Flush

Parameters:
    szFile - the file to remove from cache

Returns:
    None
===================================================================*/

void CTemplateCacheManager::Flush(const TCHAR *szFile, DWORD dwInstanceID)
    {
    LockTemplateAndIncFileCaches();

    Assert (IsNormalized(szFile));
    CTemplate *pTemplate;
    m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), &pTemplate);

    while (pTemplate != NULL)
        {
#ifndef PERF_DISABLE
        g_PerfData.Incr_TEMPLFLUSHES();
#endif

		m_pHashTemplates->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Don't flush engines if this is a global.asa file
        // We'll need the engines to run Application_OnEnd
        // The application will flush the engine from the cache
        // when it unints
        if (!FIsGlobalAsa(szFile))
            {
            g_ScriptManager.FlushCache(szFile);
            }

        ZapTemplate(pTemplate);

        // If wildcard was specified in Flush for Instance ID, there may be
        // more templates to remove.
        m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), &pTemplate);
        }

    UnLockTemplateAndIncFileCaches();
    }

/*===================================================================
CTemplateCacheManager::FlushAll

    Completely empties the template cache

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushAll(BOOL fDoLazyFlush)
{

    if (fDoLazyFlush)
	{
		m_dwTemplateCacheTag = GetTickCount();
		
		DBGPRINTF ((DBG_CONTEXT,"Using new Cache Tag to Invalidate Template\n"));
		
		return;
	}

    LockTemplateAndIncFileCaches();

    CTemplateHashTable  *pNewTable = NULL;
    HANDLE              hnd;

    // note that all of the following logic works on the premise that any
    // error causes the code to fall into the old mechanism of flushing
    // the hash table in place...

    // allocate a new table

    if (pNewTable = new CTemplateHashTable)
    {
        //
        // Create a thread to clean up the old table
        //
        DWORD nThreadIndex;

        //
        // if no threads started yet, use the first slot
        //
        if (m_cCleanupThreads) {
            nThreadIndex = 0;
            goto create_new_thread;
        }

        //
        // see if there is a thread that terminated
        //
        nThreadIndex = WaitForMultipleObjects(
                                    m_cCleanupThreads,
                                    m_hCleanupThreads,
                                    FALSE, // wait for any event
                                    0);    // return immediately

        Assert(nThreadIndex == WAIT_TIMEOUT);

        if (m_cCleanupThreads < MAX_CLEANUP_THREADS)
        {
            //
            // just get the next index
            //
            nThreadIndex = m_cCleanupThreads;
            goto create_new_thread;
        }

        goto Cleanup;

    create_new_thread:

        hnd = CreateThread(NULL, 0, CTemplateCacheManager::FlushHashTableThread, m_pHashTemplates, 0, NULL);

        if (hnd)
        {
            //
            // close the previous handle if we are reusing an entry
            //
            if (nThreadIndex < m_cCleanupThreads)
            {
                //
                // we are reusing a slot from a terminated thread
                //
                CloseHandle(m_hCleanupThreads[ nThreadIndex ]);

            } else {
                //
                // we are using a new slot
                //
                Assert(nThreadIndex == m_cCleanupThreads);

                m_cCleanupThreads++;
            }

            m_hCleanupThreads[ nThreadIndex ] = hnd;

            // all the above was successful, so note that the new table is the
            // current table in the cache, cleanup and exit.

            DBGPRINTF((DBG_CONTEXT, "[CTemplateCacheManager] Flushing entire cache on another thread.\n"));

            m_pHashTemplates = pNewTable;

            UnLockTemplateAndIncFileCaches();

            return;

        }
    }

Cleanup:
    // delete the new table if something above failed.

    if (pNewTable)
        delete pNewTable;

    DBGPRINTF((DBG_CONTEXT, "[CTemplateCacheManager] Flushing entire cache in place\n"));

    FlushHashTable(m_pHashTemplates);

    UnLockTemplateAndIncFileCaches();

    return;
}

/*===================================================================
CTemplateCacheManager::FlushHashTableThread

    Thread spun up by CTemplateCacheMgr::FlushAll() to flush all
    templates in the cache but not while under the critical section
    on the notification thread.  Prevents unwanted contention on the
    cache.

Parameters:
    None

Returns:
    None
===================================================================*/

DWORD CTemplateCacheManager::FlushHashTableThread(VOID  *pArg)
{
    CTemplateHashTable  *pTable = (CTemplateHashTable *)pArg;

    Assert(pTable);

    FlushHashTable(pTable);

    delete pTable;

    return S_OK;
}

/*===================================================================
CTemplateCacheManager::FlushHashTable

    Does the actual work of flushing the templates.

    This routine may or may not be under the global cache manager
    crit sec.  It will if the flush is happening on the notification
    thread.  It won't be if it's happening on the FlushHashTableThread.

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushHashTable(CTemplateHashTable  *pTable)
{
    // Delete templates from the cache until there are no more

    while (!pTable->FMemoryTemplatesIsEmpty()) {
        CTemplate *pTemplate = static_cast<CTemplate *>(pTable->MemoryTemplatesEnd());

        // Remove the template from its various data structures
		pTable->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Flush the engine for this template from the script engine cache
		//   (use hash key, in case template was previously a zombie.)
        g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

        ZapTemplate(pTemplate);

    }

    // Delete templates from the cache until there are no more

    while (!pTable->FPersistTemplatesIsEmpty()) {
        CTemplate *pTemplate = static_cast<CTemplate *>(pTable->PersistTemplatesEnd());

        // Remove the template from its various data structures
		pTable->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Flush the engine for this template from the script engine cache
		//   (use hash key, in case template was previously a zombie.)
        g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

        ZapTemplate(pTemplate);

    }
}


/*===================================================================
CTemplateCacheManager::FlushFiles

    Empties template cache of files that match a prefix

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushFiles(const TCHAR *szFilePrefix)
{
    LockTemplateAndIncFileCaches();
    BOOL    fDoingMemoryTemplates = TRUE;

    // Delete templates from the cache until there are no more

	CDblLink *pLink = m_pHashTemplates->MemoryTemplatesBegin();
	while (! (fDoingMemoryTemplates
                ? m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink)
                : m_pHashTemplates->FPersistTemplatesDblLinkAtEnd(pLink))) {

		CDblLink *pNextLink = pLink->PNext();
		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);

		if (_tcsncmp(pTemplate->ExtractHashKey()->szPathTranslated, szFilePrefix, _tcslen(szFilePrefix)) == 0) {
#if UNICODE
			DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %S\n", pTemplate->ExtractHashKey()->szPathTranslated));
#else
            DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %s\n", pTemplate->ExtractHashKey()->szPathTranslated));
#endif
			// Remove the template from its various data structures
			m_pHashTemplates->RemoveTemplate(pTemplate);

			// Make sure anyone using this template can tell it is obsolete
			pTemplate->Zombify();

			// Flush the engine for this template from the script engine cache
			//   (use hash key, in case template was previously a zombie.)
			g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

			ZapTemplate(pTemplate);

#ifndef PERF_DISABLE
			g_PerfData.Incr_TEMPLFLUSHES();
#endif
        }

		pLink = pNextLink;

        if (fDoingMemoryTemplates && m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink)) {
            fDoingMemoryTemplates = FALSE;
            pLink = m_pHashTemplates->PersistTemplatesBegin();
        }
    }

    UnLockTemplateAndIncFileCaches();
}


/*===================================================================
CTemplateCacheManager::AddApplicationToDebuggerUI

    Loop through the template cache, and create doc nodes for
    all templates that belong to the application

Parameters:
    pAppln - pointer to application to attach to.

Returns: N/A
===================================================================*/

void CTemplateCacheManager::AddApplicationToDebuggerUI(CAppln *pAppln)
    {
    CDblLink *pLink;
    for (pLink = m_pHashTemplates->MemoryTemplatesBegin(); !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink); pLink = pLink->PNext())
        {
        // Bug  92070:
        //   Determine if the template is a member of pAppln by comparing
        //   the virtual path of the template to the application's virtual
        //   path (previously compared physical paths)  Since a template
        //   can have multiple virtual paths, only the first instance wins.
        //   Thus the template will only appear in the application that first
        //   loaded it.

		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);
        if (_tcscmp(pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL), pTemplate->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)) == 0)
            pTemplate->AttachTo(pAppln);
        }
    }



/*===================================================================
CTemplateCacheManager::RemoveApplicationFromDebuggerUI

    Loop through the template cache, and remove doc nodes for
    all templates that belong to the application

Parameters:
    pAppln - pointer to application to detach from
             if pAppln is NULL, detach from ALL applications


Returns: N/A
===================================================================*/

void CTemplateCacheManager::RemoveApplicationFromDebuggerUI(CAppln *pAppln)
    {
    CDblLink *pLink;
    for (pLink = m_pHashTemplates->MemoryTemplatesBegin();
         !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink);
         pLink = pLink->PNext())
        {
		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);
        if (pAppln != NULL)
            pTemplate->DetachFrom(pAppln);
        else
            pTemplate->Detach();
        }
    }

/*===================================================================
void CTemplateCacheManager::RegisterTemplateForChangeNotification

    Request to watch template directories for file changes

Parameters:
    A pointer to the template

Returns:
    BOOL    True if successfully registered for change notification
===================================================================*/
BOOL CTemplateCacheManager::RegisterTemplateForChangeNotification(CTemplate *pTemplate, CAppln  *pApplication)
{
    DWORD   dwValue = 0;

    // If the template has a UNC include or main file & we the registry key is absent (default) or the key is present and disabled.
    // Then we will use the flag this file one that requires monitoring to be performed by ASP.
    if (pTemplate->FIsUNC() && !g_fUNCChangeNotificationEnabled)
    {
            pTemplate->m_fNeedsMonitoring = TRUE;
            pTemplate->m_dwLastMonitored = GetTickCount ();
            return TRUE;
    }

    //else   (Local File or UNC file with ChangeNotification Enabled)

    STACK_BUFFER( tempPath, MAX_PATH );

    for (DWORD i = 0; i < pTemplate->m_cFilemaps; i++) {
        // Check if this directory is already registered for change notification

        // Pick out the directory portion of the path
        TCHAR *szEndOfPath = _tcsrchr(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, _T('\\'));
        size_t cch = DIFF(szEndOfPath - pTemplate->m_rgpFilemaps[i]->m_szPathTranslated)+1;

        if (tempPath.Resize((cch * sizeof(TCHAR)) + sizeof(TCHAR)) == FALSE) {
            // if failure to resize, unless disabled through the registry, flag the file for manual monitoring after releasing previously registered DME's
            if (SUCCEEDED(g_AspRegistryParams.GetFileMonitoringEnabled(&dwValue)) && dwValue == 0)
                continue;

            if (i > 0) {
                while (--i) {
                    pTemplate->m_rgpFilemaps[i]->m_pDME->Release();
                    pTemplate->m_rgpFilemaps[i]->m_pDME = NULL;
                }
            }

            pTemplate->m_fNeedsMonitoring = TRUE;
            pTemplate->m_dwLastMonitored = GetTickCount ();
            return TRUE;

        }
        TCHAR *szPath = (TCHAR *) tempPath.QueryPtr();
        _tcsncpy(szPath, pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, cch);
        szPath[cch] = 0;

        // if the template is within the application's physical path, then it is
        // already being monitored.

        CASPDirMonitorEntry *pDME = NULL;

        if (pDME = pApplication->FPathMonitored(szPath)) {
            pDME->AddRef();
            pTemplate->m_rgpFilemaps[i]->m_pDME= pDME;
            continue;
        }

        if (RegisterASPDirMonitorEntry(szPath, &pDME)) {
            Assert(pDME);
            pTemplate->m_rgpFilemaps[i]->m_pDME= pDME;
        }
        else {
            // the current file failed to register.  Release all previous DMEs
            // and return FALSE...

            if (i > 0) {
                while (--i) {

                    pTemplate->m_rgpFilemaps[i]->m_pDME->Release();
                    pTemplate->m_rgpFilemaps[i]->m_pDME = NULL;
                }
            }

            // Without the monitoring magic we would return FALSE here but we give
            // it one more chance to live, except if the registry parameter is set to disable it.

            // if the registry setting asks for this to be disabled disable it.
            if (SUCCEEDED(g_AspRegistryParams.GetFileMonitoringEnabled(&dwValue)) && dwValue == 0)
                return FALSE;

            pTemplate->m_fNeedsMonitoring = TRUE;
            pTemplate->m_dwLastMonitored = GetTickCount ();
            return TRUE;

        }
    }
    return TRUE;
}

/*===================================================================
void CTemplateCacheManager::RegisterApplicationForChangeNotification

    Request to watch template directories for file changes

Parameters:
    A pointer to the template

Returns:
    BOOL    True if successfully registered for change notification
===================================================================*/
BOOL CTemplateCacheManager::RegisterApplicationForChangeNotification(CTemplate *pTemplate, CAppln *pApplication)
    {

    STACK_BUFFER( tempPath, MAX_PATH );

    // Start with 1 to skip GLOBAL.ASA that is always added
    // in hitobj.cpp when new application gets created

    for (DWORD i = 1; i < pTemplate->m_cFilemaps; i++)
        {

        // Add to list of file-application mappings
        g_FileAppMap.AddFileApplication(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, pApplication);

        // Check if this directory is already registered for change notification
        // Pick out the directory portion of the path
        TCHAR *szEndOfPath = _tcsrchr(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, _T('\\'));
        size_t cch = DIFF(szEndOfPath - pTemplate->m_rgpFilemaps[i]->m_szPathTranslated) + 1;

        if (tempPath.Resize((cch*sizeof(TCHAR)) + sizeof(TCHAR)) == FALSE) {

            // if failure, continue registering anyway...
            continue;
        }
        TCHAR *szPath = (TCHAR *) tempPath.QueryPtr();
        _tcsncpy(szPath, pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, cch);
        szPath[cch] = 0;

        // if the template is within the application's physical path, then it is
        // already being monitored.

        if (pApplication->FPathMonitored(szPath)) {

            continue;
        }

        // Register directory for monitoring
        CASPDirMonitorEntry *pDME = NULL;
        if (RegisterASPDirMonitorEntry(szPath, &pDME))
            {
            Assert(pDME);
            pApplication->AddDirMonitorEntry(pDME);
            }
        }


        return TRUE;

    }


/*===================================================================
BOOL CTemplateCacheManager::ShutdownCacheChangeNotification

    Turn off change notification for changes to files in the cache

Parameters:
    None

Returns:
    Nothing
===================================================================*/
BOOL CTemplateCacheManager::ShutdownCacheChangeNotification()
    {

    BOOL fDoingMemoryTemplates = TRUE;

    LockTemplateCache();

    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesBegin());
    while (fDoingMemoryTemplates
             ? !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pTemplate)
             : !m_pHashTemplates->FPersistTemplatesDblLinkAtEnd(pTemplate)) {

        if(pTemplate->m_rgpFilemaps)
            {
            for(UINT i = 0; i < pTemplate->m_cFilemaps; i++)
                {
                // Give up our ref count on the directory monitor entry
                if (pTemplate->m_rgpFilemaps[i]->m_pDME)
                    {
                    pTemplate->m_rgpFilemaps[i]->m_pDME->Release();
                    pTemplate->m_rgpFilemaps[i]->m_pDME = NULL;
                    }
                }
            }

        pTemplate = static_cast<CTemplate *>(pTemplate->PNext());
        if (fDoingMemoryTemplates && m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pTemplate)) {
            fDoingMemoryTemplates = FALSE;
            pTemplate = static_cast<CTemplate *>(m_pHashTemplates->PersistTemplatesBegin());
        }
    }

    UnLockTemplateCache();
    return TRUE;
    }

/*  ****************************************************************************
    CIncFileMap member functions
*/

/*===================================================================
CIncFileMap::CIncFileMap

Parameters: N/A

Returns: N/A
===================================================================*/

CIncFileMap::CIncFileMap()
    {
    }


/*===================================================================
CIncFileMap::~CIncFileMap

Parameters: N/A

Returns: N/A
===================================================================*/

CIncFileMap::~CIncFileMap()
    {
    }



/*===================================================================
CIncFileMap::Init

Parameters: None

Returns: Completion Status
===================================================================*/

HRESULT CIncFileMap::Init()
    {
    HRESULT hr;
    ErrInitCriticalSection(&m_csUpdate, hr);
    if (FAILED(hr))
        return(hr);
    return m_mpszIncFile.Init(CINCFILEBUCKETS);
    }


/*===================================================================
CIncFileMap::GetIncFile

    Get an inc-file from the cache, first storing it into cache if it is not yet there.

Parameters:
    szIncFile   - file name
    ppIncFile   - ptr-to-ptr to inc-file (out-parameter)

Returns: HRESULT
===================================================================*/

HRESULT CIncFileMap::GetIncFile(const TCHAR *szFile, CIncFile **ppIncFile)
    {
    HRESULT hrInit = S_OK;           // return value

    LockIncFileCache();

    Assert(IsNormalized(szFile));
    *ppIncFile = static_cast<CIncFile *>(m_mpszIncFile.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR)));

    // if we have a cached inc-file at this stage, it must be "reliable," so we use it.
    // else, if we have no cached inc-file, create a new one.
    if (*ppIncFile == NULL)
        {
        if ((*ppIncFile = new CIncFile) == NULL)
            {
            UnLockIncFileCache();
            return E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hrInit = (*ppIncFile)->Init(szFile)))
            {
            // The hash table will hold a reference to the inc file
            (*ppIncFile)->AddRef();
            m_mpszIncFile.AddElem(*ppIncFile);
            }
        else
            {
            //
            // Init can fail with E_OUTOFMEMORY on call to SmallAlloc or due to a failure to init critical section.
            // Cleanup allocated memory for ppIncFile if that is the case.
            //
            delete *ppIncFile;
            *ppIncFile = NULL;
            }

        }

    if (SUCCEEDED(hrInit))
        {
        // The caller will hold a reference to the inc file
        (*ppIncFile)->AddRef();
        }

    UnLockIncFileCache();

    return hrInit;
    }



/*===================================================================
CIncFileMap::UnInit

Parameters: N/A

Returns: Completion status
===================================================================*/

HRESULT CIncFileMap::UnInit()
    {
    CIncFile *pNukeIncFile = static_cast<CIncFile *>(m_mpszIncFile.Head());
    while (pNukeIncFile != NULL)
        {
        CIncFile *pNext = static_cast<CIncFile *>(pNukeIncFile->m_pNext);
        pNukeIncFile->OnIncFileDecache();
        pNukeIncFile->Release();
        pNukeIncFile = pNext;
        }
    DeleteCriticalSection(&m_csUpdate);
    return m_mpszIncFile.UnInit();
    }



/*===================================================================
CIncFileMap::Flush

Parameters:
    szFile - the file to remove from cache

Returns:
    None
===================================================================*/

void CIncFileMap::Flush(const TCHAR *szFile)
    {
    LockTemplateAndIncFileCaches();

    Assert(IsNormalized(szFile));
    CIncFile *pIncFile = static_cast<CIncFile *>(m_mpszIncFile.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR)));

    if (pIncFile != NULL)
        {
        if (pIncFile->FlushTemplates())
            {
            // Remove from hash table
            m_mpszIncFile.DeleteElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
            // The hash table gave up its reference
            // to the incfile
            pIncFile->OnIncFileDecache();
            pIncFile->Release();
            }
        }

    UnLockTemplateAndIncFileCaches();
    }



/*===================================================================
CIncFileMap::FlushFiles

Parameters:
    szFile - the file prefix to search for in cache

Returns:
    None
===================================================================*/

void CIncFileMap::FlushFiles(const TCHAR *szFilePrefix)
    {
    LockTemplateAndIncFileCaches();

    Assert(IsNormalized(szFilePrefix));
    CIncFile *pIncFile = static_cast<CIncFile *>(m_mpszIncFile.Head());

    while (pIncFile != NULL)
        {
		CIncFile *pNextFile = static_cast<CIncFile *>(pIncFile->m_pNext);

		int cchFilePrefix = _tcslen(szFilePrefix);
		if (pIncFile->m_cbKey >= (cchFilePrefix*(int)sizeof(TCHAR)) &&
		    _tcsncmp(reinterpret_cast<TCHAR *>(pIncFile->m_pKey), szFilePrefix, cchFilePrefix) == 0)
			{
#if UNICODE
			DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %S\n", pIncFile->m_pKey));
#else
            DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %s\n", pIncFile->m_pKey));
#endif
            if (pIncFile->FlushTemplates())
				{
				// Remove from hash table
				m_mpszIncFile.DeleteElem(pIncFile->m_pKey, pIncFile->m_cbKey);
				// The hash table gave up its reference
				// to the incfile
				pIncFile->OnIncFileDecache();
				pIncFile->Release();
				}
			}

		pIncFile = pNextFile;
        }

    UnLockTemplateAndIncFileCaches();
    }



/*  ****************************************************************************
    Non-class support functions
*/

/*===================================================================
FFileChangedSinceCached
Has the file changed since it was cached?

Parameters:
    szFile          - file name
    ftPrevWriteTime - the file's "previous write time"
                      (its last-write-time value when the file was cached)

Returns:
    TRUE or FALSE
===================================================================*/
BOOL FFileChangedSinceCached(const TCHAR *szFile, HANDLE hFile, FILETIME& ftPrevWriteTime)
    {
    BOOL           fRet = FALSE;   // return value
    FILETIME        ftLastWriteTime;

    if (FAILED(AspGetFileAttributes(szFile, hFile, &ftLastWriteTime)))
        {
        // assume file was changed if get file attributes failed
        fRet = TRUE;
        }

    if( 0 != CompareFileTime( &ftPrevWriteTime, &ftLastWriteTime) )
        {
        // file was changed if file times differ
        fRet = TRUE;
        }

    return fRet;
    }

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::TrimPersistCache

Parameters:
    dwTrimCount - the number of templates to trim from the cache

Returns:
    TRUE - if dwTrimCount was actually trimmed
    FALSE - if exited before dwTrimCount was met

===================================================================*/

BOOL CTemplateCacheManager::CTemplateHashTable::TrimPersistCache(DWORD  dwTrimCount)
{
    // enter a while loop to trim until the count is reached

    while(dwTrimCount--) {

        // if there isn't anything else to trim, we're done.  Return FALSE
        // to indicate that dwTrimCount was not met.

        if (m_dwPersistedTemplates == 0) {
            return(FALSE);
        }
        else {

            CTemplate   *pTemplate;

            // get the oldest template from the list

            pTemplate = static_cast<CTemplate *>(PersistTemplatesEnd());

            // remove the template.

            RemoveTemplate(pTemplate);

            ZapTemplate(pTemplate);

        }
    }

    // return TRUE to indicate that the TrimCount was met.
    return(TRUE);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::ScavengePersistCache

Parameters:
    <NONE>

Returns:
    VOID

===================================================================*/
VOID CTemplateCacheManager::CTemplateHashTable::ScavengePersistCache()
{
    CTemplate   *pTemplate;
    CTemplate   *pTemplateNext;

    // enter a for loop to look at all persisted templates to see if
    // any memory can be freed.  It's memory can be freed only if the
    // ref count is 1 (the sole ref count is for the cache).  Also note
    // that the list is re-ordered to move templates to the head of the
    // list that can't have their memory freed at this time because of
    // the ref count.

    for (pTemplate = static_cast<CTemplate *>(PersistTemplatesBegin());
         (pTemplate != static_cast<CTemplate *>(&m_listPersistTemplates)) && (pTemplate->m_pbStart != NULL);
         pTemplate = pTemplateNext) {

        pTemplateNext = static_cast<CTemplate *>(pTemplate->PNext());

        // this check should be safe.  The only risk is that we miss a release
        // of the template from 2 to 1, in which case will miss it this time
        // but get it the next time through.  AddRef from 1 to 2 is impossible
        // to interrupt because it couldn't be on this list when it gets AddRef'd
        // from 1 to 2 and moving it from this list is protected by the template
        // cache lock which we should be under.

        if (pTemplate->m_cRefs == 1) {

            BOOL    fDeleteRecord = FALSE;

            if (pTemplate->m_cUseCount == 1) {

                // not going to continue to cache or persist a template that
                // was used just once.

                fDeleteRecord = TRUE;

                g_nScavengedPurged++;
            }
            else if (pTemplate->PersistData(m_szPersistCacheDir) != S_OK) {

                // a failure will result in the record being deleted.

                fDeleteRecord = TRUE;

                g_nScavengedPersistFailed++;

            }
            else {

                g_nScavengedPersisted++;

                // remove the memory

                CTemplate::LargeFree(pTemplate->m_pbStart);
                pTemplate->m_pbStart = NULL;
            }

            if (fDeleteRecord) {

                if (RemoveTemplate(pTemplate, FALSE, FALSE) == LK_SUCCESS)
                    ZapTemplate(pTemplate);
            }
        }
        else {

            // if some is still using it, move the template to the head of the
            // list so that we'll check again later.

            pTemplate->PrependTo(m_listPersistTemplates);
        }
    }
}

/*===================================================================
    GetAggregatedTemplCounter()

    Returns the Template Perf Counter.  To do this, initializes a private
    copy of the perfmainblock and aggregates the stats into it.

===================================================================*/
static DWORD GetAggregatedTemplCounter()
{

    CPerfMainBlock  perfSharedBlk;
    DWORD           pdwCounters[C_PERF_PROC_COUNTERS];
    BOOL            bInited = FALSE;

    memset(pdwCounters, 0, sizeof(pdwCounters));

    if (!(bInited = (perfSharedBlk.Init() == S_OK)));

    else {

        perfSharedBlk.GetStats(pdwCounters);
    }

    if (bInited)
        perfSharedBlk.UnInit();

    return(pdwCounters[ID_TEMPLCACHE]);
}

/*===================================================================
 CTemplateCacheManager::OnInitCleanup

Parameters:
    [none]

Returns:
    BOOL to indicate if the init was successful

===================================================================*/

DWORD    CTemplateCacheManager::OnInitCleanup(VOID *p)
{
    // we are using a single character buffer to construct all directory and file names we use.
    CHAR             szDirBuffer[ MAX_PATH + 32];

    // first build the template for the cache directories
    INT iLen = _snprintf(szDirBuffer,
                         MAX_PATH,
                         "%s\\PID*.TMP",
                         Glob(pszPersistTemplateDir),
                         GetCurrentProcessId());

    if ((iLen <= 0) || (iLen >= MAX_PATH)) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // outer loop: find all directories, retrieve PID, if process not exist, go to inner
    // inner loop: delete all ASP cache files

    WIN32_FIND_DATAA RootDir_FindData;
    HANDLE hRootDir = FindFirstFileA( szDirBuffer, &RootDir_FindData );

    WIN32_FIND_DATAA FileDir_FindData;
    HANDLE hFileDir;

    if ( hRootDir != INVALID_HANDLE_VALUE ) {

        // point to where the cache subdirectory begins
        CHAR *pDir = szDirBuffer + strlen(Glob(pszPersistTemplateDir)) + 1;
        CHAR *pFile;
        CHAR *pc;
        DWORD pid;
        HANDLE hProcess;

        do {
            // validate file name is what we expect and extract the PID
            // we know the first letters are 'PID' as that was the search criteria

            pc = RootDir_FindData.cFileName + 3;

            for(pid = 0; isdigit(*pc); pid = pid*10 + *pc++ - '0');

            if (pid == 0) {
                continue;
            }

            hProcess = OpenProcess(SYNCHRONIZE, FALSE, pid);

            if (hProcess) {

                // the process is alive, so leave the directory alone.

                CloseHandle( hProcess );
                continue;
            }

            if (GetLastError() != ERROR_INVALID_PARAMETER) {

                // we got an error other than "no such process"

                Assert( GetLastError() == ERROR_ACCESS_DENIED);

                continue;
            }

            // The process does not exist, so clean up the directory
            // Add the directory name, append a '\', append the file template, and point pFile
            // to the position where the file name starts

            strcpy( pDir, RootDir_FindData.cFileName );
            pFile = pDir + strlen(pDir);
            *pFile++ = '\\';
            strcpy( pFile, "ASP*.TMP" );

            // search the subdirectory for asp template cache files

            hFileDir = FindFirstFileA( szDirBuffer, &FileDir_FindData );

            if ( hFileDir != INVALID_HANDLE_VALUE ) {
                do {
                    // append the file name and delete the file
                    strcpy( pFile, FileDir_FindData.cFileName);

                    DeleteFileA( szDirBuffer );

                } while (FindNextFileA( hFileDir, &FileDir_FindData ));

                FindClose( hFileDir );
            }

            // Now zap the last part of the path and delete the directory

            *--pFile = '\0';
            RemoveDirectoryA( szDirBuffer );

        } while (FindNextFileA( hRootDir, &RootDir_FindData ));

        FindClose( hRootDir );
    }

    return S_OK;
}

/*===================================================================
 CTemplateCacheManager::InitPersistCache

Parameters:
    [none]

Returns:
    BOOL to indicate if the init was successful

===================================================================*/

BOOL    CTemplateCacheManager::InitPersistCache(CIsapiReqInfo *pIReq)
{
    HANDLE      hImpersonationToken = NULL;
    BOOL        fRevertedToSelf = FALSE;
    DWORD       dirAttribs;
    INT         iLen;
    UINT        uiEventSubId = 0;
    DWORD       dwError = ERROR_SUCCESS;

    if (OpenThreadToken( GetCurrentThread(),
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,
                         &hImpersonationToken )) {

       RevertToSelf();
       fRevertedToSelf = TRUE;
    }

    // build the cache directory name

    iLen = _snprintf(m_szPersistCacheDir,
                     sizeof(m_szPersistCacheDir),
                     "%s\\PID%d.TMP",
                     Glob(pszPersistTemplateDir),
                     GetCurrentProcessId());

    if ((iLen <= 0) || (iLen >= sizeof(m_szPersistCacheDir))) {

        uiEventSubId = IDS_CACHE_DIR_NAME_TOO_LONG;

        goto LExit;
    }

    // If directory exists, rename it to something else (must be an old leftover

    dirAttribs = GetFileAttributesA(m_szPersistCacheDir);

    if (dirAttribs != INVALID_FILE_ATTRIBUTES) {

        // recreate the same dir name with a leading 0 for the pid...

        CHAR szNewDirName[ sizeof(m_szPersistCacheDir) ];
        iLen = _snprintf(szNewDirName,
                         sizeof(szNewDirName),
                         "%s\\PID0%d.TMP",
                         Glob(pszPersistTemplateDir),
                         GetCurrentProcessId());

        if ((iLen <= 0) || (iLen >= sizeof(szNewDirName))) {

            uiEventSubId = IDS_CACHE_DIR_NAME_TOO_LONG;

            goto LExit;
        }

        if (!MoveFileA(m_szPersistCacheDir, szNewDirName)) {

            uiEventSubId = IDS_CACHE_SUBDIR_CREATION_FAILED;
            dwError = GetLastError();

            goto LExit;
        }
    }

    // Now create it

    if (CreateDirectoryA(m_szPersistCacheDir, NULL)) {

        dirAttribs = GetFileAttributesA(m_szPersistCacheDir);
    } else {

        uiEventSubId = IDS_CACHE_SUBDIR_CREATION_FAILED;
        dwError = GetLastError();

        goto LExit;
    }

    if ((dirAttribs == INVALID_FILE_ATTRIBUTES)
        || !(dirAttribs & FILE_ATTRIBUTE_DIRECTORY)) {

        uiEventSubId = IDS_CACHE_SUBDIR_MISSING;

        goto LExit;
    }

    // start the scavenger thread

    m_hOnInitCleanupThread = CreateThread(NULL,
                                      0,
                                      CTemplateCacheManager::OnInitCleanup,
                                      NULL,
                                      0,
                                      NULL);


LExit:

    if (uiEventSubId != 0) {
        //
        // an initialization error has occured. log it and indicate initialization fail.
        //

        MSG_Error(IDS_CACHE_INIT_FAILED, pIReq->QueryPszAppPoolIdA(), uiEventSubId, dwError);

        m_fFailedToInitPersistCache = TRUE;
    }

    if (fRevertedToSelf) {
        SetThreadToken(NULL, hImpersonationToken);
        CloseHandle(hImpersonationToken);
    }

    return(!m_fFailedToInitPersistCache);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::CanPersistTemplate

Parameters:
    pTemplate - The template to test for persistability

Returns:
    BOOL to indicate if template can be persisted.

===================================================================*/

BOOL CTemplateCacheManager::CTemplateHashTable::CanPersistTemplate(CTemplate  *pTemplate)
{

    // if MaxFiles is zero, then the persist cache is disabled

    if (Glob(dwPersistTemplateMaxFiles) == 0)
    {
        return(FALSE);
    }

    // can't persist if the persist cache failed to init

    if (m_fFailedToInitPersistCache == TRUE)
    {
        return(FALSE);
    }

    // can't persist templates that are marked as debuggable.  The
    // script engines need access to the memory.

    if (pTemplate->FDebuggable())
    {
        return(FALSE);
    }

    //
    // Cannot write an Encrypted file to disk as we would be writing it in plaintext.
    //
    if (pTemplate->FIsEncrypted())
    {
        return(FALSE);
    }

    // at this point, we're going to return true.  The next part of the code
    // trims the cache as necessary.

    if (m_dwPersistedTemplates >= Glob(dwPersistTemplateMaxFiles))
    {
        //
        // Ignore the value returned from TrimPersistCache as we are not concerned if we met the
        // trim count or not. In anycase, there should be 1 available location to add the new template.
        // Optimization may be to free up couple of places (configurable through the metabase) to achieve performance.
        //
        TrimPersistCache(m_dwPersistedTemplates - Glob(dwPersistTemplateMaxFiles) + 1);
    }

    return(TRUE);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::InsertTemplate

Parameters:
    pTemplate - Template to insert into the memory cache

Returns:
    LK_RETCODE indicating the success of the insertion

===================================================================*/

LK_RETCODE CTemplateCacheManager::CTemplateHashTable::InsertTemplate(CTemplate *pTemplate)
{
	LK_RETCODE rcode = InsertRecord(pTemplate, true);

	if (rcode == LK_SUCCESS) {
#ifndef PERF_DISABLE
        g_PerfData.Incr_MEMORYTEMPLCACHE();
        g_PerfData.Incr_TEMPLCACHE();
#endif
        m_dwInMemoryTemplates++;
		pTemplate->PrependTo(m_listMemoryTemplates);
        pTemplate->SetHashTablePtr(this);
    }

    ScavengePersistCache();

	return rcode;
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::RemoveTemplate

Parameters:
    pTemplate - Template to remove from cache
    fPersist - indicate if memory template is a candidate for persist

Returns:
    LK_RETCODE indicating the success of the removal

===================================================================*/

LK_RETCODE CTemplateCacheManager::CTemplateHashTable::RemoveTemplate(CTemplate *pTemplate,
                                                                     BOOL fPersist,
                                                                     BOOL fScavengePersistCache)
{
	LK_RETCODE rcode = LK_SUCCESS;
#if DBG_PERSTEMPL
    DBGPRINTF((DBG_CONTEXT,
              "RemoveTemplate entered.\n\tTemplate = %s.\n\tfPersist = %d.\n\tFIsPersisted = %d\n",
              pTemplate->GetSourceFileName(),
              fPersist,
              pTemplate->FIsPersisted()));
#endif

    // if the template isn't in the cache, or if the template isn't on this
    // particular hash table, then just bail.  Nothing to
    // do here.  It may not be on this particular hash table because the entire
    // table may have been torn off the global cache manager and scheduled for
    // cleanup on the flush thread.  In this case, we're checking the wrong
    // table.  The flush thread will eventually clean this one up.

    if (pTemplate->FIsEmpty() || (pTemplate->GetHashTablePtr() != this)) {

        return LK_NO_SUCH_KEY;
    }

    // no matter what, this template is going to be unlinked from it's
    // current CDblLink

    pTemplate->UnLink();

    // update the appropriate counter

    if (pTemplate->FIsPersisted() == FALSE) {

        // decrement the number of InMemoryTemplates...

#ifndef PERF_DISABLE
        g_PerfData.Decr_MEMORYTEMPLCACHE();
#endif
        m_dwInMemoryTemplates--;
    }
    else {
        m_dwPersistedTemplates--;
    }

    // if asked to be persisted, see if it's a candidate to be persisted.

    if (fPersist && CanPersistTemplate(pTemplate)) {

        pTemplate->m_fIsPersisted = TRUE;

        // if successfully persisted, then add to the list of
        // persisted templates

        pTemplate->PrependTo(m_listPersistTemplates);

        m_dwPersistedTemplates++;

    }
    else {

#ifndef PERF_DISABLE
            g_PerfData.Decr_TEMPLCACHE();
#endif
        // if not asked to persist, then delete the record.

        rcode = DeleteRecord(pTemplate);
    }

    if (fScavengePersistCache)

        ScavengePersistCache();

	return rcode;
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::FindTemplate

Parameters:
    rTemplate - the key for the template being looked up

Returns:
    LK_RETCODE indicating the success of the look up

===================================================================*/

LK_RETCODE  CTemplateCacheManager::CTemplateHashTable::FindTemplate(const CTemplateKey &rTemplateKey, CTemplate **ppTemplate, BOOL *pfNeedsCheck)
 {

#if DBG_PERSTEMPL

    DBGPRINTF((DBG_CONTEXT,
              "FindTemplate entered\n\tLooking for %s\n",
              rTemplateKey.szPathTranslated));
#endif

#ifndef PERF_DISABLE
    g_PerfData.Incr_MEMORYTEMPLCACHETRYS();
    g_PerfData.Incr_TEMPLCACHETRYS();
#endif

    LK_RETCODE rcode = FindKey(&rTemplateKey, ppTemplate);

    // see if we found it.

	if (rcode == LK_SUCCESS) {

#if DBG_PERSTEMPL

        DBGPRINTF((DBG_CONTEXT,
                   "Template found\n\tfPersisted = %d\n",
                   (*ppTemplate)->FIsPersisted()));
#endif

#ifndef PERF_DISABLE
            g_PerfData.Incr_TEMPLCACHEHITS();
#endif
        // found it.  Is it persisted?

        if ((*ppTemplate)->FIsPersisted()) {

            // It is persisted.  Unlink it from the persisted list.

            (*ppTemplate)->UnLink();

            m_dwPersistedTemplates--;

            // unpersist it

            if ((*ppTemplate)->UnPersistData() != S_OK) {

                // error occurred

                // get the template out of the cache

                DeleteRecord(*ppTemplate);

                // release the reference that the cache had on the template

                (*ppTemplate)->Release();

                // NULL out *ppTemplate so that the caller doesn't think they
                // got a valid template

                *ppTemplate = NULL;

#ifndef PERF_DISABLE
                g_PerfData.Decr_TEMPLCACHE();
#endif
                // return NO_SUCH_KEY so that a new template will be built

                return(LK_NO_SUCH_KEY);
            }

            // bump the number of in memory templates

#ifndef PERF_DISABLE
            g_PerfData.Incr_MEMORYTEMPLCACHE();
#endif
            m_dwInMemoryTemplates++;
        }
        else {
#ifndef PERF_DISABLE
            g_PerfData.Incr_MEMORYTEMPLCACHEHITS();
#endif
        }

        // add it to, or move it to the top of, the memory templates

		(*ppTemplate)->PrependTo(m_listMemoryTemplates);
    }


    if (pfNeedsCheck && *ppTemplate && (*ppTemplate)->FNeedsValidation() && (*ppTemplate)->FIsValid())
        *pfNeedsCheck = TRUE;

    ScavengePersistCache();

	return rcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\aspdmon.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       aspdirmon.cpp

   Abstract:
       This module includes derivation of class supporting change
       notification for ASP template cache, from abstract class DIR_MON_ENTRY

   Author:

       Charles Grant    ( cgrant )     June-1997 

   Revision History:

--*/
#ifndef _CACHEDIRMON_H
#define _CACHEDIRMON_H

// ASP-customized file notification filter 
// see Winnt.h for valid flags, only valid for NT
#define FILE_NOTIFY_FILTER  (FILE_NOTIFY_CHANGE_FILE_NAME  | \
                               FILE_NOTIFY_CHANGE_DIR_NAME | \
                               FILE_NOTIFY_CHANGE_ATTRIBUTES | \
                               FILE_NOTIFY_CHANGE_SIZE       | \
                               FILE_NOTIFY_CHANGE_LAST_WRITE | \
                               FILE_NOTIFY_CHANGE_SECURITY)

// Number of times we will try to get request notification
#define MAX_NOTIFICATION_FAILURES 3

/************************************************************
 *     Include Headers
 ************************************************************/
# include "dirmon.h"
# include "reftrace.h"

class CASPDirMonitorEntry : public CDirMonitorEntry
{
private:
    DWORD m_cNotificationFailures;

    BOOL ActOnNotification(DWORD dwStatus, DWORD dwBytesWritten);
    void FileChanged(const TCHAR *pszScriptName, bool fFileWasRemoved);

public:
    CASPDirMonitorEntry();
    ~CASPDirMonitorEntry();
    VOID AddRef(VOID);
    BOOL Release(VOID);

    BOOL FPathMonitored(LPCTSTR  pszPath);

    // Trace Log info
	static PTRACE_LOG gm_pTraceLog;

};

BOOL RegisterASPDirMonitorEntry(LPCTSTR pszDirectory, CASPDirMonitorEntry **ppDME, BOOL  fWatchSubDirs = FALSE);

BOOL ConvertToLongFileName(const TCHAR *pszPath, const TCHAR *pszName, WIN32_FIND_DATA *pwfd);

/*===================================================================
  Globals
===================================================================*/

extern CDirMonitor  *g_pDirMonitor;


#endif /* _CACHEDIRMON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\asperror.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: ASPError object

File: asperror.h

Owner: dmitryr

This file contains the definiton of the ASPError class
===================================================================*/

#ifndef _ASPERROR_H
#define _ASPERROR_H

#include "debug.h"
#include "asptlb.h"
#include "disptch2.h"
#include "memcls.h"

// forward decl
class CErrInfo; 


class CASPError : public IASPErrorImpl
	{
private:
    LONG  m_cRefs;

    CHAR *m_szASPCode;
    LONG  m_lNumber;
	int   m_nColumn;
    CHAR *m_szSource;
    CHAR *m_szFileName;
    LONG  m_lLineNumber;
    CHAR *m_szDescription;
    CHAR *m_szASPDescription;
	BSTR  m_bstrLineText;

    BSTR ToBSTR(CHAR *sz);

public:
	// default constructor for 'dummy' error
	CASPError();
	// real constructor
	CASPError(CErrInfo *pErrInfo);
	
	~CASPError();

    // IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IASPError
	STDMETHODIMP get_ASPCode(BSTR *pbstrASPCode);
	STDMETHODIMP get_Number(long *plNumber);
	STDMETHODIMP get_Category(BSTR *pbstrSource);
	STDMETHODIMP get_File(BSTR *pbstrFileName);
	STDMETHODIMP get_Line(long *plLineNumber);
	STDMETHODIMP get_Description(BSTR *pbstrDescription);
	STDMETHODIMP get_ASPDescription(BSTR *pbstrDescription);
	STDMETHODIMP get_Column(long *plColumn);
	STDMETHODIMP get_Source(BSTR *pbstrLineText);

	// Cache on per-class basis
	ACACHE_INCLASS_DEFINITIONS()
	};

#endif //_ASPERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\clcert.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: clcert.h

Owner: DGottner

This file contains the definiton of the CCookie class, which
contains all of the state for an HTTP cookie
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asptlb.h"
#include "dispatch.h"
#include "hashing.h"
#include "memcls.h"

class CClCert;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


/*
 * C C l C e r t S u p p o r t E r r
 *
 * Implements ISupportErrorInfo for the CClCert class. The CSupportError class
 * is not adequate because it will only report a max of one interface which
 * supports error info. (We have two)
 */
class CClCertSupportErr : public ISupportErrorInfo
	{
private:
	CClCert *	m_pClCert;

public:
	CClCertSupportErr(CClCert *pClCert);

	// IUnknown members that delegate to m_pClCert
	//
	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(const GUID &);
	};


/*
 * C R e a d C l C e r t
 *
 * Implements IClCert which is the interface that Request.ClientCert
 * returns.  It is an IRequestDictionary.
 */
class CReadClCert : public IRequestDictionaryImpl
	{
private:
	CClCert *			m_pClCert;

public:
	CReadClCert(CClCert *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IRequestDictionary implementation
	//
	STDMETHODIMP			get_Item(VARIANT i, VARIANT *pVariantReturn);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get_Key(VARIANT VarKey, VARIANT *pvar);
	};




/*
 * C C l C e r t
 *
 * Implements CClCert, which is the object stored in the Request.Cookies
 * dictionary.
 */
class CClCert : public IUnknown
	{
	friend CReadClCert;

protected:
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CReadClCert			m_ReadClCertInterface;		// implementation of IStringList
	CClCertSupportErr	m_ClCertSupportErrorInfo;	// implementation of ISupportErrorInfo

	char *				m_szValue;					// value of clcert when not a dictionary
    VARENUM             m_veType;
    UINT                m_cLen;

public:
	CClCert(IUnknown * = NULL, PFNDESTROYED = NULL);
	~CClCert();

	HRESULT AddValue(char *szValue, VARENUM ve = VT_BSTR, UINT l = 0 );

	size_t GetHTTPClCertSize();				// return information on how big a buffer should be
	char * GetHTTPClCert(char *szBuffer);	// return the clcert value HTTP encoded

	size_t GetClCertHeaderSize(const char *szName);				// return buffer size for header
	char *GetClCertHeader(const char *szName, char *szBuffer);	// return cookie header

	HRESULT		Init();

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const GUID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

//
// simple class to handle extensible buffer
// It is guaranteed that a portion of the buffer 
// can be appended to itself.
// extension is done on a XBF_EXTEND granularity
//

#define XBF_EXTEND  512

class XBF {

public:
    XBF( LPSTR pB, int cB ) { m_pV = pB; m_cAlloc = cB; m_cSize = 0; }
    ~XBF() {}
    void Reset() { m_cSize = 0; m_cAlloc = 0; m_pV = NULL; }

    // Append a string with '\0' delimiter

    LPSTR AddStringZ( LPSTR pszV, BOOL fXt = FALSE )
    {
        return AddBlob( pszV, strlen(pszV) +1, fXt );
    }

    // Append a string w/o '\0' delimiter

    LPSTR AddString( LPSTR pszV, BOOL fXt = FALSE )
    {
        return AddBlob( pszV, strlen(pszV), fXt );
    }

    // Append a byte range

    LPSTR AddBlob( LPSTR pszV, int cV, BOOL fXt = FALSE )
    {
        if ( m_cSize + cV > m_cAlloc )
        {
            if ( !fXt || !Extend( m_cSize + cV ) )
            {
                return NULL;
            }
        }

        LPSTR pV;
        memcpy( pV = m_pV + m_cSize, pszV, cV );
        m_cSize += cV;

        return pV;
    }

    LPSTR ReserveRange( int cV , int align = 1)
    {
        int curUsed = ((m_cSize + (align - 1)) & ~(align - 1));
        if ( (curUsed + cV) > m_cAlloc )
        {
            return NULL;
        }

        return m_pV + curUsed;
    }

    VOID SkipRange( int cV, int align = 1)
    {
        m_cSize += ((cV + (align - 1)) & ~(align - 1));
    }

    BOOL Extend( int cA );

    // pointer to buffer

    LPSTR QueryBuf() const { return m_pV; }

    // size of buffer

    int QuerySize() { return m_cSize; }

    int QueryAllocSize() { return m_cAlloc; }

private:
    int m_cAlloc;       // allocated memory
    int m_cSize;        // used memory
    LPSTR m_pV;         // buffer
} ;


class CCertRequest {
public:
    CCertRequest( CRequest* Req ) { pReq = Req; }
    ~CCertRequest() {}

    HRESULT AddStringPair( CollectionType Source, LPSTR szName, 
                           LPSTR szValue, XBF *pxbf, BOOL fDuplicate, UINT lCodePage );
    HRESULT AddDatePair( CollectionType Source, LPSTR szName, 
                           FILETIME* pValue, XBF *pxbf );
    HRESULT AddDwordPair( CollectionType Source, LPSTR szName, 
                           LPDWORD pValue, XBF *pxbf );
    HRESULT AddBinaryPair( CollectionType Source, LPSTR szName, 
                           LPBYTE pValue, DWORD cValue, XBF *pxbf, UINT lCodePage );
    HRESULT AddUuBinaryPair( CollectionType Source, LPSTR szName, 
                           LPBYTE pValue, DWORD cValue, XBF *pxbf, UINT lCodePage );
    HRESULT AddName( LPSTR szName, CRequestHit **ppReqHit, XBF *pxbf );
    HRESULT ParseRDNS( CERT_NAME_INFO* pNameInfo, LPSTR pszPrefix, XBF *pxbf, UINT lCodePage );
    HRESULT ParseCertificate( LPBYTE pCert, DWORD cCert, DWORD dwEncoding, DWORD dwFlags, UINT lCodePage );
    HRESULT NoCertificate();

private:
    CRequest *pReq;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\connpt.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: IConnectionPoint implementation

File: ConnPt.h

Owner: DGottner

This file contains our implementation of IConnectionPoint
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "ConnPt.h"
#include "memchk.h"


/*------------------------------------------------------------------
 * C C o n n e c t i o n P o i n t
 */

/*===================================================================
CConnectionPoint::CConnectionPoint
CConnectionPoint::~CConnectionPoint

Parameters (Constructor):
	pUnkObj			pointer to the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.

NOTE: Code assumes connection point is contained DIRECTLY in the
      container (and thus, does not AddRef 'm_pContainer'
      If not the case, we may be in trouble.
===================================================================*/

CConnectionPoint::CConnectionPoint(IUnknown *pUnkContainer, const GUID &uidEvent)
	{
	m_pUnkContainer = pUnkContainer;
	m_uidEvent = uidEvent;
	m_dwCookieNext = 0xA5B;		// Looks like "ASP"!

	Assert (m_pUnkContainer != NULL);
	}

CConnectionPoint::~CConnectionPoint()
	{
	while (! m_listSinks.FIsEmpty())
		delete m_listSinks.PNext();
	}



/*===================================================================
CConnectionPoint::GetConnectionInterface

Returns the interface of the event source
===================================================================*/

HRESULT
CConnectionPoint::GetConnectionInterface(GUID *puidReturn)
	{
	*puidReturn = m_uidEvent;
	return S_OK;
	}



/*===================================================================
CConnectionPoint::GetConnectionPointContainer

Returns the interface of the event source
===================================================================*/

HRESULT
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppContainer)
	{
	return m_pUnkContainer->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void **>(ppContainer));
	}



/*===================================================================
CConnectionPoint::Advise

Purpose:
 Provides this connection point with a notification sink to
 call whenever the appropriate outgoing function/event occurs.

Parameters:
 pUnkSink        IUnknown to the sink to notify.  The connection
                 point must QueryInterface on this pointer to obtain
                 the proper interface to call.  The connection
                 point must also insure that any pointer held has
                 a reference count (QueryInterface will do it).
 pdwCookie       DWORD * in which to store the connection key for
                 later calls to Unadvise.
===================================================================*/

HRESULT
CConnectionPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
	{
	// Make sure they store the correct interface pointer!
	// NOTE: Storing into the list will AddRef, to we need to Release the
	//       QueryInterface pointer right away.
	//
	void *pvT;
	if (FAILED(pUnkSink->QueryInterface(m_uidEvent, &pvT)))
		return CONNECT_E_CANNOTCONNECT;
	pUnkSink->Release();

	CSinkElem *pSinkElem = new CSinkElem(*pdwCookie = m_dwCookieNext++, pUnkSink);
	if (pSinkElem == NULL)
		return E_OUTOFMEMORY;

	pSinkElem->AppendTo(m_listSinks);
	return S_OK;
	}



/*===================================================================
CConnectionPoint::Unadvise

Purpose:
 Terminates the connection to the notification sink identified
 with dwCookie (that was returned from Advise).  The connection
 point has to Release any held pointers for that sink.

Parameters:
 dwCookie        DWORD connection key from Advise.
===================================================================*/

HRESULT
CConnectionPoint::Unadvise(DWORD dwCookie)
	{
	// Search for the cookie
	for (CSinkElem *pSinkElem = static_cast<CSinkElem *>(m_listSinks.PNext());
		 pSinkElem != &m_listSinks;
		 pSinkElem = static_cast<CSinkElem *>(pSinkElem->PNext()))
		{
		if (dwCookie == pSinkElem->m_dwCookie)
			{
			delete pSinkElem;
			return S_OK;
			}
		}

	return CONNECT_E_NOCONNECTION;
	}



/*===================================================================
CConnectionPoint::EnumConnections

Purpose:
 Creates and returns an enumerator object with the
 IEnumConnections interface that will enumerate the IUnknown
 pointers of each connected sink.

Parameters:
 ppEnum          Output enumerator object
===================================================================*/

HRESULT
CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
	{
	if ((*ppEnum = new CEnumConnections(this)) == NULL)
		return E_OUTOFMEMORY;

	return S_OK;
	}


/*------------------------------------------------------------------
 * C E n u m C o n n e c t i o n s
 */

/*===================================================================
CEnumConnections::CEnumConnections
CEnumConnections::~CEnumConnections

Parameters (Constructor):
	pCP				pointer to object we're in.
===================================================================*/

CEnumConnections::CEnumConnections(CConnectionPoint *pCP)
	{
	Assert (pCP != NULL);

	m_cRefs = 1;
	m_pCP   = pCP;

	m_pCP->AddRef();
	Reset();
	}

CEnumConnections::~CEnumConnections()
	{
	m_pCP->Release();
	}



/*===================================================================
CEnumConnections::QueryInterface
CEnumConnections::AddRef
CEnumConnections::Release

IUnknown members for CEnumConnections object.
===================================================================*/

HRESULT CEnumConnections::QueryInterface(const GUID &iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumConnections)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

ULONG CEnumConnections::AddRef()
	{
	return ++m_cRefs;
	}

ULONG CEnumConnections::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CEnumConnections::Clone

Clone this iterator (standard method)
===================================================================*/

HRESULT CEnumConnections::Clone(IEnumConnections **ppEnumReturn)
	{
	CEnumConnections *pNewIterator = new CEnumConnections(m_pCP);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pElemCurr = m_pElemCurr;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CEnumConnections::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

HRESULT CEnumConnections::Next(unsigned long cElementsRequested, CONNECTDATA *rgConnectData, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pElemCurr != &m_pCP->m_listSinks)
		{
		rgConnectData->dwCookie = static_cast<CConnectionPoint::CSinkElem *>(m_pElemCurr)->m_dwCookie;
		rgConnectData->pUnk = static_cast<CConnectionPoint::CSinkElem *>(m_pElemCurr)->m_pUnkObj;
		rgConnectData->pUnk->AddRef();

		++rgConnectData;
		--cElements;
		++*pcElementsFetched;
		m_pElemCurr = m_pElemCurr->PNext();
		}

	// initialize the remaining structures
	//
	while (cElements-- > 0)
		(rgConnectData++)->pUnk = NULL;

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CEnumConnections::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

HRESULT CEnumConnections::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pElemCurr != &m_pCP->m_listSinks)
		{
		m_pElemCurr = m_pElemCurr->PNext();
		--cElements;
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CEnumConnections::Reset

Reset the iterator (standard method)
===================================================================*/

HRESULT CEnumConnections::Reset()
	{
	m_pElemCurr = m_pCP->m_listSinks.PNext();        
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\compcol.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Component Collection

File: Compcol.h

Owner: DmitryR

This is the Component Collection header file.

Component collection replaces:  (used in:)
COleVar, COleVarList            (HitObj, Session, Application)
CObjectCover                    (HitObj, Server, Session)
VariantLink HasTable            (Session, Application)
===================================================================*/

#ifndef COMPCOL_H
#define COMPCOL_H

/*===================================================================
  Special OLE stuff
===================================================================*/

#include "gip.h"

/*===================================================================
  Misc declarations
===================================================================*/

#include "hashing.h"
#include "idhash.h"
#include "dbllink.h"
#include "util.h"
#include "viperint.h"
#include "memcls.h"

// Forward declarations
class CHitObj;
class CAppln;
class CSession;
class CScriptingContext;

// Component Types
#define CompType    DWORD
#define ctUnknown   0x00000000  // (Used as UnInitialized state)
#define ctTagged    0x00000001  // Created by <OBJECT ...> tag
#define ctProperty  0x00000002  // Created with Session("xxx") =
#define ctUnnamed   0x00000004  // Created with Server.CreateObject()

// Scope levels 
#define CompScope   DWORD
#define csUnknown   0x00000000
#define csAppln     0x00000001
#define csSession   0x00000002
#define csPage      0x00000004

// COM threading models
#define CompModel   DWORD
#define cmUnknown   0x00000000
#define cmSingle    0x00000001
#define cmApartment 0x00000002
#define cmFree      0x00000004
#define cmBoth      0x00000008

/*===================================================================
  Utility Functions Prototypes
===================================================================*/

HRESULT CompModelFromCLSID
    (
    const CLSID &ClsId, 
    CompModel *pcmModel = NULL, 
    BOOL *pfInProc = NULL
    );

BOOL FIsIntrinsic(IDispatch *pdisp);

inline BOOL FIsIntrinsic(VARIANT *pVar)
    {
    if (V_VT(pVar) != VT_DISPATCH)
        return FALSE;
    return FIsIntrinsic(V_DISPATCH(pVar));
    }

/*===================================================================
  OnPageInfo struct used to cache ids of OnStartPage()/OnEndPage()
===================================================================*/

#define ONPAGEINFO_ONSTARTPAGE      0
#define ONPAGEINFO_ONENDPAGE        1
#define ONPAGE_METHODS_MAX          ONPAGEINFO_ONENDPAGE+1

struct COnPageInfo
    {
    DISPID m_rgDispIds[ONPAGE_METHODS_MAX];

    BOOL FHasAnyMethod() const;
    };

inline BOOL COnPageInfo::FHasAnyMethod() const
    {
#if (ONPAGE_METHODS_MAX == 2)
    // fast implementation for the real case
    return
        (
        m_rgDispIds[0] != DISPID_UNKNOWN ||
        m_rgDispIds[1] != DISPID_UNKNOWN
        );
#else
    for (int i = 0; i < ONPAGE_METHODS_MAX; i++)
        {
        if (m_rgDispIds[i] != DISPID_UNKNOWN)
            return TRUE;
        }
    return FALSE;
#endif
    }

/*===================================================================
  Component object stores information about a single object
  Each component object belongs to a component collection
  Component objects are linked into a list, also
  tagged objects are hashed by name, and
  properties are hashed by name, and
  all instantiated objects are hashed by IUnknown*
===================================================================*/
class CComponentObject : public CLinkElem
    {

friend class CComponentCollection;
friend class CPageComponentManager;
friend class CComponentIterator;

private:
    // properties
	CompScope   m_csScope : 4;	// Scope
    CompType    m_ctType  : 4;  // Component Object Type
	CompModel	m_cmModel : 4;  // Threading behavior (from Registry)

	DWORD       m_fAgile : 1;   // Agile?

	// flag to indicate if OnPageInfo was queried
	DWORD       m_fOnPageInfoCached : 1;
	// flag: on-start-page done, waiting to do on-end-page
	DWORD       m_fOnPageStarted : 1;

	// flag to avoid multiple unsuccessful attempts to instantiate
	DWORD       m_fFailedToInstantiate : 1;
	// flag to mark instantiated (or tried to inst.) tagged objects
	DWORD       m_fInstantiatedTagged : 1;

	// flag to mark the object in pointer cache
	DWORD       m_fInPtrCache : 1;

    // variant filled with value?
	DWORD       m_fVariant : 1;

    // name was allocated (longer than the default buffer)?
	DWORD       m_fNameAllocated : 1;

    // requests are executing in the MTA?
    DWORD       m_fMTAConfigured : 1;

	// pointers to object and type info
	IDispatch   *m_pDisp;		// Dispatch interface pointer
	IUnknown    *m_pUnknown;	// IUnknown interface pointer

    union
    {
	CLSID		m_ClsId;	// Class id (for tagged and unnamed)
	VARIANT     m_Variant;  // Variant (for properties)
    };
    
	// For objects that use OLE cookie API
	DWORD       m_dwGIPCookie;

	// cached OnPageInfo
	COnPageInfo m_OnPageInfo;

	// pointer to connect objects into link list
	CComponentObject *m_pCompNext;  // Next object in the link list.
    CComponentObject *m_pCompPrev;  // Prev object in the link list.

    // buffer for names that fit in (36 bytes = 17 unicode chars + '\0')
	BYTE        m_rgbNameBuffer[36];

private:
    // constructor is private! (not for outside use)
    CComponentObject
        (
        CompScope csScope, 
        CompType  ctType,
        CompModel cmModel
        );
    ~CComponentObject();

    // Initializes CLinkElem portion
    HRESULT Init(LPWSTR pwszName, DWORD cbName, BOOL  fMTAConfigured);

    // Releases all interface pointers (used by clear)
    HRESULT ReleaseAll();

    // Clears out data (releases all) leaving link alone
    HRESULT Clear();
    
    // Create instance if not there already
	HRESULT Instantiate(CHitObj *pHitObj);
	HRESULT TryInstantiate(CHitObj *pHitObj);
	
    // Set value from variant
    HRESULT SetPropertyValue(VARIANT *);

    // Convert Object to be GIP cookie
    HRESULT ConvertToGIPCookie();
    
    // Get and cache the ids for OnStart methods
    HRESULT GetOnPageInfo();

public:
    // functions to get the COM object (internally resolve cookies)
    HRESULT GetAddRefdIDispatch(IDispatch **ppdisp);
    HRESULT GetAddRefdIUnknown(IUnknown **ppunk);
    HRESULT GetVariant(VARIANT *pVar);  // not for GIP cookies

    // Check if the unnamed page level object object 
    // can be removed without waiting till the end of request
    inline BOOL FEarlyReleaseAllowed() const;
    
    // public inlines to access the object's properties
    // these are the only methods available from outside
    inline LPWSTR GetName();
    
    inline CompScope GetScope() const;
    inline CompType  GetType()  const;
    inline CompModel GetModel() const;
    inline BOOL      FAgile()   const;

    // Retrieve the cached ids
    inline const COnPageInfo *GetCachedOnPageInfo() const;

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline LPWSTR CComponentObject::GetName()
    {
    return (LPWSTR)m_pKey; 
    }

inline CompScope CComponentObject::GetScope() const
    {
    return m_csScope;
    }
    
inline CompType CComponentObject::GetType() const
    {
    return m_ctType; 
    }

inline CompType CComponentObject::GetModel() const
    {
    return m_cmModel; 
    }

inline BOOL CComponentObject::FAgile() const
    {
    return m_fAgile;
    }

inline const COnPageInfo *CComponentObject::GetCachedOnPageInfo() const
    {
    return m_fOnPageInfoCached ? &m_OnPageInfo : NULL;
    }

inline BOOL CComponentObject::FEarlyReleaseAllowed() const
    {
    return (!m_fOnPageStarted   &&  // no need to do on-end-page
            !m_fInPtrCache      &&  // no need to search by pointer
            m_csScope == csPage &&  // page scoped
            m_ctType == ctUnnamed); // created with Server.CreateObject()
    }

/*===================================================================
  Component collection is a manager of various types of component
  objects:
    1) Tagged objects (<OBJECT...>) (instantiated or not)
    2) Session("xxx") and Application("xxx") properties
    3) Unnamed objects (Server.CreateObject())
  It hashes added objects as needed (some by name, IUnkn *, etc.)

  The idea is to isolate the above issues from outside as much
  as possible.

  Component collections exist under session, application, hitobj
===================================================================*/
class CComponentCollection
    {
    
friend class CPageComponentManager;
friend class CComponentIterator;
friend class CVariantsIterator;

private:
    CompScope m_csScope : 4;          // scope (page, session, appln)
    DWORD     m_fUseTaggedArray : 1;  // remember tagged objects array?
    DWORD     m_fUsePropArray   : 1;  // remember properties array?
    DWORD     m_fHasComProperties : 1; // any property VARIANTs that could be objects
    DWORD     m_fMTAConfigured    : 1; // application is running in MTA
    
    // hash table (by name) of tagged objects
    CHashTableStr m_htTaggedObjects;     
    
    // hash table (by name) of properties (4)
    CHashTableStr m_htProperties;
    
    // hash table (by IUnknown *) of all instances
    CIdHashTable m_htidIUnknownPtrs;

    // Pointer to the component objects link list
	CComponentObject *m_pCompFirst;  // First object in link list.

	// Array of pointers to static objects to speed lookup by index
	CPtrArray m_rgpvTaggedObjects;

	// Array of pointers to properties to speed lookup by index
	CPtrArray m_rgpvProperties;

    // Various object counts in the collection
    USHORT m_cAllTagged;         // all tagged objects
    USHORT m_cInstTagged;        // instanciated tagged objects
    USHORT m_cProperties;        // all properties
    USHORT m_cUnnamed;           // number of unnamed objects
    
    // Add/remove object to the component objects link list
    HRESULT AddComponentToList(CComponentObject *pObj);
    HRESULT RemoveComponentFromList(CComponentObject *pObj);
    
    // Add named object to the proper hash table by name
    HRESULT AddComponentToNameHash
        (
        CComponentObject *pObj, 
        LPWSTR pwszName,
        DWORD  cbName
        );
    
    // Add named object to the IUnkown * hash table
    HRESULT AddComponentToPtrHash(CComponentObject *pObj);

    // Find by name (for tagged)
    HRESULT FindComponentObjectByName
        (
        LPWSTR pwszName,
        DWORD  cbName,
        CComponentObject **ppObj
        );
        
    // Find by name (for properties)
    HRESULT FindComponentPropertyByName
        (
        LPWSTR pwszName, 
        DWORD  cbName,
        CComponentObject **ppObj
        );

    // Find by IUnknown*
    HRESULT FindComponentByIUnknownPtr
        (
        IUnknown *pUnk,
        CComponentObject **ppObj
        );

    // Fill in the arrays for access by index for the first time
    HRESULT StartUsingTaggedObjectsArray();
    HRESULT StartUsingPropertiesArray();

public:
    // Add various kinds of objects to the collection
    // They are also used by 
    //      CPageComponentManager AddScoped...()
    
    HRESULT AddTagged
        (
        LPWSTR pwszName, 
        const CLSID &clsid, 
        CompModel cmModel
        );
        
    HRESULT AddProperty
        (
        LPWSTR pwszName,
        VARIANT *pVariant,
        CComponentObject **ppObj = NULL
        );

    HRESULT AddUnnamed
        (
        const CLSID &clsid, 
        CompModel cmModel, 
        CComponentObject **ppObj
        );

    HRESULT GetTagged
        (
        LPWSTR pwszName,
        CComponentObject **ppObj
        );

    HRESULT GetProperty
        (
        LPWSTR pwszName,
        CComponentObject **ppObj
        );

    HRESULT GetNameByIndex
        (
        CompType ctType,
        int index,
        LPWSTR *ppwszName
        );

    HRESULT RemoveComponent(CComponentObject *pObj);
    
    HRESULT RemoveProperty(LPWSTR pwszName);
    
    HRESULT RemoveAllProperties();

    CComponentCollection();
    ~CComponentCollection();

    HRESULT Init(CompScope csScope, BOOL    fMTAConfigured);
    HRESULT UnInit();

    BOOL FHasStateInfo() const;    // TRUE when state-full
    BOOL FHasObjects() const;      // TRUE when contains objects

    DWORD GetPropertyCount() const;
    DWORD GetTaggedObjectCount() const;

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline BOOL CComponentCollection::FHasStateInfo() const
    {
    return ((m_cAllTagged + m_cProperties + m_cUnnamed) > 0);
    }

inline BOOL CComponentCollection::FHasObjects() const
    {
    return (m_cInstTagged > 0 || m_cUnnamed > 0 ||
            (m_cProperties > 0 && m_fHasComProperties));
    }

inline DWORD CComponentCollection::GetPropertyCount() const
    {
    return m_cProperties;
    }

inline DWORD CComponentCollection::GetTaggedObjectCount() const
    {
    return m_cAllTagged;
    }

inline HRESULT CComponentCollection::AddComponentToList
(
CComponentObject *pObj
)
    {
    pObj->m_pCompNext = m_pCompFirst;
    pObj->m_pCompPrev = NULL;
    if (m_pCompFirst)
        m_pCompFirst->m_pCompPrev = pObj;
    m_pCompFirst = pObj;
    return S_OK;
    }

inline HRESULT CComponentCollection::RemoveComponentFromList
(
CComponentObject *pObj
)
    {
    if (pObj->m_pCompPrev)
        pObj->m_pCompPrev->m_pCompNext = pObj->m_pCompNext;
    if (pObj->m_pCompNext)
        pObj->m_pCompNext->m_pCompPrev = pObj->m_pCompPrev;
    if (m_pCompFirst == pObj)
        m_pCompFirst = pObj->m_pCompNext;
    pObj->m_pCompPrev = pObj->m_pCompNext = NULL;
    return S_OK;
    }

/*===================================================================
  A page object controls calls to OnStartPage(), OnEndPage().
  Page objects are used by CPageComponentManager
  They are hashed using IDispatch * to avoid multiple OnStartPage()
  calls for the same object.
===================================================================*/
class CPageObject
    {

friend class CPageComponentManager;

private:
	IDispatch   *m_pDisp;		       // Dispatch interface pointer
	COnPageInfo  m_OnPageInfo;         // cached OnPageInfo

    DWORD        m_fStartPageCalled : 1;
    DWORD        m_fEndPageCalled : 1;
	
private: // the only access is using CPageComponentManager
    CPageObject();
    ~CPageObject();

    HRESULT	Init(IDispatch *pDisp, const COnPageInfo &OnPageInfo);

    // Invoke OnStartPage or OnEndPage
    HRESULT InvokeMethod
        (
        DWORD iMethod, 
        CScriptingContext *pContext, 
        CHitObj *pHitObj
        );
    HRESULT TryInvokeMethod     // used by InvokeMethod
        (                       // inside TRY CATCH
        DISPID     DispId,
        BOOL       fOnStart, 
        IDispatch *pDispContext,
        CHitObj   *pHitObj
        );

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };
    
/*===================================================================
  Page component manager provides access to component collections
  for page, session, application level.
  It is associated with a HitObj.

  It also takes care of covering (OnStartPage(), OnEndPage()).
===================================================================*/
class CPageComponentManager
    {
private:
    // hashtable of page objects hashed by IDispatch *
    CIdHashTable m_htidPageObjects;

    // hit object (this page)
    CHitObj *m_pHitObj;

    // hash table iterator callbacks
    static IteratorCallbackCode DeletePageObjectCB(void *pvObj, void *, void *);
    static IteratorCallbackCode OnEndPageObjectCB(void *pvObj, void *pvHitObj, void *pvhr);

private:
    // collections related to page, session and application
    HRESULT GetPageCollection(CComponentCollection **ppCollection);
    HRESULT GetSessionCollection(CComponentCollection **ppCollection);
    HRESULT GetApplnCollection(CComponentCollection **ppCollection);
    
    HRESULT GetCollectionByScope
        (
        CompScope csScope, 
        CComponentCollection **ppCollection
        );

    // find objectc in any of the related collections 
    // (internal private method)
    HRESULT FindScopedComponentByName
        (
        CompScope csScope, 
        LPWSTR pwszName,
        DWORD  cbName,
        BOOL fProperty,
        CComponentObject **ppObj, 
        CComponentCollection **ppCollection = NULL
        );

    static HRESULT __stdcall InstantiateObjectFromMTA
        (
        void *pvObj,
        void *pvHitObj
        );

public:
    CPageComponentManager();
    ~CPageComponentManager();

    HRESULT Init(CHitObj *pHitObj);
    
    // OnStartPage processing for an object that need it
    // (OnEndPage is done for all objects at the end of page)
    HRESULT OnStartPage
        (
        CComponentObject  *pCompObj,
        CScriptingContext *pContext,
        const COnPageInfo *pOnPageInfo,
        BOOL *pfStarted
        );

    // request OnEndPage() for all objects that need it
    // (OnStartPage() is done on demand on per-object basis)
    HRESULT OnEndPageAllObjects();

    // Add various kinds of objects. Objects get added to the
    // right collection depending on scope argument
    
    HRESULT AddScopedTagged
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        const CLSID &clsid,
        CompModel cmModel
        );
        
    HRESULT AddScopedProperty
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        VARIANT *pVariant,
        CComponentObject **ppObj = NULL
        );

    // Server.CreateObject
    HRESULT AddScopedUnnamedInstantiated
        (
        CompScope csScope, 
        const CLSID &clsid, 
        CompModel cmModel,
        COnPageInfo *pOnPageInfo,
        CComponentObject **ppObj
        );

    // Get component object (tagged) by name. 
    // Scope could be csUnknown
    HRESULT GetScopedObjectInstantiated
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        DWORD  cbName,
        CComponentObject **ppObj,
        BOOL *pfNewInstance
        );

    // Get component property by name. Scope could be csUnknown
    HRESULT GetScopedProperty
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        CComponentObject **ppObj
        );

    // Find component by IUnknown * (or IDispatch *).
    HRESULT FindAnyScopeComponentByIUnknown
        (
        IUnknown *pUnk, 
        CComponentObject **ppObj
        );
    HRESULT FindAnyScopeComponentByIDispatch
        (
        IDispatch *pDisp, 
        CComponentObject **ppObj
        );
    // The same - but static - gets context from Viper
    static HRESULT FindComponentWithoutContext
        (
        IDispatch *pDisp, 
        CComponentObject **ppObj
        );

    // Remove component -- the early release logic
    HRESULT RemoveComponent(CComponentObject *pObj);

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

// Component iterator is used to go through component names
// all the HitObj - reletated object across collections
// Needed for scripting

class CComponentIterator
    {
private:
    CHitObj *m_pHitObj;
    
    DWORD     m_fInited : 1;
    DWORD     m_fFinished : 1;
    
    CompScope m_csLastScope : 4;
    
    CComponentObject *m_pLastObj;

public:    
    CComponentIterator(CHitObj *pHitObj = NULL);
    ~CComponentIterator();

    HRESULT Init(CHitObj *pHitObj);
    LPWSTR  WStrNextComponentName();
    };

 // Variant Iterator is used to go through Property or Tagged object
 // names in a component collection. Needed for scripting

class CVariantsIterator : public IEnumVARIANT
	{
public:
	CVariantsIterator(CAppln *, DWORD);
	CVariantsIterator(CSession *, DWORD);
	~CVariantsIterator();

	HRESULT Init();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;							// reference count
	CComponentCollection 	*m_pCompColl;	// collection we are iterating over
	DWORD					m_dwIndex;		// current position for iteration
	CAppln					*m_pAppln;		// application (to clone iterator and Lock())
	CSession				*m_pSession;	// session (to clone iterator)
	DWORD					m_ctColType;	// type of collection
	
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

#endif // COMPCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\compcol.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Component Collection

File: Compcol.cpp

Owner: DmitryR

This is the Component Collection source file.

Component collection replaces:  (used in:)
COleVar, COleVarList            (HitObj, Session, Application)
CObjectCover                    (HitObj, Server, Session)
VariantLink HasTable            (Session, Application)
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Context.h"
#include "MTAcb.h"
#include "Request.h"
#include "Response.h"
#include "Server.h"
#include "tlbcache.h"
#include "memchk.h"

/*===================================================================
  Defines for hash table sizes
===================================================================*/

#define HT_TAGGED_OBJECTS_BUCKETS_MAX   19
#define HT_PROPERTIES_BUCKETS_MAX       17
#define HT_IUNKNOWN_PTRS_BUCKETS_MAX    23

#define HT_PAGE_OBJECTS_BUCKETS_MAX     17

/*===================================================================
  Static utility function prototypes
===================================================================*/

static HRESULT QueryOnPageInfo
    (
    IDispatch *pDisp,
    COnPageInfo *pOnPageInfo
    );

static HRESULT CLSIDToMultibyteString
    (
    CLSID ClsId,
    char *psz,
    int cch
    );

#define REG_MODEL_TEXT_LEN_MAX  20  // big enough for "Apartment"
static CompModel RegStrToCompModel
    (
    BYTE *pb,
    DWORD cb
    );

/*===================================================================
  Static utility functions code
===================================================================*/

/*===================================================================
QueryOnPageInfo

Query dispatch ids for OnStartPage and OnEndPage

Parameters:
    IDispatch   *pDisp              Object to query
    COnPageInfo *pOnPageInfo        Struct to fill in

Returns:
    HRESULT
===================================================================*/
HRESULT QueryOnPageInfo
(
IDispatch   *pDisp,
COnPageInfo *pOnPageInfo
)
    {
    static LPOLESTR BStrEntryPoints[ONPAGE_METHODS_MAX] =
        {
        L"OnStartPage",
        L"OnEndPage"
        };

    HRESULT hr = S_OK;
    for (int i = 0; i < ONPAGE_METHODS_MAX; i++)
        {
        hr = pDisp->GetIDsOfNames
            (
            IID_NULL,
            &BStrEntryPoints[i],
            1,
            LOCALE_SYSTEM_DEFAULT,
            &pOnPageInfo->m_rgDispIds[i]
            );
        if (FAILED(hr))
            {
            if (hr != DISP_E_UNKNOWNNAME &&
                hr != DISP_E_MEMBERNOTFOUND)
                {
                break;
                }

            // If UNKNOWNNAME, set dispid to DISPID_UNKNOWN
            hr = S_OK;
            pOnPageInfo->m_rgDispIds[i] = DISPID_UNKNOWN;
            }
        }
    return hr;
    }

/*===================================================================
CLSIDToMultibyteString

Converts CLSID into multibyte string
Used in CompModelFromCLSID

Parameters:
    CLSID  ClsId     (in) CLSID to convert
    char  *pb        put string into this buffer
    int    cch       of this length

Returns:
    HRESULT
===================================================================*/
HRESULT CLSIDToMultibyteString
(
CLSID  ClsId,
char  *psz,
int    cch
)
    {
    // First convert it to OLECHAR string
    OLECHAR *pszWideClassID = NULL; // temp wide string classid
    HRESULT hr = StringFromCLSID(ClsId, &pszWideClassID);
    if (FAILED(hr))
        return hr;

    // OLECHAR to MultiByte
    BOOL f = WideCharToMultiByte
        (
        CP_ACP,         // code page
        0,              // performance and mapping flags
        pszWideClassID, // address of wide-character string
        -1,             // length (-1 == null-terminated)
        psz,            // address of buffer for new string
        cch,            // size of buffer for new string
        NULL,           // address of default for unmappable
                        //      characters; quickest if null
        NULL            // address of flag set when default
                        //      char. used; quickest if null
        );
    if (f == FALSE)
        hr = E_FAIL;

    if (pszWideClassID)
        CoTaskMemFree(pszWideClassID);
    return hr;
    }

/*===================================================================
RegStrToCompModel

Get CompModel value from a registry string

Parameters:
    char  *pb        string as returned from registry
    int    cb        length returned from registry

Returns:
    HRESULT
===================================================================*/
CompModel RegStrToCompModel
(
BYTE *pb,
DWORD cb
)
    {
    CompModel cmModel = cmSingle; // assume single

    if (cb == 5)  // 5 include '\0'
        {
        if (!(_strnicmp((const char*)pb, "Both", cb)))
            cmModel = cmBoth;
        else if (!(_strnicmp((const char*)pb, "Free", cb)))
            cmModel = cmFree;
        }
    else if (cb == 10)  // 10 include '\0'
        {
        if (!(_strnicmp((const char*)pb, "Apartment", cb)))
            cmModel = cmApartment;
        }

    return cmModel;
    }

/*===================================================================
  Public utility functions code
===================================================================*/

/*===================================================================
CompModelFromCLSID

Get object's model and InProc flag by its CLSID from the registry

Parameters:
    CLSID     &ClsId       (in)
    CompModel *pcmModel    (out) Model (optional)
    BOOL      *pfInProc    (out) InProc flag (optional)

Returns:
    CompModel (cmFree, cmBoth, etc.)
===================================================================*/
HRESULT CompModelFromCLSID
(
const CLSID &ClsId,
CompModel   *pcmModel,
BOOL        *pfInProc
)
    {
    if (!Glob(fTrackThreadingModel) && !pfInProc)
        {
        // ignore registry value for threading model and
        // inproc flag is not requested -> take short return
        if (pcmModel)
            *pcmModel = cmUnknown;
        return S_OK;
        }

    // default returns
    CompModel cmModel  = cmSingle;   // assume single
    BOOL      fInProc  = TRUE;       // assume inproc

    HRESULT hr = S_OK;

    // Convert ClsId to multibyte string

    char szClassID[50];
    hr = CLSIDToMultibyteString(ClsId, szClassID, sizeof(szClassID));
    if (FAILED(hr))
        return hr;

    /*  query the registry; threading model is stored as:
        HKEY_CLASSES_ROOT
          key: CLSID
            key: <object's classid>
              key: InprocServer32
                name: ThreadingModel data: "Both" | "Apartment"
    */

    // Navigate the registry to "InprocServer32" key

    HKEY hKey1 = NULL;  // handle of open reg key
    HKEY hKey2 = NULL;  // handle of open reg key
    HKEY hKey3 = NULL;  // handle of open reg key

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            HKEY_CLASSES_ROOT,
            "CLSID",
            0,
            KEY_READ,
            &hKey1
            );
        if (nRet != ERROR_SUCCESS)
            hr = E_FAIL;
        }

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            hKey1,
            szClassID,
            0,
            KEY_READ,
            &hKey2
            );
        if (nRet != ERROR_SUCCESS)
            hr = E_FAIL;
        }

    // Get the stuff from the registry "InprocServer32" key

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            hKey2,
            "InprocServer32",
            0,
            KEY_READ,
            &hKey3
            );
        if (nRet == ERROR_SUCCESS)
            {
            DWORD cbData = REG_MODEL_TEXT_LEN_MAX;
            BYTE  szData[REG_MODEL_TEXT_LEN_MAX];

            nRet = RegQueryValueExA
                (
                hKey3,
                "ThreadingModel",
                NULL,
                NULL,
                szData,
                &cbData
                );
            if (nRet == ERROR_SUCCESS)
                cmModel = RegStrToCompModel(szData, cbData);

            if (cmModel == cmBoth)
                {
                // Some objects marked as "Both" ASP treats as
                // "Apartment". These objects should be marked in
                // the registry as "ASPComponentNonAgile"

                nRet = RegQueryValueExA
                    (
                    hKey3,
                    "ASPComponentNonAgile",
                    NULL,
                    NULL,
                    szData,
                    &cbData
                    );

                // If the key is found pretend it's "apartment"
                if (nRet == ERROR_SUCCESS)
                    cmModel = cmApartment;
                }
            }
        else
            {
            // if there is no InprocServer32 key,
            // then it must be a localserver or remote server.
            fInProc = FALSE;
            }
        }

    // clean up registry keys
    if (hKey3)
        RegCloseKey(hKey3);
    if (hKey2)
        RegCloseKey(hKey2);
    if (hKey1)
        RegCloseKey(hKey1);

    // return values
    if (pcmModel)
        *pcmModel = Glob(fTrackThreadingModel) ? cmModel : cmUnknown;
    if (pfInProc)
        *pfInProc = fInProc;

    return hr;
    }

/*===================================================================
FIsIntrinsic

Checks if the given IDispatch * points to an ASP intrinsic.

Parameters:
    pdisp       pointer to check

Returns:
    TRUE if Intrinsic
===================================================================*/
BOOL FIsIntrinsic
(
IDispatch *pdisp
)
    {
    if (!pdisp)
        return FALSE; // null dispatch pointer - not an intrinsic

    IUnknown *punk = NULL;
    if (FAILED(pdisp->QueryInterface(IID_IDenaliIntrinsic, (void **)&punk)))
        return FALSE;

    Assert(punk);
    punk->Release();
    return TRUE;
    }

/*===================================================================
FIsSimpleVariant

Checks if the given VARIANT is a simple one

Parameters:
    pvar       variant to check

Returns:
    TRUE if [for sure] simple, FALSE if [possibly] not
===================================================================*/
inline FIsSimpleVariant(VARIANT *pvar)
    {
    switch (V_VT(pvar))
        {
    case VT_BSTR:
    case VT_I2:
    case VT_I4:
    case VT_BOOL:
    case VT_DATE:
    case VT_R4:
    case VT_R8:
        return TRUE;
        }
    return FALSE;
    }


/*===================================================================
  C  C o m p o n e n t  O b j e c t
===================================================================*/

/*===================================================================
CComponentObject::CComponentObject

CComponentObject constructor

Parameters:
    CompScope scScope       Object scope
    CompType  ctType        Object type
    CompModel cmModel       Object threading model

Returns:
===================================================================*/
CComponentObject::CComponentObject
(
CompScope scScope,
CompType  ctType,
CompModel cmModel
)
    :
    m_csScope(scScope), m_ctType(ctType), m_cmModel(cmModel),
    m_fAgile(FALSE),
    m_fOnPageInfoCached(FALSE),
    m_fOnPageStarted(FALSE),
    m_fFailedToInstantiate(FALSE), m_fInstantiatedTagged(FALSE),
    m_fInPtrCache(FALSE),
    m_fVariant(FALSE),
    m_fNameAllocated(FALSE),
    m_dwGIPCookie(NULL_GIP_COOKIE),
    m_pDisp(NULL), m_pUnknown(NULL),
    m_pCompNext(NULL), m_pCompPrev(NULL),
    m_fMTAConfigured(FALSE)
    {
    }

#ifdef DBG
/*===================================================================
CComponentObject::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CComponentObject::AssertValid() const
    {
    Assert(m_ctType != ctUnknown);
    }
#endif

/*===================================================================
CComponentObject::~CComponentObject

CComponentObject destructor
Releases interface pointers

Parameters:

Returns:
===================================================================*/
CComponentObject::~CComponentObject()
    {
    // Release all interface pointers
    Clear();

    // Name used in hash (from CLinkElem)
    if (m_fNameAllocated)
        {
        Assert(m_pKey);
        free(m_pKey);
        }
    }

/*===================================================================
CComponentObject::Init

Initialize CLinkElem portion with the object name
Needed to implement string hash

Parameters:
    LPWSTR pwszName      object name
    DWORD  cbName        name length in bytes

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Init
(
LPWSTR  pwszName,
DWORD   cbName,
BOOL    fMTAConfigured
)
    {
    Assert(pwszName);
    Assert(*pwszName != L'\0');
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    m_fMTAConfigured = fMTAConfigured;

    // required buffer length
    DWORD cbBuffer = cbName + sizeof(WCHAR);
    WCHAR *pwszNameBuffer = (WCHAR *)m_rgbNameBuffer;

    if (cbBuffer > sizeof(m_rgbNameBuffer))
        {
        // the name doesn't fit into the member buffer -> allocate
        pwszNameBuffer = (WCHAR *)malloc(cbBuffer);
        if (!pwszNameBuffer)
            return E_OUTOFMEMORY;
        m_fNameAllocated = TRUE;
        }

    memcpy(pwszNameBuffer, pwszName, cbBuffer);

    // init link with name as the key (length excludes null term)
    return CLinkElem::Init(pwszNameBuffer, cbName);
    }

/*===================================================================
CComponentObject::ReleaseAll

Releases all interface pointers

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::ReleaseAll()
    {
    // Release all other present interface pointers
    if (m_pDisp)
        {
        m_pDisp->Release();
        m_pDisp = NULL;
        }
    if (m_pUnknown)
        {
        m_pUnknown->Release();
        m_pUnknown = NULL;
        }

    // Variant
    if (m_fVariant)
        {
        VariantClear(&m_Variant);
        m_fVariant = FALSE;
        }

    if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        g_GIPAPI.Revoke(m_dwGIPCookie);
        m_dwGIPCookie = NULL_GIP_COOKIE;
        }

    return S_OK;
    }

/*===================================================================
CComponentObject::Clear

Clears out data leaving link alone

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Clear()
    {
    // Release all pointers
    TRY
        ReleaseAll();
    CATCH(nExcept)
        Assert(FALSE);
        m_pDisp = NULL;
        m_pUnknown = NULL;
        m_fVariant = FALSE;
        m_dwGIPCookie = NULL_GIP_COOKIE;
    END_TRY

    // Invalidate cached OnPageInfo
    m_fOnPageInfoCached = FALSE;
    m_fOnPageStarted = FALSE;

    // Mark it as unknown
    m_csScope = csUnknown;
    m_ctType  = ctUnknown;
    m_cmModel = cmUnknown;
    m_fAgile = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentObject::Instantiate

Create object instance if it's not there already
Calls TryInstantiate() from within TRY CATCH

Parameters:
    CHitObj *pHitObj    Hit object for error reporting

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Instantiate
(
CHitObj *pHitObj
)
    {
    HRESULT hr = S_OK;

    if (Glob(fExceptionCatchEnable))
        {
        TRY
            hr = TryInstantiate(pHitObj);
        CATCH(nExcept)
            HandleErrorMissingFilename(IDE_SCRIPT_OBJ_INSTANTIATE_FAILED,
                                       pHitObj,
                                       TRUE,
                                       GetName(),
                                       nExcept);
            hr = nExcept;
        END_TRY
        }
    else
        {
        hr = TryInstantiate(pHitObj);
        }

    if (FAILED(hr))
        {
        // Something failed -- need to clean-up
        ReleaseAll();

        // mark as "failed to instantiate"
        m_fFailedToInstantiate = TRUE;
        }

    return hr;
    }

/*===================================================================
CComponentObject::TryInstantiate

Create object instance if it's not there already
Called by Instantiate() from within TRY CATCH

Parameters:
    CHitObj *pHitObj    Hit object for error reporting


Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::TryInstantiate
(
CHitObj *pHitObj
)
    {
    HRESULT     hr  =   S_OK;
    // Check if the object already exist
    if (m_pUnknown)
        return S_OK;

    if (m_fFailedToInstantiate)
        return E_FAIL;  // already tried once

    if (m_cmModel == cmUnknown && m_ClsId != CLSID_NULL)
        {
        CompModel cmModel;  // needed because m_cmModel is a bit fld
        hr = CompModelFromCLSID(m_ClsId, &cmModel);
		if (FAILED(hr))
			return hr;
        m_cmModel = cmModel;
        }

    hr = ViperCreateInstance
        (
        m_ClsId,
        IID_IUnknown,
        (void **)&m_pUnknown
        );

    // If we failed because we incorrectly cached the clsid
    // (could happen for tagged objects) try to get updated
    // cls id and retry
    if (m_ctType == ctTagged && FAILED(hr))
        {
        if (g_TypelibCache.UpdateMappedCLSID(&m_ClsId) == S_OK)
            {
            hr = ViperCreateInstance
                (
                m_ClsId,
                IID_IUnknown,
                (void **)&m_pUnknown
                );
            }
        }

    if (SUCCEEDED(hr))
        {
        if (Glob(fTrackThreadingModel) && m_cmModel == cmBoth)
            m_fAgile = TRUE;
        else
            m_fAgile = ViperCoObjectAggregatesFTM(m_pUnknown);

        hr = m_pUnknown->QueryInterface
            (
            IID_IDispatch,
            (void **)&m_pDisp
            );
        }

    // Check if application level object that
    // restricts threading -> use Global Interface Cookie

    if (SUCCEEDED(hr)
        && (m_csScope == csAppln || m_csScope == csSession)
        && !m_fMTAConfigured
        && !m_fAgile)
        {
        return ConvertToGIPCookie();
        }

    if (SUCCEEDED(hr) && !m_fOnPageInfoCached)
        {
        // don't really care if the following fails
        GetOnPageInfo();
        }

    return hr;
    }

/*===================================================================
CComponentObject::SetPropertyValue

Sets value from a Variant
Checks agility and possible deadlocks
Does GIP conversion

Parameters:
    VARIANT *pVariant       [in]  Value to set

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::SetPropertyValue
(
VARIANT *pVariant
)
    {
    Assert(m_ctType == ctProperty);

    HRESULT hr = S_OK;

    // Copy the variant value
    VariantInit(&m_Variant);
    m_fVariant = TRUE;

    hr = VariantCopyInd(&m_Variant, pVariant);
    if (FAILED(hr))
        return hr;

    // Get IDispatch pointer
    if (V_VT(&m_Variant) == VT_DISPATCH)
        {
        m_pDisp = V_DISPATCH(&m_Variant);
        }
    else
        {
        m_pDisp = NULL;
        }

    if (!m_pDisp)
        {
        m_fAgile = TRUE; // not VT_DISPATCH VARIANTs are agile
        return S_OK;
        }

    m_pDisp->AddRef();

    // Query (and cache) OnPageInfo inside TRY CATCH
    if (Glob(fExceptionCatchEnable))
        {
        TRY
            hr = GetOnPageInfo();
        CATCH(nExcept)
            hr = E_UNEXPECTED;
        END_TRY
        }
    else
        {
        hr = GetOnPageInfo();
        }

    // Don't really care if failed
    hr = S_OK;

    // Check if the assigned object is agile
    m_fAgile = ViperCoObjectAggregatesFTM(m_pDisp);

    if (Glob(fTrackThreadingModel) && !m_fAgile)
        {
        // doesn't mean it really isn't. could be one of
        // our objects marked as 'both'
        CComponentObject *pObjCopyOf = NULL;

        hr = CPageComponentManager::FindComponentWithoutContext
            (
            m_pDisp,
            &pObjCopyOf
            );

        if (hr == S_OK)
            {
            m_fAgile = pObjCopyOf->FAgile();
            }

        // end of getting of agile flag from the original object
        hr = S_OK; // even if object was not found
        }

    // Decide whether to use GIP and if invalid assignment
    // Applies only to non-agile application objects

    if (!m_fAgile && !m_fMTAConfigured && (m_csScope == csAppln || m_csScope == csSession))
        {
        if (!ViperCoObjectIsaProxy(m_pDisp) && (m_csScope == csAppln)) // deadlocking?
            {
            m_pDisp->Release();
            m_pDisp = NULL;
            VariantClear(&m_Variant);
            hr = RPC_E_WRONG_THREAD; // to tell the caller the error
            }
        else
            {
            // use GIP
            hr = ConvertToGIPCookie();
            }
        }

    return hr;
    }

/*===================================================================
CComponentObject::ConvertToGIPCookie

Convert Object to be GIP cookie. Release all pointers

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::ConvertToGIPCookie()
    {
    Assert(m_pDisp);  // has to have dispatch pointer

    DWORD dwCookie = NULL_GIP_COOKIE;
    HRESULT hr = g_GIPAPI.Register(m_pDisp, IID_IDispatch, &dwCookie);

    if (SUCCEEDED(hr))
        {
        Assert(dwCookie != NULL_GIP_COOKIE);

        // Release all pointeres
        ReleaseAll();

        // Store the cookie instead
        m_dwGIPCookie = dwCookie;
        }

    return hr;
    }

/*===================================================================
CComponentObject::GetOnPageInfo

Query dispatch ids for OnStartPage and OnEndPage
Calls static QueryOnPageInfo

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetOnPageInfo()
    {
    Assert(m_pDisp);

    HRESULT hr = QueryOnPageInfo(m_pDisp, &m_OnPageInfo);

    if (SUCCEEDED(hr))
        m_fOnPageInfoCached = TRUE;

    return hr;
    }

/*===================================================================
CComponentObject::GetAddRefdIDispatch

Get AddRef()'d Dispatch *
Handles the Global Interface Ole Cookies

Parameters:
    Dispatch **ppdisp    output

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetAddRefdIDispatch
(
IDispatch **ppdisp
)
    {
    Assert(ppdisp);

    if (m_pDisp)
        {
        *ppdisp = m_pDisp;
        (*ppdisp)->AddRef();
        return S_OK;
        }

    // try to restore from cookie
    if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        // Even if IUnknown * needs to be returned,
        // Ask for IDispatch *, because IDispatch * is the one
        // that was put in by CoGetInterfaceFromGlobal()

        HRESULT hr = g_GIPAPI.Get
            (
            m_dwGIPCookie,
            IID_IDispatch,
            (void **)ppdisp
            );

        if (SUCCEEDED(hr))
            return S_OK;
        }

    *ppdisp = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CComponentObject::GetAddRefdIUnknown

Get AddRef()'d IUnknown *
Handles the Global Interface Ole Cookies

Parameters:
    IUnknown **ppunk    output

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetAddRefdIUnknown
(
IUnknown **ppunk
)
    {
    Assert(ppunk);

    if (m_pUnknown)
        {
        *ppunk = m_pUnknown;
        (*ppunk)->AddRef();
        return S_OK;
        }

    // Use IDispatch (from cookie)

    IDispatch *pDisp = NULL;
    if (SUCCEEDED(GetAddRefdIDispatch(&pDisp)))
        {
        *ppunk = pDisp;  // IDispatch implements IUnknown
        return S_OK;
        }

    *ppunk = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CComponentObject::GetVariant

Get object's values as variant
Handles the Global Interface Ole Cookies

Parameters:
    VARIANT *pVar       [out]  Variant filled in with object value

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetVariant
(
VARIANT *pVar
)
    {
    HRESULT hr = S_OK;

    VariantInit(pVar); // default variant empty

    if (m_fVariant)
        {
        // already has variant
        hr = VariantCopyInd(pVar, &m_Variant);
        }
    else if (m_pDisp)
        {
        // create variant from IDispatch*
        m_pDisp->AddRef();

        V_VT(pVar) = VT_DISPATCH;
        V_DISPATCH(pVar) = m_pDisp;
        }
    else if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        // create variant from cookie
        IDispatch *pDisp = NULL;
        hr = g_GIPAPI.Get(m_dwGIPCookie, IID_IDispatch, (void **)&pDisp);

        if (SUCCEEDED(hr))
            {
            V_VT(pVar) = VT_DISPATCH;
            V_DISPATCH(pVar) = pDisp;
            }
        }
    else
        {
        // nowhere to get the VARIANT value from
        hr = E_POINTER;
        }

    return hr;
    }


/*===================================================================
  C  P a g e  O b j e c t
===================================================================*/

/*===================================================================
CPageObject::CPageObject

CPageObject constructor

Parameters:

Returns:
===================================================================*/
CPageObject::CPageObject()
    : m_pDisp(NULL),
      m_fStartPageCalled(FALSE), m_fEndPageCalled(FALSE)
    {
    }

#ifdef DBG
/*===================================================================
CPageObject::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CPageObject::AssertValid() const
    {
    Assert(m_pDisp);
    }
#endif

/*===================================================================
CPageObject::~CPageObject

CPageObject destructor

Parameters:

Returns:
===================================================================*/
CPageObject::~CPageObject()
    {
    // Release interface pointer
    if (m_pDisp)
        {
        m_pDisp->Release();
        m_pDisp = NULL;
        }
    }

/*===================================================================
CPageObject::Init

Initialize CLinkElem portion with the IDispatch pointer
Needed to implement string hash

Parameters:
    IDispatch   *pDisp          dispatch pointer (AddRef()ed)
    COnPageInfo *pOnPageInfo    OnStartPage, OnEndPage Ids

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::Init
(
IDispatch   *pDisp,
const COnPageInfo &OnPageInfo
)
    {
    Assert(pDisp);

    m_pDisp = pDisp;
    m_OnPageInfo = OnPageInfo;

    m_fStartPageCalled = FALSE;
    m_fEndPageCalled   = FALSE;

    return S_OK;
    }

/*===================================================================
CPageObject::InvokeMethod

Invokes OnPageStart() or OnPageEnd()

Parameters:
    DWORD iMethod                   which method
    CScriptingContext *pContext     scripting context (for OnStart)
    CHitObj *pHitObj                HitObj for errors

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::InvokeMethod
(
DWORD iMethod,
CScriptingContext *pContext,
CHitObj *pHitObj
)
    {
    BOOL fOnStart = (iMethod == ONPAGEINFO_ONSTARTPAGE);

    // check if method exists
    if (m_OnPageInfo.m_rgDispIds[iMethod] == DISPID_UNKNOWN)
        return S_OK;

    // two OnStart in a row - BAD
    Assert(!(fOnStart && m_fStartPageCalled));

    // two OnEnd in a row - BAD
    Assert(!(!fOnStart && m_fEndPageCalled));

    Assert(m_pDisp);

    HRESULT hr = S_OK;

    if (Glob(fExceptionCatchEnable))
        {
        // Call method inside TRY CATCH
        TRY
            hr = TryInvokeMethod
                (
                m_OnPageInfo.m_rgDispIds[iMethod],
                fOnStart,
                pContext,
                pHitObj
                );
        CATCH(nExcept)
            if (fOnStart)
                ExceptionId
                    (
                    IID_IObjectCover,
                    IDE_COVER,
                    IDE_COVER_ON_START_PAGE_GPF
                    );
            else
                HandleErrorMissingFilename
                    (
                    IDE_COVER_ON_END_PAGE_GPF,
                    pHitObj
                    );
            hr = E_UNEXPECTED;
        END_TRY
        }
    else
        {
        // don't CATCH
        hr = TryInvokeMethod
            (
            m_OnPageInfo.m_rgDispIds[iMethod],
            fOnStart,
            pContext,
            pHitObj
            );
        }

    if (fOnStart)
        m_fStartPageCalled = TRUE;
    else
        m_fEndPageCalled = TRUE;

    return hr;
    }

/*===================================================================
CPageObject::TryInvokeMethod

Invokes OnPageStart() or OnPageEnd()

Parameters:
    DISPID     DispId           method's DISPID
    BOOL       fOnStart         TRUE if invoking OnStart
    IDispatch *pDispContext     scripting context (for OnStart)
    CHitObj   *pHitObj          HitObj for errors

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::TryInvokeMethod
(
DISPID     DispId,
BOOL       fOnStart,
IDispatch *pDispContext,
CHitObj   *pHitObj
)
    {
    EXCEPINFO   ExcepInfo;
    DISPPARAMS  DispParams;
    VARIANT     varResult;
    VARIANT     varParam;
    UINT        nArgErr;

    memset(&DispParams, 0, sizeof(DISPPARAMS));
    memset(&ExcepInfo, 0, sizeof(EXCEPINFO));

    if (fOnStart)
        {
        VariantInit(&varParam);
        V_VT(&varParam) = VT_DISPATCH;
        V_DISPATCH(&varParam) = pDispContext;

        DispParams.rgvarg = &varParam;
        DispParams.cArgs = 1;
        }

    VariantInit(&varResult);

    // Invoke it

    HRESULT hr = m_pDisp->Invoke
        (
        DispId,          // Call method
        IID_NULL,        // REFIID - Reserved, must be NULL
        NULL,            // Locale id
        DISPATCH_METHOD, // Calling a method, not a property
        &DispParams,     // pass arguments
        &varResult,      // return value
        &ExcepInfo,      // exeption info on failure
        &nArgErr
        );

    // Ignore errors indicating that this method doesnt exist.
    if (FAILED(hr))
        {
        if (hr == E_NOINTERFACE         ||
            hr == DISP_E_MEMBERNOTFOUND ||
            hr == DISP_E_UNKNOWNNAME)
            {
            // the above errors really aren't
            hr = S_OK;
            }
        }

    /*
     * NOTE: The OnStartPage method is always called while the
     * script is running, so we use ExceptionId and let the
     * scripting engine report the error.  OnEndPage is always
     * called after the engine is gone, so we use HandleError.
     */
    if (FAILED(hr))
        {
        if (ExcepInfo.bstrSource && ExcepInfo.bstrDescription)
            {
            // User supplied error
            Exception
                (
                IID_IObjectCover,
                ExcepInfo.bstrSource,
                ExcepInfo.bstrDescription
                );
            }
        else if (fOnStart)
            {
            // Standard on-start error
            ExceptionId
                (
                IID_IObjectCover,
                IDE_COVER,
                IDE_COVER_ON_START_PAGE_FAILED,
                hr
                );
            }
        else
            {
            // Standard on-end error
            HandleErrorMissingFilename
                (
                IDE_COVER_ON_END_PAGE_FAILED,
                pHitObj
                );
            }
        }

    return hr;
    }

/*===================================================================
  C  C o m p o n e n t  C o l l e c t i o n
===================================================================*/

/*===================================================================
CComponentCollection::CComponentCollection

CComponentCollection constructor

Parameters:

Returns:
===================================================================*/
CComponentCollection::CComponentCollection()
    :
    m_csScope(csUnknown),
    m_fUseTaggedArray(FALSE), m_fUsePropArray(FALSE),
    m_fHasComProperties(FALSE),
    m_cAllTagged(0), m_cInstTagged(0),
    m_cProperties(0), m_cUnnamed(0),
    m_pCompFirst(NULL), m_fMTAConfigured(FALSE)
    {
    }

#ifdef DBG
/*===================================================================
CComponentCollection::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CComponentCollection::AssertValid() const
    {
    Assert(m_csScope != csUnknown);
    m_htTaggedObjects.AssertValid();
    m_htTaggedObjects.AssertValid();
    m_htidIUnknownPtrs.AssertValid();
    }
#endif

/*===================================================================
CComponentCollection::~CComponentCollection

CComponentCollection destructor
Deletes all the objects

Parameters:

Returns:
===================================================================*/
CComponentCollection::~CComponentCollection()
    {
    UnInit();
    }

/*===================================================================
CComponentCollection::Init

Sets collection scope
Initializes hash tables

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::Init
(
CompScope   scScope,
BOOL        fMTAConfigured
)
    {
    HRESULT hr = S_OK;

    m_csScope        = scScope;
    m_fMTAConfigured = fMTAConfigured;

    hr = m_htTaggedObjects.Init(HT_TAGGED_OBJECTS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    hr = m_htProperties.Init(HT_PROPERTIES_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    hr = m_htidIUnknownPtrs.Init(HT_IUNKNOWN_PTRS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    return S_OK;
    }

/*===================================================================
CComponentCollection::UnInit

Deletes all the objects

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CComponentCollection::UnInit()
    {
    // clear out pointer arrays
    m_rgpvTaggedObjects.Clear();
    m_rgpvProperties.Clear();
    m_fUseTaggedArray = FALSE;
    m_fUsePropArray = FALSE;

    // clear out name hash tables
    m_htTaggedObjects.UnInit();
    m_htProperties.UnInit();

    // clear out pointers hash table
    m_htidIUnknownPtrs.UnInit();

    // delete all member component objects
    if (m_pCompFirst)
        {
        CComponentObject *pObj = m_pCompFirst;
        while (pObj)
            {
            CComponentObject *pNext = pObj->m_pCompNext;
            delete pObj;
            pObj = pNext;
            }
        m_pCompFirst = NULL;
        }

    // reset the counters
    m_cAllTagged = 0;
    m_cInstTagged = 0;
    m_cProperties = 0;
    m_cUnnamed = 0;
    m_fHasComProperties = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentCollection::AddComponentToNameHash

Adds an object to the proper hash table

Parameters:
    CComponentObject *pObj      object to add
    LPWSTR            pwszName  object's name (hash)
    DWORD             cbName    name length in bytes

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddComponentToNameHash
(
CComponentObject *pObj,
LPWSTR            pwszName,
DWORD             cbName
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    // determine which hash table
    CHashTableStr *pHashTable;

    if (pObj->m_ctType == ctTagged)
        pHashTable = &m_htTaggedObjects;
    else if (pObj->m_ctType == ctProperty)
        pHashTable = &m_htProperties;
    else
        return S_OK; // nowhere to add, OK

    // Initialize object's CLinkElem
    HRESULT hr = pObj->Init(pwszName, cbName, m_fMTAConfigured);
    if (FAILED(hr))
        return hr;

    // Add to hash table
    CLinkElem *pAddedElem = pHashTable->AddElem(pObj);
    if (!pAddedElem)
        return E_FAIL;  // couldn't add

    if (pObj != static_cast<CComponentObject *>(pAddedElem))
        return E_FAIL;  // another object with the same name
                        // already there

    return S_OK;
    }

/*===================================================================
CComponentCollection::AddComponentToPtrHash

Adds an object to the IUnkown * hash table

Parameters:
    CComponentObject *pObj      object to add

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddComponentToPtrHash
(
CComponentObject *pObj
)
    {
    // If we don't track the threading model, we don't care
    // to add objects to cache by IUnknown * - no need to look them up
    if (!Glob(fTrackThreadingModel))
        return S_OK;

    void *ptr = pObj->m_pUnknown;
    if (!ptr)
        return S_OK; // uninstatiated

    if (FAILED(m_htidIUnknownPtrs.AddObject((DWORD_PTR)ptr, pObj)))
        return E_FAIL;

    pObj->m_fInPtrCache = TRUE;
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentObjectByName

Find tagged object by name

Parameters:
    LPWSTR             pwszName   object's name
    DWORD              cbName     name length
    CComponentObject **ppObj      found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CComponentCollection::FindComponentObjectByName
(
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    CLinkElem *pElem = m_htTaggedObjects.FindElem(pwszName, cbName);
    if (!pElem)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = static_cast<CComponentObject *>(pElem);
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentPropertyByName

Find property by name

Parameters:
    LPWSTR             pwszName   object's name
    DWORD              cbName     name length
    CComponentObject **ppObj      found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CComponentCollection::FindComponentPropertyByName
(
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    CLinkElem *pElem = m_htProperties.FindElem(pwszName, cbName);
    if (!pElem)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = static_cast<CComponentObject *>(pElem);
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentByIUnknownPtr

Find property by IUnknown *

Parameters:
    IUnknown          *pUnk    find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/

HRESULT CComponentCollection::FindComponentByIUnknownPtr
(
IUnknown *pUnk,
CComponentObject **ppObj
)
    {
    void *pv;
    if (m_htidIUnknownPtrs.FindObject((DWORD_PTR)pUnk, &pv) != S_OK)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = reinterpret_cast<CComponentObject *>(pv);
    return S_OK;
    }

/*===================================================================
CComponentCollection::AddTagged

Adds a tagged object to the collection. Does not instanciate it yet.

Parameters:
    LPWSTR     pwszName     Object name
    CLSID     &ClsId        Class ID
    CompModel  cmModel      Object model

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddTagged
(
LPWSTR    pwszName,
const CLSID &ClsId,
CompModel cmModel
)
    {
    HRESULT hr = S_OK;

    DWORD cbName = CbWStr(pwszName);    // do strlen once

    if (m_htTaggedObjects.FindElem(pwszName, cbName))
        return E_FAIL;  // duplicate name

    CComponentObject *pObj = new CComponentObject
        (
        m_csScope,
        ctTagged,
        cmModel
        );

    if (pObj == NULL)
        return E_OUTOFMEMORY;

    pObj->m_ClsId = ClsId;

    hr = AddComponentToList(pObj);
    if (FAILED(hr))
        return hr;

    hr = AddComponentToNameHash(pObj, pwszName, cbName);
    if (FAILED(hr))
        return hr;

    if (m_fUseTaggedArray)
        m_rgpvTaggedObjects.Append(pObj);

    m_cAllTagged++;
    return S_OK;
    }

/*===================================================================
CComponentCollection::AddProperty

Adds a property object to the collection.
If property with the same name exists, it changes the value

Parameters:
    LPWSTR             pwszName   Object name
    VARIANT            pVariant   Property value
    CComponentObject **ppObj      [out] Property object could
                                        be NULL if not requested

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddProperty
(
LPWSTR   pwszName,
VARIANT *pVariant,
CComponentObject **ppObj
)
    {
    if (ppObj)
        *ppObj = NULL;

    HRESULT hr = S_OK;

    CComponentObject *pObj = NULL;

    DWORD cbName = CbWStr(pwszName);    // do strlen once

    // Find the existing object first
    CLinkElem *pElem = m_htProperties.FindElem(pwszName, cbName);

    if (pElem)
        {
        // Object already exists - use it
        pObj = static_cast<CComponentObject *>(pElem);
        Assert(pObj->m_ctType == ctProperty);

        // Clear out the object from any data
        hr = pObj->Clear();
        if (FAILED(hr))
            return hr;

        // Reinitialize object
        pObj->m_csScope = m_csScope;
        pObj->m_ctType  = ctProperty;
        pObj->m_cmModel = cmUnknown;
        }
    else
        {
        // Create new object
        pObj = new CComponentObject(m_csScope, ctProperty, cmUnknown);
        if (pObj == NULL)
            return E_OUTOFMEMORY;

        // Add the object to the list
        hr = AddComponentToList(pObj);
        if (FAILED(hr))
            return hr;

        // Add the object to the hash
        hr = AddComponentToNameHash(pObj, pwszName, cbName);
        if (FAILED(hr))
            return hr;

        // Add to properties array if needed
        if (m_fUsePropArray)
            m_rgpvProperties.Append(pObj);

        m_cProperties++;
        }

    // Assign value
    hr = pObj->SetPropertyValue(pVariant);

    if (SUCCEEDED(hr))
        {
        // check if simple variant
        if (!FIsSimpleVariant(&pObj->m_Variant))
            m_fHasComProperties = TRUE;
        }

    // Return object ptr if requested
    if (SUCCEEDED(hr))
        {
        if (ppObj)
            *ppObj = pObj;
        }

    return hr;
    }

/*===================================================================
CComponentCollection::AddUnnamed

Add object to be instantiated using Server.CreateObject

Parameters:
    CLSID             &ClsId    Class ID
    CompModel          cmModel  Object model
    CComponentObject **ppObj    Object Added

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddUnnamed
(
const CLSID &ClsId,
CompModel cmModel,
CComponentObject **ppObj
)
    {
    HRESULT hr = S_OK;

    if (cmModel == cmUnknown)
        {
        hr = CompModelFromCLSID(ClsId, &cmModel);
        if (FAILED(hr))
            return hr;
        }

    CComponentObject *pObj = new CComponentObject
        (
        m_csScope,
        ctUnnamed,
        cmModel
        );

    if (pObj == NULL)
        return E_OUTOFMEMORY;

    pObj->m_ClsId = ClsId;

    hr = AddComponentToList(pObj);
    if (FAILED(hr))
        return hr;

    *ppObj = pObj;
    m_cUnnamed++;
    return S_OK;
    }

/*===================================================================
CComponentCollection::GetTagged

Finds tagged object by name

Parameters:
    LPWSTR   pwszName           Object name
    CComponentObject **ppObj    [out] Object Found

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetTagged
(
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentObjectByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj && pObj->m_ctType != ctTagged)
        pObj = NULL;

    if (pObj)
        *ppObj = pObj;
    else
        hr = TYPE_E_ELEMENTNOTFOUND;

    return hr;
    }

/*===================================================================
CComponentCollection::GetProperty

Finds property object by name

Parameters:
    LPWSTR   pwszName           Property name
    CComponentObject **ppObj    [out] Object Found

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetProperty
(
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentPropertyByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj)
        *ppObj = pObj;
    else
        hr = TYPE_E_ELEMENTNOTFOUND;

    return hr;
    }

/*===================================================================
CComponentCollection::GetNameByIndex

Find name of a tagged objects or property by index

Parameters:
    CompType ctType       tagged or property
    int      index        index (1-based)
    LPWSTR  *ppwszName    [out] name (NOT allocated)

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetNameByIndex
(
CompType ctType,
int index,
LPWSTR *ppwszName
)
    {
    CPtrArray *pPtrArray;

    if (ctType == ctTagged)
        {
        if (!m_fUseTaggedArray)
            StartUsingTaggedObjectsArray();
        pPtrArray = &m_rgpvTaggedObjects;
        }
    else if (ctType == ctProperty)
        {
        if (!m_fUsePropArray)
            StartUsingPropertiesArray();
        pPtrArray = &m_rgpvProperties;
        }
    else
        {
        Assert(FALSE);
        *ppwszName = NULL;
        return E_FAIL;
        }

    if (index >= 1 && index <= pPtrArray->Count())
        {
        CComponentObject *pObj = (CComponentObject *)pPtrArray->Get(index-1);
        if (pObj)
            {
            Assert(pObj->GetType() == ctType);
            *ppwszName = pObj->GetName();
            if (*ppwszName)
                return S_OK;
            }
        }

    *ppwszName = NULL;
    return E_FAIL;
    }

/*===================================================================
CComponentCollection::RemoveComponent

Remove a known component.
Slow method for a non-recent objects.

Parameters:
    CComponentObject *pObj      -- object to remove

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveComponent
(
CComponentObject *pObj
)
    {
    Assert(pObj);

    // Remove from by-name hash tables and arrays
    if (pObj->m_ctType == ctTagged)
        {
        // tagged cannot be removed
        Assert(FALSE);
        return E_FAIL;
        }
    else if (pObj->m_ctType == ctProperty)
        {
        // hash table
        if (m_htProperties.DeleteElem(pObj->GetName(), CbWStr(pObj->GetName())))
            {
            m_cProperties--;
            }

        // array
        if (m_fUsePropArray)
            {
            m_rgpvProperties.Remove(pObj);
            }
        }
    else
        {
        Assert(pObj->m_ctType == ctUnnamed);
        m_cUnnamed--;
        }

    // Remove from the 'by pointer hash table'
    if (pObj->m_fInPtrCache)
        {
        void *ptr = pObj->m_pUnknown;
        if (ptr)
            m_htidIUnknownPtrs.RemoveObject((DWORD_PTR)ptr);
        pObj->m_fInPtrCache = FALSE;
        }

    // Remove from the list
    RemoveComponentFromList(pObj);

    // Remove
    delete pObj;

    return S_OK;
    }

/*===================================================================
CComponentCollection::RemovePropery

Remove a property by name.

Parameters:
    LPWSTR pwszName -- property name

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveProperty
(
LPWSTR pwszName
)
    {
    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentPropertyByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj)
        hr = RemoveComponent(pObj);

    return hr;
    }

/*===================================================================
CComponentCollection::RemoveAllProperties

Remove all properties.  Faster than iterating.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveAllProperties()
    {
    // Clear out the properties array
    if (m_fUsePropArray)
        {
        m_rgpvProperties.Clear();
        m_fUsePropArray = FALSE;
        }

    // Walk the object list to remove properties
    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
    {
        CComponentObject *pNextObj = pObj->m_pCompNext;

        if (pObj->m_ctType == ctProperty)
            {
            // remove from the hash table
            m_htProperties.DeleteElem(pObj->GetName(), CbWStr(pObj->GetName()));
            // properties are not in the 'by pointer hash table'
            Assert(!pObj->m_fInPtrCache);
            // remove from the list
            RemoveComponentFromList(pObj);
            // remove
            delete pObj;
            }

        pObj = pNextObj;
    }

    m_cProperties = 0;
    m_fHasComProperties = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentCollection::StartUsingTaggedObjectsArray

Fill in the tagged objects array for access by index for the
first time

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::StartUsingTaggedObjectsArray()
    {
    if (m_fUseTaggedArray)
        return S_OK;

    m_rgpvTaggedObjects.Clear();

    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
        {
        if (pObj->GetType() == ctTagged)
            m_rgpvTaggedObjects.Append(pObj);
        pObj = pObj->m_pCompNext;
        }

    m_fUseTaggedArray = TRUE;
    return S_OK;
    }

/*===================================================================
CComponentCollection::StartUsingPropertiesArray

Fill in the properties array for access by index for the
first time

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::StartUsingPropertiesArray()
    {
    if (m_fUsePropArray)
        return S_OK;

    m_rgpvProperties.Clear();

    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
        {
        if (pObj->GetType() == ctProperty)
            m_rgpvProperties.Prepend(pObj); // backwards
        pObj = pObj->m_pCompNext;
        }

    m_fUsePropArray = TRUE;
    return S_OK;
    }


/*===================================================================
  C  P a g e  C o m p o n e n t  M a n a g e r
===================================================================*/

/*===================================================================
CPageComponentManager::CPageComponentManager

CPageComponentManager constructor

Parameters:

Returns:
===================================================================*/
CPageComponentManager::CPageComponentManager()
    : m_pHitObj(NULL)
    {
    }

#ifdef DBG
/*===================================================================
CPageComponentManager::AssertValid()

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CPageComponentManager::AssertValid() const
    {
    Assert(m_pHitObj);
    m_pHitObj->AssertValid();
    m_htidPageObjects.AssertValid();
    }
#endif

/*===================================================================
CPageComponentManager::~CPageComponentManager

CPageComponentManager destructor
Deletes all page objects

Parameters:

Returns:
===================================================================*/
CPageComponentManager::~CPageComponentManager()
    {
    // delete all page objects
    m_htidPageObjects.IterateObjects(DeletePageObjectCB);
    }

/*===================================================================
CPageComponentManager::DeletePageObjectCB

Static callback from hash table iterator to delete a CPageObject

Parameters:
    pvObj       CPageObject* to delete passed as void*

Returns:
    iccContinue
===================================================================*/
IteratorCallbackCode CPageComponentManager::DeletePageObjectCB
(
void *pvObj,
void *,
void *
)
    {
    Assert(pvObj);
    CPageObject *pObj = reinterpret_cast<CPageObject *>(pvObj);
    delete pObj;
    return iccContinue;
    }

/*===================================================================
CPageComponentManager::Init

Sets collection scope (to page)
Initializes hash tables

Parameters:
    CHitObj *pHitObj        this page

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::Init
(
CHitObj *pHitObj
)
    {
    HRESULT hr;

    // Init hash table of Page Objects
    hr = m_htidPageObjects.Init(HT_PAGE_OBJECTS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    // remember pHitObj
    m_pHitObj = pHitObj;

    return S_OK;
    }

/*===================================================================
CPageComponentManager::OnStartPage

Adds new page object. Ignores objects withount page info
(OnEndPage is done for all objects at the end of page)

Parameters:
    CComponentObject  *pCompObj     object to do OnStartPage
    CScriptingContext *pContext     arg to OnStart
    COnPageInfo *pOnPageInfo        pre-queried ids (optional)
    BOOL        *pfStarted          returned flag

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::OnStartPage
(
CComponentObject  *pCompObj,
CScriptingContext *pContext,
const COnPageInfo *pOnPageInfo,
BOOL              *pfStarted
)
    {
    IDispatch  *pDisp = pCompObj->m_pDisp;
    HRESULT hr = S_OK;

    if(pDisp == NULL)
        {
        Assert(pCompObj->m_dwGIPCookie != NULL_GIP_COOKIE);
        // try to restore from cookie
        hr = g_GIPAPI.Get
            (
            pCompObj->m_dwGIPCookie,
            IID_IDispatch,
            (void **)&pDisp
            );

        if (FAILED(hr))
            return hr;
        }
	else
		pDisp->AddRef();

    Assert(pDisp);

    Assert(pfStarted);
    *pfStarted = FALSE;

    // check if onpageinfo passed and the methods aren't defined
    if (pOnPageInfo && !pOnPageInfo->FHasAnyMethod())
		{
		pDisp->Release();
        return S_OK;
		}

    // check if already in the PageObject Hash
    if (m_htidPageObjects.FindObject((DWORD_PTR)pDisp) == S_OK)
        {
		pDisp->Release();
        return S_OK;
        }

    COnPageInfo OnPageInfo;

    if (pOnPageInfo)
        {
        OnPageInfo = *pOnPageInfo;
        }
    else
        {
        // dynamically create OnPageInfo if not passed
        if (Glob(fExceptionCatchEnable))
            {
            TRY
                hr = QueryOnPageInfo(pDisp, &OnPageInfo);
            CATCH(nExcept)
                HandleErrorMissingFilename(IDE_SCRIPT_OBJ_ONPAGE_QI_FAILED,
                                           m_pHitObj,
                                           TRUE,
                                           pCompObj->GetName(),
                                           nExcept);
                hr = nExcept;
            END_TRY
            }
        else
            {
            hr = QueryOnPageInfo(pDisp, &OnPageInfo);
            }

        if (FAILED(hr))
            {
			pDisp->Release();
            return hr;
            }

        // check if any of the methods is defined
        if (!OnPageInfo.FHasAnyMethod())
            {
			pDisp->Release();
            return S_OK;
            }
        }

    // create object
    CPageObject *pPageObj = new CPageObject;
    if (!pPageObj)
        {
		pDisp->Release();
        return E_OUTOFMEMORY;
        }

    // init LinkElem
    hr = pPageObj->Init(pDisp, OnPageInfo);   // this eats our previous AddRef()
    if (SUCCEEDED(hr))
        {
        // add to hash table
        hr = m_htidPageObjects.AddObject((DWORD_PTR)pDisp, pPageObj);
        }

    // cleanup if failed
    if (FAILED(hr) && pPageObj)
        {
        pDisp->Release();   // Init failed, so remove our AddRef()
        delete pPageObj;
        return hr;
        }

    *pfStarted = TRUE;

    return pPageObj->InvokeMethod
        (
        ONPAGEINFO_ONSTARTPAGE,
        pContext,
        m_pHitObj
        );
    }

/*===================================================================
PageComponentManager::OnEndPageAllObjects

Does OnEndPage() for all objects that need it
(OnStartPage() is on demand basis)

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::OnEndPageAllObjects()
    {
    HRESULT hrGlobal = S_OK;

    m_htidPageObjects.IterateObjects
        (
        OnEndPageObjectCB,
        m_pHitObj,
        &hrGlobal
        );

    return hrGlobal;
    }

/*===================================================================
CPageComponentManager::OnEndPageObjectCB

Static callback from hash table iterator to execute OnEndPage
for a CPageObject

Parameters:
    pvObj       CPageObject* to delete passed as void*

Returns:
    iccContinue
===================================================================*/
IteratorCallbackCode CPageComponentManager::OnEndPageObjectCB
(
void *pvObj,
void *pvHitObj,
void *pvhr
)
    {
    Assert(pvObj);
    Assert(pvHitObj);
    Assert(pvhr);

    CPageObject *pObj = reinterpret_cast<CPageObject *>(pvObj);

    HRESULT hr = pObj->InvokeMethod
        (
        ONPAGEINFO_ONENDPAGE,
        NULL,
        reinterpret_cast<CHitObj *>(pvHitObj)
        );

    if (FAILED(hr))
        *(reinterpret_cast<HRESULT *>(pvhr)) = hr;

    return iccContinue;
    }

/*===================================================================
CPageComponentManager::GetPageCollection

Queries HitObj for the Page's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetPageCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetPageComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetSessionCollection

Queries HitObj for the Session's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetSessionCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetSessionComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetApplnCollection

Queries HitObj for the Application's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetApplnCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetApplnComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetCollectionByScope

Gets the collection corresponding to the scope

Parameters:
    CompScope              csScope      (in) desired scope
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetCollectionByScope
(
CompScope scScope,
CComponentCollection **ppCollection
)
    {
    HRESULT hr = S_OK;

    switch (scScope)
        {
        case csPage:
            hr = GetPageCollection(ppCollection);
            break;
        case csSession:
            hr = GetSessionCollection(ppCollection);
            break;
        case csAppln:
            hr = GetApplnCollection(ppCollection);
            break;
        default:
            hr = E_UNEXPECTED;
            break;
        }

    if (FAILED(hr))
        *ppCollection = NULL;
    else if (*ppCollection == NULL)
        hr = E_POINTER; // to make sure we fail if no collection
    return hr;
    }

/*===================================================================
CPageComponentManager::FindScopedComponentByName

Finds object by name. Searches multiple collections if
the scope is unknown.
Internal private method used in GetScoped...()

Parameters:
    CompScope             csScope       Scope (could be csUnknown)
    LPWSTR                pwszName      Object name
    DWORD                 cbName        name length
    BOOL                  fProperty     TRUE = property,
                                        FALSE = tagged

    CComponentObject     **ppObj        (out) Object found
    CComponentCollection **ppCollection (out) Collection where found
                                              (optional)

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindScopedComponentByName
(
CompScope csScope,
LPWSTR pwszName,
DWORD  cbName,
BOOL   fProperty,
CComponentObject **ppObj,
CComponentCollection **ppCollection
)
    {
    int cMaxTry = (csScope == csUnknown) ? 3 : 1;
    int cTry = 0;
    *ppObj = NULL;

    while (*ppObj == NULL && cTry < cMaxTry)
        {
        HRESULT hr = S_OK;
        CComponentCollection *pCollection = NULL;

        switch (++cTry)
            {
            case 1: // page (or explicit scope) first
                if (csScope == csUnknown)
                    hr = GetPageCollection(&pCollection);
                else  // explicit scope
                    hr = GetCollectionByScope(csScope, &pCollection);
                break;
            case 2: // session
                hr = GetSessionCollection(&pCollection);
                break;
            case 3: // application
                hr = GetApplnCollection(&pCollection);
                break;
            }
        if (FAILED(hr) || !pCollection)
            continue;   // couldn't get the collection

        Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

        // find the object
        if (fProperty)
            {
            hr = pCollection->FindComponentPropertyByName
                (
                pwszName,
                cbName,
                ppObj
                );
            }
        else
            {
            hr = pCollection->FindComponentObjectByName
                (
                pwszName,
                cbName,
                ppObj
                );
            }

        if (hr != S_OK)
            *ppObj = NULL;

        // remember where found
        if (*ppObj && ppCollection)
            *ppCollection = pCollection;
        }

    return (*ppObj ? S_OK : S_FALSE);
    }

/*===================================================================
CPageComponentManager::AddScopedTagged

Adds a tagged object to the collection. Does not instantiate it yet.

Parameters:
    CompScope csScope      Object scope (which collection)
    LPWSTR    pwszName     Object name
    CLSID    &ClsId        Class ID
    CompModel cmModel      Object model

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedTagged
(
CompScope csScope,
LPWSTR    pwszName,
const CLSID &ClsId,
CompModel cmModel
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        return hr;
    return pCollection->AddTagged(pwszName, ClsId, cmModel);
    }

/*===================================================================
CPageComponentManager::AddScopedProperty

Adds a property object to the collection.
If property with the same name exists, it changes the value

Parameters:
    CompScope          csScope    Object scope (which collection)
    LPWSTR             pwszName   Object name
    VARIANT            pVariant   Property value
    CComponentObject **ppObj      [out] Property object could
                                        be NULL if not requested

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedProperty
(
CompScope csScope,
LPWSTR pwszName,
VARIANT *pVariant,
CComponentObject **ppObj
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        {
        if (ppObj)
            *ppObj = NULL;
        return hr;
        }
    return pCollection->AddProperty(pwszName, pVariant, ppObj);
    }

/*===================================================================
CPageComponentManager::AddScopedUnnamedInstantiated

Server.CreateObject
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    csScope     Object scope (which collection)
    ClsId       Class ID
    cmModel     Object model
    pOnPageInfo DispIds for OnStartPage/OnEndPage (can be NULL)
    ppObj       [out] Object Added

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedUnnamedInstantiated
(
CompScope csScope,
const CLSID &ClsId,
CompModel cmModel,
COnPageInfo *pOnPageInfo,
CComponentObject **ppObj
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        return hr;
    hr = pCollection->AddUnnamed(ClsId, cmModel, ppObj);
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;

    // remember passed OnPageInfo
    if (pOnPageInfo)
        {
        pObj->m_OnPageInfo = *pOnPageInfo;
        pObj->m_fOnPageInfoCached = TRUE;
        }

    // create it
    hr = pObj->Instantiate(m_pHitObj);
    if (FAILED(hr))
        return hr;

    // add to pointer cash
    pCollection->AddComponentToPtrHash(pObj);

    // add as page object when needed
    if (csScope == csPage
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted = FALSE;

        hr = OnStartPage
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );

        if (fStarted)
            pObj->m_fOnPageStarted = TRUE;
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::GetScopedObjectInstantiated

Finds component object (tagged) by name.
Scope could be csUnknown.
Instantiates tagged objects.
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    CompScope          csScope        Scope (could be csUnknown)
    LPWSTR             pwszName       Object name
    DWORD              cbName         Object name length (in bytes)
    CComponentObject **ppObj          Object found
    BOOL              *pfNewInstance  [out] TRUE if just instantiated

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetScopedObjectInstantiated
(
CompScope csScope,
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj,
BOOL *pfNewInstance
)
    {
    HRESULT hr;

    Assert(pfNewInstance);
    *pfNewInstance = FALSE;

    CComponentCollection *pCollection;
    hr = FindScopedComponentByName
        (
        csScope,
        pwszName,
        cbName,
        FALSE,
        ppObj,
        &pCollection
        );
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;
    if (!pObj)   // not failed, but not found either
        return TYPE_E_ELEMENTNOTFOUND;

    if (pObj->m_ctType != ctTagged)
        return S_OK;

    // For tagged only - instantiate and do OnStartPage()

    // For application level objects instantiation must be
    // done within critical section

    BOOL fApplnLocked = FALSE;

    Assert(m_pHitObj);

    if (!pObj->m_fInstantiatedTagged &&          // uninstantiated
        pObj->m_csScope == csAppln   &&          // application scope
        m_pHitObj->PAppln()->FFirstRequestRun()) // after GLOBAL.ASA
        {
        // Lock
        m_pHitObj->PAppln()->Lock();

        // check if the object is still uninstantiated
        if (!pObj->m_fInstantiatedTagged)
            {
            // yes, still uninstantiated - keep the lock
            fApplnLocked = TRUE;
            }
        else
            {
            // object instantiated while we waited - don't keep lock
            m_pHitObj->PAppln()->UnLock();
            }
        }

    // Instantiate tagged if needed
    if (!pObj->m_fInstantiatedTagged)
        {
        if ((pObj->m_csScope == csAppln) && !pObj->m_fMTAConfigured)
            {
            // For applicatin scoped objects, instantiate from MTA if we're not
            // already executing on the MTA.
            hr = CallMTACallback
                (
                CPageComponentManager::InstantiateObjectFromMTA,
                pObj,
                m_pHitObj
                );
            }
        else
            {
            hr = pObj->Instantiate(m_pHitObj);
            }

        if (SUCCEEDED(hr))
            {
            // keep count
            pCollection->m_cInstTagged++;
            // add to pointer cash
            pCollection->AddComponentToPtrHash(pObj);
            // return flag
            *pfNewInstance = TRUE;
            }

        // Flag as instantiated even if failed
        pObj->m_fInstantiatedTagged = TRUE;
        }

    // Remove the lock kept while instantiating appln level object
    if (fApplnLocked)
        m_pHitObj->PAppln()->UnLock();

    // Return if [instantiation] failed
    if (FAILED(hr))
        {
        *ppObj = NULL;
        return hr;
        }

    // Add as page object when needed
    if (pObj->m_csScope != csAppln
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted;
        OnStartPage     // don't care if failed
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::InstantiateObjectFromMTA

Static callback called by CallMTACallback() to
instantiate aplication scoped objects

Parameters:
    void *pvObj       ComponentObject
    void *pvHitObj    HitObj

Returns:
    HRESULT
===================================================================*/
HRESULT __stdcall CPageComponentManager::InstantiateObjectFromMTA
(
void *pvObj,
void *pvHitObj
)
    {
    Assert(pvHitObj);
    Assert(pvObj);

    CHitObj *pHitObj = (CHitObj *)pvHitObj;
    CComponentObject *pObj = (CComponentObject *)pvObj;

    return pObj->Instantiate(pHitObj);
    }

/*===================================================================
CPageComponentManager::GetScopedProperty

Find property component by name.
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    CompScope          csScope      Scope (could not be csUnknown)
    LPWSTR             pwszName     Object name
    CComponentObject **ppObj        Object found

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetScopedProperty
(
CompScope csScope,
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    HRESULT hr;

    hr = FindScopedComponentByName
        (
        csScope,
        pwszName,
        CbWStr(pwszName),
        TRUE,
        ppObj
        );
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;
    if (!pObj)   // not failed, but not found either
        return TYPE_E_ELEMENTNOTFOUND;

    // Add as page object if IDispatch * is there
    // as VT_DISPATCH property
    if (pObj->m_csScope != csAppln
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted;
        hr = OnStartPage
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::FindAnyScopeComponentByIUnknown

Find component by its IUnknown *.

Parameters:
    IUnknown          *pUnk    find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindAnyScopeComponentByIUnknown
(
IUnknown *pUnk,
CComponentObject **ppObj
)
    {
    int cTry = 0;
    *ppObj = NULL;

    while (*ppObj == NULL && cTry < 3)
        {
        HRESULT hr = S_OK;
        CComponentCollection *pCollection = NULL;

        switch (++cTry)
            {
            case 1: // page first
                hr = GetPageCollection(&pCollection);
                break;
            case 2: // session
                hr = GetSessionCollection(&pCollection);
                break;
            case 3: // application
                hr = GetApplnCollection(&pCollection);
                break;
            }
        if (FAILED(hr) || !pCollection)
            continue;   // couldn't get the collection

        // find the object
        hr = pCollection->FindComponentByIUnknownPtr(pUnk, ppObj);
        if (hr != S_OK)
            *ppObj = NULL;
        }

    return (*ppObj ? S_OK : S_FALSE);
    }

/*===================================================================
CPageComponentManager::FindAnyScopeComponentByIDispatch

Find component by its IDispatch *.
Uses FindAnyScopeComponentByIUnknown.

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindAnyScopeComponentByIDispatch
(
IDispatch *pDisp,
CComponentObject **ppObj
)
    {
    IUnknown *pUnk = NULL;
    HRESULT hr = pDisp->QueryInterface(IID_IUnknown, (void **)&pUnk);

    if (SUCCEEDED(hr) && !pUnk)
        hr = E_FAIL;

    if (FAILED(hr))
        {
        *ppObj = NULL;
        return hr;
        }

    return FindAnyScopeComponentByIUnknown(pUnk, ppObj);
    }

/*===================================================================
CPageComponentManager::FindComponentWithoutContext

The same as FindAnyScopeComponentByIDispatch -
    but static - gets context from Viper

Uses FindAnyScopeComponentByIUnknown.

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindComponentWithoutContext
(
IDispatch *pDisp,
CComponentObject **ppObj
)
    {
    // Get HitObj from Viper Context
    CHitObj *pHitObj = NULL;
    ViperGetHitObjFromContext(&pHitObj);
    if (!pHitObj)
        return E_FAIL;

    // Get page component manager
    CPageComponentManager *pPCM = pHitObj->PPageComponentManager();
    if (!pPCM)
        return E_FAIL;

    // Call the page component manager to find the object
    return pPCM->FindAnyScopeComponentByIUnknown(pDisp, ppObj);
    }

/*===================================================================
CPageComponentManager::RemoveComponent

Remove component -- the early release logic

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
===================================================================*/
 HRESULT CPageComponentManager::RemoveComponent
 (
 CComponentObject *pObj
 )
    {
    Assert(pObj);

    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(pObj->m_csScope, &pCollection);
    if (FAILED(hr))
        return hr;

    return pCollection->RemoveComponent(pObj);
    }

/*===================================================================
  C  C o m p o n e n t  I t e r a t o r
===================================================================*/

/*===================================================================
CComponentIterator::CComponentIterator

CComponentIterator constructor

Parameters:
    CHitObj *pHitObj    page to init with (optional)

Returns:
===================================================================*/
CComponentIterator::CComponentIterator(CHitObj *pHitObj)
    : m_fInited(FALSE), m_fFinished(FALSE), m_pHitObj(NULL),
      m_pLastObj(NULL), m_csLastScope(csUnknown)
    {
    if (pHitObj)
        Init(pHitObj);
    }

/*===================================================================
CComponentIterator::~CComponentIterator

CComponentIterator destructor

Parameters:

Returns:
===================================================================*/
CComponentIterator::~CComponentIterator()
    {
    }

/*===================================================================
CComponentIterator::Init

Start iterating

Parameters:
    CHitObj *pHitObj    page

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentIterator::Init
(
CHitObj *pHitObj
)
    {
    Assert(pHitObj);
    pHitObj->AssertValid();

    m_pHitObj = pHitObj;
    m_fInited = TRUE;
    m_fFinished = FALSE;

    m_pLastObj = NULL;
    m_csLastScope = csUnknown;

    return S_OK;
    }

/*===================================================================
CComponentIterator::WStrNextComponentName

The iteration function

Parameters:

Returns:
    Next component name or NULL if done
===================================================================*/
LPWSTR CComponentIterator::WStrNextComponentName()
    {
    Assert(m_fInited);

    if (m_fFinished)
        return NULL;

    Assert(m_pHitObj);

    CompScope csScope = m_csLastScope;
    CComponentObject *pObj = m_pLastObj ?
        static_cast<CComponentObject *>(m_pLastObj->m_pNext) : NULL;

    while (!m_fFinished)
        {
        // try the current scope

        if (pObj)
            {
            Assert(pObj->m_ctType == ctTagged);
            Assert(pObj->GetName());

            m_pLastObj = pObj;
            m_csLastScope = csScope;
            return pObj->GetName();
            }

        // couldn't find in the current scope - try next scope
        CComponentCollection *pCol = NULL;

        switch (csScope)
            {
            case csUnknown:
                csScope = csPage;
                m_pHitObj->GetPageComponentCollection(&pCol);
                break;
            case csPage:
                csScope = csSession;
                m_pHitObj->GetSessionComponentCollection(&pCol);
                break;
            case csSession:
                csScope = csAppln;
                m_pHitObj->GetApplnComponentCollection(&pCol);
                break;
            case csAppln:
            default:
                csScope = csUnknown;
                m_fFinished = TRUE;
                break;
            }

        // start at the beginning of the new collection

        if (pCol)
            pObj = static_cast<CComponentObject *>(pCol->m_htTaggedObjects.Head());
        }

    // finished
    return NULL;
    }

/*===================================================================
  C  V a r i a n t s I t e r a t o r
===================================================================*/

/*===================================================================
CVariantsIterator::CVariantsIterator

CVariantsIterator constructor by application

Parameters:
    CAppln  *pAppln       collection to init with
    DWORD    ctCollType   type of components to list iteration

Returns:
===================================================================*/
CVariantsIterator::CVariantsIterator
(
CAppln *pAppln,
DWORD ctColType
)
    : m_pCompColl(NULL), m_pAppln(NULL), m_pSession(NULL)
    {
    Assert(pAppln);
    pAppln->AddRef();

    m_cRefs = 1;
    m_pCompColl = pAppln->PCompCol();
    m_pAppln = pAppln;
    m_ctColType = ctColType;
    m_dwIndex = 0;
    }

/*===================================================================
CVariantsIterator::CVariantsIterator

CVariantsIterator constructor by session

Parameters:
    CSession *pSession        collection to init with
    DWORD     ctCollType      type of components to list iteration

Returns:
===================================================================*/
CVariantsIterator::CVariantsIterator
(
CSession *pSession,
DWORD ctColType
)
    : m_pCompColl(NULL), m_pAppln(NULL), m_pSession(NULL)
    {
    Assert(pSession);
    pSession->AddRef();

    m_cRefs = 1;
    m_pCompColl = pSession->PCompCol();
    m_ctColType = ctColType;
    m_pSession = pSession;
    m_dwIndex = 0;
    }

/*===================================================================
CVariantsIterator::~CVariantsIterator

CVariantsIterator destructor

Parameters:

Returns:
===================================================================*/
CVariantsIterator::~CVariantsIterator()
    {
    if (m_pSession)
        m_pSession->Release();
    if (m_pAppln)
        m_pAppln->Release();
    }

/*===================================================================
CVariantsIterator::QueryInterface

CVariantsIterator QI

Parameters:
    GUID&    iid
    VOID **  ppvObj

Returns: HRESULT
===================================================================*/
STDMETHODIMP CVariantsIterator::QueryInterface
(
const GUID &iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CVariantsIterator::AddRef

CVariantsIterator AddRef

Parameters:

Returns: ULONG
===================================================================*/
STDMETHODIMP_(ULONG) CVariantsIterator::AddRef()
    {
    return ++m_cRefs;
    }

/*===================================================================
CVariantsIterator::Release

CVariantsIterator Release

Parameters:

Returns:
===================================================================*/
STDMETHODIMP_(ULONG) CVariantsIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CVariantsIterator::Clone

CVariantsIterator Clone

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Clone
(
IEnumVARIANT **ppEnumReturn
)
    {
    CVariantsIterator *pNewIterator = NULL;
    if (m_pSession)
        {
        pNewIterator = new CVariantsIterator(m_pSession, m_ctColType);
        }
    else if (m_pAppln)
        {
        pNewIterator = new CVariantsIterator(m_pAppln, m_ctColType);
        }
    else
        {
        Assert(FALSE);  // better be either Appln or Session
        return E_FAIL;
        }

    if (pNewIterator == NULL)
        return E_OUTOFMEMORY;

    // new iterator should point to same location as this.
    pNewIterator->m_dwIndex = m_dwIndex;

    *ppEnumReturn = pNewIterator;
    return S_OK;
    }

/*===================================================================
CVariantsIterator::Next

CVariantsIterator Next

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Next
(
unsigned long cElementsRequested,
VARIANT *rgVariant,
unsigned long *pcElementsFetched
)
    {
    // give a valid pointer value to 'pcElementsFetched'
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    if (cElementsRequested == 0)
        {
        if (pcElementsFetched)
            *pcElementsFetched = 0;
        return S_OK;
        }

    DWORD cMax = 0;
    if (m_ctColType == ctTagged)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cAllTagged : 0;
        }
    else if (m_ctColType == ctProperty)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cProperties : 0;
        }
    else
        {
        // Should always be either tagged object or property
        Assert(FALSE);
        return E_FAIL;
        }

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && m_dwIndex < cMax)
        {
        LPWSTR pwszName = NULL;

        if (m_pAppln) 
            m_pAppln->Lock();

        m_pCompColl->GetNameByIndex(m_ctColType, ++m_dwIndex, &pwszName);

        if (!pwszName) {
            if (m_pAppln)
                m_pAppln->UnLock();
            continue;
        }

        BSTR bstrT = SysAllocString(pwszName);

        if (m_pAppln)
            m_pAppln->UnLock();

        if (!bstrT)
            return E_OUTOFMEMORY;

        V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;
		++rgVariant;

        --cElements;
        ++(*pcElementsFetched);
        }

    // initialize the remaining variants
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }

/*===================================================================
CVariantsIterator::Skip

CVariantsIterator Skip

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Skip
(
unsigned long cElements
)
    {
    /* Adjust the index by cElements or
     * until we hit the max element
     */
    DWORD cMax = 0;

    // We iterate over different arrays depending on the collection type
    if (m_ctColType == ctTagged)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cAllTagged : 0;
        }
    else if (m_ctColType == ctProperty)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cProperties : 0;
        }
    else
        {
        // Should always be either tagged object or property
        Assert(FALSE);
        return E_FAIL;
        }

	m_dwIndex += cElements;
    return (m_dwIndex < cMax)? S_OK : S_FALSE;
    }

/*===================================================================
CVariantsIterator::Reset

CVariantsIterator Reset

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Reset()
    {
    m_dwIndex = 0;
    return NO_ERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\connpt.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: IConnectionPoint implementation

File: ConnPt.h

Owner: DGottner

Implementation of IConnectionPoint
===================================================================*/

#ifndef _ConnPt_H
#define _ConnPt_H

/*
 * C C o n n e c t i o n P o i n t
 *
 * IConnectionPoint interface implementation for OLE objects
 *
 * This class contains the basic five IConnectionPoint members.  The Big Three
 * (QueryInterface, AddRef, Release) are left as pure virtual, as this
 * class is designed as an intermediate class for further derivation.
 *
 * This also means that we no longer need a pointer to the controlling unknown.
 */

#include "DblLink.h"


/*	****************************************************************************
	Class:		CConnectionPoint
	Synopsis:	Provide a reusable implementation of IConnectionPoint

    NOTE: Linked list of sinks is used because we are expecting very
          few connections. (in fact only one (Caesars))
*/

class CConnectionPoint : public IConnectionPoint
	{
	friend class CEnumConnections;

private:
	struct CSinkElem : CDblLink
		{
		DWORD		m_dwCookie;			// cookie that we assigned the connection
		IUnknown *	m_pUnkObj;			// event sink

		CSinkElem(DWORD dwCookie, IUnknown *pUnkObj)
			{
			m_dwCookie = dwCookie;
			if ((m_pUnkObj = pUnkObj) != NULL) m_pUnkObj->AddRef();
			}

		~CSinkElem()
			{
			if (m_pUnkObj) m_pUnkObj->Release();
			}
		};

	CDblLink		m_listSinks;		// list of event sinks
	DWORD			m_dwCookieNext; 	// Next cookie

protected:
	IUnknown *		m_pUnkContainer;	// pointer to parent container
	GUID			m_uidEvent;			// connection point interface

public:
	CConnectionPoint(IUnknown *, const GUID &);
	~CConnectionPoint();

	// IConnectionPoint members
	STDMETHODIMP GetConnectionInterface(GUID *);
	STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer **);
	STDMETHODIMP Advise(IUnknown *, DWORD *);
	STDMETHODIMP Unadvise(DWORD);
	STDMETHODIMP EnumConnections(IEnumConnections **);

	inline BOOL FIsEmpty()			// quick way to check if list is empty w/o allocating enumerator
		{
		return m_listSinks.FIsEmpty();
		}
	};


/*	****************************************************************************
	Class:		CEnumConnections
	Synopsis:	Provide the enumerator for CConnectionPoint
*/

class CEnumConnections : public IEnumConnections
	{
private:
	ULONG				m_cRefs;		// Reference count
	CDblLink *			m_pElemCurr;	// Current element
	CConnectionPoint *	m_pCP;			// pointer to iteratee

public:
	CEnumConnections(CConnectionPoint *pCP);
	~CEnumConnections(void);

	// The Big Three

	STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IEnumConnections members

	STDMETHODIMP Next(ULONG, CONNECTDATA *, ULONG *);
	STDMETHODIMP Skip(ULONG);
	STDMETHODIMP Reset(void);
	STDMETHODIMP Clone(IEnumConnections **);
	};

#endif _ConnPt_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\context.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ScriptingContext object

File: Context.cpp

Owner: DmitryR

This file contains the code for the implementation of the 
ScriptingContext object, which is passed to server controls
via the OnStartPage method.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "context.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
CScriptingContext::CScriptingContext

CScriptingContext constructor

Parameters:
    IApplicationObject *pAppln          Application
    ISessionObject     *pSession        Session
    IRequest           *pRequest        Request
    IResponse          *pResponse       Response
    IServer            *pServer         Server

Returns:
===================================================================*/
CScriptingContext::CScriptingContext
(
IApplicationObject *pAppln,
ISessionObject     *pSession,
IRequest           *pRequest,
IResponse          *pResponse,
IServer            *pServer
)
	: m_cRef(1),
	  m_pAppln(pAppln), m_pSession(pSession),
      m_pRequest(pRequest), m_pResponse(pResponse), m_pServer(pServer),
      m_ImpISuppErr(this, NULL, IID_IScriptingContext)
	{
	CDispatch::Init(IID_IScriptingContext);

    // AddRef Intrinsics -- they are now true COM objects
    if (m_pAppln)
        m_pAppln->AddRef();
    if (m_pSession)
        m_pSession->AddRef();
    if (m_pRequest)
        m_pRequest->AddRef();
    if (m_pResponse)
        m_pResponse->AddRef();
    if (m_pServer)
        m_pServer->AddRef();
	}

/*===================================================================
CScriptingContext::~CScriptingContext

CScriptingContext destructor

Parameters:

Returns:
===================================================================*/
CScriptingContext::~CScriptingContext()
    {
    Assert(m_cRef == 0);

    // Release Intrinsics
    if (m_pAppln)
        m_pAppln->Release();
    if (m_pSession)
        m_pSession->Release();
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pResponse)
        m_pResponse->Release();
    if (m_pServer)
        m_pServer->Release();
    }

/*===================================================================
IScriptingContext Interface Methods

CScriptingContext::Application
CScriptingContext::Session
CScriptingContext::Request
CScriptingContext::Response
CScriptingContext::Server

Parameters:
	[out] Intrinsic object pointer

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CScriptingContext::get_Request(IRequest **ppRequest)
	{
	if (m_pRequest)
	    {
    	m_pRequest->AddRef();
    	*ppRequest = m_pRequest;
    	return S_OK;
    	}
    else
        {
    	*ppRequest = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
        }
	}
	
STDMETHODIMP CScriptingContext::get_Response(IResponse **ppResponse)
	{
	if (m_pResponse)
	    {
    	m_pResponse->AddRef();
    	*ppResponse = m_pResponse;
    	return S_OK;
    	}
    else
        {
    	*ppResponse = m_pResponse;
    	return TYPE_E_ELEMENTNOTFOUND;
        }
	}

STDMETHODIMP CScriptingContext::get_Server(IServer **ppServer)
	{
	if (m_pServer)
	    {
	    m_pServer->AddRef();
    	*ppServer = m_pServer;
    	return S_OK;
	    }
	else
	    {
    	*ppServer = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}

STDMETHODIMP CScriptingContext::get_Session(ISessionObject **ppSession)
	{
	if (m_pSession)
	    {
	    m_pSession->AddRef();
    	*ppSession = m_pSession;
    	return S_OK;
	    }
	else
	    {
    	*ppSession = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}

STDMETHODIMP CScriptingContext::get_Application(IApplicationObject **ppAppln)
	{
	if (m_pAppln)
	    {
	    m_pAppln->AddRef();
    	*ppAppln = m_pAppln;
    	return S_OK;
	    }
	else
	    {
    	*ppAppln = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}


/*===================================================================
IUnknown Interface Methods

CScriptingContext::QueryInterface
CScriptingContext::AddRef
CScriptingContext::Release
===================================================================*/
STDMETHODIMP CScriptingContext::QueryInterface
(
REFIID riid,
PPVOID ppv
)
	{
	if (riid == IID_IUnknown  ||
	    riid == IID_IDispatch ||
	    riid == IID_IScriptingContext)
	    {
        AddRef();
		*ppv = this;
		}
	else if (riid == IID_IRequest)
        {
        if (FAILED(get_Request((IRequest **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IResponse)
        {
        if (FAILED(get_Response((IResponse **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IServer)
        {
        if (FAILED(get_Server((IServer **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_ISessionObject)
        {
        if (FAILED(get_Session((ISessionObject **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IApplicationObject)
        {
        if (FAILED(get_Application((IApplicationObject **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_ISupportErrorInfo)
	    {
        m_ImpISuppErr.AddRef();
		*ppv = &m_ImpISuppErr;
		}
	else
	    {
    	*ppv = NULL;
    	return E_NOINTERFACE;
        }
	    
	return S_OK;
	}

STDMETHODIMP_(ULONG) CScriptingContext::AddRef()
	{
	return ++m_cRef;
	}

STDMETHODIMP_(ULONG) CScriptingContext::Release()
	{
	if (--m_cRef)
		return m_cRef;
		
	delete this;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\clcert.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: clcert.cpp

Owner: DGottner

This file contains the code for the implementation of the
Request.ClientCertificate
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include <schnlsp.h>

#include "objbase.h"
#include "request.h"
#include "clcert.h"

#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

#define UUENCODEDSIZE(a)  ((((a)+3)*4)/3+1)

#define BLOB_AS_ARRAY

HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn,
    DWORD       cbLen,
    LPBYTE      pbIn
    );

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

/*------------------------------------------------------------------
 * X B F
 */

BOOL XBF::Extend( int cA )
{
    if ( cA > m_cAlloc )
    {
        int cNew = (( cA + XBF_EXTEND )/XBF_EXTEND)*XBF_EXTEND;
        LPSTR pN = (LPSTR)malloc( cNew );
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_cSize )
        {
            memcpy( pN, m_pV, m_cSize );
        }
        if ( m_cAlloc )
        {
            free( m_pV );
        }
        m_pV = pN;
        m_cAlloc = cNew;
    }
    return TRUE;
}

/*------------------------------------------------------------------
 * C C l C e r t S u p p o r t E r r
 */

/*===================================================================
CClCertSupportErr::CClCertSupportErr

constructor
===================================================================*/

CClCertSupportErr::CClCertSupportErr(CClCert *pClCert)
{
    m_pClCert = pClCert;
}



/*===================================================================
CClCertSupportErr::QueryInterface
CClCertSupportErr::AddRef
CClCertSupportErr::Release

Delegating IUnknown members for CClCertSupportErr object.
===================================================================*/

STDMETHODIMP CClCertSupportErr::QueryInterface(const IID &idInterface, void **ppvObj)
{
    return m_pClCert->QueryInterface(idInterface, ppvObj);
}

STDMETHODIMP_(ULONG) CClCertSupportErr::AddRef()
{
    return m_pClCert->AddRef();
}

STDMETHODIMP_(ULONG) CClCertSupportErr::Release()
{
    return m_pClCert->Release();
}



/*===================================================================
CClCertSupportErr::InterfaceSupportsErrorInfo

Report back to OA about which interfaces we support that return
error information
===================================================================*/

STDMETHODIMP CClCertSupportErr::InterfaceSupportsErrorInfo(const GUID &idInterface)
{
    if (idInterface == IID_IDispatch)
        return S_OK;

    return S_FALSE;
}



/*------------------------------------------------------------------
 * C R e a d C l C e r t
 */

/*===================================================================
CReadClCert::CReadClCert

constructor
===================================================================*/

CReadClCert::CReadClCert(CClCert *pClCert)
{
    m_pClCert = pClCert;
    CDispatch::Init(IID_IRequestDictionary);
}



/*===================================================================
CReadClCert::QueryInterface
CReadClCert::AddRef
CReadClCert::Release

Delegating IUnknown members for CReadClCert object.
===================================================================*/

STDMETHODIMP CReadClCert::QueryInterface(const IID &idInterface, void **ppvObj)
{
    return m_pClCert->QueryInterface(idInterface, ppvObj);
}

STDMETHODIMP_(ULONG) CReadClCert::AddRef()
{
    return m_pClCert->AddRef();
}

STDMETHODIMP_(ULONG) CReadClCert::Release()
{
    return m_pClCert->Release();
}


/*===================================================================
CReadClCert::get_Item

Retrieve a value in the clcert dictionary.
===================================================================*/

STDMETHODIMP CReadClCert::get_Item(VARIANT varKey, VARIANT *pVarReturn)
{
    VariantInit(pVarReturn);                // default return value is Empty
    VARIANT *pvarKey = &varKey;
    HRESULT hres;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    if (V_VT(pvarKey) != VT_BSTR) {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
    }

    switch (V_VT(pvarKey)) {
        case VT_BSTR:
            break;

        case VT_ERROR:
            if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND) {
                // simple value, URLEncoding NOT a good idea in this case
                if (m_pClCert->m_szValue) {
                    V_VT(pVarReturn) = VT_BSTR;
                    switch( m_pClCert->m_veType ) {
                        case VT_BSTR: {
                            BSTR bstrT;
                            if ( FAILED(SysAllocStringFromSz(m_pClCert->m_szValue, 0, &bstrT )) ) {
                                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                                VariantClear(&varKeyCopy);
                                return E_FAIL;
                            }
                            V_BSTR(pVarReturn) = bstrT;
                            break;
                        }

                        case VT_DATE:
                            V_VT(pVarReturn) = VT_DATE;
                            V_DATE(pVarReturn) = *(UNALIGNED64 DATE*)m_pClCert->m_szValue;
                            break;

                        case VT_I4:
                            V_VT(pVarReturn) = VT_I4;
                            V_I4(pVarReturn) = *(UNALIGNED64 DWORD*)m_pClCert->m_szValue;
                            break;

                        case VT_BLOB:
#if defined(BLOB_AS_ARRAY)
                            if ( FAILED( hres = SetVariantAsByteArray( pVarReturn,
                                                                       m_pClCert->m_cLen,
                                                                       (LPBYTE)m_pClCert->m_szValue ) ) ) {
                                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                                VariantClear(&varKeyCopy);
                                return hres;
                            }
#else
                            V_BSTR(pVarReturn) = SysAllocStringByteLen(m_pClCert->m_szValue, m_pClCert->m_cLen );
#endif
                            break;

                        default:
                            Assert( FALSE );
                    }
                }

                // dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
                else {
                }

                VariantClear(&varKeyCopy);
                return S_OK;
            }

        default:
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
            VariantClear(&varKeyCopy);
            return E_FAIL;
    }
LExit:
    VariantClear(&varKeyCopy);
    return S_OK;
}

/*===================================================================
CReadClCert::get_Key

Function called from DispInvoke to get keys from the QueryString collection.

Parameters:
        vKey            VARIANT [in], which parameter to get the key of
        pvarReturn      VARIANT *, [out] value of the requested parameter

Returns:
        S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CReadClCert::get_Key(VARIANT varKey, VARIANT *pVar)
{
    return E_NOTIMPL;
}

/*===================================================================
CReadClCert::get_Count

Parameters:
        pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CReadClCert::get_Count(int *pcValues)
{
    HRESULT hrReturn = S_OK;

    *pcValues = 0;

    return hrReturn;
}

/*===================================================================
CReadClCert::get__NewEnum

Return an enumerator object.
===================================================================*/

STDMETHODIMP CReadClCert::get__NewEnum(IUnknown **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}



/*------------------------------------------------------------------
 * C C l C e r t
 */

/*===================================================================
CClCert::CClCert

constructor
===================================================================*/

CClCert::CClCert(IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
    : m_ReadClCertInterface(this),
      m_ClCertSupportErrorInfo(this)
{
    m_szValue    = NULL;
    m_veType     = VT_BSTR;
    m_pfnDestroy = pfnDestroy;
    m_cRefs      = 1;
}



/*===================================================================
CClCert::~CClCert

Destructor
===================================================================*/

CClCert::~CClCert()
{
}



/*===================================================================
CClCert::Init

initialize the clcert. This initializes the clcert's value hashing
table
===================================================================*/

HRESULT CClCert::Init()
{
    return S_OK;
}



/*===================================================================
CClCert::QueryInterface
CClCert::AddRef
CClCert::Release

IUnknown members for CClCert object.

Note on CClCert::QueryInterface: The Query for IDispatch is
ambiguous because it can either refer to DIRequestDictionary or
DIWriteClCert.  To resolve this, we resolve requests for IDispatch
to IRequestDictionary.
===================================================================*/

STDMETHODIMP CClCert::QueryInterface(const IID &idInterface, void **ppvObj)
{
    if (idInterface == IID_IUnknown)
        *ppvObj = this;

    else if (idInterface == IID_IRequestDictionary || idInterface == IID_IDispatch)
        *ppvObj = &m_ReadClCertInterface;

    else if (idInterface == IID_ISupportErrorInfo)
        *ppvObj = &m_ClCertSupportErrorInfo;

    else
        *ppvObj = NULL;

    if (*ppvObj != NULL)
    {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CClCert::AddRef()
{
    return ++m_cRefs;
}


STDMETHODIMP_(ULONG) CClCert::Release(void)
{
    if (--m_cRefs != 0)
        return m_cRefs;

    if (m_pfnDestroy != NULL)
        (*m_pfnDestroy)();

    delete this;
    return 0;
}



/*===================================================================
CClCert::AddValue

Set the clcert's primary value. One you set the primary value,
you can't reset it.
===================================================================*/

HRESULT CClCert::AddValue(char *szValue, VARENUM ve, UINT l )
{
    if (m_szValue != NULL)          // clcert already is marked as single-valued
        return E_FAIL;

    m_szValue = szValue;

    m_veType = ve;
    m_cLen = l;
    return S_OK;
}



/*===================================================================
CClCert::GetHTTPClCertSize

Return the number of bytes required for the expansion of the clcert
===================================================================*/

size_t CClCert::GetHTTPClCertSize()
        {
        if (m_szValue)
                return URLEncodeLen(m_szValue);
    else
        return 1;
        }


/*===================================================================
CClCert::GetHTTPClCert

Return the URL Encoded value a single clcert

Parameters:
        szBuffer -  pointer to the destination buffer to store the
                                URL encoded value

Returns:
        Returns a pointer to the terminating NUL character.
===================================================================*/

char *CClCert::GetHTTPClCert(char *szBuffer)
{
    if (m_szValue)
        return URLEncode(szBuffer, m_szValue);

    else
    {
        char *szDest = szBuffer;
        *szDest = '\0';

        return szDest;
    }
}



/*===================================================================
CClCert::GetClCertHeaderSize

Return the number of bytes required to allocate for the "Set-ClCert" header.

Parameters:
        szName - the name of the cookie (the size of the name is added to the value)

Returns:
        Returns 0 if *this does not contain a cookie value.
===================================================================*/

size_t CClCert::GetClCertHeaderSize(const char *szName)
{
    int cbClCert = sizeof "Set-ClCert: ";           // initialize and add NUL terminator now

    // Add size of the URL Encoded name, a character for the '=', and the size
    // of the URL Encoded cookie value.  URLEncodeLen, and GetHttpClCertSize
    // compensate for the NUL terminator, so we actually SUBTRACT 1. (-2 for
    // these two function calls, +1 for the '=' sign
    //
    cbClCert += URLEncodeLen(szName) + GetHTTPClCertSize() - 1;

    return cbClCert;
}



/*===================================================================
CClCert::GetClCertHeader

Construct the appropriate "Set-ClCert" header for a clcert.

Parameters:
        szName - the name of the clcert (the size of the name is added to the value)

Returns:
        Returns 0 if *this does not contain a clcert value.
===================================================================*/

char *CClCert::GetClCertHeader(const char *szName, char *szBuffer)
{
    // write out the clcert name and value
    //
    char *szDest = strcpyExA(szBuffer, "Set-ClCert: ");
    szDest = URLEncode(szDest, szName);
    szDest = strcpyExA(szDest, "=");
    szDest = GetHTTPClCert(szDest);

    return szDest;
}



/*------------------------------------------------------------------
 * C C e r t R e q u e s t
 */


/*===================================================================
CCertRequest::AddStringPair

Add a string element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    szValue - ptr to value as string
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT
CCertRequest::AddStringPair(
    CollectionType Source,
    LPSTR szName,
    LPSTR szValue,
    XBF *pxbf,
    BOOL fDuplicate,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;

    if ( fDuplicate )
    {
        if ( (szValue = pxbf->AddStringZ( szValue )) == NULL )
        {
            return E_OUTOFMEMORY;
        }
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        if ( hResult == E_FAIL )
        {
            // assume duplicate value found
            // if out of memore, OUT_OF_MEMORY would have been returned

            hResult = S_OK;
        }
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddValue( Source, szValue, NULL, lCodePage )))
    {
        return hResult;
    }

    return S_OK;
}


/*===================================================================
CCertRequest::AddDatePair

Add a date element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to date as FILETIME
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT
CCertRequest::AddDatePair(
    CollectionType Source,
    LPSTR szName,
    FILETIME* pValue,
    XBF *pxbf
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    DATE Date;
    SYSTEMTIME st;
    LPBYTE pVal;

    if ( !FileTimeToSystemTime( pValue, &st ) )
    {
        return E_FAIL;
    }

    SystemTimeToVariantTime( &st, &Date );

    if ( (pVal = (LPBYTE)pxbf->AddBlob( (LPSTR)&Date, sizeof(Date) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_DATE, pVal, sizeof(Date) )))
    {
        return hResult;
    }

    return S_OK;
}




/*===================================================================
CCertRequest::AddDwordPair

Add a DWORD element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to date as DWORD
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT
CCertRequest::AddDwordPair(
    CollectionType Source,
    LPSTR szName,
    DWORD* pValue,
    XBF *pxbf
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

    if ( (pVal = (LPBYTE)pxbf->AddBlob( (LPSTR)pValue, sizeof(DWORD) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_I4, pVal, sizeof(DWORD) )))
    {
        return hResult;
    }

    return S_OK;
}




/*===================================================================
CCertRequest::AddBinaryPair

Add a binary element in the collection
Each byte is converted to UNICODE character so that mid() & asc() work

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to value as byte array
    cValue - # of bytes pointed to by pValue
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT
CCertRequest::AddBinaryPair(
    CollectionType Source,
    LPSTR szName,
    LPBYTE pValue,
    DWORD cValue,
    XBF *pxbf,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

#if defined(BLOB_AS_ARRAY)

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( cValue )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pVal, pValue, cValue );

    pxbf->SkipRange( cValue );

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_BLOB, pVal, cValue )))
    {
        return hResult;
    }

#else

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( cValue * sizeof(WCHAR), sizeof(WCHAR))) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if ( !(cValue = MultiByteToWideChar( lCodePage, 0, (LPSTR)pValue, cValue, (WCHAR*)pVal, cValue)) )
    {
        return E_FAIL;
    }

    pxbf->SkipRange( cValue * sizeof(WCHAR), sizeof(WCHAR));

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_BLOB, pVal, cValue * sizeof(WCHAR) )))
    {
            return hResult;
    }

#endif

    return S_OK;
}


BOOL IISuuencode( BYTE *   bufin,
               DWORD    nbytes,
               BYTE *   outptr,
               BOOL     fBase64 )
{
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;

   for (i=0; i<nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if(i == nbytes+1) {
      /* There were only 2 bytes in that last group */
      outptr[-1] = '=';
   } else if(i == nbytes+2) {
      /* There was only 1 byte in that last group */
      outptr[-1] = '=';
      outptr[-2] = '=';
   }

   *outptr = '\0';

   return TRUE;
}

/*===================================================================
CCertRequest::AddUuBinaryPair

Add a binary element in the collection
buffer is uuencoded then converted to UNICODE character so that mid() & asc() work

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to value as byte array
    cValue - # of bytes pointed to by pValue
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT
CCertRequest::AddUuBinaryPair(
    CollectionType Source,
    LPSTR szName,
    LPBYTE pValue,
    DWORD cValue,
    XBF *pxbf,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( UUENCODEDSIZE(cValue) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if ( !IISuuencode( (LPBYTE)pValue, cValue, pVal, FALSE ) )
    {
        return E_FAIL;
    }

    Assert( (strlen((LPSTR)pVal)+1) <= UUENCODEDSIZE(cValue) );

    pxbf->SkipRange( strlen((LPSTR)pVal)+1 );

        if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
                return hResult;
    }

        if (FAILED(hResult = pReqHit->AddValue( Source, (LPSTR)pVal, NULL, lCodePage )))
    {
                return hResult;
    }

    return S_OK;
}


/*===================================================================
CCertRequest::AddName

Add a named entry to the collection

Parameters:
        szName - name of entry
    ppReqHit - updated with ptr to created entry
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT
CCertRequest::AddName(
    LPSTR szName,
    CRequestHit **ppReqHit,
    XBF *pxbf
    )
{
    if ( (szName = pxbf->AddStringZ( szName )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    // Add this object to the Request
    CRequestHit *pRequestHit = (CRequestHit *)(pReq->CertStoreFindElem(szName, strlen(szName)));
    if (pRequestHit == NULL)
    {
        pRequestHit = new CRequestHit;
        if (pRequestHit == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if (FAILED(pRequestHit->Init(szName)))
        {
            delete pRequestHit;
            return E_FAIL;
        }

        pReq->CertStoreAddElem( (CLinkElem*) pRequestHit );
    }
    else if (pRequestHit->m_pClCertData)    // a clcert by this name already exists
    {
        return E_FAIL;
    }

    if (!pReq->m_pData->m_ClCerts.AddRequestHit(pRequestHit))
    {
        return E_OUTOFMEMORY;
    }

    *ppReqHit = pRequestHit;

    return S_OK;
}


typedef struct _MAP_ASN {
    LPSTR pAsnName;
    LPSTR pTextName;
} MAP_ASN;


//
// definition of ASN.1 <> X.509 name conversion
//

MAP_ASN aMapAsn[] = {
    { szOID_COUNTRY_NAME, "C" },
    { szOID_ORGANIZATION_NAME, "O" },
    { szOID_ORGANIZATIONAL_UNIT_NAME, "OU" },
    { szOID_COMMON_NAME, "CN" },
    { szOID_LOCALITY_NAME, "L" },
    { szOID_STATE_OR_PROVINCE_NAME, "S" },
    { szOID_TITLE, "T" },
    { szOID_GIVEN_NAME, "GN" },
    { szOID_INITIALS, "I" },
    { "1.2.840.113549.1.9.1", "EMAIL" },
} ;


LPSTR MapAsnName(
    LPSTR pAsnName
    )
/*++

Routine Description:

    Convert ASN.1 name ( as ANSI string ) to X.509 member name

Arguments:

    pAsnName - ASN.1 name

Return Value:

    ptr to converted name if ASN.1 name was recognized, else ASN.1 name

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++x )
    {
        if ( !strcmp( pAsnName, aMapAsn[x].pAsnName ) )
        {
            return aMapAsn[x].pTextName;
        }
    }

    return pAsnName;
}


BOOL
DecodeRdn(
    CERT_NAME_BLOB* pNameBlob,
    PCERT_NAME_INFO* ppNameInfo
    )
/*++

Routine Description:

    Create a PNAME_INFO from PNAME_BLOB

Arguments:

    pNameBlob - ptr to name blob to decode
    ppNameInfo - updated with ptr to name info

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PCERT_NAME_INFO     pNameInfo = NULL;
    DWORD               cbNameInfo;

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                          (LPCSTR)X509_NAME,
                          pNameBlob->pbData,
                          pNameBlob->cbData,
                          0,
                          NULL,
                          &cbNameInfo))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_CERTIFICATE_BAD_CERT);
        return FALSE;
    }

    if (NULL == (pNameInfo = (PCERT_NAME_INFO)malloc(cbNameInfo)))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return FALSE;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           (LPCSTR)X509_NAME,
                           pNameBlob->pbData,
                           pNameBlob->cbData,
                           0,
                           pNameInfo,
                           &cbNameInfo))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_CERTIFICATE_BAD_CERT);
        free( pNameInfo );
        return FALSE;
    }

    *ppNameInfo = pNameInfo;

    return TRUE;
}


VOID
FreeDecodedRdn(
    PCERT_NAME_INFO pNameInfo
    )
/*++

Routine Description:

    Free a PNAME_BLOB created by DecodeRdn()

Arguments:

    pNameInfo - ptr to name info created by DecodeRdn()

Return Value:

    None

--*/
{
    free( pNameInfo );
}


BOOL
BuildRdnList(
    PCERT_NAME_INFO pNameInfo,
    XBF* pxbf,
    BOOL fXt
    )
/*++

Routine Description:

    Build a clear text representation of the Rdn list in pNameInfo
    Format as "C=US, O=Ms, CN=name"

Arguments:

    pNameInfo - ptr to name info
    pxbf - ptr to buffer receiving output
    fXt - TRUE if buffer to be extended, FALSE does not extend ( buffer
          must be big enough before calling this function or FALSE will
          be returned )

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD               cRDN;
    DWORD               cAttr;
    PCERT_RDN           pRDN;
    PCERT_RDN_ATTR      pAttr;
    BOOL                fFirst = TRUE;

    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( !fFirst )
            {
                if ( !pxbf->AddBlob( ", ", sizeof(", ")-1, fXt ) )
                {
                    return FALSE;
                }
            }
            else
            {
                fFirst = FALSE;
            }

            if ( pAttr->dwValueType == CERT_RDN_UNICODE_STRING )
            {
                INT                 iRet;
                BYTE                abBuffer[ 512 ];
                DWORD               cbNameBuffer;
                PBYTE               pNameBuffer = NULL;

                //
                // Need to convert unicode string to MBCS :(
                //

                iRet = WideCharToMultiByte( CP_ACP,
                                            0,
                                            (LPWSTR) pAttr->Value.pbData,
                                            -1,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL );

                if ( !iRet )
                {
                    return FALSE;
                }
                else
                {
                    cbNameBuffer = (DWORD) iRet;
                    if ( (DWORD) iRet > sizeof( abBuffer ) )
                    {
                        pNameBuffer = (PBYTE) LocalAlloc( LPTR,
                                                          (DWORD) iRet );
                        if ( !pNameBuffer )
                        {
                            return FALSE;
                        }
                    }
                    else
                    {
                        pNameBuffer = abBuffer;
                    }
                }

                iRet = WideCharToMultiByte( CP_ACP,
                                            0,
                                            (LPWSTR) pAttr->Value.pbData,
                                            -1,
                                            (LPSTR) pNameBuffer,
                                            cbNameBuffer,
                                            NULL,
                                            NULL );

                if ( !iRet )
                {
                    if ( pNameBuffer != abBuffer )
                    {
                        LocalFree( pNameBuffer );
                    }
                    return FALSE;
                }

                //
                // Now stuff the MBCS string back into the blob.  I do this
                // because there is other code that re-reads and re-processes
                // the CRYPTAPI blob.
                //

                if ( cbNameBuffer <= pAttr->Value.cbData )
                {
                    memcpy( pAttr->Value.pbData,
                            pNameBuffer,
                            cbNameBuffer );
                    pAttr->Value.cbData = cbNameBuffer;
                    pAttr->dwValueType = CERT_RDN_OCTET_STRING;
                }

                if ( pNameBuffer != abBuffer )
                {
                    LocalFree( pNameBuffer );
                    pNameBuffer = NULL;
                }
            }

            if ( !pxbf->AddString( MapAsnName( pAttr->pszObjId ), fXt ) ||
                 !pxbf->AddBlob( "=", sizeof("=")-1, fXt ) ||
                 !pxbf->AddString( (LPSTR) pAttr->Value.pbData, fXt ) )
            {
                return FALSE;
            }
        }
    }

    return pxbf->AddBlob( "", sizeof(""), fXt ) != NULL;
}


/*===================================================================
CCertRequest::ParseRDNS

Function called to parse a certificate into a OA collection

Parameters:
        pNameInfo - ptr to name structure ( cf. CAPI 2 )
    pszPrefix - prefix to prepend to members name
    pxbf - ptr to buffer to hold result

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::ParseRDNS(
    PCERT_NAME_INFO pNameInfo,
    LPSTR pszPrefix,
    XBF *pxbf,
    UINT lCodePage
    )
{
    DWORD               cRDN;
    DWORD               cAttr;
    PCERT_RDN           pRDN;
    PCERT_RDN_ATTR      pAttr;
    DWORD               cRDNs;
    DWORD               cAttrs;
    PCERT_RDN           pRDNs;
    PCERT_RDN_ATTR      pAttrs;
    LPSTR               pszFullName = NULL;
    HRESULT             hRes = S_OK;
    LPSTR               pName;
    UINT                cL;
    LPSTR               pVal = NULL;


    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( pAttr->dwValueType & 0x80000000 )
            {
                continue;
            }

            // scan for attr of same name

            pAttr->dwValueType |= 0x80000000;
            cL = 0;
            pVal = NULL;
            for ( cRDNs = cRDN, pRDNs = pRDN;
                  cRDNs > 0;
                  cRDNs--, pRDNs++)
            {
                for ( cAttrs = pRDNs->cRDNAttr, pAttrs = pRDNs->rgRDNAttr ;
                      cAttrs > 0 ;
                      cAttrs--, ++pAttrs )
                {
                    if ( !(pAttrs->dwValueType & 0x80000000) &&
                         !strcmp( pAttr->pszObjId, pAttrs->pszObjId ) )
                    {
                        cL += strlen( (LPSTR)pAttrs->Value.pbData ) + 1;
                    }
                }
            }

            //
            // if attributes of the same name found, concatenate their
            // values separated by ';'
            //

            if ( cL )
            {
                pVal = (LPSTR)malloc( cL + strlen((LPSTR)pAttr->Value.pbData) + 1 );
                if ( pVal == NULL )
                {
                    return E_OUTOFMEMORY;
                }
                strcpy( pVal, (LPSTR)pAttr->Value.pbData );
                for ( cRDNs = cRDN, pRDNs = pRDN;
                      cRDNs > 0;
                      cRDNs--, pRDNs++)
                {
                    for ( cAttrs = pRDNs->cRDNAttr, pAttrs = pRDNs->rgRDNAttr ;
                          cAttrs > 0 ;
                          cAttrs--, ++pAttrs )
                    {
                        if ( !(pAttrs->dwValueType & 0x80000000) &&
                             !strcmp( pAttr->pszObjId, pAttrs->pszObjId ) )
                        {
                            strcat( pVal, ";" );
                            strcat( pVal, (LPSTR)pAttrs->Value.pbData );
                            pAttrs->dwValueType |= 0x80000000;
                        }
                    }
                }
            }

            pName = MapAsnName( pAttr->pszObjId );
            if ( (pszFullName = (LPSTR)malloc( strlen(pszPrefix)+strlen(pName)+1 )) == NULL )
            {
                hRes = E_OUTOFMEMORY;
                goto cleanup;
            }
            strcpy( pszFullName, pszPrefix );
            strcat( pszFullName, pName );
            if ( (hRes = AddStringPair( CLCERT,
                                        pszFullName,
                                        pVal ? pVal : (LPSTR)pAttr->Value.pbData,
                                        pxbf,
                                        TRUE,
                                        lCodePage )) != S_OK )
            {
                if ( pVal != NULL )
                {
                    free( pVal );
                }
                goto cleanup;
            }
            if ( pVal != NULL )
            {
                free( pVal );
                pVal = NULL;
            }
            free( pszFullName );
            pszFullName = NULL;
        }
    }

cleanup:
    if ( pszFullName != NULL )
    {
        free( pszFullName );
    }

    return hRes;
}


/*===================================================================
CCertRequest::ParseCertificate

Function called to parse a certificate into a OA collection

Parameters:
        pspcRCI - client certificate structure

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::ParseCertificate(
    LPBYTE      pbCert,
    DWORD       cCert,
    DWORD       dwEncoding,
    DWORD       dwFlags,
    UINT        lCodePage
    )
{
    XBF                 xbf( pReq->GetCertStoreBuf(), pReq->GetCertStoreSize() );
    HRESULT             hRes = S_OK;
    PCERT_NAME_INFO     pNameInfo = NULL;
    UINT                cStore;
    UINT                x;
    LPSTR               pVal;
    PCCERT_CONTEXT      pCert;


    if (NULL == (pCert = CertCreateCertificateContext(dwEncoding,
                                                      pbCert,
                                                      cCert))) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }

    // estimate size of buffer holding values

    cStore = pCert->cbCertEncoded +          // for clear text format
             sizeof("ISSUER") +
             sizeof("BINARYISSUER") + (UUENCODEDSIZE(pCert->pCertInfo->Issuer.cbData)*sizeof(WCHAR)) +
             sizeof("BINARYSUBJECT") + (UUENCODEDSIZE(pCert->pCertInfo->Subject.cbData)*sizeof(WCHAR)) +
             sizeof("SUBJECT") + ((pCert->cbCertEncoded + 2) * 2 * sizeof(WCHAR)) +     // store fields
             sizeof("CERTIFICATE") + ((pCert->cbCertEncoded +2)* sizeof(WCHAR)) +
             sizeof("SERIALNUMBER") + (pCert->pCertInfo->SerialNumber.cbData * 3) +
             sizeof("PUBLICKEY") + ((pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData+2) * sizeof(WCHAR)) +
             sizeof("VALIDFROM") + sizeof(DATE) +
             sizeof("VALIDUNTIL") + sizeof(DATE) +
             sizeof("FLAGS") + sizeof(DWORD) +
             sizeof("ENCODING") + sizeof(DWORD);
           ;

    if ( !xbf.Extend( cStore ) ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // Build Issuer clear text format & fields collection
    //

    if ( !DecodeRdn( &pCert->pCertInfo->Issuer, &pNameInfo ) )
    {
        hRes = E_FAIL;
        goto cleanup;
    }
    pVal = xbf.ReserveRange( 0 );
    if ( !BuildRdnList( pNameInfo, &xbf, FALSE ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }
    if ( (hRes = AddStringPair( CLCERT, "ISSUER", pVal, &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddUuBinaryPair( CLCERT,
                                "BINARYISSUER",
                                pCert->pCertInfo->Issuer.pbData,
                                pCert->pCertInfo->Issuer.cbData,
                                &xbf,
                                lCodePage ))!=S_OK ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=ParseRDNS( pNameInfo, "ISSUER", &xbf, lCodePage )) != S_OK ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    FreeDecodedRdn( pNameInfo );

    //
    // Build Subject clear text format & fields collection
    //

    if ( !DecodeRdn( &pCert->pCertInfo->Subject, &pNameInfo ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_FAIL;
    }
    pVal = xbf.ReserveRange( 0 );
    if ( !BuildRdnList( pNameInfo, &xbf, FALSE ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }
    if ( (hRes = AddStringPair( CLCERT, "SUBJECT", pVal, &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddUuBinaryPair( CLCERT,
                                "BINARYSUBJECT",
                                pCert->pCertInfo->Subject.pbData,
                                pCert->pCertInfo->Subject.cbData,
                                &xbf,
                                lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=ParseRDNS( pNameInfo, "SUBJECT", &xbf, lCodePage )) != S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    FreeDecodedRdn( pNameInfo );

    if ( (hRes=AddBinaryPair( CLCERT, "CERTIFICATE", pCert->pbCertEncoded, pCert->cbCertEncoded, &xbf, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    //
    //  SerialNumber
    //  The certificate's serial number. (Decoded as a multiple byte integer.
    //  SerialNumber.pbData[0] is the least significant byte. SerialNumber.pbData[
    //  SerialNumber.cbData - 1] is the most significant byte.)
    //
    char achSerNum[128];
    UINT cbSN;

    DBG_ASSERT(pCert->pCertInfo->SerialNumber.cbData > 1);
    cbSN = pCert->pCertInfo->SerialNumber.cbData;
    if (cbSN > 0 && cbSN < sizeof(achSerNum)/3)
    {
        cbSN--;
    }
    else
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    UINT iOffSet;
    for ( x = 0, iOffSet = 0; x < pCert->pCertInfo->SerialNumber.cbData ; ++x )
    {
        iOffSet = (cbSN-x)*3;   // start with the least significant byte
        achSerNum[iOffSet] = "0123456789abcdef"[((LPBYTE)pCert->pCertInfo->SerialNumber.pbData)[x]>>4];
        achSerNum[iOffSet+1] = "0123456789abcdef"[pCert->pCertInfo->SerialNumber.pbData[x]&0x0f];
        if ( x != 0 ) {
            achSerNum[iOffSet+2] = '-';
        }
        else
        {
            achSerNum[iOffSet+2] = '\0';
        }
    }

    if ( (hRes=AddStringPair( CLCERT, "SERIALNUMBER", achSerNum, &xbf, TRUE, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddBinaryPair( CLCERT, "PUBLICKEY", pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData, pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData, &xbf, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDFROM", &pCert->pCertInfo->NotBefore, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDUNTIL", &pCert->pCertInfo->NotAfter, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDwordPair( CLCERT, "FLAGS", &dwFlags, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDwordPair( CLCERT, "ENCODING", &dwEncoding, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

cleanup:
    if ( pCert )
    {
        CertFreeCertificateContext( pCert );
    }

    pReq->SetCertStore( xbf.QueryBuf(), xbf.QueryAllocSize() );

    xbf.Reset();

    return hRes;
}


/*===================================================================
CCertRequest::NoCertificate

Function called to create NULL certificate info into a OA collection

Parameters:
        None

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::NoCertificate(
    )
{
#if 1

    return S_OK;

#else

    XBF                 xbf( pReq->GetCertStoreBuf(), pReq->GetCertStoreSize() );
    HRESULT             hRes = S_OK;
    UINT                cStore;
    FILETIME            ft;

    // estimate size of buffer holding values

    cStore =
             sizeof("ISSUER") + 2*sizeof(WCHAR) +
             sizeof("BINARYISSUER") + 2*sizeof(WCHAR) +
             sizeof("BINARYSUBJECT") + 2*sizeof(WCHAR) +
             sizeof("SUBJECT") + 2*sizeof(WCHAR) +
             sizeof("CERTIFICATE") + 2 * sizeof(WCHAR) +
             sizeof("SERIALNUMBER") + 2 * sizeof(WCHAR) +
             sizeof("PUBLICKEY") + 2 * sizeof(WCHAR) +
             sizeof("VALIDFROM") + sizeof(DATE) +
             sizeof("VALIDUNTIL") + sizeof(DATE)
           ;

    if ( !xbf.Extend( cStore ) )
    {
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }

    ft.dwLowDateTime = 0;
    ft.dwHighDateTime = 0;

    //
    // Build Issuer clear text format & fields collection
    //

    if ( (hRes = AddStringPair( CLCERT, "ISSUER", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "BINARYISSUER", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "SUBJECT", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "BINARYSUBJECT", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "CERTIFICATE", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddStringPair( CLCERT, "SERIALNUMBER", "", &xbf, TRUE, lCodePage ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddStringPair( CLCERT, "PUBLICKEY", "", &xbf, TRUE, lCodePage ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDFROM", &ft, &xbf ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDUNTIL", &ft, &xbf ))!=S_OK )
    {
        goto cleanup;
    }

cleanup:

    pReq->SetCertStore( xbf.QueryBuf(), xbf.QueryAllocSize() );

    xbf.Reset();

    return hRes;

#endif
}


/*===================================================================
RequestSupportTerminate

Function called to initialize certificate support

Parameters:
        None

Returns:
        TRUE on success, otherwise FALSE
===================================================================*/

BOOL
RequestSupportInit(
    )
{
    return TRUE;
}


/*===================================================================
RequestSupportTerminate

Function called to terminate certificate support

Parameters:
        None

Returns:
        Nothing
===================================================================*/

VOID
RequestSupportTerminate(
    )
{
}


HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn,
    DWORD       cbLen,
    LPBYTE      pbIn
    )
/*++

Routine Description:

    Create variant as byte array

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
    HRESULT         hr;
    SAFEARRAYBOUND  rgsabound[1];
    BYTE *          pbData = NULL;

    // Set the variant type of the output parameter

    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    // Allocate a SafeArray for the data

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbLen;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
    {
        return E_UNEXPECTED;
    }

    memcpy(pbData, pbIn, cbLen );

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\cachemgr.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Template Cache Manager

File: CacheMgr.h

Owner: DGottner

Template cache manager definition
-----------------------------------------------------------------------------*/

#ifndef _CACHEMGR_H
#define _CACHEMGR_H

// Includes -------------------------------------------------------------------

#include "Template.h"
#include "lkrhash.h"
#include "aspdmon.h"

class CHitObj;

#define MAX_CLEANUP_THREADS 32

// Types and Constants --------------------------------------------------------

#define CTEMPLATEBUCKETS 1021		// size of CTemplate hash table
#define CINCFILEBUCKETS  89			// size of CIncFile hash table


/*	****************************************************************************
	Class:		CTemplateCacheManager
	Synopsis:	A CCacheManager that manages a cache of Denali templates
*/	
class CTemplateCacheManager
	{

private:
    class CTemplateHashTable;
    friend class CTemplateHashTable;

    // since there is only one CTemplateCacheManager object ever available, namely
    // g_TemplateCache, this is safe to call these two members static.

    static BOOL     m_fFailedToInitPersistCache;
    static char     m_szPersistCacheDir[MAX_PATH];

    HANDLE m_hOnInitCleanupThread;

    HANDLE m_hCleanupThreads[MAX_CLEANUP_THREADS];
    DWORD m_cCleanupThreads;

    // The type for a hash table of CTemplates keyed on instance id + name
	//
	// since we provide new methods, make parent methods uncallable
	class CTemplateHashTable :  private CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>
	{
	private:
        CDblLink m_listMemoryTemplates;
        CDblLink m_listPersistTemplates;
        DWORD    m_dwInMemoryTemplates;
        DWORD    m_dwPersistedTemplates;

	public:
		// export some methods
        DWORD InMemoryTemplates() { return m_dwInMemoryTemplates; };
		//CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>::Size;

        // test to see if the template can be persisted...
        BOOL  CanPersistTemplate(CTemplate *pTemplate);

        // trim some number of templates from the persist cache...
        BOOL  TrimPersistCache(DWORD    dwTrimCount);

        VOID     ScavengePersistCache();

		// new methods
		CTemplateHashTable()
			: CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>("ASP Template Cache") {
            m_dwInMemoryTemplates = 0;
            m_dwPersistedTemplates = 0;
            }

		static const CTemplateKey *ExtractKey(const CTemplate *pTemplate)
			{
			return pTemplate->ExtractHashKey();
			}

		// NOTE: We don't hash the pTemplateKey->nInstanceID because it can be wildcarded.
		//       if we were to include in the hash, the wildcard won't hash to the same key
		//
		static DWORD CalcKeyHash(const CTemplateKey *pTemplateKey)
			{
			return HashString(pTemplateKey->szPathTranslated, 0);
			}

		static bool EqualKeys(const CTemplateKey *pKey1, const CTemplateKey *pKey2) {
            return (_tcscmp(pKey1->szPathTranslated, pKey2->szPathTranslated) == 0)
                    && (pKey1->dwInstanceID == pKey2->dwInstanceID
                            || pKey1->dwInstanceID == MATCH_ALL_INSTANCE_IDS
                            || pKey2->dwInstanceID == MATCH_ALL_INSTANCE_IDS);
        }

		// NOTE: In theory, the LKHash can help solve our ref. counting problems, by
		//       automatic addref/release.  However, since prior code uses non-refcounting
		//       data structure, it's safer to leave old code alaone in this respect, and
		//       no-op the AddRefRecord method.
		//
		static void AddRefRecord(CTemplate *pTemplate, int nIncr)
			{
			}

    	// Provide new methods to automatically manage the LRU ordering.
    	// NOTE: We used to override the methods but ran into inconsistencies (bugs?)
    	// in VC compiler. Sometimes it would call derived & sometimes the base class
    	// given the same arguemt datatypes.
		//
		LK_RETCODE InsertTemplate(CTemplate *pTemplate);

		LK_RETCODE RemoveTemplate(CTemplate *pTemplate, BOOL fPersist = FALSE, BOOL fScavengePersistCache = TRUE);

		// NOTE: Template signature also requires const ptr to const data
		LK_RETCODE FindTemplate(const CTemplateKey &rTemplateKey, CTemplate **ppTemplate, BOOL* pfNeedsCheck = NULL);

		// accessor methods for hidden LRU cache
		bool FMemoryTemplatesIsEmpty() const
			{
			return m_listMemoryTemplates.FIsEmpty();
			}

		// you CANNOT compare LRU nodes to NULL to know if you are at the end
		// of the list!  Instead use this member.
		//
		BOOL FMemoryTemplatesDblLinkAtEnd(CDblLink *pElem)
			{
			pElem->AssertValid();
			return pElem == &m_listMemoryTemplates;
			}

		CDblLink *MemoryTemplatesBegin()		// return pointer to last referenced item
			{
			return m_listMemoryTemplates.PNext();
			}

		CDblLink *MemoryTemplatesEnd()			// return pointer to least recently accessed item
			{
			return m_listMemoryTemplates.PPrev();
			}

		// accessor methods for hidden LRU cache
		bool FPersistTemplatesIsEmpty() const
			{
			return m_listPersistTemplates.FIsEmpty();
			}

		// you CANNOT compare LRU nodes to NULL to know if you are at the end
		// of the list!  Instead use this member.
		//
		BOOL FPersistTemplatesDblLinkAtEnd(CDblLink *pElem)
			{
			pElem->AssertValid();
			return pElem == &m_listPersistTemplates;
			}

		CDblLink *PersistTemplatesBegin()		// return pointer to last referenced item
			{
			return m_listPersistTemplates.PNext();
			}

		CDblLink *PersistTemplatesEnd()			// return pointer to least recently accessed item
			{
			return m_listPersistTemplates.PPrev();
			}
		};

	CRITICAL_SECTION	m_csUpdate;			// CS for updating the data structures
	CTemplateHashTable	*m_pHashTemplates;	// the cache data structure
	DWORD				m_dwTemplateCacheTag; // Cache Tag to for cache consistency verification

    // Initialize the persistant template cache
    BOOL     InitPersistCache(CIsapiReqInfo *pIReq);

    // static methods primarily used from a seperate thread to flush
    // the template cache out of band from the FCN thread notification.

    static  void  FlushHashTable(CTemplateHashTable   *pTable);
    static  DWORD __stdcall FlushHashTableThread(VOID  *pArg);

    // Spawned at FirstInit to cleanup leftover old cache directories
    static  DWORD OnInitCleanup(VOID *p);

public:


	CTemplateCacheManager();
	~CTemplateCacheManager();

    inline void LockTemplateCache()   { EnterCriticalSection(&m_csUpdate); }
    inline void UnLockTemplateCache() { LeaveCriticalSection(&m_csUpdate); }

	HRESULT Init();
	HRESULT UnInit();
	DWORD	GetCacheTag() { return m_dwTemplateCacheTag;}	

    HRESULT FirstHitInit(CIsapiReqInfo *pIReq)
                { InitPersistCache(pIReq); return S_OK; }

	// Find in cache (don't load) -- for look-aheads
	/////
    HRESULT FindCached(const TCHAR *szFile, DWORD dwInstanceID, CTemplate **ppTemplate);

	// Get a template from the cache, or load it into cache
	/////
	HRESULT Load(BOOL fRunGlobalAsp, const TCHAR *szFile, DWORD dwInstanceID, CHitObj *pHitObj, CTemplate **ppTemplate, BOOL *pfTemplateInCache);

	// Remove a template from the cache
	//   for backward compatibility, "nInstanceID" can be omitted, in which case all instance ID
	//   templates are flushed.
	/////
	void Flush(const TCHAR *szFile, DWORD dwInstanceID);

	// Remove templates from the cache that have a common prefix
	//   Instance ID is ignored.
	/////
	void FlushFiles(const TCHAR *szFilePrefix);

	// Remove all templates from the cache
	/////
	//void FlushAll(VOID);
	void FlushAll(BOOL fDoLazyFlush = FALSE);


	// Add all templates that form an application to the debugger's list of
	// running documents
	/////
	void AddApplicationToDebuggerUI(CAppln *pAppln);

	// Remove all templates that form an application from the debugger's list of
	// running documents
	/////
	void RemoveApplicationFromDebuggerUI(CAppln *pAppln);

	// Get directory change notification on directories used by template
	BOOL RegisterTemplateForChangeNotification(CTemplate *pTemplate, CAppln  *pApplication);

	// Get directory change notification for applications
	BOOL RegisterApplicationForChangeNotification(CTemplate *pTemplate, CAppln *pApplication);

    // Stop getting change notification for changes to templates in the cache.
	BOOL ShutdownCacheChangeNotification();

	};



/*	****************************************************************************
	Class:		CIncFileMap
	Synopsis:	A database mapping template include files to a list of their users
*/	
class CIncFileMap
	{
	CRITICAL_SECTION	m_csUpdate;			// CS for updating the data structures
	CHashTable			m_mpszIncFile;		// the cache data structure

public:

	CIncFileMap();
	~CIncFileMap();

    inline void LockIncFileCache()   { EnterCriticalSection(&m_csUpdate); }
    inline void UnLockIncFileCache() { LeaveCriticalSection(&m_csUpdate); }

	HRESULT Init();
	HRESULT UnInit();

	HRESULT	GetIncFile(const TCHAR *szIncFile, CIncFile **ppIncFile);
	void Flush(const TCHAR *szIncFile);
	void FlushFiles(const TCHAR *szIncFilePrefix);
	};



/*	****************************************************************************
	Non-class support functions
*/
BOOL FFileChangedSinceCached(const TCHAR *szFile, HANDLE hFile, FILETIME& ftPrevWriteTime);



// Globals --------------------------------------------------------------------

extern CTemplateCacheManager	g_TemplateCache;
extern CIncFileMap 				g_IncFileMap;

inline void LockTemplateAndIncFileCaches()
    {
    g_TemplateCache.LockTemplateCache();
    g_IncFileMap.LockIncFileCache();
    }

inline void UnLockTemplateAndIncFileCaches()
    {
    g_TemplateCache.UnLockTemplateCache();
    g_IncFileMap.UnLockIncFileCache();
    }


// Prototypes -----------------------------------------------------------------

#endif // _CACHEMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\context.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ScriptingContext object

File: Context.h

Owner: SteveBr

This file contains the header info for defining the Context object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef SCRIPTING_CONTEXT_H
#define SCRIPTING_CONTEXT_H

#include "debug.h"
#include "util.h"

#include "request.h"
#include "response.h"
#include "server.h"

#include "asptlb.h"
#include "memcls.h"

/*===================================================================
  C S c r i p t i n g C o n t e x t
===================================================================*/

class CScriptingContext : public IScriptingContextImpl
	{
private:
	// Ref count
	ULONG m_cRef; 	    

    // Intrinsics
	IApplicationObject *m_pAppln;
	ISessionObject     *m_pSession;
	IRequest           *m_pRequest;
	IResponse          *m_pResponse;
	IServer            *m_pServer;
	
	// Interface to indicate that we support ErrorInfo reporting
	CSupportErrorInfo m_ImpISuppErr;

public:
	CScriptingContext() 
	    {
	    Assert(FALSE); // Default constructor should not be used
	    }
	
	CScriptingContext
	    (
	    IApplicationObject *pAppln,
        ISessionObject     *pSession,
        IRequest           *pRequest,
        IResponse          *pResponse,
        IServer            *pServer
        );

	~CScriptingContext();
        
	// Non-delegating object IUnknown
	
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IScriptingContext implementation
	
	STDMETHODIMP get_Request(IRequest **ppRequest);
	STDMETHODIMP get_Response(IResponse **ppResponse);
	STDMETHODIMP get_Server(IServer **ppServer);
	STDMETHODIMP get_Session(ISessionObject **ppSession);
	STDMETHODIMP get_Application(IApplicationObject **ppApplication);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

#endif // SCRIPTING_CONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\dbgprop.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 14:24:06 1997
 */
/* Compiler settings for dbgprop.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dbgprop_h__
#define __dbgprop_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDebugProperty_FWD_DEFINED__
#define __IDebugProperty_FWD_DEFINED__
typedef interface IDebugProperty IDebugProperty;
#endif 	/* __IDebugProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_FWD_DEFINED__
#define __IEnumDebugPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugPropertyInfo IEnumDebugPropertyInfo;
#endif 	/* __IEnumDebugPropertyInfo_FWD_DEFINED__ */


#ifndef __IDebugExtendedProperty_FWD_DEFINED__
#define __IDebugExtendedProperty_FWD_DEFINED__
typedef interface IDebugExtendedProperty IDebugExtendedProperty;
#endif 	/* __IDebugExtendedProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugExtendedPropertyInfo IEnumDebugExtendedPropertyInfo;
#endif 	/* __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_FWD_DEFINED__
#define __IPerPropertyBrowsing2_FWD_DEFINED__
typedef interface IPerPropertyBrowsing2 IPerPropertyBrowsing2;
#endif 	/* __IPerPropertyBrowsing2_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_FWD_DEFINED__
#define __IDebugPropertyEnumType_All_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_All IDebugPropertyEnumType_All;
#endif 	/* __IDebugPropertyEnumType_All_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_FWD_DEFINED__
#define __IDebugPropertyEnumType_Locals_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Locals IDebugPropertyEnumType_Locals;
#endif 	/* __IDebugPropertyEnumType_Locals_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
#define __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Arguments IDebugPropertyEnumType_Arguments;
#endif 	/* __IDebugPropertyEnumType_Arguments_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_LocalsPlusArgs IDebugPropertyEnumType_LocalsPlusArgs;
#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_FWD_DEFINED__
#define __IDebugPropertyEnumType_Registers_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Registers IDebugPropertyEnumType_Registers;
#endif 	/* __IDebugPropertyEnumType_Registers_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dbgprop_0000
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 







typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0001
    {	OBJECT_ATTRIB_NO_ATTRIB	= 0,
	OBJECT_ATTRIB_NO_NAME	= 0x1,
	OBJECT_ATTRIB_NO_TYPE	= 0x2,
	OBJECT_ATTRIB_NO_VALUE	= 0x4,
	OBJECT_ATTRIB_VALUE_IS_INVALID	= 0x8,
	OBJECT_ATTRIB_VALUE_IS_OBJECT	= 0x10,
	OBJECT_ATTRIB_VALUE_IS_ENUM	= 0x20,
	OBJECT_ATTRIB_VALUE_IS_CUSTOM	= 0x40,
	OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE	= 0x70,
	OBJECT_ATTRIB_VALUE_HAS_CODE	= 0x80,
	OBJECT_ATTRIB_TYPE_IS_OBJECT	= 0x100,
	OBJECT_ATTRIB_TYPE_HAS_CODE	= 0x200,
	OBJECT_ATTRIB_TYPE_IS_EXPANDABLE	= 0x100,
	OBJECT_ATTRIB_SLOT_IS_CATEGORY	= 0x400,
	OBJECT_ATTRIB_VALUE_READONLY	= 0x800,
	OBJECT_ATTRIB_ACCESS_PUBLIC	= 0x1000,
	OBJECT_ATTRIB_ACCESS_PRIVATE	= 0x2000,
	OBJECT_ATTRIB_ACCESS_PROTECTED	= 0x4000,
	OBJECT_ATTRIB_ACCESS_FINAL	= 0x8000,
	OBJECT_ATTRIB_STORAGE_GLOBAL	= 0x10000,
	OBJECT_ATTRIB_STORAGE_STATIC	= 0x20000,
	OBJECT_ATTRIB_STORAGE_FIELD	= 0x40000,
	OBJECT_ATTRIB_STORAGE_VIRTUAL	= 0x80000,
	OBJECT_ATTRIB_TYPE_IS_CONSTANT	= 0x100000,
	OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED	= 0x200000,
	OBJECT_ATTRIB_TYPE_IS_VOLATILE	= 0x400000,
	OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS	= 0x800000,
	OBJECT_ATTRIB_IS_CLASS	= 0x1000000,
	OBJECT_ATTRIB_IS_FUNCTION	= 0x2000000,
	OBJECT_ATTRIB_IS_VARIABLE	= 0x4000000,
	OBJECT_ATTRIB_IS_PROPERTY	= 0x8000000,
	OBJECT_ATTRIB_IS_MACRO	= 0x10000000,
	OBJECT_ATTRIB_IS_TYPE	= 0x20000000,
	OBJECT_ATTRIB_IS_INHERITED	= 0x40000000,
	OBJECT_ATTRIB_IS_INTERFACE	= 0x80000000
    }	OBJECT_ATTRIB_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0002
    {	PROP_INFO_NAME	= 0x1,
	PROP_INFO_TYPE	= 0x2,
	PROP_INFO_VALUE	= 0x4,
	PROP_INFO_FULLNAME	= 0x20,
	PROP_INFO_ATTRIBUTES	= 0x8,
	PROP_INFO_DEBUGPROP	= 0x10,
	PROP_INFO_AUTOEXPAND	= 0x8000000
    }	PROP_INFO_FLAGS;

#define	PROP_INFO_STANDARD	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_ATTRIBUTES )

#define	PROP_INFO_ALL	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_FULLNAME | PROP_INFO_ATTRIBUTES | PROP_INFO_DEBUGPROP )

typedef struct  tagDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    BSTR m_bstrName;
    BSTR m_bstrType;
    BSTR m_bstrValue;
    BSTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    }	DebugPropertyInfo;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0003
    {	EX_PROP_INFO_ID	= 0x100,
	EX_PROP_INFO_NTYPE	= 0x200,
	EX_PROP_INFO_NVALUE	= 0x400,
	EX_PROP_INFO_LOCKBYTES	= 0x800,
	EX_PROP_INFO_DEBUGEXTPROP	= 0x1000
    }	EX_PROP_INFO_FLAGS;

typedef struct  tagExtendedDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    LPOLESTR m_bstrName;
    LPOLESTR m_bstrType;
    LPOLESTR m_bstrValue;
    LPOLESTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    DWORD m_nDISPID;
    DWORD m_nType;
    VARIANT m_varValue;
    ILockBytes __RPC_FAR *m_plbValue;
    IDebugExtendedProperty __RPC_FAR *m_pDebugExtProp;
    }	ExtendedDebugPropertyInfo;



extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_s_ifspec;

#ifndef __IDebugProperty_INTERFACE_DEFINED__
#define __IDebugProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugProperty
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C50-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugProperty : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedInfo( 
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        END_INTERFACE
    } IDebugPropertyVtbl;

    interface IDebugProperty
    {
        CONST_VTBL struct IDebugPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_RemoteGetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);


void __RPC_STUB IDebugProperty_RemoteGetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetExtendedInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ ULONG cInfos,
    /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
    /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);


void __RPC_STUB IDebugProperty_GetExtendedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_SetValueAsString_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszValue,
    /* [in] */ UINT nRadix);


void __RPC_STUB IDebugProperty_SetValueAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_EnumMembers_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [in] */ REFIID refiid,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IDebugProperty_EnumMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetParent_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);


void __RPC_STUB IDebugProperty_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugPropertyInfo
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C51-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugPropertyInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugPropertyInfoVtbl;

    interface IEnumDebugPropertyInfo
    {
        CONST_VTBL struct IEnumDebugPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPropertyInfo_Next(This,celt,pi,pcEltsfetched)	\
    (This)->lpVtbl -> Next(This,celt,pi,pcEltsfetched)

#define IEnumDebugPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPropertyInfo_Clone(This,ppepi)	\
    (This)->lpVtbl -> Clone(This,ppepi)

#define IEnumDebugPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_RemoteNext_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);


void __RPC_STUB IEnumDebugPropertyInfo_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Skip_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Reset_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Clone_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IEnumDebugPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_GetCount_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugExtendedProperty_INTERFACE_DEFINED__
#define __IDebugExtendedProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugExtendedProperty
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugExtendedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C52-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExtendedProperty : public IDebugProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtendedPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtendedMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExtendedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtendedMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);
        
        END_INTERFACE
    } IDebugExtendedPropertyVtbl;

    interface IDebugExtendedProperty
    {
        CONST_VTBL struct IDebugExtendedPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExtendedProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExtendedProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExtendedProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExtendedProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugExtendedProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugExtendedProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugExtendedProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugExtendedProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)


#define IDebugExtendedProperty_GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)	\
    (This)->lpVtbl -> GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)

#define IDebugExtendedProperty_EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)	\
    (This)->lpVtbl -> EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_GetExtendedPropertyInfo_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);


void __RPC_STUB IDebugExtendedProperty_GetExtendedPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_EnumExtendedMembers_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);


void __RPC_STUB IDebugExtendedProperty_EnumExtendedMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExtendedProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugExtendedPropertyInfo
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugExtendedPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C53-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExtendedPropertyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExtendedPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugExtendedPropertyInfoVtbl;

    interface IEnumDebugExtendedPropertyInfo
    {
        CONST_VTBL struct IEnumDebugExtendedPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExtendedPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugExtendedPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugExtendedPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugExtendedPropertyInfo_Next(This,celt,rgExtendedPropertyInfo,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgExtendedPropertyInfo,pceltFetched)

#define IEnumDebugExtendedPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugExtendedPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugExtendedPropertyInfo_Clone(This,pedpe)	\
    (This)->lpVtbl -> Clone(This,pedpe)

#define IEnumDebugExtendedPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Next_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Skip_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Reset_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Clone_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_GetCount_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerPropertyBrowsing2
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPerPropertyBrowsing2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C54-CB0C-11d0-B5C9-00A0244A0E7A")
    IPerPropertyBrowsing2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayString( 
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapPropertyToPage( 
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPredefinedStrings( 
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPredefinedValue( 
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerPropertyBrowsing2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayString )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPropertyToPage )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPredefinedStrings )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPredefinedValue )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IPerPropertyBrowsing2Vtbl;

    interface IPerPropertyBrowsing2
    {
        CONST_VTBL struct IPerPropertyBrowsing2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerPropertyBrowsing2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerPropertyBrowsing2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerPropertyBrowsing2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerPropertyBrowsing2_GetDisplayString(This,dispid,pBstr)	\
    (This)->lpVtbl -> GetDisplayString(This,dispid,pBstr)

#define IPerPropertyBrowsing2_MapPropertyToPage(This,dispid,pClsidPropPage)	\
    (This)->lpVtbl -> MapPropertyToPage(This,dispid,pClsidPropPage)

#define IPerPropertyBrowsing2_GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)	\
    (This)->lpVtbl -> GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)

#define IPerPropertyBrowsing2_SetPredefinedValue(This,dispid,dwCookie)	\
    (This)->lpVtbl -> SetPredefinedValue(This,dispid,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetDisplayString_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR __RPC_FAR *pBstr);


void __RPC_STUB IPerPropertyBrowsing2_GetDisplayString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_MapPropertyToPage_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CLSID __RPC_FAR *pClsidPropPage);


void __RPC_STUB IPerPropertyBrowsing2_MapPropertyToPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetPredefinedStrings_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
    /* [out] */ CADWORD __RPC_FAR *pCaCookies);


void __RPC_STUB IPerPropertyBrowsing2_GetPredefinedStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_SetPredefinedValue_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IPerPropertyBrowsing2_SetPredefinedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerPropertyBrowsing2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_All_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_All
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_All;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C55-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_All : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_AllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_AllVtbl;

    interface IDebugPropertyEnumType_All
    {
        CONST_VTBL struct IDebugPropertyEnumType_AllVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_All_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_All_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_All_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_All_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPropertyEnumType_All_GetName_Proxy( 
    IDebugPropertyEnumType_All __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *__MIDL_0016);


void __RPC_STUB IDebugPropertyEnumType_All_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPropertyEnumType_All_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Locals
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Locals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C56-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Locals : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsVtbl;

    interface IDebugPropertyEnumType_Locals
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Locals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Locals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Locals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Locals_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Arguments
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Arguments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C57-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Arguments : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_ArgumentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_ArgumentsVtbl;

    interface IDebugPropertyEnumType_Arguments
    {
        CONST_VTBL struct IDebugPropertyEnumType_ArgumentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Arguments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Arguments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Arguments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Arguments_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_LocalsPlusArgs
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_LocalsPlusArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C58-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_LocalsPlusArgs : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsPlusArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsPlusArgsVtbl;

    interface IDebugPropertyEnumType_LocalsPlusArgs
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsPlusArgsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_LocalsPlusArgs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_LocalsPlusArgs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_LocalsPlusArgs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_LocalsPlusArgs_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Registers
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Registers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C59-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Registers : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_RegistersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_RegistersVtbl;

    interface IDebugPropertyEnumType_Registers
    {
        CONST_VTBL struct IDebugPropertyEnumType_RegistersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Registers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Registers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Registers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Registers_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Stub( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Stub( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\dbgcxt.cpp ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:			dbgcxt.cpp
Maintained by:	DGottner
Component:		Implementation of IDebugDocumentContext for CTemplates
==============================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dbgcxt.h"
#include "perfdata.h"
#include "memchk.h"

// {5FA45A6C-AB8A-11d0-8EBA-00C04FC34DCC}
const GUID IID_IDenaliTemplateDocumentContext = 
	{ 0x5fa45a6c, 0xab8a, 0x11d0, { 0x8e, 0xba, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

// {3AED94BE-ED79-11d0-8F34-00C04FC34DCC}
static const GUID IID_IDenaliIncFileDocumentContext = 
	{ 0x3aed94be, 0xed79, 0x11d0, { 0x8f, 0x34, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };


/*
 *
 * C T e m p l a t e D o c u m e n t C o n t e x t
 *
 */

/*	============================================================================
	CTemplateDocumentContext::CTemplateDocumentContext
	Constructor
*/
CTemplateDocumentContext::CTemplateDocumentContext
(
CTemplate *pTemplate,
ULONG cchSourceOffset,
ULONG cchText,
IActiveScriptDebug *pDebugScript,
ULONG idEngine,
ULONG cchTargetOffset
)
	{
	Assert (pTemplate != NULL);

	m_pTemplate       = pTemplate;
	m_idEngine        = idEngine;
	m_pDebugScript    = pDebugScript;
	m_cchSourceOffset = cchSourceOffset;
	m_cchTargetOffset = cchTargetOffset;
	m_cchText         = cchText;
	m_cRefs           = 1;

	m_pTemplate->AddRef();

	if (m_pDebugScript)
		{
		m_pDebugScript->AddRef();

		// If they passed in a script, then they must also pass in target offset & engine ID
		Assert (m_idEngine != -1);
		Assert (m_cchTargetOffset != -1);
		}
	}

/*	============================================================================
	CTemplateDocumentContext::~CTemplateDocumentContext
	Destructor
*/
CTemplateDocumentContext::~CTemplateDocumentContext
(
)
	{
	m_pTemplate->Release();

	if (m_pDebugScript)
		m_pDebugScript->Release();
	}

/*	============================================================================
	CTemplateDocumentContext::QueryInterface

	NOTE: QueryInterface here is also used by CTemplate to determine if an
		  arbitrary document context is ours.
*/
HRESULT CTemplateDocumentContext::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown ||
		guid == IID_IDebugDocumentContext ||
		guid == IID_IDenaliTemplateDocumentContext)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CTemplateDocumentContext::AddRef
	CTemplateDocumentContext::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CTemplateDocumentContext::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CTemplateDocumentContext::Release()
	{
	LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}

/*	============================================================================
	CTemplateDocumentContext::GetDocument
	Return the document.
*/
HRESULT CTemplateDocumentContext::GetDocument
(
/* [out] */ IDebugDocument **ppDebugDocument
)
	{
#ifndef PERF_DISABLE
    g_PerfData.Incr_DEBUGDOCREQ();
#endif
	return m_pTemplate->QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDocument));
	}

/*	============================================================================
	CTemplateDocumentContext::EnumCodeContexts
	Convert document offset to script offset and enumerate code contexts
*/

HRESULT CTemplateDocumentContext::EnumCodeContexts
(
/* [out] */ IEnumDebugCodeContexts **ppEnumerator
)
	{
	if (! m_pTemplate->FIsValid())
		return E_FAIL;

	if (m_pDebugScript == NULL)
		{
		// Convert offset
		m_pTemplate->GetTargetOffset(m_pTemplate->GetSourceFileName(), m_cchSourceOffset, &m_idEngine, &m_cchTargetOffset);

		// See if the script ran and template is holding onto it
		CActiveScriptEngine *pScriptEngine = m_pTemplate->GetActiveScript(m_idEngine);
		if (pScriptEngine)
			{
			if (FAILED(pScriptEngine->GetActiveScript()->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&m_pDebugScript))))
				{
				pScriptEngine->Release();
				return E_FAIL;
				}

			pScriptEngine->IsBeingDebugged();
			pScriptEngine->Release();
			}

		// Script may be still running ("stop" statement case)
		if (m_pDebugScript == NULL)
			m_pDebugScript = g_ScriptManager.GetDebugScript(m_pTemplate, m_idEngine);

		// This is probably a bug...
		if (m_pDebugScript == NULL)		// don't have a running script to match this
			return E_FAIL;

		// No need for AddRef(); m_pDebugScript called funtions that AddRef'ed
		}

	return m_pDebugScript->EnumCodeContextsOfPosition(
												m_idEngine, 
												m_cchTargetOffset,
												m_cchText,
												ppEnumerator);
	}

/*
 *
 * C I n c F i l e E n u m C o d e C o n t e x t s
 *
 *
 * For an include file, the corresponding code contexts are the union
 * of all appropriate code contexts in all template objects that are using
 * the include file.  This special enumerator implements the union.
 */
class CIncFileEnumCodeContexts : public IEnumDebugCodeContexts
	{
private:
	CIncFileDocumentContext *	m_pContext;				// context we are providing enumeration for
	IEnumDebugCodeContexts *	m_pEnumCodeContexts;	// Current code context enumerator
	LONG						m_cRefs;				// reference count
	int							m_iTemplate;			// index of current template

	IEnumDebugCodeContexts *GetEnumerator(int *piTemplate);	// Get enumerator for a template

public:
	CIncFileEnumCodeContexts(CIncFileDocumentContext *pIncFileDocumentContext);
	~CIncFileEnumCodeContexts();

	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IEnumDebugCodeContexts methods

	virtual HRESULT STDMETHODCALLTYPE Next(ULONG celt, IDebugCodeContext **pscc, ULONG *pceltFetched);
	virtual HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
	virtual HRESULT STDMETHODCALLTYPE Reset(void);
	virtual HRESULT STDMETHODCALLTYPE Clone(IEnumDebugCodeContexts **ppescc);
	};
        
/*	============================================================================
	CIncFileEnumCodeContexts::CIncFileEnumCodeContexts
	Constructor
*/
CIncFileEnumCodeContexts::CIncFileEnumCodeContexts
(
CIncFileDocumentContext *pDocumentContext
)
	{
	m_pContext = pDocumentContext;
	m_pContext->AddRef();
	m_cRefs = 1;
	Reset();
	}

/*	============================================================================
	CIncFileEnumCodeContexts::~CIncFileEnumCodeContexts
	Destructor
*/
CIncFileEnumCodeContexts::~CIncFileEnumCodeContexts()
	{
	m_pContext->Release();
	if (m_pEnumCodeContexts)
		m_pEnumCodeContexts->Release();
	}

/*	============================================================================
	CIncFileEnumCodeContexts::GetEnumerator
	Get a code context enumerator for the current script engine

	Side Effects:
		piTemplate is incremented to point to the next available template
		(piTemplate is really an "iteration cookie" -- don't think of it as an index)
*/
IEnumDebugCodeContexts *CIncFileEnumCodeContexts::GetEnumerator
(
int *piTemplate
)
	{
	// Get a template from the array - may need to retry if template contains compiler errors
	CTemplate *pTemplate;
	do
		{
		// GetTemplate returns NULL when array index is out of range (which is when iteration is exhaused)
		pTemplate = m_pContext->m_pIncFile->GetTemplate((*piTemplate)++);
		if (pTemplate == NULL)
			return NULL;
		}  
	while (! pTemplate->FIsValid());

	// If we got this far, we got one of the users of this include file.  Convert the offset
	ULONG idEngine, cchTargetOffset;
	pTemplate->GetTargetOffset(m_pContext->m_pIncFile->GetIncFileName(), m_pContext->m_cchSourceOffset, &idEngine, &cchTargetOffset);

	// Now we have the engine ID, see if template is holding onto corresponding engine
	IActiveScriptDebug *pDebugScriptEngine = NULL;
	CActiveScriptEngine *pScriptEngine = pTemplate->GetActiveScript(idEngine);
	if (pScriptEngine)
		{
		if (FAILED(pScriptEngine->GetActiveScript()->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&pDebugScriptEngine))))
			{
			pScriptEngine->Release();
			return NULL;
			}

		pScriptEngine->IsBeingDebugged();
		pScriptEngine->Release();
		}

	// If we could not get the engine that way, the script is likely still in the running state
	if (pDebugScriptEngine == NULL)
		pDebugScriptEngine = g_ScriptManager.GetDebugScript(pTemplate, idEngine);

	// This is probably a bug...
	if (pDebugScriptEngine == NULL)		// don't have a running script to match this
		return NULL;

	IEnumDebugCodeContexts *pEnumerator;
	HRESULT hrGotEnum = pDebugScriptEngine->EnumCodeContextsOfPosition(
																idEngine, 
																cchTargetOffset,
																m_pContext->m_cchText,
																&pEnumerator);


	pDebugScriptEngine->Release();
	return SUCCEEDED(hrGotEnum)? pEnumerator : NULL;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::QueryInterface
*/
HRESULT CIncFileEnumCodeContexts::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown || guid == IID_IEnumDebugCodeContexts)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CIncFileEnumCodeContexts::AddRef
	CIncFileEnumCodeContexts::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CIncFileEnumCodeContexts::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CIncFileEnumCodeContexts::Release()
	{
	LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Clone

	Clone this iterator (standard method)
*/
HRESULT CIncFileEnumCodeContexts::Clone
(
IEnumDebugCodeContexts **ppEnumClone
)
	{
	CIncFileEnumCodeContexts *pClone = new CIncFileEnumCodeContexts(m_pContext);
	if (pClone == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pClone->m_iTemplate = m_iTemplate;
	pClone->m_pEnumCodeContexts = m_pEnumCodeContexts;
	if (m_pEnumCodeContexts)
		m_pEnumCodeContexts->AddRef();

	*ppEnumClone = pClone;
	return S_OK;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Next

	Get next value (standard method)

	To rehash standard OLE semantics:

		We get the next "cElements" from the collection and store them
		in "rgVariant" which holds at least "cElements" items.  On
		return "*pcElementsFetched" contains the actual number of elements
		stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
		otherwise.
*/
HRESULT CIncFileEnumCodeContexts::Next
(
unsigned long cElementsRequested,
IDebugCodeContext **ppCodeContexts,
unsigned long *pcElementsFetched
)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cLocalElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cLocalElementsFetched;

	// Initialize things
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	// Loop over all templates until we fill the ppCodeContext array or we've exhausted the collection
	//   (when m_pEnumCodeContexts is NULL that means we are done)
	//
	while (cElements > 0 && m_pEnumCodeContexts)
		{
		// Fetch as many contexts as we can from the current iterator
		unsigned long cElementsFetched;
		HRESULT hrEnum = m_pEnumCodeContexts->Next(cElements, ppCodeContexts, &cElementsFetched);
		if (FAILED(hrEnum))
			return hrEnum;

		// If iterator did not fill entire array, advance to next one
		if (cElementsFetched < cElements)
			{
			// Advance - first release the current iterator
			m_pEnumCodeContexts->Release();
			m_pEnumCodeContexts = GetEnumerator(&m_iTemplate);
			}

		*pcElementsFetched += cElementsFetched;
        ppCodeContexts += cElementsFetched;
		cElements -= cElementsFetched;
		}

	// initialize the remaining structures
	while (cElements-- > 0)
		*ppCodeContexts++ = NULL;

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Skip

	Skip items (standard method)

	To rehash standard OLE semantics:

		We skip over the next "cElements" from the collection.
		Returns S_FALSE if less than "cElements" were skipped, S_OK
		otherwise.
*/
HRESULT CIncFileEnumCodeContexts::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero.  Since the iteration logic is
	 * so complex, we do not repeat it here.
	 */
	HRESULT hrElementFetched = S_OK;
	while (cElements > 0 && hrElementFetched == S_OK)
		{
		IDebugCodeContext *pCodeContext;
		hrElementFetched = Next(1, &pCodeContext, NULL);
		pCodeContext->Release();
		--cElements;
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Reset

	Reset the iterator (standard method)
*/
HRESULT CIncFileEnumCodeContexts::Reset()
	{
	m_iTemplate = 0;
	m_pEnumCodeContexts = GetEnumerator(&m_iTemplate);
	return S_OK;
	}

/*
 *
 * C I n c F i l e D o c u m e n t C o n t e x t
 *
 */

/*	============================================================================
	CIncFileDocumentContext::CIncFileDocumentContext
	Constructor
*/
CIncFileDocumentContext::CIncFileDocumentContext
(
CIncFile *pIncFile,
ULONG cchSourceOffset,
ULONG cchText
)
	{
	Assert (pIncFile != NULL);

	m_pIncFile        = pIncFile;
	m_cchSourceOffset = cchSourceOffset;
	m_cchText         = cchText;
	m_cRefs           = 1;

	m_pIncFile->AddRef();
	}

/*	============================================================================
	CIncFileDocumentContext::~CIncFileDocumentContext
	Destructor
*/
CIncFileDocumentContext::~CIncFileDocumentContext
(
)
	{
	m_pIncFile->Release();
	}

/*	============================================================================
	CIncFileDocumentContext::QueryInterface

	NOTE: QueryInterface here is also used by CIncFile to determine if an
		  arbitrary document context is ours.
*/
HRESULT CIncFileDocumentContext::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown ||
		guid == IID_IDebugDocumentContext ||
		guid == IID_IDenaliIncFileDocumentContext)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CIncFileDocumentContext::AddRef
	CIncFileDocumentContext::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CIncFileDocumentContext::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CIncFileDocumentContext::Release()
	{
	LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}

/*	============================================================================
	CIncFileDocumentContext::GetDocument
	Return the document.
*/
HRESULT CIncFileDocumentContext::GetDocument
(
/* [out] */ IDebugDocument **ppDebugDocument
)
	{
#ifndef PERF_DISABLE
    g_PerfData.Incr_DEBUGDOCREQ();
#endif
	return m_pIncFile->QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDocument));
	}

/*	============================================================================
	CIncFileDocumentContext::EnumCodeContexts
	Convert document offset to script offset and enumerate code contexts
*/
HRESULT CIncFileDocumentContext::EnumCodeContexts
(
/* [out] */ IEnumDebugCodeContexts **ppEnumerator
)
	{
	if ((*ppEnumerator = new CIncFileEnumCodeContexts(this)) == NULL)
		return E_OUTOFMEMORY;

	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\dbllink.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash tables with LRU threading 

File: DblLink.cpp

Owner: DGottner

simple, effective linked list manager
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "DblLink.h"
#include "memchk.h"


/*------------------------------------------------------------------
 * C D b l L i n k
 */

/*===================================================================
CDblLink::UnLink

Unlink this element from the list that it currently resides on
===================================================================*/

void CDblLink::UnLink()
	{
	m_pLinkPrev->m_pLinkNext = m_pLinkNext;
	m_pLinkNext->m_pLinkPrev = m_pLinkPrev;

	// Paranoia:
	//       reset the node to empty after the unlink
	//
	m_pLinkPrev = m_pLinkNext = this;
	}



/*===================================================================
CDblLink::AppendTo

Append this link onto a list

Parameters: pListHead - pointer to a the list header (itself
						a CDblLink) to append this item onto.

Condition: the link must be UnLink'ed before this method is called
===================================================================*/

void CDblLink::AppendTo(CDblLink &ListHead)
	{
	UnLink();

	m_pLinkNext = &ListHead;		// remember termination is at list head
	m_pLinkPrev = ListHead.m_pLinkPrev;
	ListHead.m_pLinkPrev->m_pLinkNext = this;
	ListHead.m_pLinkPrev = this;
	}



/*===================================================================
CDblLink::Prepend

Prepend this link onto a list

Parameters: pListHead - pointer to a the list header (itself
						a CDblLink) to prepend this item onto.

Condition: the link must be UnLink'ed before this method is called
===================================================================*/

void CDblLink::PrependTo(CDblLink &ListHead)
	{
	UnLink();

	m_pLinkPrev = &ListHead;
	m_pLinkNext = ListHead.m_pLinkNext;
	ListHead.m_pLinkNext->m_pLinkPrev = this;
	ListHead.m_pLinkNext = this;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\cookies.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: cookies.h

Owner: DGottner

This file contains the definiton of the CCookie class, which
contains all of the state for an HTTP cookie
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asptlb.h"
#include "dispatch.h"
#include "hashing.h"
#include "memcls.h"

class CCookie;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);



/* C C o o k i e P a i r
 *
 * Implements a name/value pair in the Cookie dictionary
 */
class CCookiePair : public CLinkElem
	{
public:
	char *m_szValue;
	BOOL m_fDuplicate;		// TRUE if we have a strdup'ed copy of m_pKey, m_szValue

	HRESULT Init(const char *szKey, const char *szValue, BOOL fDuplicate = FALSE);

	CCookiePair();
	~CCookiePair();
	};
	

/*
 * C C o o k i e S u p p o r t E r r
 *
 * Implements ISupportErrorInfo for the CCookie class. The CSupportError class
 * is not adequate because it will only report a max of one interface which
 * supports error info. (We have two)
 */
class CCookieSupportErr : public ISupportErrorInfo
	{
private:
	CCookie *	m_pCookie;

public:
	CCookieSupportErr(CCookie *pCookie);

	// IUnknown members that delegate to m_pCookie
	//
	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(const GUID &);
	};



/*
 * C W r i t e C o o k i e
 *
 * Implements IWriteCookie which is the interface that Response.Cookies
 * returns.
 */
class CWriteCookie : public IWriteCookieImpl
	{
private:
	CCookie *			m_pCookie;

public:
	CWriteCookie(CCookie *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IWriteCookie implementation
	//
	STDMETHODIMP	put_Item(VARIANT varKey, BSTR bstrValue);
	STDMETHODIMP	put_Expires(DATE dtExpires);
	STDMETHODIMP	put_Domain(BSTR bstrDomain);
	STDMETHODIMP	put_Path(BSTR bstrPath);
	STDMETHODIMP	put_Secure(VARIANT_BOOL fSecure);
	STDMETHODIMP	get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnum);
	};



/*
 * C R e a d C o o k i e
 *
 * Implements IReadCookie which is the interface that Request.Cookies
 * returns.
 */
class CReadCookie : public IReadCookieImpl
	{
private:
	CCookie *			m_pCookie;

public:
	CReadCookie(CCookie *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IReadCookie implementation
	//
	STDMETHODIMP			get_Item(VARIANT i, VARIANT *pVariantReturn);
	STDMETHODIMP			get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get_Key(VARIANT VarKey, VARIANT *pvar);
	};



/*
 * C C o o k i e
 *
 * Implements CCookie, which is the object stored in the Request.Cookies
 * dictionary.
 */
class CCookie : public IUnknown
	{
	friend class CWriteCookie;
	friend class CReadCookie;
	friend class CCookieIterator;

protected:
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CWriteCookie		m_WriteCookieInterface;		// implementation of IWriteCookie
	CReadCookie			m_ReadCookieInterface;		// implementation of IStringList
	CCookieSupportErr	m_CookieSupportErrorInfo;	// implementation of ISupportErrorInfo

	CIsapiReqInfo *                 m_pIReq;        // pointer to CIsapiReqInfo for this cookie
    UINT                            m_lCodePage;    // code page used for UNICODE conversions
	char *							m_szValue;	    // value of cookie when not a dictionary
	CHashTableMBStr					m_mpszValues;	// dictionary of values for the cookie
	time_t							m_tExpires;		// date & time when cookie expires
	char *							m_szDomain;		// Cookie's domain
	CHAR *							m_szPath;		// Cookie's path (If UNICODE, stored as UTF-8)
	VARIANT_BOOL					m_fSecure:1;	// does cookie require security?
	BOOL							m_fDirty:1;		// does cookie need to be sent?
	BOOL							m_fDuplicate:1;	// does cookie contain dynamically allocated string?

public:
	CCookie(CIsapiReqInfo *, UINT  lCodePage, IUnknown * = NULL, PFNDESTROYED = NULL);
	~CCookie();

	HRESULT AddValue(char *szValue, BOOL fDuplicate = FALSE);
	HRESULT AddKeyAndValue(char *szKey, char *szValue, BOOL fDuplicate = FALSE);

	size_t GetHTTPCookieSize();				// return information on how big a buffer should be
	char * GetHTTPCookie(char *szBuffer);	// return the cookie value HTTP encoded

	size_t GetCookieHeaderSize(const char *szName);				// return buffer size needed for Set-Cookie header
	char *GetCookieHeader(const char *szName, char *szBuffer);	// return cookie header

	BOOL IsDirty() { return m_fDirty; }

	HRESULT		Init();

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const GUID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C C o o k i e I t e r a t o r
 *
 * IEnumVariant implementation for Cookie dictionaries
 */

class CCookieIterator : public IEnumVARIANT
	{
public:
	CCookieIterator(CCookie *pCookie);
	~CCookieIterator();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	CCookie *m_pCookie;				// pointer to iteratee
	CCookiePair *m_pCurrent;		// pointer to current item
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\dbgcxt.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:			dbgcxt.h
Maintained by:	DGottner
Component:		include file for IDebugDocumentContext
==============================================================================*/

#ifndef _DBGCXT_H
#define _DBGCXT_H

#include "activdbg.h"

/*	These GUIDs exist to enable the document to determine if an arbitrary
	IDebugDocumentContext object belongs to its document class.  QueryInterface
	for this GUID causes the IDebugDocument object to return a pointer to
	the CDocumentContext (or CIncFileContext) class.
*/
extern const GUID IID_IDenaliTemplateDocumentContext;
extern const GUID IID_IDenaliIncFileDocumentContext;


/*	============================================================================
	Class:		CTemplateDocumentContext
	Synopsis:	implementation of IDebugDocumentContext for CTemplate objects
*/
class CTemplateDocumentContext : public IDebugDocumentContext
	{
friend class CTemplate;		// CTemplate is only user who even cares about this stuff

public:
	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IDebugDocumentContext methods

	virtual HRESULT STDMETHODCALLTYPE GetDocument(
		/* [out] */ IDebugDocument **ppDebugDocument);
 
	virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts(
		/* [out] */ IEnumDebugCodeContexts **ppEnum);
        
	// Constructor & destructor

	CTemplateDocumentContext(
					CTemplate *pTemplate,
					ULONG cchSourceOffset,
					ULONG cchText,
					IActiveScriptDebug *pDebugScript = NULL,	// cached values
					ULONG idEngine = -1,						// only initialize ctor if
					ULONG cchTargetOffset = -1					// values happen to be on hand
					);


	~CTemplateDocumentContext();

private:
	IActiveScriptDebug *m_pDebugScript;		// pointer to script engine
	CTemplate *			m_pTemplate;		// pointer to source document
	ULONG				m_idEngine;			// Engine # in template
	ULONG				m_cchSourceOffset;	// character offset in source
	ULONG				m_cchTargetOffset;	// character offset in target (cached)
	ULONG				m_cchText;			// # of characters in the context
	LONG				m_cRefs;			// reference count
	};


/*	============================================================================
	Class:		CIncFileDocumentContext
	Synopsis:	implementation of IDebugDocumentContext for CIncFile objects
*/
class CIncFileDocumentContext : public IDebugDocumentContext
	{
friend class CIncFile;						// CIncFile is only user who even cares about this stuff
friend class CIncFileEnumCodeContexts;		// iterator class

public:
	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IDebugDocumentContext methods

	virtual HRESULT STDMETHODCALLTYPE GetDocument(
		/* [out] */ IDebugDocument **ppDebugDocument);
 
	virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts(
		/* [out] */ IEnumDebugCodeContexts **ppEnum);
        
	// Constructor & destructor

	CIncFileDocumentContext(
					CIncFile *pIncFile,
					ULONG cchSourceOffset,
					ULONG cchText
					);


	~CIncFileDocumentContext();

private:
	CIncFile *			m_pIncFile;			// pointer to source document
	ULONG				m_cchSourceOffset;	// character offset in source
	ULONG				m_cchText;			// # of characters in the context
	LONG				m_cRefs;			// reference count
	};

#endif /* _DBGCXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\dbllink.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: DblList.h

Owner: DGottner

extremly simple, yet very flexible, linked list manager
===================================================================*/

#ifndef DBLLINK_H
#define DBLLINK_H

#ifdef LINKTEST
#define _DEBUG
#include <assert.h>
#define Assert assert

#else
#include "debug.h"
#endif


/* C D b l L i n k
 *
 * This structure contains a set of links suitable for a doubly linked list
 * implementation.  Here we actually use it as a circularly linked list -
 * the links are extracted into this file because the list headers are also
 * of this type.
 */

class CDblLink
	{
public:
	CDblLink();
	virtual ~CDblLink();

	// manipulators
	/////
	void UnLink();
	void AppendTo(CDblLink &);
	void PrependTo(CDblLink &);

	// accessors
	/////
	CDblLink *PNext() const;
	CDblLink *PPrev() const;

	// testers
	/////
	bool FIsEmpty() const;
	void AssertValid() const
		{
		#ifdef _DEBUG
			Assert (this == m_pLinkPrev->m_pLinkNext && this == m_pLinkNext->m_pLinkPrev);
		#endif
		}

private:
	CDblLink *m_pLinkNext, *m_pLinkPrev;
	};

inline CDblLink::CDblLink()	 { m_pLinkNext = m_pLinkPrev = this; }
inline CDblLink::~CDblLink() { UnLink(); }

inline bool CDblLink::FIsEmpty() const { return this == m_pLinkNext; }
inline CDblLink *CDblLink::PNext() const { return m_pLinkNext; }
inline CDblLink *CDblLink::PPrev() const { return m_pLinkPrev; }

#endif // DBLLINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\cookies.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: cookies.cpp

Owner: DGottner

This file contains the code for the implementation of the 
Request.Cookies and Response.Cookies collections.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "objbase.h"
#include "cookies.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init



/*------------------------------------------------------------------
 * C C o o k i e S u p p o r t E r r
 */

/*===================================================================
CCookieSupportErr::CCookieSupportErr

constructor
===================================================================*/

CCookieSupportErr::CCookieSupportErr(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	}



/*===================================================================
CCookieSupportErr::QueryInterface
CCookieSupportErr::AddRef
CCookieSupportErr::Release

Delegating IUnknown members for CCookieSupportErr object.
===================================================================*/

STDMETHODIMP CCookieSupportErr::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CCookieSupportErr::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CCookieSupportErr::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CCookieSupportErr::InterfaceSupportsErrorInfo

Report back to OA about which interfaces we support that return
error information
===================================================================*/

STDMETHODIMP CCookieSupportErr::InterfaceSupportsErrorInfo(const GUID &idInterface)
	{
	if (idInterface == IID_IDispatch || idInterface == IID_IWriteCookie || idInterface == IID_IReadCookie)
		return S_OK;

	return S_FALSE;
	}



/*------------------------------------------------------------------
 * C W r i t e C o o k i e
 */

/*===================================================================
CWriteCookie::CWriteCookie

constructor
===================================================================*/

CWriteCookie::CWriteCookie(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	CDispatch::Init(IID_IWriteCookie);
	}



/*===================================================================
CWriteCookie::QueryInterface
CWriteCookie::AddRef
CWriteCookie::Release

Delegating IUnknown members for CWriteCookie object.
===================================================================*/

STDMETHODIMP CWriteCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	// Bug 85953 Trap IDispatch before it gets to the core object
	if (idInterface == IID_IUnknown || 
		idInterface == IID_IWriteCookie ||
		idInterface == IID_IDispatch)
		{
		*ppvObj = this;
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}
	else
		return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CWriteCookie::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CWriteCookie::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CWriteCookie::put_Item

Set the primary value for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Item(VARIANT varKey, BSTR bstrValue)
	{
	char            *szKey;		// ascii value of the key
    CWCharToMBCS    convValue;
    CWCharToMBCS    convKey;

	// Bug 122589: Don't crash when "bstrValue" is NULL
	if (bstrValue == NULL)
		return E_FAIL;

	// Initialize things
	//
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	if (V_VT(pvarKey) != VT_BSTR)
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}

	switch (V_VT(pvarKey))
		{
	case VT_BSTR:
		break;

	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			if (m_pCookie->m_szValue == NULL)	// current value is a dictionary
				{
				CCookiePair *pNukePair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
				while (pNukePair != NULL)
					{
					CCookiePair *pNext = static_cast<CCookiePair *>(pNukePair->m_pNext);
					delete pNukePair;
					pNukePair = pNext;
					}

				m_pCookie->m_mpszValues.ReInit();
				}
			else								// no dictionary value
				if (m_pCookie->m_fDuplicate)
					free(m_pCookie->m_szValue);
            if (FAILED(hrReturn = convValue.Init(bstrValue,m_pCookie->m_lCodePage))) {
                goto LExit;
            }
			m_pCookie->m_szValue = NULL;
			m_pCookie->AddValue(convValue.GetString(), TRUE);
			m_pCookie->m_fDirty = TRUE;
			goto LExit;
			}

		// Other error, FALL THROUGH to wrong type case

	default:
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	// don't allow empty keys in the cookie
	//
    
    if (V_BSTR(pvarKey)) {

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
            goto LExit;
        }
        else {
            szKey = convKey.GetString();
        }
    }
    else {
		szKey = "";
    }

	if (*szKey == '\0')
		{
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_COOKIE_EMPTY_DICT);
		hrReturn = E_FAIL;
		goto LExit;
		}

	// we're changing a dictionary value, so first trash the primary value
	//
	if (m_pCookie->m_fDuplicate)
		free(m_pCookie->m_szValue);

    if (FAILED(hrReturn = convValue.Init(bstrValue,m_pCookie->m_lCodePage))) {
        goto LExit;
    }

	m_pCookie->m_szValue = NULL;
	m_pCookie->AddKeyAndValue(szKey, convValue.GetString(), TRUE);
	m_pCookie->m_fDirty = TRUE;

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}



/*===================================================================
CWriteCookie::put_Expires

Set the expires attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Expires(DATE dtExpires)
	{
	if (FAILED(VariantDateToCTime(dtExpires, &m_pCookie->m_tExpires)))
		{
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_COOKIE_BAD_EXPIRATION);
		return E_FAIL;
		}

	m_pCookie->m_fDirty = TRUE;
	return S_OK;
	}



/*===================================================================
CWriteCookie::put_Domain

Set the domain attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Domain(BSTR bstrDomain)
	{
    CWCharToMBCS    convDomain;
    HRESULT         hr = S_OK;

    if (FAILED(hr = convDomain.Init(bstrDomain,m_pCookie->m_lCodePage)));

    else {
        if (m_pCookie->m_szDomain)
            free(m_pCookie->m_szDomain);
	    m_pCookie->m_szDomain = convDomain.GetString(TRUE);
	    m_pCookie->m_fDirty = TRUE;
    }

	return hr;
	}



/*===================================================================
CWriteCookie::put_Path

Set the path attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Path(BSTR bstrPath) 
{
    HRESULT         hr = S_OK;

    CWCharToMBCS    convPath;

    if (FAILED(hr = convPath.Init(bstrPath,m_pCookie->m_lCodePage)));

    else {
		
        if (m_pCookie->m_szPath)
            free(m_pCookie->m_szPath);
	    m_pCookie->m_szPath = convPath.GetString(TRUE);
        if (m_pCookie->m_szPath == NULL)
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
        m_pCookie->m_fDirty = TRUE;

	return hr;
}

/*===================================================================
CWriteCookie::put_Secure

Set the secure attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Secure(VARIANT_BOOL fSecure)
	{
	m_pCookie->m_fSecure = fSecure;
	m_pCookie->m_fDirty = TRUE;

	return S_OK;
	}



/*===================================================================
CWriteCookie::get_HasKeys

Return True if the cookie contains keys, False if it is a simple
value
===================================================================*/

STDMETHODIMP CWriteCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys)
	{
	*pfHasKeys = ( m_pCookie->m_mpszValues.Count() > 0 ? VARIANT_TRUE : VARIANT_FALSE);
	return S_OK;
	}



/*===================================================================
CWriteCookie::get__NewEnum

Return an enumerator object.

ReadCookie and WriteCookie use the same iterator object.
To reduce useless redundancy, deletage to IReadCookie.
The IReadCookie enumerator will likely be used much more
frequently than the IWriteCookie iterator, so we pay the
overhead of delegation in this function.
===================================================================*/

STDMETHODIMP CWriteCookie::get__NewEnum(IUnknown **ppEnumReturn)
	{
	IReadCookie *pReadCookie;
	if (FAILED(QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&pReadCookie))))
		{
		Assert (FALSE);		// expect success!
		return E_FAIL;
		}

	HRESULT hrNewEnum = pReadCookie->get__NewEnum(ppEnumReturn);

	pReadCookie->Release();
	return hrNewEnum;
	}



/*------------------------------------------------------------------
 * C R e a d C o o k i e
 */

/*===================================================================
CReadCookie::CReadCookie

constructor
===================================================================*/

CReadCookie::CReadCookie(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	CDispatch::Init(IID_IReadCookie);
	}



/*===================================================================
CReadCookie::QueryInterface
CReadCookie::AddRef
CReadCookie::Release

Delegating IUnknown members for CReadCookie object.
===================================================================*/

STDMETHODIMP CReadCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	// Bug 85953 Trap IDispatch before it gets to the core object
	if (idInterface == IID_IUnknown || 
		idInterface == IID_IReadCookie ||
		idInterface == IID_IDispatch)
		{
		*ppvObj = this;
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}
	else
		return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CReadCookie::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CReadCookie::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CReadCookie::get_Item

Retrieve a value in the cookie dictionary.
===================================================================*/

STDMETHODIMP CReadCookie::get_Item(VARIANT varKey, VARIANT *pvarReturn)
	{
	char            *szKey;			// ascii version of the key
	CCookiePair     *pPair = NULL;	// name and value of cookie in the dictionary
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128 );

	// Initialize things
	//
	VariantInit(pvarReturn);
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	DWORD vt = V_VT(pvarKey);

	if ((V_VT(pvarKey) != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}
	vt = V_VT(pvarKey);

	switch (vt)
		{
	// Bug 95201 support all numberic sub-types
	case VT_I1:  case VT_I2:               case VT_I8:
	case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
	case VT_R4:  case VT_R8:
		// Coerce all integral types to VT_I4
		if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
			goto LExit;

		// fallthru to VT_I4

	case VT_I4:
	case VT_BSTR:
		break;
	
	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			V_VT(pvarReturn) = VT_BSTR;
	
			// simple value, URLEncoding NOT a good idea in this case
			if (m_pCookie->m_szValue)
				{
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(m_pCookie->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}			
			// dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
			else
				{
				int cbHTTPCookie = m_pCookie->GetHTTPCookieSize();
				if (cbHTTPCookie > REQUEST_ALLOC_MAX)
					{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_STACK_OVERFLOW);
					hrReturn = E_FAIL;
					goto LExit;
					}

                if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    goto LExit;
                }
				char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());
				m_pCookie->GetHTTPCookie(szHTTPCookie);
	
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}

			goto LExit;
			}

	default:
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	if (vt == VT_BSTR)
		{
		// convert the key to ANSI
        if (V_BSTR(pvarKey)) {
            if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
                goto LExit;
            }
            else {
                szKey = convKey.GetString();
            }
        }
        else {
			szKey = "";
        }

		// Look up the key in the Cookie.
		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.FindElem(szKey, strlen(szKey)));
		}
	else 
		{
		// Look up item by index
		int iCount;

		iCount = V_I4(pvarKey);

		if ((iCount < 1) || 
			(m_pCookie->m_mpszValues.Count() == 0) ||
			(iCount > (int) m_pCookie->m_mpszValues.Count() ))
			{
			hrReturn = E_FAIL;
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_BAD_ARRAY_INDEX);
			goto LExit;
			}

		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
		while((iCount > 1) && (pPair != NULL)) 
			{
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			iCount--;
			}
		}

	if (pPair)
		{
       	BSTR bstrT;
       	if (FAILED(SysAllocStringFromSz(pPair->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
    		{
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
			hrReturn = E_FAIL;
			goto LExit;
    		}
		V_VT(pvarReturn) = VT_BSTR;
		V_BSTR(pvarReturn) = bstrT;
		}

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}



/*===================================================================
CReadCookie::get_HasKeys

Return True if the cookie contains keys, False if it is a simple
value
===================================================================*/

STDMETHODIMP CReadCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys)
	{
	*pfHasKeys = (m_pCookie->m_mpszValues.Count() > 0 ? VARIANT_TRUE : VARIANT_FALSE);
	return S_OK;
	}

/*===================================================================
CReadCookie::get__NewEnum

Return an enumerator object.
===================================================================*/

STDMETHODIMP CReadCookie::get__NewEnum(IUnknown **ppEnumReturn)
	{
	*ppEnumReturn = NULL;

	CCookieIterator *pIterator = new CCookieIterator(m_pCookie);
	if (pIterator == NULL)
		{
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	*ppEnumReturn = pIterator;
	return S_OK;
	}

/*===================================================================
CReadCookie::get_Count

Parameters:
	pcValues - count is stored in *pcValues.  Set to 0 if this
		cookie is not multi-valued.
===================================================================*/
STDMETHODIMP CReadCookie::get_Count(int *pcValues)
	{
	*pcValues = m_pCookie->m_mpszValues.Count();
	return S_OK;
	}

/*===================================================================
CReadCookie::get_Key

Function called from DispInvoke to get keys from a multi-valued
Cookie collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the key of
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CReadCookie::get_Key(VARIANT varKey, VARIANT *pvarReturn)
	{
	char            *szKey;			// ascii version of the key
	CCookiePair     *pPair = NULL;	// name and value of cookie in the dictionary
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128);

	// Initialize things
	//
	VariantInit(pvarReturn);
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	DWORD vt = V_VT(pvarKey);

	if ((V_VT(pvarKey) != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}
	vt = V_VT(pvarKey);

	switch (vt)
		{
	// Bug 95201 support all numberic sub-types
	case VT_I1:  case VT_I2:               case VT_I8:
	case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
	case VT_R4:  case VT_R8:
		// Coerce all integral types to VT_I4
		if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
			goto LExit;

		// fallthru to VT_I4

	case VT_I4:
	case VT_BSTR:
		break;
	
	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			V_VT(pvarReturn) = VT_BSTR;
	
			// simple value, URLEncoding NOT a good idea in this case
			if (m_pCookie->m_szValue)
				{
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(m_pCookie->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}			
			// dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
			else
				{
				int cbHTTPCookie = m_pCookie->GetHTTPCookieSize();
				if (cbHTTPCookie > REQUEST_ALLOC_MAX)
					{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_STACK_OVERFLOW);
					hrReturn = E_FAIL;
					goto LExit;
					}

                if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    goto LExit;
                }
				char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());
				m_pCookie->GetHTTPCookie(szHTTPCookie);
	
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT, m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}

			goto LExit;
			}

	default:
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	if (vt == VT_BSTR)
		{
		// convert the key to ANSI
        if (V_BSTR(pvarKey)) {
            if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
                goto LExit;
            }
            else {
                szKey = convKey.GetString();
            }
        }
        else {
			szKey = "";
        }

		// Look up the key in the Cookie.
		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.FindElem(szKey, strlen(szKey)));
		}
	else 
		{
		// Look up item by index
		int iCount;
		
		iCount = V_I4(pvarKey);

		if ((iCount < 1) || 
			(m_pCookie->m_mpszValues.Count() == 0) ||
			(iCount > (int) m_pCookie->m_mpszValues.Count() ))
			{
			hrReturn = E_FAIL;
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_BAD_ARRAY_INDEX);
			goto LExit;
			}

		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
		while((iCount > 1) && (pPair != NULL)) 
			{
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			iCount--;
			}
		}

	if (pPair)
		{
		// Create a BSTR containing the key for this variant
    	BSTR bstrT;
        SysAllocStringFromSz((CHAR *)pPair->m_pKey, 0, &bstrT, m_pCookie->m_lCodePage);
		if (!bstrT)
			return E_OUTOFMEMORY;
		V_VT(pvarReturn) = VT_BSTR;
		V_BSTR(pvarReturn) = bstrT;
    	}

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}


/*------------------------------------------------------------------
 * C C o o k i e
 */

/*===================================================================
CCookie::CCookie

constructor
===================================================================*/

CCookie::CCookie(CIsapiReqInfo   *pIReq, UINT lCodePage, IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
	: m_WriteCookieInterface(this),
	  m_ReadCookieInterface(this),
	  m_CookieSupportErrorInfo(this)
	{
	m_szValue    = NULL;
	m_tExpires  = -1;
	m_szDomain   = NULL;
	m_szPath     = NULL;
	m_fSecure    = FALSE;
	m_fDirty     = FALSE;
	m_fDuplicate = FALSE;
	m_pfnDestroy = pfnDestroy;
	m_pIReq      = pIReq;
    m_lCodePage  = lCodePage;
	m_cRefs      = 1;
	}



/*===================================================================
CCookie::~CCookie

Destructor
===================================================================*/

CCookie::~CCookie()
	{
	CCookiePair *pNukePair = static_cast<CCookiePair *>(m_mpszValues.Head());
	while (pNukePair != NULL)
		{
		CCookiePair *pNext = static_cast<CCookiePair *>(pNukePair->m_pNext);
		delete pNukePair;
		pNukePair = pNext;
		}

	m_mpszValues.UnInit();
	
	if (m_fDuplicate)
		free(m_szValue);
	
	if (m_szDomain) free(m_szDomain);
	if (m_szPath) free(m_szPath);
	}



/*===================================================================
CCookie::Init

initialize the cookie. This initializes the cookie's value hashing
table
===================================================================*/

HRESULT CCookie::Init()
{
    HRESULT     hr = S_OK;
    TCHAR       pathInfo[MAX_PATH];
#if UNICODE
    CWCharToMBCS  convStr;
#endif

    if (FAILED(hr = m_mpszValues.Init(7)));

    // it would be nice if we could use the application path from the metabase,
    // but because of case sensitivity issues, we can't.  The safest bet is
    // to use the request's path info up to the length of the application's
    // pathinfo.

    else if (FAILED(hr=FindApplicationPath(m_pIReq, pathInfo, sizeof(pathInfo))));

#if UNICODE
    else if (FAILED(hr = convStr.Init(m_pIReq->QueryPszPathInfo(), m_lCodePage, _tcslen(pathInfo))));

    else {

        m_szPath = convStr.GetString(TRUE);
    }
#else
    else {

        int cchPathInfo = _tcslen(pathInfo);
        
        if (!(m_szPath = (char *)malloc(cchPathInfo+1))) {
            hr = E_OUTOFMEMORY;
        }
        else {
            memcpy(m_szPath, pathInfo, cchPathInfo+1);
        }
    }
#endif

    return hr;
}



/*===================================================================
CCookie::QueryInterface
CCookie::AddRef
CCookie::Release

IUnknown members for CCookie object.

Note on CCookie::QueryInterface: The Query for IDispatch is
ambiguous because it can either refer to IReadCookie or
IWriteCookie.  To resolve this, we resolve requests for IDispatch
to IReadCookie.  The rationale for this is that the code in
request.cpp calls QueryInterface for a generic IDispatch pointer
(because the collection is heterogenous)  The Response.Cookies
collection is homogeneous and so only calls QueryInterface for
IWriteCookie.
===================================================================*/

STDMETHODIMP CCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	if (idInterface == IID_IUnknown)
		*ppvObj = this;

	else if (idInterface == IID_IReadCookie || idInterface == IID_IDispatch)
		*ppvObj = &m_ReadCookieInterface;

	else if (idInterface == IID_IWriteCookie)
		*ppvObj = &m_WriteCookieInterface;

	else if (idInterface == IID_ISupportErrorInfo)
		*ppvObj = &m_CookieSupportErrorInfo;

	else
		*ppvObj = NULL;

	if (*ppvObj != NULL)
		{
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}

	return ResultFromScode(E_NOINTERFACE);
	}


STDMETHODIMP_(ULONG) CCookie::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CCookie::Release(void)
	{
	if (--m_cRefs != 0)
		return m_cRefs;

	if (m_pfnDestroy != NULL)
		(*m_pfnDestroy)();

	delete this;
	return 0;
	}



/*===================================================================
CCookie::AddValue

Set the cookie's primary value. One you set the primary value,
you can't reset it.
===================================================================*/

HRESULT CCookie::AddValue(char *szValue, BOOL fDuplicate)
	{
	if (m_szValue != NULL)		// cookie already is marked as single-valued
		return E_FAIL;

	if (m_mpszValues.Count() != 0)	// cookie already has a value
		return E_FAIL;

	if (fDuplicate)
		{
		char *szNew = (char *)malloc(strlen(szValue) + 1);
		if (szNew == NULL)
			return E_OUTOFMEMORY;

		m_szValue = strcpy(szNew, szValue);
		}
	else
		m_szValue = szValue;

	m_fDuplicate = fDuplicate;
	return S_OK;
	}



/*===================================================================
CCookie::AddKeyAndValue

Add a key and value pair to the Cookie's dictionary. It fails
if the cookie has a primary value already set. It will overwrite
the value if the key already exists.
===================================================================*/

HRESULT CCookie::AddKeyAndValue(char *szKey, char *szValue, BOOL fDuplicate)
	{
	if (m_szValue != NULL)
		return E_FAIL;

	delete static_cast<CCookiePair *>(m_mpszValues.DeleteElem(szKey, strlen(szKey)));

	CCookiePair *pCookiePair = new CCookiePair;
	if (pCookiePair == NULL)
		return E_OUTOFMEMORY;

	if (FAILED(pCookiePair->Init(szKey, szValue, fDuplicate)))
		return E_FAIL;

	m_mpszValues.AddElem(pCookiePair);

	return S_OK;
	}




/*===================================================================
CCookie::GetHTTPCookieSize

Return the number of bytes required for the expansion of the HTTP_COOKIE variable
===================================================================*/

size_t CCookie::GetHTTPCookieSize()
	{
	if (m_szValue)
		return URLEncodeLen(m_szValue);

	else
		{
		int cbValue = 1;
		CCookiePair *pPair = static_cast<CCookiePair *>(m_mpszValues.Head());
		while (pPair)
			{
			// Add size of the URL Encoded key, a character for the '=', and a
			// character for the '&' or the NUL terminator.  URLEncodeLen
			// returns the size + 1, so the two calls to URLEncodeLen() add the
			// two characters we need.
			//
			cbValue += URLEncodeLen(reinterpret_cast<char *>(pPair->m_pKey)) + URLEncodeLen(pPair->m_szValue);
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			}

		return cbValue;
		}
	}


/*===================================================================
CCookie::GetHTTPCookie

Return the URL Encoded value a single cookie

Parameters:
	szBuffer -  pointer to the destination buffer to store the
				URL encoded value

Returns:
	Returns a pointer to the terminating NUL character.
===================================================================*/

char *CCookie::GetHTTPCookie(char *szBuffer)
	{
	if (m_szValue)
		return URLEncode(szBuffer, m_szValue);

	else
		{
		char *szDest = szBuffer;
		*szDest = '\0';

		CCookiePair *pPair = static_cast<CCookiePair *>(m_mpszValues.Head());
		while (pPair)
			{
			// Write <name>=<value> string
			szDest = URLEncode(szDest, reinterpret_cast<char *>(pPair->m_pKey));
			*szDest++ = '=';
			szDest = URLEncode(szDest, pPair->m_szValue);

			// Advance
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);

			// Append '&' if there's another one following
			if (pPair)
				*szDest++ = '&';
			}

		Assert (*szDest == '\0');	// make sure we are nul-terminated
		return szDest;
		}
	}



/*===================================================================
CCookie::GetCookieHeaderSize

Return the number of bytes required to allocate for the "Set-Cookie" header.

Parameters:
	szName - the name of the cookie (the size of the name is added to the value)

Returns:
	Returns 0 if *this does not contain a cookie value.
===================================================================*/

size_t CCookie::GetCookieHeaderSize(const char *szName)
	{
	int cbCookie = sizeof "Set-Cookie: ";		// initialize and add NUL terminator now

	// Add size of the URL Encoded name, a character for the '=', and the size
	// of the URL Encoded cookie value.  URLEncodeLen, and GetHttpCookieSize
	// compensate for the NUL terminator, so we actually SUBTRACT 1. (-2 for
	// these two function calls, +1 for the '=' sign
	//
	cbCookie += URLEncodeLen(szName) + GetHTTPCookieSize() - 1;
	
	if (m_tExpires != -1)
		cbCookie += (sizeof "; expires=") + DATE_STRING_SIZE - 1;

	// BUG 250 - DBCS External
	// ASP does not URLEncode the domain and path attributes, which was noticed
	// during localizaiton.
	//
	// NOTE: URLEncodeLen and sizeof both add a space for the nul terminator,
	//       so we subtract 2 to compensate.
	//
	if (m_szDomain)
		cbCookie += (sizeof "; domain=") + DBCSEncodeLen(m_szDomain) - 2;

	cbCookie += (sizeof "; path=") + DBCSEncodeLen(m_szPath) - 2;

	if (m_fSecure)
		cbCookie += (sizeof "; secure") - 1;
	
	return cbCookie;
	}



/*===================================================================
CCookie::GetCookieHeader

Construct the appropriate "Set-Cookie" header for a cookie.

Parameters:
	szName - the name of the cookie (the size of the name is added to the value)

Returns:
	Returns 0 if *this does not contain a cookie value.
===================================================================*/

char *CCookie::GetCookieHeader(const char *szName, char *szBuffer)
{
	// write out the cookie name and value
	//
	char *szDest = strcpyExA(szBuffer, "Set-Cookie: ");
	szDest = URLEncode(szDest, szName);
	szDest = strcpyExA(szDest, "=");
	szDest = GetHTTPCookie(szDest);
	
	if (m_tExpires != -1) {
		char szExpires[DATE_STRING_SIZE];
		CTimeToStringGMT(&m_tExpires, szExpires, TRUE);

		szDest = strcpyExA(szDest, "; expires=");
		szDest = strcpyExA(szDest, szExpires);
    }

	if (m_szDomain) {
		szDest = strcpyExA(szDest, "; domain=");
		szDest = DBCSEncode(szDest, m_szDomain);
    }

	szDest = strcpyExA(szDest, "; path=");
	szDest = DBCSEncode(szDest, m_szPath);

	if (m_fSecure)
		szDest = strcpyExA(szDest, "; secure");

	return szDest;
	}



/*------------------------------------------------------------------
 * C C o o k i e P a i r
 */

/*===================================================================
CCookiePair::CCookiePair

constructor
===================================================================*/

CCookiePair::CCookiePair()
	{
	m_fDuplicate = FALSE;
	m_szValue = NULL;
	}



/*===================================================================
CCookiePair::Init

Initialize the cookie pair with a key and a value.  Optionally,
it will copy the strings as well.
===================================================================*/

HRESULT CCookiePair::Init(const char *szKey, const char *szValue, BOOL fDuplicate)
	{
	m_fDuplicate = fDuplicate;
	if (fDuplicate)
		{
		char *szNewKey = (char *)malloc(strlen(szKey) + 1);
		if (szNewKey == NULL)
			return E_OUTOFMEMORY;
		
		char *szNewValue = (char *)malloc(strlen(szValue) + 1);
		if (szNewValue == NULL)
			{
			free(szNewKey);
			return E_OUTOFMEMORY;
			}
		
		if (FAILED(CLinkElem::Init(strcpy(szNewKey, szKey), strlen(szKey))))
			{
			free(szNewKey);
			free(szNewValue);
			return E_FAIL;
			}
	
		m_szValue = strcpy(szNewValue, szValue);
		}
	else
		{
		if (FAILED(CLinkElem::Init(const_cast<char *>(szKey), strlen(szKey))))
			return E_FAIL;
	
		m_szValue = const_cast<char *>(szValue);
		}
	
	return S_OK;
	}



/*===================================================================
CCookiePair::~CCookiePair

destructor
===================================================================*/

CCookiePair::~CCookiePair()
	{
	if (m_fDuplicate)
		{
		if (m_pKey) free(m_pKey);
		if (m_szValue) free(m_szValue);
		}
	}



/*------------------------------------------------------------------
 * C C o o k i e I t e r a t o r
 */

/*===================================================================
CCookieIterator::CCookieIterator

Constructor
===================================================================*/

CCookieIterator::CCookieIterator(CCookie *pCookie)
	{
	m_pCookie	= pCookie;
	m_pCurrent  = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
	m_cRefs		= 1;

	m_pCookie->AddRef();
	}



/*===================================================================
CCookieIterator::CCookieIterator

Destructor
===================================================================*/

CCookieIterator::~CCookieIterator()
	{
	m_pCookie->Release();
	}



/*===================================================================
CCookieIterator::QueryInterface
CCookieIterator::AddRef
CCookieIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CCookieIterator::QueryInterface(REFIID iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}


STDMETHODIMP_(ULONG) CCookieIterator::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CCookieIterator::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CCookieIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CCookieIterator::Clone(IEnumVARIANT **ppEnumReturn)
	{
	CCookieIterator *pNewIterator = new CCookieIterator(m_pCookie);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pCurrent = m_pCurrent;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CCookieIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CCookieIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pCurrent != NULL)
		{
       	BSTR bstrT;
       	if (FAILED(SysAllocStringFromSz(reinterpret_cast<char *>(m_pCurrent->m_pKey), 0, &bstrT, m_pCookie->m_lCodePage)))
			return E_OUTOFMEMORY;
		V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;

		++rgVariant;
		--cElements;
		++*pcElementsFetched;
		m_pCurrent = static_cast<CCookiePair *>(m_pCurrent->m_pNext);
		}

	// initialize the remaining variants
	//
	while (cElements-- > 0)
		VariantInit(rgVariant++);

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CCookieIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CCookieIterator::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pCurrent != NULL)
		{
		--cElements;
		m_pCurrent = static_cast<CCookiePair *>(m_pCurrent->m_pNext);
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CCookieIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CCookieIterator::Reset()
	{
	m_pCurrent = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\debug.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Debug tools

File: debug.h

This file contains the header info for helping with debugging.
===================================================================*/
#include "dbgutil.h"

#define DEBUG_FCN				0x00000800L   // File Change Notification
#define DEBUG_TEMPLATE          0x00001000L
#define DEBUG_SCRIPT_DEBUGGER   0x00002000L
#define DEBUG_SCRIPT_ENGINE     0x00004000L

#define DEBUG_RESPONSE          0x00010000L
#define DEBUG_REQUEST           0x00020000L
#define DEBUG_SERVER            0x00040000L
#define DEBUG_APPLICATION       0x00080000L

#define DEBUG_SESSION           0x00100000L
#define DEBUG_MTS               0X00200000L

#undef Assert
#define Assert(exp)  DBG_ASSERT(exp)

#undef FImplies
#define FImplies(f1,f2) (!(f1)||(f2))

void _ASSERT_IMPERSONATING(void);

#define ASSERT_IMPERSONATING() _ASSERT_IMPERSONATING()

//define DBGWARN     DBGPRINTF
//define DBGERROR    DBGPRINTF
//define DBGINFO     DBGPRINTF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\debug.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Debug tools

File: debug.cpp

This file contains the routines for helping with debugging.
===================================================================*/
#include "denpre.h"
#pragma hdrstop


void _ASSERT_IMPERSONATING(void)
	{
	HANDLE _token;
	DWORD _err;																														
	if( OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &_token) ) 
		CloseHandle( _token );												
	else																	
		{																	
		_err = GetLastError();												
		ASSERT( _err != ERROR_NO_TOKEN );									
		}																	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\debugger.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: debugger.h

Owner: DGottner, DmitryR

This file contains debugger useful utility prototypes.
===================================================================*/

#ifndef _DEBUGGER_H
#define _DEBUGGER_H

#include "activdbg.h"
#include "dbgcxt.h"		// Convienence for users of debugger.h

/*
 * Globals that we advertise
 */

class CViperActivity;

extern IProcessDebugManager *g_pPDM;
extern IDebugApplication *g_pDebugApp;
extern IDebugApplicationNode *g_pDebugAppRoot;
extern CViperActivity *g_pDebugActivity;
extern DWORD g_dwDebugThreadId;

/*
 * Initialize/Uninitialize debugging
 */

extern HRESULT InitDebugging(CIsapiReqInfo *pIReq);
extern HRESULT UnInitDebugging();


/*
 * Get the application node for the virtual server
 */

extern HRESULT GetServerDebugRoot(CIsapiReqInfo *pIReq, IDebugApplicationNode **ppDebugRoot);


/*
 * Query debugging client
 */
BOOL FCaesars();		// TRUE if default JIT debugger is Script Debugger


/*
 * Debugger (or Debugger UI) invocation from a correct thread
 */

#define DEBUGGER_UI_BRING_DOCUMENT_TO_TOP       0x00000001
#define DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP    0x00000002
#define DEBUGGER_EVENT_ON_PAGEBEGIN             0x00000010
#define DEBUGGER_EVENT_ON_PAGEEND               0x00000020
#define DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT	0x00000040
#define DEBUGGER_ON_REMOVE_CHILD                0x00000100
#define DEBUGGER_ON_DESTROY                     0x00000200
#define DEBUGGER_UNUSED_RECORD                  0x80000000  // can reclaim argument space

HRESULT InvokeDebuggerWithThreadSwitch(IDebugApplication *pDebugAppln, DWORD iMethod, void *Arg = NULL);


/*
 * Create/Destroy entire document trees (debugger)
 */

HRESULT CreateDocumentTree(wchar_t *szDocPath, IDebugApplicationNode *pDocParent, IDebugApplicationNode **ppDocRoot, IDebugApplicationNode **ppDocLeaf, wchar_t **pwszLeaf);
void DestroyDocumentTree(IDebugApplicationNode *pDocRoot);


/*===================================================================
  C  F i l e  N o d e

These are used to provide directory nodes in debugger
Used by application mgr & by CreateDocumentTree
===================================================================*/

extern const GUID IID_IFileNode;
struct IFileNode : IDebugDocumentProvider
	{
	//
	// This private interface provides two functions:
	//
	//  * An extra method to retrieve/set the count of documents in
	//    a directory (used to know when we can detach a folder from
	//    the UI
	//
	//  * A way of verifying that an IDebugDocumentProvider is a CFileNode
	//

	STDMETHOD_(DWORD, IncrementDocumentCount)() = 0;
	STDMETHOD_(DWORD, DecrementDocumentCount)() = 0;
	};


class CFileNode : public IFileNode
	{
private:
	DWORD	m_cRefs;			// Reference Count
	DWORD	m_cDocuments;		// # of CTemplates in the directory (and recursively in subdirectories)
	wchar_t *m_wszName;

public:
	CFileNode();
	~CFileNode();
	HRESULT Init(wchar_t *wszName);

	// IUnknown methods
	STDMETHOD(QueryInterface)(const GUID &, void **);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDebugDocumentProvider methods
	STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

	// IDebugDocumentInfo (also IDebugDocumentProvider) methods
	STDMETHOD(GetName)(
		/* [in] */ DOCUMENTNAMETYPE dnt,
		/* [out] */ BSTR *pbstrName);

	STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
		{
		return E_NOTIMPL;
		}

	STDMETHOD_(DWORD, IncrementDocumentCount)()
		{
		return ++m_cDocuments;
		}

	STDMETHOD_(DWORD, DecrementDocumentCount)()
		{
		return --m_cDocuments;
		}
	};

#endif // _DEBUGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\denali.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hit Manager

File: Denali.h

Owner: PramodD

This is the Hit (Request) Manager header file.
===================================================================*/
#ifndef DENALI_H
#define DENALI_H

//#define	LOG_FCNOTIFICATIONS	// logs file change notifications to a file

extern BOOL g_fShutDownInProgress;

inline IsShutDownInProgress() 
    {
    return g_fShutDownInProgress;
    }

extern HRESULT InitializeResourceDll();
extern VOID UninitializeResourceDll();

// de-comment the following line to build with no perfmon counters
//#define 	PERF_DISABLE

DWORD	HandleHit(CIsapiReqInfo     *pIReq);
//void	InitODBC( void );
//void	UnInitODBC( void );

extern BOOL g_fOOP;

extern HINSTANCE g_hinstDLL;

extern HMODULE g_hResourceDLL;


/*	intrinsic object names (bug 164)
	NOTE to add an intrinsic object to denali, follow these steps:
	1. add both sz and wsz versions of the object name below
	2. add a check for the sz version of the object name in CTemplate::FValidObjectName
*/
#define 	CONCAT(a, b)				a ## b
#define 	WSZ(x)						CONCAT(L, x)

#define 	SZ_OBJ_APPLICATION			"Application"
#define 	SZ_OBJ_REQUEST				"Request"
#define 	SZ_OBJ_RESPONSE				"Response"
#define 	SZ_OBJ_SERVER				"Server"
#define 	SZ_OBJ_CERTIFICATE			"Certificate"
#define 	SZ_OBJ_SESSION				"Session"
#define 	SZ_OBJ_SCRIPTINGNAMESPACE 	"ScriptingNamespace"
#define 	SZ_OBJ_OBJECTCONTEXT		"ObjectContext"
#define     SZ_OBJ_ASPPAGETLB           "ASPPAGETLB"
#define     SZ_OBJ_ASPGLOBALTLB         "ASPGLOBALTLB"

#define 	WSZ_OBJ_APPLICATION			WSZ(SZ_OBJ_APPLICATION)
#define 	WSZ_OBJ_REQUEST				WSZ(SZ_OBJ_REQUEST)
#define 	WSZ_OBJ_RESPONSE			WSZ(SZ_OBJ_RESPONSE)
#define 	WSZ_OBJ_SERVER				WSZ(SZ_OBJ_SERVER)
#define 	WSZ_OBJ_CERTIFICATE			WSZ(SZ_OBJ_CERTIFICATE)
#define 	WSZ_OBJ_SESSION				WSZ(SZ_OBJ_SESSION)
#define 	WSZ_OBJ_SCRIPTINGNAMESPACE 	WSZ(SZ_OBJ_SCRIPTINGNAMESPACE)
#define 	WSZ_OBJ_OBJECTCONTEXT		WSZ(SZ_OBJ_OBJECTCONTEXT)
#define     WSZ_OBJ_ASPPAGETLB          WSZ(SZ_OBJ_ASPPAGETLB)
#define     WSZ_OBJ_ASPGLOBALTLB        WSZ(SZ_OBJ_ASPGLOBALTLB)

#define 	BSTR_OBJ_APPLICATION		g_bstrApplication
#define 	BSTR_OBJ_REQUEST			g_bstrRequest
#define 	BSTR_OBJ_RESPONSE			g_bstrResponse
#define 	BSTR_OBJ_SERVER				g_bstrServer
#define 	BSTR_OBJ_CERTIFICATE		g_bstrCertificate
#define 	BSTR_OBJ_SESSION			g_bstrSession
#define 	BSTR_OBJ_SCRIPTINGNAMESPACE g_bstrScriptingNamespace
#define 	BSTR_OBJ_OBJECTCONTEXT		g_bstrObjectContext

// Cached BSTRs
extern BSTR g_bstrApplication;
extern BSTR g_bstrRequest;
extern BSTR g_bstrResponse;
extern BSTR g_bstrServer;
extern BSTR g_bstrCertificate;
extern BSTR g_bstrSession;
extern BSTR g_bstrScriptingNamespace;
extern BSTR g_bstrObjectContext;

// Dll name
#define		ASP_DLL_NAME				"ASP.DLL"

// Max # of bytes we will allocate before we assume an attack by a malicious browser
#define		REQUEST_ALLOC_MAX  (100 * 1024)

#define     SZ_GLOBAL_ASA       _T("GLOBAL.ASA")
#define     CCH_GLOBAL_ASA      10

/*
 * InitializeCriticalSection can throw.  Use this macro instead
 */
#define ErrInitCriticalSection( cs, hr ) \
		do { \
		hr = S_OK; \
		__try \
			{ \
			INITIALIZE_CRITICAL_SECTION(cs); \
			} \
		__except(1) \
			{ \
			hr = E_UNEXPECTED; \
			} \
		} while (0)

#ifdef LOG_FCNOTIFICATIONS
void LfcnCreateLogFile();
void LfcnCopyAdvance(char** ppchDest, const char* sz);
void LfcnAppendLog(const char* sz);
void LfcnLogNotification(char* szFile);
void LfcnLogHandleCreation(int i, char* szApp);
void LfcnUnmapLogFile();
#endif	//LOG_FCNOTIFICATIONS

#endif // DENALI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\denguid.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Denali

File: denguid.cpp

Owner: SteveBr

Contains all guid's created by Denali not in the .odl.
===================================================================*/

DEFINE_GUID(IID_IObjectCover,0xD99A6DA2L,0x485C,0x17CF,0x83,0xBE,0x01,0xD0,0xC9,0x0C,0x2B,0xD8);

// {7F50F880-1230-11d0-B394-00A0C90C2048}
// this is a dummy GUID that is used to identify all Denali intrinsics, 
// its primary intent is to prevent a user from assigning an intrinsic
// object into the session/ application object
DEFINE_GUID(IID_IDenaliIntrinsic, 0x7f50f880, 0x1230, 0x11d0, 0xb3, 0x94, 0x0, 0xa0, 0xc9, 0xc, 0x20, 0x48);

// BUG 1423: We want to be able to identify JavaScript objects.
//				We are NOT supposed to know what this guid is.  We MUST not use this GUID
//				for anything besides QI'ing to see if the object is a JavaScript object
// The GUID used to identify the IJScriptDispatch interface
// {A0AAC450-A77B-11CF-91D0-00AA00C14A7C}
#define szIID_IJScriptDispatch "{A0AAC450-A77B-11CF-91D0-00AA00C14A7C}"
DEFINE_GUID(IID_IJScriptDispatch,  0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\denpre.h ===
#pragma warning(disable:4237)
#pragma warning(disable:4162)
#define _CRYPT32_

#include <ctype.h>
#include <stdlib.h>     // for itow
#include <string.h>
#include <mbstring.h>   // string functions (DBCS)
#include <crtdbg.h>
#include <malloc.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <wtypes.h>
#include <process.h>

#include <rpc.h>
#include <rpcndr.h>
#include <ole2.h>
#include <olectl.h>
#include <oleauto.h>
#include <cguid.h>      // for GUID_NULL
#include <new.h>

#include <iis64.h>
#include <iisextp.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <dbgutil.h>

#include "except.h"
#include "isapireq.h"
#include "Denali.h"
#include "applmgr.h"
#include "sessmgr.h"
#include "hitobj.h"
#include "debug.h"
#include "error.h"
#include "eventlog.h"
#include "aspresource.h"
#include "compcol.h"
#include "scrptmgr.h"
#include "template.h"
#include "cachemgr.h"
#include "glob.h"
#include "scrptmgr.h"
#include "fileapp.h"
#include "util.h"
#include "fileapp.h"

#include "iisresource.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\debugger.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.cpp

Owner: DGottner

This file contains debugger utility functions
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "vector.h"
#include "debugger.h"
#include "iiscnfg.h"
#include "mdcommsg.h"   // for RETURNCODETOHRESULT macro
#include "memchk.h"
#include "vecimpl.h"

/* Win64: This struct is used to package data passed to the thread handler.
 *        (3 DWORDs are too small in 64 bit world.)
 */
struct DebugThreadCallArgs
	{
	DWORD					dwMethod;
	IDebugApplication *		pDebugAppln;
	void *					pvArg;

	DebugThreadCallArgs(DWORD dwMethod = 0, IDebugApplication *pDebugAppln = 0, void *pvArg = 0)
		{
		this->dwMethod = dwMethod;
		this->pDebugAppln = pDebugAppln;
		this->pvArg = pvArg;
		}
	};


// Published globals

IProcessDebugManager *  g_pPDM = NULL;              // instance of debugger for this process.
IDebugApplication *     g_pDebugApp = NULL;         // Root ASP application
IDebugApplicationNode * g_pDebugAppRoot = NULL;     // used to create hierarchy tree
CViperActivity        * g_pDebugActivity = NULL;    // Debugger's activity
DWORD                   g_dwDebugThreadId = 0;      // Thread ID of viper activity

// Globals for debugging

static DWORD    g_dwDenaliAppCookie;            // Cookie to use to remove app
static HANDLE   g_hPDMTermEvent;                // PDM terminate event
static vector<DebugThreadCallArgs> *g_prgThreadCallArgs;    // for new 64 bit interface.

// This hash structure & CS is used by GetServerDebugRoot()

struct CDebugNodeElem : CLinkElem
    {
    IDebugApplicationNode *m_pServerRoot;

    HRESULT Init(char *szKey, int cchKey)
        {
        char *szKeyAlloc = new char [cchKey + 1];
        if (!szKeyAlloc) return E_OUTOFMEMORY;
        return CLinkElem::Init(memcpy(szKeyAlloc, szKey, cchKey + 1), cchKey);
        }

    ~CDebugNodeElem()
        {
        if (m_pKey)
            delete m_pKey;
        }
    };

static CHashTable g_HashMDPath2DebugRoot;
static CRITICAL_SECTION g_csDebugLock;      // Lock for g_hashMDPath2DebugRoot


/*===================================================================
InvokeDebuggerWithThreadSwitch

Invoke Debugger (or Debugger UI) method from a correct thread
using IDebugThreadCall.

Parameters
    IDebugApplication *pDebugAppln      to get to debugger UI
    DWORD              iMethod          which method to call
    void              *Arg              call argument

Returns
    HRESULT
===================================================================*/

// GUIDs for debugger events

static const GUID DEBUGNOTIFY_ONPAGEBEGIN =
            { 0xfd6806c0, 0xdb89, 0x11d0, { 0x8f, 0x81, 0x0, 0x80, 0xc7, 0x3d, 0x6d, 0x96 } };

static const GUID DEBUGNOTIFY_ONPAGEEND =
            { 0xfd6806c1, 0xdb89, 0x11d0, { 0x8f, 0x81, 0x0, 0x80, 0xc7, 0x3d, 0x6d, 0x96 } };

static const GUID DEBUGNOTIFY_ON_REFRESH_BREAKPOINT =
            { 0xffcf4b38, 0xfa12, 0x11d0, { 0x8f, 0x3b, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

// Local class that implements IDebugCallback
class CDebugThreadDebuggerCall : public IDebugThreadCall
    {
public:
    STDMETHODIMP         QueryInterface(const GUID &, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP ThreadCallHandler(DWORD_PTR, DWORD_PTR, DWORD_PTR);
    };

HRESULT CDebugThreadDebuggerCall::QueryInterface
(
const GUID &iid,
void **ppv
)
    {
    if (iid == IID_IUnknown || iid == IID_IDebugThreadCall)
        {
        *ppv = this;
        return S_OK;
        }
    else
        {
        *ppv = NULL;
        return E_NOINTERFACE;
        }
    }

ULONG CDebugThreadDebuggerCall::AddRef()
    {
    return 1;
    }

ULONG CDebugThreadDebuggerCall::Release()
    {
    return 1;
    }

HRESULT CDebugThreadDebuggerCall::ThreadCallHandler
(
DWORD_PTR iArg,
DWORD_PTR ,
DWORD_PTR
)
    {
	// Get arguments
	DebugThreadCallArgs *pThreadCallArgs = &(*g_prgThreadCallArgs)[(int)iArg];
    IDebugApplication *  pDebugAppln     = pThreadCallArgs->pDebugAppln;
    DWORD                dwMethod        = pThreadCallArgs->dwMethod;
    void *               pvArg           = pThreadCallArgs->pvArg;

	// we won't reference the argument block again, so free it up now.
	pThreadCallArgs->dwMethod |= DEBUGGER_UNUSED_RECORD;

    BOOL fForceDebugger  = (dwMethod & (DEBUGGER_UI_BRING_DOCUMENT_TO_TOP|DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP)) != 0;
    BOOL fNeedDebuggerUI = (dwMethod & (DEBUGGER_UI_BRING_DOCUMENT_TO_TOP|DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP)) != 0;
    BOOL fNeedNodeEvents = (dwMethod & DEBUGGER_ON_REMOVE_CHILD) != 0;
    BOOL fNeedDebugger   = (dwMethod & ~DEBUGGER_ON_DESTROY) != 0;

    HRESULT hr = S_OK;

    IApplicationDebugger *pDebugger = NULL;
    IApplicationDebuggerUI *pDebuggerUI = NULL;
    IDebugApplicationNodeEvents *pNodeEvents = NULL;

    if (pDebugAppln == NULL)
        return E_POINTER;

    // Get the debugger
    if (fNeedDebugger)
        {
        hr = pDebugAppln->GetDebugger(&pDebugger);

        if (FAILED(hr))
            {
            // Debugger is not currently debugging our application.
            if (!fForceDebugger)
                return E_FAIL; // no debugger

            // Start the debugger and try again.
            hr = pDebugAppln->StartDebugSession();

            if (SUCCEEDED(hr))
                hr = pDebugAppln->GetDebugger(&pDebugger);
            }

        // Debugger UI is needed only for some methods
        if (SUCCEEDED(hr) && fNeedDebuggerUI)
            {
            hr = pDebugger->QueryInterface
                (
                IID_IApplicationDebuggerUI,
                reinterpret_cast<void **>(&pDebuggerUI)
                );
            }

        // Debugger UI is needed only for some methods
        if (SUCCEEDED(hr) && fNeedNodeEvents)
            {
            hr = pDebugger->QueryInterface
                (
                IID_IDebugApplicationNodeEvents,
                reinterpret_cast<void **>(&pNodeEvents)
                );
            }
        }

    // Call the desired method
    if (SUCCEEDED(hr))
        {
        switch (dwMethod)
            {
            case DEBUGGER_EVENT_ON_PAGEBEGIN:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ONPAGEBEGIN,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_EVENT_ON_PAGEEND:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ONPAGEEND,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ON_REFRESH_BREAKPOINT,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_ON_REMOVE_CHILD:
                {
                hr = pNodeEvents->onRemoveChild
                    (
                    static_cast<IDebugApplicationNode *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_ON_DESTROY:
                {
                hr = static_cast<IDebugDocumentTextEvents *>(pvArg)->onDestroy();
                break;
                }
            case DEBUGGER_UI_BRING_DOCUMENT_TO_TOP:
                {
                hr = pDebuggerUI->BringDocumentToTop
                    (
                    static_cast<IDebugDocumentText *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP:
                {
                hr = pDebuggerUI->BringDocumentContextToTop
                    (
                    static_cast<IDebugDocumentContext *>(pvArg)
                    );
                break;
                }
            default:
                hr = E_FAIL;
                break;
            }
        }

    // Cleanup
    if (pDebuggerUI) pDebuggerUI->Release();
    if (pNodeEvents) pNodeEvents->Release();
    if (pDebugger) pDebugger->Release();

    return hr;
    }

// The function calls using IDebugThreadCall
HRESULT InvokeDebuggerWithThreadSwitch
(
IDebugApplication *pDebugAppln,
DWORD              dwMethod,
void              *pvArg
)
    {
	// take these arguments and package them up in the array.  We will pass the
	// index to the callback handler.
	//
	// first look for a freed up element before creating a new one.

	for (int i = g_prgThreadCallArgs->length() - 1; i >= 0; --i)
		{
		DebugThreadCallArgs *pThreadCallArgs = &(*g_prgThreadCallArgs)[i];
		if (pThreadCallArgs->dwMethod & DEBUGGER_UNUSED_RECORD)
			{
			pThreadCallArgs->dwMethod    = dwMethod;
			pThreadCallArgs->pDebugAppln = pDebugAppln;
			pThreadCallArgs->pvArg       = pvArg;
			break;
			}
		}
	
	if (i < 0)
		{
		HRESULT hr = g_prgThreadCallArgs->append(DebugThreadCallArgs(dwMethod, pDebugAppln, pvArg));
		if (FAILED(hr))
			return hr;

		i = g_prgThreadCallArgs->length() - 1;
		}

    CDebugThreadDebuggerCall Call;
    return pDebugAppln->SynchronousCallInDebuggerThread
        (
        &Call, i, 0, 0
        );
    }


/*===================================================================
FCaesars

Query registry to determine if default debugger is Caesar's
(Script Debugger)
===================================================================*/

BOOL FCaesars()
	{
	static BOOL fCaesars = 0xBADF00D;
	HKEY  hKey = NULL;
	char  szRegPath[_MAX_PATH];
	DWORD dwSize = sizeof szRegPath;

	// Check to see if Ceasers is registered as the JIT debugger on this machine.

	if (fCaesars == 0xBADF00D)
		{
		fCaesars = FALSE;
		if (RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID\\{834128A2-51F4-11D0-8F20-00805F2CD064}\\LocalServer32"), &hKey) == ERROR_SUCCESS)
			{
			if (RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szRegPath, &dwSize) == ERROR_SUCCESS)
				{
				char szFile[_MAX_FNAME];
				_splitpath(szRegPath, NULL, NULL, szFile, NULL);
				if (_stricmp(szFile, "msscrdbg") == 0)
					fCaesars = TRUE;
				}

			CloseHandle (hKey);
			}
		}

	return fCaesars;
	}


/*===================================================================
DestroyDocumentTree

Recursively release all the nodes in a document tree.

Parameters
    IDebugApplication *pDocRoot         root of hierarchy to destroy
===================================================================*/
void
DestroyDocumentTree(IDebugApplicationNode *pDocRoot)
    {
    IEnumDebugApplicationNodes *pEnum;

    if (SUCCEEDED(pDocRoot->EnumChildren(&pEnum)) && pEnum != NULL)
        {
        IDebugApplicationNode *pDocNode;
        while (pEnum->Next(1, &pDocNode, NULL) == S_OK)
            DestroyDocumentTree(pDocNode);

        pEnum->Release();
        }

    // See if this is a directory node
    //
    IFileNode *pFileNode;
    if (SUCCEEDED(pDocRoot->QueryInterface(IID_IFileNode, reinterpret_cast<void **>(&pFileNode))))
        {
        // This is a directory node, only detach when its document count vanishes)
        if (pFileNode->DecrementDocumentCount() == 0)
            {
            pDocRoot->Detach();
            pDocRoot->Close();
            pDocRoot->Release();
            }

        pFileNode->Release();
        }
    else
        {
        // This node is a CTemplate (or one of its include files)
        pDocRoot->Detach();
        pDocRoot->Close();
        pDocRoot->Release();
        }

    }

/*===================================================================
CreateDocumentTree

Takes a path to be rooted at a node "pDocRoot", parses the path,
and creates a node for each component of the path. Returns the
leaf (Since the root is known) as its value.

This function is called from contexts where part of the document
tree may already exist, so EnumChildren is called and nodes are only
created when a child does not exist. When a node exists, we merely
descend into the tree.

NOTE:
    The intermediate nodes are created with a CFileNode document
    implementation.  The leaf node is not given a document provider
    - the caller must provide one.

Parameters
    wchar_t *          szDocPath    path of the document
    IDebugApplication *pDocParent   parent to attach the application tree to
    IDebugApplication **ppDocRoot   returns root of document hierarchy
    IDebugApplication **ppDocLeaf   returns document leaf node.
    wchar_t **        pwszLeaf      name of the leaf node

Returns
    HRESULT
===================================================================*/
HRESULT CreateDocumentTree
(
wchar_t *wszDocPath,
IDebugApplicationNode *pDocParent,
IDebugApplicationNode **ppDocRoot,
IDebugApplicationNode **ppDocLeaf,
wchar_t **pwszLeaf
)
    {
    HRESULT hr;
    BOOL fCreateOnly = FALSE;   // Set to TRUE when there is no need to check for duplicate node
    *ppDocRoot = *ppDocLeaf = NULL;

    // Ignore initial delimiters
    while (wszDocPath[0] == '/')
        ++wszDocPath;

    // Now loop over every component in the path, adding a node for each
    while (wszDocPath != NULL)
        {
        // Get next path component
        *pwszLeaf = wszDocPath;
        wszDocPath = wcschr(wszDocPath, L'/');
        if (wszDocPath)
            *wszDocPath++ = L'\0';

        // Check to see if this component is already a child or not
        BOOL fNodeExists = FALSE;
        if (!fCreateOnly)
            {
            IEnumDebugApplicationNodes *pEnum;
            if (SUCCEEDED(pDocParent->EnumChildren(&pEnum)) && pEnum != NULL)
                {
                IDebugApplicationNode *pDocChild;
                while (!fNodeExists && pEnum->Next(1, &pDocChild, NULL) == S_OK)
                    {
                    BSTR bstrName = NULL;
                    if (FAILED(hr = pDocChild->GetName(DOCUMENTNAMETYPE_APPNODE, &bstrName)))
                        return hr;

                    if (wcscmp(bstrName, *pwszLeaf) == 0)
                        {
                        // The name of this node is equal to the component.  Instead of
                        // creating a new node, descend into the tree.
                        //
                        fNodeExists = TRUE;
                        *ppDocLeaf = pDocChild;

                        // If '*ppDocRoot' hasn't been assigned to yet, this means that
                        // this is the first node found (and hence the root of the tree)
                        //
                        if (*ppDocRoot == NULL)
                            {
                            *ppDocRoot = pDocChild;
                            (*ppDocRoot)->AddRef();
                            }

                        // If this node is a CFileNode structure (we don't require it to be)
                        // then increment its (recursive) containing document count.
                        //
                        IFileNode *pFileNode;
                        if (SUCCEEDED(pDocChild->QueryInterface(IID_IFileNode, reinterpret_cast<void **>(&pFileNode))))
                            {
                            pFileNode->IncrementDocumentCount();
                            pFileNode->Release();
                            }
                        }

                    SysFreeString(bstrName);
                    pDocChild->Release();
                    }

                pEnum->Release();
                }
            }

        // Create a new node if the node was not found above.  Also, at this point,
        // to save time, we always set "fCreateOnly" to TRUE because if we are
        // forced to create a node at this level, we will need to create nodes at
        // all other levels further down
        //
        if (!fNodeExists)
            {
            fCreateOnly = TRUE;

            // Create the node
            if (FAILED(hr = g_pDebugApp->CreateApplicationNode(ppDocLeaf)))
                return hr;

            // Create a doc provider for the node - for intermediate nodes only
            if (wszDocPath != NULL) // intermediate node
                {
                CFileNode *pFileNode = new CFileNode;
                if (pFileNode == NULL ||
                    FAILED(hr = pFileNode->Init(*pwszLeaf)) ||
                    FAILED(hr = (*ppDocLeaf)->SetDocumentProvider(pFileNode)))
                    {
                    (*ppDocLeaf)->Release();
                    return E_OUTOFMEMORY;
                    }

                // New node, only one document (count started at 0, so this will set to 1)
                pFileNode->IncrementDocumentCount();

                // SetDocumentProvider() AddRef'ed
                pFileNode->Release();
                }

                // If '*ppDocRoot' hasn't been assigned to yet, this means that
                // this is the first node created (and hence the root of the tree)
                //
                if (*ppDocRoot == NULL)
                    {
                    *ppDocRoot = *ppDocLeaf;
                    (*ppDocRoot)->AddRef();
                    }

            // Attach the node
            if (FAILED(hr = (*ppDocLeaf)->Attach(pDocParent)))
                return hr;
            }

        // Descend
        pDocParent = *ppDocLeaf;
        }

    if (*ppDocLeaf)
        (*ppDocLeaf)->AddRef();

    return S_OK;
    }

/*===================================================================
Debugger

The purpose of this thread is to create an execution environment for
the Process Debug Manager (PDM). There is only one PDM per process,
and this does not really fit in other threads, so we dedicate a thread to this.

Parameters:
    LPVOID  params
                Points to a BOOL* which will be set to 1 when
                this thread is completely initialized.

Returns:
    0
===================================================================*/
void __cdecl Debugger(void *pvInit)
    {
    HRESULT hr;

    if (FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        {
        // Bug 87857: if we get E_INVALIDARG, we need to do a CoUninitialize
        if (hr == E_INVALIDARG)
            CoUninitialize();

        *static_cast<BOOL *>(pvInit) = TRUE;
        return;
        }

    if (FAILED(CoCreateInstance(
                    CLSID_ProcessDebugManager,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IProcessDebugManager,
                    reinterpret_cast<void **>(&g_pPDM))))

        {
        *static_cast<BOOL *>(pvInit) = TRUE;
        CoUninitialize();
        return;
        }

    *static_cast<BOOL *>(pvInit) = TRUE;
    while (TRUE)
        {
        DWORD dwRet = MsgWaitForMultipleObjects(1,
                                                &g_hPDMTermEvent,
                                                FALSE,
                                                INFINITE,
                                                QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
            break;

        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);
        }

    g_pPDM->Release();
    CoUninitialize();

    g_pPDM = NULL; // indication that the thread is gone
    }

/*===================================================================
HRESULT StartPDM()

kick off the PDM thread
===================================================================*/

HRESULT StartPDM()
    {
    BOOL fStarted = FALSE;

    g_hPDMTermEvent = IIS_CREATE_EVENT(
                          "g_hPDMTermEvent",
                          &g_hPDMTermEvent,
                          TRUE,
                          FALSE
                          );

    if( g_hPDMTermEvent == NULL )
        return E_FAIL;

    _beginthread(Debugger, 0, &fStarted);
    while (!fStarted)
        Sleep(100);

    if (g_pPDM == NULL)     // could not create the PDM for some reason
        {
        CloseHandle(g_hPDMTermEvent);
        g_hPDMTermEvent = NULL;
        return E_FAIL;
        }

    return S_OK;
    }

/*===================================================================
HRESULT InitDebugging

Initialize everything we need for debugging

===================================================================*/
HRESULT InitDebugging
(
CIsapiReqInfo *pIReq
)
    {
    HRESULT hr;

    // this stack size should cover the static string directly
    // below and the process pid.  If the app name is found, the
    // buffer is resized.

    STACK_BUFFER(tempWszDebugAppName, 128);

    // Start the PDM
    if (FAILED(hr = StartPDM()))
        return hr;

    Assert (g_pPDM);    // StartPDM succeeds ==> g_pPDM <> NULL

    ErrInitCriticalSection(&g_csDebugLock, hr);
    if (FAILED(hr))
        return hr;

    // Create the debug application & give it a name
    if (FAILED(hr = g_pPDM->CreateApplication(&g_pDebugApp)))
        goto LErrorCleanup;

    wchar_t *wszDebugAppName = (wchar_t *)tempWszDebugAppName.QueryPtr();
    wcscpy(wszDebugAppName, L"Microsoft Active Server Pages");   // DO NOT LOCALIZE THIS STRING

    if (g_fOOP) {

        // Bug 154300: If a friendly app. name exists, use it along with the PID for
        //             WAM identification.
        //
        // Declare some temporaries
        //
        DWORD dwApplMDPathLen;
        DWORD dwRequiredBuffer = 0;

        STACK_BUFFER( tempMDData, 2048 );

        BYTE  *prgbData = (BYTE *)tempMDData.QueryPtr();

        TCHAR *szApplMDPath = pIReq->QueryPszApplnMDPath();

        //
        //  if the webserver returned NULL for ApplnMDPath which is not expected we return an error.
        //
        if (!szApplMDPath)
        {
            hr = E_FAIL;
            goto LErrorCleanup;
        }

        // get friendly name from metabase
        hr = pIReq->GetAspMDData(
                        szApplMDPath,
                        MD_APP_FRIENDLY_NAME,
                        METADATA_INHERIT,
                        ASP_MD_UT_APP,
                        STRING_METADATA,
                        tempMDData.QuerySize(),
                        0,
                        prgbData,
                        &dwRequiredBuffer);

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
            {

            if (tempMDData.Resize(dwRequiredBuffer) == FALSE) {
                hr = E_OUTOFMEMORY;
            }
            else {
                prgbData = (BYTE *)tempMDData.QueryPtr();
                hr = pIReq->GetAspMDData(
                                    szApplMDPath,
                                    MD_APP_FRIENDLY_NAME,
                                    METADATA_INHERIT,
                                    ASP_MD_UT_APP,
                                    STRING_METADATA,
                                    dwRequiredBuffer,
                                    0,
                                    prgbData,
                                    &dwRequiredBuffer);
                }
            }

        // For OOP append process id
        if (SUCCEEDED(hr) && *reinterpret_cast<wchar_t *>(prgbData) != 0) {

            wchar_t *pwszAppName = reinterpret_cast<wchar_t *>(prgbData);

            // first thing we need to do is resize the buffer...

            if (tempWszDebugAppName.Resize((wcslen(wszDebugAppName) * 2)  // string already in buffer
                                           + (wcslen(pwszAppName) * 2)    // length of app name
                                           + 20                           // max size of a process ID
                                           + 10                           // various format chars from below
                                           + 2) == FALSE) {               // NULL termination
                hr = E_OUTOFMEMORY;
            }
            else {
                wszDebugAppName = (wchar_t *)tempWszDebugAppName.QueryPtr();
                _snwprintf(&wszDebugAppName[wcslen(wszDebugAppName)],
                           (tempWszDebugAppName.QuerySize()/2) - wcslen(wszDebugAppName),
                           L" (%s, %d)",
                           reinterpret_cast<wchar_t *>(prgbData),
                           GetCurrentProcessId());
            }
        }
        else {
            _snwprintf(&wszDebugAppName[wcslen(wszDebugAppName)],
                       (tempWszDebugAppName.QuerySize()/2) - wcslen(wszDebugAppName),
                       L" (%d)",
                       GetCurrentProcessId());
        }
        hr = S_OK;
    }

    if (FAILED(hr = g_pDebugApp->SetName(wszDebugAppName)))
        goto LErrorCleanup;

    if (FAILED(hr = g_pPDM->AddApplication(g_pDebugApp, &g_dwDenaliAppCookie)))
        goto LErrorCleanup;

    if (FAILED(hr = g_pDebugApp->GetRootNode(&g_pDebugAppRoot)))
        goto LErrorCleanup;

    // Init the hash table used for Keeping track of virtual server roots
    if (FAILED(hr = g_HashMDPath2DebugRoot.Init()))
        goto LErrorCleanup;

	// Create the array for passing data to debug thread
	if ((g_prgThreadCallArgs = new vector<DebugThreadCallArgs>) == NULL) {
		hr = E_OUTOFMEMORY;
		goto LErrorCleanup;
    }

    return S_OK;

LErrorCleanup:
    // Clean up some globals (some thing may be NULL and some not)
    if (g_pDebugAppRoot) {
        g_pDebugAppRoot->Release();
        g_pDebugAppRoot = NULL;
    }

    if (g_pDebugApp) {
        g_pDebugApp->Release();
        g_pDebugApp = NULL;
    }

    // Kill PDM thread if we started it up.
    if (g_pPDM) {
        SetEvent(g_hPDMTermEvent);

        while (g_pPDM)
            Sleep(100);

        CloseHandle(g_hPDMTermEvent);
        g_pPDM = NULL;

        DeleteCriticalSection(&g_csDebugLock);
    }

    return hr;
}

/*===================================================================
UnInitDebugging

Uninitialize debugging

NOTE: WE DO NOT RELEASE THE VIPER DEBUG ACTIVITY.
      (EVEN THOUGH INIT CREATES IT)

      THIS IS BECAUSE UNINIT MUST BE INVOKED WHILE SCRIPTS ON THE
      ACTIVITY ARE STILL RUNNING!
===================================================================*/
HRESULT UnInitDebugging()
    {
    // Clear and UnInit the hash tables (containing the application nodes)
    CDebugNodeElem *pNukeDebugNode = static_cast<CDebugNodeElem *>(g_HashMDPath2DebugRoot.Head());
    while (pNukeDebugNode != NULL)
        {
        CDebugNodeElem *pNext = static_cast<CDebugNodeElem *>(pNukeDebugNode->m_pNext);
        pNukeDebugNode->m_pServerRoot->Detach();
        pNukeDebugNode->m_pServerRoot->Close();
        pNukeDebugNode->m_pServerRoot->Release();
        delete pNukeDebugNode;
        pNukeDebugNode = pNext;
        }
    g_HashMDPath2DebugRoot.UnInit();

    DeleteCriticalSection(&g_csDebugLock);

    // Unlink the top node
    if (g_pDebugAppRoot)
        {
        g_pDebugAppRoot->Detach();
        g_pDebugAppRoot->Close();
        g_pDebugAppRoot->Release();
        }

    // Delete the application
    if (g_pDebugApp)
        {
        Assert (g_pPDM != NULL);

        // EXPLICITLY ignore failure result here:
        //     if Init() failed earlier, then RemoveApplication will fail here.
        g_pPDM->RemoveApplication(g_dwDenaliAppCookie);
        g_pDebugApp->Close();
        g_pDebugApp->Release();
        g_pDebugApp = NULL;
        }

    // Tell the PDM to suicide
    if (g_pPDM)
        {
        SetEvent(g_hPDMTermEvent);

        while (g_pPDM)
            Sleep(100);

        CloseHandle(g_hPDMTermEvent);
        }

	// delete the argument buffer
	delete g_prgThreadCallArgs;

    return S_OK;
    }

/*===================================================================
GetServerDebugRoot

Each virtual server has its own root in the application tree.

    (i.e. the tree looks like
            Microsoft ASP
                <Virtual Server 1 Name>
                    <Denali Application Name>
                        <Files>
                <Virtual Server 2 Name>
                    <Denali Application>
                        ...

Since there may be multiple applications per each server, the
server nodes are managed at one central location (here) so that
new applications get added to the correct nodes.
===================================================================*/
HRESULT GetServerDebugRoot
(
CIsapiReqInfo   *pIReq,
IDebugApplicationNode **ppDebugRoot
)
    {
    HRESULT hr = E_FAIL;

    STACK_BUFFER( tempMDData, 2048 );
    *ppDebugRoot = NULL;

    // Get the metabase path for this virtual server from the CIsapiReqInfo
    DWORD dwInstanceMDPathLen;
    char *szInstanceMDPath;

    STACK_BUFFER( instPathBuf, 128 );

    if (!SERVER_GET(pIReq, "INSTANCE_META_PATH", &instPathBuf, &dwInstanceMDPathLen))
        return HRESULT_FROM_WIN32(GetLastError());

    szInstanceMDPath = (char *)instPathBuf.QueryPtr();

    // See if we already have a node for this path - If not then create it and add to hash table

    EnterCriticalSection(&g_csDebugLock);
    CDebugNodeElem *pDebugNode = static_cast<CDebugNodeElem *>(g_HashMDPath2DebugRoot.FindElem(szInstanceMDPath, dwInstanceMDPathLen - 1));
    BOOL fDeleteDebugNode = FALSE;

    if (!pDebugNode)
        {
        // Node does not exist, so create a new application node.
        pDebugNode = new CDebugNodeElem;
        if (pDebugNode == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }

        fDeleteDebugNode = TRUE;

        if (FAILED(hr = pDebugNode->Init(szInstanceMDPath, dwInstanceMDPathLen - 1)))
        {
            goto LExit;
        }

        // Look up server name in metabase.
        BYTE *prgbData = (BYTE *)tempMDData.QueryPtr();
        DWORD dwRequiredBuffer = 0;
        hr = pIReq->GetAspMDDataA(
                            szInstanceMDPath,
                            MD_SERVER_COMMENT,
                            METADATA_INHERIT,
                            IIS_MD_UT_SERVER,
                            STRING_METADATA,
                            tempMDData.QuerySize(),
                            0,
                            prgbData,
                            &dwRequiredBuffer);

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {

            if (tempMDData.Resize(dwRequiredBuffer) == FALSE) {
                hr = E_OUTOFMEMORY;
            }
            else {
                prgbData = reinterpret_cast<BYTE *>(tempMDData.QueryPtr());
                hr = pIReq->GetAspMDDataA(
                                    szInstanceMDPath,
                                    MD_SERVER_COMMENT,
                                    METADATA_INHERIT,
                                    IIS_MD_UT_SERVER,
                                    STRING_METADATA,
                                    dwRequiredBuffer,
                                    0,
                                    prgbData,
                                    &dwRequiredBuffer);
            }
        }
        if (FAILED(hr))
            {
            // ServerComment does not exist, so construct using server name and port

            STACK_BUFFER( serverNameBuff, 16 );
            DWORD cbServerName;
            STACK_BUFFER( serverPortBuff, 10 );
            DWORD cbServerPort;
            STACK_BUFFER( debugNodeBuff, 30 );

            if (!SERVER_GET(pIReq, "LOCAL_ADDR", &serverNameBuff, &cbServerName)
                || !SERVER_GET(pIReq, "SERVER_PORT", &serverPortBuff, &cbServerPort)) {
                hr = E_FAIL;
                goto LExit;
            }

            char *szServerName = (char *)serverNameBuff.QueryPtr();
            char *szServerPort = (char*)serverPortBuff.QueryPtr();

            // resize the debugNodeBuff to hold <serverIP>:<port>'\0'.
            if (!debugNodeBuff.Resize(cbServerName + cbServerPort + 2)) {
                hr = E_OUTOFMEMORY;
                goto LExit;
            }
            // Syntax is <serverIP:port>
            char *szDebugNode = (char *)debugNodeBuff.QueryPtr();
            strcpyExA(strcpyExA(strcpyExA(szDebugNode, szServerName), ":"), szServerPort);

            // Convert to Wide Char
            hr = MultiByteToWideChar(CP_ACP, 0, szDebugNode, -1, reinterpret_cast<wchar_t *>(prgbData), tempMDData.QuerySize() / 2);
            if (FAILED(hr))
                goto LExit;
            }

        // We've got the metadata (ServerComment), create a debug node with this name
        IDebugApplicationNode *pServerRoot;
        if (FAILED(hr = g_pDebugApp->CreateApplicationNode(&pServerRoot)))
            goto LExit;

        // Create a doc provider for the node
        CFileNode *pFileNode = new CFileNode;
        if (pFileNode == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }

        if (FAILED(hr = pFileNode->Init(reinterpret_cast<wchar_t *>(prgbData))))
            goto LExit;

        if (FAILED(hr = pServerRoot->SetDocumentProvider(pFileNode)))
            goto LExit;

        // pFileNode has been AddRef'ed and we don't need it now.
        pFileNode->Release();

        // Attach to the UI
        if (FAILED(pServerRoot->Attach(g_pDebugAppRoot)))
            goto LExit;

        // OK, Now add this item to the hashtable (this eats the reference from creation)
        pDebugNode->m_pServerRoot = pServerRoot;
        g_HashMDPath2DebugRoot.AddElem(pDebugNode);
        fDeleteDebugNode = FALSE;
        }

    *ppDebugRoot = pDebugNode->m_pServerRoot;
    (*ppDebugRoot)->AddRef();
    hr = S_OK;

LExit:
    if (fDeleteDebugNode) {
        delete pDebugNode;
    }
    LeaveCriticalSection(&g_csDebugLock);
    return hr;
    }

/*===================================================================
  C  F i l e  N o d e

Implementation of CFileNode - trivial class
===================================================================*/

const GUID IID_IFileNode =
            { 0x41047bd2, 0xfe1e, 0x11d0, { 0x8f, 0x3f, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

CFileNode::CFileNode() : m_cRefs(1), m_cDocuments(0), m_wszName(NULL) {}
CFileNode::~CFileNode() { delete[] m_wszName; }


HRESULT
CFileNode::Init(wchar_t *wszName)
    {
    if ((m_wszName = new wchar_t [wcslen(wszName) + 1]) == NULL)
        return E_OUTOFMEMORY;

    wcscpy(m_wszName, wszName);
    return S_OK;
    }


HRESULT
CFileNode::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown ||
        uidInterface == IID_IDebugDocumentProvider ||
        uidInterface == IID_IFileNode)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }


ULONG
CFileNode::AddRef()
    {
    InterlockedIncrement(reinterpret_cast<long *>(&m_cRefs));
    return m_cRefs;
    }


ULONG
CFileNode::Release()
{
    LONG cRefs = InterlockedDecrement(reinterpret_cast<long *>(&m_cRefs));
	if (cRefs)
		return cRefs;
	delete this;
	return 0;	
}


HRESULT
CFileNode::GetDocument(IDebugDocument **ppDebugDoc)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }


HRESULT
CFileNode::GetName(DOCUMENTNAMETYPE, BSTR *pbstrName)
    {
    return ((*pbstrName = SysAllocString(m_wszName)) == NULL)? E_OUTOFMEMORY : S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\denali.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996-1999 Microsoft Corporation. All Rights Reserved.

Component: Main

File: denali.cpp

Owner: AndyMorr

This file contains the  I S A P I   C A L L B A C K   A P I S
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#undef DEFAULT_TRACE_FLAGS
#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "gip.h"
#include "mtacb.h"
#include "perfdata.h"
#include "activdbg.h"
#include "debugger.h"
#include "dbgutil.h"
#include "randgen.h"
#include "aspdmon.h"
#include "tlbcache.h"
#include "ie449.h"

#include "memcls.h"
#include "memchk.h"
#include "etwtrace.hxx"

// Globals

BOOL g_fShutDownInProgress = FALSE;
BOOL g_fInitStarted = FALSE;
BOOL g_fTerminateExtension = FALSE;

DWORD g_nIllStatesReported = 0;

LONG g_nOOMErrors = 0;

BOOL g_fOOMRecycleDisabled = FALSE;
BOOL g_fLazyContentPropDisabled = FALSE;
BOOL g_fUNCChangeNotificationEnabled = FALSE;
DWORD g_dwFileMonitoringTimeoutSecs = 5;                // Default 5 Seconds Time to Live (TTL) for monitoring files.

char g_szExtensionDesc[] = "Microsoft Active Server Pages 2.0";
GLOB gGlob;
BOOL g_fFirstHit = TRUE;
DWORD g_fFirstHitFailed = 0;
LONG  g_fUnhealthyReported = 0;

char g_pszASPModuleName[] = "ASP";

enum g_eInitCompletions {
        eInitMDReadConfigFail = 1,
        eInitTemplateCacheFail,
        eInitViperConfigFail,
        eInitViperReqMgrFail,
        eInitMBListenerFail
    };

DECLARE_DEBUG_PRINTS_OBJECT();

DECLARE_PLATFORM_TYPE();

//
// Etw Tracing
//
#define ASP_TRACE_MOF_FILE     L"AspMofResource"
#define ASP_IMAGE_PATH         L"Asp.dll"
CEtwTracer * g_pEtwTracer = NULL;

HRESULT AdjustProcessSecurityToAllowPowerUsersToWait();

// Out of process flag
BOOL g_fOOP = FALSE;

// session id cookie
char g_szSessionIDCookieName[CCH_SESSION_ID_COOKIE+1];

CRITICAL_SECTION    g_csEventlogLock;
CRITICAL_SECTION    g_csFirstHitLock;
CRITICAL_SECTION    g_csFirstMTAHitLock;
CRITICAL_SECTION    g_csFirstSTAHitLock;
HINSTANCE           g_hODBC32Lib;

// Added to support CacheExtensions
HINSTANCE           g_hDenali = (HINSTANCE)0;
HINSTANCE           g_hinstDLL = (HINSTANCE)0;
HMODULE             g_hResourceDLL = (HMODULE)0;

extern LONG g_nSessionObjectsActive;
extern DWORD g_nApplicationObjectsActive;

extern LONG g_nRequestsHung;
extern LONG g_nThreadsExecuting;

DWORD   g_nConsecutiveIllStates = 0;
DWORD   g_nRequestSamples[3] = {0,0,0};

class CHangDetectConfig {

public:

    CHangDetectConfig() {
        dwRequestThreshold = 1000;
        dwThreadsHungThreshold = 50;
        dwConsecIllStatesThreshold = 3;
        dwHangDetectionEnabled = TRUE;
    }

    void Init() {

        dwRequestThreshold = Glob(dwRequestQueueMax)/3;

        ReadRegistryValues();
    }

    DWORD   dwRequestThreshold;
    DWORD   dwThreadsHungThreshold;
    DWORD   dwConsecIllStatesThreshold;
    DWORD   dwHangDetectionEnabled;

private:

    void ReadRegistryValues() {

        DWORD   dwValue;

        if (SUCCEEDED(g_AspRegistryParams.GetHangDetRequestThreshold(&dwValue)))
            dwRequestThreshold = dwValue;

        if (SUCCEEDED(g_AspRegistryParams.GetHangDetThreadHungThreshold(&dwValue)))
            dwThreadsHungThreshold = dwValue;

        if (SUCCEEDED(g_AspRegistryParams.GetHangDetConsecIllStatesThreshold(&dwValue)))
            dwConsecIllStatesThreshold = dwValue;

        if (SUCCEEDED(g_AspRegistryParams.GetHangDetEnabled(&dwValue)))
            dwHangDetectionEnabled = dwValue;

    }
};

CHangDetectConfig g_HangDetectConfig;

// Cached BSTRs
BSTR g_bstrApplication = NULL;
BSTR g_bstrRequest = NULL;
BSTR g_bstrResponse = NULL;
BSTR g_bstrServer = NULL;
BSTR g_bstrCertificate = NULL;
BSTR g_bstrSession = NULL;
BSTR g_bstrScriptingNamespace = NULL;
BSTR g_bstrObjectContext = NULL;

extern IASPObjectContext  *g_pIASPDummyObjectContext;

// Forward references
HRESULT GlobInit();
HRESULT GlobUnInit();
HRESULT CacheStdTypeInfos();
HRESULT UnCacheStdTypeInfos();
HRESULT InitCachedBSTRs();
HRESULT UnInitCachedBSTRs();
HRESULT ShutDown();
HRESULT SendHtmlSubstitute(CIsapiReqInfo    *pIReq);
void    DoHangDetection(CIsapiReqInfo   *pIReq,  DWORD  totalReqs);
void    DoOOMDetection(CIsapiReqInfo   *pIReq,  DWORD  totalReqs);
BOOL    FReportUnhealthy();

BOOL FirstHitInit(CIsapiReqInfo    *pIReq);


// ATL support
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/*===================================================================
DllMain - Moved from clsfctry.cpp

Main entry point into the DLL.  Called by system on DLL load
and unload.

Returns:
    TRUE on success

Side effects:
    None.
===================================================================*/
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)
    {
/* Obsolete
    // Let the Proxy code get a crack at it
    if (!PrxDllMain(hinstDLL, dwReason, lpvReserved))
        return FALSE;
*/

    switch(dwReason)
        {
    case DLL_PROCESS_ATTACH:
        // hang onto the hinstance so we can use it to get to our string resources
        //
        g_hinstDLL = hinstDLL;

        // Here's an interesting optimization:
        // The following tells the system NOT to call us for Thread attach/detach
        // since we dont handle those calls anyway, this will speed things up a bit.
        // If this turns out to be a problem for some reason (cant imagine why),
        // just remove this again.
        DisableThreadLibraryCalls(hinstDLL);

        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

        }
    return TRUE;
    }

/*===================================================================
DWORD HandleHit

Given the CIsapiReqInfo construct a hit object to be queued
for execution

Parameters:
    pIReq  - CIsapiReqInfo

Returns:
    HSE_STATUS_PENDING if function is successful in queuing request
    HSE_STATUS_ERROR if not successful
===================================================================*/

DWORD HandleHit(CIsapiReqInfo    *pIReq)
    {
    int         errorId   = 0;
    BOOL        fRejected = FALSE;
    BOOL        fCompleted = FALSE;
    HRESULT     hr        = S_OK;
    DWORD       totalReqs;

    /*
     * We cant read the metabase until we have the WAM_EXEC_INFO, which
     * we dont have at DllInit time.  Therefore, we postpone reading the
     * metabase until now, but we do it only on the first hit.
     */
    if (g_fFirstHit)
    {
        EnterCriticalSection(&g_csFirstHitLock);

        // If someone initied while we were waiting for the CS,
        // then noop
        if (g_fFirstHit)
        {
            BOOL fT;

            fT = FirstHitInit(pIReq);
            Assert(fT);

            g_fFirstHit = FALSE;

            // Log error to the NT EventLog
            if (!fT)
            {
                // Log event to EventLog
                MSG_Error(IDS_FIRSTHIT_INIT_FAILED_STR);
            }

        }

        LeaveCriticalSection(&g_csFirstHitLock);
    }

    if (g_fFirstHitFailed)
    {
       // return 500 error.
        errorId = IDE_500_SERVER_ERROR;
        Handle500Error(errorId, pIReq);

        // We cannot return HSE_STATUS_ERROR because of a race condition.
        // We have queued the response for Async Completion (in Handle500Error).
        // It is the duty of the Async Completion routine to flag DONE_WITH_SESSION
        return pIReq->GetRequestStatus();
    }

#ifndef PERF_DISABLE
    if (!g_fPerfInited) // Init PERFMON data on first request
        {
        // FYI: leverage same CS as first hit lock
        EnterCriticalSection(&g_csFirstHitLock);

        // If someone initied while we were waiting for the CS,
        // then noop
        if (!g_fPerfInited)
            {
            if (SUCCEEDED(InitPerfDataOnFirstRequest(pIReq)))
                {
                    g_fPerfInited = TRUE;
                }
                else
                {
                    g_fPerfInited = FALSE;
                }
            }
        LeaveCriticalSection(&g_csFirstHitLock);
        }
    totalReqs = g_PerfData.Incr_REQTOTAL();
#endif

    if (Glob(fNeedUpdate))
        gGlob.Update(pIReq);


    if (IsShutDownInProgress())
        hr = E_FAIL;

    // Do hang detection tests

    DoHangDetection(pIReq, totalReqs);

    DoOOMDetection(pIReq, totalReqs);

    // Enforce the limit of concurrent browser requests
    if (SUCCEEDED(hr) && Glob(dwRequestQueueMax) &&
        (g_nBrowserRequests >= Glob(dwRequestQueueMax)))
        {
        hr = E_FAIL;
        fRejected = TRUE;
        }

    if (SUCCEEDED(hr))
        hr = CHitObj::NewBrowserRequest(pIReq, &fRejected, &fCompleted, &errorId);

    if (SUCCEEDED(hr))
        return pIReq->GetRequestStatus();

    if (fRejected)
        {
        if (Glob(fEnableAspHtmlFallBack))
        {
            // Instead of rejecting the request try to find
            // XXX_ASP.HTM file in the same directory and dump its contents
            hr = SendHtmlSubstitute(pIReq);

            if (hr == S_OK)
            {

#ifndef PERF_DISABLE
                //
                // Counts as request succeeded
                //
                g_PerfData.Incr_REQSUCCEEDED();
#endif
                //
                // HTML substitute sent
                //
                return pIReq->GetRequestStatus();
            }

            //
            // HTML substitute not found
            //
        }

        errorId = IDE_SERVER_TOO_BUSY;

#ifndef PERF_DISABLE
        g_PerfData.Incr_REQREJECTED();
#endif
        }

        Handle500Error(errorId, pIReq);

    return pIReq->GetRequestStatus();
    }

/*===================================================================
BOOL DllInit

Initialize Denali if not invoked by RegSvr32.  Only do inits here
that dont require Glob values loaded from the metabase.  For any
inits that require values loaded into Glob from the metabase, use
FirstHitInit.

Returns:
    TRUE on successful initialization
===================================================================*/
BOOL DllInit()
    {
    HRESULT hr;
    const   CHAR  szASPDebugRegLocation[] =
                        "System\\CurrentControlSet\\Services\\W3Svc\\ASP";

    DWORD  initStatus = 0;

    enum eInitCompletions {
        eInitResourceDll = 1,
        eInitDebugPrintObject,
        eInitTraceLogs,
        eInitPerfData,
        eInitEventLogCS,
        eInitFirstHitCS,
        eInitFirstMTAHitCS,
        eInitFirstSTAHitCS,
        eInitDenaliMemory,
        eInitDirMonitor,
        eInitGlob,
        eInitMemCls,
        eInitCachedBSTRs,
        eInitCacheStdTypeInfos,
        eInitTypelibCache,
        eInitErrHandle,
        eInitRandGenerator,
        eInitApplnMgr,
        eInit449,
        eInitTemplateCache,
        eInitIncFileMap,
        eInitFileAppMap,
        eInitScriptMgr,
        eInitTemplate__InitClass,
        eInitGIPAPI,
        eInitMTACallbacks
    };

    hr = InitializeResourceDll();
    if (FAILED(hr))
    {
        return FALSE;
    }

    initStatus = eInitResourceDll;

    CREATE_DEBUG_PRINT_OBJECT( g_pszASPModuleName);

    if ( !VALID_DEBUG_PRINT_OBJECT())
        goto errExit;



    initStatus = eInitDebugPrintObject;

    LOAD_DEBUG_FLAGS_FROM_REG_STR(szASPDebugRegLocation, 0);

#ifdef SCRIPT_STATS
    ReadRegistrySettings();
#endif // SCRIPT_STATS

    // Create ASP RefTrace Logs
    IF_DEBUG(TEMPLATE) CTemplate::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(SESSION) CSession::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(APPLICATION) CAppln::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(FCN) CASPDirMonitorEntry::gm_pTraceLog = CreateRefTraceLog(500, 0);

    initStatus = eInitTraceLogs;

    if (FAILED(PreInitPerfData()))
        goto errExit;

    initStatus = eInitPerfData;

    DBGPRINTF((DBG_CONTEXT, "ASP Init -- PerfMon Data PreInit\n"));

    ErrInitCriticalSection( &g_csEventlogLock, hr );
    if (FAILED(hr))
        goto errExit;

    initStatus = eInitEventLogCS;

    ErrInitCriticalSection( &g_csFirstHitLock, hr );
    if (FAILED(hr))
        goto errExit;

    initStatus = eInitFirstHitCS;

    ErrInitCriticalSection( &g_csFirstMTAHitLock, hr );
    if (FAILED(hr))
        goto errExit;

    initStatus = eInitFirstMTAHitCS;

    ErrInitCriticalSection( &g_csFirstSTAHitLock, hr );
    if (FAILED(hr))
        goto errExit;

    initStatus = eInitFirstSTAHitCS;

#ifdef DENALI_MEMCHK
    if (FAILED(DenaliMemoryInit()))
        goto errExit;
#else
    if (FAILED(AspMemInit()))
        goto errExit;
#endif
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Denali Memory Init\n"));

    initStatus = eInitDenaliMemory;

    g_pDirMonitor = new CDirMonitor;

    if (g_pDirMonitor == NULL) {
        goto errExit;
    }

    initStatus = eInitDirMonitor;

    _Module.Init(ObjectMap, g_hinstDLL, &LIBID_ASPTypeLibrary);

    if (FAILED(GlobInit()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Glob Init\n"));

    initStatus = eInitGlob;

    DWORD dwData = 0;

    if (SUCCEEDED(g_AspRegistryParams.GetDisableOOMRecycle(&dwData)))
        g_fOOMRecycleDisabled = dwData;

    if (SUCCEEDED(g_AspRegistryParams.GetDisableLazyContentPropagation(&dwData)))
        g_fLazyContentPropDisabled = dwData;

    if (SUCCEEDED(g_AspRegistryParams.GetChangeNotificationForUNCEnabled(&dwData)))
        g_fUNCChangeNotificationEnabled = dwData;

    // Read the Registry to see if a timeout value has been added.
    if (SUCCEEDED(g_AspRegistryParams.GetFileMonitoringTimeout(&dwData)))
        g_dwFileMonitoringTimeoutSecs = dwData;


    if (FAILED(InitMemCls()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Per-Class Cache Init\n"));

    initStatus = eInitMemCls;

    if (FAILED(InitCachedBSTRs()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Cached BSTRs Init\n"));

    initStatus = eInitCachedBSTRs;

    if (FAILED(CacheStdTypeInfos()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Cache Std TypeInfos\n"));

    initStatus = eInitCacheStdTypeInfos;

    if (FAILED(g_TypelibCache.Init()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Typelib Cache Init\n"));

    initStatus = eInitTypelibCache;

    if (FAILED(ErrHandleInit()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Err Handler Init\n"));

    initStatus = eInitErrHandle;

    srand( (unsigned int) time(NULL) );
    if (FAILED(g_SessionIdGenerator.Init()))    // seed session id
        goto errExit;

    // Init new Exposed Session Id variable
    if (FAILED(g_ExposedSessionIdGenerator.Init(g_SessionIdGenerator)))    // seed exposed session id
    	goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- SessionID Generator Init\n"));

    if (FAILED(InitRandGenerator()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- RandGen Init\n"));

    initStatus = eInitRandGenerator;

    if (FAILED(g_ApplnMgr.Init()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Appln Mgr Init\n"));

    initStatus = eInitApplnMgr;

    if (FAILED(Init449()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- 449 Mgr Init\n"));

    initStatus = eInit449;

    // Note: Template cache manager is inited in two phases.  Do first here.
    if (FAILED(g_TemplateCache.Init()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Template Cache Init\n"));

    initStatus = eInitTemplateCache;

    if (FAILED(g_IncFileMap.Init()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Inc File Users Init\n"));

    initStatus = eInitIncFileMap;

    if (FAILED(g_FileAppMap.Init()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- File-Application Map Init\n"));


    initStatus = eInitFileAppMap;

    if (FAILED(g_ScriptManager.Init()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Script Manager Init\n"));

    initStatus = eInitScriptMgr;

    if (FAILED(CTemplate::InitClass()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- CTemplate Init Class\n"));

    initStatus = eInitTemplate__InitClass;

    if (FAILED(g_GIPAPI.Init()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Global Interface API Init\n"));

    initStatus = eInitGIPAPI;


    if (FAILED(InitMTACallbacks()))
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- MTA Callbacks Init\n"));

    initStatus = eInitMTACallbacks;

    if (!RequestSupportInit())
        goto errExit;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Request Support Init\n"));

    //
    // Intialize Trace
    //
    g_pEtwTracer = new CEtwTracer();
    if (g_pEtwTracer != NULL)
    {
        DWORD Status;
        Status = g_pEtwTracer->Register(&AspControlGuid,
                                ASP_IMAGE_PATH,
                                ASP_TRACE_MOF_FILE );
        if (Status != ERROR_SUCCESS)
        {
           delete g_pEtwTracer;
           g_pEtwTracer = NULL;
        }
    }
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Event Tracer Init\n"));

    AdjustProcessSecurityToAllowPowerUsersToWait();

    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Denali DLL Initialized\n"));

#ifdef LOG_FCNOTIFICATIONS
    LfcnCreateLogFile();
#endif //LOG_FCNOTIFICATIONS

    return TRUE;

errExit:

    // we should never be here.  If we do get here, in checked builds we should break.

    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Error in DllInit.  initStatus = %d\n", initStatus));

    Assert(0);

    switch (initStatus) {
        case eInitMTACallbacks:
            UnInitMTACallbacks();
        case eInitGIPAPI:
            g_GIPAPI.UnInit();
        case eInitTemplate__InitClass:
            CTemplate::UnInitClass();
        case eInitScriptMgr:
            g_ScriptManager.UnInit();
        case eInitFileAppMap:
                g_FileAppMap.UnInit();
                if (g_pDirMonitor) {
                    g_pDirMonitor->Cleanup();
                }
        case eInitIncFileMap:
            g_IncFileMap.UnInit();
        case eInitTemplateCache:
            g_TemplateCache.UnInit();
        case eInit449:
            UnInit449();
        case eInitApplnMgr:
            g_ApplnMgr.UnInit();
        case eInitRandGenerator:
            UnInitRandGenerator();
        case eInitErrHandle:
            ErrHandleUnInit();
        case eInitTypelibCache:
            g_TypelibCache.UnInit();
        case eInitCacheStdTypeInfos:
            UnCacheStdTypeInfos();
        case eInitCachedBSTRs:
            UnInitCachedBSTRs();
        case eInitMemCls:
            UnInitMemCls();
        case eInitGlob:
            GlobUnInit();
        case eInitDirMonitor:
            delete g_pDirMonitor;
            g_pDirMonitor = NULL;
        case eInitDenaliMemory:
#ifdef DENALI_MEMCHK
            DenaliMemoryUnInit();
#else
            AspMemUnInit();
#endif
        case eInitFirstSTAHitCS:
            DeleteCriticalSection( &g_csFirstSTAHitLock );
        case eInitFirstMTAHitCS:
            DeleteCriticalSection( &g_csFirstMTAHitLock );
        case eInitFirstHitCS:
            DeleteCriticalSection( &g_csFirstHitLock );
        case eInitEventLogCS:
            DeleteCriticalSection( &g_csEventlogLock );
        case eInitTraceLogs:
            IF_DEBUG(TEMPLATE) DestroyRefTraceLog(CTemplate::gm_pTraceLog);
            IF_DEBUG(SESSION) DestroyRefTraceLog(CSession::gm_pTraceLog);
            IF_DEBUG(APPLICATION) DestroyRefTraceLog(CAppln::gm_pTraceLog);
            IF_DEBUG(FCN) DestroyRefTraceLog(CASPDirMonitorEntry::gm_pTraceLog);

        case eInitDebugPrintObject:
            DELETE_DEBUG_PRINT_OBJECT();
        case eInitResourceDll:
            UninitializeResourceDll();
    }

    return FALSE;

    }

/*===================================================================
BOOL FirstHitInit

Initialize any ASP values that can not be inited at DllInit time.

Returns:
    TRUE on successful initialization
===================================================================*/
BOOL FirstHitInit
(
CIsapiReqInfo    *pIReq
)
    {
    HRESULT hr;

    DWORD  FirstHitInitStatus = 0;;

    /*
     * In the out of proc case, being able to call the metabase relies on having
     * told WAM that we are a "smart" client
     */

    // ReadConfigFromMD uses pIReq - need to bracket
    hr = ReadConfigFromMD(pIReq, NULL, TRUE);
    if (FAILED(hr))
        FirstHitInitStatus = eInitMDReadConfigFail;

    // Initialize Debugging
    if (RevertToSelf())  // No Debugging on Win95
        {
        // Don't care whether debugging initializaiton succeeds or not.  The most likely
        // falure is debugger not installed on the machine.
        //
        if (SUCCEEDED(InitDebugging(pIReq)))
        {
            DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Debugging Initialized\n"));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Debugger Initialization Failed\n"));
        }

        DBG_REQUIRE( SetThreadToken(NULL, pIReq->QueryImpersonationToken()) );
    }

    if (FAILED(hr))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Metadata loaded successfully\n"));

    // Do FirstHitInit for the Template Cache Manager.  Primarily initializes
    // the Persisted Template Cache
    if (FAILED(hr = g_TemplateCache.FirstHitInit(pIReq)))
    {
        FirstHitInitStatus = eInitTemplateCacheFail;
        goto LExit;
    }
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Template Cache Initialized\n"));

    // Configure MTS
    if (FAILED(hr = ViperConfigure()))
    {
        FirstHitInitStatus = eInitViperConfigFail;
        goto LExit;
    }
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: MTS configured\n"));

    //
    // we need to initialize the CViperReqManager here because it needs some metabase props
    //
    if (FAILED(hr = g_ViperReqMgr.Init()))
    {
        FirstHitInitStatus = eInitViperReqMgrFail;
        goto LExit;
    }
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: CViperReqManager configured\n"));


    //
    // Initialize Hang Detection Configuration
    //
    g_HangDetectConfig.Init();
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Hang Detection configured\n"));

    //
    //  Initialize ApplnMgr to listen to Metabase changes.
    //
    if (FAILED(hr = g_ApplnMgr.InitMBListener()))
    {
        FirstHitInitStatus = eInitMBListenerFail;
        goto LExit;
    }
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: ApplnMgr Metabase Listener configured\n"));

    DBGPRINTF((DBG_CONTEXT, "ASP First Hit Initialization complete\n"));

LExit:
    if (FAILED(hr))
        g_fFirstHitFailed = FirstHitInitStatus;
    Assert(SUCCEEDED(hr));
    return SUCCEEDED(hr);
    }

/*===================================================================
void DllUnInit

UnInitialize Denali DLL if not invoked by RegSvr32

Returns:
    NONE

Side effects:
    NONE
===================================================================*/
void DllUnInit( void )
    {
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- %d Apps %d Sessions %d Requests\n",
                g_nApplications, g_nSessions, g_nBrowserRequests));

    g_fShutDownInProgress = TRUE;

    ShutDown();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ShutDown Processing\n" ));

    UnInitMTACallbacks();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- MTA Callbacks\n" ));

    UnInitRandGenerator();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- RandGen\n"));

    UnInit449();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- 449 Mgr\n"));

    g_ApplnMgr.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Application Manager\n" ));

    g_ScriptManager.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Script Manager\n" ));

    if (!g_fFirstHitFailed || g_fFirstHitFailed > eInitViperConfigFail)
    {
        g_TemplateCache.UnInit();
        DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Template Cache\n" ));
    }

    g_IncFileMap.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- IncFileMap\n" ));

    g_FileAppMap.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- File-Application Map\n" ));

    if (g_pDirMonitor) {
        g_pDirMonitor->Cleanup();
        DBGPRINTF((DBG_CONTEXT,  "ASP UNInit -- Directory Monitor\n" ));
    }


    CTemplate::UnInitClass();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- CTemplate\n" ));

    g_TypelibCache.UnInit();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- Typelib Cache\n"));

    UnCacheStdTypeInfos();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- TypeInfos\n" ));

    g_GIPAPI.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- GIP\n" ));


    ErrHandleUnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ErrHandler\n" ));

    GlobUnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Glob\n" ));

    UnInitCachedBSTRs();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Cached BSTRs\n" ));

    //////////////////////////////////////////////////////////
    // Wait for the actual session or Application objects to be destroyed.
    // The g_nSessions global tracks the init/uninit of session
    // objects but not the memory itself.  This presents a
    // problem when something outside of ASP holds a reference
    // to a session object or one of the contained intrinsics.
    // One case of this is the revoking of a git'd transaction
    // object.  Turns out the revoke can happen asynchronously.
    //
    // NOTE!!! - This needs to be done BEFORE uniniting the
    // mem classes since these objects are in the acache.

    // Wait for Sessions objects to shutdown.
    LONG    lastCount = g_nSessionObjectsActive;
    DWORD   loopCount = 50;

    while( (g_nSessionObjectsActive > 0) && (loopCount--) )
    {
        if (lastCount != g_nSessionObjectsActive)
        {
            lastCount = g_nSessionObjectsActive;
            loopCount = 50;
        }
        Sleep (100);
    }


    // Wait for Application objects to shutdown.
    lastCount = g_nApplicationObjectsActive;
    loopCount = 50;

    while( (g_nApplicationObjectsActive > 0) && (loopCount--) )
    {
        if (lastCount != g_nApplicationObjectsActive)
        {
            lastCount = g_nApplicationObjectsActive;
            loopCount = 50;
        }
        Sleep (100);
    }

    // We have waited too long. Proceed with shutdown.

    UnInitMemCls();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Per-Class Cache\n" ));

    // Destroy ASP RefTrace Logs
    IF_DEBUG(TEMPLATE) DestroyRefTraceLog(CTemplate::gm_pTraceLog);
    IF_DEBUG(SESSION) DestroyRefTraceLog(CSession::gm_pTraceLog);
    IF_DEBUG(APPLICATION) DestroyRefTraceLog(CAppln::gm_pTraceLog);
    IF_DEBUG(FCN) DestroyRefTraceLog(CASPDirMonitorEntry::gm_pTraceLog);

    if (g_pIASPDummyObjectContext)
        g_pIASPDummyObjectContext->Release();

    _Module.Term();

    delete g_pDirMonitor;
    g_pDirMonitor = NULL;

    if (g_pEtwTracer != NULL) {
        g_pEtwTracer->UnRegister();
        delete g_pEtwTracer;
        g_pEtwTracer = NULL;
    }

    //  UnInitODBC();
    // Note: the memmgr uses perf counters, so must be uninited before the perf counters are uninited
#ifdef DENALI_MEMCHK
    DenaliMemoryUnInit();
#else
    AspMemUnInit();
#endif
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Memory Manager\n" ));

    UnInitPerfData();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Perf Counters\n" ));

    UnPreInitPerfData();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Perf Counters\n" ));

    // Viper Request manager is the last to be initialized. So if anything failed dont Uninitialize.
    if (!g_fFirstHitFailed)
    {
        g_ViperReqMgr.UnInit();
        DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- CViperReqManager\n" ));
    }

    DBGPRINTF((DBG_CONTEXT,  "ASP Uninitialized\n" ));

#ifdef LOG_FCNOTIFICATIONS
    LfcnUnmapLogFile();
#endif //LOG_FCNOTIFICATIONS

    // Deleting the following CS's must be last.  Dont put anything after this
    DeleteCriticalSection( &g_csFirstMTAHitLock );
    DeleteCriticalSection( &g_csFirstSTAHitLock );
    DeleteCriticalSection( &g_csFirstHitLock );
    DeleteCriticalSection( &g_csEventlogLock );

    DELETE_DEBUG_PRINT_OBJECT();

    UninitializeResourceDll();

    }

/*===================================================================
GetExtensionVersion

Mandatory server extension call which returns the version number of
the ISAPI spec that we were built with.

Returns:
    TRUE on success

Side effects:
    None.
===================================================================*/
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pextver)
    {
    // This DLL can be inited only once
    if (g_fShutDownInProgress ||
        InterlockedExchange((LPLONG)&g_fInitStarted, TRUE))
        {
        SetLastError(ERROR_BUSY);
        return FALSE;
        }

    if (!DllInit())
        {
        SetLastError(ERROR_BUSY);
        return FALSE;
        }

    pextver->dwExtensionVersion =
            MAKELONG(HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
    strcpy(pextver->lpszExtensionDesc, g_szExtensionDesc);
    return TRUE;
    }

/*===================================================================
HttpExtensionProc

Main entry point into the DLL for the (ActiveX) Internet Information Server.

Returns:
    DWord indicating status of request.
    HSE_STATUS_PENDING for normal return
        (This indicates that we will process the request, but havent yet.)

Side effects:
    None.
===================================================================*/
DWORD WINAPI HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB)
    {
#ifdef SCRIPT_STATS
    InterlockedIncrement(&g_cHttpExtensionsExecuting);
#endif // SCRIPT_STATS

    CIsapiReqInfo   *pIReq = new CIsapiReqInfo(pECB);

    if (pIReq == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return HSE_STATUS_ERROR;
    }

#ifndef PERF_DISABLE
    g_PerfData.Add_REQTOTALBYTEIN
        (
        pIReq->QueryCchQueryString()
        + strlen( pIReq->ECB()->lpszPathTranslated )
        + pIReq->QueryCbTotalBytes()
        );
#endif

    HandleHit(pIReq);

#ifdef SCRIPT_STATS
    InterlockedDecrement(&g_cHttpExtensionsExecuting);
#endif // SCRIPT_STATS

    pIReq->Release();

    // Always return HSE_STATUS_PENDING and let CIsapiReqInfo Destructor do the DONE_WITH_SESSION
    return HSE_STATUS_PENDING;

    }

/*===================================================================
TerminateExtension

IIS is supposed to call this entry point to unload ISAPI DLLs.

Returns:
    NONE

Side effects:
    Uninitializes the Denali ISAPI DLL if asked to.
===================================================================*/
BOOL WINAPI TerminateExtension( DWORD dwFlag )
    {
    if ( dwFlag == HSE_TERM_ADVISORY_UNLOAD )
        return TRUE;

    if ( dwFlag == HSE_TERM_MUST_UNLOAD )
        {
        // If already shutdown don't uninit twice.
        if (g_fShutDownInProgress)
            return TRUE;

        // make sure this is a CoInitialize()'d thread
        HRESULT hr = CoInitialize(NULL);

        if (hr == RPC_E_CHANGED_MODE)
            {
            // already coinitialized MUTLITREADED - OK
            DllUnInit();
            }
        else if (SUCCEEDED(hr))
            {
            DllUnInit();

            // need to CoUninit() because CoInit() Succeeded
            CoUninitialize();
            }
        else  //Should never reach here.
            {
            g_fTerminateExtension = TRUE;
            Assert (FALSE);
            }

        return TRUE;
        }

    return FALSE;
    }

/*===================================================================
HRESULT ShutDown

ASP Processing ShutDown logic. (Moved from ThreadManager::UnInit())

Returns:
    HRESULT - S_OK on success

Side effects:
    May be slow. Kills all requests/sessions/applications
===================================================================*/
HRESULT ShutDown()
    {
    long iT;
    const DWORD dwtLongWait  = 1000;  // 1 sec
    const DWORD dwtShortWait = 100;   // 1/10 sec

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: %d apps (%d restarting), %d sessions\n",
                g_nApplications, g_nApplicationsRestarting, g_nSessions ));

    //////////////////////////////////////////////////////////
    // Stop change notification on files in template cache

    g_TemplateCache.ShutdownCacheChangeNotification();


    //////////////////////////////////////////////////////////
    // Shut down debugging, which will have the effect of
    // resuming scripts stopped at a breakpoint.
    //
    // (otherwise stopping running scripts will hang later)

    if (g_pPDM)
        {
        g_TemplateCache.RemoveApplicationFromDebuggerUI(NULL);  // remove all document nodes
        UnInitDebugging();                                      // kill PDM
        DBGPRINTF((DBG_CONTEXT,  "ASP Shutdown: PDM Closed\n" ));
        }

    //////////////////////////////////////////////////////////
    // Drain down all pending browser requests

    if (g_nBrowserRequests > 0)
        {
        // Give them a little time each
        for (iT = 2*g_nBrowserRequests; g_nBrowserRequests > 0 && iT > 0; iT--)
            Sleep(dwtShortWait);

        if (g_nBrowserRequests > 0)
            {
            // Still there - kill scripts and wait again
            g_ScriptManager.EmptyRunningScriptList();

            for (iT = 2*g_nBrowserRequests; g_nBrowserRequests > 0 && iT > 0; iT--)
                Sleep(dwtShortWait);
            }
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Requests drained: %d remaining\n",
                g_nBrowserRequests));

    //////////////////////////////////////////////////////////
    // Kill any remaining engines running scripts

    g_ScriptManager.EmptyRunningScriptList();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Scripts killed\n"));

    //////////////////////////////////////////////////////////
    // Wait till there are no appications restarting

    g_ApplnMgr.Lock();
    while (g_nApplicationsRestarting > 0)
        {
        g_ApplnMgr.UnLock();
        Sleep(dwtShortWait);
        g_ApplnMgr.Lock();
        }
    g_ApplnMgr.UnLock();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: 0 applications restarting\n"));

    //////////////////////////////////////////////////////////
    // Make this thread's priority higher than that of worker threads

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    //////////////////////////////////////////////////////////
    // For each application queue up all its sessions for deletion

    CApplnIterator ApplnIterator;
    ApplnIterator.Start();
    CAppln *pAppln;
    while (pAppln = ApplnIterator.Next())
        {
        // remove link to ATQ scheduler (even if killing of sessions fails)
        pAppln->PSessionMgr()->UnScheduleSessionKiller();

        for (iT = pAppln->GetNumSessions(); iT > 0; iT--)
            {
            pAppln->PSessionMgr()->DeleteAllSessions(TRUE);

            if (pAppln->GetNumSessions() == 0) // all gone?
                break;

            Sleep(dwtShortWait);
            }
        }
    ApplnIterator.Stop();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: All sessions queued up for deletion. nSessions=%d\n",
                g_nSessions));

    //////////////////////////////////////////////////////////
    // Wait till all sessions are gone (UnInited)

    while (g_nSessions > 0)
        {
        // Wait for a maximum of 0.1 sec x # of sessions
        for (iT = g_nSessions; g_nSessions > 0 && iT > 0; iT--)
            Sleep(dwtShortWait);

        if (g_nSessions > 0)
            g_ScriptManager.EmptyRunningScriptList();   // Kill runaway Session_OnEnd scripts
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Finished waiting for sessions to go away. nSessions=%d\n",
                g_nSessions));

    //////////////////////////////////////////////////////////
    // Queue up all application objects for deletion

    g_ApplnMgr.DeleteAllApplications();
    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: All applications queued up for deletion. nApplications=%d\n",
                g_nApplications));

    //////////////////////////////////////////////////////////
    // Wait till all applications are gone (UnInited)

    while (g_nApplications > 0)
        {
        // Wait for a maximum of 1 sec x # of applications
        for (iT = g_nApplications; g_nApplications > 0 && iT > 0; iT--)
            Sleep(dwtLongWait);

        if (g_nApplications > 0)
            g_ScriptManager.EmptyRunningScriptList();   // Kill runaway Applications_OnEnd scripts
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Finished waiting for applications to go away. nApplications=%d\n",
                g_nApplications));

    /////////////////////////////////////////////////////////
    // Wait on the CViperAsyncRequest objects. COM holds the
    // final reference to these so we need to let the activity
    // threads release any outstanding references before we
    // exit.

    while( g_nViperRequests > 0 )
    {
        Sleep( dwtShortWait );
    }


    //////////////////////////////////////////////////////////
    // Free up libraries to force call of DllCanUnloadNow()
    //    Component writers should put cleanup code in the DllCanUnloadNow() entry point.

    CoFreeUnusedLibraries();

    //////////////////////////////////////////////////////////
    // Kill Debug Activity if any

    if (g_pDebugActivity)
        delete g_pDebugActivity;

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Debug Activity destroyed\n"));

    //////////////////////////////////////////////////////////

    return S_OK;
    }

/*===================================================================
HRESULT GlobInit

Get all interesting global values (mostly from registry)

Returns:
    HRESULT - S_OK on success

Side effects:
    fills in glob.  May be slow
===================================================================*/
HRESULT GlobInit()
{
    //
    // BUGBUG - This really needs to be provided either through
    // a server support function or via the wamexec
    //

    char szModule[MAX_PATH+1];
    if (GetModuleFileNameA(NULL, szModule, MAX_PATH) > 0)
    {
        int cch = strlen(szModule);
        if (cch > 12 && stricmp(szModule+cch-12, "inetinfo.exe") == 0)
        {
            g_fOOP = FALSE;
        }
        else if ( cch > 8 && stricmp( szModule+cch-8, "w3wp.exe" ) == 0 )
        {
            g_fOOP = FALSE;
        }
        else
        {
            g_fOOP = TRUE;
        }
    }

    // Init gGlob
    return gGlob.GlobInit();
}

/*===================================================================
GlobUnInit

It is a macro now. see glob.h

Returns:
    HRESULT - S_OK on success

Side effects:
    memory freed.
===================================================================*/
HRESULT GlobUnInit()
    {
    return gGlob.GlobUnInit();
    }

/*===================================================================
InitCachedBSTRs

Pre-create frequently used BSTRs
===================================================================*/
HRESULT InitCachedBSTRs()
    {
    g_bstrApplication        = SysAllocString(WSZ_OBJ_APPLICATION);
    g_bstrRequest            = SysAllocString(WSZ_OBJ_REQUEST);
    g_bstrResponse           = SysAllocString(WSZ_OBJ_RESPONSE);
    g_bstrServer             = SysAllocString(WSZ_OBJ_SERVER);
    g_bstrCertificate        = SysAllocString(WSZ_OBJ_CERTIFICATE);
    g_bstrSession            = SysAllocString(WSZ_OBJ_SESSION);
    g_bstrScriptingNamespace = SysAllocString(WSZ_OBJ_SCRIPTINGNAMESPACE);
    g_bstrObjectContext      = SysAllocString(WSZ_OBJ_OBJECTCONTEXT);

    return
        (
        g_bstrApplication &&
        g_bstrRequest &&
        g_bstrResponse &&
        g_bstrServer &&
        g_bstrCertificate &&
        g_bstrSession &&
        g_bstrScriptingNamespace &&
        g_bstrObjectContext
        )
        ? S_OK : E_OUTOFMEMORY;
    }

/*===================================================================
UnInitCachedBSTRs

Delete frequently used BSTRs
===================================================================*/
HRESULT UnInitCachedBSTRs()
    {
    if (g_bstrApplication)
        {
        SysFreeString(g_bstrApplication);
        g_bstrApplication = NULL;
        }
    if (g_bstrRequest)
        {
        SysFreeString(g_bstrRequest);
        g_bstrRequest = NULL;
        }
    if (g_bstrResponse)
        {
        SysFreeString(g_bstrResponse);
        g_bstrResponse = NULL;
        }
    if (g_bstrServer)
        {
        SysFreeString(g_bstrServer);
        g_bstrServer = NULL;
        }
    if (g_bstrCertificate)
        {
        SysFreeString(g_bstrCertificate);
        g_bstrCertificate = NULL;
        }
    if (g_bstrSession)
        {
        SysFreeString(g_bstrSession);
        g_bstrSession = NULL;
        }
    if (g_bstrScriptingNamespace)
        {
        SysFreeString(g_bstrScriptingNamespace);
        g_bstrScriptingNamespace = NULL;
        }
    if (g_bstrObjectContext)
        {
        SysFreeString(g_bstrObjectContext);
        g_bstrObjectContext = NULL;
        }
    return S_OK;
    }

// Cached typeinfo's
ITypeInfo   *g_ptinfoIDispatch = NULL;              // Cache IDispatch typeinfo
ITypeInfo   *g_ptinfoIUnknown = NULL;               // Cache IUnknown typeinfo
ITypeInfo   *g_ptinfoIStringList = NULL;            // Cache IStringList typeinfo
ITypeInfo   *g_ptinfoIRequestDictionary = NULL;     // Cache IRequestDictionary typeinfo
ITypeInfo   *g_ptinfoIReadCookie = NULL;            // Cache IReadCookie typeinfo
ITypeInfo   *g_ptinfoIWriteCookie = NULL;           // Cache IWriteCookie typeinfo

/*===================================================================
CacheStdTypeInfos

This is kindofa funny OA-threading bug workaround and perf improvement.
Because we know that they typinfo's for IUnknown and IDispatch are
going to be used like mad, we will load them on startup and keep
them addref'ed.  Without this, OA would be loading and unloading
their typeinfos on almost every Invoke.

Also, cache denali's typelib so everyone can get at it, and
cache tye typeinfo's of all our non-top-level intrinsics.

Returns:
    HRESULT - S_OK on success

Side effects:
===================================================================*/
HRESULT CacheStdTypeInfos()
    {
    HRESULT hr = S_OK;
    ITypeLib *pITypeLib = NULL;
    CMBCSToWChar    convStr;

    /*
     * Load the typeinfos for IUnk and IDisp
     */
    hr = LoadRegTypeLib(IID_StdOle,
                 STDOLE2_MAJORVERNUM,
                 STDOLE2_MINORVERNUM,
                 STDOLE2_LCID,
                 &pITypeLib);
    if (hr != S_OK)
        {
        hr = LoadTypeLibEx(OLESTR("stdole2.tlb"), REGKIND_DEFAULT, &pITypeLib);
        if (FAILED(hr))
            goto LFail;
        }

    hr = pITypeLib->GetTypeInfoOfGuid(IID_IDispatch, &g_ptinfoIDispatch);
    if (SUCCEEDED(hr))
        {
        hr = pITypeLib->GetTypeInfoOfGuid(IID_IUnknown, &g_ptinfoIUnknown);
        }

    pITypeLib->Release();
    pITypeLib = NULL;

    if (FAILED(hr))
        goto LFail;

    /*
     * Load denali's typelibs.  Save them in Glob.
     */

    /*
     * The type libraries are registered under 0 (neutral),
     * and 9 (English) with no specific sub-language, which
     * would make them 407 or 409 and such.
     * If we become sensitive to sub-languages, then use the
     * full LCID instead of just the LANGID as done here.
     */

    char szPath[MAX_PATH + 4];

    // Get the path for denali so we can look for the TLB there.
    if (!GetModuleFileNameA(g_hinstDLL, szPath, MAX_PATH))
        return E_FAIL;

    if (FAILED(hr = convStr.Init(szPath)))
        goto LFail;

    hr = LoadTypeLibEx(convStr.GetString(), REGKIND_DEFAULT, &pITypeLib);

    // Since it's presumably in our DLL, make sure that we loaded it.
    Assert (SUCCEEDED(hr));
    if (FAILED(hr))
        goto LFail;

    // Save it in Glob
    gGlob.m_pITypeLibDenali = pITypeLib;

    // now load the txn type lib

    strcat(szPath, "\\2");

    if (FAILED(hr = convStr.Init(szPath)))
        goto LFail;

    hr = LoadTypeLibEx(convStr.GetString(), REGKIND_DEFAULT, &pITypeLib);

    // Since it's presumably in our DLL, make sure that we loaded it.
    Assert (SUCCEEDED(hr));
    if (FAILED(hr))
        goto LFail;

    // Save it in Glob
    gGlob.m_pITypeLibTxn = pITypeLib;

    /*
     * Now cache the typeinfo's of all non-top-level intrinsics
     * This is for the OA workaround and for performance.
     */
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IStringList, &g_ptinfoIStringList);
    if (FAILED(hr))
        goto LFail;
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IRequestDictionary, &g_ptinfoIRequestDictionary);
    if (FAILED(hr))
        goto LFail;
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IReadCookie, &g_ptinfoIReadCookie);
    if (FAILED(hr))
        goto LFail;
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IWriteCookie, &g_ptinfoIWriteCookie);
    if (FAILED(hr))
        goto LFail;

LFail:
    return(hr);
    }

/*===================================================================
UnCacheStdTypeInfos

Release the typeinfo's we have cached for IUnknown and IDispatch
and the denali typelib and the other cached stuff.

Returns:
    HRESULT - S_OK on success

Side effects:
===================================================================*/
HRESULT UnCacheStdTypeInfos()
    {
    ITypeInfo **ppTypeInfo;

    // Release the typeinfos for IUnk and IDisp
    if (g_ptinfoIDispatch)
        {
        g_ptinfoIDispatch->Release();
        g_ptinfoIDispatch = NULL;
        }
    if (g_ptinfoIUnknown)
        {
        g_ptinfoIUnknown->Release();
        g_ptinfoIDispatch = NULL;
        }

    // Let go of the cached Denali typelibs
    Glob(pITypeLibDenali)->Release();
    Glob(pITypeLibTxn)->Release();

    // Let go of other cached typeinfos
    g_ptinfoIStringList->Release();
    g_ptinfoIRequestDictionary->Release();
    g_ptinfoIReadCookie->Release();
    g_ptinfoIWriteCookie->Release();

    return(S_OK);
    }


/*===================================================================
SendHtmlSubstitute

Send the html file named XXX_ASP.HTM instead of rejecting the
request.

Parameters:
    pIReq       CIsapiReqInfo

Returns:
    HRESULT     (S_FALSE = no html substitute found)
===================================================================*/
HRESULT SendHtmlSubstitute(CIsapiReqInfo    *pIReq)
    {
    TCHAR *szAspPath = pIReq->QueryPszPathTranslated();
    DWORD cchAspPath = pIReq->QueryCchPathTranslated();

    // verify file name
    if (cchAspPath < 4 || cchAspPath > MAX_PATH ||
        _tcsicmp(szAspPath + cchAspPath - 4, _T(".asp")) != 0)
        {
        return S_FALSE;
        }

    // construct path of the html file
    TCHAR szHtmPath[MAX_PATH+5];
    DWORD cchHtmPath = cchAspPath + 4;
    _tcscpy(szHtmPath, szAspPath);
    szHtmPath[cchAspPath - 4] = _T('_');
    _tcscpy(szHtmPath + cchAspPath, _T(".htm"));

    // check if the html file exists
    if (FAILED(AspGetFileAttributes(szHtmPath)))
        return S_FALSE;

    return CResponse::SyncWriteFile(pIReq, szHtmPath);
    }

/*===================================================================
DoHangDetection

Checks a variety of global counters to see if this ASP process
is underwater.  If the conditions are met, an ISAPI SSF function
is called to report this state.

Parameters:
    pIReq       CIsapiReqInfo

Returns:
    void
===================================================================*/
void    DoHangDetection(CIsapiReqInfo   *pIReq,  DWORD  totalReqs)
{
    // we can bail quickly if there aren't any requests hung

    if (g_HangDetectConfig.dwHangDetectionEnabled && g_nRequestsHung) {

        // temp work around for a div by zero bug.  If g_nRequestsHung
        // is non-zero and g_nThreadsExecuting is zero, then this is
        // an inconsistency in the counter management.  A bug that will
        // be hard to track down.  To get us through beta3, I'm going to
        // reset the requestshung counter.

        if (g_nThreadsExecuting == 0) {
            g_nRequestsHung = 0;
            memset (g_nRequestSamples, 0 , sizeof(g_nRequestSamples));

            return;
        }

        if (((totalReqs % g_HangDetectConfig.dwRequestThreshold) == 0)) {

            DWORD   dwPercentHung = (g_nRequestsHung*100)/g_nThreadsExecuting;
            DWORD   dwPercentQueueFull = 0;

            DBGPRINTF((DBG_CONTEXT, "DoHangDetection: Request Thread Hit.  Percent Hung Threads is %d (%d of %d)\n",dwPercentHung, g_nRequestsHung, g_nThreadsExecuting));

            // need at least 50% hung before a recycle is requested

            if (dwPercentHung >= g_HangDetectConfig.dwThreadsHungThreshold) {

                // now, check the queue

                dwPercentQueueFull = (Glob(dwRequestQueueMax) != 0)
                                         ? (g_nBrowserRequests*100)/Glob(dwRequestQueueMax)
                                         : 0;

                DBGPRINTF((DBG_CONTEXT, "DoHangDetection: Percent Hung exceed threshold.  Percent Queue Full is %d\n", dwPercentQueueFull));

                if ((dwPercentQueueFull + dwPercentHung) >= 100) {

                    g_nConsecutiveIllStates++;

                    // Fill the Requests Queued Samples Array ..Instead of doing a memcopy(setup) this will be equally fast on a pipelined processor.
                    g_nRequestSamples[0] = g_nRequestSamples[1];
                    g_nRequestSamples[1] = g_nRequestSamples[2];
                    g_nRequestSamples[2] = g_nViperRequests;

                    DBGPRINTF((DBG_CONTEXT, "DoHangDetection: Exceeded combined threshold.  Incrementing ConsecIllStates (%d)\n",g_nConsecutiveIllStates));

                } // if ((dwPercentQueueFull + dwPercentHung) >= 100)
                else {

                    g_nConsecutiveIllStates = 0;
                    memset (g_nRequestSamples, 0 , sizeof(g_nRequestSamples));
                }
            } // if (dwPercentHung >= g_HangDetectConfig.dwThreadsHungThreshold)
            else {
                g_nConsecutiveIllStates = 0;
                memset (g_nRequestSamples, 0 , sizeof(g_nRequestSamples));
            }

            if (FReportUnhealthy()) {

                char  szResourceStr[MAX_MSG_LENGTH];
                char  szComposedStr[MAX_MSG_LENGTH];

                DBGPRINTF((DBG_CONTEXT, "DoHangDetection: ConsecIllStatesThreshold exceeded.  Reporting ill state to ISAPI\n"));

                if (CchLoadStringOfId(IDS_UNHEALTHY_STATE_STR, szResourceStr, MAX_MSG_LENGTH) == 0)
                    strcpy(szResourceStr,"ASP unhealthy because %d%% of executing requests are hung and %d%% of the request queue is full.");

                _snprintf(szComposedStr, MAX_MSG_LENGTH, szResourceStr, dwPercentHung, dwPercentQueueFull);
                szComposedStr[sizeof(szComposedStr)-1] = '\0';

                pIReq->ServerSupportFunction(HSE_REQ_REPORT_UNHEALTHY,
                                             szComposedStr,
                                             NULL,
                                             NULL);
                g_nIllStatesReported++;
                DBGPRINTF((DBG_CONTEXT, "############################### Ill'ing ##############################\n"));
            }
        }
    } // if (g_nRequestsHung)
    else {
        g_nConsecutiveIllStates = 0;
    }

    return;
}

/*===================================================================
FReportUnhealthy

  returns TRUE of all conditions are met to report Unhealthy

Parameters:
    none

Returns:
    TRUE - Report Unhealthy
    FALSE - Dont Report Unhealthy
===================================================================*/
BOOL    FReportUnhealthy()
{
    return
      (     // Is it over the threshold yet.
            (g_nConsecutiveIllStates >= g_HangDetectConfig.dwConsecIllStatesThreshold)

            // Should have at least 1 request queued other than the ones hung
            && (g_nViperRequests  > g_nRequestsHung)

            // The queue size has not been decreasing
            && ((g_nRequestSamples[0]<= g_nRequestSamples[1]) && (g_nRequestSamples[1]<= g_nRequestSamples[2]))

            // This is the chosen thread to report unhealthy
            && (InterlockedExchange(&g_fUnhealthyReported, 1) == 0)
      );
}

/*===================================================================
DoOOMDetection

  Checks to see if any Out of Memory errors have occurred recently.
  If so, calls the UNHEALTHY SSF.

Parameters:
    pIReq       CIsapiReqInfo

Returns:
    void
===================================================================*/
void    DoOOMDetection(CIsapiReqInfo   *pIReq,  DWORD  totalReqs)
{

    // see if there are OOM errors, but only report unhealthy once!

    if (!g_fOOMRecycleDisabled
        && g_nOOMErrors
        && (InterlockedExchange(&g_fUnhealthyReported, 1) == 0)) {

        char  szResourceStr[MAX_MSG_LENGTH];

        DBGPRINTF((DBG_CONTEXT, "DoOOMDetection: Reporting ill state to ISAPI\n"));

        if (CchLoadStringOfId(IDS_UNHEALTHY_OOM_STATE_STR, szResourceStr, MAX_MSG_LENGTH) == 0)
            strcpy(szResourceStr,"ASP unhealthy due to an out of memory condition.");

        pIReq->ServerSupportFunction(HSE_REQ_REPORT_UNHEALTHY,
                                     szResourceStr,
                                     NULL,
                                     NULL);
        g_nIllStatesReported++;
        DBGPRINTF((DBG_CONTEXT, "############################### Ill'ing ##############################\n"));
    }
}

#ifdef LOG_FCNOTIFICATIONS
// UNDONE get this from registry
LPSTR   g_szNotifyLogFile = "C:\\Temp\\AspNotify.Log";
HANDLE  g_hfileNotifyLog;
HANDLE  g_hmapNotifyLog;
char*   g_pchNotifyLogStart;
char*   g_pchNotifyLogCurrent;
LPSTR   g_szNotifyPrefix = "File change notification: ";
LPSTR   g_szCreateHandlePrefix = "Create handle: ";

void LfcnCreateLogFile()
    {
    DWORD   dwErrCode;

    if(INVALID_HANDLE_VALUE != (g_hfileNotifyLog =
                                CreateFile(
                                            g_szNotifyLogFile,              // file name
                                            GENERIC_READ | GENERIC_WRITE,   // access (read-write) mode
                                            FILE_SHARE_READ,        // share mode
                                            NULL,                   // pointer to security descriptor
                                            CREATE_ALWAYS,          // how to create
                                            FILE_ATTRIBUTE_NORMAL,  // file attributes
                                            NULL                    // handle to file with attributes to copy
                                           )))
        {
        BYTE    rgb[0x10000];
        DWORD   cb = sizeof( rgb );
        DWORD   cbWritten = 0;
//      FillMemory( rgb, cb, 0xAB );

        WriteFile(
                    g_hfileNotifyLog,   // handle to file to write to
                    rgb,                // pointer to data to write to file
                    cb,                 // number of bytes to write
                    &cbWritten,         // pointer to number of bytes written
                    NULL                // pointer to structure needed for overlapped I/O
                   );

        if(NULL != (g_hmapNotifyLog =
                    CreateFileMapping(
                                        g_hfileNotifyLog,       // handle to file to map
                                        NULL,           // optional security attributes
                                        PAGE_READWRITE,     // protection for mapping object
                                        0,              // high-order 32 bits of object size
                                        100,                // low-order 32 bits of object size
                                        NULL            // name of file-mapping object
                                    )))
            {
            if(NULL != (g_pchNotifyLogStart =
                        (char*) MapViewOfFile(
                                                g_hmapNotifyLog,        // file-mapping object to map into address space
                                                FILE_MAP_WRITE, // access mode
                                                0,              // high-order 32 bits of file offset
                                                0,              // low-order 32 bits of file offset
                                                0               // number of bytes to map
                                            )))
                {
                *g_pchNotifyLogStart = '\0';
                g_pchNotifyLogCurrent = g_pchNotifyLogStart;
                LfcnAppendLog( "ASP change-notifications log file \r\n" );
                LfcnAppendLog( "================================= \r\n" );
                DBGPRINTF((DBG_CONTEXT,  "Notifications log file created and mapped.\r\n" ));
                return;
                }
            }
        }

    dwErrCode = GetLastError();
    DBGERROR((DBG_CONTEXT, "Failed to create notifications log file; last error was %d\r\n", szErrCode));
    }

void LfcnCopyAdvance(char** ppchDest, const char* sz)
    {
    // UNDONE make this robust (WriteFile to extend file?)
    strcpy( *ppchDest, sz );
    *ppchDest += strlen( sz );
    }

void LfcnAppendLog(const char* sz)
    {
    LfcnCopyAdvance( &g_pchNotifyLogCurrent, sz );
    DBGPRINTF((DBG_CONTEXT, "%s", sz));
    }

void LfcnLogNotification(char* szFile)
    {
    LfcnAppendLog( g_szNotifyPrefix );
    LfcnAppendLog( szFile );
    LfcnAppendLog( "\r\n" );
    }

void LfcnLogHandleCreation(int i, char* szApp)
    {
    char    szIndex[5];
    _itoa( i, szIndex, 10);

    LfcnAppendLog( g_szCreateHandlePrefix );
    LfcnAppendLog( szIndex );
    LfcnAppendLog( "\t" );
    LfcnAppendLog( szApp );
    LfcnAppendLog( "\r\n" );
    }

void LfcnUnmapLogFile()
    {
    if(g_pchNotifyLogStart != NULL)
        UnmapViewOfFile(g_pchNotifyLogStart);

    if(g_hmapNotifyLog!= NULL)
        CloseHandle(g_hmapNotifyLog);

    if(g_hfileNotifyLog != NULL && g_hfileNotifyLog != INVALID_HANDLE_VALUE)
        CloseHandle( g_hfileNotifyLog );

    g_pchNotifyLogStart = NULL;
    g_hmapNotifyLog = NULL;
    g_hfileNotifyLog = NULL;
    }

#endif  //LOG_FCNOTIFICATIONS

HRESULT AdjustProcessSecurityToAllowPowerUsersToWait()
{
    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;
    EXPLICIT_ACCESS ea[5];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    PSID psidPowerUser = NULL;
    PSID psidSystemOperator = NULL;
    PSID psidAdministrators = NULL;
    PSID psidPerfMonUser = NULL;
    PSID psidPerfLogUser = NULL;
    PACL pNewDACL = NULL;
    PACL pOldDACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    HANDLE hProcess = GetCurrentProcess();

    //
    // Get a sid that represents the Administrators group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinAdministratorsSid,
                                           &psidAdministrators );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the POWER_USERS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPowerUsersSid,
                                           &psidPowerUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the SYSTEM_OPERATORS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinSystemOperatorsSid,
                                           &psidSystemOperator );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating System Operators SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the PERF LOG USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfLoggingUsersSid,
                                        &psidPerfLogUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating perf log user SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the PERF MON USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfMonitoringUsersSid,
                                        &psidPerfMonUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating perf mon user SID failed\n"
            ));

        goto exit;
    }

    //
    // Now Get the SD for the Process.
    //

    //
    // The pOldDACL is just a pointer into memory owned
    // by the pSD, so only free the pSD.
    //
    dwErr = GetSecurityInfo( hProcess,
                             SE_KERNEL_OBJECT,
                             DACL_SECURITY_INFORMATION,
                             NULL,        // owner SID
                             NULL,        // primary group SID
                             &pOldDACL,   // PACL*
                             NULL,        // PACL*
                             &pSD );      // Security Descriptor

    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not get security info for the current process \n"
            ));

        goto exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for the new ACE.

    ZeroMemory(&ea[0], sizeof(ea));
    SetExplicitAccessSettings(  &(ea[0]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidPowerUser );

    SetExplicitAccessSettings(  &(ea[1]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidSystemOperator );

    SetExplicitAccessSettings(  &(ea[2]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidAdministrators );

    SetExplicitAccessSettings(  &(ea[3]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidPerfMonUser );

    SetExplicitAccessSettings(  &(ea[4]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidPerfLogUser );

    //
    // Add the power user acl to the list.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS),
                            ea,
                            pOldDACL,
                            &pNewDACL);

    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not set Acls into security descriptor \n"
            ));

        goto exit;
    }

    //
    // Attach the new ACL as the object's DACL.
    //
    dwErr = SetSecurityInfo(hProcess,
                            SE_KERNEL_OBJECT,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            NULL,
                            pNewDACL,
                            NULL);

    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not set process security info \n"
            ));

        goto exit;
    }

exit:

    FreeWellKnownSid(&psidPowerUser);
    FreeWellKnownSid(&psidSystemOperator);
    FreeWellKnownSid(&psidAdministrators);
    FreeWellKnownSid(&psidPerfLogUser);
    FreeWellKnownSid(&psidPerfMonUser);

    if( pSD != NULL )
    {
        LocalFree((HLOCAL) pSD);
        pSD = NULL;
    }

    if( pNewDACL != NULL )
    {
        LocalFree((HLOCAL) pNewDACL);
        pNewDACL = NULL;
    }

    return hr;
}

HRESULT
InitializeResourceDll()
    {
        HRESULT hr = S_OK;

        // check if already initialized
        if (g_hResourceDLL)
            return S_OK;


        // Allocate MAX_PATH + some greater than reasonable amout for system32\inetsrv\iisres.dll
        STACK_STRU(struResourceDll, MAX_PATH + 100);

        UINT i = GetWindowsDirectory(struResourceDll.QueryStr(), MAX_PATH);
        if ( 0 == i || MAX_PATH < i )
            return HRESULT_FROM_WIN32(GetLastError());

        struResourceDll.SyncWithBuffer();

        hr = struResourceDll.Append(L"\\system32\\inetsrv\\");
        if (FAILED(hr))
            return hr;

        hr = struResourceDll.Append(IIS_RESOURCE_DLL_NAME);
        if (FAILED(hr))
            return hr;

        g_hResourceDLL = LoadLibrary(struResourceDll.QueryStr());
        if (!g_hResourceDLL)
            {
            return HRESULT_FROM_WIN32(GetLastError());
            }

        return S_OK;
    }


VOID
UninitializeResourceDll()
{
    if (g_hResourceDLL)
    {
        FreeLibrary(g_hResourceDLL);
        g_hResourceDLL = (HMODULE)0;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\denver.h ===
#include <winver.h>
#include "ntverp.h"

/*------------------------------------------------------------------------------*/
/* the following section defines values used in the version			*/
/* data structure for all files, and which do not change.			*/
/*------------------------------------------------------------------------------*/
#ifndef VER_FILETYPE
#define VER_FILETYPE                VFT_DLL
#endif

#ifndef DLL_VER
#define VER_FILEDESCRIPTION_STR     "Active Server Pages"
#define VER_INTERNALNAME_STR        "asp.dll"
#define VER_ORIGINALFILENAME_STR    "asp.dll"

#endif //DLL_VER

#include "iisver.h"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\disptch2.h ===
#ifndef __DISPTCH2_H__
#define __DISPTCH2_H__

#include "dispatch.h"
#include "asptxn.h"

template <class T>
class ATL_NO_VTABLE CDispatchImpl : public T
{
public:
// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return gm_tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		return gm_tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		// VBScript does not distinguish between a propget and a method
		// implement that behavior for other languages.
		//
		if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
			wFlags |= DISPATCH_METHOD | DISPATCH_PROPERTYGET;

		return gm_tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                           wFlags, pdispparams, pvarResult, pexcepinfo,
                           puArgErr);
	}
protected:
	static CComTypeInfoHolder gm_tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		return gm_tih.GetTI(lcid, ppInfo);
	}
};

typedef CDispatchImpl<IApplicationObject>   IApplicationObjectImpl;
typedef CDispatchImpl<IASPError>            IASPErrorImpl;
typedef CDispatchImpl<IReadCookie>          IReadCookieImpl;
typedef CDispatchImpl<IRequest>             IRequestImpl;
typedef CDispatchImpl<IRequestDictionary>   IRequestDictionaryImpl;
typedef CDispatchImpl<IResponse>            IResponseImpl;
typedef CDispatchImpl<IScriptingContext>    IScriptingContextImpl;
typedef CDispatchImpl<IServer>              IServerImpl;
typedef CDispatchImpl<ISessionObject>       ISessionObjectImpl;
typedef CDispatchImpl<IStringList>          IStringListImpl;
typedef CDispatchImpl<IVariantDictionary>   IVariantDictionaryImpl;
typedef CDispatchImpl<IWriteCookie>         IWriteCookieImpl;
typedef CDispatchImpl<IASPObjectContext>    IASPObjectContextImpl;

#endif // __DISPTCH2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\dispatch.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: IDispatch implementation

File: Dispatch.h

Owner: DGottner

This file contains our implementation of IDispatch
===================================================================*/

#ifndef _Dispatch_H
#define _Dispatch_H

/*
 * C D i s p a t c h
 *
 * IDispatch interface implementation for OLE objects
 *
 * This class contains the basic four IDispatch members.  The Big Three
 * (QueryInterface, AddRef, Release) are left as pure virtual, as this
 * class is designed as an intermediate class for further derivation.
 *
 * This also means that we no longer need a pointer to the controlling unknown.
 */

class CDispatch : public IDispatch
	{
private:
	const GUID *	m_pGuidDispInterface;
	ITypeLib *		m_pITypeLib;
	ITypeInfo *		m_pITINeutral;

public:

	CDispatch();
	~CDispatch();

	// Do this in Init because OLE interfaces in general do not take
	// parameters in the constructor.  This call CANNOT fail, however.
	//
	void Init(const IID &GuidDispInterface, const ITypeLib *pITypeLib = NULL);

	// IDispatch members
	//
	STDMETHODIMP GetTypeInfoCount(UINT *);
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD,
						DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
	};


/*
 * C S u p p o r t E r r o r I n f o
 *
 * Implemention of ISupportErrorInfo for Denali classes
 */

class CSupportErrorInfo : public ISupportErrorInfo
	{
private:
	IUnknown *	m_pUnkObj;
	IUnknown *	m_pUnkOuter;
	const GUID *m_pGuidDispInterface;

public:
	CSupportErrorInfo(void);
	CSupportErrorInfo(IUnknown *pUnkObj, IUnknown *pUnkOuter, const IID &GuidDispInterface);
	void Init(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface);

	// IUnknown members that delegate to m_pUnkOuter.
	//
	STDMETHODIMP		 QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(REFIID);
	};


extern void Exception(REFIID ObjID, LPOLESTR strSource, LPOLESTR strDescr);
extern void ExceptionId(REFIID ObjID, UINT SourceID, UINT DescrID, HRESULT hrCode = S_OK);

#endif /* _Dispatch_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\except.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Exception Handling

File: Except.h

Owner: DGottner

Exception handling macros implemented via Win32 structured exceptions.

Usage:

	TRY
		<try block>

	CATCH (<exception variable>)
		<exception handler>

	END_TRY

To throw an exception use "THROW (<integer expression>)"

To set up a termination handler use:

	TRY
		<try block>

	FINALLY
		<termination handler>

	END_TRY

Rationale:
	This macro package offers a strict subset of Win32 structured exception
	handling. There is no support for exception filters (you have to rethrow
	exceptions), and no support for the resumption model of exception handling
	(though Win32 supports the resumption model)

	The purpose for these restrictions is to make it very easy to rewrite the
	exception handling macros for use with other exception throwing mechanisms.
	It would be easy to use this same interface with C++ exceptions or
	setjmp/longjmp.

	The braces with TRY, CATCH, and FINALLY are optional. Since this code is
	structured using self-bracketing constructs, the braces seem redundant.

	There is no need to declare the datatype of the <exception variable>
	because it is always an integer.
-----------------------------------------------------------------------------*/

#ifndef _EXCEPT_H
#define _EXCEPT_H

// Pragmas --------------------------------------------------------------------
//
// Turn off the "signed/unsigned conversion" warning off because it we get this
// all the time that we throw an HRESULT. (which is a harmless thing)  The
// warning is usually benign anyway.


#pragma warning(disable: 4245)


// Macros ---------------------------------------------------------------------

#define TRY	               __try {
#define CATCH(nException)  } __except(1) { DWORD nException = GetExceptionCode();
#define FINALLY            } __finally {
#define END_TRY            }

#define THROW(nException)  RaiseException(nException, 0, 0, NULL)

#endif // _EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\dispatch.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: IDispatch implementation

File: Dispatch.h

Owner: DGottner

This file contains our implementation of IDispatch
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dispatch.h"
#include "asptlb.h"

#include "memchk.h"

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

extern LONG g_nOOMErrors;

CComTypeInfoHolder CDispatchImpl<IApplicationObject>::gm_tih = {&__uuidof(IApplicationObject), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IASPError>::gm_tih = {&__uuidof(IASPError), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IReadCookie>::gm_tih = {&__uuidof(IReadCookie), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IRequest>::gm_tih = {&__uuidof(IRequest), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IRequestDictionary>::gm_tih = {&__uuidof(IRequestDictionary), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IResponse>::gm_tih = {&__uuidof(IResponse), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IScriptingContext>::gm_tih = {&__uuidof(IScriptingContext), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IServer>::gm_tih = {&__uuidof(IServer), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<ISessionObject>::gm_tih = {&__uuidof(ISessionObject), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IStringList>::gm_tih = {&__uuidof(IStringList), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IVariantDictionary>::gm_tih = {&__uuidof(IVariantDictionary), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IWriteCookie>::gm_tih = {&__uuidof(IWriteCookie), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IASPObjectContext>::gm_tih = {&__uuidof(IASPObjectContext), &LIBID_ASPObjectContextTypeLibrary, 3, 0, NULL, 0, NULL, 0};

/*===================================================================
CDispatch::CDispatch
CDispatch::~CDispatch

Parameters (Constructor):
	pUnkObj			pointer to the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.
===================================================================*/

CDispatch::CDispatch()
{
	m_pITINeutral = NULL;
	m_pITypeLib = NULL;
	m_pGuidDispInterface = NULL;
}

void CDispatch::Init
(
const GUID &GuidDispInterface,
const ITypeLib *pITypeLib		// = NULL
)
{
	m_pGuidDispInterface = &GuidDispInterface;
	m_pITypeLib = const_cast<ITypeLib *>(pITypeLib);
}

CDispatch::~CDispatch(void)
{
	ReleaseInterface(m_pITINeutral);
	return;
}


/*===================================================================
CDispatch::GetTypeInfoCount

Returns the number of type information (ITypeInfo) interfaces
that the object provides (0 or 1).

Parameters:
	pcInfo		UINT * to the location to receive
				the count of interfaces.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetTypeInfoCount(UINT *pcInfo)
	{
	// We implement GetTypeInfo so return 1

	*pcInfo = 1;
	return S_OK;
	}


/*===================================================================
CDispatch::GetTypeInfo

Retrieves type information for the automation interface.	This
is used anywhere that the right ITypeInfo interface is needed
for whatever LCID is applicable.	Specifically, this is used
from within GetIDsOfNames and Invoke.

Parameters:
	itInfo			UINT reserved.	Must be zero.
	lcid			LCID providing the locale for the type
					information.	If the object does not support
					localization, this is ignored.
	ppITypeInfo		ITypeInfo ** in which to store the ITypeInfo
					interface for the object.

Return Value:
	HRESULT			S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetTypeInfo(
	UINT itInfo,
	LCID lcid,
	ITypeInfo **ppITypeInfo
)
{
	HRESULT hr;
	ITypeInfo **ppITI = NULL;

    if (0 != itInfo)
		return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);

	if (NULL == ppITypeInfo)
		return ResultFromScode(E_POINTER);

	*ppITypeInfo = NULL;

    // We don't internationalize the type library, so
    // we always return the same one, regardless of the locale.
    
	ppITI = &m_pITINeutral;

	//Load a type lib if we don't have the information already.
	if (NULL == *ppITI)
	{
		ITypeLib *pITL;
		
		// If a specific TypeLib was given at init time use that, otherwise default to the main one
		if (m_pITypeLib == NULL)
			pITL = Glob(pITypeLibDenali);
		else
			pITL = m_pITypeLib;
		Assert(pITL != NULL);
			
		hr = pITL->GetTypeInfoOfGuid(*m_pGuidDispInterface, ppITI);

		if (FAILED(hr))
			return hr;

		// Save the type info in a class member, so we don't have
		// go through all this work again;
		m_pITINeutral = *ppITI;
	}

	/*
	 * Note: the type library is still loaded since we have
	 * an ITypeInfo from it.
	 */
	(*ppITI)->AddRef();
	*ppITypeInfo = *ppITI;
	return S_OK;
}


/*===================================================================
CDispatch::GetIDsOfNames

Converts text names into DISPIDs to pass to Invoke

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetIDsOfNames
(
	REFIID riid,
	OLECHAR **rgszNames,
	UINT cNames,
	LCID lcid,
	DISPID *rgDispID
)
{
	HRESULT hr;
	ITypeInfo *pTI;

	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	//Get the right ITypeInfo for lcid.
	hr = GetTypeInfo(0, lcid, &pTI);

	if (SUCCEEDED(hr))
		{
		hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
		pTI->Release();
    }

	return hr;
}


/*===================================================================
CDispatch::Invoke

Calls a method in the dispatch interface or manipulates a property.

Parameters:
	dispID			DISPID of the method or property of interest.
	riid			REFIID reserved, must be IID_NULL.
	lcid			LCID of the locale.
	wFlags			USHORT describing the context of the invocation.
	pDispParams		DISPPARAMS * to the array of arguments.
	pVarResult		VARIANT * in which to store the result.	Is
					NULL if the caller is not interested.
	pExcepInfo		EXCEPINFO * to exception information.
	puArgErr		UINT * in which to store the index of an
					invalid parameter if DISP_E_TYPEMISMATCH
					is returned.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::Invoke
(
DISPID dispID,
REFIID riid,
LCID lcid,
unsigned short wFlags,
DISPPARAMS *pDispParams,
VARIANT *pVarResult,
EXCEPINFO *pExcepInfo,
UINT *puArgErr
)
{
	HRESULT hr;
	ITypeInfo *pTI;
	LANGID langID = PRIMARYLANGID(lcid);

	// riid is supposed to be IID_NULL always
	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	// Get the ITypeInfo for lcid
	hr = GetTypeInfo(0, lcid, &pTI);

	if (FAILED(hr))
		return hr;

#ifdef USE_LOCALE
	// This saves the language ID for this thread
	TlsSetValue(g_dwTLS, &langID);
#endif

	// Clear exceptions
	SetErrorInfo(0L, NULL);

	// VBScript does not distinguish between a propget and a method
	// implement that behavior for other languages.
	//
	if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
		wFlags |= DISPATCH_METHOD | DISPATCH_PROPERTYGET;

	// This is exactly what DispInvoke does--so skip the overhead.
	// With dual interface, "this" is the address of the object AND its dispinterface
	//
	hr = pTI->Invoke(this, dispID, wFlags, 
					pDispParams, pVarResult, pExcepInfo, puArgErr);

	// Exception handling is done within ITypeInfo::Invoke

	pTI->Release();
	return hr;
}

/*===================================================================
CSupportErrorInfo::CSupportErrorInfo

Default constructor so that the Init method can be used.

Parameters (Constructor):
	pObj			PCResponse of the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.
===================================================================*/
CSupportErrorInfo::CSupportErrorInfo(void)
:	m_pUnkObj(NULL),
	m_pUnkOuter(NULL)
	{
	}

/*===================================================================
CSupportErrorInfo::CSupportErrorInfo

Parameters (Constructor):
	pObj				PCResponse of the object we're in.
	pUnkOuter			LPUNKNOWN to which we delegate.
	GuidDispInterface	GUID of dispatch interface.
===================================================================*/

CSupportErrorInfo::CSupportErrorInfo(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface)
	{
	m_pUnkObj = pUnkObj;
	m_pUnkOuter = (pUnkOuter == NULL)? pUnkObj : pUnkOuter;
	m_pGuidDispInterface = &GuidDispInterface;
	}

/*===================================================================
void CSupportErrorInfo::Init

Parameters:
	pObj				PCResponse of the object we're in.
	pUnkOuter			LPUNKNOWN to which we delegate.
	GuidDispInterface	GUID of dispatch interface.

Returns:
	Nothing
===================================================================*/

void CSupportErrorInfo::Init(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface)
	{
	m_pUnkObj = pUnkObj;
	m_pUnkOuter = (pUnkOuter == NULL)? pUnkObj : pUnkOuter;
	m_pGuidDispInterface = &GuidDispInterface;
	}

/*===================================================================
CSupportErrorInfo::QueryInterface
CSupportErrorInfo::AddRef
CSupportErrorInfo::Release

IUnknown members for CSupportErrorInfo object.
===================================================================*/

STDMETHODIMP CSupportErrorInfo::QueryInterface(const GUID &Iid, void **ppvObj)
	{
	return m_pUnkOuter->QueryInterface(Iid, ppvObj);
	}

STDMETHODIMP_(ULONG) CSupportErrorInfo::AddRef(void)
	{
	return m_pUnkOuter->AddRef();
	}

STDMETHODIMP_(ULONG) CSupportErrorInfo::Release(void)
	{
	return m_pUnkOuter->Release();
	}



/*===================================================================
CSupportErrorInfo::InterfaceSupportsErrorInfo

Informs a caller whether or not a specific interface
supports exceptions through the Set/GetErrorInfo mechanism.

Parameters:
	riid			REFIID of the interface in question.

Return Value:
	HRESULT			S_OK if a call to GetErrorInfo will succeed
					for callers of riid. S_FALSE if not.
===================================================================*/
STDMETHODIMP CSupportErrorInfo::InterfaceSupportsErrorInfo
(
REFIID riid
)
	{
	if (IID_IDispatch == riid || *m_pGuidDispInterface == riid)
		return S_OK;

	return ResultFromScode(S_FALSE);
	}



/*===================================================================
Exception

Raises an exception using the CreateErrorInfo API and the
ICreateErrorInfo interface.

Note that this method doesn't allow for deferred filling
of an EXCEPINFO structure.

Parameters:
	strSource	LPOLESTR the exception source
	strDescr	LPOLESTR the exception description

Returns:
	Nothing
===================================================================*/

void Exception
(
REFIID ObjID,
LPOLESTR strSource,
LPOLESTR strDescr
)
	{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	//Not much we can do if this fails.
	if (FAILED(CreateErrorInfo(&pICreateErr)))
		return;

	/*
	 * CONSIDER: Help file and help context?
	 */
	pICreateErr->SetGUID(ObjID);
	pICreateErr->SetHelpFile(L"");
	pICreateErr->SetHelpContext(0L);
	pICreateErr->SetSource(strSource);
	pICreateErr->SetDescription(strDescr);

	hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

	if (SUCCEEDED(hr))
		{
		SetErrorInfo(0L, pIErr);
		pIErr->Release();
		}

	//SetErrorInfo holds the object's IErrorInfo
	pICreateErr->Release();
	return;
	}

/*===================================================================
ExceptionId

Raises an exception using the CreateErrorInfo API and the
ICreateErrorInfo interface.

Note that this method doesn't allow for deferred filling
of an EXCEPINFO structure.

Parameters:
	SourceID	Resource ID for the source string
	DescrID		Resource ID for the description string

Returns:
	Nothing
===================================================================*/

void ExceptionId
(
REFIID ObjID,
UINT SourceID,
UINT DescrID,
HRESULT	hrCode
)
	{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

    if (DescrID == IDE_OOM)
        InterlockedIncrement(&g_nOOMErrors);

    // let's bail out of here if an error info is already set.  Note,
    // getting the ErrorInfo clears, so we need to restore it.  The 
    // AddRef/ownership model is that GetErrorInfo gives ownership
    // to the caller, while SetErrorInfo takes ownership.  As such,
    // no additional AddRef/Releases should be required.

    if (GetErrorInfo(0, &pIErr) == S_OK) {
        SetErrorInfo(0, pIErr);
        return;
    }

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	//Not much we can do if this fails.
	if (FAILED(CreateErrorInfo(&pICreateErr)))
		return;

	/*
	 * CONSIDER: Help file and help context?
	 */
	DWORD cch;
	WCHAR strSource[MAX_RESSTRINGSIZE];
	WCHAR strDescr[MAX_RESSTRINGSIZE];
	WCHAR strHRESULTDescr[256];
	WCHAR strDescrWithHRESULT[MAX_RESSTRINGSIZE];

	pICreateErr->SetGUID(ObjID);
	pICreateErr->SetHelpFile(L"");
	pICreateErr->SetHelpContext(0L);

	cch = CwchLoadStringOfId(SourceID, strSource, MAX_RESSTRINGSIZE);
	if (cch > 0)
		pICreateErr->SetSource(strSource);
	
	cch = CwchLoadStringOfId(DescrID, strDescr, MAX_RESSTRINGSIZE);
	if (cch > 0) 
		{
		//Bug Fix 91847 use a FormatMessage() based description
		HResultToWsz(hrCode, strHRESULTDescr, 256);

		_snwprintf(strDescrWithHRESULT, MAX_RESSTRINGSIZE, strDescr, strHRESULTDescr);
		strDescrWithHRESULT[MAX_RESSTRINGSIZE - 1] = L'\0';
	
		pICreateErr->SetDescription(strDescrWithHRESULT);
		}

	hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

	if (SUCCEEDED(hr))
		{
		SetErrorInfo(0L, pIErr);
		pIErr->Release();
		}

	//SetErrorInfo holds the object's IErrorInfo
	pICreateErr->Release();
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\error.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Error handling

File: Error.h

Owner: AndrewS

Include file for general error reporting routines for Denali.
===================================================================*/

#ifndef __ERROR_H
#define __ERROR_H

#include "hitobj.h"
#include "scrptmgr.h"




#define MAX_RESSTRINGSIZE		1024
// bug 840: must use these in both HandleErrorSz and CTemplate
#define	SZ_BREAKBOLD	"<BR><B>"
#define	SZ_UNBREAKBOLD	"<BR></B>"
const UINT	CCH_BREAKBOLD = strlen(SZ_BREAKBOLD);
const UINT	CCH_UNBREAKBOLD = strlen(SZ_UNBREAKBOLD);


/* format of default mask

32 bits

	31				16		8	4	0

	bit 0 - 4	default sink/output places.
	bit 0		NT Event Log
	bit 1		IIS log
	bit 2		Browser
	bit 3		Reserved

	bit 5 - 8	default predefined messages.(from registry)
	bit 5		use generic AccessDenied Message
	bit 6		use generic ScriptError Message
	bit 7 - 8	Reserved

	bit 9 - 10	to browser templates.(4 templates available)
				0x00	Default Script Template
				0x01	Empty Template/No Template
				0x10	System Template(mimic IIS style to Browser on HTTP errors, 204, 404, 500)
				0x11	Reserved
				
	bit 11 - 31	Reserved

*/
#define		ERR_LOGTONT					0x00000001
#define		ERR_LOGTOIIS				0x00000002
#define		ERR_LOGTOBROWSER			0x00000004

//Format(Script style is default, SYS style is for System error, 204, 404 and 500)
#define		ERR_FMT_SCRIPT				0x00000000
#define		ERR_FMT_SYS					0x00000200

#define		ERR_SetNoLogtoNT(x)			((x) & 0xfffffffe)
#define		ERR_SetNoLogtoIIS(x)		((x) & 0xfffffffd)
#define		ERR_SetNoLogtoBrowser(x)	((x) & 0xfffffffb)

#define		ERR_SetLogtoNT(x)			((x) | ERR_LOGTONT)
#define		ERR_SetLogtoIIS(x)			((x) | ERR_LOGTOIIS)
#define		ERR_SetLogtoBrowser(x)		((x) | ERR_LOGTOBROWSER)

#define		ERR_FLogtoNT(x)				((x) & ERR_LOGTONT)
#define		ERR_FLogtoIIS(x)			((x) & ERR_LOGTOIIS)
#define		ERR_FLogtoBrowser(x)		((x) & ERR_LOGTOBROWSER)
#define		ERR_FIsSysFormat(x)			((x) & ERR_FMT_SYS)

#define		ERR_SetSysFormat(x)			((x) | ERR_FMT_SYS)

//The order of the index is the order we send to the browser.(exclude header).
#define 	Im_szEngine				0
#define		Im_szErrorCode			1
#define 	Im_szShortDescription	2
#define 	Im_szFileName			3
#define 	Im_szLineNum			4
#define		Im_szCode				5
#define		Im_szLongDescription	6
#define		Im_szHeader				7
#define		Im_szItemMAX			8

// ASP HTTP sub-error codes for custom 500 errors
#define     SUBERRORCODE500_SERVER_ERROR             0
#define     SUBERRORCODE500_SHUTTING_DOWN           11
#define     SUBERRORCODE500_RESTARTING_APP          12
#define     SUBERRORCODE500_SERVER_TOO_BUSY         13
#define     SUBERRORCODE500_INVALID_APP             14
#define     SUBERRORCODE500_GLOBALASA_FORBIDDEN     15

class CErrInfo
	{
	friend HRESULT ErrHandleInit(void);
	friend HRESULT ErrHandleUnInit(void);
	friend HRESULT GetSpecificError(CErrInfo *pErrInfo,
									HRESULT hrError);
									
	friend HRESULT HandleSysError(	DWORD dwHttpError,
                                    DWORD dwHttpSubError,
	                                UINT ErrorID,
									UINT ErrorHeaderID,
									CIsapiReqInfo   *pIReq,
									CHitObj *pHitObj);

	friend HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
									CHitObj *pHitObj);

	friend HRESULT HandleError(	CHAR *szShortDes,
								CHAR *szLongDes,
								DWORD mask,
								CHAR *szFileName, 
								CHAR *szLineNum, 
								CHAR *szEngine, 
								CHAR *szErrCode,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj);

	friend HRESULT HandleError( IActiveScriptError *pscripterror,
								CTemplate *pTemplate,
								DWORD dwEngineID,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj);

	friend HRESULT HandleError(	UINT ErrorID,
								CHAR *szFileName, 
								CHAR *szLineNum, 
								CHAR *szEngine,
								CHAR *szErrCode,
								CHAR *szLongDes,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj,
                                va_list *pArgs = NULL);
	public:
		CErrInfo();

		inline LPSTR GetItem(DWORD iItem) { return m_szItem[iItem]; }
		inline void   GetLineInfo(BSTR *pbstrLineText, int *pnColumn)
			{ *pbstrLineText = m_bstrLineText, *pnColumn = m_nColumn; }

	private:
		//sink, either via CResponse(also use CIsapiReqInfo), or via WAM_EXEC_INFO
		CIsapiReqInfo               *m_pIReq;
		CHitObj						*m_pHitObj;

		// HTTP error code (404, 500, etc.) and sub error code
		DWORD                       m_dwHttpErrorCode;
		DWORD                       m_dwHttpSubErrorCode;
		
		//mask
		DWORD						m_dwMask;

		//data
		LPSTR						m_szItem[Im_szItemMAX];

		//line data (don't use m_szItem[] because data is BSTR
		BSTR						m_bstrLineText;
		int							m_nColumn;
		
		HRESULT						LogError();
		HRESULT						LogError(DWORD dwMask, LPSTR *szErrorString);
		
		HRESULT						LogErrortoNTEventLog(BOOL, BOOL);
		HRESULT						LogErrortoIISLog(BOOL *, BOOL *);
		HRESULT						LogErrortoBrowserWrapper();
		HRESULT						LogErrortoBrowser(CResponse *pResponse);
		HRESULT						LogErrortoBrowser(CIsapiReqInfo   *pIReq);
        HRESULT	                    LogCustomErrortoBrowser(CIsapiReqInfo   *pIReq, BOOL *pfCustomErrorProcessed);
		void						WriteHTMLEncodedErrToBrowser(const CHAR *StrIn, CResponse *pResponse, CIsapiReqInfo   *pIReq);
        HRESULT                     WriteCustomFileError(CIsapiReqInfo   *pIReq, TCHAR *szPath, TCHAR *szMimeType);
        HRESULT                     WriteCustomURLError(CIsapiReqInfo   *pIReq, TCHAR *szURL);
		
		HRESULT						ParseResourceString(CHAR *sz);
	};


//Error Handling APIs
//Case 1.a: Runtime Script Error(From Denali, VBS, JavaScript, or anyother Engines).
//example. Called by OnScriptError.
HRESULT HandleError( IActiveScriptError *pscripterror,
					 CTemplate *pTemplate,
					 DWORD dwEngineID,
					 CIsapiReqInfo   *pIReq, 
					 CHitObj *pHitObj );

//Case 1.b: Runtime Script Error(From Denali, VBS, JavaScript, or anyother Engines).
// Show error in debugger rather than the standard error logging.
HRESULT DebugError( IActiveScriptError *pScriptError, CTemplate *pTemplate, DWORD dwEngineID, IDebugApplication *pDebugApp);

//Case 2: Compiling time Script Error, 
//Also, this function is the most generic HandleError.
HRESULT HandleError(	CHAR *szShortDes,
						CHAR *szLongDes,
						DWORD dwMask,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine, 
						CHAR *szErrCode,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj);

//Case 3: Predefined Error ID
HRESULT	HandleError(	UINT ErrorID,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine,
						CHAR *szErrCode,
						CHAR *szLongDes,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj,
                        va_list *pArgs);
						
//Case 4: SystemDefined Error(so far, only 204, 404, and 500 can use this call)
//		 Implementation of this call will first send out the header, if ErrorHeaderID is not 0.
HRESULT HandleSysError(	DWORD dwHttpError,
                        DWORD dwHttpSubError,
                        UINT ErrorID,
						UINT ErrorHeaderID,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj);

// 500 Error processing calls HandleSysError()
HRESULT Handle500Error( UINT ErrorID, CIsapiReqInfo   *pIReq);
						
//OOM, special attention, because Heap is full, and therefore, no dynamic allocation						
HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj);

//FileName missing
//		The caller has no file name, nor any other info about where or when
//		the error occurred.  Trys to get the filename from the hitobj
VOID HandleErrorMissingFilename(UINT    errorID, 
                                CHitObj *pHitObj,
                                BOOL    fVarArgs = FALSE,
                                ...);

//The following 2 calls are discouraged for error-handling usage.  
//Use one of the Error Handling APIs instead.
//Ok when loading other strings from resource file.
INT CchLoadStringOfId(UINT id, CHAR *sz, INT cchMax);
INT CwchLoadStringOfId(UINT id, WCHAR *sz, INT cchMax);


HRESULT ErrHandleInit(void);
HRESULT ErrHandleUnInit(void);

HRESULT	LoadErrResString(UINT ErrID/*IN*/, DWORD *dwMask, CHAR *szErrorCode, CHAR *szShortDes, CHAR *LongDes);
CHAR *SzScodeToErrorCode(HRESULT hrError);

BOOL HResultToWsz(HRESULT hrIn, WCHAR *wszOut, DWORD cdwOut);
BOOL HResultToSz(HRESULT hrIn, CHAR *szOut, DWORD cdwOut);


#endif __ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\eventlog.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT Event logging

File: eventlog.h

Owner: jhittle

This is the header file for eventlog.cpp
===================================================================*/

#ifndef EVENTLOG_H
#define EVENTLOG_H

#define MAX_MSG_LENGTH	512
#define MSG_ID_MASK		0x0000FFFF
#define MAX_INSERT_STRS 8

		STDAPI	RegisterEventLog( void );
		STDAPI	UnRegisterEventLog( void );
		STDAPI 	ReportAnEvent(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCSTR *pszStrings,
                              DWORD dwBinDataSize = 0, LPVOID pData = NULL);
		STDAPI 	ReportAnEventW(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCWSTR *pszStrings);


extern void 	MSG_Error( LPCSTR );
extern void 	MSG_Error( UINT );
extern void		MSG_Error( UINT, PCSTR, UINT, DWORD Err = 0);
extern void 	MSG_Error( UINT, UINT );
extern void 	MSG_Error( UINT, UINT, UINT );
extern void 	MSG_Error( UINT, UINT, UINT, UINT );
extern void		MSG_Error( DWORD, LPCWSTR);
extern void 	MSG_Warning( LPCSTR );
extern void 	MSG_Warning( UINT );
extern void 	MSG_Warning( UINT, UINT );
extern void 	MSG_Warning( UINT, UINT, UINT );
extern void 	MSG_Warning( UINT, UINT, UINT, UINT );
extern void     MSG_Warning( DWORD, LPCWSTR, LPCWSTR );

// support function
//extern void queryEventLog(void);

#endif  //EVENTLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\fileapp.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: File/Application mapping

File: CFileApp.h

Owner: CGrant

File/Application mapping definition
-----------------------------------------------------------------------------*/

#ifndef _CFILEAPP_H
#define _CFILEAPP_H

// Includes -------------------------------------------------------------------
#include "applmgr.h"
#include "hashing.h"
#include "idhash.h"
#include "memcls.h"

#define    NUM_FILEAPP_HASHING_BUCKETS	17

/*****************************************************************************
Class:  CFileApplicationMap
Synopsis:   Maintains a database relating files to the applications that
            must be shut down if the file changes. The key for the hash table
            is the full file name
*/  
class CFileApplicationMap : public CHashTable
{
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fHashTableInited : 1;       // Need to UnInit hash table?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

public:

    CFileApplicationMap();
    ~CFileApplicationMap();
    void Lock();
    void UnLock();
    HRESULT Init();
    HRESULT UnInit();
    HRESULT AddFileApplication(const TCHAR *pszFileName, CAppln *pAppln);
    BOOL ShutdownApplications(const TCHAR *pszFile);
};

inline void CFileApplicationMap::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void CFileApplicationMap::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock ); 
    }
    
/*****************************************************************************
Class:  CFileApplnList
Synopsis:   Maintains a list of applications that
            must be shut down if a file changes
*/
class CFileApplnList : public CLinkElem
{

friend class CFileApplicationMap;

    TCHAR*      m_pszFilename;
    CPtrArray   m_rgpvApplications; // the list of applications
    BOOL        m_fInited;          // flag indicating initialization

public:

    CFileApplnList();
    ~CFileApplnList();

    HRESULT Init(const TCHAR* pszFilename);
    HRESULT UnInit();

    HRESULT AddApplication(void *pApplication);
    HRESULT RemoveApplication(void *pApplication);
    VOID    GetShutdownApplications(CPtrArray *prgpapplnRestartList);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
};

/*===================================================================
  Globals
===================================================================*/

extern CFileApplicationMap    g_FileAppMap;

#endif // _CFILEAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\exec.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Executive

File:	Executor.h

Owner: DGottner

Executor API definition
-----------------------------------------------------------------------------*/

#ifndef _EXECUTOR_H
#define _EXECUTOR_H

// Includes -------------------------------------------------------------------

#include "HitObj.h"


// Forward References ---------------------------------------------------------

class CResponse;
class CRequest;
class CServer;
class CScriptingNamespace;


// Error codes ----------------------------------------------------------------

#define E_PAGE_HAS_SESSAPP_OBJECTS		0x8000E001L


// Types and Constants --------------------------------------------------------

class CIntrinsicObjects
	{
private:
    BOOL                    m_fIsChild;
	CResponse *				m_pResponse;
	CRequest *				m_pRequest;
	CServer *				m_pServer;
	CScriptingNamespace *	m_pScriptingNamespace;

public:
	inline CResponse *			PResponse() const { return m_pResponse; }
	inline CRequest *			PRequest()  const { return m_pRequest; }
	inline CServer *			PServer()   const { return m_pServer; }
	inline CScriptingNamespace *PScriptingNamespace() const { return m_pScriptingNamespace; }
	
    CIntrinsicObjects()
        {
        m_fIsChild = FALSE;
    	m_pResponse = NULL;
	    m_pRequest = NULL;
        m_pServer = NULL;
        m_pScriptingNamespace = NULL;
        }
        
    ~CIntrinsicObjects()
        {
        Cleanup();
        }

    HRESULT Prepare(CSession *pSession);
    HRESULT PrepareChild(CResponse *pResponse, CRequest *pRequest, CServer *pServer);
    HRESULT Cleanup();
	};

struct TemplateGoodies
	{
	int				iScriptBlock;
	CTemplate *		pTemplate;
	};

// CONSIDER: declare pScriptEngine to be a CActiveScriptEngine, because that's its
//           actual type.
//
struct ScriptingInfo
	{
	CHAR *				szScriptEngine;		// name of this scripting engine
	PROGLANG_ID *		pProgLangId;		// ptr to prog lang id of the script engine
	CScriptEngine *		pScriptEngine;		// pointer to scripting engine
	TemplateGoodies		LineMapInfo;		// used to map lines back to VBScript
	};

struct ActiveEngineInfo
	{
	int cEngines;           // required engines
	int cActiveEngines;     // successfully instantiated engines
	
	ScriptingInfo *rgActiveEngines; // pointer to array of engines
	
	// when only one engine rgActiveEngines points to here
	ScriptingInfo siOneActiveEngine;
	};

 
// Prototypes -----------------------------------------------------------------

HRESULT Execute
    (
    CTemplate *pTemplate,
    CHitObj *pHitObj,
    const CIntrinsicObjects &intrinsics,
    BOOL fChild = FALSE
    );

HRESULT LoadTemplate
    (
    const TCHAR *szFile,
    CHitObj *pHitObj, 
    CTemplate **ppTemplate,
	const CIntrinsicObjects &intrinsics,
	BOOL fGlobalAsa,
	BOOL *pfTemplateInCache
	);

#endif // _EXECUTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\error.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Error handling

File: Error.cpp

Owner: AndrewS

This file contains general error reporting routines for Denali.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include <psapi.h>

#include "debugger.h"
#include "asperror.h"
#include "memchk.h"

#define DELIMITER	"~"
#define MAX_HEADERSIZE			128
#define	MAX_TEMPLATELEN			128

//The order of ErrTemplate_Index should be exactly the same order as the IDS_BROWSER_TEMPLATE
//in the aspresource.h, and as the same order we output the template to the browser.
//Implementation will loop through the index and picking the string from the resource file.
//Implementation will also loop through the index and write the string to browser.
#define ErrTemplate_BEGIN			0
#define ErrTemplate_ENGINE_BEGIN	1
#define ErrTemplate_ENGINE_END		2
#define ErrTemplate_ERROR_BEGIN		3
#define ErrTemplate_ERROR_END		4
#define ErrTemplate_SHORT_BEGIN		5
#define ErrTemplate_SHORT_END		6
#define ErrTemplate_FILE_BEGIN		7
#define ErrTemplate_FILE_END		8
#define ErrTemplate_LINE_BEGIN		9
#define ErrTemplate_LINE_END		10
#define ErrTemplate_CODE_BEGIN		11
#define ErrTemplate_CODE_END		12
#define ErrTemplate_LONG_BEGIN		13
#define ErrTemplate_LONG_END		14
#define ErrTemplate_END				15
#define ErrTemplateMAX				16

const 	DWORD	dwDefaultMask				= 0x6;	// toNTLog(OFF), toIISLog(ON), toBrowser(ON)

CHAR			g_szErrTemplate[ErrTemplateMAX][MAX_TEMPLATELEN];
const	LPSTR	szErrSysTemplate[]			= { "<html><body><h1> HTTP/1.1 ",
												"</h1></body></html>"};
CErrInfo		g_ErrInfoOOM, g_ErrInfoUnExpected;	
CHAR			szIISErrorPrefix[20];
DWORD			cszIISErrorPrefix;
CPINFO			g_SystemCPInfo;		// global System CodePage default info.

static char s_szContentTypeTextHtml[] = "Content-type: text/html\r\n\r\n";

CHAR *SzScodeToErrorCode(HRESULT hrError);
void FreeNullifySz(CHAR **szIn);
BOOL FIsResStrFormatted(char *szIn);

extern LONG g_nOOMErrors;

/*===================================================================
FreeNullifySz

Free the memory allocated in szIn, and Nullify the szIn.
===================================================================*/
void FreeNullifySz(CHAR **szIn)
{
	if(*szIn)
		{
		free(*szIn);
		*szIn = NULL;
		}
}

/*===================================================================
ErrHandleInit

PreLoad strings for
	1> OOM
	2> Browser Output Template
Returns:
	HRESULT
===================================================================*/
HRESULT ErrHandleInit(void)
{
	INT	iEntry, iEntryID;
	HRESULT	hr;

	// Retrieve global system codepage and stores it.
	GetCPInfo(CP_ACP, &g_SystemCPInfo);

	//Init g_szErrTemplate
	//Loop through, and load strings from resource file.
	for (iEntry = ErrTemplate_BEGIN, iEntryID = IDS_BROWSER_TEMPLATE_BEGIN;
			iEntry < ErrTemplateMAX; iEntry ++, iEntryID++)
		{
		CchLoadStringOfId(iEntryID, (CHAR *)g_szErrTemplate[iEntry], MAX_TEMPLATELEN);
		}

	g_ErrInfoOOM.m_szItem[Im_szErrorCode] = (CHAR *)malloc(sizeof(CHAR)*20*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoOOM.m_szItem[Im_szShortDescription] = (CHAR *)malloc(sizeof(CHAR)*256*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoOOM.m_szItem[Im_szLongDescription] = (CHAR *)malloc(sizeof(CHAR)*512*g_SystemCPInfo.MaxCharSize);

    if (!g_ErrInfoOOM.m_szItem[Im_szErrorCode]        ||
        !g_ErrInfoOOM.m_szItem[Im_szShortDescription] ||
        !g_ErrInfoOOM.m_szItem[Im_szLongDescription])
        {
        return E_OUTOFMEMORY;
        }
	
	hr = LoadErrResString(IDE_OOM,
						&g_ErrInfoOOM.m_dwMask,
						g_ErrInfoOOM.m_szItem[Im_szErrorCode],
						g_ErrInfoOOM.m_szItem[Im_szShortDescription],
						g_ErrInfoOOM.m_szItem[Im_szLongDescription]);

	
	g_ErrInfoUnExpected.m_szItem[Im_szErrorCode] = (CHAR *)malloc(sizeof(CHAR)*20*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoUnExpected.m_szItem[Im_szShortDescription] = (CHAR *)malloc(sizeof(CHAR)*256*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoUnExpected.m_szItem[Im_szLongDescription] = (CHAR *)malloc(sizeof(CHAR)*512*g_SystemCPInfo.MaxCharSize);

    if (!g_ErrInfoUnExpected.m_szItem[Im_szErrorCode]        ||
        !g_ErrInfoUnExpected.m_szItem[Im_szShortDescription] ||
        !g_ErrInfoUnExpected.m_szItem[Im_szLongDescription])
        {
        return E_OUTOFMEMORY;
        }
	
	hr = LoadErrResString(IDE_UNEXPECTED,
						&g_ErrInfoUnExpected.m_dwMask,
						g_ErrInfoUnExpected.m_szItem[Im_szErrorCode],
						g_ErrInfoUnExpected.m_szItem[Im_szShortDescription],
						g_ErrInfoUnExpected.m_szItem[Im_szLongDescription]);

	cszIISErrorPrefix = CchLoadStringOfId(IDS_IISLOG_PREFIX , szIISErrorPrefix, 20);
	return hr;
}
/*===================================================================
 ErrHandleUnInit

 Unit the global err-handling data.

 Free up the OOM CErrInfo.

 Side Effect:

 Free up memory.
===================================================================*/
HRESULT ErrHandleUnInit(void)
{
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szErrorCode]);
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szShortDescription]);
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szLongDescription]);

	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szErrorCode]);
	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szShortDescription]);
	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szLongDescription]);
	return S_OK;
}
/*===================================================================
Constructor

===================================================================*/
CErrInfo::CErrInfo()
{
	for (UINT iErrInfo = 0; iErrInfo < Im_szItemMAX; iErrInfo++)
		m_szItem[iErrInfo] = NULL;
	m_bstrLineText = NULL;
	m_nColumn = -1;

	m_dwMask 	= 0;
	m_pIReq		= NULL;
	m_pHitObj	= NULL;

	m_dwHttpErrorCode = 0;
    m_dwHttpSubErrorCode = 0;
}

/*===================================================================
CErrInfo::ParseResourceString

Parse Resource String to get default mask, error type, short description,
and long description.

Assume resource string is proper formmated.
Format of resource string
DefaultMask~errortype~shortdescription~longdescription

In case we can not allocate szResourceString(szResourceString), we use default.
Returns:
	Nothing
===================================================================*/
HRESULT	CErrInfo::ParseResourceString(CHAR *szResourceString)
{
	CHAR 	*szToken 	= NULL;
	INT		cfield		= 0;
	INT		iItem		= 0;
	INT		iIndex		= 0;
	INT		rgErrInfoIndex[3] = {Im_szErrorCode, Im_szShortDescription, Im_szLongDescription};

	if(NULL == szResourceString)
		{
		m_dwMask = dwDefaultMask;
		for(iItem = 0, iIndex = 0; iIndex < 3; iIndex++)
			{
			iItem = rgErrInfoIndex[iIndex];
			m_szItem[iItem]	= g_ErrInfoUnExpected.m_szItem[iItem];
			}
		return S_OK;
		}
	//Mask
	szToken = (char *)_mbstok((unsigned char *)szResourceString, (unsigned char *)DELIMITER);
	if(szToken != NULL)
		{
		m_dwMask = atoi(szToken);
		cfield++;
		}
	else
		{
		m_dwMask = dwDefaultMask;
		}

	//3 String Items, ErrorCode,ShortDescription,LongDescription
	for(iItem = 0, iIndex = 0; iIndex < 3; iIndex++)
		{
		szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
		iItem = rgErrInfoIndex[iIndex];
		if (szToken != NULL)
			{
			m_szItem[iItem]	= szToken;
			cfield++;
			}
		else
			{
			// Long Description is optional.
			if (Im_szLongDescription != iItem)
			    {
    			m_szItem[iItem]	= g_ErrInfoUnExpected.m_szItem[iItem];
    			}
			cfield++;
			}
		}

	//check wether we have wrong format of resource string.
	Assert(cfield == 4);

	return S_OK;
}

/*===================================================================
CErrInfo::LogError(void)

Perform all the switch logic in this functions. Send error to NT Log,
IIS Log, or Browser.
When reach this point, we assume all the strings have allocated, and will not be used after this
function.

Side effects:

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogError(void)
{
	HRESULT	hr 		= S_OK;
	HRESULT hr_ret	= S_OK;
	UINT	iEInfo	= 0;
	BOOL	fIISLogFailed, fDupToNTLog;

#if DBG
	// Print details about the error to debug window; don't bother if
	// info is NULL (happens for things like 404 not found, etc.)

	if (m_szItem[Im_szEngine] != NULL && m_szItem[Im_szFileName] != NULL)
		{
		DBGERROR((DBG_CONTEXT, "%s error in %s at line %s\n",
								m_szItem[Im_szEngine],
								m_szItem[Im_szFileName],
								m_szItem[Im_szLineNum]? m_szItem[Im_szLineNum] : "?"));

		DBGPRINTF((DBG_CONTEXT, "  %s: %s\n",
								m_szItem[Im_szErrorCode],
								m_szItem[Im_szShortDescription]));
		}
	else
		DBGERROR((DBG_CONTEXT, "ASP Error: %s\n", m_szItem[Im_szShortDescription]? m_szItem[Im_szShortDescription] : "?"));
#endif

	// Attach ASP error to HitObj (if exists and in 'executing' state)
	if (m_pHitObj && m_pHitObj->FExecuting())
	    {
	    CASPError *pASPError = new CASPError(this);
	    if (pASPError)
    	    m_pHitObj->SetASPError(pASPError);
	    }
	
	hr = LogErrortoIISLog(&fIISLogFailed, &fDupToNTLog);
	if (FAILED(hr))
		{
		hr_ret = hr;
		}

	//fIISLogFailed, if it is TRUE, then, this error was upgraded, and should be a WARNING type in
	//NT event log.
	hr = LogErrortoNTEventLog(fIISLogFailed, fDupToNTLog);
	if (FAILED(hr))
		{
		hr_ret = hr;
		}
		
	hr = LogErrortoBrowserWrapper();
	
	if (FAILED(hr))
		{
		hr_ret = hr;
		}
		
	if (m_pHitObj)
		{
		m_pHitObj->SetExecStatus(eExecFailed);
		}
	//In case of an error, hr_ret is the last error reported from the 3 logging functions.
	return hr_ret;
	
}

/*===================================================================
CErrInfo::LogErrortoNTEventLog

Log Error/Event to NT Event Log.

Returns:
	Nothing
===================================================================*/
HRESULT CErrInfo::LogErrortoNTEventLog
(
BOOL fIISLogFailed,
BOOL fDupToNTLog
)
{
	CHAR szErrNTLogEntry[4096];
	CHAR szStringTemp[MAX_PATH];
	INT	cch = 0;

	if(Glob(fLogErrorRequests))
		{
		//Is the error serious enough to get into NT log
		if(ERR_FLogtoNT(m_dwMask) || fIISLogFailed || fDupToNTLog)
			{
			szErrNTLogEntry[0] = '\0';

			if (fIISLogFailed)
				{
				cch = CchLoadStringOfId(IDS_LOG_IISLOGFAILED, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				}
				
			if (m_szItem[Im_szFileName] != NULL)
				{
				cch = CchLoadStringOfId(IDS_LOGTOEVENTLOG_FILE, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				strncat(szErrNTLogEntry, m_szItem[Im_szFileName], 512);	
				}
			strncat(szErrNTLogEntry, " ", 1);

			if (m_szItem[Im_szLineNum] != NULL)
				{
				cch = CchLoadStringOfId(IDS_LOGTOEVENTLOG_LINE, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				strncat(szErrNTLogEntry, m_szItem[Im_szLineNum], 48);	
				}
			strncat(szErrNTLogEntry, " ", 1);
			
			//Ok, do we have something to log.
			if (m_szItem[Im_szShortDescription] != NULL)
				{
				// ShortDescription does not have ". " at the end.
				// Therefore, the next strncat need to concatenate two sentences together with
				// a period ". ".
				char szTempPeriod[] = ". ";
				
				strncat(szErrNTLogEntry, m_szItem[Im_szShortDescription], 512);
				strncat(szErrNTLogEntry, szTempPeriod, 512);
				}
			else
				{
				DWORD dwMask;
				CHAR szDenaliNotWorking[MAX_PATH];
				
				LoadErrResString(IDE_UNEXPECTED, &dwMask, NULL, szDenaliNotWorking, NULL);
				strncat(szErrNTLogEntry, szDenaliNotWorking, strlen(szDenaliNotWorking));
				}

			//Ok, do we have something to log.
			if (m_szItem[Im_szLongDescription] != NULL)
				{
				strncat(szErrNTLogEntry, m_szItem[Im_szLongDescription], 512);
				}

			if (fIISLogFailed || fDupToNTLog)
				MSG_Warning((LPCSTR)szErrNTLogEntry);
			else
				MSG_Error((LPCSTR)szErrNTLogEntry);
			}
		}

	return S_OK;
}

/*===================================================================
CErrInfo::LogErrortoIISLog

Log Error/Event to IIS Log.

If we fail to log the message then upgrade logging to NT event Log
with entries indicate the error and the IIS log failed.

Also do the upgrade if the global setting says so.

Returns:
	Nothing
===================================================================*/
HRESULT	CErrInfo::LogErrortoIISLog
(
BOOL *pfIISLogFailed,
BOOL *pfDupToNTLog
)
{
	HRESULT			hr				= S_OK;
	const	LPSTR	szIISDelimiter	= "|";
	const	DWORD	cszIISDelimiter = 1; // strlen("|");
	const	LPSTR	szIISNoInfo		= "-";
	const	DWORD	cszIISNoInfo	= 1; // strlen("-");
	const	CHAR	chProxy			= '_';
	CIsapiReqInfo  *pIReq = NULL;

	*pfIISLogFailed = FALSE;
	*pfDupToNTLog = FALSE;
	
	if (m_pIReq == NULL && m_pHitObj == NULL)
		return S_OK;
	
	//Try to write to IISLog via pIReq->QueryPszLogData()
	if (ERR_FLogtoIIS(m_dwMask))
		{
		//get pIReq
		if (m_pHitObj)
			{
			pIReq = m_pHitObj->PIReq();
			}

		if (NULL == pIReq)
			{
			pIReq = m_pIReq;
			}

		if (pIReq == NULL)
			{
			*pfIISLogFailed = TRUE;
			return E_FAIL;
			}

		// Setup the sub-string array
		const DWORD crgsz = 3;
		LPSTR rgsz[crgsz];

		rgsz[0] = m_szItem[Im_szLineNum];
		rgsz[1] = m_szItem[Im_szErrorCode];
		rgsz[2] = m_szItem[Im_szShortDescription];

		// Allocate the log entry string
		CHAR *szLogEntry = NULL;
		DWORD cszLogEntry = (cszIISDelimiter * crgsz) + 1;
		DWORD dwIndex;

		for (dwIndex = 0; dwIndex < crgsz; dwIndex++)
			{
			if (rgsz[dwIndex])
				cszLogEntry += strlen(rgsz[dwIndex]);
			else
				cszLogEntry += cszIISNoInfo;
			}

		szLogEntry = new CHAR[cszLogEntry];
		if (NULL == szLogEntry) {
			return E_OUTOFMEMORY;
		}

		// Copy the entry, proxy bad characters
		CHAR *szSource = NULL;
		CHAR *szDest = szLogEntry;

		// Start with a delimiter to separate us from
        // the request query
        memcpy(szDest, szIISDelimiter, cszIISDelimiter);
		szDest += cszIISDelimiter;

		for (dwIndex = 0; dwIndex < crgsz; dwIndex++)
			{
			szSource = rgsz[dwIndex];
			if (szSource)
				{
				while (*szSource)
					{
					if (isleadbyte(*szSource))
						{
						*szDest++ = *szSource++;
						*szDest++ = *szSource++;
						}
					else if ((*szSource == ',') ||
							 (*szSource == ' ') ||
							 (*szSource == '\r') ||
							 (*szSource == '\n') ||
							 (*szSource == '\"'))
						{
						*szDest++ = chProxy;
						szSource++;
						}
					else
						*szDest++ = *szSource++;
					}
				}
			else
				{
				memcpy(szDest, szIISNoInfo, cszIISNoInfo);
				szDest += cszIISNoInfo;
				}

			if ((dwIndex + 1) < crgsz)
				{
				// Another sub-string comming, use a delimiter
				memcpy(szDest, szIISDelimiter, cszIISDelimiter);
				szDest += cszIISDelimiter;
				}
			}
		*szDest = '\0';
		
		// Log it		
		BOOL fResult = TRUE;

        fResult = SUCCEEDED(pIReq->AppendLogParameter(szLogEntry));

		// Set "500" error in log.
		if (pIReq->ECB()->dwHttpStatusCode == 200)   // error content sent, OK, but really an error
			pIReq->ECB()->dwHttpStatusCode = 500;

		// Release log string
		delete [] szLogEntry;
			
		// If any error occurred while writing to log, upgrade to NT Event log
		if (!fResult)
			{
			m_dwMask = ERR_SetLogtoNT(m_dwMask);
			*pfIISLogFailed = TRUE;
			}
			
		// Even if successful we might still want the message
		// in the NT event log if the global setting to do so is on.
	    else if (Glob(fDupIISLogToNTLog))
	        {
	        if (!ERR_FLogtoNT(m_dwMask))
	            {
                // Need to remember the flag in order to insert
                // the upgraded IIS log error as NT log warnings.
                // The errors already destined for NT log should
                // stay as errors.
    			m_dwMask = ERR_SetLogtoNT(m_dwMask);
    			*pfDupToNTLog = TRUE;
    			}
			}
			
		hr = S_OK;
		}
		
	return(hr);
}

/*===================================================================
CErrInfo::LogErrortoBrowserWrapper

Just a Wrapper around Log Error/Event to Browser.

In this function, pIReq or pResponse is resolved.

NOTE:
Unfortunately, this function can not tell pResponse is inited or not.
In case when pResponse has not been inited, pResponse is not NULL, but things
in pResponse are invalid.
Therefore, caller need to provide pIReq in case where pResponse has not been inited.

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogErrortoBrowserWrapper()
{
	HRESULT hr = S_OK;

	//
	// Must have passed in either an CIsapiReqInfo or a HITOBJ.  Otherwise, there is nothing we can do.
	// This condition occurs in case of HandleOOMError
	//
	if (m_pIReq == NULL && m_pHitObj == NULL)
		return E_FAIL;


    // Remember response object if any	
    CResponse *pResponse = m_pHitObj ? m_pHitObj->PResponse() : NULL;

	CIsapiReqInfo *pIReq =
	    (m_pHitObj && pResponse && m_pHitObj->PIReq()) ?
	        m_pHitObj->PIReq() : m_pIReq;
	if (!pIReq)
	    return E_FAIL;

    // Do custom errors only if response headers aren't written already
    // ALSO: No custom error if called from global.asa, with intrinsic objects hidden.
    //   (Appln_OnStart & Session_OnStart)
    //
    // for errors in Appln_OnEnd or Session_OnEnd, these are not browser requests
    // and so pResponse == NULL in this case.

    if (!pResponse || !pResponse->FHeadersWritten())
        {
        BOOL fIntrinsicsWereHidden = FALSE;
        if (m_pHitObj)
       	    {
       	    fIntrinsicsWereHidden = m_pHitObj->FRequestAndResponseIntrinsicsHidden();
       	    m_pHitObj->UnHideRequestAndResponseIntrinsics();
       	    }

        BOOL fCustom = FALSE;
        hr = LogCustomErrortoBrowser(pIReq, &fCustom);

        if (fIntrinsicsWereHidden)
        	m_pHitObj->HideRequestAndResponseIntrinsics();

        if (fCustom)
            return hr;
        }

	// No custom error - do regular error from this object

	if (m_szItem[Im_szHeader])
		{
	    BOOL fRet = pIReq->SendHeader
	        (
			m_szItem[Im_szHeader],
			strlen(m_szItem[Im_szHeader]) + 1,
			s_szContentTypeTextHtml,
			sizeof(s_szContentTypeTextHtml),
			FALSE
			);

        if (!fRet)					
			return E_FAIL;
		}

	if (pResponse)
		hr = LogErrortoBrowser(pResponse);
	else
		hr = LogErrortoBrowser(pIReq);
		
	return hr;
}

/*===================================================================
CErrInfo::LogCustomErrortoBrowser

Called by LogErrortoBrowserWrapper.

Parameters
    pIReq
    pfCustomErrorProcessed

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogCustomErrortoBrowser
(
CIsapiReqInfo *pIReq,
BOOL *pfCustomErrorProcessed
)
    {
    // Custom errors when HttpErrorCode is specified (404 or 500),
    // or '500;100' ASP scripting error case
    BOOL fTryErrorTransfer = FALSE;
    DWORD dwCode, dwSubCode;

    if (m_dwHttpErrorCode == 404 || m_dwHttpErrorCode == 500 || m_dwHttpErrorCode == 401)
        {
        dwCode = m_dwHttpErrorCode;
        dwSubCode = m_dwHttpSubErrorCode;
        }
    else if (m_dwHttpErrorCode == 0 && m_pHitObj &&
             m_pHitObj->FHasASPError() &&               // there's an error on this page
             m_pHitObj->FExecuting() &&                 // while executing
             !m_pHitObj->FInTransferOnError() &&        // not inside transfer-on-error already
             m_pHitObj->PAppln() && m_pHitObj->PResponse() && m_pHitObj->PServer() &&
			 m_pHitObj->PAppln()->QueryAppConfig()->pCLSIDDefaultEngine())   // engine in the registry is valid
        {
        dwCode = 500;
        dwSubCode = 100;
        fTryErrorTransfer = TRUE;
        }
    else
        {
        // no need to try
        *pfCustomErrorProcessed = FALSE;
        return S_OK;
        }

    // Get custom error from W3SVC


    STACK_BUFFER( tempParamBuf, MAX_PATH );
    TCHAR *szBuf = (TCHAR *)tempParamBuf.QueryPtr();
    DWORD dwLen = MAX_PATH;
    BOOL fIsFileError;
    BOOL fSendErrorBody;

    BOOL fRet = pIReq->GetCustomError(dwCode, dwSubCode, dwLen, szBuf, &dwLen, &fIsFileError, &fSendErrorBody);
    if (!fRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        if (tempParamBuf.Resize(dwLen) == TRUE) {
            szBuf = (TCHAR *)tempParamBuf.QueryPtr();
            fRet = pIReq->GetCustomError(dwCode, dwSubCode, dwLen, szBuf, &dwLen, &fIsFileError, &fSendErrorBody);
        }
    }
    if (fRet) {


        if (fSendErrorBody == FALSE) {
             // suppress all output through intrinsic
            if (m_pHitObj && m_pHitObj->PResponse())
                 m_pHitObj->PResponse()->SetIgnoreWrites();
        }
        if (fIsFileError) {
            // Verify that the error file can be read
            if (FAILED(AspGetFileAttributes(szBuf)))
                fRet = FALSE;
        }
        else {
            // Avoid circular client redirections
            // (check if the current URL is the same as error URL
            if (_tcsicmp(szBuf, pIReq->QueryPszPathInfo()) == 0)
                fRet = FALSE;
        }
    }

    if (!fRet) {
        // no custom error found
        *pfCustomErrorProcessed = FALSE;
        return S_OK;
    }

    // There's a custom error - use it

    HRESULT hr = S_OK;

    if (fIsFileError)
        {

        if (fSendErrorBody)
            // in case of file errors mime type follows the file path
            // in the returned buffer
            hr = WriteCustomFileError(pIReq, szBuf, szBuf+_tcslen(szBuf)+1);
        }
    else if (fTryErrorTransfer)
        {
        // transfer to URL

        // need to Map Path first
    	TCHAR szTemplate[MAX_PATH];
        WCHAR   *pErrorURL;
#if UNICODE
        pErrorURL = szBuf;
#else
        CMBCSToWChar    convStr;
        if (FAILED(convStr.Init(szBuf))) {
            *pfCustomErrorProcessed = FALSE;
            return S_OK;
        }
        pErrorURL = convStr.GetString();
#endif

        if (FAILED(m_pHitObj->PServer()->MapPathInternal(0, pErrorURL, szTemplate))) {
            // could use custom error
            *pfCustomErrorProcessed = FALSE;
            return S_OK;
        }
        Normalize(szTemplate);

        // do the transfer
        m_pHitObj->SetInTransferOnError();
        hr = m_pHitObj->ExecuteChildRequest(TRUE, szTemplate, szBuf);

        if (FAILED(hr))
            {
            // error while reporting error -- report both
            LogErrortoBrowser(m_pHitObj->PResponse());
            }
        }
    else
        {
        // client redirect to URL
        hr = WriteCustomURLError(pIReq, szBuf);
        }

    if (fIsFileError || !fTryErrorTransfer)
        {
        // suppress all output through intrinsic
        if (m_pHitObj && m_pHitObj->PResponse())
             m_pHitObj->PResponse()->SetIgnoreWrites();
        }

    *pfCustomErrorProcessed = TRUE;
    return hr;
    }

/*===================================================================
CErrInfo::WriteCustomFileError

Dumps the content of a custom error file to the browser

Returns:
	NONE.
===================================================================*/
HRESULT CErrInfo::WriteCustomFileError
(
CIsapiReqInfo   *pIReq,
TCHAR *szPath,
TCHAR *szMimeType
)
{
    HRESULT hr = S_OK;
    char *szStatus = m_szItem[Im_szHeader];
    char *pszMBCSMimeType;

#if UNICODE
    CWCharToMBCS    convStr;

    if (FAILED(hr = convStr.Init(szMimeType, 65001))) {
        return hr;
    }
    else {
        pszMBCSMimeType = convStr.GetString();
    }
#else
    pszMBCSMimeType = szMimeType;
#endif

    if (szStatus == NULL) {
        // no status set -- get it from the response object if available
        CResponse *pResponse = m_pHitObj ? m_pHitObj->PResponse() : NULL;
        if (pResponse)
            szStatus = pResponse->PCustomStatus();
    }

    hr = CResponse::SyncWriteFile(pIReq,
                                  szPath,
                                  pszMBCSMimeType,
                                  szStatus);        // NULL is OK - means 200

    return hr;
}

/*===================================================================
CErrInfo::WriteCustomURLError

Sends client redirect to the custom URL error

Returns:
	NONE.
===================================================================*/
HRESULT CErrInfo::WriteCustomURLError(
CIsapiReqInfo   *pIReq,
TCHAR           *sztURL)
{
    // Header is
    // Location: redirect_URL?code;http://original_url

    HRESULT         hr = S_OK;
    char            *szURL;
#if UNICODE
    CWCharToMBCS    convRedirURL;

    if (FAILED(hr = convRedirURL.Init(sztURL,65001))) {
        return hr;
    }

    szURL = convRedirURL.GetString();
#else
    szURL = sztURL;
#endif

    // code
    char szCode[8];
    if (m_dwHttpErrorCode > 0 && m_dwHttpErrorCode < 1000)
        ltoa(m_dwHttpErrorCode, szCode, 10);
    else
        return E_FAIL;

    // get the current URL
    char szServer[128];
    DWORD dwServerSize = sizeof(szServer);

    STACK_BUFFER( tempHeader, 256 );
    if (!pIReq->GetServerVariableA("SERVER_NAME", szServer, &dwServerSize))
        return E_FAIL; // shouldn't happen
    char  *szOrigURL;
#if UNICODE
    CWCharToMBCS    convOrigStr;

    if (FAILED(hr = convOrigStr.Init(pIReq->QueryPszPathInfo(), 65001))) {
        return hr;
    }

    szOrigURL = convOrigStr.GetString();
#else
    szOrigURL = pIReq->QueryPszPathInfo();
#endif

    // estimate of the length
    DWORD cchHeaderMax = strlen(szURL)
                       + strlen(szServer)
                       + strlen(szOrigURL)
                       + 80;    // decorations

    if (tempHeader.Resize(cchHeaderMax) == FALSE) {
        return E_OUTOFMEMORY;
    }
    char *szHeader = (char *)tempHeader.QueryPtr();

    // construct the redirection header
    char *szBuf = szHeader;
    szBuf = strcpyExA(szBuf, "Location: ");
    szBuf = strcpyExA(szBuf, szURL);
    szBuf = strcpyExA(szBuf, "?");
    szBuf = strcpyExA(szBuf, szCode);
    szBuf = strcpyExA(szBuf, ";http://");
    szBuf = strcpyExA(szBuf, szServer);
    szBuf = strcpyExA(szBuf, szOrigURL);
    szBuf = strcpyExA(szBuf, "\r\n\r\n");
    Assert(strlen(szHeader) < cchHeaderMax);

    // set the status
    static char s_szRedirected[] = "302 Object moved";
	pIReq->SetDwHttpStatusCode(302);

    // send the header
    BOOL fRet = pIReq->SendHeader(s_szRedirected,
		                          sizeof(s_szRedirected),
		                          szHeader,
		                          strlen(szHeader) + 1,
		                          FALSE);

    return (fRet ? S_OK : E_FAIL);
}

/*===================================================================
CErrInfo::WriteHTMLEncodedErrToBrowser

Log Error/Event to Browser with HTMLEncoded via either pResponse or pIReq.

Either pResponse or pIReq must be valid.

Returns:
	NONE.
===================================================================*/
void CErrInfo::WriteHTMLEncodedErrToBrowser
    (
    const CHAR *StrIn,
    CResponse *pResponse,
    CIsapiReqInfo   *pIReq
    )
{
CHAR szHTMLEncoded[2*MAX_RESSTRINGSIZE];
LPSTR pszHTMLEncoded = NULL;
LPSTR pStartszHTMLEncoded = NULL;
DWORD	nszHTMLEncoded = 0;
BOOL fStrAllocated = FALSE;

	nszHTMLEncoded = HTMLEncodeLen(StrIn, CP_ACP, NULL);
	

	if (nszHTMLEncoded > 0)
		{
		if (nszHTMLEncoded > 2 * MAX_RESSTRINGSIZE)
			{
			pszHTMLEncoded = new char[nszHTMLEncoded+2];
			if (pszHTMLEncoded)
				{
				fStrAllocated = TRUE;
				}
			else
				{
				HandleOOMError(NULL, NULL);
				return;
				}
			}
		else
			pszHTMLEncoded = &szHTMLEncoded[0];

		pStartszHTMLEncoded = pszHTMLEncoded;
		pszHTMLEncoded = HTMLEncode(pszHTMLEncoded, StrIn, CP_ACP, NULL);
		
		nszHTMLEncoded--;		// take out the count for '\0'.
		if (pResponse)
			pResponse->WriteSz((CHAR *)pStartszHTMLEncoded, nszHTMLEncoded);
		else
			CResponse::StaticWrite(pIReq, pStartszHTMLEncoded, nszHTMLEncoded);
		}

	if (fStrAllocated)
		delete [] pStartszHTMLEncoded;

	return;
}

/*===================================================================
CErrInfo::LogErrortoBrowser

Log Error/Event to Browser via pResponse.

We will output
	1> default ScriptErrorMessage or
	2> Error Info/Default Template/has long description available or
	3> Error Info/Default Template/no long description available

Returns:
	HRESULT
===================================================================*/
HRESULT CErrInfo::LogErrortoBrowser(CResponse *pResponse)
{
	INT	cch 	= 0;
	INT	cLine	= 0;
	INT iErrTemplate = 0;
	
	Assert(NULL != pResponse);

	// When the error code is zero, then it's coming from a 500 error code path.
	//   (HandleSysError presets the code to 404 or 204.)
	//
	if (!pResponse->FHeadersWritten() && (m_dwHttpErrorCode == 500 || m_dwHttpErrorCode == 0))
		pResponse->put_Status(L"500 Internal Server Error");

	if(ERR_FIsSysFormat(m_dwMask))
		{
		DWORD	cChHeader	= strlen(szErrSysTemplate[0]);
		DWORD	cChTail		= strlen(szErrSysTemplate[1]);
			
		pResponse->WriteSz((CHAR *)szErrSysTemplate[0], cChHeader);
		WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[Im_szShortDescription], pResponse, NULL);
		pResponse->WriteSz((CHAR *)szErrSysTemplate[1], cChTail);
		return S_OK;
		}
		
	if (!(m_pHitObj->QueryAppConfig())->fScriptErrorsSentToBrowser())
		{
        cch = strlen((CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()));
		GlobStringUseLock();
        pResponse->WriteSz((CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()),cch);
		GlobStringUseUnLock();
		}
	else
		{
		// line 0 is the begin line.
		cch = strlen((CHAR *)g_szErrTemplate[ErrTemplate_BEGIN]);
		pResponse->WriteSz((CHAR *)g_szErrTemplate[ErrTemplate_BEGIN], cch);

		//7 standard items(file, line, engine, error#, short description, code, long description)
		//If any info missing(is NULL), we skip.
		for (cLine = 0; cLine < 7; cLine++)
			{
			if (NULL == m_szItem[cLine])
	  	 		continue;
			
			iErrTemplate = cLine * 2 + 1;
			/*	BUG 78782 (IIS Active) */
	  		//WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], pResponse, NULL);
	  		pResponse->WriteSz((CHAR *)g_szErrTemplate[iErrTemplate], strlen((CHAR *)g_szErrTemplate[iErrTemplate]));
	  		
	  		
	  	 	WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[cLine], pResponse, NULL);
	  	 	
	  	 	iErrTemplate++;
	  	 	/*	BUG 78782 (IIS Active) */
	  		//WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], pResponse, NULL);
	  		pResponse->WriteSz((CHAR *)g_szErrTemplate[iErrTemplate], strlen((CHAR *)g_szErrTemplate[iErrTemplate]));
	  	 	}

		//ouput the end line
		cch = strlen((CHAR *)g_szErrTemplate[ErrTemplate_END]);
		pResponse->WriteSz((CHAR *)g_szErrTemplate[ErrTemplate_END], cch);
		}	
	return S_OK;
}

/*===================================================================
CErrInfo::LogErrortoBrowser

Log Error/Event to Browser via pIReq.

We will output
	1> default ScriptErrorMessage or
	2> Error Info/Default Template/has long description available or
	3> Error Info/Default Template/no long description available

Returns:
	HRESULT
===================================================================*/
HRESULT CErrInfo::LogErrortoBrowser(CIsapiReqInfo  *pIReq)
{
	INT			cLine	= 0;
	INT			iErrTemplate 	= 0;
	
	Assert(NULL != pIReq);

	//HTTP type error, 204, 404, 500
	//mimic IIS error reporting
	//And send out the header.
	if(ERR_FIsSysFormat(m_dwMask))
		{
		CResponse::StaticWrite(pIReq, szErrSysTemplate[0]);
		WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[Im_szShortDescription], NULL, pIReq);
		CResponse::StaticWrite(pIReq, szErrSysTemplate[1]);
		return S_OK;
		}

	if (!(m_pHitObj->QueryAppConfig())->fScriptErrorsSentToBrowser())
		{
		GlobStringUseLock();
        CResponse::StaticWrite(pIReq, (CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()));
		GlobStringUseUnLock();
		}
	else
		{
		// line 0 is the begin line.
		CResponse::StaticWrite(pIReq, g_szErrTemplate[ErrTemplate_BEGIN]);

		//7 standard items(file, line, engine, error#, short description, code, long description)
		//If any info missing(is NULL), we skip.
		for (cLine = 0; cLine < 5; cLine++)
			{
			if (NULL == m_szItem[cLine])
	  	 		continue;
			
			iErrTemplate = cLine * 2 + 1;
	  		WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], NULL, pIReq);
	  		
	  	 	WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[cLine], NULL, pIReq);

	  	 	iErrTemplate++;
	  		WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], NULL, pIReq);
	  	 	}

		//ouput the end line
		CResponse::StaticWrite(pIReq, g_szErrTemplate[ErrTemplate_END]);
		}

	return S_OK;
}


/*===================================================================
CchLoadStringOfId

Loads a string from the string table.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CchLoadStringOfId
(
UINT id,
CHAR *sz,
INT cchMax
)
	{
	INT cchRet;
	
	// The handle to the DLL instance should have been set up when we were loaded
	if (g_hResourceDLL == (HINSTANCE)0)
		{
		// Totally bogus
		Assert(FALSE);
		return(0);
		}

	cchRet = LoadStringA(g_hResourceDLL, id, sz, cchMax);

    IF_DEBUG(ERROR)
        {
    	// For debugging purposes, if we get back 0, get the last error info
    	if (cchRet == 0)
    		{
    		DWORD err = GetLastError();
    		DBGERROR((DBG_CONTEXT, "Failed to load string resource.  Id = %d, error = %d\n", id, err));
    		DBG_ASSERT(FALSE);
    		}
		}

	return(cchRet);
	}


/*===================================================================
CwchLoadStringOfId

Loads a string from the string table as a UNICODE string.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CwchLoadStringOfId
(
UINT id,
WCHAR *sz,
INT cchMax
)
	{
	INT cchRet;
	
	// The handle to the DLL instance should have been set up when we were loaded
	if (g_hResourceDLL == (HINSTANCE)0)
		{
		// Totally bogus
		Assert(FALSE);
		return(0);
		}

    cchRet = LoadStringW(g_hResourceDLL, id, sz, cchMax);

    IF_DEBUG(ERROR)
        {
    	// For debugging purposes, if we get back 0, get the last error info
    	if (cchRet == 0)
    		{
    		DWORD err = GetLastError();
    		DBGERROR((DBG_CONTEXT, "Failed to load string resource.  Id = %d, error = %d\n", id, err));
    		DBG_ASSERT(FALSE);
    		}
		}

	return(cchRet);
	}

/*===================================================================
HandleSysError

Dumps the error to the client and/or to the log
Loads a string from the string table as a UNICODE string.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
HRESULT HandleSysError(	DWORD dwHttpError,
                        DWORD dwHttpSubError,
                        UINT ErrorID,
						UINT ErrorHeaderID,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	CHAR		szResourceStr[MAX_RESSTRINGSIZE];
	CHAR		szHeader[MAX_HEADERSIZE];
	INT			cch;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_pHitObj = pHitObj;
	pErrInfo->m_pIReq	= pIReq;
	if (ErrorHeaderID != 0)
		{
		cch = CchLoadStringOfId(ErrorHeaderID, szHeader, MAX_HEADERSIZE);
		pErrInfo->m_szItem[Im_szHeader] = szHeader;
		}
	else
		{
		pErrInfo->m_szItem[Im_szHeader] = NULL;
		}
		
	if (ErrorID != 0)
		cch = CchLoadStringOfId(ErrorID, szResourceStr, MAX_RESSTRINGSIZE);
		
	pErrInfo->ParseResourceString(szResourceStr);

	pErrInfo->m_dwMask = ERR_SetSysFormat(pErrInfo->m_dwMask);

    pErrInfo->m_dwHttpErrorCode = dwHttpError;
    pErrInfo->m_dwHttpSubErrorCode = dwHttpSubError;
	
	pErrInfo->LogError();

	return S_OK;
}

/*===================================================================
Handle500Error

Based on ErrorID determines headerID, code, sub-code, and
calls HandleSysError()

Returns:
	HRESULT
===================================================================*/
HRESULT Handle500Error( UINT errorId,
                        CIsapiReqInfo   *pIReq)
{
    UINT  headerId;
    DWORD dwHttpSubError;

    switch (errorId)
        {
        case IDE_SERVER_TOO_BUSY:
            headerId = IDH_500_SERVER_ERROR;
    		dwHttpSubError = SUBERRORCODE500_SERVER_TOO_BUSY;
            break;

        case IDE_SERVER_SHUTTING_DOWN:
            headerId = IDH_500_SERVER_ERROR;
       		dwHttpSubError = SUBERRORCODE500_SHUTTING_DOWN;
       		break;

        case IDE_GLOBAL_ASA_CHANGED:
            headerId = IDH_500_SERVER_ERROR;
            dwHttpSubError = SUBERRORCODE500_RESTARTING_APP;
            break;

        case IDE_INVALID_APPLICATION:
    		headerId = IDH_500_SERVER_ERROR;
	    	dwHttpSubError = SUBERRORCODE500_INVALID_APP;
	    	break;

        case IDE_GLOBAL_ASA_FORBIDDEN:
    		headerId = IDH_500_SERVER_ERROR;
	    	dwHttpSubError = SUBERRORCODE500_GLOBALASA_FORBIDDEN;
	    	break;

        default:
            headerId = IDH_500_SERVER_ERROR;
    		dwHttpSubError = SUBERRORCODE500_SERVER_ERROR;
    		break;
		}

    pIReq->SetDwHttpStatusCode(500);
    return HandleSysError(500, dwHttpSubError, errorId, headerId, pIReq, NULL);
}

/*===================================================================
HandleOOMError

Handle OOM error with special care, because we can not do any dynamic allocation.

if pIReq or pHitObj is NULL, nothing will be reported to browser

Returns:
	Nothing
===================================================================*/
HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj)
{
	CErrInfo OOMErrInfo;
	CErrInfo *pErrInfo;

    // Note the OOM occurred

    InterlockedIncrement(&g_nOOMErrors);

	pErrInfo = (CErrInfo *)&OOMErrInfo;

	pErrInfo->m_pIReq 	= pIReq;
	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_dwMask	= g_ErrInfoOOM.m_dwMask;
	pErrInfo->m_szItem[Im_szErrorCode] = g_ErrInfoOOM.m_szItem[Im_szErrorCode];
	pErrInfo->m_szItem[Im_szShortDescription] = g_ErrInfoOOM.m_szItem[Im_szShortDescription];
	pErrInfo->m_szItem[Im_szLongDescription] = g_ErrInfoOOM.m_szItem[Im_szLongDescription];

	pErrInfo->LogError();

	return S_OK;
}
/*===================================================================
HandleError

Handle reporting of errors given ErrorID, FileName, and LineNum.

If Caller provide ErrCode or LongDescription, the default value will be overwriten.

Strings passed in will be freed.  That is, consider the function as a sink.  Caller
should not use strings after the call.

Returns:
	Nothing
===================================================================*/
HRESULT	HandleError(	UINT ErrorID,
						CHAR *szFileName,
						CHAR *szLineNum,
						CHAR *szEngine,
						CHAR *szErrCode,
						CHAR *szLongDes,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj,
                        va_list *pArgs)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	CHAR		szResourceStr[MAX_RESSTRINGSIZE];
    CHAR        szUnformattedResStr[MAX_RESSTRINGSIZE];
	HRESULT		hr = S_OK;

	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_szItem[Im_szFileName] 	= szFileName;
	pErrInfo->m_szItem[Im_szLineNum]	= szLineNum;
	pErrInfo->m_szItem[Im_szEngine]		= szEngine;

	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_pIReq	= pIReq;

	//Load resource string according to the resource ID.

    if (pArgs) {
	    CchLoadStringOfId(ErrorID, szUnformattedResStr, MAX_RESSTRINGSIZE);
        vsprintf(szResourceStr, szUnformattedResStr, *pArgs);
    }
    else {
	    CchLoadStringOfId(ErrorID, szResourceStr, MAX_RESSTRINGSIZE);
    }

	pErrInfo->ParseResourceString(szResourceStr);

	//NOTE: if ErrorCode/LongDescription not NULL, caller want to overwrite.
	if (szErrCode)
		{
		pErrInfo->m_szItem[Im_szErrorCode] = szErrCode;
		}
	if(szLongDes)
		{
		pErrInfo->m_szItem[Im_szLongDescription] = szLongDes;
		}
		
	hr = pErrInfo->LogError();

	//free up the inputs
	FreeNullifySz((CHAR **)&szFileName);
	FreeNullifySz((CHAR **)&szLineNum);
	FreeNullifySz((CHAR **)&szEngine);
	FreeNullifySz((CHAR **)&szErrCode);
	FreeNullifySz((CHAR **)&szLongDes);
	
	return hr;
}
/*===================================================================
HandleError

Handle reporting of errors given all the info.

This is basically a cover over HandleErrorSz which called from OnScriptError.

Strings passed in will be freed.  That is, consider the function as a sink.  Caller
should not use strings after the call.

Returns:
	Nothing
===================================================================*/
HRESULT HandleError(	CHAR *szShortDes,
						CHAR *szLongDes,
						DWORD dwMask,
						CHAR *szFileName,
						CHAR *szLineNum,
						CHAR *szEngine,
						CHAR *szErrCode,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	HRESULT		hr = S_OK;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;
		
	pErrInfo->m_dwMask 					= dwMask;

	pErrInfo->m_szItem[Im_szHeader]		= NULL;		// Caller has already sent out header
	pErrInfo->m_szItem[Im_szFileName] 	= szFileName;
	pErrInfo->m_szItem[Im_szLineNum]	= szLineNum;
	pErrInfo->m_szItem[Im_szEngine]		= szEngine;
	pErrInfo->m_szItem[Im_szErrorCode]	= szErrCode;
	pErrInfo->m_szItem[Im_szShortDescription]	= szShortDes;
	pErrInfo->m_szItem[Im_szLongDescription]	= szLongDes;
	
	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_pIReq	= pIReq;

	hr = pErrInfo->LogError();	

	//free up the inputs
	FreeNullifySz((CHAR **)&szFileName);
	FreeNullifySz((CHAR **)&szLineNum);
	FreeNullifySz((CHAR **)&szEngine);
	FreeNullifySz((CHAR **)&szErrCode);
	FreeNullifySz((CHAR **)&szShortDes);
	FreeNullifySz((CHAR **)&szLongDes);
		
	return hr;
}
/*===================================================================
HandleError

Handle reporting of errors given the IActiveScriptError and PFNLINEMAP.

This is basically a cover over HandleErrorSz which called from OnScriptError.

Returns:
	Nothing
===================================================================*/
HRESULT HandleError( IActiveScriptError *pscripterror,
					 CTemplate *pTemplate,
					 DWORD dwEngineID,
					 CIsapiReqInfo  *pIReq,
					 CHitObj *pHitObj )
	{
	UINT        cchBuf = 0;
	CHAR        *szOrigin = NULL;
	CHAR        *szDesc = NULL;
	CHAR        *szLine = NULL;
	CHAR        *szPrefix = NULL;
	UINT        cchOrigin = 0;
	UINT        cchDesc = 0;
	UINT        cchLineNum = 0;
	UINT        cchLine = 0;
	EXCEPINFO   excepinfo = {0};
	CHAR        *szResult = NULL;
	BSTR        bstrLine = NULL;
	HRESULT     hr;
	DWORD       dwSourceContext = 0;		// Don't trust this one
	ULONG       ulLineError = 0;
	BOOLB       fGuessedLine = FALSE;		// see bug 379
	CHAR        *szLineNumT = NULL;
	LPTSTR      szPathInfo = NULL;
	LPTSTR      szPathTranslated = NULL;
	LONG        ichError = -1;
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
    wchar_t     wszUnknownException[128];
    wchar_t     wszUnknownEngine[32];
    CWCharToMBCS  convStr;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_pIReq 	= pIReq;
	pErrInfo->m_pHitObj	= pHitObj;

	if (pscripterror == NULL)
		return E_POINTER;

	hr = pscripterror->GetExceptionInfo(&excepinfo);
	if (FAILED(hr))
		goto LExit;

	// bug 99543 If details are deferrred, use the callback to get
	// detailed information.
	if (excepinfo.pfnDeferredFillIn)
		excepinfo.pfnDeferredFillIn(&excepinfo);

    // if error is OOM, then increment the global counter.

    if ((excepinfo.wCode == ERROR_OUTOFMEMORY)
        || ((excepinfo.wCode == 0) && (excepinfo.scode == ERROR_OUTOFMEMORY)))
        InterlockedIncrement(&g_nOOMErrors);


	hr = pscripterror->GetSourcePosition(&dwSourceContext, &ulLineError, &ichError);
	if (FAILED(hr))
		goto LExit;

	// Intentionally ignore any error
	(VOID)pscripterror->GetSourceLineText(&bstrLine);

	if (pTemplate == NULL)
		goto LExit;

	// call GetScriptSourceInfo to get path-info (of file) and actual line number where error occurred
	// bug 379: if GetScriptSourceInfo returns fGuessedLine = TRUE, it means we gave it a non-authored line,
	// so we adjust below by not printing bstrLine in the error msg
	if (ulLineError > 0)
		pTemplate->GetScriptSourceInfo(dwEngineID, ulLineError, &szPathInfo, &szPathTranslated, &ulLineError, NULL, &fGuessedLine);
	else
		{
		// ulLineError was zero - no line # specified, so assume main file (usually this will be "out of memory"
		// so effect will be to display the script that was running when this occurred.
		//
		szPathInfo = pTemplate->GetSourceFileName(SOURCEPATHTYPE_VIRTUAL);
		szPathTranslated = pTemplate->GetSourceFileName(SOURCEPATHTYPE_PHYSICAL);
		}

    // if we have HitObj use it to get the virtual path to avoid
    // displaying of wrong path for shared templates
    //
    // first verify that PathTranslated == main file path; this file could be
    // an include file, in which case PszPathInfo is incorrect.
    //
    if (!pTemplate->FGlobalAsa() && szPathTranslated && _tcscmp(szPathTranslated, pTemplate->GetSourceFileName()) == 0 && pHitObj != NULL && pHitObj->PIReq())
        szPathInfo = pHitObj->PSzCurrTemplateVirtPath();

#if UNICODE
    pErrInfo->m_szItem[Im_szFileName] = StringDupUTF8(szPathInfo);
#else
	pErrInfo->m_szItem[Im_szFileName] = StringDupA(szPathInfo);
#endif
	szLineNumT = (CHAR *)malloc(10*sizeof(CHAR));
	if (szLineNumT)
		{
		// convert the line number
		_ltoa(ulLineError, szLineNumT, 10);
		}
	pErrInfo->m_szItem[Im_szLineNum] = szLineNumT;

	
	// is the scode one of the VBScript of JavaScript errors (this needs to be lang independent)
	// excepinfo.bstrDescription now has the formatted error string.
	if (excepinfo.bstrSource && excepinfo.bstrDescription)
		{
		// Bug 81954: Misbehaved objects may throw an exception without providing any information
		wchar_t *wszDescription;
		if (excepinfo.bstrDescription[0] == L'\0')
			{
			HRESULT hrError;

			if (0 == excepinfo.wCode)
				hrError = excepinfo.scode;
			else
				hrError = excepinfo.wCode;

            wszUnknownException[0] = '\0';
			// Bug 91847 Attempt to get a description via FormatMessage()
			if (!HResultToWsz(hrError, wszUnknownException, 128))
				CwchLoadStringOfId(IDE_SCRIPT_UNKNOWN, wszUnknownException, sizeof(wszUnknownException)/sizeof(WCHAR));
			wszDescription = wszUnknownException;
			}
		else
			wszDescription = excepinfo.bstrDescription;

		wchar_t *wszSource;
		if (excepinfo.bstrSource[0] == L'\0')
			{
            wszUnknownEngine[0] = '\0';
			CwchLoadStringOfId(IDS_DEBUG_APP, wszUnknownEngine, sizeof(wszUnknownEngine)/sizeof(WCHAR));
			wszSource = wszUnknownEngine;
			}
		else
			wszSource = excepinfo.bstrSource;

		CHAR *ch = NULL;
		
		// convert the Source to ascii

        if (convStr.Init(wszSource) != NO_ERROR) {
            szOrigin = NULL;
        }
        else {
            szOrigin = convStr.GetString(TRUE);
        }
		if (NULL != szOrigin)
			{
			// Remove the word "error"from  the string, if any, because we will
			//print out "error" when we print out the errorID
			cchOrigin = strlen(szOrigin);
			if (cchOrigin > 5) // 5 is strlen("error")
				{
				ch = szOrigin + cchOrigin - 5;
				if (!strncmp(ch, "error", 5))
					{// we found the word "error", truncate the szOrigin by null out the word "error"
					*ch = '\0';
					}
			  	}
			  	ch = NULL;
			} 	
		pErrInfo->m_szItem[Im_szEngine] = szOrigin;


		// convert the sDescription to ascii
        if (convStr.Init(wszDescription) != NO_ERROR) {
            szDesc = NULL;
        }
        else {
            szDesc = convStr.GetString(TRUE);
        }
					
		//check whether the szDesc is Denali/formatted error resource string or other unformatted string
		if (FALSE == FIsResStrFormatted(szDesc))
			{
			//unformatted string.
			pErrInfo->m_dwMask 	= dwDefaultMask;
			if (0 == excepinfo.wCode)
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.scode);
			else
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.wCode);
				
			pErrInfo->m_szItem[Im_szShortDescription] 	= StringDupA(szDesc);
			pErrInfo->m_szItem[Im_szLongDescription]	= NULL;
			}
		else
			{
			pErrInfo->ParseResourceString(szDesc);

			char *szTempErrorCode 		= SzScodeToErrorCode(excepinfo.scode);
			char *szTempErrorASPCode	= StringDupA(pErrInfo->m_szItem[Im_szErrorCode]);
			int nstrlen					= strlen(szTempErrorCode) + strlen(szTempErrorASPCode);
			
			pErrInfo->m_szItem[Im_szErrorCode] = new char[nstrlen+4];
			
			if(pErrInfo->m_szItem[Im_szErrorCode])			
				sprintf(pErrInfo->m_szItem[Im_szErrorCode], "%s : %s", szTempErrorASPCode, szTempErrorCode);

			if (szTempErrorCode)
				delete [] szTempErrorCode;
				
			if(szTempErrorASPCode)	
				delete [] szTempErrorASPCode;
			
			//pErrInfo->m_szItem[Im_szErrorCode] = StrDup(pErrInfo->m_szItem[Im_szErrorCode]);
			pErrInfo->m_szItem[Im_szShortDescription] 	= StringDupA(pErrInfo->m_szItem[Im_szShortDescription]);
			pErrInfo->m_szItem[Im_szLongDescription]	= StringDupA(pErrInfo->m_szItem[Im_szLongDescription]);
			}

		/*
		 * If we didnt guess a line, and we have a line of source code to display
		 * then attempt to display it and hopefully a line of ------^ to point to the error
		 */
		if (!fGuessedLine && bstrLine != NULL)
			{
			INT cchDBCS = 0;		// Number of DBCS characters in source line
			CHAR *pszTemp = NULL;	// Temp sz pointer used to calculate cchDBCS
			// convert the source code line

            if (FAILED(hr = convStr.Init(bstrLine))) {
                goto LExit;
            }
            szLine = convStr.GetString();
				
			cchLine = strlen(szLine);
			if (0 == cchLine)
				goto LExit;

			// Check for DBCS character, and cchLine -= NumberofDBCScharacter, such that
			// the ----^ will point to the right position.
			pszTemp = szLine;
			while(*pszTemp != NULL)
				{
					if (IsDBCSLeadByte(*pszTemp))
					{
						cchDBCS++;
						pszTemp += 2;	// skip 2 bytes
					}
					else
					{
						pszTemp++;		// single byte
					}
				}

			// compute the size of the source code indicator:
			// "<source line> + '\r\n' + <error pos>*'-' + '^'
			// 3 chars. without source line and '-'
			LONG ichErrorT = ichError;
			cchBuf += cchLine + ichErrorT + 3;

			// allocate the result buffer
			szResult = new(char[cchBuf + 2]);
			if (szResult == NULL)
				goto LExit;

			// fill up the buffer
			ch = szResult;

			// append the <PRE>
			// bug 87118, moved to template for a proper HTML encoding

			// <source line>
			if (cchLine)
				strncpy(ch, szLine, cchLine);
			ch += cchLine;

			// stick the "----^" string on the end
			if (ichErrorT > -1)
				{
				// prepend the '\n'
				strncpy(ch, "\r\n", 2);
				ch += 2;
				// put in the "---"'s, and shrink "---" by #ofDBCS
				ichErrorT -= cchDBCS;
				while (ichErrorT-- > 0)
					*ch++ = '-';

				*ch++ = '^';
				}

			// append the </PRE>
			// bug 87118, moved to template for a proper HTML encoding

			// terminate the string
			*ch++ = '\0';
			pErrInfo->m_szItem[Im_szCode] = szResult;

			// add line and column to error object
			pErrInfo->m_nColumn = ichError;
			pErrInfo->m_bstrLineText = bstrLine;
			}
		}
	else
		{
		// Not VBS or other Engine errors/Unknown error
		// Load Default
		// try to compute a specific error message
		HRESULT hr_def;
		hr_def = GetSpecificError(pErrInfo, excepinfo.scode);
		CHAR *szShortDescription = new CHAR[256];

		// if that failed try to compute a generic error
		if (FAILED(hr_def))
			{
			pErrInfo->m_dwMask							= dwDefaultMask;
			if (0 == excepinfo.wCode)
				{
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.scode);
				// Bug 91847 Attempt to get a description via FormatMessage()
				if ((szShortDescription != NULL) &&
					!HResultToSz(excepinfo.scode, szShortDescription, 256))
					{
					// Displaying the error number twice would be redundant, delete it
					delete [] szShortDescription;
					szShortDescription = NULL;
					}
				}
			else
				{
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.wCode);
				// Bug 91847 Attempt to get a description via FormatMessage()
				if ((szShortDescription != NULL) &&
					!HResultToSz(excepinfo.wCode, szShortDescription, 256))
					{
					// Displaying the error number twice would be redundant, delete it
					delete [] szShortDescription;
					szShortDescription = NULL;
					}
				}
			pErrInfo->m_szItem[Im_szEngine] 			= NULL;
			pErrInfo->m_szItem[Im_szShortDescription] 	= szShortDescription;
			pErrInfo->m_szItem[Im_szLongDescription]	= NULL;
			}
		}

LExit:
	if (excepinfo.bstrSource)
		{
		SysFreeString(excepinfo.bstrSource);
		}

	if (excepinfo.bstrDescription)
		{
		SysFreeString(excepinfo.bstrDescription);
		}

	if (excepinfo.bstrHelpFile)
		{
		SysFreeString(excepinfo.bstrHelpFile);
		}

	pErrInfo->LogError();

	if (bstrLine)
		{
		SysFreeString(bstrLine);
		}

	FreeNullifySz((CHAR **)&szDesc);

	for(INT iErrInfo = 0; iErrInfo < Im_szItemMAX; iErrInfo++)
		{
		FreeNullifySz((CHAR **)&pErrInfo->m_szItem[iErrInfo]);
		}
	
	return S_OK;
	}
	
/*===================================================================
LoadErrResString

Loads an error string(formatted) from the string table.

Returns:
		pdwMask
		szErrorCode
		szShortDes
		szLongDes

if any of the szVariable is NULL, that particular string value will not be loaded.

		S_OK	if successes.
		E_FAIL	if fails.
Side Effect
		NONE
===================================================================*/
HRESULT	LoadErrResString(
UINT ErrID/*IN*/,
DWORD *pdwMask,
CHAR *szErrorCode,
CHAR *szShortDes,
CHAR *szLongDes)
{
	CHAR 	*szToken 	= NULL;
	CHAR 	szResTemp[2*MAX_RESSTRINGSIZE];	//ResourceTempString
	INT		cch			= 0;

	cch = CchLoadStringOfId(ErrID, szResTemp, MAX_RESSTRINGSIZE);

	//Mask
	szToken = (char *)_mbstok((unsigned char *)szResTemp, (unsigned char *)DELIMITER);
	if (NULL != szToken)
		*pdwMask = atoi(szToken);
	else
		Assert(FALSE);

	//ErrorCode
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szErrorCode)
		{
		cch = strlen(szToken);
		memcpy(szErrorCode, szToken, cch);
		szErrorCode[cch] = '\0';
		}

	//ShortDescription
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szShortDes)
		{
		cch = strlen(szToken);
		memcpy(szShortDes, szToken, cch);
		szShortDes[cch] = '\0';
		}

	//LongDescription
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szLongDes)
		{
		cch = strlen(szToken);
		memcpy(szLongDes, szToken, cch);
		szLongDes[cch] = '\0';
		}

	return S_OK;
}

/*===================================================================
SzScodeToErrorCode

Conver Scode to string

Returns:
	Composed string

Side Effects:
	***ALLOCATES MEMORY -- CALLER MUST FREE***
===================================================================*/
CHAR *SzScodeToErrorCode
(
HRESULT hrError
)
	{
	CHAR *szResult = NULL;
	CHAR szBuf[17];
	CHAR *szNumber;
	CHAR *szError;
	INT iC;
	INT cch;
	
	// put a bunch of zeros into the buffer
	for (iC = 0; iC < 16; ++iC)
		szBuf[iC] = '0';

	// szNumber points half way into the buffer
	szNumber = &szBuf[8];

	// get the error szNumber as a hex string
	_ltoa(hrError, szNumber, 16);

	// back up szNumber to allow a total of 8 digits
	szNumber -= 8 - strlen(szNumber);

	cch = strlen(szNumber) + 1;

	szError = new(CHAR[cch]);
	if (szError != NULL)
		{
		szError[0] = '\0';
		strcat(szError, szNumber);
		szResult = szError;
		}
	else
		{
		HandleOOMError(NULL, NULL);
		}

	return(szResult);
	}

/*===================================================================
SzComposeSpecificError

Compose a specific error for an HRESULT of the form:
	<string> <error-number>

This is our last resort if there is not more useful information to be had.

Returns:
	Composed string

Side Effects:
	***ALLOCATES MEMORY -- CALLER MUST FREE***
===================================================================*/
HRESULT GetSpecificError
(
CErrInfo *pErrInfo,
HRESULT hrError
)
	{
	HRESULT hr_return = E_FAIL;
	UINT idErr;

	switch (hrError)
		{
		case DISP_E_MEMBERNOTFOUND:
			idErr = IDE_SCRIPT_METHOD_NOT_FOUND;
			break;

		case DISP_E_UNKNOWNNAME:
			idErr = IDE_SCRIPT_UNKNOWN_NAME;
			break;

		case DISP_E_UNKNOWNINTERFACE:
			idErr = IDE_SCRIPT_UNKNOWN_INTERFACE;
			break;

		case DISP_E_PARAMNOTOPTIONAL:
			idErr = IDE_SCRIPT_MISSING_PARAMETER;
			break;

		default:
			// Not one of the errors we know how to handle specially.  E_FAIL will be returned.
			idErr = 0;
			break;
		}

	// build a szResult string if we find a match
	if (idErr != 0)
		{
		hr_return = LoadErrResString(idErr,
									&(pErrInfo->m_dwMask),
									pErrInfo->m_szItem[Im_szErrorCode],
									pErrInfo->m_szItem[Im_szShortDescription],
									pErrInfo->m_szItem[Im_szLongDescription]
									);
		}

	return(hr_return);
	}

/*===================================================================
HResultToWsz

Tranlates a HRESULT to a description string of the HRESULT.  Attempts
to use FormatMessage() to get a

Parameters:
	hrIn	The error to lookup
	wszOut	String to output the description to
	cdwOut	Number of WCHARs wszOut can hold

Returns:
	TRUE if a description string was found
	FALSE if the error number was output instead

Notes:
	Added to resolve bug 91847.  When unexpected errors are processed
	the naked error number was output, which developers would then
	have to look up in winerror.h.
===================================================================*/
BOOL HResultToWsz(HRESULT hrIn, WCHAR *wszOut, DWORD cdwOut)
	{
	LANGID langID = LANG_NEUTRAL;
    DWORD   dwFound = 0;
    HMODULE  hMsgModule = NULL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

    if (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_INTERNET)
        hMsgModule = GetModuleHandleA("METADATA");
    else
        hMsgModule = GetModuleHandleA("ASP");

    dwFound = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    hMsgModule,
					    hrIn,
					    langID,
					    wszOut,
					    cdwOut,
					    NULL);


	if (!dwFound)
		{
		// Error not found, make a string out of the error number
		WCHAR *wszResult = NULL;
		WCHAR wszBuf[17];
		WCHAR *wszNumber;
		WCHAR *wszError;
		INT iC;
	
		// put a bunch of zeros into the buffer
		for (iC = 0; iC < 16; ++iC)
			wszBuf[iC] = L'0';

		// wszNumber points half way into the buffer
		wszNumber = &wszBuf[8];

		// get the error wszNumber as a hex string
		_ltow(hrIn, wszNumber, 16);

		// back up szNumber to allow a total of 8 digits
		wszNumber -= 8 - wcslen(wszNumber);

		// Copy the result to wszOut
		wcsncpy(wszOut, wszNumber, cdwOut);

		return FALSE;
		}
	else
		return TRUE;
	}

HMODULE GetModuleHandleForHRESULT(HRESULT  hrIn)
{
    char        szModuleName[MAX_PATH];
    DWORD       pathLen = 0;
    char       *pch;

    szModuleName[0] = '\0';

    if (g_fOOP) {

            strcat(szModuleName, "INETSRV\\");
    }

    if (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_INTERNET)
        strcat(szModuleName, "METADATA.DLL");
    else
        strcat(szModuleName, "ASP.DLL");

    return(LoadLibraryExA(szModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE));
}

/*===================================================================
HResultToSz

Tranlates a HRESULT to a description string of the HRESULT.  Attempts
to use FormatMessage() to get a

Parameters:
	hrIn	The error to lookup
	szOut	String to output the description to
	cdwOut	Number of WCHARs wszOut can hold

Returns:
	TRUE if a description string was found
	FALSE if the error number was output instead

Notes:
	Added to resolve bug 91847.  When unexpected errors are processed
	the naked error number was output, which developers would then
	have to look up in winerror.h.
===================================================================*/
BOOL HResultToSz(HRESULT hrIn, CHAR *szOut, DWORD cdwOut)
	{
	LANGID langID = LANG_NEUTRAL;
    HMODULE  hMsgModule = NULL;
    BOOL     bFound = FALSE;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

    hMsgModule = GetModuleHandleForHRESULT(hrIn);

    HRESULT hr = GetLastError();

    bFound = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    hMsgModule,
					    hrIn,
					    langID,
					    szOut,
					    cdwOut,
					    NULL);

    // make one additional check before giving up.  If the facility of the error is
    // WIN32, then retry the call after masking out the facility code to get standard
    // WIN32 errors. I.E. 80070005 is really just 5 - access denied

    if (!bFound && (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_WIN32)) {

        bFound = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    NULL,
					    hrIn & 0xffff,
					    langID,
					    szOut,
					    cdwOut,
					    NULL);
    }

    if (hMsgModule)
        FreeLibrary(hMsgModule);

	if (!bFound )
		{
		// Error not found, make a string out of the error number
		CHAR *szResult = NULL;
		CHAR szBuf[17];
		CHAR *szNumber;
		CHAR *szError;
		INT iC;
	
		// put a bunch of zeros into the buffer
		for (iC = 0; iC < 16; ++iC)
			szBuf[iC] = L'0';

		// wszNumber points half way into the buffer
		szNumber = &szBuf[8];

		// get the error wszNumber as a hex string
		_ltoa(hrIn, szNumber, 16);

		// back up szNumber to allow a total of 8 digits
		szNumber -= 8 - strlen(szNumber);

		// Copy the result to wszOut
		strncpy(szOut, szNumber, cdwOut);

		return FALSE;
		}
	else
		return TRUE;
	}

/*===================================================================
FIsResStrFormatted

Check for formatted resource string.

RETURN:
	TRUE/FALSE
===================================================================*/
BOOL FIsResStrFormatted(char *szIn)
{
	BOOL  freturn = FALSE;
	UINT  cDelimiter = 0;
	CHAR  *pch;

	if(szIn)
		{
			pch = szIn;
			while(*pch)
			{
			if ('~' == *pch)
				cDelimiter++;
			pch = CharNextA(pch);
			}

			if(3 == cDelimiter)
				return TRUE;
		}
	return freturn;
	
}

/*===================================================================
HandleErrorMissingFilename

In several circumstances we want to report an error, but
we have no filename, and the normal method for getting
the filename from the template wont work because we have
no line number info either (e.g. Script timeout, GPF, control GPF, etc)

Get the filename from the CIsapiReqInfo (if possible) and report the error.

Returns:
	Nothing
===================================================================*/
VOID HandleErrorMissingFilename
(
UINT errorID,
CHitObj *pHitObj,
BOOL    fAddlInfo /* = FALSE */,
...
)
	{
    va_list args;

    if (fAddlInfo)
        va_start(args, fAddlInfo);

	CHAR *szFileName = NULL;

	if (pHitObj && pHitObj->PSzCurrTemplateVirtPath())
		{
#if UNICODE
        szFileName = StringDupUTF8(pHitObj->PSzCurrTemplateVirtPath());
#else
   		szFileName = StringDupA(pHitObj->PSzCurrTemplateVirtPath());
#endif
		}
		
	char szEngine[64];
	CchLoadStringOfId(IDS_ENGINE, szEngine, sizeof szEngine);

	char *pszEngine = new char [strlen(szEngine) + 1];
	if (pszEngine)
		{
		// If the alloc failed, we will pass NULL to HandleError for pszEngine, which is fine.
		// (old code used to pass NULL)  All that will happen is that the AspError.Category == "". Oh Well.
		// TODO: change this function to return an HRESULT.
		//
		strcpy(pszEngine, szEngine);
		}

	HandleError(errorID, szFileName, NULL, pszEngine, NULL, NULL, NULL, pHitObj, fAddlInfo ? &args : NULL);
	}

/*===================================================================
DebugError

Handle a script error by invoking the debugger.

Returns:
	fails if debugger cannot be invoked.
	If this function fails, no other action is taken.
	  (Therefore, the caller should make sure error is reported in
	   some other way)
===================================================================*/
HRESULT DebugError(IActiveScriptError *pScriptError, CTemplate *pTemplate, DWORD dwEngineID, IDebugApplication *pDebugApp)
	{
	EXCEPINFO excepinfo = {0};
	BSTR bstrLine = NULL;
	DWORD dwSourceContext = 0;
	ULONG ulLineError = 0;
	ULONG ichLineError = 0;			// character offset of the line in the source
	ULONG cchLineError = 0;			// length of the source line
	BOOLB fGuessedLine = FALSE;		// see bug 379
	LPTSTR szPathInfo = NULL;
	LPTSTR szPathTranslated = NULL;
	LONG ichError = -1;
	HRESULT hr = S_OK;
	IDebugDocumentContext *pDebugContext = NULL;
	wchar_t *wszErrNum, *wszShortDesc, *wszLongDesc;	// Used to tokenize resource strings
	
	if (pScriptError == NULL || pTemplate == NULL || pDebugApp == NULL)
		return E_POINTER;

	if (FAILED(pScriptError->GetSourcePosition(&dwSourceContext, &ulLineError, &ichError)))
		return E_FAIL;

	if (FAILED(pScriptError->GetExceptionInfo(&excepinfo)))
		return E_FAIL;

	// call template object to get line number and character offset where error occurred
	// (It returns both - caller discards whichever it does not want)
	// bug 379: if pTemplate returns fGuessedLine == TRUE, it means we gave it a non-authored
	// line, so we adjust below by not printing bstrLine in the error msg
	pTemplate->GetScriptSourceInfo(dwEngineID, ulLineError, &szPathInfo, &szPathTranslated, NULL, &ichLineError, NULL);

	// Create a new document context for this statement
	// CONSIDER: character count that we return is bogus - however our debugging
	//           client (Caesar's) does not use this information anyway.
	//
	// If this is in the main file, create a document context based on the CTemplate compiled source
	if (_tcscmp(szPathTranslated, pTemplate->GetSourceFileName()) == 0)
		pDebugContext = new CTemplateDocumentContext(pTemplate, ichLineError, 1);

	// source refers to an include file, so create a documet context based on cached CIncFile dependency graph
	else
		{
		CIncFile *pIncFile;
		if (FAILED(g_IncFileMap.GetIncFile(szPathTranslated, &pIncFile)))
			{
			hr = E_FAIL;
			goto LExit;
			}

		pDebugContext = new CIncFileDocumentContext(pIncFile, ichLineError, 1);
		pIncFile->Release();
		}

	if (pDebugContext == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto LExit;
		}

	// Yes it does, bring up the debugger on this line
    hr =  InvokeDebuggerWithThreadSwitch
        (
        pDebugApp,
        DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP,
        pDebugContext
        );
	if (FAILED(hr))
		goto LExit;
	

	// pop up a message box with the error description
	// Bug 81954: Misbehaved objects may throw an exception without providing any information
	wchar_t wszExceptionBuffer[256];
	wchar_t *wszDescription;
	if (excepinfo.bstrDescription == NULL || excepinfo.bstrDescription[0] == L'\0')
		{
		HRESULT hrError;

		if (0 == excepinfo.wCode)
			hrError = excepinfo.scode;
		else
			hrError = excepinfo.wCode;

		// Bug 91847 Attempt to get a description via FormatMessage()
		if (!HResultToWsz(hrError, wszExceptionBuffer, 128))
			CwchLoadStringOfId(IDE_SCRIPT_UNKNOWN, wszExceptionBuffer, sizeof(wszExceptionBuffer)/sizeof(WCHAR));
		wszDescription = wszExceptionBuffer;
		}
	else
		wszDescription = excepinfo.bstrDescription;

	wchar_t wszSource[35];
	CwchLoadStringOfId(IDS_SCRIPT_ERROR, wszSource, sizeof(wszSource)/sizeof(WCHAR));

	// See if this is resource formatted string, and if it is, get pointers to short & long string
	// resource formatted strings are delimited by '~' characters  There are three '~' characters
	// in the resource formatted string
	//
	wszErrNum = wcschr(wszDescription, L'~');
	if (wszErrNum)
		{
		wszShortDesc = wcschr(wszErrNum + 1, L'~');
		if (wszShortDesc)
			{
			wszLongDesc = wcschr(wszShortDesc + 1, L'~');

			// OK. If all three tests succeeded, we know this is a resource formatted string,
			// and we have pointers to all three segments. Replace each '~' with two newlines.
			// First: Load resource strings

			wchar_t wszErrorBegin[20], wszErrorEnd[5];
			wchar_t *pwchEnd;

			CwchLoadStringOfId(IDS_DEBUGGER_TEMPLATE_BEGIN, wszErrorBegin, sizeof(wszErrorBegin)/sizeof(WCHAR));
			CwchLoadStringOfId(IDS_DEBUGGER_TEMPLATE_END, wszErrorEnd, sizeof(wszErrorEnd)/sizeof(WCHAR));

			// Tokenize string by setting '~' characters to NULL and incrementing ptrs

			*wszErrNum++ = *wszShortDesc++ = *wszLongDesc++ = L'\0';

			// Build the string

			pwchEnd = strcpyExW(wszExceptionBuffer, excepinfo.bstrSource);
			*pwchEnd++ = L' ';
			pwchEnd = strcpyExW(pwchEnd, wszErrorBegin);
			pwchEnd = strcpyExW(pwchEnd, wszErrNum);
			pwchEnd = strcpyExW(pwchEnd, wszErrorEnd);
			*pwchEnd++ = L'\n';
			*pwchEnd++ = L'\n';

			pwchEnd = strcpyExW(pwchEnd, wszShortDesc);
			*pwchEnd++ = L'\n';
			*pwchEnd++ = L'\n';

			pwchEnd = strcpyExW(pwchEnd, wszLongDesc);

			wszDescription = wszExceptionBuffer;
			}
		}

	MessageBoxW(NULL, wszDescription, wszSource, MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONEXCLAMATION);

LExit:
	if (pDebugContext)
		pDebugContext->Release();

	if (excepinfo.bstrSource)
		SysFreeString(excepinfo.bstrSource);

	if (excepinfo.bstrDescription)
		SysFreeString(excepinfo.bstrDescription);

	if (excepinfo.bstrHelpFile)
		SysFreeString(excepinfo.bstrHelpFile);

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\gip.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.cpp

Owner: DmitryR

This is the GIP source file.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "gip.h"
#include "memchk.h"

/*===================================================================
  Globals
===================================================================*/

CGlobalInterfaceAPI g_GIPAPI;

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

/*===================================================================
CGlobalInterfaceAPI::CGlobalInterfaceAPI

CGlobalInterfaceAPI constructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::CGlobalInterfaceAPI() 
    : m_fInited(FALSE), m_pGIT(NULL)
    {
    }
    
/*===================================================================
CGlobalInterfaceAPI::~CGlobalInterfaceAPI

CGlobalInterfaceAPI destructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::~CGlobalInterfaceAPI()
    {
    UnInit();
    }

/*===================================================================
CGlobalInterfaceAPI::Init

Creates instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CGlobalInterfaceAPI::Init()
    {
    Assert(!m_fInited); // don't init twice
    
    HRESULT hr = CoCreateInstance
        (
        CLSID_StdGlobalInterfaceTable,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,
        (void **)&m_pGIT
        );
        
    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        m_pGIT = NULL;

    return hr;
    }

/*===================================================================
CGlobalInterfaceAPI::UnInit

Releases instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT (S_OK)
===================================================================*/	
HRESULT CGlobalInterfaceAPI::UnInit()
    {
    if (m_pGIT)
        {
        m_pGIT->Release();
        m_pGIT = NULL;
        }

    m_fInited = FALSE;
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\eventlog.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT Event logging

File: Eventlog.cpp

Owner: Jhittle

This file contains general event logging routines for Denali.
===================================================================*/

#include "denpre.h"
#pragma hdrstop
#include <direct.h>
#include <iismsg.h>
#include "memchk.h"

extern HINSTANCE g_hinstDLL;
extern CRITICAL_SECTION g_csEventlogLock;

/*===================================================================
STDAPI  UnRegisterEventLog( void )

UnRegister the event log.

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Removes denali NT eventlog entries from the registry
===================================================================*/
STDAPI UnRegisterEventLog( void )
	{
	HKEY		hkey = NULL;
	DWORD		iKey;
	CHAR		szKeyName[255];
	DWORD		cbKeyName;
	static const char szDenaliKey[] = "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Active Server Pages";	

	// Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
	if	(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szDenaliKey, 0, KEY_READ | KEY_WRITE, &hkey) != ERROR_SUCCESS)
		goto LErrExit;

	// Enumerate all its subkeys, and delete them
	for (iKey=0;;iKey++)
		{
		cbKeyName = sizeof(szKeyName);
		if (RegEnumKeyExA(hkey, iKey, szKeyName, &cbKeyName, 0, NULL, 0, NULL) != ERROR_SUCCESS)
			break;

		if (RegDeleteKeyA(hkey, szKeyName) != ERROR_SUCCESS)
			goto LErrExit;
		}

	// Close the key, and then delete it
	if (RegCloseKey(hkey) != ERROR_SUCCESS)
		return E_FAIL;
			
	if (RegDeleteKeyA(HKEY_LOCAL_MACHINE, szDenaliKey) != ERROR_SUCCESS)
		return E_FAIL;

	return S_OK;

LErrExit:
	RegCloseKey(hkey);
	return E_FAIL;
	}

/*===================================================================
STDAPI  RegisterEventLog(void)

Register the NT event log.

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Sets up denali dll in the Eventlog registry for resolution of
	NT eventlog message strings
===================================================================*/
STDAPI RegisterEventLog( void )
	{

	HKEY	hk;                      // registry key handle
	DWORD	dwData;					
	BOOL	bSuccess;
	//char	szMsgDLL[MAX_PATH];	

	char    szPath[MAX_PATH];
	char    *pch;

	// Get the path and name of Denali
	if (!GetModuleFileNameA(g_hinstDLL, szPath, sizeof(szPath)/sizeof(char)))
		return E_FAIL;
		
	// BUG FIX: 102010 DBCS code changes
	//
	//for (pch = szPath + lstrlen(szPath); pch > szPath && *pch != TEXT('\\'); pch--)
	//	;
	//	
	//if (pch == szPath)
	//	return E_FAIL;

	pch = (char*) _mbsrchr((const unsigned char*)szPath, '\\');
	if (pch == NULL)	
		return E_FAIL;
		
		
	strcpy(pch + 1, IIS_RESOURCE_DLL_NAME_A);
	
  	
	// When an application uses the RegisterEventSource or OpenEventLog
	// function to get a handle of an event log, the event loggging service
	// searches for the specified source name in the registry. You can add a
	// new source name to the registry by opening a new registry subkey
	// under the Application key and adding registry values to the new
	// subkey.

	// Create a new key for our application
	bSuccess = RegCreateKeyA(HKEY_LOCAL_MACHINE,
		"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Active Server Pages", &hk);

	if(bSuccess != ERROR_SUCCESS)
		return E_FAIL;

	// Add the Event-ID message-file name to the subkey.
	bSuccess = RegSetValueExA(hk,  	// subkey handle
		"EventMessageFile",       	// value name
		0,                        	// must be zero
		REG_EXPAND_SZ,            	// value type
		(LPBYTE) szPath,        	// address of value data
		strlen(szPath) + 1);   		// length of value data
		
	if(bSuccess != ERROR_SUCCESS)
		goto LT_ERROR;
	

	// Set the supported types flags and addit to the subkey.
	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
	bSuccess = RegSetValueExA(hk,	// subkey handle
		"TypesSupported",         	// value name
		0,                        	// must be zero
		REG_DWORD,                	// value type
		(LPBYTE) &dwData,         	// address of value data
		sizeof(DWORD));           	// length of value data

	if(bSuccess != ERROR_SUCCESS)
		goto LT_ERROR;

	RegCloseKey(hk);	
	return S_OK;

	LT_ERROR:

	RegCloseKey(hk);	
	return E_FAIL;
	}

/*===================================================================
STDAPI  ReportAnEvent

Register report an event to the NT event log

INPUT:
	the event ID to report in the log, the number of insert
    strings, and an array of null-terminated insert strings

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
STDAPI ReportAnEvent(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCSTR  *pszStrings,
                     DWORD dwBinDataSize, LPVOID pData)
	{
  	HANDLE	hAppLog;
  	BOOL	bSuccess;
  	HRESULT hr = S_OK;

  	
    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

  	// Get a handle to the Application event log
  	hAppLog = RegisterEventSourceA(NULL,   		// use local machine
    	  "Active Server Pages");                   	// source name

    if(hAppLog == NULL) {
		hr = E_FAIL;
        goto LExit;
    }

	  // Now report the event, which will add this event to the event log
	bSuccess = ReportEventA(hAppLog,        		// event-log handle
    	wEventlog_Type,				    		// event type
      	0,		                       			// category zero
      	dwIdEvent,		              			// event ID
      	NULL,					     			// no user SID
      	cStrings,								// number of substitution strings
	  	dwBinDataSize,             				// binary data
      	pszStrings,                				// string array
      	dwBinDataSize ? pData : NULL);			// address of data

	if(!bSuccess)
		hr = E_FAIL;
		
	DeregisterEventSource(hAppLog);

LExit:

    AspUndoRevertHack( &hCurrentUser );

  	return hr;
	}
/*===================================================================
STDAPI  ReportAnEvent

Register report an event to the NT event log

INPUT:
	the event ID to report in the log, the number of insert
    strings, and an array of null-terminated insert strings

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
STDAPI ReportAnEventW(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCWSTR  *pszStrings)
	{
  	HANDLE	hAppLog;
  	BOOL	bSuccess;
  	HRESULT hr = S_OK;

  	
    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

  	// Get a handle to the Application event log
  	hAppLog = RegisterEventSourceW(NULL,   		// use local machine
    	  L"Active Server Pages");                   	// source name

    if(hAppLog == NULL) {
		hr = E_FAIL;
        goto LExit;
    }

	  // Now report the event, which will add this event to the event log
	bSuccess = ReportEventW(hAppLog,        		// event-log handle
    	wEventlog_Type,				    		// event type
      	0,		                       			// category zero
      	dwIdEvent,		              			// event ID
      	NULL,					     			// no user SID
      	cStrings,								// number of substitution strings
	  	0,	                       				// no binary data
      	pszStrings,                				// string array
      	NULL);                     				// address of data

	if(!bSuccess)
		hr = E_FAIL;
		
	DeregisterEventSource(hAppLog);

LExit:

    AspUndoRevertHack( &hCurrentUser );

  	return hr;
	}

/*===================================================================
void MSG_Error

report an event to the NT event log

INPUT:
	ptr to null-terminated string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( LPCSTR strSource )
	{
    static char	szLastError[MAX_MSG_LENGTH] = {0};

	EnterCriticalSection(&g_csEventlogLock);
	if (strcmp(strSource, szLastError) == 0)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
		
	strncpy(szLastError,strSource, MAX_MSG_LENGTH);
	szLastError[MAX_MSG_LENGTH-1] = '\0';
	LeaveCriticalSection(&g_csEventlogLock);
	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_1, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 1, &strSource /*aInsertStrs*/ );  	
	}

/*===================================================================
void MSG_Error

report an event to the NT event log

INPUT:
	string table string ID
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1 )
	{
	static unsigned int nLastSourceID1 = 0;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
	nLastSourceID1 = SourceID1;
	LeaveCriticalSection(&g_csEventlogLock);
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char	*aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
	cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_1, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 1, (LPCSTR *) aInsertStrs );  	
	return;
	}


/*===================================================================
void MSG_Error

report an event to the NT event log

INPUT:
	string table string ID
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, PCSTR pszSource2, UINT SourceID3, DWORD dwData )
{
	static unsigned int nLastSourceID1 = 0;
    static char	szLastSource2[MAX_MSG_LENGTH] = {0};
	static unsigned int nLastSourceID3 = 0;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if ((SourceID1 == nLastSourceID1) &&
        (strcmp(pszSource2, szLastSource2) == 0) &&
        (SourceID3 == nLastSourceID3))
	{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
	}
	nLastSourceID1 = SourceID1;
	strncpy(szLastSource2,pszSource2, MAX_MSG_LENGTH);
	szLastSource2[MAX_MSG_LENGTH-1] = '\0';
	nLastSourceID3 = SourceID3;
	LeaveCriticalSection(&g_csEventlogLock);
	
    // load the strings
	DWORD	cch;
	char	strSource1[MAX_MSG_LENGTH];
	cch = CchLoadStringOfId(SourceID1, strSource1, MAX_MSG_LENGTH);
	Assert(cch > 0);
	char	strSource3[MAX_MSG_LENGTH];
	cch = CchLoadStringOfId(SourceID3, strSource3, MAX_MSG_LENGTH);
	Assert(cch > 0);

    // construct the msg
	char	strSource[MAX_MSG_LENGTH];
	char	*aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    WORD    numStrs = 1;
	aInsertStrs[0] = (char*) strSource;
    if (_snprintf(strSource, MAX_MSG_LENGTH, strSource1, pszSource2, strSource3) <= 0)
    {
        // the string is too long. this should never happen, and we have the assert here,
        // but if we got to this point in production, at least we get an unformated log entry
        Assert(0);
        numStrs = 3;
        aInsertStrs[0] = strSource1;
        aInsertStrs[1] = (char*)pszSource2;
        aInsertStrs[2] = strSource3;
    }
    strSource[MAX_MSG_LENGTH-1] = '\0';

	ReportAnEvent( (DWORD) (numStrs == 1 ? MSG_DENALI_ERROR_1 : MSG_DENALI_ERROR_3),
                   (WORD) EVENTLOG_ERROR_TYPE,
                   numStrs,
                   (LPCSTR *) aInsertStrs,
                   dwData ? sizeof(dwData) : 0,
                   dwData ? &dwData : NULL );
	return;
}


/*===================================================================
void MSG_Error

report an event to the NT event log

INPUT:
	two part message of string table string ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2 )
	{
	static unsigned int nLastSourceID1 = 0;
	static unsigned int nLastSourceID2 = 0;

	// if this is a repeat of the last reported message then return
	// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
		
	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	LeaveCriticalSection(&g_csEventlogLock);
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[1] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_2, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 2, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Error

report an event to the NT event log

INPUT:
	three part message string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2, UINT SourceID3 )
	{
	static unsigned int nLastSourceID1 = 0;
	static unsigned int nLastSourceID2 = 0;
	static unsigned int nLastSourceID3 = 0;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	LeaveCriticalSection(&g_csEventlogLock);

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[1] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[2] = (char*) strSource;                                     	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_3, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 3, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Error

report an event to the NT event log

INPUT:
	four String table ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )
	{
	static unsigned int nLastSourceID1 = 0;
	static unsigned int nLastSourceID2 = 0;
	static unsigned int nLastSourceID3 = 0;
	static unsigned int nLastSourceID4 = 0;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3 && SourceID4 == nLastSourceID4)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	nLastSourceID4 = SourceID4;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[1] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[2] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID4, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[3] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_4, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 4, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Error

report an event to the NT event log

INPUT:
    ErrId - ID of error description in Message File
    cItem - count of strings in szItems array
    szItems - array of string points
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( DWORD ErrId, LPCWSTR pwszItem )
{
	static unsigned int LastErrId = 0;
   	static WCHAR	szLastStr[MAX_MSG_LENGTH] = {0};

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if ((ErrId == LastErrId) && !wcscmp(szLastStr, pwszItem))
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	LastErrId = ErrId;
    wcsncpy(szLastStr, pwszItem, MAX_MSG_LENGTH);
    szLastStr[MAX_MSG_LENGTH-1] = L'\0';
	LeaveCriticalSection(&g_csEventlogLock);
	
	ReportAnEventW( ErrId, (WORD) EVENTLOG_ERROR_TYPE, 1, &pwszItem );
}

/*===================================================================
void MSG_Warning

report an event to the NT event log

INPUT:
	ptr to null-terminated string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( LPCSTR strSource )
{
    static char	szLastError[MAX_MSG_LENGTH] = {0};

	EnterCriticalSection(&g_csEventlogLock);
	if (strcmp(strSource, szLastError) == 0)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
	szLastError[0] = '\0';
	strncat(szLastError,strSource, MAX_MSG_LENGTH-1);
	LeaveCriticalSection(&g_csEventlogLock);

		ReportAnEvent( (DWORD) MSG_DENALI_WARNING_1, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 1, &strSource /*aInsertStrs*/ );
}
/*===================================================================
void MSG_Warning

report an event to the NT event log

INPUT:
	String table message ID
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1 )
	{

	static unsigned int nLastSourceID1 = 0;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	LeaveCriticalSection(&g_csEventlogLock);	
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];	
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_1, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 1, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Warning

report an event to the NT event log

INPUT:
	two string tabel message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2 )
	{
	static unsigned int nLastSourceID1 = 0;
	static unsigned int nLastSourceID2 = 0;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[1] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_2, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 2, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Warning

report an event to the NT event log

INPUT:
	three string table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3)
	{

	static unsigned int nLastSourceID1 = 0;
	static unsigned int nLastSourceID2 = 0;
	static unsigned int nLastSourceID3 = 0;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[1] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[2] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_3, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 3, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Warning

report an event to the NT event log

INPUT:
	four String table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )
	{

	static unsigned int nLastSourceID1 = 0;
	static unsigned int nLastSourceID2 = 0;
	static unsigned int nLastSourceID3 = 0;
	static unsigned int nLastSourceID4 = 0;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3 && SourceID4 == nLastSourceID4)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	nLastSourceID4 = SourceID4;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[1] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[2] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID4, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);
	aInsertStrs[3] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_4, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 4, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Warning

report an event to the NT event log

INPUT:
    ErrId - ID of error description in Message File
	pwszI1
    pwszI2

Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( DWORD ErrId, LPCWSTR pwszI1, LPCWSTR pwszI2 )
{
	static unsigned int LastErrId = 0;
   	static WCHAR	szLastStr1[MAX_MSG_LENGTH] = {0};
   	static WCHAR	szLastStr2[MAX_MSG_LENGTH] = {0};

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if ((ErrId == LastErrId) && !wcscmp(szLastStr1, pwszI1) && !wcscmp(szLastStr2, pwszI2))
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	LastErrId = ErrId;
    wcsncpy(szLastStr1, pwszI1, MAX_MSG_LENGTH);
    szLastStr1[MAX_MSG_LENGTH-1] = L'\0';
    wcsncpy(szLastStr2, pwszI2, MAX_MSG_LENGTH);
    szLastStr2[MAX_MSG_LENGTH-1] = L'\0';
	LeaveCriticalSection(&g_csEventlogLock);
	
	LPCWSTR aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    aInsertStrs[0] = szLastStr1;
    aInsertStrs[1] = szLastStr2;
	ReportAnEventW( ErrId, (WORD) EVENTLOG_ERROR_TYPE, 2, aInsertStrs );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\fileapp.cpp ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: File/Application map

File: CFileApp.cpp

Owner: cgrant

File/Application mapping implementation
-----------------------------------------------------------------------------*/

#include "denpre.h"
#pragma hdrstop

#include "dbgutil.h"
#include "memchk.h"

CFileApplicationMap g_FileAppMap;

/*===================================================================
CFileApplnList::CFileApplnList

Constructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplnList::CFileApplnList() :
    m_pszFilename(NULL),
    m_fInited(FALSE)
{

}


/*===================================================================
CFileApplnList::~CFileApplnList

Destructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplnList::~CFileApplnList()
{
    // We should have no applications in our list
    DBG_ASSERT(m_rgpvApplications.Count() == 0);

    // Free the string used as the hash key
    if (m_pszFilename)
    {
        delete [] m_pszFilename;
        m_pszFilename = NULL;
    }
}

/*===================================================================
CFileApplnList::Init

Initialize the file application list by setting the key to file name

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplnList::Init(const TCHAR* pszFilename)
{
    HRESULT hr = S_OK;

    DBG_ASSERT(pszFilename);

    // Make a copy of the file name to 
    // use as the hash key
    DWORD cch = _tcslen(pszFilename);
    m_pszFilename = new TCHAR[cch+1];
    if (!m_pszFilename)
    {
        return E_OUTOFMEMORY;
    }
    _tcscpy(m_pszFilename, pszFilename);

    if (FAILED(CLinkElem::Init(m_pszFilename, cch*sizeof(TCHAR))))
    {
        return E_FAIL;
    }

    m_fInited = TRUE;
    return hr;
}

/*===================================================================
CFileApplnList::UnInit

Clean up the application list

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplnList::UnInit(void)
{
    HRESULT hr = S_OK;

    DBG_ASSERT(m_fInited);
    
    while(m_rgpvApplications.Count())
    {
        CAppln* pAppln = static_cast<CAppln *>(m_rgpvApplications[0]);

        DBG_ASSERT(pAppln);

        // Remove this appliation from the array
        m_rgpvApplications.Remove(pAppln);

        // Release the array's refcount on the application
        // This may result in the application being deleted
        pAppln->Release();
    }

    m_rgpvApplications.Clear();
    m_fInited = FALSE;
    return hr;
}


/*===================================================================
CFileApplnList::AddApplication

Add an application pointer to the list of applications

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful

Comments

    The caller should hold a lock on the hash table containing
    the element    
===================================================================*/	
HRESULT CFileApplnList::AddApplication(void *pApplication)
{
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pApplication);
    
    HRESULT hr = S_OK;
    int index;
    
    // See if the application is alreay in the list
    hr = m_rgpvApplications.Find(pApplication, &index);
    if (hr == S_FALSE)
    {
       // Not found, add it.
       
       // We are going to hold a reference to the application
       static_cast<CAppln *>(pApplication)->AddRef();

       // Add the application to the list
       if (FAILED(hr = m_rgpvApplications.Append(pApplication)))
       {
            // We failed so give back the refcount we took.
            static_cast<CAppln *>(pApplication)->Release();
       }
    }
    return hr;
}

/*===================================================================
CFileApplnList::RemoveApplication

Removes an application pointer from the list of applications

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful

Comments

    The caller should hold a lock on the hash table containing
    the element
===================================================================*/	
HRESULT CFileApplnList::RemoveApplication(void *pApplication)
{
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pApplication);
    
    HRESULT hr = S_OK;
    int index;

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Removing Application entry for %S\n", reinterpret_cast<CAppln *>(pApplication)->GetApplnPath()));
#else
    DBGPRINTF((DBG_CONTEXT, "Removing Application entry for %s\n", reinterpret_cast<CAppln *>(pApplication)->GetApplnPath()));
#endif
#endif // DBG_NOTIFICATION

    // Remove the application from the list
    hr = m_rgpvApplications.Remove(pApplication);

    // If the count of applications in the list goes
    // to 0, remove the element from the hash table 
    // and delete it
    if (m_rgpvApplications.Count() == 0)
    {
#ifdef DBG_NOTIFICATION
#if UNICODE
        DBGPRINTF((DBG_CONTEXT, "Deleting File/Application entry for %s\n", m_pszFilename));
#else
        DBGPRINTF((DBG_CONTEXT, "Deleting File/Application entry for %s\n", m_pszFilename));
#endif
#endif // DBG_NOTIFICATION
        g_FileAppMap.RemoveElem(this);
        delete this;
    }

    // If we found the application to remove it
    // we need to release a ref count on the application
    if (hr == S_OK)
    {
        static_cast<CAppln *>(pApplication)->Release();
    }

    return hr;
}

/*===================================================================
CFileApplnList::GetShutdownApplications

Obtain a list of applications to shut down

Parameters:
    None

===================================================================*/	
VOID CFileApplnList::GetShutdownApplications(CPtrArray *prgpapplnRestartList)
{
    DBG_ASSERT(m_fInited);

    HRESULT hr = S_OK;

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CFileApplnList] Shutting down %d applications depending on %S.\n", m_rgpvApplications.Count(), m_pszFilename));
#else
    DBGPRINTF((DBG_CONTEXT, "[CFileApplnList] Shutting down %d applications depending on %s.\n", m_rgpvApplications.Count(), m_pszFilename));
#endif
#endif // DBG_NOTIFICATION
    
    for  (int i = m_rgpvApplications.Count() - 1; i >= 0; i--)
    {
        CAppln* pAppln = static_cast<CAppln *>(m_rgpvApplications[i]);
        DBG_ASSERT(pAppln);
        
        // If not already tombstoned, shut the application down.
        // When the application is uninited it will remove itself
        // from this list
        if (!pAppln->FTombstone())
        {
            pAppln->AddRef();
            prgpapplnRestartList->Append(pAppln);
        }
    }
}

/*===================================================================
CFileApplicationMap::CFileApplicationMap

Constructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplicationMap::CFileApplicationMap()
    : m_fInited(FALSE),
      m_fHashTableInited(FALSE), 
      m_fCriticalSectionInited(FALSE)
{
}

/*===================================================================
CFileApplicationMap::~CFileApplicationMap

Destructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplicationMap::~CFileApplicationMap()
{
    if (m_fInited)
    {
        UnInit();
    }
}

/*===================================================================
CFileApplicationMap::Init

Initialize the hash table and critical section

Parameters:
    None
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::Init()
{
    HRESULT hr = S_OK;
    
    Assert(!m_fInited);

    hr = CHashTable::Init(NUM_FILEAPP_HASHING_BUCKETS);
    if (FAILED(hr))
    {
        return hr;
    }
    m_fHashTableInited = TRUE;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
    {
        return(hr);
    }
    m_fCriticalSectionInited = TRUE;

    m_fInited = TRUE;
    return S_OK;
}

/*===================================================================
CFileApplicationMap::UnInit

Uninitialize the hash table and critical section
Free any applications lists remaining in the hash
table elements

Parameters:
    None
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::UnInit()
{
    if (m_fHashTableInited)
    {
        // Delete any elements remaining in the hash table
        
        CFileApplnList *pNukeElem = static_cast<CFileApplnList *>(Head());

        while (pNukeElem != NULL)
        {
            CFileApplnList *pNext = static_cast<CFileApplnList *>(pNukeElem->m_pNext);
            pNukeElem->UnInit();
            delete pNukeElem;
            pNukeElem = pNext;
        }

        // Uninit the hash table
        CHashTable::UnInit();
        m_fHashTableInited = FALSE;
    }

    if (m_fCriticalSectionInited)
    {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
    }
        
    m_fInited = FALSE;
    return S_OK;
}

/*===================================================================
CFileApplicationMap::AddFileApplication

Add a file-application pair to the hash table

Parameters:
    pszFilename     pointer to string containing name of the file
    pAppln          pointer to the application associated with the file
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::AddFileApplication(const TCHAR* pszFilename, CAppln* pAppln)
{
    // We must have both a file and an application
    DBG_ASSERT(pszFilename);
    DBG_ASSERT(pAppln);

    HRESULT hr = S_OK;
    
    Lock();

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Adding File/Application entry for %S\n", pszFilename));
#else
    DBGPRINTF((DBG_CONTEXT, "Adding File/Application entry for %s\n", pszFilename));
#endif
#endif // DBG_NOTIFICATION
    
    // See if the file already has an entry
    CFileApplnList* pFileApplns = static_cast<CFileApplnList *>(CHashTable::FindElem(pszFilename, _tcslen(pszFilename)*sizeof(TCHAR)));
    i